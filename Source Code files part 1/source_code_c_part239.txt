ee(tree, needReg);  
    assert(tree->gtFlags & GTF_REG_VAL);

    regNumber       reg = tree->gtRegNum;
    regNumber       rg2;

    /* Did the value end up in an acceptable register? */

    if  ((mustReg == EXACT_REG) && needReg && !(genRegMask(reg) & needReg))
    {
        /* Not good enough to satisfy the caller's orders */

        rg2 = rsGrabReg(needReg);
    }
    else
    {
        /* Do we have to end up with a free register? */

        if  (!freeOnly)
            goto REG_OK;

        /* Did we luck out and the value got computed into an unused reg? */

        if  (genRegMask(reg) & rsRegMaskFree())
            goto REG_OK;

        /* Register already in use, so spill previous value */

        if ((mustReg == EXACT_REG) && needReg && (genRegMask(reg) & needReg))
        {
            rg2 = rsGrabReg(needReg);
            if (rg2 == reg)
            {
                gcMarkRegPtrVal(reg, tree->TypeGet());
                tree->gtRegNum = reg;
                goto REG_OK;
            }
        }
        else
        {
            /* OK, let's find a trashable home for the value */

            regMaskTP   rv1RegUsed;

            rsLockReg  (genRegMask(reg), &rv1RegUsed);
            rg2 = rsPickReg(needReg);
            rsUnlockReg(genRegMask(reg),  rv1RegUsed);
        }
    }

    assert(reg != rg2);

    /* Update the value in the target register */

    rsTrackRegCopy(rg2, reg);

#if TGT_x86

    inst_RV_RV(INS_mov, rg2, reg, tree->TypeGet());

#else

    genEmitter->emitIns_R_R(INS_mov, emitActualTypeSize(tree->TypeGet()),
                                     (emitRegs)rg2,
                                     (emitRegs)reg);

#endif

    /* The value has been transferred to 'reg' */

    if ((genRegMask(reg) & rsMaskUsed) == 0)
        gcMarkRegSetNpt(genRegMask(reg));

    gcMarkRegPtrVal(rg2, tree->TypeGet());

    /* The value is now in an appropriate register */

    tree->gtRegNum = reg = rg2;

REG_OK:

    /* Does the caller want us to mark the register as used? */

    if  (keepReg == KEEP_REG)
    {
        /* In case we're computing a value into a register variable */

        genUpdateLife(tree);

        /* Mark the register as 'used' */

        rsMarkRegUsed(tree);
    }
}

/*****************************************************************************
 *
 *  Same as genComputeReg(), the only difference being that the result is
 *  guaranteed to end up in a trashable register.
 */

inline
void                Compiler::genCompIntoFreeReg(GenTreePtr   tree,
                                                 regMaskTP    needReg,
                                                 KeepReg      keepReg)
{
    genComputeReg(tree, needReg, ANY_REG, keepReg, true);
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register; free up that
 *  register (but also make sure the value is presently in a register).
 */

void                Compiler::genReleaseReg(GenTreePtr    tree)
{
    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The register has been spilled -- reload it */

        rsUnspillReg(tree, 0, FREE_REG);
        return;
    }

    rsMarkRegFree(genRegMask(tree->gtRegNum));
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register. Check whether that
 *  register has been spilled (and reload it if so), and if 'keepReg' is 0,
 *  free the register.
 */

void                Compiler::genRecoverReg(GenTreePtr    tree,
                                            regMaskTP     needReg,
                                            KeepReg       keepReg)
{
    assert(varTypeIsI(genActualType(tree->gtType)));

    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The register has been spilled -- reload it */

        rsUnspillReg(tree, needReg, keepReg);
        return;
    }
    else if (needReg && (needReg & genRegMask(tree->gtRegNum)) == 0)
    {
        /* We need the tree in another register. So move it there */

        assert(tree->gtFlags & GTF_REG_VAL);
        regNumber   oldReg  = tree->gtRegNum;

        /* Pick an acceptable register */

        regNumber   reg     = rsGrabReg(needReg);

        /* Copy the value */

        inst_RV_RV(INS_mov, reg, oldReg);
        tree->gtRegNum      = reg;

        gcMarkRegPtrVal(tree);
        rsMarkRegUsed(tree);
        rsMarkRegFree(oldReg, tree);

        rsTrackRegCopy(reg, oldReg);
    }

    /* Free the register if the caller desired so */

    if  (keepReg == FREE_REG)
    {
        rsMarkRegFree(genRegMask(tree->gtRegNum));
        // Can't use FREE_REG on a GC type 
        assert(!varTypeIsGC(tree->gtType));
    }
    else
    {
        assert(rsMaskUsed & genRegMask(tree->gtRegNum));
    }
}


/*****************************************************************************
 *
 * Move one half of a register pair to it's new regPair(half).
 */

inline
void               Compiler::genMoveRegPairHalf(GenTreePtr  tree,
                                                regNumber   dst,
                                                regNumber   src,
                                                int         off)
{

#if TGT_x86

    if  (src == REG_STK)
    {
        // handle long to unsigned long overflow casts
        while (tree->gtOper == GT_CAST)
        {
            assert(tree->gtType == TYP_LONG);
            tree = tree->gtCast.gtCastOp;
        }
        assert(tree->gtEffectiveVal()->gtOper == GT_LCL_VAR);
        assert(tree->gtType == TYP_LONG);
        inst_RV_TT(INS_mov, dst, tree, off);
        rsTrackRegTrash(dst);
    }
    else
    {
        rsTrackRegCopy     (dst, src);
        inst_RV_RV(INS_mov, dst, src, TYP_INT);
    }

#else

    if  (src == REG_STK)
    {
        assert(tree->gtOper == GT_LCL_VAR);
        assert(!"need non-x86 code to load reg pair half from frame");
    }
    else
    {
        rsTrackRegCopy     (dst, src);

        genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, (emitRegs)dst,
                                                   (emitRegs)src);
    }

#endif

}

/*****************************************************************************
 *
 *  The given long value is in a register pair, but it's not an acceptable
 *  one. We have to move the value into a register pair in 'needReg' (if
 *  non-zero) or the pair 'newPair' (when 'newPair != REG_PAIR_NONE').
 *
 *  Important note: if 'needReg' is non-zero, we assume the current pair
 *  has not been marked as free. If, OTOH, 'newPair' is specified, we
 *  assume that the current register pair is marked as used and free it.
 */

void                Compiler::genMoveRegPair(GenTreePtr  tree,
                                             regMaskTP   needReg,
                                             regPairNo   newPair)
{
    regPairNo       oldPair;

    regNumber       oldLo;
    regNumber       oldHi;
    regNumber       newLo;
    regNumber       newHi;

    /* Either a target set or a specific pair may be requested */

    assert((needReg != 0) != (newPair != REG_PAIR_NONE));

    /* Get hold of the current pair */

    oldPair = tree->gtRegPair; assert(oldPair != newPair);

    /* Are we supposed to move to a specific pair? */

    if  (newPair != REG_PAIR_NONE)
    {
        regMaskTP  oldMask = genRegPairMask(oldPair);
        regMaskTP  loMask  = genRegMask(genRegPairLo(newPair));
        regMaskTP  hiMask  = genRegMask(genRegPairHi(newPair));
        regMaskTP  overlap = oldMask & (loMask|hiMask);

        /* First lock any registers that are in both pairs */

        assert((rsMaskUsed &  overlap) == overlap);
        assert((rsMaskLock &  overlap) == 0);
                rsMaskLock |= overlap;

        /* Make sure any additional registers we need are free */

        if  ((loMask & rsMaskUsed) != 0 &&
             (loMask & oldMask   ) == 0)
        {
            rsGrabReg(loMask);
        }

        if  ((hiMask & rsMaskUsed) != 0 &&
             (hiMask & oldMask   ) == 0)
        {
            rsGrabReg(hiMask);
        }

        /* Unlock those registers we have temporarily locked */

        assert((rsMaskUsed &  overlap) == overlap);
        assert((rsMaskLock &  overlap) == overlap);
                rsMaskLock -= overlap;

        /* We can now free the old pair */

        rsMarkRegFree(oldMask);
    }
    else
    {
        /* Pick the new pair based on the caller's stated preference */

        newPair = rsGrabRegPair(needReg);        
    }

    // If grabbed pair is the same as old one we're done
    if (newPair==oldPair)
    {
        assert(
            (oldLo = genRegPairLo(oldPair),
             oldHi = genRegPairHi(oldPair),
             newLo = genRegPairLo(newPair),
             newHi = genRegPairHi(newPair),
             newLo != REG_STK && newHi != REG_STK));
        return;
    }


    /* Move the values from the old pair into the new one */
    
    oldLo = genRegPairLo(oldPair);
    oldHi = genRegPairHi(oldPair);
    newLo = genRegPairLo(newPair);
    newHi = genRegPairHi(newPair);

    assert(newLo != REG_STK && newHi != REG_STK);

    /* Careful - the register pairs might overlap */

    if  (newLo == oldLo)
    {
        /* The low registers are identical, just move the upper half */

        assert(newHi != oldHi);
        genMoveRegPairHalf(tree, newHi, oldHi, sizeof(int));
    }
    else
    {
        /* The low registers are different, are the upper ones the same? */

        if  (newHi == oldHi)
        {
            /* Just move the lower half, then */
            genMoveRegPairHalf(tree, newLo, oldLo, 0);
        }
        else
        {
            /* Both sets are different - is there an overlap? */

            if  (newLo == oldHi)
            {
                /* Are high and low simply swapped ? */

                if  (newHi == oldLo)
                {
                    rsTrackRegSwap(newLo, oldLo);
#if TGT_x86
                    inst_RV_RV    (INS_xchg, newLo, oldLo);
#else
                    assert(!"need non-x86 code");
#endif
                }
                else
                {
                    /* New lower == old higher, so move higher half first */

                    assert(newHi != oldLo);
                    genMoveRegPairHalf(tree, newHi, oldHi, sizeof(int));
                    genMoveRegPairHalf(tree, newLo, oldLo, 0);

                }
            }
            else
            {
                /* Move lower half first */
                genMoveRegPairHalf(tree, newLo, oldLo, 0);
                genMoveRegPairHalf(tree, newHi, oldHi, sizeof(int));
            }
        }
    }

    /* Record the fact that we're switching to another pair */

    tree->gtRegPair   = newPair;
}

/*****************************************************************************
 *
 *  Compute the value 'tree' into the register pair specified by 'needRegPair'
 *  if 'needRegPair' is REG_PAIR_NONE then use any free register pair, avoid
 *  those in avoidReg.
 *  If 'keepReg' is set to KEEP_REG then we mark both registers that the 
 *  value ends up in as being used.
 */

void                Compiler::genComputeRegPair(GenTreePtr  tree,
                                                regPairNo   needRegPair,
                                                regMaskTP   avoidReg,
                                                KeepReg     keepReg,
                                                bool        freeOnly)
{
    regMaskTP       regMask;
    regPairNo       regPair;
    regMaskTP       tmpMask;
    regMaskTP       tmpUsedMask;
    regNumber       rLo;
    regNumber       rHi;

#if SPECIAL_DOUBLE_ASG
    assert(genTypeSize(tree->TypeGet()) == genTypeSize(TYP_LONG));
#else
    assert(isRegPairType(tree->gtType));
#endif

    if (needRegPair == REG_PAIR_NONE)
    {
        if (freeOnly)
        {
            regMask = rsRegMaskFree() & ~avoidReg;
            if (genMaxOneBit(regMask))
                regMask = rsRegMaskFree();
        }
        else
        {
            regMask = RBM_ALL & ~avoidReg;
        }

        if (genMaxOneBit(regMask))
            regMask = rsRegMaskCanGrab();
    }
    else
    {
        regMask = genRegPairMask(needRegPair);
    }

    /* Generate the value, hopefully into the right register pair */

    genCodeForTreeLng(tree, regMask);

    assert(tree->gtFlags & GTF_REG_VAL);

    regPair = tree->gtRegPair;
    tmpMask = genRegPairMask(regPair);

    rLo     = genRegPairLo(regPair);
    rHi     = genRegPairHi(regPair);

    /* At least one half is in a real register */

    assert(rLo != REG_STK || rHi != REG_STK);

    /* Did the value end up in an acceptable register pair? */

    if  (needRegPair != REG_PAIR_NONE)
    {
        if  (needRegPair != regPair)
        {
            /* This is a hack. If we specify a regPair for genMoveRegPair */
            /* it expects the source pair being marked as used */
            rsMarkRegPairUsed(tree);
            genMoveRegPair(tree, 0, needRegPair);
        }
    }
    else if  (freeOnly)
    {
        /* Do we have to end up with a free register pair?
           Something might have gotten freed up above */
        bool mustMoveReg=false;

        regMask = rsRegMaskFree() & ~avoidReg;

        if (genMaxOneBit(regMask))
            regMask = rsRegMaskFree();

        if ((tmpMask & regMask) != tmpMask || rLo == REG_STK || rHi == REG_STK)
        {
            /* Note that we must call genMoveRegPair if one of our registers
               comes from the used mask, so that it will be properly spilled. */
            
            mustMoveReg = true;
        }
                
        if (genMaxOneBit(regMask))
            regMask |= rsRegMaskCanGrab() & ~avoidReg;

        if (genMaxOneBit(regMask))
            regMask |= rsRegMaskCanGrab();

        /* Did the value end up in a free register pair? */

        if  (mustMoveReg)
        {
            /* We'll have to move the value to a free (trashable) pair */
            genMoveRegPair(tree, regMask, REG_PAIR_NONE);
        }
    }
    else
    {
        assert(needRegPair == REG_PAIR_NONE);
        assert(!freeOnly);

        /* it is possible to have tmpMask also in the rsMaskUsed */
        tmpUsedMask  = tmpMask & rsMaskUsed;
        tmpMask     &= ~rsMaskUsed;

        /* Make sure that the value is in "real" registers*/
        if (rLo == REG_STK)
        {
            /* Get one of the desired registers, but exclude rHi */

            rsLockReg(tmpMask);
            rsLockUsedReg(tmpUsedMask);

            regNumber reg = rsPickReg(regMask);

            rsUnlockUsedReg(tmpUsedMask);
            rsUnlockReg(tmpMask);

#if TGT_x86
            inst_RV_TT(INS_mov, reg, tree, 0);
#else
            assert(!"need non-x86 code");
#endif

            tree->gtRegPair = gen2regs2pair(reg, rHi);

            rsTrackRegTrash(reg);
            gcMarkRegSetNpt(genRegMask(reg));
        }
        else if (rHi == REG_STK)
        {
            /* Get one of the desired registers, but exclude rLo */

            rsLockReg(tmpMask);
            rsLockUsedReg(tmpUsedMask);

            regNumber reg = rsPickReg(regMask);

            rsUnlockUsedReg(tmpUsedMask);
            rsUnlockReg(tmpMask);

#if TGT_x86
            inst_RV_TT(INS_mov, reg, tree, EA_4BYTE);
#else
            assert(!"need non-x86 code");
#endif

            tree->gtRegPair = gen2regs2pair(rLo, reg);

            rsTrackRegTrash(reg);
            gcMarkRegSetNpt(genRegMask(reg));
        }
    }

    /* Does the caller want us to mark the register as used? */

    if  (keepReg == KEEP_REG)
    {
        /* In case we're computing a value into a register variable */

        genUpdateLife(tree);

        /* Mark the register as 'used' */

        rsMarkRegPairUsed(tree);
    }
}

/*****************************************************************************
 *
 *  Same as genComputeRegPair(), the only difference being that the result
 *  is guaranteed to end up in a trashable register pair.
 */

inline
void                Compiler::genCompIntoFreeRegPair(GenTreePtr   tree,
                                                     regMaskTP    avoidReg,
                                                     KeepReg      keepReg)
{
    genComputeRegPair(tree, REG_PAIR_NONE, avoidReg, keepReg, true);
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register pair; free up that
 *  register pair (but also make sure the value is presently in a register
 *  pair).
 */

void                Compiler::genReleaseRegPair(GenTreePtr    tree)
{
    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The register has been spilled -- reload it */

        rsUnspillRegPair(tree, 0, FREE_REG);
        return;
    }

    rsMarkRegFree(genRegPairMask(tree->gtRegPair));
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register pair. Check whether
 *  either register of that pair has been spilled (and reload it if so), and
 *  if 'keepReg' is 0, free the register pair.
 */

void                Compiler::genRecoverRegPair(GenTreePtr    tree,
                                                regPairNo     regPair,
                                                KeepReg       keepReg)
{
    if  (tree->gtFlags & GTF_SPILLED)
    {
        regMaskTP regMask;

        if (regPair == REG_PAIR_NONE)
            regMask = RBM_NONE;
        else
            regMask = genRegPairMask(regPair);

        /* The register pair has been spilled -- reload it */

        rsUnspillRegPair(tree, regMask, KEEP_REG);
    }

    /* Does the caller insist on the value being in a specific place? */

    if  (regPair != REG_PAIR_NONE && regPair != tree->gtRegPair)
    {
        /* No good -- we'll have to move the value to a new place */

        genMoveRegPair(tree, 0, regPair);

        /* Mark the pair as used if appropriate */

        if  (keepReg == KEEP_REG)
            rsMarkRegPairUsed(tree);

        return;
    }

    /* Free the register pair if the caller desired so */

    if  (keepReg == FREE_REG)
        rsMarkRegFree(genRegPairMask(tree->gtRegPair));
}

/*****************************************************************************
 *
 *  Compute the given long value into the specified register pair; don't mark
 *  the register pair as used.
 */

inline
void         Compiler::genEvalIntoFreeRegPair(GenTreePtr tree, regPairNo regPair)
{
    genComputeRegPair(tree, regPair, RBM_NONE, KEEP_REG);
    genRecoverRegPair(tree, regPair, FREE_REG);
}

/*****************************************************************************
 *  This helper makes sure that the regpair target of an assignment is
 *  available for use.  This needs to be called in genCodeForTreeLng just before
 *  a long assignment, but must not be called until everything has been
 *  evaluated, or else we might try to spill enregistered variables.
 *  
 */

inline
void         Compiler::genMakeRegPairAvailable(regPairNo regPair)
{
    /* Make sure the target of the store is available */
    /* @TODO [CONSIDER] [04/16/01] []: We should be able to avoid this situation somehow */

    regNumber regLo   = genRegPairLo(regPair);
    regNumber regHi   = genRegPairHi(regPair);

    if  ((regHi != REG_STK) && (rsMaskUsed & genRegMask(regHi)))
        rsSpillReg(regHi);

    if  ((regLo != REG_STK) && (rsMaskUsed & genRegMask(regLo)))
        rsSpillReg(regLo);
}

/*****************************************************************************
 *
 *  Take an address expression and try to find the best set of components to
 *  form an address mode; returns non-zero if this is successful.
 *
 *  'fold' specifies if it is OK to fold the array index which hangs off
 *  a GT_NOP node.
 *
 *  If successful, the parameters will be set to the following values:
 *
 *      *rv1Ptr     ...     base operand
 *      *rv2Ptr     ...     optional operand
 *      *revPtr     ...     true if rv2 is before rv1 in the evaluation order
 *  #if SCALED_ADDR_MODES
 *      *mulPtr     ...     optional multiplier (2/4/8) for rv2
 *  #endif
 *      *cnsPtr     ...     integer constant [optional]
 *
 *  The 'mode' parameter may have one of the following values:
 *
 *  #if LEA_AVAILABLE
 *         +1       ...     we're trying to compute a value via 'LEA'
 *  #endif
 *
 *          0       ...     we're trying to form an address mode
 *
 *         -1       ...     we're generating code for an address mode,
 *                          and thus the address must already form an
 *                          address mode (without any further work)
 *
 *  IMPORTANT NOTE: This routine doesn't generate any code, it merely
 *                  identifies the components that might be used to
 *                  form an address mode later on.
 */

bool                Compiler::genCreateAddrMode(GenTreePtr    addr,
                                                int           mode,
                                                bool          fold,
                                                regMaskTP     regMask,
#if!LEA_AVAILABLE
                                                var_types     optp,
#endif
                                                bool        * revPtr,
                                                GenTreePtr  * rv1Ptr,
                                                GenTreePtr  * rv2Ptr,
#if SCALED_ADDR_MODES
                                                unsigned    * mulPtr,
#endif
                                                unsigned    * cnsPtr,
                                                bool          nogen)
{
#if     TGT_x86

    /*
        The following indirections are address modes on the x86:

            [reg                   ]
            [reg             + icon]

            [reg2 +     reg1       ]
            [reg2 +     reg1 + icon]

            [reg2 + 2 * reg1       ]
            [reg2 + 4 * reg1       ]
            [reg2 + 8 * reg1       ]

            [reg2 + 2 * reg1 + icon]
            [reg2 + 4 * reg1 + icon]
            [reg2 + 8 * reg1 + icon]
     */

#elif   TGT_SH3

    /*
        The following indirections are address modes on the SH-3:

            [reg1       ]
            [reg1 + icon]

            [reg1 + reg2]       for            32-bit operands

            [ R0  + reg2]       for  8-bit and 16-bit operands
     */

#endif

    /* All indirect address modes require the address to be an addition */

    if  (addr->gtOper != GT_ADD)
        return false;

    // Cant use indirect addressing mode as we need to check for overflow
    // Also, cant use 'lea' as it doesnt set the flags

    if (addr->gtOverflow())
        return false;

    GenTreePtr      rv1 = 0;
    GenTreePtr      rv2 = 0;

    GenTreePtr      op1;
    GenTreePtr      op2;

    unsigned        cns;
#if SCALED_ADDR_MODES
    unsigned        mul;
#endif

    GenTreePtr      tmp;

    /* What order are the sub-operand to be evaluated */

    if  (addr->gtFlags & GTF_REVERSE_OPS)
    {
        op1 = addr->gtOp.gtOp2;
        op2 = addr->gtOp.gtOp1;
    }
    else
    {
        op1 = addr->gtOp.gtOp1;
        op2 = addr->gtOp.gtOp2;
    }

    bool    rev = false; // Is op2 first in the evaluation order?

    /*
        A complex address mode can combine the following operands:

            op1     ...     base address
            op2     ...     optional scaled index
#if SCALED_ADDR_MODES
            mul     ...     optional multiplier (2/4/8) for rv2
#endif
            cns     ...     optional displacement

        Here we try to find such a set of operands and arrange for these
        to sit in registers.
     */

    cns = 0;
#if SCALED_ADDR_MODES
    mul = 0;
#endif

AGAIN:

    /* Check both operands as far as being register variables */

    if  (mode != -1)
    {
        if (op1->gtOper == GT_LCL_VAR) genMarkLclVar(op1);
        if (op2->gtOper == GT_LCL_VAR) genMarkLclVar(op2);
    }

    /* Special case: keep constants as 'op2' */

    if  (op1->gtOper == GT_CNS_INT)
    {
        tmp = op1;
              op1 = op2;
                    op2 = tmp;
    }

    /* Check for an addition of a constant */

    if ((op2->gtOper == GT_CNS_INT) && (op2->gtType != TYP_REF))
    {
        /* We're adding a constant */

        cns += op2->gtIntCon.gtIconVal;

        /* Can (and should) we use "add reg, icon" ? */

        if  ((op1->gtFlags & GTF_REG_VAL) && mode == 1 && !nogen)
        {
            regNumber       reg1 = op1->gtRegNum;

            if  (regMask == 0 || (regMask & genRegMask(reg1)) &&
                 genRegTrashable(reg1, addr))
            {
                // In case genMarkLclVar(op1) bashed it above and it is
                // the last use of the variable.

                genUpdateLife(op1);

                /* 'reg1' is trashable, so add "icon" into it */

                genIncRegBy(reg1, cns, addr, addr->TypeGet());

                genUpdateLife(addr);
                return true;
            }
        }

        /* Inspect the operand the constant is being added to */

        switch (op1->gtOper)
        {
        case GT_ADD:

            if (op1->gtOverflow())
                break;

            op2 = op1->gtOp.gtOp2;
            op1 = op1->gtOp.gtOp1;

            goto AGAIN;

#if     SCALED_ADDR_MODES

        case GT_MUL:
            if (op1->gtOverflow())
                return false; // Need overflow check

        case GT_LSH:

            mul = op1->IsScaledIndex();
            if  (mul)
            {
                /* We can use "[mul*rv2 + icon]" */

                rv1 = 0;
                rv2 = op1->gtOp.gtOp1;

                goto FOUND_AM;
            }
#endif
        }

        /* The best we can do is "[rv1 + icon]" */

        rv1 = op1;
        rv2 = 0;

        goto FOUND_AM;
    }

    /* op2 is not a constant. So keep on trying.
       Does op1 or op2 already sit in a register? */

    if      (op1->gtFlags & GTF_REG_VAL)
    {
        /* op1 is sitting in a register */
    }
    else if (op2->gtFlags & GTF_REG_VAL)
    {
        /* op2 is sitting in a register. Keep the enregistered value as op1 */

        tmp = op1;
              op1 = op2;
                    op2 = tmp;

        assert(rev == false);
        rev = true;
    }
    else
    {
        /* Neither op1 nor op2 are sitting in a register right now */

        switch (op1->gtOper)
        {
        case GT_ADD:

            if (op1->gtOverflow())
                break;

            if  (op1->gtOp.gtOp2->gtOper == GT_CNS_INT)
            {
                cns += op1->gtOp.gtOp2->gtIntCon.gtIconVal;
                op1  = op1->gtOp.gtOp1;

                goto AGAIN;
            }

            break;

#if     SCALED_ADDR_MODES

        case GT_MUL:

            if (op1->gtOverflow())
                break;

        case GT_LSH:

            mul = op1->IsScaledIndex();
            if  (mul)
            {
                /* 'op1' is a scaled value */

                rv1 = op2;
                rv2 = op1->gtOp.gtOp1;

                assert(rev == false);
                rev = true;

                goto FOUND_AM;
            }

            break;
#endif

        case GT_NOP:

            if  (!nogen)
                break;

            op1 = op1->gtOp.gtOp1;
            goto AGAIN;

        case GT_COMMA:

            if  (!nogen)
                break;

            op1 = op1->gtOp.gtOp2;
            goto AGAIN;
        }

        assert(op2);
        switch (op2->gtOper)
        {
        case GT_ADD:

            if (op2->gtOverflow())
                break;

            if  (op2->gtOp.gtOp2->gtOper == GT_CNS_INT)
            {
                cns += op2->gtOp.gtOp2->gtIntCon.gtIconVal;
                op2  = op2->gtOp.gtOp1;

                goto AGAIN;
            }

            break;

#if     SCALED_ADDR_MODES

        case GT_MUL:

            if (op2->gtOverflow())
                break;

        case GT_LSH:

            mul = op2->IsScaledIndex();
            if  (mul)
            {
                /* 'op2' is a scaled value */

                rv1 = op1;
                rv2 = op2->gtOp.gtOp1;

                goto FOUND_AM;
            }

            break;
#endif

        case GT_NOP:

            if  (!nogen)
                break;

            op2 = op2->gtOp.gtOp1;
            goto AGAIN;

        case GT_COMMA:

            if  (!nogen)
                break;

            op2 = op2->gtOp.gtOp2;
            goto AGAIN;
        }

        goto ADD_OP12;
    }

    /* op1 is in a register.
       Is op2 an addition or a scaled value? */

    assert(op2);
    switch (op2->gtOper)
    {
    case GT_ADD:

        if (op2->gtOverflow())
            break;

        if  (op2->gtOp.gtOp2->gtOper == GT_CNS_INT)
        {
            cns += op2->gtOp.gtOp2->gtIntCon.gtIconVal;
            op2  = op2->gtOp.gtOp1;
            goto AGAIN;
        }

        break;

#if     SCALED_ADDR_MODES

    case GT_MUL:

        if (op2->gtOverflow())
            break;

    case GT_LSH:

        mul = op2->IsScaledIndex();
        if  (mul)
        {
            rv1 = op1;
            rv2 = op2->gtOp.gtOp1;

            goto FOUND_AM;
        }

        break;

#endif

    }

ADD_OP12:

    /* The best we can do "[rv1 + rv2]" */

    rv1 = op1;
    rv2 = op2;

FOUND_AM:

    /* Check for register variables */

    if  (mode != -1)
    {
        if (rv1 && rv1->gtOper == GT_LCL_VAR) genMarkLclVar(rv1);
        if (rv2 && rv2->gtOper == GT_LCL_VAR) genMarkLclVar(rv2);
    }

    if  (rv2)
    {
        /* Make sure a GC address doesn't end up in 'rv2' */

        if  (varTypeIsGC(rv2->TypeGet()))
        {
            assert(rv1 && !varTypeIsGC(rv1->TypeGet()));

            tmp = rv1;
                  rv1 = rv2;
                        rv2 = tmp;

            rev = !rev;
        }

        /* Special case: constant array index (that is range-checked) */

        if  (fold)
        {
            long        tmpMul;
            GenTreePtr  index;

            if ((rv2->gtOper == GT_MUL || rv2->gtOper == GT_LSH) &&
                (rv2->gtOp.gtOp2->gtOper == GT_CNS_INT))
            {
                /* For valuetype arrays where we cant use the scaled address
                   mode, rv2 will point to the scaled index. So we have to do
                   more work */

                long cnsVal = rv2->gtOp.gtOp2->gtIntCon.gtIconVal;
                if (rv2->gtOper == GT_MUL)
                    tmpMul = cnsVal;
                else
                    tmpMul = 1 << cnsVal;

                index = rv2->gtOp.gtOp1;
            }
            else
            {
                /* May be a simple array. rv2 will points to the actual index */

                index = rv2;
                tmpMul = mul;
            }

            /* Get hold of the array index and see if it's a constant */

            if ((index->gtOper == GT_NOP) && (index->gtFlags & GTF_NOP_RNGCHK) &&
                (index->gtOp.gtOp1->gtOper == GT_CNS_INT))
            {
                /* Get hold of the index value */

                long ixv = index->gtOp.gtOp1->gtIntCon.gtIconVal;

                /* Scale the index if necessary */

#if SCALED_ADDR_MODES
                if  (tmpMul) ixv *= tmpMul;
#endif

                /* Add the scaled index to the offset value */

                cns += ixv;

                /* There is no scaled operand any more */

#if SCALED_ADDR_MODES
                mul = 0;
#endif
                rv2 = 0;
            }
        }
    }

    // We shouldnt have [rv2*1 + cns] - this is equivalent to [rv1 + cns]
    assert(rv1 || mul != 1);

    /* Success - return the various components to the caller */

    *revPtr = rev;
    *rv1Ptr = rv1;
    *rv2Ptr = rv2;
#if SCALED_ADDR_MODES
    *mulPtr = mul;
#endif
    *cnsPtr = cns;

    return  true;
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Return non-zero if the given tree can be computed via an addressing mode,
 *  such as "[ebx+esi*4+20]". If the expression isn't an address mode already
 *  try to make it so (but we don't try 'too hard' to accomplish this). If we
 *  end up needing a register (or two registers) to hold some part(s) of the
 *  address, we return the use register mask via '*useMaskPtr'.
 */

bool                Compiler::genMakeIndAddrMode(GenTreePtr   addr,
                                                 GenTreePtr   oper,
                                                 bool         forLea,
                                                 regMaskTP    regMask,
                                                 KeepReg      keepReg,
                                                 regMaskTP *  useMaskPtr,
                                                 bool         deferOK)
{
    if (addr->gtOper == GT_ARR_ELEM)
    {
        regMaskTP   regMask = genMakeAddrArrElem(addr, oper, RBM_ALL, keepReg);
        *useMaskPtr = regMask;
        return true;
    }

    bool            rev;
    GenTreePtr      rv1;
    GenTreePtr      rv2;
    bool            operIsChkdArr;  // is oper an array which needs rng-chk
    GenTreePtr      scaledIndex;    // If scaled addressing mode cant be used

    regMaskTP       anyMask = RBM_ALL;

    unsigned        cns;
    unsigned        mul;

    GenTreePtr      tmp;
    long            ixv = INT_MAX; // unset value

    /* Deferred address mode forming NYI for x86 */

    assert(deferOK == false);

    assert(oper == NULL || oper->gtOper == GT_IND);
    operIsChkdArr =  (oper != NULL) && ((oper->gtFlags & GTF_IND_RNGCHK) != 0);

    /* Is the complete address already sitting in a register? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
        rv1 = addr;
        rv2 = scaledIndex = 0;
        cns = 0;

        goto YES;
    }

    /* Is it an absolute address */

    if (addr->gtOper == GT_CNS_INT)
    {
        rv1 = rv2 = scaledIndex = 0;
        cns = addr->gtIntCon.gtIconVal;

        goto YES;
    }

    if (addr->gtOper == GT_LCL_VAR && genMarkLclVar(addr))
    {
        genUpdateLife(addr);

        rv1 = addr;
        rv2 = scaledIndex = 0;
        cns = 0;

        goto YES;
    }

    /* Is there a chance of forming an address mode? */

    if  (!genCreateAddrMode(addr, forLea, false, regMask, &rev, &rv1, &rv2, &mul, &cns))
    {
        /* This better not be an array index or we're screwed */
        assert(!operIsChkdArr);

        return  false;
    }

   /*  For scaled array access, RV2 may not be pointing to the index of the
       array if the CPU does not support the needed scaling factor.  We will
       make it point to the actual index, and scaledIndex will point to
       the scaled value */

    scaledIndex = NULL;

    if  (operIsChkdArr && rv2->gtOper != GT_NOP)
    {
        assert((rv2->gtOper == GT_MUL || rv2->gtOper == GT_LSH) &&
               !rv2->IsScaledIndex());

        scaledIndex = rv2;
        rv2 = scaledIndex->gtOp.gtOp1;

        assert(scaledIndex->gtOp.gtOp2->gtOper == GT_CNS_INT &&
               rv2->gtOper == GT_NOP);
    }

    /* Has the address already been computed? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
        if  (forLea)
            return  true;

        rv1         = addr;
        rv2         = 0;
        scaledIndex = 0;
        goto YES;
    }

    /*
        Here we have the following operands:

            rv1     .....       base address
            rv2     .....       offset value        (or NULL)
            mul     .....       multiplier for rv2  (or NULL)
            cns     .....       additional constant (or NULL)

        The first operand must be present (and be an address) unless we're
        computing an expression via 'LEA'. The scaled operand is optional,
        but must not be a pointer if present.
     */

    assert(rv2 == 0 || !varTypeIsGC(rv2->TypeGet()));

#if CSELENGTH

    /* Do we have an array length CSE definition? */

    if  (operIsChkdArr && oper->gtInd.gtIndLen)
    {
        GenTreePtr      len = oper->gtInd.gtIndLen;

        assert(len->gtOper == GT_LCL_VAR ||
               len->gtOper == GT_REG_VAR ||
               len->gtOper == GT_ARR_LENREF);

        if  (len->gtOper == GT_ARR_LENREF)
        {
            anyMask &= ~genCSEevalRegs(len);
            regMask &= anyMask;

            /* Make sure the register mask is actually useful */

            if  (!(regMask & rsRegMaskFree()))
                regMask = anyMask;
        }
    }

#endif

    /*-------------------------------------------------------------------------
     *
     * Make sure both rv1 and rv2 (if present) are in registers
     *
     */

    // Trivial case : Is either rv1 or rv2 a NULL ?

    if  (!rv2)
    {
        /* A single operand, make sure it's in a register */

        genCodeForTree(rv1, regMask);
        goto DONE_REGS;
    }
    else if (!rv1)
    {
        /* A single (scaled) operand, make sure it's in a register */

        genCodeForTree(rv2, 0);
        goto DONE_REGS;
    }

    /* At this point, both rv1 and rv2 are non-NULL and we have to make sure
      they are in registers */

    assert(rv1 && rv2);

    // If we are trying to use addr-mode for an arithmetic operation,
    // make sure we have enough scratch registers

    if (!operIsChkdArr)
    {
        regMaskTP canGrab = rsRegMaskCanGrab();

        unsigned numRegs;

        if (canGrab == RBM_NONE)
            numRegs = 0;
        else if (genMaxOneBit(canGrab))
            numRegs = 1;
        else
            numRegs = 2;

        unsigned numRegVals = ((rv1->gtFlags & GTF_REG_VAL) ? 1 : 0) +
                              ((rv2->gtFlags & GTF_REG_VAL) ? 1 : 0);

        // Not enough registers available. Cant use addressing mode.

        if (numRegs + numRegVals < 2)
            return false;
    }

    /*  If we have to check a constant array index, compare it against
        the array dimension (see below) but then fold the index with a
        scaling factor (if any) and additional offset (if any).
     */

    if  (rv2->gtOper == GT_NOP && (rv2->gtFlags & GTF_NOP_RNGCHK))
    {
        /* We must have a range-checked index operation */

        assert(operIsChkdArr);

        /* Get hold of the index value and see if it's a constant */

        if  (rv2->gtOp.gtOp1->gtOper == GT_CNS_INT)
        {
            tmp = rv2->gtOp.gtOp1;
            rv2 = scaledIndex = 0;
            ixv = tmp->gtIntCon.gtIconVal;

            /* Add the scaled index into the added value */

            if  (mul)
                cns += ixv * mul;
            else
                cns += ixv;

            /* Make sure 'rv1' is in a register */

            genCodeForTree(rv1, regMask);

            goto DONE_REGS;
        }
    }

    if      (rv1->gtFlags & GTF_REG_VAL)
    {
        /* op1 already in register - how about op2? */

        if  (rv2->gtFlags & GTF_REG_VAL)
        {
            /* Great - both operands are in registers already. Just update
               the liveness and we are done. */

            genUpdateLife(rev ? rv1 : rv2);

            goto DONE_REGS;
        }

        /* rv1 is in a register, but rv2 isn't */

        if (!rev)
        {
            /* rv1 is already materialized in a register. Just update liveness
               to rv1 and generate code for rv2 */

            genUpdateLife(rv1);
            rsMarkRegUsed(rv1, oper);
        }

        goto GEN_RV2;
    }
    else if (rv2->gtFlags & GTF_REG_VAL)
    {
        /* rv2 is in a register, but rv1 isn't */

        assert(rv2->gtOper == GT_REG_VAR);

        if (rev)
        {
            /* rv2 is already materialized in a register. Update liveness
               to after rv2 and then hang on to rv2 */

            genUpdateLife(rv2);
            rsMarkRegUsed(rv2, oper);
        }

        /* Generate the for the first operand */

        genCodeForTree(rv1, regMask);        

        if (rev)
        {
            // Free up rv2 in the right fashion (it might be re-marked if keepReg)
            rsMarkRegUsed(rv1, oper);
            rsLockUsedReg  (genRegMask(rv1->gtRegNum));
            genReleaseReg(rv2);
            rsUnlockUsedReg(genRegMask(rv1->gtRegNum));
            genReleaseReg(rv1);            
        }
        else
        {
            /* We have evaluated rv1, and now we just need to update liveness
               to rv2 which was already in a register */

            genUpdateLife(rv2);
        }

        goto DONE_REGS;
    }

    if  (forLea && !cns)
        return  false;

    /* Make sure we preserve the correct operand order */

    if  (rev)
    {
        /* Generate the second operand first */

        genCodeForTree(rv2, regMask);
        rsMarkRegUsed(rv2, oper);

        /* Generate the first operand second */

        genCodeForTree(rv1, regMask);
        rsMarkRegUsed(rv1, oper);

        /* Free up both operands in the right order (they might be
           re-marked as used below)
        */
        rsLockUsedReg  (genRegMask(rv1->gtRegNum));
        genReleaseReg(rv2);
        rsUnlockUsedReg(genRegMask(rv1->gtRegNum));
        genReleaseReg(rv1);
    }
    else
    {
        /* Get the first operand into a register */

        genCodeForTree(rv1, anyMask & ~rv2->gtRsvdRegs);
        rsMarkRegUsed(rv1, oper);

    GEN_RV2:

        /* Here, we need to get rv2 in a register. We have either already
           materialized rv1 into a register, or it was already in a one */

        assert(rv1->gtFlags & GTF_REG_VAL);
        assert(rev || rsIsTreeInReg(rv1->gtRegNum, rv1));

        /* Generate the second operand as well */

        regMask &= ~genRegMask(rv1->gtRegNum);

        genCodeForTree(rv2, regMask);

        if (rev)
        {
            /* rev==true means the evalutaion order is rv2,rv1. We just
               evaluated rv2, and rv1 was already in a register. Just
               update liveness to rv1 and we are done. */

            genUpdateLife(rv1);
        }
        else
        {
            /* We have evaluated rv1 and rv2. Free up both operands in
               the right order (they might be re-marked as used below) */

            /* Even though we havent explicitly marked rv2 as used,
               rv2->gtRegNum may be used if rv2 is a multi-use or
               an enregistered variable. */
            regMaskTP   rv2Used;

            rsLockReg  (genRegMask(rv2->gtRegNum), &rv2Used);

            /* Check for special case both rv1 and rv2 are the same register */
            if (rv2Used != genRegMask(rv1->gtRegNum))
            {
                genReleaseReg(rv1);
                rsUnlockReg(genRegMask(rv2->gtRegNum),  rv2Used);
            }
            else
            {
                rsUnlockReg(genRegMask(rv2->gtRegNum),  rv2Used);
                genReleaseReg(rv1);
            }
        }
    }

    /*-------------------------------------------------------------------------
     *
     * At this point, both rv1 and rv2 (if present) are in registers
     *
     */

DONE_REGS:

    /* We must verify that 'rv1' and 'rv2' are both sitting in registers */

    if  (rv1 && !(rv1->gtFlags & GTF_REG_VAL)) return false;
    if  (rv2 && !(rv2->gtFlags & GTF_REG_VAL)) return false;

YES:

    // *(intVar1+intVar1) causes problems as we
    // call rsMarkRegUsed(op1) and rsMarkRegUsed(op2). So the calling function
    // needs to know that it has to call rsFreeReg(reg1) twice. We cant do
    // that currently as we return a single mask in useMaskPtr.

    if ((keepReg == KEEP_REG) && oper && rv1 && rv2 &&
        (rv1->gtFlags & rv2->gtFlags & GTF_REG_VAL))
    {
        if (rv1->gtRegNum == rv2->gtRegNum)
        {
            assert(!operIsChkdArr);
            return false;
        }
    }

    /* Check either register operand to see if it needs to be saved */

    if  (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);

        if (keepReg == KEEP_REG)
        {
            rsMarkRegUsed(rv1, oper);
        }
        else
        {
            /* If the register holds an address, mark it */

            gcMarkRegPtrVal(rv1->gtRegNum, rv1->TypeGet());
        }
    }

    if  (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);

        if (keepReg == KEEP_REG)
            rsMarkRegUsed(rv2, oper);
    }

    if  (deferOK)
    {
        assert(!scaledIndex);
        return  true;
    }

    /* Is this an array index that needs to be range-checked? */

    if  (operIsChkdArr)
    {
        genRangeCheck(oper, rv1, rv2, ixv, regMask, keepReg);

        /* For valuetype arrays where we cant use a scaled addressing mode,
           we need to materialize the scaled index so that the element
           can be accessed by a non-scaled addressing mode */

        if (scaledIndex)
        {
            assert(rv2->gtFlags & GTF_REG_VAL);
            if (keepReg == KEEP_REG)
                genReleaseReg(rv2);

            /* If rv1 is evaluated after rv2, then evaluating scaledIndex
               here will reset the liveness to that of rv2. So bash it.
               It is safe to do this as scaledIndex is simple GT_MUL node
               and rv2 is guaranteed to be in a register 

               Note, there's also a problem when the rangecheck changes the liveset, 
               as we're doing the range check "out of order", so we will always bash 
               the liveset to genCodeCurLife, which is the state just after the range
               check.            

               Anyways, this is very ugly, as the NOP/GTF_NOP_RNGCHK aproach forces us
               to hack the code somewhere to maintain the correct behaviour with lifetimes:
               here or in the liveness analysis.

               @TODO [CONSIDER] [04/23/01] [] : to avoid this stuff we should have more
               node types instead of abusing the NOP node.
            */

            
            assert((scaledIndex->gtOper == GT_MUL || scaledIndex->gtOper == GT_LSH) &&
                   (scaledIndex->gtOp.gtOp1 == rv2) &&
                   (rv2->gtFlags & GTF_REG_VAL));
            assert(scaledIndex->gtLiveSet == rv2->gtLiveSet);
            scaledIndex->gtLiveSet = rv2->gtLiveSet = genCodeCurLife;
            

            regMaskTP   rv1Mask = genRegMask(rv1->gtRegNum);
            bool        rv1Used = (rsMaskUsed & rv1Mask) != 0;

            (rv1Used) ? rsLockUsedReg  (rv1Mask) : rsLockReg  (rv1Mask);
            genCodeForTree(scaledIndex, regMask);
            (rv1Used) ? rsUnlockUsedReg(rv1Mask) : rsUnlockReg(rv1Mask);

            if (keepReg == KEEP_REG)
                rsMarkRegUsed(scaledIndex, oper);
        }
    }
    else
    {
        assert(!scaledIndex);

        /*  Special case: a class member might reside at a very large offset,
            and access to such a member via a null pointer may not be trapped
            by the hardware on some architectures/platforms.

            To get around this, if the member offset is larger than some safe
            (but hopefully large) value, we generate "cmp al, [addr]" to make
            sure we try to access the base address of the object and thus trap
            any use of a null pointer.

            For now, we pick an arbitrary offset limit of 32K.
         */

        size_t offset =  cns;

        if  (offset > MAX_UNCHECKED_OFFSET_FOR_NULL_OBJECT)
        {
            // For C indirections, the address can be in any form.
            // rv1 may not be the base, and rv2 the index.
            // Consider (0x400000 + 8*i) --> rv1=NULL, rv2=i, mul=8, and
            // cns=0x400000. So the base is actually in 'cns'
            // So not much we can do.
            if (varTypeIsGC(addr->TypeGet()) && rv1 && varTypeIsGC(rv1->TypeGet()))
            {
                /* Generate "cmp dl, [addr]" to trap null pointers */
                inst_RV_AT(INS_cmp, EA_1BYTE, TYP_BYTE, REG_EDX, rv1, 0);
            }
        }
    }

    /* Compute the set of registers the address depends on */

    regMaskTP  useMask = RBM_NONE;

    if (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv1->gtRegNum);
    }

    if (scaledIndex)
    {
        assert(scaledIndex->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(scaledIndex->gtRegNum);
    }
    else if (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv2->gtRegNum);
    }

    /* Tell the caller which registers we need to hang on to */

    *useMaskPtr = useMask;

    return true;
}

/*****************************************************************************/
#if CSELENGTH
/*****************************************************************************
 *
 *  Check the passed in GT_IND for an array length operand. If it exists and
 *  it's been converted to a CSE def/use, process it appropriately.
 *
 *  Upon return the array length value will either be NULL (which means the
 *  array length needs to be fetched from the array), or it will be a simple
 *  local/register variable reference (which means it's become a CSE use).
 */

regNumber           Compiler::genEvalCSELength(GenTreePtr   ind,
                                               GenTreePtr   adr,
                                               GenTreePtr   ixv)
{
    GenTreePtr      lenRef;

    assert(ind);

    if  (ind->gtOper == GT_ARR_LENREF)
    {
        lenRef  = ind;
        ind     = 0;
    }
    else
    {
        assert(ind->gtOper == GT_IND);
        assert(ind->gtFlags & GTF_IND_RNGCHK);

        lenRef = ind->gtInd.gtIndLen; assert(lenRef);
    }

    /* We better have an array length node here */

    assert(lenRef->gtOper == GT_ARR_LENREF);

    /* If we have an address/index, make sure they're marked as "in use" */

    assert(ixv == 0 || ((ixv->gtFlags & GTF_REG_VAL) != 0 &&
                        (ixv->gtFlags & GTF_SPILLED) == 0));
    assert(adr == 0 || ((adr->gtFlags & GTF_REG_VAL) != 0 &&
                        (adr->gtFlags & GTF_SPILLED) == 0));
    
    unsigned gtRngChkOffs = lenRef->gtArrLenOffset();
    assert (!ind || (ind->gtInd.gtRngChkOffs == gtRngChkOffs));
    assert (gtRngChkOffs == offsetof(CORINFO_Array, length) || 
            gtRngChkOffs == offsetof(CORINFO_String, stringLen));

    /* Do we have a CSE expression or not? */

    GenTreePtr  len = lenRef->gtArrLen.gtArrLenCse;

    if  (!len)
    {
        if  (ind)
            ind->gtInd.gtIndLen = NULL;

        return  REG_COUNT;
    }

    switch (len->gtOper)
    {
    case GT_LCL_VAR:

        /* Has this local been enregistered? */

        if (!genMarkLclVar(len))
        {
            /* Not a register variable, do we have any free registers? */

            if  (!riscCode || rsFreeNeededRegCount(rsRegMaskFree()) == 0)
            {
                /* Too bad, just delete the ref as its not worth it */

                if  (ind)
                    ind->gtInd.gtIndLen = NULL;

                genUpdateLife(len);

                return  REG_COUNT;
            }

            /* Loading from a frame var is better than [reg+4] ... */
        }

        /* Otherwise fall through */

    case GT_REG_VAR:

        genCodeForTree(len, 0);

        if  (ind)
            ind->gtInd.gtIndLen = 0;

        genUpdateLife(len);
        break;

    case GT_COMMA:
        {
            GenTreePtr  asg = len->gtOp.gtOp1;
            GenTreePtr  lcl = len->gtOp.gtOp2;

            GenTreePtr  cse = asg->gtOp.gtOp2;
            GenTreePtr  dst = asg->gtOp.gtOp1;

            regNumber   reg;

            /* This must be an array length CSE definition */

            assert(asg->gtOper == GT_ASG);

            assert(cse->gtOper == GT_NOP);
            assert(lcl->gtOper == GT_LCL_VAR);
            assert(dst->gtOper == GT_LCL_VAR);
            assert(dst->gtLclVar.gtLclNum ==
                   lcl->gtLclVar.gtLclNum);

            genUpdateLife(cse);

            /* Has the CSE temp been enregistered? */

            if  (genMarkLclVar(lcl))
            {
                bool        rsp = false;

                reg = lcl->gtRegVar.gtRegNum;

                /* Make sure the variable's register is available */

                if  (rsMaskUsed & genRegMask(reg))
                {
                    if  (reg == adr->gtRegNum)
                    {
                        /* Bad luck: address in same register as target */
#if 1
                        /* @TODO [NOW] [04/19/01] [] : why do we need to spill the address
                         * since this is the only purpose we computed it for? */

                        assert((adr->gtFlags & GTF_SPILLED) == 0);
                        assert((adr->gtFlags & GTF_REG_VAL) != 0);
                        rsSpillReg(reg);
                        assert((adr->gtFlags & GTF_REG_VAL) == 0);
                        assert((adr->gtFlags & GTF_SPILLED) != 0);

                        /* Value copied to spill temp but still in reg */

                        rsp = true;

                        /* Clear flag so that we can indirect through reg */

                        adr->gtFlags &= ~GTF_SPILLED;
                        adr->gtFlags |=  GTF_REG_VAL;
#endif
                    }
                    else
                    {
                        /* Simply spill the target register */

                        rsSpillReg(reg);
                    }
                }

                /* The CSE temp is     enregistered */
                inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg, adr, gtRngChkOffs);

                /* If we've spilled the address, restore the flags */

                if  (rsp)
                {
                    adr->gtFlags |=  GTF_SPILLED;
                    adr->gtFlags &= ~GTF_REG_VAL;
                }

                /* Update the contents of the register */

                rsTrackRegTrash(reg);
                gcMarkRegSetNpt(genRegMask(reg));
                genUpdateLife(len);
            }
            else
            {
                /* The CSE temp is not enregistered; move via temp reg */

                regMaskTP adrRegMask = genRegMask(adr->gtRegNum);
                rsLockUsedReg(adrRegMask);

                reg = rsPickReg(RBM_ALL);

                rsUnlockUsedReg(adrRegMask);

                /* Generate "mov tmp, [rv1+LenOffs]" */

                inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg, adr, gtRngChkOffs);

                /* The register certainly doesn't contain a pointer */

//              genUpdateLife(cse);
                gcMarkRegSetNpt(genRegMask(reg));
                genUpdateLife(asg);

                /* The register now contains the variable value */

                rsTrackRegLclVar(reg, lcl->gtLclVar.gtLclNum);

                /* Now store the value in the CSE temp */

                inst_TT_RV(INS_mov, dst, reg);

                /* Remember that the value is in a register. However, since
                   the register has not been explicitly marked as used, we
                   need to be careful if reg gets spilled below. */

                lcl->gtFlags |= GTF_REG_VAL;
                lcl->gtRegNum = reg;
            }

            /* We've generated the assignment, now toss the CSE */

            if  (ind)
                ind->gtInd.gtIndLen = NULL;

            /* Is there an index value? */

            if  (ixv)
            {
                /* If the index value has been spilled, recover it */

                if  (ixv->gtFlags & GTF_SPILLED)
                {
                    rsUnspillReg(ixv, 0, KEEP_REG);

                    /* Is the CSE variable is not enregistered, then we used
                       rsTrackRegLclVar(). Check if the reg has been trashed. */

                    if (ixv->gtRegNum == reg)
                    {
                        lcl->gtFlags &= ~GTF_REG_VAL;
                        reg = REG_COUNT;
                    }
                }
            }

            return reg;
        }
        break;

    default:
#ifdef  DEBUG
        gtDispTree(len);
#endif
        assert(!"unexpected length on array range check");
    }

    assert(len->gtFlags & GTF_REG_VAL);

    return  len->gtRegNum;
}

/*****************************************************************************/
#endif//CSELENGTH
/*****************************************************************************
 *
 *  'oper' is an array index that needs to be range-checked.
 *  rv1 is the array.
 *  If rv2, then it is the index tree, else ixv is the constant index.
 *  keptReg indicates whether the caller has called rsMarkRegUsed(rv1/2).
 */

void                Compiler::genRangeCheck(GenTreePtr  oper,
                                            GenTreePtr  rv1,
                                            GenTreePtr  rv2,
                                            long        ixv,
                                            regMaskTP   regMask,
                                            KeepReg     keptReg)
{
    assert((oper->gtOper == GT_IND) && (oper->gtFlags & GTF_IND_RNGCHK));
    assert (oper->gtInd.gtRngChkOffs == offsetof(CORINFO_Array, length) || 
            oper->gtInd.gtRngChkOffs == offsetof(CORINFO_String, stringLen));


    /* We must have 'rv1' in a register at this point */

    assert(rv1);
    assert(rv1->gtFlags & GTF_REG_VAL);
    assert(!rv2 || ixv == INT_MAX);

    /* Is the array index a constant value? */

    if  (rv2)
    {
        regMaskTP  tmpMask;

        /* Make sure we have the values we expect */
        assert(rv2);
        assert(rv2->gtOper == GT_NOP);
        assert(rv2->gtFlags & GTF_REG_VAL);
        assert(rv2->gtFlags & GTF_NOP_RNGCHK);
        assert(oper && oper->gtOper == GT_IND && (oper->gtFlags & GTF_IND_RNGCHK));

#if CSELENGTH

        if  (oper->gtInd.gtIndLen)
        {
            if  (oper->gtInd.gtIndLen->gtArrLen.gtArrLenCse)
            {
                regNumber       lreg;

                /* Make sure we don't lose the address/index values */

                assert(rv1->gtFlags & GTF_REG_VAL);
                assert(rv2->gtFlags & GTF_REG_VAL);

                if  (keptReg == FREE_REG)
                {
                    rsMarkRegUsed(rv1, oper);
                    rsMarkRegUsed(rv2, oper);
                }

                /* Try to get the array length into a register */

                lreg = genEvalCSELength(oper, rv1, rv2);

                /* Has the array length become a CSE? */

                if  (lreg != REG_COUNT)
                {
                    /* Make sure the index is still in a register */

                    if  (rv2->gtFlags & GTF_SPILLED)
                    {
                        /* The register has been spilled -- reload it */

                           rsLockReg(genRegMask(lreg));
                        rsUnspillReg(rv2, 0, KEEP_REG);
                         rsUnlockReg(genRegMask(lreg));
                    }

                    /* Compare the index against the array length */

                    inst_RV_RV(INS_cmp, rv2->gtRegNum, lreg);

                    /* Don't need the index for now */

                    genReleaseReg(rv2);

                    /* Free up the address (unless spilled) as well */

                    if  (rv1->gtFlags & GTF_SPILLED)
                    {
                        regNumber       xreg = rv2->gtRegNum;

                        /* The register has been spilled -- reload it */

                           rsLockReg(genRegMask(xreg));
                        rsUnspillReg(rv1, 0, FREE_REG);
                         rsUnlockReg(genRegMask(xreg));
                    }
                    else
                    {
                        /* Release the address register */

                        genReleaseReg(rv1);

                        /* But note that rv1 is still a pointer */

                        gcMarkRegSetGCref(genRegMask(rv1->gtRegNum));
                    }

                    /* Hang on to the value if the caller desires so */

                    if (keptReg == KEEP_REG)
                    {
                        rsMarkRegUsed(rv1, oper);
                        rsMarkRegUsed(rv2, oper);
                    }

                    goto GEN_JAE;
                }

                /* Make sure the index/address are still around */

                if  (rv2->gtFlags & GTF_SPILLED)
                {
                    assert(!"rv2 spilled - can this ever happen?");
                }

                if  (rv1->gtFlags & GTF_SPILLED)
                {
                    /* Lock the index and unspill the address */

                    rsMaskLock |=  genRegMask(rv2->gtRegNum);
                    rsUnspillReg(rv1, 0, FREE_REG);
                    rsMaskLock &= ~genRegMask(rv2->gtRegNum);
                }

                assert(rv1->gtFlags & GTF_REG_VAL);
                assert(rv1->gtType == TYP_REF);

                /* Release the registers */

                genReleaseReg(rv1);
                genReleaseReg(rv2);

                /* Hang on to the values if the caller desires so */

                if (keptReg == KEEP_REG)
                {
                    rsMarkRegUsed(rv1, oper);
                    rsMarkRegUsed(rv2, oper);
                }

                /* But note that rv1 is still a pointer */

                gcMarkRegSetGCref(genRegMask(rv1->gtRegNum));
            }
            else
            {
                oper->gtInd.gtIndLen = NULL;
            }
        }

        /*
         *  NOTE:   If length has not been cse'd, or the cse has not
         *          ended up in a register, then we use the array
         *          pointer already loaded at rv1.
         */

#endif

        /* Might it be useful to load the length into a register? */

        tmpMask = rsRegMaskFree() & ~(genRegMask(rv1->gtRegNum)|
                                      genRegMask(rv2->gtRegNum));

        tmpMask = rsNarrowHint(tmpMask, regMask);

         if  (riscCode && compCurBB->bbWeight > BB_UNITY_WEIGHT
                      && rsFreeNeededRegCount(tmpMask) != 0)
        {
            regNumber   reg = rsGrabReg(tmpMask);

            /* Generate "mov tmp, [rv1+LenOffs]" */

            inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg, rv1, oper->gtInd.gtRngChkOffs);

            /* The register now contains trash */

            rsTrackRegTrash(reg);

            /* Generate "cmp rv2, reg" */

            inst_RV_RV(INS_cmp, rv2->gtRegNum, reg);
        }
        else
        {
            /* Generate "cmp rv2, [rv1+LenOffs]" */

            inst_RV_AT(INS_cmp, EA_4BYTE, TYP_INT, rv2->gtRegNum, rv1, oper->gtInd.gtRngChkOffs);
        }

#if CSELENGTH
    GEN_JAE:
#endif

        /* Generate "jae <fail_label>" */

        assert(oper->gtOper == GT_IND);

        genJumpToThrowHlpBlk(EJ_jae, ACK_RNGCHK_FAIL, oper->gtInd.gtIndRngFailBB);
    }
    else
    {
        /* Generate "cmp [rv1+LenOffs], cns" */

        assert(oper && oper->gtOper == GT_IND && (oper->gtFlags & GTF_IND_RNGCHK));

#if CSELENGTH

        if  (oper->gtInd.gtIndLen)
        {
            if  (oper->gtInd.gtIndLen->gtArrLen.gtArrLenCse)
            {
                regNumber       lreg;

                /* Make sure we don't lose the index value */

                assert(rv1->gtFlags & GTF_REG_VAL);
                if (keptReg == FREE_REG)
                    rsMarkRegUsed(rv1, oper);

                /* Try to get the array length into a register */

                lreg = genEvalCSELength(oper, rv1, NULL);

                /* Make sure the index is still in a register */

                if  (rv1->gtFlags & GTF_SPILLED)
                {
                    /* The register has been spilled -- reload it */

                    if  (lreg == REG_COUNT)
                    {
                        rsUnspillReg(rv1, 0, FREE_REG);
                    }
                    else
                    {
                           rsLockReg(genRegMask(lreg));
                        rsUnspillReg(rv1, 0, FREE_REG);
                         rsUnlockReg(genRegMask(lreg));
                    }
                }
                else
                {
                    /* Release the address register */

                    genReleaseReg(rv1);

                    /* But note that it still contains a pointer */

                    gcMarkRegSetGCref(genRegMask(rv1->gtRegNum));
                }

                assert(rv1->gtFlags & GTF_REG_VAL);

                if (keptReg == KEEP_REG)
                    rsMarkRegUsed(rv1, oper);

                /* Has the array length become a CSE? */

                if  (lreg != REG_COUNT)
                {
                    /* Compare the index against the array length */

                    inst_RV_IV(INS_cmp, lreg, ixv);

                    goto GEN_JBE;
                }
            }
            else
            {
                oper->gtInd.gtIndLen = NULL;
            }
        }

#endif
        /*
            If length has not been cse'd or genEvalCSELength()
            decided not to use it, we use the array pointer
            already loaded at rv1
         */

        inst_AT_IV(INS_cmp, EA_4BYTE, rv1, ixv, oper->gtInd.gtRngChkOffs);

#if CSELENGTH
    GEN_JBE:
#endif

        /* Generate "jbe <fail_label>" */

        assert(oper->gtOper == GT_IND);

        genJumpToThrowHlpBlk(EJ_jbe, ACK_RNGCHK_FAIL, oper->gtInd.gtIndRngFailBB);
    }

    // The ordering must be maintined for fully interruptible code, or else
    // in the case that the range check fails, it is possible to GC with a byref
    // that contains the address of the array element which is out of range.

#if SCHEDULER
    if (opts.compSchedCode)
    {
        genEmitter->emitIns_SchedBoundary();
    }
#endif
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if     TGT_RISC
/*****************************************************************************
 *
 *  Return non-zero if the given tree can be computed via an addressing mode,
 *  such as "[reg+20]" or "[rg1+rg2]". If the expression isn't an address
 *  mode already try to make it so (but we don't try 'too hard' to accomplish
 *  this). If we end up needing a register (or two registers) to hold some
 *  part(s) of the address, we return the use register mask via '*useMaskPtr'.
 *
 *
 * the 'compute' parameter is really three states 1 - doing LEA, 0, not LEA, -1
 *  don't compute (it should already be set up).  See the 'mode' flag on
 *  genCreateAddrMode for more

 * if keepReg==KEEP_REG, then the registers are marked as in use.
 * if deferOK is true then we don't do the complete job but only set it up
      so that it can be complete later see comment on genMakeAddressable for more
 */

bool                Compiler::genMakeIndAddrMode(GenTreePtr   addr,
                                                 GenTreePtr   oper,
                                                 int          mode,
                                                 regMaskTP    regMask,
                                                 KeepReg      keepReg,
                                                 regMaskTP *  useMaskPtr,
                                                 bool         deferOK)
{
    bool            rev;
    GenTreePtr      rv1;
    GenTreePtr      rv2;

    regMaskTP       anyMask = RBM_ALL;

    unsigned        cns;
#if SCALED_ADDR_MODES
    unsigned        mul;
#endif

    GenTreePtr      tmp;
    long            ixv;
    bool            operIsChkdArr;  // is oper an array which needs rng-chk

#if!LEA_AVAILABLE
    var_types       optp = oper ? oper->TypeGet() : TYP_UNDEF;
#endif

#if TGT_SH3
    bool            useR0 = false;
#endif

    genAddressMode = AM_NONE;

    assert(oper == NULL || oper->gtOper == GT_IND);
    operIsChkdArr =  (oper != NULL) && ((oper->gtFlags & GTF_IND_RNGCHK) != 0);

    /* Is the complete address already sitting in a register? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
        rv1  = addr;
        rv2  = 0;
        cns  = 0;

        goto YES;
    }

    /* Is there a chance of forming an address mode? */

    if  (!genCreateAddrMode(addr,
                            forLea,
                            mode,
                            regMask,
#if!LEA_AVAILABLE
                            optp,
#endif
                            &rev,
                            &rv1,
                            &rv2,
#if SCALED_ADDR_MODES
                            &mul,
#endif
                            &cns))
    {
        /* This better not be an array index or we're screwed */
        assert(!operIsChkdArr);

        return  false;
    }

    /* Has the address already been computed? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
        if  (mode != 0)
            return  true;

        rv1 = addr;
        rv2 = 0;

        goto YES;
    }

    /*
        Here we have the following operands:

            rv1     .....       base address
            rv2     .....       offset value        (or NULL)
#if SCALED_ADDR_MODES
            mul     .....       scaling of rv2      (or 0)
#endif
            cns     .....       additional constant (or 0)

        The first operand must be present (and be an address) unless we're
        computing an expression via 'LEA'. The scaled operand is optional,
        but must not be a pointer if present.
     */

#if CSELENGTH

    /* Do we have an array length CSE definition? */

    if  (operIsChkdArr && oper->gtInd.gtIndLen)
    {
        GenTreePtr      len = oper->gtInd.gtIndLen;

        assert(len->gtOper == GT_LCL_VAR ||
               len->gtOper == GT_REG_VAR || len->gtOper == GT_ARR_LENREF);

        if  (len->gtOper == GT_ARR_LENREF)
        {
            anyMask &= ~genCSEevalRegs(len);
            regMask &= anyMask;

            /* Make sure the register mask is actually useful */

            if  (!(regMask & rsRegMaskFree()))
                regMask = anyMask;
        }
    }

#endif

    /*-------------------------------------------------------------------------
     *
     * Make sure both rv1 and rv2 (if present) are in registers
     *
     */

    // Trivial case : Is either rv1 or rv2 a NULL ?

    if  (!rv2)
    {
        /* A single operand, make sure it's in a register */

        genCodeForTree(rv1, regMask);
        goto DONE_REGS;
    }
#if SCALED_ADDR_MODES
    else if (!rv1)
    {
        /* A single (scaled) operand, make sure it's in a register */

        genCodeForTree(rv2, 0);
        goto DONE_REGS;
    }

#endif

    /* At this point, both rv1 and rv2 are non-NULL and we have to make sure
       they are in registers */

    assert(rv1 && rv2);

#if TGT_SH3

    /* It's awfully convenient to use r0 for indexed access */

    useR0 = true;

    /* Are we allowed to use r0 and is it available? */

    if  ((regMask & rsRegMaskFree() & RBM_r00) || !deferOK)
    {
        // ISSUE: When is it good idea (and when not) to use r0 ?
    }
    else
    {
        /*
            We want to use R0 but it's not available and we were told that it was
            OK to defer creating the address mode, so let's give up for now .....
         */

        return  false;
    }

#endif

    /*
        If we have to check a constant array index, compare it against
        the array dimension (see below) but then fold the index with a
        scaling factor (if any) and additional offset (if any).
     */

    if  (rv2->gtOper == GT_NOP && (rv2->gtFlags & GTF_NOP_RNGCHK))
    {
        /* We must have a range-checked index operation */

        assert(operIsChkdArr);

        /* Get hold of the index value and see if it's a constant */

        if  (rv2->gtOp.gtOp1->gtOper == GT_CNS_INT)
        {
            tmp = rv2->gtOp.gtOp1;
            rv2 = 0;
            ixv = tmp->gtIntCon.gtIconVal;

            /* Add the scaled index into the added value */

#if SCALED_ADDR_MODES
            if  (mul) ixv *= mul;
#endif

            cns += ixv;

            /* Make sure 'rv1' is in a register */

            genCodeForTree(rv1, regMask);

            goto DONE_REGS;
        }
    }

    if      (rv1->gtFlags & GTF_REG_VAL)
    {
        /* op1 already in register - how about op2? */

        if  (rv2->gtFlags & GTF_REG_VAL)
        {
            /* great - both operands are in registers already */

            goto DONE_REGS;
        }

        /* rv1 is in a register, but rv2 isn't */

#if TGT_SH3

        /* On the SH-3, small indirection go better via r0 */

        if  (useR0)
            regMask = RBM_r00;

#endif

        goto GEN_RV2;
    }
    else if (rv2->gtFlags & GTF_REG_VAL)
    {
        /* rv2 is in a register, but rv1 isn't */

        assert(rv2->gtOper == GT_REG_VAR);

#if TGT_SH3

        /* On the SH-3, small indirection go better via r0 */

        if  (useR0)
            regMask = RBM_r00;

#endif

        /* Generate the for the first operand */

        genCodeForTree(rv1, regMask);

        goto DONE_REGS;
    }
    else
    {
        /* If we are trying to use addr-mode for an arithmetic operation,
           and we dont have atleast 2 registers, just refuse.
           For arrays, we had better have 2 registers or we will
           barf below on genCodeForTree(rv1 or rv2) */

        if (!operIsChkdArr)
        {

            regMaskTP canGrab = rsRegMaskCanGrab();

            if (canGrab == 0)
            {
                // No registers available. Bail
                return false;
            }
            else if (genMaxOneBit(canGrab))
            {
                // Just one register available. Either rv1 or rv2 should be
                // an enregisterd var

                // @TODO [CONSIDER] [04/16/01] [] Check if rv1 or rv2 is an enregisterd variable
                // Dont bash it else, you have to be careful about marking the register as used
                return  false;
            }
        }
    }

    if  (mode!=0 && !cns)
        return  false;

    /* Make sure we preserve the correct operand order */

    if  (rev)
    {

#if TGT_SH3

        if  (useR0)
        {
            // UNDONE: Decide which operand to generate into r0

            anyMask = RBM_r00;
        }

#endif

        /* Generate the second operand first */

        genCodeForTree(rv2, regMask);
        rsMarkRegUsed(rv2, oper);

        /* Generate the first operand second */

        genCodeForTree(rv1, regMask);
        rsMarkRegUsed(rv1, oper);

        /* Free up both operands in the right order (they might be
           re-marked as used below)
        */

        rsLockUsedReg  (genRegMask(rv1->gtRegNum));
        genReleaseReg(rv2);
        rsUnlockUsedReg(genRegMask(rv1->gtRegNum));
        genReleaseReg(rv1);
    }
    else
    {

#if TGT_SH3

        if  (useR0)
        {
            // UNDONE: Decide which operand to generate into r0

            anyMask = RBM_r00;
        }

#endif

        /* Get the first operand into a register */

        genCodeForTree(rv1, anyMask & ~rv2->gtRsvdRegs);

    GEN_RV2:

        /* Here the 'rv1' operand is in a register but 'rv2' isn't */

        assert(rv1->gtFlags & GTF_REG_VAL);

        /* Hang on to the first operand */

        rsMarkRegUsed(rv1, oper);

        /* Generate the second operand as well */

        genCodeForTree(rv2, regMask);
        rsMarkRegUsed(rv2, oper);

        /* Free up both operands in the right order (they might be
           re-marked as used below)
        */
        rsLockUsedReg  (genRegMask(rv2->gtRegNum));
        genReleaseReg(rv1);
        rsUnlockUsedReg(genRegMask(rv2->gtRegNum));
        genReleaseReg(rv2);
    }

    /*-------------------------------------------------------------------------
     *
     * At this piont, both rv1 and rv2 (if present) are in registers
     *
     */

DONE_REGS:

    /* We must verify that 'rv1' and 'rv2' are both sitting in registers */

    if  (rv1 && !(rv1->gtFlags & GTF_REG_VAL)) return false;
    if  (rv2 && !(rv2->gtFlags & GTF_REG_VAL)) return false;

#if TGT_SH3 && defined(DEBUG)

    /* If we decided we had to use R0, it better really be used */

    if  (useR0 && !deferOK)
    {
        assert(rv1 && rv2);

        assert(rv1->gtRegNum == REG_r00 ||
               rv2->gtRegNum == REG_r00);
    }

#endif

YES:

    // *(intVar1+intVar1) causes problems as we
    // call rsMarkRegUsed(op1) and rsMarkRegUsed(op2). So the calling function
    // needs to know that it has to call rsFreeReg(reg1) twice. We cant do
    // that currently as we return a single mask in useMaskPtr.

    if ((keepReg == KEEP_REG) && oper && rv1 && rv2 &&
        (rv1->gtFlags & rv2->gtFlags & GTF_REG_VAL))
    {
        if (rv1->gtRegNum == rv2->gtRegNum)
            return false;
    }

    /* Do we have a legal address mode combination? */

    if  (oper) oper->gtFlags &= ~GTF_DEF_ADDRMODE;

#if TGT_SH3

    /* Is there a non-zero displacement? */

    if  (cns)
    {
        /* Negative displacement are never allowed */

        if  (cns < 0)
            return  false;

        /* Can't have "dsp" or "rg1+rg2+dsp" as address modes */

        if  (rv1 == NULL)
            return  false;
        if  (rv2 != NULL)
            return  false;

        /* Make sure the displacement is withing range */
        /* [ISSUE: do we need to check alignment here?] */

        if  ((unsigned)cns >= 16U * genTypeSize(optp))
            return  false;

        genAddressMode = AM_IND_REG1_DISP;
        goto DONE_AM;
    }

    /* Do we have to use "R0" ? */

    if  (useR0)
    {
        /* We should have two operands and r0 should be free, right? */

        assert(rv1);
        assert(rv2);

        assert(rsRegMaskFree() & RBM_r00);

        /* Is either operand loaded into R0 ? */

        if  (rv1->gtRegNum != REG_r00 &&
             rv2->gtRegNum != REG_r00)
        {
            /* We'll need to load one operand into R0, should we do it now? */

            if  (deferOK && oper)
            {
                oper->gtFlags |= GTF_DEF_ADDRMODE;
            }
            else
            {
                /* Move one of the operands to R0 */

                // ISSUE: Which operand should be moved to R0????

                genComputeReg(rv1, RBM_r00, EXACT_REG, FREE_REG, false);

                genAddressMode = AM_IND_REG1_REG0;
            }
        }
    }

DONE_AM:

#endif

    /* Check either register operand to see if it needs to be saved */

    if  (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);

        if  (keepReg == KEEP_REG)
        {
            rsMarkRegUsed(rv1, oper);
        }
        else
        {
            /* Mark the register as holding an address */

            switch(rv1->gtType)
            {
            case TYP_REF:   gcMarkRegSetGCref(regMask); break;
            case TYP_BYREF: gcMarkRegSetByref(regMask); break;
            }
        }
    }

    if  (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);

        if (keepReg == KEEP_REG)
            rsMarkRegUsed(rv2, oper);
    }

    if  (deferOK)
        return  true;

    /* Is this an array index that needs to be range-checked? */

    if  (operIsChkdArr)
    {
        genRangeCheck(oper, rv1, rv2, ixv, regMask, keepReg);
    }
    else
    {
        /*  Special case: a class member might reside at a very large offset,
            and access to such a member via a null pointer may not be trapped
            by the hardware on some architectures/platforms.

            To get around this, if the member offset is larger than some safe
            (but hopefully large) value, we generate "cmp al, [addr]" to make
            sure we try to access the base address of the object and thus trap
            any use of a null pointer.

            For now, we pick an arbitrary offset limit of 32K.
         */

        size_t offset =  cns;

        if  (mode != 1 && offset > MAX_UNCHECKED_OFFSET_FOR_NULL_OBJECT)
        {
            // For C indirections, the address can be in any form.
            // rv1 may not be the base, and rv2 the index.
            // Consider (0x400000 + 8*i) --> rv1=NULL, rv2=i, mul=8, and
            // cns=0x400000. So the base is actually in 'cns'
            // So we cant do anything. But trap non-C indirections.

            if (varTypeIsGC(addr->TypeGet()))
            {
                /* Make sure we have an address */

                assert(rv1->gtType == TYP_REF);

                /* Generate "cmp dl, [addr]" to trap null pointers */

//              inst_RV_AT(INS_cmp, 1, TYP_BYTE, REG_EDX, rv1, 0);
                assert(!"need non-x86 code");
            }
        }
    }

    /* Compute the set of registers the address depends on */

    regMaskTP  useMask = RBM_NONE;

    if (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv1->gtRegNum);
    }

    if (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv2->gtRegNum);
    }

    /* Tell the caller which registers we need to hang on to */

    *useMaskPtr = useMask;

    return true;
}

#if CSELENGTH

regNumber           Compiler::genEvalCSELength(GenTreePtr   ind,
                                               GenTreePtr   adr,
                                               GenTreePtr   ixv,
                                               regMaskTP *  regMaskPtr)
{
    assert(!"NYI");
    return  REG_NA;
}

#endif

void                Compiler::genRangeCheck(GenTreePtr  oper,
                                            GenTreePtr  rv1,
                                            GenTreePtr  rv2,
                                            long        ixv,
                                            regMaskTP   regMask,
                                            KeepReg     keptReg)
{
    assert(!"NYI");
}

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************
 *
 *  If an array length CSE is present and has been enregistered, return
 *  the register's mask; otherwise return 0.
 */

#if CSELENGTH

regMaskTP           Compiler::genCSEevalRegs(GenTreePtr tree)
{
    assert(tree->gtOper == GT_ARR_LENREF);

    GenTreePtr      cse = tree->gtArrLen.gtArrLenCse;

    if  (cse)
    {
        if  (cse->gtOper == GT_COMMA)
        {
            unsigned        varNum;
            LclVarDsc   *   varDsc;

            cse = cse->gtOp.gtOp2; assert(cse->gtOper == GT_LCL_VAR);

            /* Does the variable live in a register? */

            varNum = cse->gtLclVar.gtLclNum;
            assert(varNum < lvaCount);
            varDsc = lvaTable + varNum;

            if  (varDsc->lvRegister)
                return  genRegMask(varDsc->lvRegNum);
        }
    }

    return  0;
}

#endif

/*****************************************************************************
 *
 * If compiling without REDUNDANT_LOAD, same as genMakeAddressable().
 * Otherwise, check if rvalue is in register. If so, mark it. Then
 * call genMakeAddressable(). Needed because genMakeAddressable is used
 * for both lvalue and rvalue, and we only can do this for rvalue.
 */

inline
regMaskTP           Compiler::genMakeRvalueAddressable(GenTreePtr   tree,
                                                       regMaskTP    needReg,
                                                       KeepReg      keepReg,
                                                       bool         smallOK)
{
    regNumber reg;

#if SCHEDULER
    if  (tree->gtOper == GT_IND && tree->gtType == TYP_INT)
    {
        if  (rsRiscify(tree->TypeGet(), needReg))
        {
            genCodeForTree(tree, needReg);
            goto RET;
        }
    }
#endif

#if REDUNDANT_LOAD

    if (tree->gtOper == GT_LCL_VAR)
    {
        reg = rsLclIsInReg(tree->gtLclVar.gtLclNum);

        if (reg != REG_NA && (needReg == 0 || (genRegMask(reg) & needReg) != 0))
        {
            assert(isRegPairType(tree->gtType) == false);

            tree->gtRegNum = reg;
            tree->gtFlags |=  GTF_REG_VAL;
        }
#if SCHEDULER
        else if (!varTypeIsGC(tree->TypeGet()) && rsRiscify(tree->TypeGet(), needReg))
        {
            genCodeForTree(tree, needReg);
        }
#endif
    }

#endif

#if SCHEDULER
RET:
#endif

    return genMakeAddressable(tree, needReg, keepReg, smallOK);
}

/*****************************************************************************/
#if TGT_RISC
/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable() with a
 *  non-zero value for "deferOK"; return non-zero if the address mode has
 *  not yet been fully formed.
 */

inline
bool                Compiler::genDeferAddressable(GenTreePtr tree)
{
    return  (tree->gtFlags & GTF_DEF_ADDRMODE) != 0;
}

inline
regMaskTP           Compiler::genNeedAddressable(GenTreePtr tree,
                                                 regMaskTP  addrReg,
                                                 regMaskTP  needReg)
{
    /* Clear the "deferred" address mode flag */

    assert(tree->gtFlags & GTF_DEF_ADDRMODE); tree->gtFlags &= ~GTF_DEF_ADDRMODE;

    /* Free up the old address register(s) */

    rsMarkRegFree(addrReg);

    /* Now try again, this time disallowing any deferral */

    return  genMakeAddressable(tree, needReg, KEEP_REG, true, false);
}

/*****************************************************************************/
#endif//TGT_RISC


bool Compiler::genIsLocalLastUse    (GenTreePtr     tree)
{
    LclVarDsc * varDsc;

    varDsc = &lvaTable[tree->gtLclVar.gtLclNum];    
   
    assert(tree->OperGet() == GT_LCL_VAR);
    assert(varDsc->lvTracked);

    VARSET_TP varBit  = genVarIndexToBit(varDsc->lvVarIndex);
    return ((tree->gtLiveSet & varBit) == 0);    
}
                

/*****************************************************************************
 *
 *  This is genMakeAddressable(GT_ARR_ELEM).
 *  Makes the array-element addressible and returns the addressibility registers.
 *  It also marks them as used if keepReg==KEEP_REG.
 *  tree is the dependant tree.
 *
 *  Note that an array-element needs 2 registers to be addressibile, the
 *  array-object and the offset. This function marks gtArrObj and gtArrInds[0]
 *  with the 2 registers so that other functions (like instGetAddrMode()) know
 *  where to look for the offset to use.
 */

regMaskTP           Compiler::genMakeAddrArrElem(GenTreePtr     arrElem,
                                                 GenTreePtr     tree,
                                                 regMaskTP      needReg,
                                                 KeepReg        keepReg)
{
    assert(arrElem->gtOper == GT_ARR_ELEM);
    assert(!tree || tree->gtOper == GT_IND || tree == arrElem);

    /* Evaluate all the operands. We dont evaluate them into registers yet
       as GT_ARR_ELEM does not reorder the evaluation of the operands, and
       hence may use a sub-optimal ordering. We try to improve this
       situation somewhat by accessing the operands in stages
       (genMakeAddressable2 + genComputeAddressable and
       genCompIntoFreeReg + genRecoverReg).

       Note: we compute operands into free regs to avoid multiple uses of
       the same register. Multi-use would cause problems when we free
       registers in FIFO order instead of the assumed LIFO order that
       applies to all type of tree nodes except for GT_ARR_ELEM.
     */

    GenTreePtr  arrObj  = arrElem->gtArrElem.gtArrObj;
    unsigned    rank    = arrElem->gtArrElem.gtArrRank;

    regMaskTP   addrReg = 0;

    // If the array ref is a stack var that's dying here we have to move it
    // into a register (regalloc already counts of this), as if it's a GC pointer
    // it can be collected from here on. This is not an issue for locals that are
    // in a register, as they get marked as used an will be tracked.
    // The bug that caused this is #100776. (untracked vars?)
    if (arrObj->OperGet() == GT_LCL_VAR &&
        optIsTrackedLocal(arrObj) &&
        genIsLocalLastUse(arrObj) &&
        !genMarkLclVar(arrObj))
    {
        genCodeForTree(arrObj, RBM_NONE);
        rsMarkRegUsed(arrObj, 0);
        addrReg = genRegMask(arrObj->gtRegNum);
    }
    else
    {
    addrReg = genMakeAddressable2(
                    arrObj,
                    RBM_NONE,
                    KEEP_REG,
                    false,      // smallOK
                    false,      // deferOK
                    true,       // evalSideEffs
                    false);     // evalConsts
    }

    for(unsigned dim = 0; dim < rank; dim++)
        genCompIntoFreeReg(arrElem->gtArrElem.gtArrInds[dim], RBM_NONE, KEEP_REG);

    /* Ensure that the array-object is in a register */

    addrReg = genKeepAddressable(arrObj, addrReg);
    genComputeAddressable(arrObj, addrReg, KEEP_REG, RBM_NONE, KEEP_REG);

    regNumber   arrReg = arrObj->gtRegNum;
    rsLockUsedReg(genRegMask(arrReg));

    /* Now process all the indices, do the range check, and compute
       the offset of the element */

    var_types   elemType = arrElem->gtArrElem.gtArrElemType;
    regNumber   accReg; // accumulates the offset calculation

    for(dim = 0; dim < rank; dim++)
    {
        GenTreePtr  index = arrElem->gtArrElem.gtArrInds[dim];

        /* Get the index into a free register */

        genRecoverReg(index, RBM_NONE, FREE_REG);
        
        /* Subtract the lower bound, and do the range check */

        genEmitter->emitIns_R_AR(
                        INS_sub, EA_4BYTE,
                        emitRegs(index->gtRegNum),
                        emitRegs(arrReg),
                        ARR_DIMCNT_OFFS(elemType) + sizeof(int) * (dim + rank));
        rsTrackRegTrash(index->gtRegNum);

        genEmitter->emitIns_R_AR(
                        INS_cmp, EA_4BYTE,
                        emitRegs(index->gtRegNum),
                        emitRegs(arrReg),
                        ARR_DIMCNT_OFFS(elemType) + sizeof(int) * dim);

        genJumpToThrowHlpBlk(EJ_jae, ACK_RNGCHK_FAIL);

        // The ordering must be maintined for fully interruptible code, or else
        // in the case that the range check fails, it is possible to GC with a byref
        // that contains the address of the array element which is out of range.

#if SCHEDULER
        if (opts.compSchedCode)
        {
            genEmitter->emitIns_SchedBoundary();
        }
#endif

        if (dim == 0)
        {
            /* Hang on to the register of the first index */

            accReg = index->gtRegNum;
            rsMarkRegUsed(index);
            rsLockUsedReg(genRegMask(accReg));
        }
        else
        {
            /* Evaluate accReg = accReg*dim_size + index */

            genEmitter->emitIns_R_AR(
                        INS_imul, EA_4BYTE,
                        emitRegs(accReg),
                        emitRegs(arrReg),
                        ARR_DIMCNT_OFFS(elemType) + sizeof(int) * dim);

            inst_RV_RV(INS_add, accReg, index->gtRegNum);
            rsTrackRegTrash(accReg);
        }
    }

    if (!jitIsScaleIndexMul(arrElem->gtArrElem.gtArrElemSize))
    {
        regNumber   sizeReg = rsPickReg();
        genSetRegToIcon(sizeReg, arrElem->gtArrElem.gtArrElemSize);

        genEmitter->emitIns_R_R(INS_imul, EA_4BYTE, emitRegs(accReg), emitRegs(sizeReg));
        rsTrackRegTrash(accReg);
    }

    rsUnlockUsedReg(genRegMask(arrReg));
    rsUnlockUsedReg(genRegMask(accReg));

    rsMarkRegFree(genRegMask(arrReg));
    rsMarkRegFree(genRegMask(accReg));

    if (keepReg == KEEP_REG)
    {
        /* We mark the addressability registers on arrObj and gtArrInds[0].
           instGetAddrMode() knows to work with this. */

        rsMarkRegUsed(arrObj,                          tree);
        rsMarkRegUsed(arrElem->gtArrElem.gtArrInds[0], tree);
    }

    return genRegMask(arrReg) | genRegMask(accReg);
}

/*****************************************************************************
 *
 *  Make sure the given tree is addressable.  'needReg' is a mask that indicates
 *  the set of registers we would prefer the destination tree to be computed
 *  into (0 means no preference).
 *
 *  'tree' can subsequently be used with the inst_XX_TT() family of functions.
 *
 *  If 'keepReg' is KEEP_REG, we mark any registers the addressability depends
 *  on as used, and return the mask for that register set. (if no registers
 *  are marked as used, 0 is returned). 
 *
 *  If 'smallOK' is not true and the datatype being address is a byte or short,
 *  then the tree is forced into a register.  This is useful when the machine
 *  instruction being emitted does not have a byte or short version.
 *
 *  The "deferOK" parameter indicates the mode of operation - when it's false,
 *  upon returning an actual address mode must have been formed (i.e. it must
 *  be possible to immediately call one of the inst_TT methods to operate on
 *  the value). When "deferOK" is true, we do whatever it takes to be ready
 *  to form the address mode later - for example, if an index address mode on
 *  a particular CPU requires the use of a specific register, we usually don't
 *  want to immediately grab that register for an address mode that will only
 *  be needed later. The convention is to call genMakeAddressable() is with
 *  "deferOK" equal to true, do whatever work is needed to prepare the other
 *  operand, call genMakeAddressable() with "deferOK" equal to false, and
 *  finally call one of the inst_TT methods right after that.
 *
 *  If we do any other codegen after genMakeAddressable(tree) which can
 *  potentially spill the addressability registers, genKeepAddressable()
 *  needs to be called before accessing the tree again.
 *
 *  genDoneAddressable() needs to be called when we are done with the tree
 *  to free the addressability registers.
 */

regMaskTP           Compiler::genMakeAddressable(GenTreePtr   tree,
                                                 regMaskTP    needReg,
                                                 KeepReg      keepReg,
                                                 bool         smallOK,
                                                 bool         deferOK)
{
    GenTreePtr      addr = NULL;
    regMaskTP       regMask;

    /* Is the value simply sitting in a register? */

    if  (tree->gtFlags & GTF_REG_VAL)
    {
        genUpdateLife(tree);

#if TGT_RISC
        genAddressMode = AM_REG;
#endif
        goto GOT_VAL;
    }

    // UNDONE: If the value is for example a cast of float -> int, compute
    // UNDONE: the converted value into a stack temp, and leave it there,
    // UNDONE: since stack temps are always addressable. This would require
    // UNDONE: recording the fact that a particular tree is in a stack temp.

#if TGT_x86

    /* byte/char/short operand -- is this acceptable to the caller? */

    if (varTypeIsSmall(tree->TypeGet()) && !smallOK)
        goto EVAL_TREE;

#endif

    switch (tree->gtOper)
    {
    case GT_LCL_FLD:

        // We only use GT_LCL_FLD for lvAddrTaken vars, so we dont have
        // to worry about it being enregistered.
        assert(lvaTable[tree->gtLclFld.gtLclNum].lvRegister == 0);

#if TGT_RISC
        genAddressMode = AM_LCL;
#endif
        genUpdateLife(tree);
        return 0;


    case GT_LCL_VAR:

        if (!genMarkLclVar(tree))
        {
#if TGT_RISC
            genAddressMode = AM_LCL;
#endif
            genUpdateLife(tree);
            return 0;
        }
        // Fall through, it turns out the variable lives in a register

    case GT_REG_VAR:

        genUpdateLife(tree);

#if TGT_RISC
        genAddressMode = AM_REG;
#endif
        goto GOT_VAL;

    case GT_CLS_VAR:

#if !TGT_x86
        // ISSUE: Is this acceptable?

        genAddressMode = AM_GLOBAL;

#endif

        return 0;

    case GT_CNS_INT:
    case GT_CNS_LNG:
    case GT_CNS_DBL:
#if TGT_RISC
        genAddressMode = AM_CONS;
#endif
        return 0;


    case GT_IND:

        /* Try to make the address directly addressable */

        if  (genMakeIndAddrMode(tree->gtInd.gtIndOp1,
                                tree,
                                false,
                                needReg,
                                keepReg,
                                &regMask,
                                deferOK))
        {
            genUpdateLife(tree);
            return regMask;
        }

        /* No good, we'll have to load the address into a register */

        addr = tree;
        tree = tree->gtInd.gtIndOp1;
        break;


    case GT_ARR_ELEM:

        return genMakeAddrArrElem(tree, tree, needReg, keepReg);
    }

EVAL_TREE:

    /* Here we need to compute the value 'tree' into a register */

    genCodeForTree(tree, needReg);

#if TGT_RISC
    genAddressMode = AM_REG;
#endif

GOT_VAL:

    assert(tree->gtFlags & GTF_REG_VAL);

    if  (isRegPairType(tree->gtType))
    {
        /* Are we supposed to hang on to the register? */

        if (keepReg == KEEP_REG)
            rsMarkRegPairUsed(tree);

        regMask = genRegPairMask(tree->gtRegPair);
    }
    else
    {
        /* Are we supposed to hang on to the register? */

        if (keepReg == KEEP_REG)
            rsMarkRegUsed(tree, addr);

        regMask = genRegMask(tree->gtRegNum);
    }

    return  regMask;
}

/*****************************************************************************
 *  Compute a tree (which was previously made addressable using
 *  genMakeAddressable()) into a register.
 *  needReg - mask of preferred registers.
 *  keepReg - should the computed register be marked as used by the tree
 *  freeOnly - target register needs to be a scratch register
 */

void        Compiler::genComputeAddressable(GenTreePtr  tree,
                                            regMaskTP   addrReg,
                                            KeepReg     keptReg,
                                            regMaskTP   needReg,
                                            KeepReg     keepReg,
                                            bool        freeOnly)
{
    assert(genStillAddressable(tree));
    assert(varTypeIsIntegral(tree->gtType) || varTypeIsI(tree->gtType));

    genDoneAddressable(tree, addrReg, keptReg);

    regNumber   reg;

    if (tree->gtFlags & GTF_REG_VAL)
    {
        reg = tree->gtRegNum;

        if (freeOnly && !(genRegMask(reg) & rsRegMaskFree()))
            goto MOVE_REG;
    }
    else
    {
        if (tree->OperIsConst())
        {
            /* Need to handle consts separately as we dont want to emit
              "mov reg, 0" (emitter doesnt like that). Also, genSetRegToIcon() 
              handles consts better for SMALL_CODE */

            reg = rsPickReg(needReg);

            /* ISSUE: We could call genCodeForTree() and get the benefit
               of rsIconIsInReg(). However, genCodeForTree() would update
               liveness to tree->gtLiveSet which could be incorrect. If
               we cared, we could handle such cases appropriately. */

            assert(tree->gtOper == GT_CNS_INT);
            genSetRegToIcon(reg, tree->gtIntCon.gtIconVal, tree->gtType);
        }
        else
        {
        MOVE_REG:
            reg = rsPickReg(needReg);

            inst_RV_TT(INS_mov, reg, tree);
            rsTrackRegTrash(reg);
        }
    }

    /* Mark the tree as living in the register */

    tree->gtRegNum = reg;
    tree->gtFlags |= GTF_REG_VAL;

    if (keepReg == KEEP_REG)
        rsMarkRegUsed(tree);
    else
        gcMarkRegPtrVal(tree);
}

/*****************************************************************************
 *  Should be similar to genMakeAddressable() but gives more control.
 */

regMaskTP       Compiler::genMakeAddressable2(GenTreePtr    tree,
                                              regMaskTP     needReg,
                                              KeepReg       keepReg,
                                              bool          smallOK,
                                              bool          deferOK,
                                              bool          evalSideEffs,
                                              bool          evalConsts)
{
    if ((evalConsts && tree->OperIsConst()) ||
        (evalSideEffs && tree->gtOper == GT_IND && (tree->gtFlags & GTF_EXCEPT)))
    {
        genCodeForTree(tree, needReg);
        
        assert(tree->gtFlags & GTF_REG_VAL);

        if  (isRegPairType(tree->gtType))
        {
            /* Are we supposed to hang on to the register? */

            if (keepReg == KEEP_REG)
                rsMarkRegPairUsed(tree);

            return genRegPairMask(tree->gtRegPair);
        }
        else
        {
            /* Are we supposed to hang on to the register? */

            if (keepReg == KEEP_REG)
                rsMarkRegUsed(tree);

            return genRegMask(tree->gtRegNum);
        }
    }
    else
    {
        return genMakeAddressable(tree, needReg, keepReg, smallOK, deferOK);
    }
}

/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable(); return
 *  non-zero if the operand is still addressable.
 */

inline
bool                Compiler::genStillAddressable(GenTreePtr tree)
{

#if TGT_RISC
    assert((tree->gtFlags & GTF_DEF_ADDRMODE) == 0);
#endif

    /* Has the value (or one or more of its sub-operands) been spilled? */

    if  (tree->gtFlags & (GTF_SPILLED|GTF_SPILLED_OPER))
        return  false;

    return  true;
}

/*****************************************************************************
 *
 *  Recursive helper to restore complex address modes. The 'lockPhase'
 *  argument indicates whether we're in the 'lock' or 'reload' phase.
 */

regMaskTP           Compiler::genRestoreAddrMode(GenTreePtr   addr,
                                                 GenTreePtr   tree,
                                                 bool         lockPhase)
{
    regMaskTP  regMask = RBM_NONE;

    /* Have we found a spilled value? */

    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* Do nothing if we're locking, otherwise reload and lock */

        if  (!lockPhase)
        {
            /* Unspill the register */

            rsUnspillReg(tree, 0, FREE_REG);

            /* The value should now be sitting in a register */

            assert(tree->gtFlags & GTF_REG_VAL);
            regMask = genRegMask(tree->gtRegNum);

            /* Mark the register as used for the address */

            rsMarkRegUsed(tree, addr);

            /* Lock the register until we're done with the entire address */

            rsMaskLock |= regMask;
        }

        return  regMask;
    }

    /* Is this sub-tree sitting in a register? */

    if  (tree->gtFlags & GTF_REG_VAL)
    {
        regMask = genRegMask(tree->gtRegNum);

        /* Lock the register if we're in the locking phase */

        if  (lockPhase)
            rsMaskLock |= regMask;
    }
    else
    {
        /* Process any sub-operands of this node */

        unsigned        kind = tree->OperKind();

        if  (kind & GTK_SMPOP)
        {
            /* Unary/binary operator */

            if  (tree->gtOp.gtOp1)
                regMask |= genRestoreAddrMode(addr, tree->gtOp.gtOp1, lockPhase);
            if  (tree->gtGetOp2())
                regMask |= genRestoreAddrMode(addr, tree->gtOp.gtOp2, lockPhase);
        }
        else if (tree->gtOper == GT_ARR_ELEM)
        {
            /* gtArrObj is the array-object and gtArrInds[0] is marked with the register
               which holds the offset-calculation */

            regMask |= genRestoreAddrMode(addr, tree->gtArrElem.gtArrObj,     lockPhase);
            regMask |= genRestoreAddrMode(addr, tree->gtArrElem.gtArrInds[0], lockPhase);
        }
        else
        {
            /* Must be a leaf/constant node */

            assert(kind & (GTK_LEAF|GTK_CONST));
        }
    }

    return  regMask;
}

/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable, but since then
 *  some of its registers are known to have been spilled; do whatever it takes
 *  to make the operand addressable again (typically by reloading any spilled
 *  registers).
 */

regMaskTP           Compiler::genRestAddressable(GenTreePtr tree,
                                                 regMaskTP  addrReg,
                                                 regMaskTP  lockMask)
{
    assert((rsMaskLock & lockMask) == lockMask);

    /* Is this a 'simple' register spill? */

    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The mask must match the original register/regpair */

        if  (isRegPairType(tree->gtType))
        {
            assert(addrReg == genRegPairMask(tree->gtRegPair));

            rsUnspillRegPair(tree, 0, KEEP_REG);

            addrReg = genRegPairMask(tree->gtRegPair);
        }
        else
        {
            assert(addrReg == genRegMask(tree->gtRegNum));

            rsUnspillReg(tree, 0, KEEP_REG);

            addrReg = genRegMask(tree->gtRegNum);
        }

        assert((rsMaskLock &  lockMask) == lockMask);
                rsMaskLock -= lockMask;

        return  addrReg;
    }

    /* We have a complex address mode with some of its sub-operands spilled */

    assert((tree->gtFlags & GTF_REG_VAL     ) == 0);
    assert((tree->gtFlags & GTF_SPILLED_OPER) != 0);

    /*
        We'll proceed in several phases:

         1. Lock any registers that are part of the address mode and
            have not been spilled. This prevents these registers from
            getting spilled in step 2.

         2. Reload any registers that have been spilled; lock each
            one right after it is reloaded.

         3. Unlock all the registers.
     */

    addrReg   = genRestoreAddrMode(tree, tree,  true);
    addrReg  |= genRestoreAddrMode(tree, tree, false);

    /* Unlock all registers that the address mode uses */

    lockMask |= addrReg;

    assert((rsMaskLock &  lockMask) == lockMask);
            rsMaskLock -= lockMask;

    return  addrReg;
}

/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable, but since then
 *  some of its registers might have been spilled ('addrReg' is the set of
 *  registers used by the address). This function makes sure the operand is
 *  still addressable (while avoiding any of the registers in 'avoidMask'),
 *  and returns the (possibly modified) set of registers that are used by
 *  the address (these will be marked as used on exit).
 */

regMaskTP           Compiler::genKeepAddressable(GenTreePtr   tree,
                                                 regMaskTP    addrReg,
                                                 regMaskTP    avoidMask)
{
    /* Is the operand still addressable? */

    if  (!genStillAddressable(tree))
    {
        /* Temporarily lock 'avoidMask' while we restore addressability */
        /* genRestAddressable will unlock the 'avoidMask' for us */

        assert((rsMaskLock &  avoidMask) == 0);
                rsMaskLock |= avoidMask;

        addrReg = genRestAddressable(tree, addrReg, avoidMask);

        assert((rsMaskLock &  avoidMask) == 0);
    }

    return  addrReg;
}

/*****************************************************************************
 *
 *  After we're finished with the given operand (which was previously marked
 *  by calling genMakeAddressable), this function must be called to free any
 *  registers that may have been used by the address.
 *  keptReg indicates if the addressability registers were marked as used
 *  by genMakeAddressable().
 */

inline
void                Compiler::genDoneAddressable(GenTreePtr tree,
                                                 regMaskTP  addrReg,
                                                 KeepReg    keptReg)
{
    if (keptReg == FREE_REG)
    {
        /* addrReg was not marked as used. So just reset its GC info */

        addrReg &= ~rsMaskUsed;
        if (addrReg)
        {
            gcMarkRegSetNpt(addrReg);
        }
    }
    else
    {
        /* addrReg was marked as used. So we need to free it up (which
           will also reset its GC info) */

        rsMarkRegFree(addrReg);
    }
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Make sure the given floating point value is addressable, and return a tree
 *  that will yield the value as an addressing mode (this tree may differ from
 *  the one passed in, BTW). If the only way to make the value addressable is
 *  to evaluate into the FP stack, we do this and return zero.
 */

GenTreePtr          Compiler::genMakeAddrOrFPstk(GenTreePtr   tree,
                                                 regMaskTP *  regMaskPtr,
                                                 bool         roundResult)
{
    *regMaskPtr = 0;

    switch (tree->gtOper)
    {
    case GT_LCL_VAR:
    case GT_LCL_FLD:
    case GT_CLS_VAR:
        return tree;

    case GT_CNS_DBL:
        if (tree->gtType == TYP_FLOAT) 
        {
            float f = tree->gtDblCon.gtDconVal;
            return  genMakeConst(&f, sizeof(float ), TYP_FLOAT, tree, false, true);
        }
        return  genMakeConst(&tree->gtDblCon.gtDconVal, sizeof(double), tree->gtType, tree, true, true);

    case GT_IND:

        /* Try to make the address directly addressable */

        if  (genMakeIndAddrMode(tree->gtInd.gtIndOp1,
                                tree,
                                false,
                                0,
                                FREE_REG,
                                regMaskPtr,
                                false))
        {
            genUpdateLife(tree);
            return tree;
        }

        break;
    }

    /* We have no choice but to compute the value 'tree' onto the FP stack */

    genCodeForTreeFlt(tree, roundResult);

    return 0;
}

/*****************************************************************************
 *
 *  Generate the "SUB ESP, <sz>" that makes room on the stack for a float
 *  argument.
 */

void                Compiler::genFltArgPass(size_t *argSzPtr)
{
    assert(argSzPtr);

    size_t          sz = *argSzPtr;

    inst_RV_IV(INS_sub, REG_ESP, sz);

    genSinglePush(false);

    if  (sz == 2*sizeof(unsigned))
        genSinglePush(false);

    *argSzPtr = 0;
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************
 *
 *  Display a string literal value (debug only).
 */

#ifdef  DEBUG
#endif

/*****************************************************************************
 *
 *  The following awful hack used as a last resort in tracking down random
 *  crash bugs.
 */

#if GEN_COUNT_CODE

unsigned            methodCount;

static
void                genMethodCount()
{
    //  FF 05   <ADDR>                  inc dword ptr [classVar]

    genEmitter.emitCodeGenByte(0xFF);
    genEmitter.emitCodeGenByte(0x05);
    genEmitter.emitCodeGenLong((int)&methodCount);

    //  81 3D   <ADDR>    NNNNNNNN      cmp dword ptr [classVar], NNNNNNNN

    genEmitter.emitCodeGenByte(0x81);
    genEmitter.emitCodeGenByte(0x3D);
    genEmitter.emitCodeGenLong((int)&methodCount);
    genEmitter.emitCodeGenLong(0x0000c600);

    //  75 01                           jne short nope

    genEmitter.emitCodeGenByte(0x75);
    genEmitter.emitCodeGenByte(0x01);

    //  CC                              int 3
    instGen(INS_int3);

    //                      nope:

}

#else

inline
void                genMethodCount(){}

#endif

/*****************************************************************************
 *
 *  Generate an exit sequence for a return from a method (note: when compiling
 *  for speed there might be multiple exit points).
 */

void                Compiler::genExitCode(bool endFN)
{
#ifdef DEBUGGING_SUPPORT
    /* Just wrote the first instruction of the epilog - inform debugger
       Note that this may result in a duplicate IPmapping entry, and
       that this is ok  */

    if (opts.compDbgInfo)
    {
        //for nonoptimized debuggable code, there is only one epilog
        genIPmappingAdd(ICorDebugInfo::MappingTypes::EPILOG, true);
    }
#endif //DEBUGGING_SUPPORT

    genEmitter->emitBegEpilog();

    genMethodCount();

    if  (genFullPtrRegMap)
    {
        if (varTypeIsGC(info.compRetType))
        {
            assert(genTypeStSz(info.compRetType) == genTypeStSz(TYP_INT));

            gcMarkRegPtrVal(REG_INTRET, info.compRetType);

//          genEmitter->emitSetGClife(gcVarPtrSetCur, gcRegGCrefSetCur, gcRegByrefSetCur);
        }
    }

#if     TGT_x86

    /* Check if this a special return block i.e.
     * CEE_JMP or CEE_JMPI instruction */

    if  (compCurBB->bbFlags & BBF_HAS_JMP)
    {
        assert(compCurBB->bbJumpKind == BBJ_RETURN);
        assert(compCurBB->bbTreeList);

        /* figure out what jump we have */

        GenTreePtr jmpNode = compCurBB->bbTreeList->gtPrev;

        assert(jmpNode && (jmpNode->gtNext == 0));
        assert(jmpNode->gtOper == GT_STMT);

        jmpNode = jmpNode->gtStmt.gtStmtExpr;
        assert(jmpNode->gtOper == GT_JMP || jmpNode->gtOper == GT_JMPI);

        if  (jmpNode->gtOper == GT_JMP)
        {
            CORINFO_METHOD_HANDLE  methHnd    = (CORINFO_METHOD_HANDLE)jmpNode->gtVal.gtVal1;
            InfoAccessType         accessType = IAT_VALUE;

            // in/direct access ?
            eeGetMethodEntryPoint(methHnd, &accessType);
            assert(accessType == IAT_VALUE || accessType == IAT_PVALUE);

            emitter::EmitCallType  callType = (accessType == IAT_VALUE) ? emitter::EC_FUNC_TOKEN
                                                                        : emitter::EC_FUNC_TOKEN_INDIR;

            /* Simply emit a jump to the methodHnd
             * This is similar to a call so we can use
             * the same descriptor with some minor adjustments */

            genEmitter->emitIns_Call(callType,
                                     (void *)methHnd,
                                     0,                     /* argSize */
                                     0,                     /* retSize */
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur,
                                     SR_NA, SR_NA, 0, 0,    /* ireg, xreg, xmul, disp */
                                     true);                 /* isJump */
        }
        else
        {
            /* We already have the pointer in EAX - Do a 'jmp EAX' */

            genEmitter->emitIns_R(INS_i_jmp, EA_4BYTE, (emitRegs)REG_EAX);
        }

        /* finish the epilog */

        goto DONE_EMIT;
    }

    /* Return, popping our arguments (if any) */

    assert(compArgSize < 0x10000); // "ret" only has 2 byte operand


        // varargs has caller pop
    if (info.compIsVarArgs)
        instGen(INS_ret);
    else
    {
        // @TODO [CONSIDER] [04/16/01] []: check if compArgSize is not used anywhere 
        // else as the total size of arguments and then update it in lclvars.cpp
        assert(compArgSize >= rsCalleeRegArgNum * sizeof(void *));
        if (compArgSize - (rsCalleeRegArgNum * sizeof(void *)))
            inst_IV(INS_ret, compArgSize - (rsCalleeRegArgNum * sizeof(void *)));
        else
            instGen(INS_ret);
    }

#elif   TGT_SH3

    /* Check for CEE_JMP or CEE_JMPI */
    if  (compCurBB->bbFlags & BBF_HAS_JMP)
        assert(!"NYI for SH3!");

    /* Generate "rts", and optionally fill in the branch-delay slot */

    if  (genEmitter->emitIns_BD(INS_rts))
        genEmitter->emitIns(INS_nop);

#else

    assert(!"unexpected target");

#endif

DONE_EMIT:

    genEmitter->emitEndEpilog(endFN);
}

    

/*****************************************************************************
 *
 *  Generate any side effects within the given expression tree.
 */

void                Compiler::genEvalSideEffects(GenTreePtr tree)
{
    genTreeOps      oper;
    unsigned        kind;

AGAIN:

    /* Does this sub-tree contain any side-effects? */

    if  (tree->gtFlags & GTF_SIDE_EFFECT)
    {
        /* Remember the current FP stack level */

        unsigned savFPstkLevel = genFPstkLevel;

        if (tree->gtOper == GT_IND)
        {
            regMaskTP addrReg = genMakeAddressable(tree, RBM_ALL, KEEP_REG, true, false);

            if  (tree->gtFlags & GTF_REG_VAL)
            {
                gcMarkRegPtrVal(tree);
            }
            else
            {
                /* Compare against any register */
                inst_TT_RV(INS_cmp, tree, REG_EAX);
            }

            /* Free up anything that was tied up by the LHS */
            genDoneAddressable(tree, addrReg, KEEP_REG);
        }
        else
        {
            /* Generate the expression and throw it away */
            genCodeForTree(tree, RBM_ALL);
        if  (tree->gtFlags & GTF_REG_VAL)
            {
            gcMarkRegPtrVal(tree);
            }
        }

        /* If the tree computed a value on the FP stack, pop the stack */

        if  (genFPstkLevel > savFPstkLevel)
        {
            assert(genFPstkLevel == savFPstkLevel + 1);
            inst_FS(INS_fstp, 0);
            genFPstkLevel--;
        }

        return;
    }

    assert(tree->gtOper != GT_ASG);

    /* Walk the tree, just to mark any dead values appropriately */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
    {
        if ((oper == GT_REG_VAR) && isFloatRegType(tree->gtType) &&
            (tree->gtFlags & GTF_REG_DEATH))
        {
            assert(tree->gtRegVar.gtRegNum == 0);

            #if FPU_DEFEREDDEATH

            if (genFPstkLevel == 0)
            {
                inst_FS(INS_fstp, 0);
                genFPregVarDeath(tree);
            }
            else
            {
                // We will pop the variable off the FP stack later.
                genFPregVarDeath(tree, false);
            }            
            #else
            // Hack so that genFPmovRegTop does the right thing
            // (it expects the regvar to bubble up as counted in the evaluation
            //  stack, therefore we bump up the evaluation stack 1 slot)
            genFPstkLevel++;

            // fxch through any temps
            genFPmovRegTop();

            // throw away regvar
            inst_FS(INS_fstp, 0);

            genFPregVarDeath(tree);

            // Go back to where we were
            genFPstkLevel--;
            
            #endif
        }

        genUpdateLife(tree);
        gcMarkRegPtrVal (tree);
        return;
    }

#if CSELENGTH

    if  (oper == GT_ARR_LENREF)
    {
        genCodeForTree(tree, 0);
        return;
    }

#endif

    /* Must be a 'simple' unary/binary operator */

    assert(kind & GTK_SMPOP);

    if  (tree->gtGetOp2())
    {
        genEvalSideEffects(tree->gtOp.gtOp1);

        tree = tree->gtOp.gtOp2;
        goto AGAIN;
    }
    else
    {
        tree = tree->gtOp.gtOp1;
        if  (tree)
            goto AGAIN;
    }
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Spill the top of the FP stack into a temp, and return that temp.
 */

Compiler::TempDsc *     Compiler::genSpillFPtos(var_types type)
{
    TempDsc  *          temp = tmpGetTemp(type);
    emitAttr            size = EA_ATTR(genTypeSize(type));

    /* Pop the value from the FP stack into the temp */

    genEmitter->emitIns_S(INS_fstp, size, temp->tdTempNum(), 0);

    genFPstkLevel--;

    genTmpAccessCnt++;

    return temp;
}

/*****************************************************************************
 *
 *  Spill the top of the FP stack into a temp, and return that temp.
 */

inline
Compiler::TempDsc *     Compiler::genSpillFPtos(GenTreePtr oper)
{
    return  genSpillFPtos(oper->TypeGet());
}

/*****************************************************************************
 *
 *  Reload a previously spilled FP temp via the specified instruction (which
 *  could be something like 'fadd' or 'fcomp', or 'fld' in which case it is
 *  the caller's responsibility to bump the FP stack level).
 */

void                Compiler::genReloadFPtos(TempDsc *temp, instruction ins)
{
    emitAttr      size = EA_ATTR(genTypeSize(temp->tdTempType()));

    genEmitter->emitIns_S(ins, size, temp->tdTempNum(), 0);

    genTmpAccessCnt++;

    /* We no longer need the temp */

    tmpRlsTemp(temp);
}

/*****************************************************************************
 *
 *  A persistent pointer value is being overwritten, record it for the GC.
 */

regMaskTP           Compiler::WriteBarrier(GenTreePtr tgt,
                                           regNumber  reg,
                                           regMaskTP  addrReg)
{
    const static
    int regToHelper[2][8] =
    {
        // If the target is known to be in managed memory
        {
            CORINFO_HELP_ASSIGN_REF_EAX,
            CORINFO_HELP_ASSIGN_REF_ECX,
            -1,
            CORINFO_HELP_ASSIGN_REF_EBX,
            -1,
            CORINFO_HELP_ASSIGN_REF_EBP,
            CORINFO_HELP_ASSIGN_REF_ESI,
            CORINFO_HELP_ASSIGN_REF_EDI,
        },

        // Dont know if the target is in managed memory
        {
            CORINFO_HELP_CHECKED_ASSIGN_REF_EAX,
            CORINFO_HELP_CHECKED_ASSIGN_REF_ECX,
            -1,
            CORINFO_HELP_CHECKED_ASSIGN_REF_EBX,
            -1,
            CORINFO_HELP_CHECKED_ASSIGN_REF_EBP,
            CORINFO_HELP_CHECKED_ASSIGN_REF_ESI,
            CORINFO_HELP_CHECKED_ASSIGN_REF_EDI,
        },
    };

    regNumber       rg1;
    bool            trashOp1 = true;

    if  (!Compiler::gcIsWriteBarrierCandidate(tgt))
        return  0;

    assert(regToHelper[0][REG_EAX] == CORINFO_HELP_ASSIGN_REF_EAX);
    assert(regToHelper[0][REG_ECX] == CORINFO_HELP_ASSIGN_REF_ECX);
    assert(regToHelper[0][REG_EBX] == CORINFO_HELP_ASSIGN_REF_EBX);
    assert(regToHelper[0][REG_ESP] == -1                 );
    assert(regToHelper[0][REG_EBP] == CORINFO_HELP_ASSIGN_REF_EBP);
    assert(regToHelper[0][REG_ESI] == CORINFO_HELP_ASSIGN_REF_ESI);
    assert(regToHelper[0][REG_EDI] == CORINFO_HELP_ASSIGN_REF_EDI);

    assert(regToHelper[1][REG_EAX] == CORINFO_HELP_CHECKED_ASSIGN_REF_EAX);
    assert(regToHelper[1][REG_ECX] == CORINFO_HELP_CHECKED_ASSIGN_REF_ECX);
    assert(regToHelper[1][REG_EBX] == CORINFO_HELP_CHECKED_ASSIGN_REF_EBX);
    assert(regToHelper[1][REG_ESP] == -1                     );
    assert(regToHelper[1][REG_EBP] == CORINFO_HELP_CHECKED_ASSIGN_REF_EBP);
    assert(regToHelper[1][REG_ESI] == CORINFO_HELP_CHECKED_ASSIGN_REF_ESI);
    assert(regToHelper[1][REG_EDI] == CORINFO_HELP_CHECKED_ASSIGN_REF_EDI);

    assert(reg != REG_ESP && reg != REG_EDX);

#ifdef DEBUG
    if  (reg == REG_EDX)
    {
        printf("WriteBarrier: RHS == REG_EDX");
        if (rsMaskVars & RBM_EDX)
            printf(" (EDX is enregistered!)\n");
        else
            printf(" (just happens to be in EDX!)\n");
    }
#endif

    /*
        Generate the following code:

                lea     edx, tgt
                call    write_barrier_helper_reg

        First, we'll pick EDX for the target address.
     */

    if  ((addrReg & RBM_EDX) == 0)
    {
        rg1 = rsGrabReg(RBM_EDX);

        rsMaskUsed |= RBM_EDX;
        rsMaskLock |= RBM_EDX;

        trashOp1 = false;
    }
    else
    {
        rg1 = REG_EDX;
    }
    assert(rg1 == REG_EDX);

    /* Generate "lea EDX, [addr-mode]" */

    assert(tgt->gtType == TYP_REF);
    tgt->gtType = TYP_BYREF;
    inst_RV_TT(INS_lea, rg1, tgt, 0, EA_BYREF);

    rsTrackRegTrash(rg1);
    gcMarkRegSetNpt(genRegMask(rg1));
    gcMarkRegPtrVal(rg1, TYP_BYREF);


    /* Call the proper vm helper */

#if TGT_RISC
    assert(genNonLeaf);
#endif
    assert(tgt->gtOper == GT_IND ||
           tgt->gtOper == GT_CLS_VAR); // enforced by gcIsWriteBarrierCandidate

    unsigned    tgtAnywhere = 0;
    if ((tgt->gtOper == GT_IND) && (tgt->gtFlags & GTF_IND_TGTANYWHERE))
        tgtAnywhere = 1;

    int helper = regToHelper[tgtAnywhere][reg];

    gcMarkRegSetNpt(RBM_EDX);          // byref EDX is killed the call

    genEmitHelperCall(helper,
                      0,               // argSize
                      sizeof(void*));  // retSize

    if  (!trashOp1)
    {
        rsMaskUsed &= ~RBM_EDX;
        rsMaskLock &= ~RBM_EDX;
    }

    return RBM_EDX;
}

/*****************************************************************************
 *
 *  Generate the appropriate conditional jump(s) right after the low 32 bits
 *  of two long values have been compared.
 */

void                Compiler::genJccLongHi(genTreeOps   cmp,
                                           BasicBlock * jumpTrue,
                                           BasicBlock * jumpFalse,
                                           bool         unsOper )
{
    if (cmp != GT_NE)    
        jumpFalse->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;

    switch (cmp)
    {
    case GT_EQ:
        inst_JMP(EJ_jne, jumpFalse, false, false, true);
        break;

    case GT_NE:
        inst_JMP(EJ_jne, jumpTrue , false, false, true);
        break;

    case GT_LT:
    case GT_LE:
        if (unsOper)
        {
            inst_JMP(EJ_ja , jumpFalse, false, false, true);
            inst_JMP(EJ_jb , jumpTrue , false, false, true);
        }
        else
        {
            inst_JMP(EJ_jg , jumpFalse, false, false, true);
            inst_JMP(EJ_jl , jumpTrue , false, false, true);
        }
        break;

    case GT_GE:
    case GT_GT:
        if (unsOper)
        {
            inst_JMP(EJ_jb , jumpFalse, false, false, true);
            inst_JMP(EJ_ja , jumpTrue , false, false, true);
        }
        else
        {
            inst_JMP(EJ_jl , jumpFalse, false, false, true);
            inst_JMP(EJ_jg , jumpTrue , false, false, true);
        }
        break;

    default:
        assert(!"expected a comparison operator");
    }
}

/*****************************************************************************
 *
 *  Generate the appropriate conditional jump(s) right after the high 32 bits
 *  of two long values have been compared.
 */

void            Compiler::genJccLongLo(genTreeOps cmp, BasicBlock *jumpTrue,
                                                       BasicBlock *jumpFalse)
{
    switch (cmp)
    {
    case GT_EQ:
        inst_JMP(EJ_je , jumpTrue);
        break;

    case GT_NE:
        inst_JMP(EJ_jne, jumpTrue);
        break;

    case GT_LT:
        inst_JMP(EJ_jb , jumpTrue);
        break;

    case GT_LE:
        inst_JMP(EJ_jbe, jumpTrue);
        break;

    case GT_GE:
        inst_JMP(EJ_jae, jumpTrue);
        break;

    case GT_GT:
        inst_JMP(EJ_ja , jumpTrue);
        break;

    default:
        assert(!"expected comparison");
    }
}

/*****************************************************************************
 *
 *  Called by genCondJump() for TYP_LONG.
 */

void                Compiler::genCondJumpLng(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(jumpTrue && jumpFalse);
    assert((cond->gtFlags & GTF_REVERSE_OPS) == false); // Done in genCondJump()
    assert(cond->gtOp.gtOp1->gtType == TYP_LONG);

    GenTreePtr      op1       = cond->gtOp.gtOp1;
    GenTreePtr      op2       = cond->gtOp.gtOp2;
    genTreeOps      cmp       = cond->OperGet();

    regPairNo       regPair;
    regMaskTP       addrReg;

    /* Are we comparing against a constant? */

    if  (op2->gtOper == GT_CNS_LNG)
    {
        __int64    lval = op2->gtLngCon.gtLconVal;
        regNumber  rTmp;

        /* We can generate much faster code for four special cases */
        instruction     ins;

        if (cmp == GT_EQ)
        {
            if (lval == 0)
            {
                /* op1 == 0  */
                ins = INS_or;
                goto SPECIAL_CASE;
            }
            else if (lval == -1)
            {
                /* op1 == -1 */
                ins = INS_and;
                goto SPECIAL_CASE;
            }
        }
        else if (cmp == GT_NE)
        {
            if (lval == 0)
            {
                /* op1 != 0  */
                ins = INS_or;
                goto SPECIAL_CASE;
            }
            else if (lval == -1)
            {
                /* op1 != -1 */
                ins = INS_and;
SPECIAL_CASE:
                /* Make the comparand addressable */

                addrReg = genMakeRvalueAddressable(op1, 0, KEEP_REG, true);

                regMaskTP tmpMask = rsRegMaskCanGrab();

                if (op1->gtFlags & GTF_REG_VAL)
                {
                    regPairNo regPair = op1->gtRegPair;
                    regNumber rLo     = genRegPairLo(regPair);
                    regNumber rHi     = genRegPairHi(regPair);
                    if (tmpMask & genRegMask(rLo))
                    {
                        rTmp = rLo;
                    }
                    else if (tmpMask & genRegMask(rHi))
                    {
                        rTmp = rHi;
                        rHi  = rLo;
                    }
                    else
                    {
                        rTmp = rsGrabReg(tmpMask);
                        inst_RV_RV(INS_mov, rTmp, rLo, TYP_INT);
                    }

                    /* The register is now trashed */
                    rsTrackRegTrash(rTmp);

                    if (rHi != REG_STK)
                    {
                        /* Set the flags using INS_and | INS_or */
                        inst_RV_RV(ins, rTmp, rHi, TYP_INT);
                    }
                    else
                    {
                        /* Set the flags using INS_and | INS_or */
                        inst_RV_TT(ins, rTmp, op1, 4);
                    }

                }
                else
                {
                    rTmp = rsGrabReg(tmpMask);

                    /* Load the low 32-bits of op1 */
                    inst_RV_TT(INS_mov, rTmp, op1, 0);

                    /* The register is now trashed */
                    rsTrackRegTrash(rTmp);

                    /* Set the flags using INS_and | INS_or */
                    inst_RV_TT(ins, rTmp, op1, 4);
                }

                /* Free up the addrReg(s) if any */
                genDoneAddressable(op1, addrReg, KEEP_REG);

                /* compares against -1, also requires an an inc instruction */
                if (lval == -1)
                {
                    /* Set the flags using INS_inc or INS_add */
                    genIncRegBy(rTmp, 1, cond, TYP_INT);
                }

                if (cmp == GT_EQ)
                {
                    inst_JMP(EJ_je,  jumpTrue);
                }
                else
                {
                    inst_JMP(EJ_jne, jumpTrue);
                }

                return;
            }
        }

        /* Make the comparand addressable */

        addrReg = genMakeRvalueAddressable(op1, 0, FREE_REG, true);

        /* Compare the high part first */

        long  ival = (long)(lval >> 32);

        /* Comparing a register against 0 is easier */

        if  (!ival && (op1->gtFlags & GTF_REG_VAL)
             && (rTmp = genRegPairHi(op1->gtRegPair)) != REG_STK )
        {
            /* Generate 'test rTmp, rTmp' */

            inst_RV_RV(INS_test, rTmp, rTmp, op1->TypeGet());
        }
        else
        {
            if  (op1->gtOper == GT_CNS_LNG)
            {
                /* Special case: comparison of two constants */
                // Needed as gtFoldExpr() doesnt fold longs

                assert(addrReg == 0);
                int op1_hiword = (long)(op1->gtLngCon.gtLconVal >> 32);

                /* HACK: get the constant operand into a register */
#if REDUNDANT_LOAD
                /* Is the constant already in register? If so, use it */

                rTmp = rsIconIsInReg(op1_hiword);

                if  (rTmp == REG_NA)
#endif
                {
                    rTmp = rsPickReg();
                    genSetRegToIcon(rTmp, op1_hiword, TYP_INT);
                    rsTrackRegTrash(rTmp);
                }

                /* Generate 'cmp rTmp, ival' */

                inst_RV_IV(INS_cmp, rTmp, ival);
            }
            else
            {
                assert(op1->gtOper != GT_CNS_LNG);

                /* Generate 'cmp [addr], ival' */

                inst_TT_IV(INS_cmp, op1, ival, 4);
            }
        }

        /* Generate the appropriate jumps */

        if  (cond->gtFlags & GTF_UNSIGNED)
             genJccLongHi(cmp, jumpTrue, jumpFalse, true);
        else
             genJccLongHi(cmp, jumpTrue, jumpFalse);

        /* Compare the low part second */

        ival = (long)lval;

        /* Comparing a register against 0 is easier */

        if  (!ival && (op1->gtFlags & GTF_REG_VAL)
             && (rTmp = genRegPairLo(op1->gtRegPair)) != REG_STK)
        {
            /* Generate 'test rTmp, rTmp' */

            inst_RV_RV(INS_test, rTmp, rTmp, op1->TypeGet());
        }
        else
        {
            if  (op1->gtOper == GT_CNS_LNG)
            {
                /* Special case: comparison of two constants */
                // Needed as gtFoldExpr() doesnt fold longs

                assert(addrReg == 0);
                long op1_loword = (long) op1->gtLngCon.gtLconVal;

                /* HACK: get the constant operand into a register */
#if REDUNDANT_LOAD
                /* Is the constant already in register? If so, use it */

                rTmp = rsIconIsInReg(op1_loword);

                if  (rTmp == REG_NA)
#endif
                {
                    rTmp   = rsPickReg();
                    genSetRegToIcon(rTmp, op1_loword, TYP_INT);
                    rsTrackRegTrash(rTmp);
                }

                /* Generate 'cmp rTmp, ival' */

                inst_RV_IV(INS_cmp, rTmp, ival);
            }
            else
            {
                assert(op1->gtOper != GT_CNS_LNG);

                /* Generate 'cmp [addr], ival' */

                inst_TT_IV(INS_cmp, op1, ival, 0);
            }
        }

        /* Generate the appropriate jumps */

        genJccLongLo(cmp, jumpTrue, jumpFalse);

        genDoneAddressable(op1, addrReg, FREE_REG);
        return;
    }

    /* The operands would be reversed by physically swapping them */

    assert((cond->gtFlags & GTF_REVERSE_OPS) == 0);

    /* Generate the first operand into a register pair */

    genComputeRegPair(op1, REG_PAIR_NONE, op2->gtRsvdRegs, KEEP_REG, false);
    assert(op1->gtFlags & GTF_REG_VAL);

    /* Make the second operand addressable */

    addrReg = genMakeRvalueAddressable(op2, RBM_ALL & ~genRegPairMask(op1->gtRegPair), KEEP_REG);

    /* Make sure the first operand hasn't been spilled */

    genRecoverRegPair(op1, REG_PAIR_NONE, KEEP_REG);
    assert(op1->gtFlags & GTF_REG_VAL);

    regPair = op1->gtRegPair;

    /* Make sure 'op2' is still addressable while avoiding 'op1' (regPair) */

    addrReg = genKeepAddressable(op2, addrReg, genRegPairMask(regPair));

    /* Perform the comparison - high parts */

    inst_RV_TT(INS_cmp, genRegPairHi(regPair), op2, 4);

    if  (cond->gtFlags & GTF_UNSIGNED)
        genJccLongHi(cmp, jumpTrue, jumpFalse, true);
    else
        genJccLongHi(cmp, jumpTrue, jumpFalse);

    /* Compare the low parts */

    inst_RV_TT(INS_cmp, genRegPairLo(regPair), op2, 0);
    genJccLongLo(cmp, jumpTrue, jumpFalse);

    /* Free up anything that was tied up by either operand */

    genDoneAddressable(op2, addrReg, KEEP_REG);
    genReleaseRegPair (op1);

    return;
}


/*****************************************************************************
 *  gen_fcomp_FN, gen_fcomp_FS_TT, gen_fcompp_FS
 *  Called by genCondJumpFlt() to generate the fcomp instruction appropriate
 *  to the architecture we're running on.
 *
 *  P5:
 *  gen_fcomp_FN:     fcomp ST(0), stk
 *  gen_fcomp_FS_TT:  fcomp ST(0), addr
 *  gen_fcompp_FS:    fcompp
 *    These are followed by fnstsw, sahf to get the flags in EFLAGS.
 *
 *  P6:
 *  gen_fcomp_FN:     fcomip ST(0), stk
 *  gen_fcomp_FS_TT:  fld addr, fcomip ST(0), ST(1), fstp ST(0)
 *      (and reverse the branch condition since addr comes first)
 *  gen_fcompp_FS:    fcomip, fstp
 *    These instructions will correctly set the EFLAGS register.
 *
 *  Return value:  These functions return true if the instruction has
 *    already placed its result in the EFLAGS register.
 */

bool                Compiler::genUse_fcomip()
{
    return opts.compUseFCOMI;
}

bool                Compiler::gen_fcomp_FN(unsigned stk)
{
    if (genUse_fcomip())
    {
        inst_FN(INS_fcomip, stk);
        return true;
    }
    else
    {
        inst_FN(INS_fcomp, stk);
        return false;
    }
}

bool                Compiler::gen_fcomp_FS_TT(GenTreePtr addr, bool *reverseJumpKind)
{
    assert(reverseJumpKind);

    if (genUse_fcomip())
    {
        inst_FS_TT(INS_fld, addr);
        inst_FN(INS_fcomip, 1);
        inst_FS(INS_fstp, 0);
        *reverseJumpKind = true;
        return true;
    }
    else
    {
        inst_FS_TT(INS_fcomp, addr);
        return false;
    }
}

bool                Compiler::gen_fcompp_FS()
{
    if (genUse_fcomip())
    {
        inst_FS(INS_fcomip, 1);
        inst_FS(INS_fstp, 0);
        return true;
    }
    else
    {
        inst_FS(INS_fcompp, 1);
        return false;
    }
}

/*****************************************************************************
 *
 *  Called by genCondJump() for TYP_FLOAT and TYP_DOUBLE
 */

void                Compiler::genCondJumpFlt(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(jumpTrue && jumpFalse);
    assert(!(cond->gtFlags & GTF_REVERSE_OPS)); // Done in genCondJump()
    assert(varTypeIsFloating(cond->gtOp.gtOp1->gtType));

    GenTreePtr      op1 = cond->gtOp.gtOp1;
    GenTreePtr      op2 = cond->gtOp.gtOp2;
    genTreeOps      cmp = cond->OperGet();

    regMaskTP       addrReg;
    GenTreePtr      addr;
    TempDsc  *      temp;

    bool            resultInEFLAGS  = false;
    bool            reverseJumpKind = false;

#if ROUND_FLOAT
    bool roundOp1 = false; // @TODO: [REVISIT] [04/16/01] [] This seems to be used for op2 as well!

    switch (getRoundFloatLevel())
    {
    case ROUND_NEVER:
        /* No rounding at all */
        break;

    case ROUND_CMP_CONST:
        /* Round values compared against constants only */
        if  (op2->gtOper == GT_CNS_DBL)
            roundOp1 = true;
        break;

    case ROUND_CMP:
        /* Round all comparands */
        roundOp1 = true;
        break;

    case ROUND_ALWAYS:
        /*
            If we're going to spill due to call, no need to round
            the result of computation of op1.
         */
        roundOp1 = (op2->gtFlags & GTF_CALL) ? false : true;
        break;

    default:
        assert(!"Unsupported Round Level");
        break;
    }
#endif

    /* Are we comparing against floating-point 0 ? */

    if  (op2->gtOper == GT_CNS_DBL && op2->gtDblCon.gtDconVal == 0)
    {
        /* Is the other operand cast from float? */

        if  (op1->gtOper                  == GT_CAST &&
             op1->gtCast.gtCastOp->gtType == TYP_FLOAT)
        {
            /* We can only optimize EQ/NE because of NaN */

            if (cmp == GT_EQ || cmp == GT_NE)
            {
                /* Simply toss the cast and do a float compare */

                op1 = op1->gtOp.gtOp1;
                
                /* Is the operand in memory? */
                
                addr = genMakeAddrOrFPstk(op1, &addrReg, genShouldRoundFP());
                
                if  (addr)
                {
                    /* We have the address of the float operand, compare it */
                    
                    inst_TT_IV(INS_test, addr, 0x7FFFFFFFU);
                    
                    if (cmp == GT_EQ)
                    {
                        inst_JMP  (EJ_je   , jumpTrue);
                    }
                    else
                    {
                        inst_JMP  (EJ_jne , jumpTrue);
                    }

                    genDoneAddressable(op1, addrReg, FREE_REG);
                    return;
                }
#if ROUND_FLOAT
                else if (true || // Cant ignore GT_CAST even with ROUND_NEVER. (9/26/00)
                         (getRoundFloatLevel() != ROUND_NEVER))
                {
                    /* Allocate a temp for the expression */
                    
                    TempDsc * temp = genSpillFPtos(TYP_FLOAT);
                    
                    inst_ST_IV(INS_test, temp, 0, 0x7FFFFFFFU, TYP_FLOAT);

                    if (cmp == GT_EQ)
                    {
                        inst_JMP  (EJ_je   , jumpTrue);
                    }
                    else
                    {
                        inst_JMP  (EJ_jne , jumpTrue);
                    }
                      
                    /* We no longer need the temp */
                    
                    tmpRlsTemp(temp);
                    return;
                }
#endif
                else
                {
                    /* The argument is on the FP stack */
                    goto FLT_OP2;
                }
            }
            else
            {
                /* float compares other than EQ/NE */
                goto FLT_CMP;
            }
        }
    }

    /* Compute both of the comparands onto the FP stack */

FLT_CMP:

    /* Is the first comparand a register variable? */

    if  (op1->gtOper == GT_REG_VAR)
    {
        /* Does op1 die here? */

        if  (op1->gtFlags & GTF_REG_DEATH)
        {
            assert(op1->gtRegVar.gtRegNum == 0);

            /* Are both comparands register variables? */

            if  (op2->gtOper == GT_REG_VAR && genFPstkLevel == 0)
            {
                /* Mark op1 as dying at the bottom of the stack */

                genFPregVarLoadLast(op1);
                assert(genFPstkLevel == 1);

                /* Does 'op2' die here as well? */

                if  (op2->gtFlags & GTF_REG_DEATH)
                {
                    assert(op2->gtRegVar.gtRegNum == 0);

                    /* We're killing 'op2' here */

                    genFPregVarDeath(op2);
                    genFPstkLevel++;

                    /* Compare the values and pop both */

                    resultInEFLAGS = gen_fcompp_FS();
                    genFPstkLevel -= 2;
                }
                else
                {
                    /* Compare op1 against op2 and toss op1 */

                    resultInEFLAGS = gen_fcomp_FN(op2->gtRegNum + genFPstkLevel);
                    genFPstkLevel--;
                }

                addrReg = RBM_NONE;
                goto FLT_REL;
            }
            else // if  (op2->gtOper != GT_REG_VAR || genFPstkLevel != 0)
            {
                #if FPU_DEFEREDDEATH

                
                bool popOp1 = genFPstkLevel == 0;

                // We are killing op1, and popping it if its at the stack-top
                genFPregVarDeath(op1, popOp1);

                genCodeForTreeFlt(op2, roundOp1);

                if  (genFPstkLevel == 1)
                {
                    assert(popOp1);
                    resultInEFLAGS = gen_fcompp_FS();
                }
                else
                {
                    assert(!popOp1);
                    resultInEFLAGS = gen_fcomp_FN(genFPstkLevel);
                }

                genFPstkLevel--; // Pop off 'op2'
                goto REV_CMP_FPREG1;
                
                #else

                // op1 is a reg var, it will simply bubble up the regvar to the TOS
                genFPregVarLoad(op1);

                // Load the 2nd operand
                genCodeForTreeFlt(op2, roundOp1);

                // Generate comparison
                resultInEFLAGS = gen_fcompp_FS();

                genFPstkLevel -= 2; // Pop off op1 and op2 
                goto REV_CMP_FPREG1;
                
                #endif //  FPU_DEFEREDDEATH                
            }
        }
        else if (op2->gtOper == GT_REG_VAR && (op2->gtFlags & GTF_REG_DEATH))
        {
            if (op2->gtRegNum + genFPstkLevel == 0)
            {
                resultInEFLAGS = gen_fcomp_FN(op1->gtRegNum);

                /* Record the fact that 'op2' is now dead */

                genFPregVarDeath(op2);

                goto REV_CMP_FPREG1;
            }
        }
        else
        {
            unsigned op1Index = lvaTable[op1->gtRegVar.gtRegVar].lvVarIndex;

            /* The op1 regvar may actually be dying inside of op2. To simplify
               tracking of the liveness, we just load a copy of the regvar for op1 */

            if ((genVarIndexToBit(op1Index) & op2->gtLiveSet) == 0)
            {
                /* Load op1 */

                genFPregVarLoad(op1);

                /* Load op2. The regvar goes dead inside op2 and will be
                   appropriately popped/handled */

                genCodeForTreeFlt(op2, roundOp1);

                /* Do the comparison and pop off both op1 and op2 */

                resultInEFLAGS = gen_fcompp_FS();
                genFPstkLevel -= 2;

                goto REV_CMP_FPREG1;
            }
        }

        /* We get here if neither op1 nor op2 is dying here.
           Simply load the second operand to TOS and compare */

        assert(op1->gtOper == GT_REG_VAR && (op1->gtFlags & GTF_REG_DEATH) == 0);

        genCodeForTreeFlt(op2, roundOp1);
        resultInEFLAGS = gen_fcomp_FN(op1->gtRegNum + genFPstkLevel);

        genFPstkLevel--;

    REV_CMP_FPREG1:

        /* Flip the comparison direction */

        cmp            = GenTree::SwapRelop(cmp);
        goto FLT_REL;
    }

    /* We get here if op1 is not an enregistered FP var */
    assert(op1->gtOper != GT_REG_VAR);

    genCodeForTreeFlt(op1, roundOp1);

#if ROUND_FLOAT

    if  (op1->gtType == TYP_DOUBLE && roundOp1)
    {
        if (op1->gtOper                  == GT_CAST &&
            op1->gtCast.gtCastOp->gtType == TYP_LONG)
        {
            genRoundFpExpression(op1);
        }
    }

#endif

FLT_OP2:

    /* Does the other operand contain a call? */
    /* Or do we compare against infinity ? */

    temp = 0;

    if  ((op2->gtFlags & GTF_CALL) ||
         (op2->gtOper == GT_CNS_DBL &&
          (*((__int64*)&(op2->gtDblCon.gtDconVal)) & 0x7ff0000000000000) == 0x7ff0000000000000)
         )
    {
        /* We must spill the first operand */

        assert(genFPstkLevel == 1 || !(op2->gtFlags & GTF_CALL));
        temp = genSpillFPtos(op1);
    }

    /* Get hold of the second operand and compare against it */

    /* Is the second comparand a dying register variable? */

    if  (op2->gtOper == GT_REG_VAR && (op2->gtFlags & GTF_REG_DEATH) && temp == 0)
    {
        assert(genFPstkLevel >= 1); // We know atleast op1 is on the FP stack

        /* The second comparand dies here. We should be able to pop it off */

        genFPregVarDeath(op2);
        genFPstkLevel++;

        if (genFPstkLevel > 2)
        {
            genFPmovRegTop();
        }
        else
        {
            /* Flip the sense of the comparison */

            cmp = GenTree::SwapRelop(cmp);
        }

        /* The second operand is obviously on the FP stack */

        addr = 0;
    }
    else
    {
        addr = genMakeAddrOrFPstk(op2, &addrReg, roundOp1);

#if ROUND_FLOAT

        if  (addr == 0 && op2->gtType == TYP_DOUBLE && roundOp1)
        {
            if (op2->gtOper                  == GT_CAST &&
                op2->gtCast.gtCastOp->gtType == TYP_LONG)
            {
                genRoundFpExpression(op2);
            }
        }
#endif
    }

    /* Did we have to spill the first operand? */

    if  (temp)
    {
        instruction     ins;

        /*  Either reload the temp back onto the FP stack (if the other
            operand is not itself on the FP stack), or just compare the
            first operand against the temp (if the operand is on the FP
            stack).
         */

        if  (addr)
        {
            ins = INS_fld;
            genFPstkLevel++;
        }
        else
        {
            /* op2 is already on the FP stack. We can immediately
               compare against it, but we have to 'swap' the sense
               of the comparison.
            */

            ins = INS_fcomp;
            cmp = GenTree::SwapRelop(cmp);
        }

        genReloadFPtos(temp, ins);
    }

    if  (addr)
    {
        /* We have the address of the other operand */

        resultInEFLAGS = gen_fcomp_FS_TT(addr, &reverseJumpKind);
    }
    else
    {
        /* The other operand is on the FP stack */

        if  (!temp)
        {
            resultInEFLAGS = gen_fcompp_FS();
            genFPstkLevel--;
            cmp = GenTree::SwapRelop(cmp);
        }
    }

    genFPstkLevel--;

FLT_REL:

    genDoneAddressable(op2, addrReg, FREE_REG);

    // For top of tree conditional branches
    // we need to make sure that we pop off any dying
    // FP variables right before we do the branch(s)

    if ((cond->gtFlags & (GTF_RELOP_JMP_USED|GTF_RELOP_QMARK)) == GTF_RELOP_JMP_USED)
    {
        assert(compCurStmt);
        genChkFPregVarDeath(compCurStmt, false);
    }

    if (!resultInEFLAGS)
    {
        /* Grab EAX for the result of the fnstsw */

        rsGrabReg(RBM_EAX);

        /* Generate the 'fnstsw' and test its result */

        inst_RV(INS_fnstsw, REG_EAX, TYP_INT);
        rsTrackRegTrash(REG_EAX);
        instGen(INS_sahf);
    }

    /* Will we jump is operands are NaNs? */

    if (cond->gtFlags & GTF_RELOP_NAN_UN)
    {
        /* Generate the first jump (NaN check) */

        inst_JMP(EJ_jpe, jumpTrue, false, false, true);
    }
    else
    {
        jumpFalse->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;

        /* Generate the first jump (NaN check) */

        inst_JMP(EJ_jpe, jumpFalse, false, false, true);
    }

    /* Generate the second jump (comparison) */

    const static
    BYTE        dblCmpTstJmp2[] =
    {
          EJ_je      , // GT_EQ
          EJ_jne     , // GT_NE
          EJ_jb      , // GT_LT
          EJ_jbe     , // GT_LE
          EJ_jae     , // GT_GE
          EJ_ja      , // GT_GT
    };

    if (reverseJumpKind)
    {
        cmp = GenTree::SwapRelop(cmp);
    }

    inst_JMP((emitJumpKind)dblCmpTstJmp2[cmp - GT_EQ], jumpTrue);
}

/*****************************************************************************
 *  The condition to use for (the jmp/set for) the given type of operation
 */

static emitJumpKind         genJumpKindForOper(genTreeOps   cmp,
                                               bool         isUnsigned)
{
    const static
    BYTE            genJCCinsSgn[] =
    {
        EJ_je,      // GT_EQ
        EJ_jne,     // GT_NE
        EJ_jl,      // GT_LT
        EJ_jle,     // GT_LE
        EJ_jge,     // GT_GE
        EJ_jg,      // GT_GT
    };

    const static
    BYTE            genJCCinsUns[] =       /* unsigned comparison */
    {
        EJ_je,      // GT_EQ
        EJ_jne,     // GT_NE
        EJ_jb,      // GT_LT
        EJ_jbe,     // GT_LE
        EJ_jae,     // GT_GE
        EJ_ja,      // GT_GT
    };

    assert(genJCCinsSgn[GT_EQ - GT_EQ] == EJ_je );
    assert(genJCCinsSgn[GT_NE - GT_EQ] == EJ_jne);
    assert(genJCCinsSgn[GT_LT - GT_EQ] == EJ_jl );
    assert(genJCCinsSgn[GT_LE - GT_EQ] == EJ_jle);
    assert(genJCCinsSgn[GT_GE - GT_EQ] == EJ_jge);
    assert(genJCCinsSgn[GT_GT - GT_EQ] == EJ_jg );

    assert(genJCCinsUns[GT_EQ - GT_EQ] == EJ_je );
    assert(genJCCinsUns[GT_NE - GT_EQ] == EJ_jne);
    assert(genJCCinsUns[GT_LT - GT_EQ] == EJ_jb );
    assert(genJCCinsUns[GT_LE - GT_EQ] == EJ_jbe);
    assert(genJCCinsUns[GT_GE - GT_EQ] == EJ_jae);
    assert(genJCCinsUns[GT_GT - GT_EQ] == EJ_ja );

    assert(GenTree::OperIsCompare(cmp));

    if (isUnsigned)
    {
        return (emitJumpKind) genJCCinsUns[cmp - GT_EQ];
    }
    else
    {
        return (emitJumpKind) genJCCinsSgn[cmp - GT_EQ];
    }
}

/*****************************************************************************
 *
 *  Sets the flag for the TYP_INT/TYP_REF comparison.
 *  We try to use the flags if they have already been set by a prior
 *  instruction.
 *  eg. i++; if(i<0) {}  Here, the "i++;" will have set the sign flag. We dont
 *                       need to compare again with zero. Just use a "INS_js"
 *
 *  Returns the flags the following jump/set instruction should use.
 */

emitJumpKind            Compiler::genCondSetFlags(GenTreePtr cond)
{
    assert(varTypeIsI(genActualType(cond->gtOp.gtOp1->gtType)));

    GenTreePtr      op1       = cond->gtOp.gtOp1;
    GenTreePtr      op2       = cond->gtOp.gtOp2;
    genTreeOps      cmp       = cond->OperGet();

    if  (cond->gtFlags & GTF_REVERSE_OPS)
    {
        /* Don't forget to modify the condition as well */

        cond->gtOp.gtOp1 = op2;
        cond->gtOp.gtOp2 = op1;
        cond->SetOper     (GenTree::SwapRelop(cmp));
        cond->gtFlags   &= ~GTF_REVERSE_OPS;

        /* Get hold of the new values */

        cmp  = cond->OperGet();
        op1  = cond->gtOp.gtOp1;
        op2  = cond->gtOp.gtOp2;
    }

    // Note that op1's type may get bashed. So save it early

    var_types     op1Type     = op1->TypeGet();
    bool          unsignedCmp = (cond->gtFlags & GTF_UNSIGNED) != 0;
    emitAttr      size        = EA_UNKNOWN;

    regMaskTP     regNeed;
    regMaskTP     addrReg;
    emitJumpKind  jumpKind;

#ifdef DEBUG
    addrReg = 0xDDDDDDDD;
#endif

    /* Are we comparing against a constant? */

    if  (op2->gtOper == GT_CNS_INT)
    {
        long            ival = op2->gtIntCon.gtIconVal;
        
        /* unsigned less than comparisons with 1 ('< 1' )
           should be transformed into '== 0' to potentially
           suppress a tst instruction.
        */
        if  ((ival == 1) && (cmp == GT_LT) && unsignedCmp)
        {
            op2->gtIntCon.gtIconVal = ival = 0;
            cond->gtOper            = cmp  = GT_EQ;
        }

        /* Comparisons against 0 can be easier */

        if  (ival == 0)
        {
            // if we can safely change the comparison to unsigned we do so
            if  (!unsignedCmp                       &&  
                 varTypeIsSmall(op1->TypeGet())     &&  
                 varTypeIsUnsigned(op1->TypeGet()))
            {
                unsignedCmp = true;
            }

            /* unsigned comparisons with 0 should be transformed into
               '==0' or '!= 0' to potentially suppress a tst instruction. */

            if (unsignedCmp)
            {
                if (cmp == GT_GT)
                    cond->gtOper = cmp = GT_NE;
                else if (cmp == GT_LE)
                    cond->gtOper = cmp = GT_EQ;
            }

            /* Is this a simple zero/non-zero test? */

            if  (cmp == GT_EQ || cmp == GT_NE)
            {
                /* Is the operand an "AND" operation? */

                if  (op1->gtOper == GT_AND)
                {
                    GenTreePtr      an1 = op1->gtOp.gtOp1;
                    GenTreePtr      an2 = op1->gtOp.gtOp2;

                    /* Check for the case "expr & icon" */

                    if  (an2->gtOper == GT_CNS_INT)
                    {
                        long iVal = an2->gtIntCon.gtIconVal;

                        /* make sure that constant is not out of an1's range */

                        switch (an1->gtType)
                        {
                        case TYP_BOOL:
                        case TYP_BYTE:
                            if (iVal & 0xffffff00)
                                goto NO_TEST_FOR_AND;
                            break;
                        case TYP_CHAR:
                        case TYP_SHORT:
                            if (iVal & 0xffff0000)
                                goto NO_TEST_FOR_AND;
                            break;
                        }

                        if (an1->gtOper == GT_CNS_INT)
                        {
                            // Special case - Both operands of AND are consts
                            genComputeReg(an1, 0, EXACT_REG, FREE_REG);
                            addrReg = 0;
                        }
                        else
                        {
                            addrReg = genMakeAddressable(an1, 0, FREE_REG, true);
                        }

                        inst_TT_IV(INS_test, an1, iVal);

                        goto DONE;

                    NO_TEST_FOR_AND:
                        ;

                    }

                    // UNDONE: Check for other cases that can generate 'test',
                    // UNDONE: also check for a 64-bit integer zero test which
                    // UNDONE: could generate 'or lo, hi' followed by jz/jnz.
                }
            }

            /* Is the value a simple local variable? */

            if  (op1->gtOper == GT_LCL_VAR)
            {
                /* Is the flags register set to the value? */

                switch (genFlagsAreVar(op1->gtLclVar.gtLclNum))
                {
                case 1:
                    if  (cmp != GT_EQ && cmp != GT_NE)
                        break;
                    else
                        /* fall through */ ;

                case 2:
                    addrReg = 0;
                    goto DONE;
                }
            }

            /* Make the comparand addressable */

            addrReg = genMakeRvalueAddressable(op1, 0, FREE_REG, true);

            /* Are the condition flags set based on the value? */

            unsigned flags = (op1->gtFlags & (GTF_ZF_SET|GTF_CC_SET));

            if (op1->gtFlags & GTF_REG_VAL)
            {
                switch(genFlagsAreReg(op1->gtRegNum))
                {
                case 1: flags |= GTF_ZF_SET; break;
                case 2: flags |= GTF_CC_SET; break;
                }
            }

            if  (flags)
            {
                /* The zero flag is certainly enough for "==" and "!=" */

                if  (cmp == GT_EQ || cmp == GT_NE)
                    goto DONE;

                /* For other comparisons, we need more conditions flags */

                if ((flags & GTF_CC_SET) && (!(cond->gtFlags & GTF_UNSIGNED)) &&
                    ((cmp == GT_LT) || (cmp == GT_GE)))
                {
                    jumpKind = ((cmp == GT_LT) ? EJ_js : EJ_jns);
                    goto DONE_FLAGS;
                }
            }

            /* Is the value in a register? */

            if  (op1->gtFlags & GTF_REG_VAL)
            {
                regNumber       reg = op1->gtRegNum;

                /* Is it just a test for equality? */

                if (cmp == GT_EQ || cmp == GT_NE)
                {
                    /* Generate 'test reg, reg' */

                    inst_RV_RV(INS_test, reg, reg, op1->TypeGet());
                    goto DONE;
                }

                /* With a 'test' we can only do "<" and ">=" */

                if  (((cmp == GT_LT) || (cmp == GT_GE))
                     && !(cond->gtFlags & GTF_UNSIGNED)  )
                {
                    /* Generate 'test reg, reg' */

                    inst_RV_RV(INS_test, reg, reg, op1->TypeGet());
                    jumpKind = ((cmp == GT_LT) ? EJ_js : EJ_jns);
                    goto DONE_FLAGS;
                }
            }
        }

        else // if (ival != 0)
        {
            bool smallOk = true;
                        

            /* make sure that constant is not out of op1's range 
               if it is, we need to perform an int with int comparison
               and therefore, we set smallOk to false, so op1 gets loaded
               into a register
            */

            /* If op1 is TYP_SHORT, and is followed by an unsigned
             * comparison, we can use smallOk. But we dont know which
             * flags will be needed. This probably doesnt happen often.
            */
            var_types gtType=op1->TypeGet();

            switch (gtType)
            {
            case TYP_BYTE:  if (ival != (signed   char )ival) smallOk = false; break;
            case TYP_BOOL:
            case TYP_UBYTE: if (ival != (unsigned char )ival) smallOk = false; break;

            case TYP_SHORT: if (ival != (signed   short)ival) smallOk = false; break;
            case TYP_CHAR:  if (ival != (unsigned short)ival) smallOk = false; break;

            default:                                                           break;
            }
            
            if (smallOk                     &&      // constant is in op1's range
                !unsignedCmp                &&      // signed comparison
                varTypeIsSmall(gtType)      &&      // smalltype var
                varTypeIsUnsigned(gtType))          // unsigned type
            {
                unsignedCmp = true;                
            }


            /* Make the comparand addressable */                                   
            addrReg = genMakeRvalueAddressable(op1, 0, FREE_REG, smallOk);
        }

// #if defined(DEBUGGING_SUPPORT) || ALLOW_MIN_OPT

        /* Special case: comparison of two constants */

        // Needed if Importer doesnt call gtFoldExpr()

        // @TODO: [REVISIT] [04/16/01] [] Importer/Inliner should fold this

        if  (op1->gtOper == GT_CNS_INT)
        {
            // assert(opts.compMinOptim || opts.compDbgCode);

            /* HACK: get the constant operand into a register */
            genComputeReg(op1, 0, ANY_REG, FREE_REG);

            assert(addrReg == 0);
            assert(op1->gtFlags & GTF_REG_VAL);

            addrReg = genRegMask(op1->gtRegNum);
        }

// #endif

        /* Compare the operand against the constant */

        inst_TT_IV(INS_cmp, op1, ival);
        goto DONE;
    }

    //---------------------------------------------------------------------
    //
    // We reach here if op2 was not a GT_CNS_INT
    //

    assert(op1->gtOper != GT_CNS_INT);

    if  (op2->gtOper == GT_LCL_VAR)
        genMarkLclVar(op2);

    /* Are we comparing against a register? */

    if  (op2->gtFlags & GTF_REG_VAL)
    {
        /* Make the comparand addressable */

        addrReg = genMakeAddressable(op1, 0, FREE_REG, true);

        /* Is the size of the comparison byte/char/short ? */

        if  (varTypeIsSmall(op1->TypeGet()))
        {
            /* Is op2 sitting in an appropriate register? */

            if (varTypeIsByte(op1->TypeGet()) && !isByteReg(op2->gtRegNum))
                goto NO_SMALL_CMP;

            /* Is op2 of the right type for a small comparison */

            if (op2->gtOper == GT_REG_VAR)
            {
                if (op1->gtType != lvaGetRealType(op2->gtRegVar.gtRegVar))
                    goto NO_SMALL_CMP;
            }
            else
            {
                if (op1->gtType != op2->gtType)
                    goto NO_SMALL_CMP;
            }
            
            if (varTypeIsUnsigned(op1->TypeGet()))
                unsignedCmp = true;                
        }

        /* Compare against the register */

        inst_TT_RV(INS_cmp, op1, op2->gtRegNum);

        addrReg |= genRegMask(op2->gtRegNum);
        goto DONE;

NO_SMALL_CMP:

        if ((op1->gtFlags & GTF_REG_VAL) == 0)
        {
            regNumber reg1 = rsPickReg();

            assert(varTypeIsSmall(op1->TypeGet()));
            inst_RV_TT(varTypeIsUnsigned(op1->TypeGet()) ? INS_movzx : INS_movsx, reg1, op1);
            rsTrackRegTrash(reg1);

            op1->gtFlags |= GTF_REG_VAL;
            op1->gtRegNum = reg1;
        }

        genDoneAddressable(op1, addrReg, FREE_REG);

        rsMarkRegUsed(op1);
        goto DONE_OP1;
    }

    /* We get here if op2 is not enregistered or not in a "good" register.
       Compute the first comparand into some register */

    regNeed = rsMustExclude(RBM_ALL, op2->gtRsvdRegs);

    if  (varTypeIsByte(op2->TypeGet()))
        regNeed = rsNarrowHint(RBM_BYTE_REGS, regNeed);

    genComputeReg(op1, regNeed, ANY_REG, KEEP_REG);

DONE_OP1:

    assert(op1->gtFlags & GTF_REG_VAL);

    /* Make the second comparand addressable. We can do a byte type
       comparison iff the operands are the same type and
       op1 ended in a byte addressable register */

    bool      byteCmp;
    bool      shortCmp;
    regMaskTP needRegs;
    
    byteCmp  = false;
    shortCmp = false;
    needRegs = RBM_ALL;

    if (op1Type == op2->gtType)
    {
        shortCmp = varTypeIsShort(op1Type);
        byteCmp  = varTypeIsByte(op1Type) && isByteReg(op1->gtRegNum);
        if (byteCmp)
            needRegs = RBM_BYTE_REGS;
    }
    addrReg = genMakeRvalueAddressable(op2, needRegs, KEEP_REG, byteCmp|shortCmp);

    /*  Make sure the first operand is still in a register; if
        it's been spilled, we have to make sure it's reloaded
        into a byte-addressable register if needed.
        Pass keepReg=KEEP_REG. Otherwise get pointer lifetimes wrong.
     */

    genRecoverReg(op1, needRegs, KEEP_REG);

    assert(op1->gtFlags & GTF_REG_VAL);
    assert(!byteCmp || isByteReg(op1->gtRegNum));

    rsLockUsedReg(genRegMask(op1->gtRegNum));

    /* Make sure that op2 is addressable. If we are going to do a
       byte-comparison, we need it to be in a byte register. */

    if (byteCmp && (op2->gtFlags & GTF_REG_VAL))
    {
        genRecoverReg(op2, needRegs, KEEP_REG);
        addrReg = genRegMask(op2->gtRegNum);
    }
    else
    {
        addrReg = genKeepAddressable(op2, addrReg, RBM_ALL & ~needRegs);
    }

    rsUnlockUsedReg(genRegMask(op1->gtRegNum));

    if (byteCmp || shortCmp)
    {
        size = emitTypeSize(op2->TypeGet());
        if (varTypeIsUnsigned(op1Type))
            unsignedCmp = true;                
    }
    else
    {
        size = emitActualTypeSize(op2->TypeGet());
    }

    /* Perform the comparison */
    inst_RV_TT(INS_cmp, op1->gtRegNum, op2, 0, size);

    /* free reg left used in Recover call */
    rsMarkRegFree(genRegMask(op1->gtRegNum));

    /* Free up anything that was tied up by the LHS */

    genDoneAddressable(op2, addrReg, KEEP_REG);

DONE:

    jumpKind = genJumpKindForOper(cmp, unsignedCmp);

DONE_FLAGS: // We have determined what jumpKind to use

    genUpdateLife(cond);

    /* The condition value is dead at the jump that follows */

    assert(addrReg != 0xDDDDDDDD);
    genDoneAddressable(op1, addrReg, FREE_REG);

    return jumpKind;
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if     TGT_SH3
/*****************************************************************************
 *
 *  Generate a conditional jump with a float/double operand.
 */

void                Compiler::genCondJumpFlt(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(!"RISC flt/dbl compare");
}

/*****************************************************************************
 *
 *  Generate a conditional jump with a long operand.
 */

void                Compiler::genCondJumpLng(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(!"RISC long compare");
}

/*****************************************************************************
 *
 *  Generates code that will set the "true" flag based on the given int/ptr
 *  comparison. When the value trueOnly is false, the "T" flag may be set to
 *  the opposite result of the comparison and 'false' is returned; otherwise
 *  'true' is returned.
 */

bool                    Compiler::genCondSetTflag(GenTreePtr    cond,
                                                  bool          trueOnly)
{
    GenTreePtr      op1 = cond->gtOp.gtOp1;
    GenTreePtr      op2 = cond->gtOp.gtOp2;
    genTreeOps      cmp = cond->OperGet();

    regNumber       rg1;
    regNumber       rg2;

    bool            uns;
    bool            sense;

    struct  cmpDsc
    {
        unsigned short  cmpIns;
        unsigned char   cmpRev;
        unsigned char   cmpYes;
    }
                *   jinfo;

    const static
    cmpDsc          genCMPinsSgn[] =
    {
        //   ins    reverse   yes
        { INS_cmpEQ,  true,  true },   // GT_EQ
        { INS_cmpEQ, false, false },   // GT_NE
        { INS_cmpGT,  true,  true },   // GT_LT
        { INS_cmpGE,  true,  true },   // GT_LE
        { INS_cmpGE, false,  true },   // GT_GE
        { INS_cmpGT, false,  true },   // GT_GT
    };

    const static
    cmpDsc          genCMPinsUns[] =
    {
        //   ins    reverse   yes
        { INS_cmpEQ,  true,  true },   // GT_EQ
        { INS_cmpEQ, false, false },   // GT_NE
        { INS_cmpHI,  true,  true },   // GT_LT
        { INS_cmpHS,  true,  true },   // GT_LE
        { INS_cmpHS, false,  true },   // GT_GE
        { INS_cmpHI, false,  true },   // GT_GT
    };

    assert(genCMPinsSgn[GT_EQ - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsSgn[GT_NE - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsSgn[GT_LT - GT_EQ].cmpIns == INS_cmpGT);
    assert(genCMPinsSgn[GT_LE - GT_EQ].cmpIns == INS_cmpGE);
    assert(genCMPinsSgn[GT_GE - GT_EQ].cmpIns == INS_cmpGE);
    assert(genCMPinsSgn[GT_GT - GT_EQ].cmpIns == INS_cmpGT);

    assert(genCMPinsUns[GT_EQ - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsUns[GT_NE - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsUns[GT_LT - GT_EQ].cmpIns == INS_cmpHI);
    assert(genCMPinsUns[GT_LE - GT_EQ].cmpIns == INS_cmpHS);
    assert(genCMPinsUns[GT_GE - GT_EQ].cmpIns == INS_cmpHS);
    assert(genCMPinsUns[GT_GT - GT_EQ].cmpIns == INS_cmpHI);

    assert(varTypeIsI(genActualType(cond->gtOp.gtOp1->gtType)));

    if  (cond->gtFlags & GTF_REVERSE_OPS)
    {
        /* Don't forget to modify the condition as well */

        cond->gtOp.gtOp1 = op2;
        cond->gtOp.gtOp2 = op1;
        cond->SetOper     (GenTree::SwapRelop(cmp));
        cond->gtFlags   &= ~GTF_REVERSE_OPS;

        /* Get hold of the new values */

        cmp  = cond->OperGet();
        op1  = cond->gtOp.gtOp1;
        op2  = cond->gtOp.gtOp2;
    }

    regMaskTP       regNeed;
    regMaskTP       addrReg;

#ifdef DEBUG
    addrReg = 0xDDDDDDDD;
#endif

    /* Is this an unsigned or signed comparison? */

    if (varTypeIsUnsigned(op1->TypeGet()) || (cond->gtFlags & GTF_UNSIGNED))
    {
        uns   = true;
        jinfo = genCMPinsUns;
    }
    else
    {
        uns   = false;
        jinfo = genCMPinsSgn;
    }

    /* Are we comparing against a constant? */

    if  (op2->gtOper == GT_CNS_INT)
    {
        long            ival = op2->gtIntCon.gtIconVal;

        /* Comparisons against 0 can be easier */

        if  (ival == 0)
        {
            regNumber   reg;
            emitAttr    size = emitActualTypeSize(op1->TypeGet());

            /* Special case: comparison against 0 */

            genCodeForTree(op1, 0, 0);

            /* The comparand should be in a register now */

            assert(op1->gtFlags & GTF_REG_VAL);

            reg     = op1->gtRegNum;
            addrReg = genRegMask(reg);

            /* What kind of a comparison do we have? */

            switch (cmp)
            {
            case GT_EQ:
                genEmitter->emitIns_R_R(INS_tst, size, (emitRegs)reg,
                                                       (emitRegs)reg);
                sense = true;
                break;

            case GT_NE:
                if  (!trueOnly)
                {
                    genEmitter->emitIns_R_R(INS_tst, size, (emitRegs)reg,
                                                           (emitRegs)reg);
                    sense = false;
                    break;
                }
                assert(!"integer != for SH-3 NYI");

            case GT_LT:

                assert(uns == false); // UNDONE: unsigned compare against 0

                if  (!trueOnly)
                {
                    genEmitter->emitIns_R(INS_cmpPZ, size, (emitRegs)reg);

                    sense = false;
                    break;
                }
                assert(!"integer <  for SH-3 NYI");

            case GT_LE:

                assert(uns == false); // UNDONE: unsigned compare against 0

                if  (!trueOnly)
                {
                    genEmitter->emitIns_R(INS_cmpPL, size, (emitRegs)reg);

                    sense = false;
                    break;
                }
                assert(!"integer <= for SH-3 NYI");

            case GT_GE:

                assert(uns == false); // UNDONE: unsigned compare against 0

                genEmitter->emitIns_R(INS_cmpPZ, size, (emitRegs)reg);
                sense = true;
                break;

            case GT_GT:

                assert(uns == false); // UNDONE: unsigned compare against 0

                genEmitter->emitIns_R(INS_cmpPL, size, (emitRegs)reg);
                sense = true;
                break;

            default:
#ifdef DEBUG
                gtDispTree(cond);
#endif
                assert(!"compare operator NYI");
            }

            goto DONE_FLAGS;
        }
    }

    /* Compute the first operand into any register */

    genComputeReg(op1, 0, ANY_REG, KEEP_REG, false);
    assert(op1->gtFlags & GTF_REG_VAL);

    /* Compute the second operand into any register */

    genComputeReg(op2, 0, ANY_REG, KEEP_REG, false);
    assert(op2->gtFlags & GTF_REG_VAL);
    rg2 = op2->gtRegNum;

    /* Make sure the first operand is still in a register */

    genRecoverReg(op1, 0, KEEP_REG);
    assert(op1->gtFlags & GTF_REG_VAL);
    rg1 = op1->gtRegNum;

    /* Make sure the second operand is still addressable */

    genKeepAddressable(op2, genRegMask(rg2), genRegMask(rg1));

    /* Point at the appropriate comparison entry */

    jinfo = (uns ? genCMPinsUns
                 : genCMPinsSgn) + (cmp - GT_EQ);

    /* Reverse the operands if necessary */

    if  (jinfo->cmpRev)
    {
        rg2 = op1->gtRegNum;
        rg1 = op2->gtRegNum;
    }

    /* Now perform the comparison */

    genEmitter->emitIns_R_R((instruction)jinfo->cmpIns,
                             EA_4BYTE,
                             (emitRegs)rg1,
                             (emitRegs)rg2);

    /* Free up both operands */

    genReleaseReg(op1);
    genReleaseReg(op2);

    genUpdateLife(cond);

    addrReg = genRegMask(rg1) | genRegMask(rg2);

    /* Are we required to produce a "true" result? */

    if  (jinfo->cmpYes)
    {
        sense = true;
    }
    else
    {
        if  (trueOnly)
        {
            assert(!"reverse comparison result");
        }
        else
        {
            sense = false;
        }
    }

DONE_FLAGS:

    /* The condition value is dead at the jump that will follow */

    assert(addrReg != 0xDDDDDDDD); gcMarkRegSetNpt(addrReg);

    return  sense;
}

/*****************************************************************************
 *
 *  Set the "T" flag to the result of comparing the given register value
 *  against the given integer constant.
 */

void                Compiler::genCompareRegIcon(regNumber   reg,
                                                int         val,
                                                bool        uns,
                                                genTreeOps  rel)
{
    GenTree         op1;
    GenTree         op2;
    GenTree         cmp;

    op1.ChangeOper          (GT_REG_VAR);
    op1.gtType             = TYP_INT;
    op1.gtFlags            = GTF_REG_VAL;
    op1.gtRegNum           =
    op1.gtRegVar.gtRegNum  = reg;
    op1.gtRegVar.gtRegVar  = -1;

    op2.ChangeOperConst     (GT_CNS_INT);
    op2.gtType             = TYP_INT;
    op2.gtFlags            = 0;
    op2.gtIntCon.gtIconVal = val;

    cmp.ChangeOper          (rel);
    cmp.gtType             = TYP_INT;
    cmp.gtFlags            = uns ? GTF_UNSIGNED : 0;
    cmp.gtOp.gtOp1         = &op1;
    cmp.gtOp.gtOp2         = &op2;

    op1.gtLiveSet          =
    op2.gtLiveSet          =
    cmp.gtLiveSet          = genCodeCurLife;

#ifdef  DEBUG
    op1.gtFlags           |= GTF_NODE_LARGE;
    op2.gtFlags           |= GTF_NODE_LARGE;
    cmp.gtFlags           |= GTF_NODE_LARGE;
#endif

    genCondSetTflag(&cmp, true);
}

/*****************************************************************************/
#endif//TGT_SH3
/*****************************************************************************
 *
 *  Generate code to jump to the jump target of the current basic block if
 *  the given relational operator yields 'true'.
 */

void                Compiler::genCondJump(GenTreePtr cond, BasicBlock *destTrue,
                                                           BasicBlock *destFalse)
{
    BasicBlock  *   jumpTrue;
    BasicBlock  *   jumpFalse;

    GenTreePtr      op1       = cond->gtOp.gtOp1;
    GenTreePtr      op2       = cond->gtOp.gtOp2;
    genTreeOps      cmp       = cond->OperGet();

#if INLINING
    if  (destTrue)
    {
        jumpTrue  = destTrue;
        jumpFalse = destFalse;
    }
    else
#endif
    {
        assert(compCurBB->bbJumpKind == BBJ_COND);

        jumpTrue  = compCurBB->bbJumpDest;
        jumpFalse = compCurBB->bbNext;
    }

    assert(cond->OperIsCompare());

    /* Make sure the more expensive operand is 'op1' */

    if  (cond->gtFlags & GTF_REVERSE_OPS)
    {
        /* Don't forget to modify the condition as well */

        cond->gtOp.gtOp1 = op2;
        cond->gtOp.gtOp2 = op1;
        cond->SetOper     (GenTree::SwapRelop(cmp));
        cond->gtFlags   &= ~GTF_REVERSE_OPS;

        /* Get hold of the new values */

        cmp  = cond->OperGet();
        op1  = cond->gtOp.gtOp1;
        op2  = cond->gtOp.gtOp2;
    }

    /* What is the type of the operand? */

    switch (genActualType(op1->gtType))
    {
    case TYP_INT:
    case TYP_REF:
    case TYP_BYREF:

#if TGT_x86

        emitJumpKind    jumpKind;

        // Check if we can use the currently set flags. Else set them

        jumpKind = genCondSetFlags(cond);

        /* Generate the conditional jump */

        inst_JMP(jumpKind, jumpTrue);

#else

        instruction     ins;

        /* Set the "true" flag and figure what jump to use */

        ins = genCondSetTflag(cond, false) ? INS_bt
                                           : INS_bf;

        /* Issue the conditional jump */

        genEmitter->emitIns_J(ins, false, false, jumpTrue);

#endif

        return;

    case TYP_LONG:

        genCondJumpLng(cond, jumpTrue, jumpFalse);
        return;

    case TYP_FLOAT:
    case TYP_DOUBLE:

        genCondJumpFlt(cond, jumpTrue, jumpFalse);
        return;

#ifdef DEBUG
    default:
        gtDispTree(cond);
        assert(!"unexpected/unsupported 'jtrue' operands type");
#endif
    }
}

/*****************************************************************************
 *
 *  The following can be used to create basic blocks that serve as labels for
 *  the emitter. Use with caution - these are not real basic blocks!
 *
 *  @TODO [CONSIDER] [04/16/01] [] The emitter binds jumps by setting bbEmitCookie and then using
 *  emitCodeGetCookie(). Since everyone passes around a (BasicBlock*), we need
 *  to allocate a BasicBlock here for its bbEmitCookie.
 *  Instead we should just pass around a (bbEmitCooke*) ie. a (insGroup*)
 *  everywhere, avoiding the need to allocate a complete BasicBlock.
 */

inline
BasicBlock *        Compiler::genCreateTempLabel()
{
    BasicBlock  *   block = bbNewBasicBlock(BBJ_NONE);
    block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
#ifdef DEBUG
    block->bbTgtStkDepth = genStackLevel / sizeof(int);
#endif
    return  block;
}

inline
void                Compiler::genDefineTempLabel(BasicBlock *label, bool inBlock)
{
#ifdef  DEBUG
    if  (dspCode) printf("\n      L_M%03u_BB%02u:\n", Compiler::s_compMethodsCount, label->bbNum);
#endif

    genEmitter->emitAddLabel(&label->bbEmitCookie,
                             gcVarPtrSetCur,
                             gcRegGCrefSetCur,
                             gcRegByrefSetCur);

    /* gcRegGCrefSetCur does not account for redundant load-suppression
       of GC vars, and the emitter will not know about */

    rsTrackRegClrPtr();
}

/*****************************************************************************
 *
 * Generate code for an out-of-line exception.
 * For debuggable code, we generate the 'throw' inline.
 * For non-dbg code, we share the helper blocks created by fgAddCodeRef().
 */

void            Compiler::genJumpToThrowHlpBlk(emitJumpKind jumpKind,
                                               addCodeKind  codeKind,
                                               GenTreePtr   failBlk)
{
    if (!opts.compDbgCode)
    {
        /* For non-debuggable code, find and use the helper block for
           raising the exception. The block may be shared by other trees too. */

        BasicBlock * tgtBlk;

        if (failBlk)
        {
            /* We already know which block to jump to. Use that. */

            assert(failBlk->gtOper == GT_LABEL);
            tgtBlk = failBlk->gtLabel.gtLabBB;
            assert(tgtBlk == fgFindExcptnTarget(codeKind, compCurBB->bbTryIndex)->acdDstBlk);
        }
        else
        {
            /* Find the helper-block which raises the exception. */

            AddCodeDsc * add = fgFindExcptnTarget(codeKind, compCurBB->bbTryIndex);
            assert((add != NULL) && "ERROR: failed to find exception throw block");
            tgtBlk = add->acdDstBlk;
        }

        assert(tgtBlk);

        // Jump to the excption-throwing block on error.

        inst_JMP(jumpKind, tgtBlk, true, genCanSchedJMP2THROW(), true);
    }
    else
    {
        /* The code to throw the exception will be generated inline, and
           we will jump around it in the normal non-exception case */

        BasicBlock * tgtBlk = genCreateTempLabel();
        jumpKind = emitReverseJumpKind(jumpKind);
        inst_JMP(jumpKind, tgtBlk, true, genCanSchedJMP2THROW(), true);

        /* This code must match the tree that fgAddCodeRef would have created.
           Load the bbTryIndex and call the helper function. */

        if (compCurBB->bbTryIndex)
            inst_RV_IV(INS_mov, REG_ARG_0, compCurBB->bbTryIndex);
        else
            inst_RV_RV(INS_xor, REG_ARG_0, REG_ARG_0);

        genEmitHelperCall(acdHelper(codeKind), 0, 0);

        /* Define the spot for the normal non-exception case to jump to */

        genDefineTempLabel(tgtBlk, true);
    }
}

/*****************************************************************************
 *
 * The last operation done was generating code for "tree" and that would
 * have set the flags. Check if the operation caused an overflow
 * For small types, "reg" is where the result register. We need to sign-extend it
 */

inline
void            Compiler::genCheckOverflow(GenTreePtr tree, regNumber reg)
{
    var_types  type = tree->TypeGet();

    // Overflow-check should be asked for for this tree
    assert(tree->gtOverflow());

#if TGT_x86

    emitJumpKind jumpKind = (tree->gtFlags & GTF_UNSIGNED) ? EJ_jb : EJ_jo;

    // Jump to the block which will throw the expection

    genJumpToThrowHlpBlk(jumpKind, ACK_OVERFLOW);

    // No sign extension needed for TYP_INT,TYP_LONG,
    // so 'reg' can be ignored. Else it should be valid

    assert(genIsValidReg(reg) || genTypeSize(type) >= sizeof(int));

    switch(type)
    {
   case TYP_BYTE:

        assert(genRegMask(reg) & RBM_BYTE_REGS);
        // Fall-through

    case TYP_SHORT:

        // ISSUE : Should we select another register to expand the value into

        inst_RV_RV(INS_movsx, reg, reg, type, emitTypeSize(type));
        break;

    case TYP_UBYTE:
    case TYP_CHAR:
        inst_RV_RV(INS_movzx, reg, reg, type, emitTypeSize(type));
        break;

    default:
        break;
    }

#else

    assert(!"need non-x86 overflow checking code");

#endif

}

inline
static regMaskTP exclude_EDX(regMaskTP mask)
{
    unsigned result = (mask & ~RBM_EDX);
    if (result)
        return result;
    else
        return RBM_ALL & ~RBM_EDX;
}

/*****************************************************************************
 *  Spill registers to check callers can handle it.
 */

#ifdef DEBUG

void                Compiler::genStressRegs(GenTreePtr tree)
{
    if (rsStressRegs() < 2)
        return;

    /* Spill as many registers as possible. Callers should be prepared
       to handle this case */

    regMaskTP spillRegs = rsRegMaskCanGrab() & rsMaskUsed;

    if (spillRegs)
        rsSpillRegs(spillRegs);

    regMaskTP trashRegs = rsRegMaskFree();

    if (trashRegs == RBM_NONE)
        return;

    /* It is sometimes reasonable to expect that calling genCodeForTree()
       on certain trees wont spill anything */

    if (tree->gtFlags & GTF_OTHER_SIDEEFF)
        trashRegs &= ~(RBM_EAX|RBM_EDX); // GT_CATCH_ARG or GT_BB_QMARK

    // If genCodeForTree() effectively gets called a second time on the same tree

    if (tree->gtFlags & GTF_REG_VAL)
    {
        assert(varTypeIsIntegral(tree->gtType) || varTypeIsGC(tree->gtType));
        trashRegs &= ~genRegMask(tree->gtRegNum);
    }

    if (tree->gtType == TYP_INT && tree->OperIsSimple())
    {
        GenTreePtr  op1 = tree->gtOp.gtOp1;
        GenTreePtr  op2 = tree->gtOp.gtOp2;
        if (op1 && (op1->gtFlags & GTF_REG_VAL))
            trashRegs &= ~genRegMask(op1->gtRegNum);
        if (op2 && (op2->gtFlags & GTF_REG_VAL))
            trashRegs &= ~genRegMask(op2->gtRegNum);
    }

    if (compCurBB == genReturnBB)
    {
        // The return value is sitting in an unprotected register.

        if (varTypeIsIntegral(info.compRetType) ||
            varTypeIsGC      (info.compRetType))
            trashRegs &= ~RBM_INTRET;
        else if (genActualType(info.compRetType) == TYP_LONG)
            trashRegs &= ~RBM_LNGRET;

        if (info.compCallUnmanaged)
        {
            LclVarDsc * varDsc = &lvaTable[info.compLvFrameListRoot];
            if (varDsc->lvRegister)
                trashRegs &= ~genRegMask(varDsc->lvRegNum);
        }
    }

    /* Now trash the registers. We use rsMaskModf, else we will have
       to save/restore the register. We try to be as unintrusive
       as possible */

    assert((REG_LAST - REG_FIRST) == 7);
    for (regNumber reg = REG_FIRST; reg <= REG_LAST; reg = REG_NEXT(reg))
    {
        regMaskTP   regMask = genRegMask(reg);

        if (regMask & trashRegs & rsMaskModf)
            genSetRegToIcon(reg, 0);
    }
}

#endif


/*****************************************************************************
 *
 *  Generate code for a GTK_CONST tree
 */

void                Compiler::genCodeForTreeConst(GenTreePtr tree,
                                                  regMaskTP  destReg,
                                                  regMaskTP  bestReg)
{
    genTreeOps      oper    = tree->OperGet();
    regNumber       reg;
    regMaskTP       needReg = destReg;

#ifdef DEBUG
    reg  =  (regNumber)0xFEEFFAAF;              // to detect uninitialized use
#endif

    assert(tree->OperKind() & GTK_CONST);
    
    switch (oper)
    {
        int             ival;

    case GT_CNS_INT:

        ival = tree->gtIntCon.gtIconVal;

#if!CPU_HAS_FP_SUPPORT
    INT_CNS:
#endif

#if REDUNDANT_LOAD

        /* If we are targeting destReg and ival is zero           */
        /* we would rather xor needReg than copy another register */

        if (((destReg == 0) || (ival != 0)) &&
            (!opts.compReloc || !(tree->gtFlags & GTF_ICON_HDL_MASK)))
        {
            /* Is the constant already in register? If so, use this register */

            reg = rsIconIsInReg(ival);
            if  (reg != REG_NA)
                break;
        }

#endif
        reg   = rsPickReg(needReg, bestReg);

        /* If the constant is a handle, we need a reloc to be applied to it */

        if (opts.compReloc && (tree->gtFlags & GTF_ICON_HDL_MASK))
        {
            genEmitter->emitIns_R_I(INS_mov, EA_4BYTE_CNS_RELOC, (emitRegs)reg, ival);
            rsTrackRegTrash(reg);
        }
        else
        {
            genSetRegToIcon(reg, ival, tree->TypeGet());            
        }
        break;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected constant node");
        NO_WAY("unexpected constant node");
    }

#ifdef  DEBUG
    /* Special case: GT_CNS_INT - Restore the current live set if it was changed */

    if  (!genTempLiveChg)
    {
        genCodeCurLife = genTempOldLife;
        genTempLiveChg = true;
    }
#endif

    genCodeForTree_DONE(tree, reg);
}


/*****************************************************************************
 *
 *  Generate code for a GTK_LEAF tree
 */

void                Compiler::genCodeForTreeLeaf(GenTreePtr tree,
                                                 regMaskTP  destReg,
                                                 regMaskTP  bestReg)
{
    genTreeOps      oper    = tree->OperGet();
    regNumber       reg;
    regMaskTP       regs    = rsMaskUsed;
    regMaskTP       needReg = destReg;
    size_t          size;

#ifdef DEBUG
    reg  =  (regNumber)0xFEEFFAAF;              // to detect uninitialized use
#endif

    assert(tree->OperKind() & GTK_LEAF);

    switch (oper)
    {
    case GT_REG_VAR:
        assert(!"should have been caught above");

    case GT_LCL_VAR:

        /* Does the variable live in a register? */

        if  (genMarkLclVar(tree))
        {
            genCodeForTree_REG_VAR1(tree, regs);
            return;
        }

#if REDUNDANT_LOAD

        /* Is the local variable already in register? */

        reg = rsLclIsInReg(tree->gtLclVar.gtLclNum);

        if (reg != REG_NA)
        {
            /* Use the register the variable happens to be in */
            regMaskTP regMask = genRegMask(reg);

            // If the register that it was in isn't one of the needRegs 
            // then try to move it into a needReg register

            if (((regMask & needReg) == 0) && (rsRegMaskCanGrab() & needReg))
            {
                regNumber rg2 = reg;
                reg = rsPickReg(needReg, bestReg, tree->TypeGet());
                if (reg != rg2)
                {
                    regMask = genRegMask(reg);
                    inst_RV_RV(INS_mov, reg, rg2, tree->TypeGet()); 
                }
            }

            gcMarkRegPtrVal (reg, tree->TypeGet());
            rsTrackRegLclVar(reg, tree->gtLclVar.gtLclNum);
            break;
        }

#endif

#if TGT_RISC

        /* Pick a register for the value */

        reg = rsPickReg(needReg, bestReg, tree->TypeGet());

        /* Load the variable into the register */

        inst_RV_TT(INS_mov, reg, tree, 0);

        gcMarkRegPtrVal (reg, tree->TypeGet());
        rsTrackRegLclVar(reg, tree->gtLclVar.gtLclNum);
        break;

    case GT_LCL_FLD:

        // We only use GT_LCL_FLD for lvAddrTaken vars, so we dont have
        // to worry about it being enregistered.
        assert(lvaTable[tree->gtLclFld.gtLclNum].lvRegister == 0);

        // We only create GT_LCL_FLD while morphing if the offset is
        // not too large as the emitter cant handle it
        assert(sizeof(short) == sizeof(emitter::emitLclVarAddr::lvaOffset) &&
               tree->gtLclFld.gtLclOffs < USHORT_MAX);
        // fall-through

    case GT_CLS_VAR:

        reg = rsClsVarIsInReg(tree->gtClsVar.gtClsVarHnd);

        if (reg != REG_NA)
            break;

        /* Pick a register for the address/value */

        reg = rsPickReg(needReg, bestReg, TYP_INT);

        /* Load the variable value into the register */

        inst_RV_TT(INS_mov, reg, tree, 0);

        rsTrackRegClsVar(reg, tree);
        gcMarkRegPtrVal(reg, tree->TypeGet());
        break;

#else

        goto MEM_LEAF;

    case GT_LCL_FLD:

        // We only use GT_LCL_FLD for lvAddrTaken vars, so we dont have
        // to worry about it being enregistered.
        assert(lvaTable[tree->gtLclFld.gtLclNum].lvRegister == 0);
        goto MEM_LEAF;

    case GT_CLS_VAR:

        reg = rsClsVarIsInReg(tree->gtClsVar.gtClsVarHnd);

        if (reg != REG_NA)
            break;

    MEM_LEAF:

        /* Pick a register for the value */

        reg = rsPickReg(needReg, bestReg, tree->TypeGet());

        /* Load the variable into the register */

        size = genTypeSize(tree->gtType);

        if  (size < EA_4BYTE)
        {
            bool        uns = varTypeIsUnsigned(tree->TypeGet());

            inst_RV_TT(uns ? INS_movzx : INS_movsx, reg, tree, 0);

            /* We've now "promoted" the tree-node to TYP_INT */

            tree->gtType = TYP_INT;
        }
        else
        {
            inst_RV_TT(INS_mov, reg, tree, 0);
        }

        rsTrackRegTrash(reg);

        gcMarkRegPtrVal (reg, tree->TypeGet());

        switch(oper)
        {
        case GT_CLS_VAR:
            rsTrackRegClsVar(reg, tree);
            break;
        case GT_LCL_VAR:
            rsTrackRegLclVar(reg, tree->gtLclVar.gtLclNum);
            break;
        case GT_LCL_FLD:
            break;
        default: assert(!"Unexpected oper");
        }

        break;

    case GT_BREAK:
        // @TODO: [CLEANUP] [04/16/01] [] Remove GT_BREAK if cee_break will continue to invoke a helper call.
        assert(!"Currently replaced by CORINFO_HELP_USER_BREAKPOINT");
        instGen(INS_int3);
        reg = REG_STK;
        break;

    case GT_NO_OP:
        assert(opts.compDbgCode); // Should normally be optimized away
        instGen(INS_nop);
        reg = REG_STK;
        break;

    case GT_END_LFIN:

        /* Have to clear the shadowSP of the nesting level which
           encloses the finally */

        unsigned    finallyNesting;
        finallyNesting = tree->gtVal.gtVal1;
        assert(finallyNesting < info.compXcptnsCount);

        unsigned    shadowSPoffs;
        shadowSPoffs = lvaShadowSPfirstOffs + finallyNesting * sizeof(void*);

        genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0, SR_EBP,
                                  SR_NA, -shadowSPoffs);
        if (genInterruptible && opts.compSchedCode)
            genEmitter->emitIns_SchedBoundary();
        reg = REG_STK;
        break;

#endif // TGT_RISC


#if TGT_x86

    case GT_BB_QMARK:

        /* The "_?" value is always in EAX */
        /* @TODO [CONSIDER] [04/16/01] []: Don't always load the value into EAX! */

        reg  = REG_EAX;
        break;
#endif

    case GT_CATCH_ARG:

        assert(compCurBB->bbCatchTyp && handlerGetsXcptnObj(compCurBB->bbCatchTyp));

        /* Catch arguments get passed in a register. genCodeForBBlist()
           would have marked it as holding a GC object, but not used. */

        assert(gcRegGCrefSetCur & RBM_EXCEPTION_OBJECT);
        reg = REG_EXCEPTION_OBJECT;
        break;

    case GT_JMP:
        genCodeForTreeLeaf_GT_JMP(tree);
        return;

#ifdef  DEBUG
    default:
        gtDispTree(tree);
        assert(!"unexpected leaf");
#endif
    }

    genCodeForTree_DONE(tree, reg);
}


/*****************************************************************************
 *
 *  Generate code for the a leaf node of type GT_JMP
 */

void                Compiler::genCodeForTreeLeaf_GT_JMP(GenTreePtr tree)
{
    assert(compCurBB->bbFlags & BBF_HAS_JMP);

#ifdef PROFILER_SUPPORT
    if (opts.compEnterLeaveEventCB)
    {
#if     TGT_x86
        /* fire the event at the call site */
        unsigned         saveStackLvl2 = genStackLevel;
        BOOL             bHookFunction = TRUE;
        CORINFO_PROFILING_HANDLE handleFrom, *pHandleFrom;

        handleFrom = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandleFrom);
        assert((!handleFrom) != (!pHandleFrom));

        // Give profiler a chance to back out of hooking this method
        if (bHookFunction)
        {
            if (handleFrom)
                inst_IV(INS_push, (unsigned) handleFrom);
            else
                genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                         SR_NA, SR_NA, (int)pHandleFrom);

            genSinglePush(false);

            genEmitHelperCall(CORINFO_HELP_PROF_FCN_TAILCALL,
                              sizeof(int),   // argSize
                              0);            // retSize

            /* Restore the stack level */
            genStackLevel = saveStackLvl2;
            genOnStackLevelChanged();
        }
#endif // TGT_x86
    }
#endif // PROFILER_SUPPORT

    /* Make sure register arguments are in their initial registers */

    if  (rsCalleeRegArgNum)
    {
        assert(rsCalleeRegArgMaskLiveIn);

        unsigned        varNum;
        LclVarDsc   *   varDsc;

        for (varNum = 0, varDsc = lvaTable;
             varNum < info.compArgsCount;
             varNum++  , varDsc++)
        {
            assert(varDsc->lvIsParam);

            /* Is this variable a register arg? */

            if  (!varDsc->lvIsRegArg)
                continue;
            else
            {
                /* Register argument */

                assert(isRegParamType(genActualType(varDsc->TypeGet())));

                if  (varDsc->lvRegister)
                {
                    /* Check if it remained in the same register */

                    if  (varDsc->lvRegNum != varDsc->lvArgReg)
                    {
                        /* Move it back to the arg register */

                        inst_RV_RV(INS_mov, (regNumber)varDsc->lvArgReg,
                                            (regNumber)varDsc->lvRegNum, varDsc->TypeGet());
                    }
                }
                else
                {
                    /* Argument was passed in register, but ended up on the stack
                     * Reload it from the stack */

                    emitAttr size = emitTypeSize(varDsc->TypeGet());

                    genEmitter->emitIns_R_S(INS_mov,
                                            size,
                                            (emitRegs)(regNumber)varDsc->lvArgReg,
                                            varNum,
                                            0);
                }
            }
        }
    }
}


/*****************************************************************************
 *
 *  Generate code for a qmark colon
 */

void                Compiler::genCodeForQmark(GenTreePtr tree,
                                              regMaskTP  destReg,
                                              regMaskTP  bestReg)
{
    GenTreePtr      op1      = tree->gtOp.gtOp1;
    GenTreePtr      op2      = tree->gtOp.gtOp2;
    regNumber       reg;
    regMaskTP       regs     = rsMaskUsed;
    regMaskTP       needReg  = destReg;
    
    assert(tree->gtOper == GT_QMARK);
    assert(op1->OperIsCompare());
    assert(op2->gtOper == GT_COLON);

    GenTreePtr      thenNode = op2->gtOp.gtOp1;
    GenTreePtr      elseNode = op2->gtOp.gtOp2;

    /* If thenNode is a Nop node you must reverse the 
       thenNode and elseNode prior to reaching here! */
    
    assert(!thenNode->IsNothingNode());

    /* Try to implement the qmark colon using a CMOV.  If we can't for
       whatever reason, this will return false and we will implement
       it using regular branching constructs. */
    
    if (genCodeForQmarkWithCMOV(tree, destReg, bestReg))
        return;
    
    /*
        This is a ?: operator; generate code like this:

            condition_compare
            jmp_if_true lab_false

        lab_true:
            op1 (true = 'then' part)
            jmp lab_done

        lab_false:
            op2 (false = 'else' part)

        lab_done:


        NOTE: If no 'else' part we do not generate the 'jmp lab_done'
            or the 'lab_done' label
    */

    BasicBlock *    lab_true;
    BasicBlock *    lab_false;
    BasicBlock *    lab_done;

    genLivenessSet  entryLiveness;
    genLivenessSet  exitLiveness;

    lab_true  = genCreateTempLabel();
    lab_false = genCreateTempLabel();


    /* Spill any register that hold partial values so that the exit liveness
       from sides is the same */

    if (rsMaskUsed)
    {
        /* If rsMaskUsed overlaps with rsMaskVars (multi-use of the enregistered
           variable), then it may not get spilled. However, the variable may
           then go dead within thenNode/elseNode, at which point rsMaskUsed
           may get spilled from one side and not the other. So unmark rsMaskVars
           before spilling rsMaskUsed */

        // rsAdditional holds the variables we're going to spill (these are
        // enregistered and marked as used).
        regMaskTP rsAdditional = rsMaskUsed & rsMaskVars;
        regMaskTP rsSpill = (rsMaskUsed & ~rsMaskVars) | rsAdditional;
        if (rsSpill)
        {
            // Remember which registers hold pointers. We will spill 
            // them, but the code that follows will fetch reg vars from
            // the registers, so we need that gc info.            
            regMaskTP gcRegSavedByref = gcRegByrefSetCur & rsAdditional;
            regMaskTP gcRegSavedGCRef = gcRegGCrefSetCur & rsAdditional;
            regMaskTP   rsTemp = rsMaskVars;
            rsMaskVars = RBM_NONE;
            
            rsSpillRegs( rsMaskUsed );

            // Restore gc tracking masks.
            gcRegByrefSetCur |= gcRegSavedByref;
            gcRegGCrefSetCur |= gcRegSavedGCRef;

            // Set maskvars back to normal
            rsMaskVars = rsTemp;
        }               
    }

    /* Generate the conditional jump */

    genCondJump(op1, lab_false, lab_true);

    /* the "colon or op2" liveSet  has liveness information        */
    /* which is the union of both the then and else parts          */

    genUpdateLife(op2);

    /* Save the current liveness, register status, and GC pointers */
    /* This is the liveness information upon entry                 */
    /* to both the then and else parts of the qmark                */

    saveLiveness(&entryLiveness);

    /* Clear the liveness of any local varbles that are dead upon     */
    /* entry to the then part.                                        */

    /* Subtract the liveSet upon entry of the then part (op1->gtNext) */
    /* from the "colon or op2" liveSet                                */
    genDyingVars(op2->gtLiveSet, op1->gtNext);

    /* genCondJump() closes the current emitter block */

    genDefineTempLabel(lab_true, true);

    /* Does the operator yield a value? */

    if  (tree->gtType == TYP_VOID)
    {
        /* Generate the code for the then part of the qmark */

        genCodeForTree(thenNode, needReg, bestReg);

        /* The type is VOID, so we shouldn't have computed a value */

        assert(!(thenNode->gtFlags & GTF_REG_VAL));

        /* Save the current liveness, register status, and GC pointers               */
        /* This is the liveness information upon exit of the then part of the qmark  */

        saveLiveness(&exitLiveness);

        /* Is there an 'else' part? */

        if  (gtIsaNothingNode(elseNode))
        {
            /* No 'else' - just generate the 'lab_false' label */

            genDefineTempLabel(lab_false, true);
        }
        else
        {
            lab_done  = genCreateTempLabel();

            /* Generate jmp lab_done */

            inst_JMP  (EJ_jmp, lab_done, false, false, true);

            /* Restore the liveness that we had upon entry of the then part of the qmark */

            restoreLiveness(&entryLiveness);

            /* Clear the liveness of any local varbles that are dead upon      */
            /* entry to the else part.                                         */

            /* Subtract the liveSet upon entry of the else part (op2->gtNext)  */
            /* from the "colon or op2" liveSet                                 */
            genDyingVars(op2->gtLiveSet, op2->gtNext);

            /* Generate lab_false: */

            genDefineTempLabel(lab_false, true);

            /* Enter the else part - trash all registers */


            rsTrackRegClr();

            /* Generate the code for the else part of the qmark */

            genCodeForTree(elseNode, needReg, bestReg);

            /* The type is VOID, so we shouldn't have computed a value */

            assert(!(elseNode->gtFlags & GTF_REG_VAL));

            /* Verify that the exit liveness information is same for the two parts of the qmark */

            checkLiveness(&exitLiveness);

            /* Define the "result" label */

            genDefineTempLabel(lab_done, true);
        }

        /* Join of the two branches - trash all registers */

        rsTrackRegClr();

        /* We're just about done */

        genUpdateLife(tree);
    }
    else
    {
        /* Generate the code for the then part of the qmark */

        assert(gtIsaNothingNode(thenNode) == false);
                    
        /* Compute the thenNode into any free register */
        genComputeReg(thenNode, needReg, ANY_REG, FREE_REG, true);
        assert(thenNode->gtFlags & GTF_REG_VAL);
        assert(thenNode->gtRegNum != REG_NA);                

        /* Record the chosen register */
        reg  = thenNode->gtRegNum;
        regs = genRegMask(reg);

        /* Save the current liveness, register status, and GC pointers               */
        /* This is the liveness information upon exit of the then part of the qmark  */

        saveLiveness(&exitLiveness);

        /* Generate jmp lab_done */

        lab_done  = genCreateTempLabel();
        inst_JMP  (EJ_jmp, lab_done, false, false, true);

        /* Restore the liveness that we had upon entry of the then part of the qmark */

        restoreLiveness(&entryLiveness);

        /* Clear the liveness of any local varbles that are dead upon      */
        /* entry to the then part.                                         */

        /* Subtract the liveSet upon entry of the else part (op2->gtNext)  */
        /* from the "colon or op2" liveSet                                 */
        genDyingVars(op2->gtLiveSet, op2->gtNext);

        /* Generate lab_false: */

        genDefineTempLabel(lab_false, true);

        /* Enter the else part - trash all registers */

        rsTrackRegClr();

        /* Generate the code for the else part of the qmark */

        assert(gtIsaNothingNode(elseNode) == false);

        /* This must place a value into the chosen register */
        genComputeReg(elseNode, regs, EXACT_REG, FREE_REG, true);

        assert(elseNode->gtFlags & GTF_REG_VAL);
        assert(elseNode->gtRegNum == reg);

        /* Verify that the exit liveness information is same for the two parts of the qmark */
        checkLiveness(&exitLiveness);

        /* Define the "result" label */
        genDefineTempLabel(lab_done, true);

        /* Join of the two branches - trash all registers */

        rsTrackRegClr();

        /* Check whether this subtree has freed up any variables */

        genUpdateLife(tree);

        tree->gtFlags   |= GTF_REG_VAL;
        tree->gtRegNum   = reg;
    }
    return;
}


/*****************************************************************************
 *
 *  Generate code for a qmark colon using the CMOV instruction.  It's OK
 *  to return false when we can't easily implement it using a cmov (leading
 *  genCodeForQmark to implement it using branches).
 */

bool                Compiler::genCodeForQmarkWithCMOV(GenTreePtr tree,
                                                      regMaskTP  destReg,
                                                      regMaskTP  bestReg)
{
    GenTreePtr      cond     = tree->gtOp.gtOp1;
    GenTreePtr      colon    = tree->gtOp.gtOp2;
    GenTreePtr      thenNode = colon->gtOp.gtOp1;
    GenTreePtr      elseNode = colon->gtOp.gtOp2;
    GenTreePtr      alwaysNode, predicateNode;
    regNumber       reg;
    regMaskTP       needReg  = destReg;

    assert(tree->gtOper == GT_QMARK);
    assert(cond->OperIsCompare());
    assert(colon->gtOper == GT_COLON);

#ifdef DEBUG
    static ConfigDWORD fJitNoCMOV(L"JitNoCMOV", 0);
    if (fJitNoCMOV.val())
    {
        return false;
    }
#endif

    /* Can only implement CMOV on processors that support it */

    if (!opts.compUseCMOV)
    {
        return false;
    }

    /* thenNode better be a local or a constant */

    if ((thenNode->OperGet() != GT_CNS_INT) && 
        (thenNode->OperGet() != GT_LCL_VAR))
    {
        return false;
    }

    /* elseNode better be a local or a constant or nothing */

    if ((elseNode->OperGet() != GT_CNS_INT) && 
        (elseNode->OperGet() != GT_LCL_VAR))
    {
        return false;
    }

    /* can't handle two constants here */

    if ((thenNode->OperGet() == GT_CNS_INT) &&
        (elseNode->OperGet() == GT_CNS_INT))
    {
        return false;
    }

    /* let's not handle comparisons of non-integer types */

    if (!varTypeIsI(cond->gtOp.gtOp1->gtType))
    {
        return false;
    }

    /* Choose nodes for predicateNode and alwaysNode.  Swap cond if necessary.
       The biggest constraint is that cmov doesn't take an integer argument.
    */

    bool reverseCond = false;
    if (elseNode->OperGet() == GT_CNS_INT)
    {
        // else node is a constant

        alwaysNode    = elseNode;
        predicateNode = thenNode;
        reverseCond    = true;
    }
    else
    {   
        alwaysNode    = thenNode;
        predicateNode = elseNode;
    }

    // If the live set in alwaysNode is not the same as in tree, then
    // the variable in predicate node dies here.  This is a dangerous
    // case that we don't handle (genComputeReg could overwrite
    // the value of the variable in the predicate node).

    if (colon->gtLiveSet != alwaysNode->gtLiveSet)
    {
        return false;
    }

    // Pass this point we are comitting to use CMOV.
    
    if (reverseCond)
    {
        cond->gtOper  = GenTree::ReverseRelop(cond->gtOper);
    }

    emitJumpKind jumpKind = genCondSetFlags(cond);

    // Compute the always node into any free register.  If it's a constant,
    // we need to generate the mov instruction here (otherwise genComputeReg might
    // modify the flags, as in xor reg,reg).

    if (alwaysNode->OperGet() == GT_CNS_INT)
    {
        reg = rsPickReg(needReg, bestReg, predicateNode->TypeGet());
        inst_RV_IV(INS_mov, reg, alwaysNode->gtIntCon.gtIconVal, alwaysNode->TypeGet());
        gcMarkRegPtrVal(reg, alwaysNode->TypeGet());
        rsTrackRegTrash(reg);
    }
    else
    {
        genComputeReg(alwaysNode, needReg, ANY_REG, FREE_REG, true);
        assert(alwaysNode->gtFlags & GTF_REG_VAL);
        assert(alwaysNode->gtRegNum != REG_NA);

        // Record the chosen register

        reg  = alwaysNode->gtRegNum;
    }

    regNumber regPredicate = REG_NA;

    // Is predicateNode an enregistered variable?

    if (genMarkLclVar(predicateNode))
    {
        // Variable lives in a register
        
        regPredicate = predicateNode->gtRegNum;
    }
#if REDUNDANT_LOAD
    else
    {
        // Checks if the variable happens to be in any of the registers

        regPredicate = rsLclIsInReg(predicateNode->gtLclVar.gtLclNum);
    }
#endif

    const static
    instruction EJtoCMOV[] =
    {
        INS_nop,
        INS_nop,
        INS_cmovo,
        INS_cmovno,
        INS_cmovb,
        INS_cmovae,
        INS_cmove,
        INS_cmovne,
        INS_cmovbe,
        INS_cmova,
        INS_cmovs,
        INS_cmovns,
        INS_cmovpe,
        INS_cmovpo,
        INS_cmovl,
        INS_cmovge,
        INS_cmovle,
        INS_cmovg
    };

    assert(jumpKind < (sizeof(EJtoCMOV) / sizeof(EJtoCMOV[0])));
    instruction cmov_ins = EJtoCMOV[jumpKind];

    assert(insIsCMOV(cmov_ins));

    if (regPredicate != REG_NA)
    {
        // regPredicate is in a register

        inst_RV_RV(cmov_ins, reg, regPredicate, predicateNode->TypeGet());
    }
    else
    {
        // regPredicate is in memory

        inst_RV_TT(cmov_ins, reg, predicateNode, NULL);
    }
    gcMarkRegPtrVal(reg, predicateNode->TypeGet());
    rsTrackRegTrash(reg);

    genCodeForTree_DONE_LIFE(tree, reg);
    return true;
}



/*****************************************************************************
 *
 *  Generate code for a GTK_SMPOP tree
 */

void                Compiler::genCodeForTreeSmpOp(GenTreePtr tree,
                                                  regMaskTP  destReg,
                                                  regMaskTP  bestReg)
{
    genTreeOps      oper     = tree->OperGet();
    const var_types treeType = tree->TypeGet();
    GenTreePtr      op1      = tree->gtOp.gtOp1;
    GenTreePtr      op2      = tree->gtGetOp2();
    regNumber       reg;
    regMaskTP       regs     = rsMaskUsed;
    regMaskTP       needReg  = destReg;
    emitAttr        size;
    instruction     ins;
    bool            gotOp1;
    bool            isArith;
    bool            op2Released;
    regMaskTP       addrReg;
    GenTreePtr      opsPtr[3];
    regMaskTP       regsPtr[3];
    bool            ovfl = false;        // Do we need an overflow check
    unsigned        val;
    regMaskTP       tempRegs;
    
    bool            multEAX;
    bool            andv;
    BOOL            unsv;
    unsigned        mask;

#ifdef DEBUG
    reg  =  (regNumber)0xFEEFFAAF;              // to detect uninitialized use
    addrReg = 0xDEADCAFE;
#endif

    assert(tree->OperKind() & GTK_SMPOP);

    switch (oper)
    {
        case GT_ASG:

            genCodeForTreeSmpOpAsg(tree, destReg, bestReg);
            return;

#if TGT_x86

        case GT_ASG_LSH: ins = INS_shl; goto ASG_SHF;
        case GT_ASG_RSH: ins = INS_sar; goto ASG_SHF;
        case GT_ASG_RSZ: ins = INS_shr; goto ASG_SHF;

        ASG_SHF:

            assert(!varTypeIsGC(tree->TypeGet()));
            assert(op2);

            /* Shifts by a constant amount are easier */

            if  (op2->gtOper == GT_CNS_INT)
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, FREE_REG, true);

                /* Are we shifting a register left by 1 bit? */

                if  (op2->gtIntCon.gtIconVal == 1 &&
                     (op1->gtFlags & GTF_REG_VAL) && oper == GT_ASG_LSH)
                {
                    /* The target lives in a register */

                    reg  = op1->gtRegNum;

                    /* "add reg, reg" is cheaper than "shl reg, 1" */

                    inst_RV_RV(INS_add, reg, reg, tree->TypeGet());
                }
                else
                {
                    /* Shift by the constant value */

                    inst_TT_SH(ins, op1, op2->gtIntCon.gtIconVal);
                }

                /* If the target is a register, it has a new value */

                if  (op1->gtFlags & GTF_REG_VAL)
                    rsTrackRegTrash(op1->gtRegNum);

                genDoneAddressable(op1, addrReg, FREE_REG);

                /* The zero flag is now equal to the target value */
                /* But only if the shift count is != 0 */

                if (op2->gtIntCon.gtIconVal != 0)
                {
                    if       (op1->gtOper == GT_LCL_VAR)
                        genFlagsEqualToVar(tree, op1->gtLclVar.gtLclNum, false);
                    else if  (op1->gtOper == GT_REG_VAR)
                        genFlagsEqualToReg(tree, op1->         gtRegNum, false);
                }
                else
                {
                    // It is possible for the shift count to equal 0 with valid
                    // IL, and not be optimized away, in the case where the node
                    // is of a small type.  The sequence of instructions looks like
                    // ldsfld, shr, stsfld and executed on a char field.  This will
                    // never happen with code produced by our compilers, because the
                    // compilers will insert a conv.u2 before the stsfld (which will
                    // lead us down a different codepath in the JIT and optimize away
                    // the shift by zero).  This case is not worth optimizing and we
                    // will just make sure to generate correct code for it.

                    genFlagsEqualToNone();
                }

            }
            else
            {
                if (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    tempRegs = rsMustExclude(RBM_ECX, op1->gtRsvdRegs);
                    genCodeForTree(op2, tempRegs);
                    rsMarkRegUsed(op2);

                    tempRegs = rsMustExclude(RBM_ALL, genRegMask(op2->gtRegNum));
                    addrReg = genMakeAddressable(op1, tempRegs, KEEP_REG, true);

                    genRecoverReg(op2, RBM_ECX, KEEP_REG);
                }
                else
                {
                    /* Make the target addressable avoiding op2->RsvdRegs and ECX */

                    tempRegs = rsMustExclude(RBM_ALL, op2->gtRsvdRegs|RBM_ECX);
                    addrReg = genMakeAddressable(op1, tempRegs, KEEP_REG, true);

                    /* Load the shift count into ECX */

                    genComputeReg(op2, RBM_ECX, EXACT_REG, KEEP_REG);
                }

                /* Make sure the address is still there, and free it */

                genDoneAddressable(op1, genKeepAddressable(op1, addrReg, RBM_ECX), KEEP_REG);

                /* Perform the shift */

                inst_TT_CL(ins, op1);

                /* If the value is in a register, it's now trash */

                if  (op1->gtFlags & GTF_REG_VAL)
                    rsTrackRegTrash(op1->gtRegNum);

                /* Release the ECX operand */

                genReleaseReg(op2);
            }

            genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
            return;

#else

        case GT_ASG_LSH:
        case GT_ASG_RSH:
        case GT_ASG_RSZ:

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif
        case GT_ASG_OR : ins = INS_or ; goto ASG_OPR;
        case GT_ASG_XOR: ins = INS_xor; goto ASG_OPR;
        case GT_ASG_AND: ins = INS_and; goto ASG_OPR;

        case GT_ASG_SUB: ins = INS_sub; goto ASG_ARITH;
        case GT_ASG_ADD: ins = INS_add; goto ASG_ARITH;

        ASG_ARITH:

//            assert(!varTypeIsGC(tree->TypeGet()));

            ovfl = tree->gtOverflow();

            // We cant use += with overflow if the value cannot be changed
            // in case of an overflow-exception which the "+" might cause
            assert(!ovfl ||
                   ((op1->gtOper == GT_LCL_VAR || op1->gtOper == GT_LCL_FLD) &&
                    !compCurBB->bbTryIndex));

            /* Do not allow overflow instructions with refs/byrefs */

            assert(!ovfl || !varTypeIsGC(tree->TypeGet()));

#if TGT_x86
            // We disallow overflow and byte-ops here as it is too much trouble
            assert(!ovfl || !varTypeIsByte(treeType));
#endif

            /* Is the second operand a constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                long        ival = op2->gtIntCon.gtIconVal;

                /* What is the target of the assignment? */

                switch (op1->gtOper)
                {
                case GT_REG_VAR:

                REG_VAR4:

                    reg = op1->gtRegVar.gtRegNum;

                    /* No registers are needed for addressing */

                    addrReg = 0;

                INCDEC_REG:

                    /* We're adding a constant to a register */

                    if  (oper == GT_ASG_ADD)
                        genIncRegBy(reg,  ival, tree, treeType, ovfl);
                    else if (ovfl && (tree->gtFlags & GTF_UNSIGNED))
                        /* For unsigned overflow, we have to use INS_sub to set
                           the flags correctly */
                        genDecRegBy(reg,  ival, tree);
                    else
                        genIncRegBy(reg, -ival, tree, treeType, ovfl);

                    break;

                case GT_LCL_VAR:

                    /* Does the variable live in a register? */

                    if  (genMarkLclVar(op1))
                        goto REG_VAR4;

                    // Fall through ....

                default:

#if     TGT_x86

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, needReg, FREE_REG, true);

                    /* For small types with overflow check, we need to
                       sign/zero extend the result, so we need it in a reg */

                    if (ovfl && genTypeSize(treeType) < sizeof(int))
                    {
                        // Load op1 into a reg

                        reg = rsPickReg();

                        inst_RV_TT(INS_mov, reg, op1);

                        // Issue the add/sub and the overflow check

                        inst_RV_IV(ins, reg, ival, treeType);
                        rsTrackRegTrash(reg);

                        genCheckOverflow(tree, reg);

                        /* Store the (sign/zero extended) result back to
                           the stack location of the variable */

                        inst_TT_RV(INS_mov, op1, reg);

                        rsMarkRegFree(genRegMask(reg));

                        break;
                    }

                    /* Add/subtract the new value into/from the target */

                    if  (op1->gtFlags & GTF_REG_VAL)
                    {
                        reg = op1->gtRegNum;
                        goto INCDEC_REG;
                    }

                    /* Special case: inc/dec */
                    bool setCarry;
                    if (!ovfl && (ival == 1 || ival == -1)) {
                        assert(oper == GT_ASG_SUB || oper == GT_ASG_ADD);
                        if (oper == GT_ASG_SUB)
                            ival = -ival;
                        
                        ins = (ival > 0) ? INS_inc : INS_dec;
                        inst_TT(ins, op1);
                        setCarry = false;
                    }
                    else 
                    {
                        inst_TT_IV(ins, op1, ival);
                        setCarry = true;
                    }

                    /* For overflow instrs on small type, we will sign-extend the result */
                    if  (op1->gtOper == GT_LCL_VAR && (!ovfl || treeType == TYP_INT))
                        genFlagsEqualToVar(tree, op1->gtLclVar.gtLclNum, setCarry);             
#else

#ifdef  DEBUG
                    gtDispTree(tree);
#endif
                    assert(!"need non-x86 code");
#endif

                    break;
                }

                genDoneAddressable(op1, addrReg, FREE_REG);
                
                genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
                return;
            }

            // Fall through

ASG_OPR:
            assert(!varTypeIsGC(tree->TypeGet()) || ins == INS_sub || ins == INS_add);

            /* Is the target a register or local variable? */

            switch (op1->gtOper)
            {
            case GT_LCL_VAR:

                /* Does the target variable live in a register? */

                if  (!genMarkLclVar(op1))
                    break;

            case GT_REG_VAR:

                /* Get hold of the target register */

                reg = op1->gtRegVar.gtRegNum;

                /* Make sure the target of the store is available */

                if  (rsMaskUsed & genRegMask(reg))
                {
                    /* @TODO [CONSIDER] [04/16/01] []: We should be able to avoid this situation somehow */

                    rsSpillReg(reg);
                }

                /* Make the RHS addressable */

#if TGT_x86
                addrReg = genMakeRvalueAddressable(op2, 0, KEEP_REG);
#else
                genComputeReg(op2, 0, ANY_REG, KEEP_REG);
                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);
#endif

                /* Compute the new value into the target register */

                inst_RV_TT(ins, reg, op2, 0, emitTypeSize(treeType));

                /* The zero flag is now equal to the register value */

#if TGT_x86
                genFlagsEqualToReg(tree, reg, false);
#endif

                /* Remember that we trashed the target */

                rsTrackRegTrash(reg);

                /* Free up anything that was tied up by the RHS */

                genDoneAddressable(op2, addrReg, KEEP_REG);
                
                genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
                return;

            }

#if TGT_x86

            /* Special case: "x ^= -1" is actually "not(x)" */

            if  (oper == GT_ASG_XOR)
            {
                if  (op2->gtOper == GT_CNS_INT &&
                     op2->gtIntCon.gtIconVal == -1)
                {
                    addrReg = genMakeAddressable(op1, RBM_ALL, KEEP_REG, true);
                    inst_TT(INS_not, op1);
                    genDoneAddressable(op1, addrReg, KEEP_REG);
                    
                    genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, tree->gtRegNum, ovfl);
                    return;

                }
            }

            /* Setup target mask for op2 (byte-regs for small operands) */

            if (varTypeIsByte(tree->TypeGet()))
                mask = RBM_BYTE_REGS;
            else
                mask = RBM_ALL;

            /* Is the second operand a constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                long        ival = op2->gtIntCon.gtIconVal;

                /* Make the target addressable */
                addrReg = genMakeAddressable(op1, needReg, FREE_REG, true);

                inst_TT_IV(ins, op1, ival);

                genDoneAddressable(op1, addrReg, FREE_REG);
                
                genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, tree->gtRegNum, ovfl);
                return;
            }

            /* Is the value or the address to be computed first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Compute the new value into a register */

                genComputeReg(op2, mask, EXACT_REG, KEEP_REG);

                /* For small types with overflow check, we need to
                   sign/zero extend the result, so we need it in a reg */

                if  (ovfl && genTypeSize(treeType) < sizeof(int))
                {
                    reg = rsPickReg();
                    goto ASG_OPR_USING_REG;
                }

                /* Shall we "RISCify" the assignment? */

                if  ((op1->gtOper == GT_LCL_VAR || op1->gtOper == GT_LCL_FLD) &&
                     riscCode && compCurBB->bbWeight > BB_UNITY_WEIGHT)
                {
                    regMaskTP regFree;
                    regFree = rsRegMaskFree();

                    if  (rsFreeNeededRegCount(regFree) != 0)
                    {
                        reg = rsGrabReg(regFree);

ASG_OPR_USING_REG:
                        assert(genIsValidReg(reg));

                        /* Generate "mov tmp, [var]" */

                        inst_RV_TT(INS_mov, reg, op1);

                        /* Compute the new value */

                        inst_RV_RV(ins, reg, op2->gtRegNum, treeType, emitTypeSize(treeType));

                        if (ovfl) genCheckOverflow(tree, reg);

                        /* Move the new value back to the variable */

                        inst_TT_RV(INS_mov, op1, reg);

                        if (op1->gtOper == GT_LCL_VAR)
                            rsTrackRegLclVar(reg, op1->gtLclVar.gtLclNum);

                        /* Free up the register */

                        rsMarkRegFree(genRegMask(op2->gtRegNum));

                        addrReg = 0;

                        genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
                        return;

                    }
                }

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, KEEP_REG, true);

                /* Make sure the new value is in a register */

                genRecoverReg(op2, 0, FREE_REG);

                /* Add the new value into the target */

                inst_TT_RV(ins, op1, op2->gtRegNum);

                /* Free up anything that is tied up by the address */

                genDoneAddressable(op1, addrReg, KEEP_REG);
            }
            else
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, RBM_ALL & ~op2->gtRsvdRegs, KEEP_REG, true);

                /* Compute the new value into a register */

                genComputeReg(op2, mask, EXACT_REG, KEEP_REG);

                /* Make sure the target is still addressable */

                addrReg = genKeepAddressable(op1, addrReg);

                /* For small types with overflow check, we need to
                   sign/zero extend the result, so we need it in a reg */

                if (ovfl && genTypeSize(treeType) < sizeof(int))
                {
                    reg = rsPickReg();

                    inst_RV_TT(INS_mov, reg, op1);

                    inst_RV_RV(ins, reg, op2->gtRegNum, treeType, emitTypeSize(treeType));
                    rsTrackRegTrash(reg);

                    genCheckOverflow(tree, reg);

                    inst_TT_RV(INS_mov, op1, reg);

                    rsMarkRegFree(genRegMask(reg));
                }
                else
                {
                    /* Add the new value into the target */

                    inst_TT_RV(ins, op1, op2->gtRegNum);
                }

                /* Free up anything that was tied up either side */

                genDoneAddressable(op1, addrReg, KEEP_REG);
                genReleaseReg (op2);
            }

            genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
            return;



#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

        case GT_CHS:

#if TGT_x86

            addrReg = genMakeAddressable(op1, 0, KEEP_REG, true);
            inst_TT(INS_neg, op1, 0, 0, emitTypeSize(treeType));
            if (op1->gtFlags & GTF_REG_VAL)
                rsTrackRegTrash(op1->gtRegNum);

            genDoneAddressable(op1, addrReg, KEEP_REG);
            
            genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, tree->gtRegNum, ovfl);
            return;


#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

#if TGT_SH3

        case GT_AND: ins = INS_and;  isArith = false;  goto BIN_OPR;
        case GT_OR : ins = INS_or;   isArith = false;  goto BIN_OPR;
        case GT_XOR: ins = INS_xor;  isArith = false;  goto BIN_OPR;

        case GT_ADD: ins = INS_add;  goto ARITH;
        case GT_SUB: ins = INS_sub;  goto ARITH;
        case GT_MUL: ins = INS_mul;  goto ARITH;

#endif

#if TGT_x86

        case GT_AND: ins = INS_and;  isArith = false;  goto BIN_OPR;
        case GT_OR : ins = INS_or ;  isArith = false;  goto BIN_OPR;
        case GT_XOR: ins = INS_xor;  isArith = false;  goto BIN_OPR;

        case GT_ADD: ins = INS_add;  goto ARITH;
        case GT_SUB: ins = INS_sub;  goto ARITH;

        case GT_MUL: ins = INS_imul;

            /* Special case: try to use the 3 operand form "imul reg, op1, icon" */

            if  (op2->gtOper == GT_CNS_INT             &&  // op2 is a constant 
                 op1->gtOper != GT_CNS_INT             &&  // op1 is not a constant
                 (tree->gtFlags & GTF_MUL_64RSLT) == 0 &&  // tree not marked with MUL_64RSLT
                 !varTypeIsByte(treeType)              &&  // No encoding for say "imul al,al,imm"
                 !tree->gtOverflow()                     ) // 3 operand imul doesnt set flags
            {
                /* Make the first operand addressable */

                addrReg = genMakeRvalueAddressable(op1,
                                                   needReg & ~op2->gtRsvdRegs,
                                                   FREE_REG);

                /* Grab a register for the target */

                reg   = rsPickReg(needReg, bestReg);

                /* Compute the value into the target: reg=op1*op2_icon */

                inst_RV_TT_IV(INS_imul, reg, op1, op2->gtIntCon.gtIconVal);

                /* The register has been trashed now */

                rsTrackRegTrash(reg);

                /* The address is no longer live */

                genDoneAddressable(op1, addrReg, FREE_REG);

                ovfl = tree->gtOverflow();
                goto CHK_OVF;
            }

            goto ARITH;

#endif

        ARITH: // We reach here for GT_ADD, GT_SUB and GT_MUL.

            ovfl = tree->gtOverflow();

            /* We record the accurate (small) types in trees only we need to
             * check for overflow. Otherwise we record genActualType()
             */

            assert(ovfl || (treeType == genActualType(treeType)));

#if     LEA_AVAILABLE

            /* Can we use an 'lea' to compute the result?
               Can't use 'lea' for overflow as it doesnt set flags
               Can't use 'lea' unless we have at least one free register */

            if  (!ovfl &&
                 genMakeIndAddrMode(tree, NULL, true, needReg, FREE_REG, &regs, false))
            {
                /* Is the value now computed in some register? */

                if  (tree->gtFlags & GTF_REG_VAL)
                {
                    genCodeForTree_REG_VAR1(tree, regs);
                    return;
                }

                /* If we can reuse op1/2's register directly, and 'tree' is
                   a simple expression (ie. not in scaled index form),
                   might as well just use "add" instead of "lea" */

                if  (op1->gtFlags & GTF_REG_VAL)
                {
                    reg = op1->gtRegNum;

                    if  (genRegMask(reg) & rsRegMaskFree())
                    {
                        if (op2->gtFlags & GTF_REG_VAL)
                        {
                            /* Simply add op2 to the register */

                            inst_RV_TT(INS_add, reg, op2, 0, emitTypeSize(treeType));

                            rsTrackRegTrash(reg);
                            genFlagsEqualToReg(tree, reg, true);

                            goto DONE_LEA_ADD;
                        }
                        else if (op2->OperGet() == GT_CNS_INT)
                        {
                            /* Simply add op2 to the register */

                            genIncRegBy(reg, op2->gtIntCon.gtIconVal, tree, treeType);

                            goto DONE_LEA_ADD;
                        }
                    }
                }

                if  (op2->gtFlags & GTF_REG_VAL)
                {
                    reg = op2->gtRegNum;

                    if  (genRegMask(reg) & rsRegMaskFree())
                    {
                        if (op1->gtFlags & GTF_REG_VAL)
                        {
                            /* Simply add op1 to the register */

                            inst_RV_TT(INS_add, reg, op1, 0, emitTypeSize(treeType));

                            rsTrackRegTrash(reg);
                            genFlagsEqualToReg(tree, reg, true);

                            goto DONE_LEA_ADD;
                        }
                    }
                }

                /* The expression either requires scaled-index form, or op1
                   and op2's registers cant be targetted (op1/2 may be
                   enregistered variables). So use 'lea'. */

                reg = rsPickReg(needReg, bestReg);

                /* Generate "lea reg, [addr-mode]" */

                size = (treeType == TYP_BYREF) ? EA_BYREF : EA_4BYTE;

                inst_RV_AT(INS_lea, size, treeType, reg, tree);

                /* The register has been trashed now */

                rsTrackRegTrash(reg);

            DONE_LEA_ADD:

                regs |= genRegMask(reg);


                /* The following could be an 'inner' pointer!!! */

                if (treeType == TYP_BYREF)
                {
                    genUpdateLife(tree);
                    gcMarkRegSetNpt(regs);

                    gcMarkRegPtrVal(reg, TYP_BYREF);

                    /* We may have already modified the register via genIncRegBy */

                    if (op1->TypeGet() == TYP_REF ||
                        op2->TypeGet() == TYP_REF)
                    {
                        /* Generate "cmp ecx, [addr]" to trap null pointers.
                           @TODO [CONSIDER] [04/16/01] []: If we know the value 
                           will be indirected, for eg. if it is being used for a GT_COPYBLK,
                           we dont need to do this extra indirection. */
#if TGT_x86
                        genEmitter->emitIns_R_AR(INS_cmp, EA_4BYTE, SR_ECX,
                                                 (emitRegs)reg, 0);
#else
                        assert(!"No non-x86 support");
#endif
                    }
                }

                genCodeForTree_DONE(tree, reg);
                return;
            }

#endif // LEA_AVAILABLE

            assert((varTypeIsGC(treeType) == false) ||
                   (treeType == TYP_BYREF && (ins == INS_add || ins == INS_sub)));

            isArith = true;

        BIN_OPR:

            /* The following makes an assumption about gtSetEvalOrder(this) */

            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

#if TGT_x86

            /* Special case: "small_val & small_mask" */

            if  (varTypeIsSmall(op1->TypeGet()) &&
                 op2->gtOper == GT_CNS_INT && oper == GT_AND)
            {
                unsigned        and = op2->gtIntCon.gtIconVal;
                var_types       typ = op1->TypeGet();

                switch (typ)
                {
                case TYP_BOOL :     mask = 0x000000FF; break;
                case TYP_BYTE :     mask = 0x000000FF; break;
                case TYP_UBYTE :    mask = 0x000000FF; break;
                case TYP_SHORT:     mask = 0x0000FFFF; break;
                case TYP_CHAR :     mask = 0x0000FFFF; break;
                default: assert(!"unexpected type");
                }

                if  (!(and & ~mask))
                {
                    /* Make sure the operand is addressable */

                    addrReg = genMakeAddressable(op1, needReg, KEEP_REG, true);

                    /* Pick a register for the value */

                    reg   = rsPickReg(needReg, bestReg, tree->TypeGet());

                    /* Make sure the operand is still addressable */

                    addrReg = genKeepAddressable(op1, addrReg);

                    /* Does the "and" mask cover some or all the bits? */

                    if  (and != mask)
                    {
                        // @TODO [CONSIDER] [04/16/01] []: load via byte/short register

//                      if  (genRegMask(reg) & RBM_BYTE_REGS)
//                      {
//                      }
//                      else
//                      {
//                      }

                        /* Load the value and "and" it */

                        inst_RV_ST(INS_movzx, emitTypeSize(typ), reg, op1);
                        inst_RV_IV(INS_and  , reg, and);
                    }
                    else
                    {
                        /* Simply generate "movzx reg, [addr]" */

                        inst_RV_ST(INS_movzx, emitTypeSize(typ), reg, op1);
                    }

                    /* Note the new contents of the register we used */

                    rsTrackRegTrash(reg);

                    /* Free up anything that was tied up by the operand */

                    genDoneAddressable(op1, addrReg, KEEP_REG);

                    /* Update the live set of register variables */

#ifdef DEBUG
                    if (varNames) genUpdateLife(tree);
#endif

                    /* Now we can update the register pointer information */

                    gcMarkRegSetNpt(addrReg);
                    gcMarkRegPtrVal(reg, tree->TypeGet());
                    
                    genCodeForTree_DONE_LIFE(tree, reg);
                    return;
                }
            }

#endif //TGT_x86

            /* Compute a useful register mask */

            needReg = rsMustExclude(needReg, op2->gtRsvdRegs);
            needReg = rsNarrowHint (needReg, rsRegMaskFree());

            /* 8-bit operations can only be done in the byte-regs */
            if (ovfl && varTypeIsByte(treeType))
            {
                needReg &= RBM_BYTE_REGS;

                if (needReg == 0)
                    needReg = RBM_BYTE_REGS;
            }

            /* Do we have to use the special "imul" encoding which has eax
             * as the implicit operand ?
             */

            multEAX = false;

            if (oper == GT_MUL)
            {
                if (tree->gtFlags & GTF_MUL_64RSLT)
                {
                    /* Only multiplying with EAX will leave the 64-bit
                     * result in EDX:EAX */

                    multEAX = true;
                }
                else if (ovfl)
                {
                    if (tree->gtFlags & GTF_UNSIGNED)
                    {
                        /* "mul reg/mem" always has EAX as default operand */

                        multEAX = true;
                    }
                    else if (varTypeIsSmall(tree->TypeGet()))
                    {
                        /* Only the "imul with EAX" encoding has the 'w' bit
                         * to specify the size of the operands */

                        multEAX = true;
                    }
                }
            }

#if     TGT_x86

            /* Generate the first operand into some register */

            if  (multEAX)
            {
                assert(oper == GT_MUL);

                /* We'll evaluate 'op1' first */

                regMaskTP op1Mask = rsMustExclude(RBM_EAX, op2->gtRsvdRegs);

                /* Generate the op1 into regMask and hold on to it. freeOnly=true */

                genComputeReg(op1, op1Mask, ANY_REG, KEEP_REG, true);
            }
            else
            {
                genCompIntoFreeReg(op1, needReg, KEEP_REG);
            }
            assert(op1->gtFlags & GTF_REG_VAL);

            // Normally, we'd just make the second operand addressable.
            // However, if op2 is a constant and we're using the one-operand
            // form of mul, need to load the constant into a register

            if (multEAX && op2->gtOper == GT_CNS_INT)
            {
                genCodeForTree(op2, RBM_EDX);  // since EDX is going to be spilled anyway
                assert(op2->gtFlags & GTF_REG_VAL);
                rsMarkRegUsed(op2);
                addrReg = genRegMask(op2->gtRegNum);
            }
            else
            {
                /* Make the second operand addressable */

                addrReg = genMakeRvalueAddressable(op2, RBM_ALL, KEEP_REG);
            }

            /* Is op1 spilled and op2 in a register? */

            if  ((op1->gtFlags & GTF_SPILLED) &&
                 (op2->gtFlags & GTF_REG_VAL) && ins != INS_sub
                                              && !multEAX)
            {
                assert(ins == INS_add  ||
                       ins == INS_imul ||
                       ins == INS_and  ||
                       ins == INS_or   ||
                       ins == INS_xor);

                /* genMakeRvalueAddressable(GT_LCL_VAR) cant spill anything
                   as it should be a nop */
                assert(op2->gtOper != GT_LCL_VAR ||
                       varTypeIsSmall(lvaTable[op2->gtLclVar.gtLclNum].TypeGet()) ||
                       (riscCode && rsStressRegs()));

                reg = op2->gtRegNum;
                regMaskTP regMask = genRegMask(reg);

                /* Is the register holding op2 available? */

                if  (regMask & rsMaskVars)
                {
                    // @TODO [REVISIT] [04/16/01] []: Grab another register for the operation
                }
                else
                {
                    /* Get the temp we spilled into. */

                    TempDsc * temp = rsUnspillInPlace(op1, false);

                    /* For 8bit operations, we need to make sure that op2 is
                       in a byte-addressable registers */

                    if (ovfl && varTypeIsByte(treeType) &&
                        !(regMask & RBM_BYTE_REGS))
                    {
                        regNumber byteReg = rsGrabReg(RBM_BYTE_REGS);

                        inst_RV_RV(INS_mov, byteReg, reg);
                        rsTrackRegTrash(byteReg);

                        /* op2 couldn't have spilled as it was not sitting in
                           RBM_BYTE_REGS, and rsGrabReg() will only spill its args */
                        assert(op2->gtFlags & GTF_REG_VAL);

                        rsUnlockReg  (regMask);
                        rsMarkRegFree(regMask);

                        reg             = byteReg;
                        regMask         = genRegMask(reg);
                        op2->gtRegNum   = reg;
                        rsMarkRegUsed(op2);
                    }

                    inst_RV_ST(ins, reg, temp, 0, tree->TypeGet());

                    rsTrackRegTrash(reg);

                    genTmpAccessCnt++;

                    /* Free the temp */

                    tmpRlsTemp(temp);

                    /* 'add'/'sub' set all CC flags, others only ZF */

                    /* If we need to check overflow, for small types, the
                     * flags cant be used as we perform the arithmetic
                     * operation (on small registers) and then sign extend it
                     *
                     * NOTE : If we ever dont need to sign-extend the result,
                     * we can use the flags
                     */

                    if  (oper != GT_MUL && (!ovfl || treeType==TYP_INT))
                    {
                        genFlagsEqualToReg(tree, reg, isArith);
                    }

                    /* The result is where the second operand is sitting */
                    // ISSUE: Why not rsMarkRegFree(genRegMask(op2->gtRegNum)) ?

                    genRecoverReg(op2, 0, FREE_REG);

                    goto CHK_OVF;
                }
            }

#else // not TGT_x86

            if  (GenTree::OperIsCommutative(oper))
            {
                /* It might be better to start with the second operand */

                if  (op1->gtFlags & GTF_REG_VAL)
                {
                    reg = op1->gtRegNum;

                    if  (!(genRegMask(reg) & rsRegMaskFree()))
                    {
                        /* op1 is in a non-free register */

                        op1 = tree->gtOp.gtOp2;
                        op2 = tree->gtOp.gtOp1;
                    }
                }
            }

            /* Compute the first operand into a free register */

            genCompIntoFreeReg(op1, needReg, KEEP_REG);
            assert(op1->gtFlags & GTF_REG_VAL);

            /* Can we use an "add/sub immediate" instruction? */

            if  (op2->gtOper != GT_CNS_INT || (oper != GT_ADD &&
                                               oper != GT_SUB)
                                           || treeType != TYP_INT)
            {
                /* Compute the second operand into any register */

                genComputeReg(op2, needReg, ANY_REG, KEEP_REG, false);
                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);
            }

#endif//!TGT_x86

            /* Make sure the first operand is still in a register */

            genRecoverReg(op1, multEAX ? RBM_EAX : 0, KEEP_REG);
            assert(op1->gtFlags & GTF_REG_VAL);
            reg = op1->gtRegNum;

#if     TGT_x86
            // For 8 bit operations, we need to pick byte addressable registers

            if (ovfl && varTypeIsByte(treeType) &&
               !(genRegMask(reg) & RBM_BYTE_REGS))
            {
                regNumber   byteReg = rsGrabReg(RBM_BYTE_REGS);

                inst_RV_RV(INS_mov, byteReg, reg);

                rsTrackRegTrash(byteReg);
                rsMarkRegFree  (genRegMask(reg));

                reg = byteReg;
                op1->gtRegNum = reg;
                rsMarkRegUsed(op1);
            }
#endif

            /* Make sure the operand is still addressable */

            addrReg = genKeepAddressable(op2, addrReg, genRegMask(reg));

            /* Free up the operand, if it's a regvar */

            genUpdateLife(op2);

            /* The register is about to be trashed */

            rsTrackRegTrash(reg);

            op2Released = false;

            emitAttr opSize;

            // For overflow instructions, tree->gtType is the accurate type,
            // and gives us the size for the operands.

            opSize = emitTypeSize(treeType);

            /* Compute the new value */

#if CPU_HAS_FP_SUPPORT
            if  (op2->gtOper == GT_CNS_INT && isArith && !multEAX)
#else
            if  (op2->gtOper == GT_CNS_INT && isArith && !multEAX && treeType == TYP_INT)
#endif
            {
                long        ival = op2->gtIntCon.gtIconVal;

                if      (oper == GT_ADD)
                {
                    genIncRegBy(reg, ival, tree, treeType, ovfl);
                }
                else if (oper == GT_SUB)
                {
                    if (ovfl && (tree->gtFlags & GTF_UNSIGNED))
                    {
                        /* For unsigned overflow, we have to use INS_sub to set
                           the flags correctly */

                        genDecRegBy(reg, ival, tree);
                    }
                    else
                    {
                        /* Else, we simply add the negative of the value */

                        genIncRegBy(reg, -ival, tree, treeType, ovfl);
                    }
                }
#if     TGT_x86
                else
                {
                    genMulRegBy(reg, ival, op2, treeType, ovfl);
                }
#else
                op2Released = true;
#endif
            }
#if     TGT_x86
            else if (multEAX)
            {
                assert(oper == GT_MUL);
                assert(op1->gtRegNum == REG_EAX);

                // Make sure Edx is free (unless used by op2 itself)

                assert(!op2Released);

                if ((addrReg & RBM_EDX) == 0)
                {
                    // op2 does not use Edx, so make sure noone else does either
                    rsGrabReg(RBM_EDX);
                }
                else if (rsMaskMult & RBM_EDX)
                {
                    /* Edx is used by op2 and some other trees.
                       Spill the other trees besides op2.
                       @TODO [CONSIDER] [04/16/01] []: We currently do it very 
                       inefficiently by spilling all trees, and unspilling only op2. Could 
                       avoid the reload by never marking op2 as spilled */

                    rsGrabReg(RBM_EDX);
                    op2Released = true;

                    /* keepReg==FREE_REG so that the other multi-used trees
                       dont get marked as unspilled as well. */
                    rsUnspillReg(op2, RBM_EDX, FREE_REG);
                }

                if (tree->gtFlags & GTF_UNSIGNED)
                    ins = INS_mulEAX;
                else
                    ins = INS_imulEAX;

                inst_TT(ins, op2, 0, 0, opSize);

                /* Both EAX and EDX are now trashed */

                rsTrackRegTrash (REG_EAX);
                rsTrackRegTrash (REG_EDX);
            }
            else
            {
                if (ovfl && varTypeIsByte(treeType) &&
                    (op2->gtFlags & GTF_REG_VAL))
                {
                    assert(genRegMask(reg) & RBM_BYTE_REGS);

                    regNumber   op2reg      = op2->gtRegNum;
                    regMaskTP   op2regMask  = genRegMask(op2reg);

                    if (!(op2regMask & RBM_BYTE_REGS))
                    {
                        regNumber   byteReg = rsGrabReg(RBM_BYTE_REGS);

                        inst_RV_RV(INS_mov, byteReg, op2reg);
                        rsTrackRegTrash(byteReg);

                        genDoneAddressable(op2, addrReg, KEEP_REG);
                        op2Released = true;

                        op2->gtRegNum = byteReg;
                    }
                }

                inst_RV_TT(ins, reg, op2, 0, opSize);
            }
#else//!TGT_x86
            else
            {
                /* On RISC the two operands better be in registers now */

                assert(op2->gtFlags & GTF_REG_VAL);
                rg2 = op2->gtRegNum;

#if 0   // UNDONE: The following doesn't completely work; 'rg2' is marked as
        //         used here, plus we end with the result marked wrong, but
        //         this little optimization holds some promise ...

                /* Would it legal and better to compute the result into 'rg2' ? */

                if  (genRegTrashable(rg2, tree) && GenTree::OperIsCommutative(oper))
                {
                    /* Does 'rg2' look better than 'reg' for the result? */

                    if  ((genRegMask(reg) & needReg) == 0 &&
                         (genRegMask(rg2) & needReg) != 0)
                    {
#if     TGT_SH3
                        if  (oper != GT_MUL)
#endif
                        {
                            /* Switch 'reg' and 'rg2' */

                            rg2 = reg;
                            reg = op2->gtRegNum;
                        }
                    }
                }

#endif

                /* Compute the result into "reg" */

                genEmitter->emitIns_R_R(ins, EA_4BYTE, (emitRegs)reg,
                                                       (emitRegs)rg2);

#if     TGT_SH3

                /* On the SH-3 the result of a multiply is in the "MAC.lo" reg */

                if  (oper == GT_MUL)
                {
                    /* Is the target the right register? */

                    if  (needReg && !(needReg & genRegMask(reg)))
                    {
                        /* Is a better register available? */

                        if  (needReg & rsRegMaskFree())
                        {
                            reg = rsGrabReg(needReg); assert(reg != op1->gtRegNum);

                            /* Free op the old register */

                            rsMarkRegFree(genRegMask(op1->gtRegNum));

                            /* Switch 'op1' over to the new register */

                            op1->gtRegNum = reg; rsMarkRegUsed(op1);
                        }
                    }

                    genEmitter->emitIns_R(INS_stsmacl, EA_4BYTE, (emitRegs)reg);
                }
            }

#endif

#endif//TGT_x86

            /* Free up anything that was tied up by the operand */

            if (!op2Released)
                genDoneAddressable(op2, addrReg, KEEP_REG);

            /* The result will be where the first operand is sitting */

            /* We must use KEEP_REG since op1 can have a GC pointer here */
            genRecoverReg(op1, 0, KEEP_REG);

            reg = op1->gtRegNum;

#if     TGT_x86
            assert(multEAX == false || reg == REG_EAX);

            /* 'add'/'sub' set all CC flags, others only ZF+SF, mul doesnt set SF */

            if  (oper != GT_MUL)
                genFlagsEqualToReg(tree, reg, isArith);
#endif

            genReleaseReg(op1);

    CHK_OVF:

            /* Do we need an overflow check */

            if (ovfl)
                genCheckOverflow(tree, reg);

            genCodeForTree_DONE(tree, reg);
            return;

        case GT_UMOD:

            /* Is this a division by an integer constant? */

            assert(op2);
            if  (op2->gtOper == GT_CNS_INT)
            {
                unsigned ival = op2->gtIntCon.gtIconVal;

                /* Is the divisor a power of 2 ? */

                if  (ival != 0 && ival == (unsigned)genFindLowestBit(ival))
                {
                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, FREE_REG);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;

                    /* Generate the appropriate sequence */

#if TGT_x86
                    inst_RV_IV(INS_and, reg, ival - 1);
#else
                    assert(!"need non-x86 code");
#endif

                    /* The register is now trashed */

                    rsTrackRegTrash(reg);

                    genCodeForTree_DONE(tree, reg);
                    return;
                }
            }

            goto DIVIDE;

        case GT_MOD:

#if TGT_x86

            /* Is this a division by an integer constant? */

            assert(op2);
            if  (op2->gtOper == GT_CNS_INT)
            {
                long        ival = op2->gtIntCon.gtIconVal;

                /* Is the divisor a power of 2 ? */

                if  (ival > 0 && genMaxOneBit(unsigned(ival)))
                {
                    BasicBlock *    skip = genCreateTempLabel();

                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, FREE_REG);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;

                    /* Generate the appropriate sequence */

                    inst_RV_IV(INS_and, reg, (ival - 1) | 0x80000000);

                    /* The register is now trashed */

                    rsTrackRegTrash(reg);

                    /* Generate "jns skip" */

                    inst_JMP(EJ_jns, skip, false, false, true);

                    /* Generate the rest of the sequence and we're done */

                    genIncRegBy(reg, -1, NULL, TYP_INT);
                    inst_RV_IV (INS_or,  reg,  -ival);
                    genIncRegBy(reg,  1, NULL, TYP_INT);

                    /* Define the 'skip' label and we're done */

                    genDefineTempLabel(skip, true);

                    genCodeForTree_DONE(tree, reg);
                    return;
                }
            }

#endif

            goto DIVIDE;

        case GT_UDIV:

            /* Is this a division by an integer constant? */

            assert(op2);
            if  (op2->gtOper == GT_CNS_INT)
            {
                unsigned    ival = op2->gtIntCon.gtIconVal;

                /* Division by 1 must be handled elsewhere */

                assert(ival != 1);

                /* Is the divisor a power of 2 ? */

                if  (ival && genMaxOneBit(ival))
                {
                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, FREE_REG);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;

                    /* Generate "shr reg, log2(value)" */

#if TGT_x86
                    inst_RV_SH(INS_shr, reg, genLog2(ival));
#else
                    assert(!"need non-x86 code");
#endif

                    /* The register is now trashed */

                    rsTrackRegTrash(reg);

                    genCodeForTree_DONE(tree, reg);
                    return;
                }
            }

            goto DIVIDE;

        case GT_DIV:

#if TGT_x86

            /* Is this a division by an integer constant? */

            assert(op2);
            if  (op2->gtOper == GT_CNS_INT)
            {
                unsigned    ival = op2->gtIntCon.gtIconVal;

                /* Division by 1 must be handled elsewhere */

                assert(ival != 1);

                /* Is the divisor a power of 2 (excluding INT_MIN) ? */

                if  (int(ival) > 0 && genMaxOneBit(ival))
                {
#if 1
                    BasicBlock *    onNegDivisee = genCreateTempLabel();

                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, FREE_REG);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;

                    if (ival == 2)
                    {
                        /* Generate "sar reg, log2(value)" */

                        inst_RV_SH(INS_sar, reg, genLog2(ival));

                        /* Generate "jns onNegDivisee" followed by "adc reg, 0" */

                        inst_JMP  (EJ_jns, onNegDivisee, false, false, true);
                        inst_RV_IV(INS_adc, reg, 0);

                        /* Define the 'onNegDivisee' label and we're done */

                        genDefineTempLabel(onNegDivisee, true);

                        /* The register is now trashed */

                        rsTrackRegTrash(reg);

                        /* The result is the same as the operand */

                        reg  = op1->gtRegNum;
                    }
                    else
                    {
                        /* Generate the following sequence */
                        /*
                            test    reg, reg
                            jns     onNegDivisee
                            add     reg, ival-1
                        onNegDivisee:
                            sar     reg, log2(ival)
                         */

                        inst_RV_RV(INS_test, reg, reg, TYP_INT);

                        inst_JMP  (EJ_jns, onNegDivisee, false, false, true);
                        inst_RV_IV(INS_add, reg, ival-1);

                        /* Define the 'onNegDivisee' label and we're done */

                        genDefineTempLabel(onNegDivisee, true);

                        /* Generate "sar reg, log2(value)" */

                        inst_RV_SH(INS_sar, reg, genLog2(ival));

                        /* The register is now trashed */

                        rsTrackRegTrash(reg);

                        /* The result is the same as the operand */

                        reg  = op1->gtRegNum;
                    }

#else

                    /* Make sure EAX is not used */

                    rsGrabReg(RBM_EAX);

                    /* Compute the operand into EAX */

                    genComputeReg(op1, RBM_EAX, EXACT_REG, KEEP_REG);

                    /* Make sure EDX is not used */

                    rsGrabReg(RBM_EDX);

                    /*
                        Generate the following code:

                            cdq
                            and edx, <ival-1>
                            add eax, edx
                            sar eax, <log2(ival)>
                     */

                    instGen(INS_cdq);

                    if  (ival == 2)
                    {
                        inst_RV_RV(INS_sub, REG_EAX, REG_EDX, tree->TypeGet());
                    }
                    else
                    {
                        inst_RV_IV(INS_and, REG_EDX, ival-1);
                        inst_RV_RV(INS_add, REG_EAX, REG_EDX, tree->TypeGet());
                    }
                    inst_RV_SH(INS_sar, REG_EAX, genLog2(ival));

                    /* Free up the operand (i.e. EAX) */

                    genReleaseReg(op1);

                    /* Both EAX and EDX are now trashed */

                    rsTrackRegTrash (REG_EAX);
                    rsTrackRegTrash (REG_EDX);

                    /* The result is in EAX */

                    reg  = REG_EAX;
#endif

                    genCodeForTree_DONE(tree, reg);
                    return;
                }
            }

#endif

        DIVIDE: // Jump here if op2 for GT_UMOD, GT_MOD, GT_UDIV, GT_DIV
                // is not a power of 2 constant

#if TGT_x86

            /* Which operand are we supposed to evaluate first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* We'll evaluate 'op2' first */

                gotOp1   = false;
                destReg &= ~op1->gtRsvdRegs;

                /* Also if op1 is an enregistered LCL_VAR then exclude it's register as well */
                if (op1->gtOper == GT_LCL_VAR)
                {
                    unsigned varNum = op1->gtLclVar.gtLclNum;
                    assert(varNum < lvaCount);
                    LclVarDsc* varDsc = lvaTable + varNum;
                    if  (varDsc->lvRegister)
                    {
                        destReg &= ~genRegMask(varDsc->lvRegNum);
                    }
                }
            }
            else
            {
                /* We'll evaluate 'op1' first */

                gotOp1 = true;

                regMaskTP op1Mask;
                if (RBM_EAX & op2->gtRsvdRegs)
                    op1Mask = RBM_ALL & ~op2->gtRsvdRegs;
                else
                    op1Mask = RBM_EAX;  // EAX would be ideal

                /* Generate the dividend into EAX and hold on to it. freeOnly=true */

                genComputeReg(op1, op1Mask, ANY_REG, KEEP_REG, true);
            }

            /* We want to avoid using EAX or EDX for the second operand */

            destReg = rsMustExclude(destReg, RBM_EAX|RBM_EDX);

            /* Make the second operand addressable */

            /* Special case: if op2 is a local var we are done */

            if  (op2->gtOper == GT_LCL_VAR || op2->gtOper == GT_LCL_FLD)
            {
                if ((op2->gtFlags & GTF_REG_VAL) == 0)
                    addrReg = genMakeRvalueAddressable(op2, destReg, KEEP_REG);
                else
                    addrReg = 0;
            }
            else
            {
                genComputeReg(op2, destReg, ANY_REG, KEEP_REG);

                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);
            }

            /* Make sure we have the dividend in EAX */

            if  (gotOp1)
            {
                /* We've previously computed op1 into EAX */

                genRecoverReg(op1, RBM_EAX, KEEP_REG);
            }
            else
            {
                /* Compute op1 into EAX and hold on to it */

                genComputeReg(op1, RBM_EAX, EXACT_REG, KEEP_REG, true);
            }

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_EAX);

            /* We can now safely (we think) grab EDX */

            rsGrabReg(RBM_EDX);
            rsLockReg(RBM_EDX);

            /* Convert the integer in EAX into a un/signed long in EDX:EAX */

            if (oper == GT_UMOD || oper == GT_UDIV)
                inst_RV_RV(INS_xor, REG_EDX, REG_EDX);
            else
                instGen(INS_cdq);

            /* Make sure the divisor is still addressable */

            addrReg = genKeepAddressable(op2, addrReg, RBM_EAX);

            /* Perform the division */

            if (oper == GT_UMOD || oper == GT_UDIV)
                inst_TT(INS_div,  op2);
            else
                inst_TT(INS_idiv, op2);

            /* Free up anything tied up by the divisor's address */

            genDoneAddressable(op2, addrReg, KEEP_REG);

            /* Unlock and free EDX */

            rsUnlockReg(RBM_EDX);

            /* Free up op1 (which is in EAX) as well */

            genReleaseReg(op1);

            /* Both EAX and EDX are now trashed */

            rsTrackRegTrash (REG_EAX);
            rsTrackRegTrash (REG_EDX);

            /* Figure out which register the result is in */

            reg = (oper == GT_DIV || oper == GT_UDIV)   ? REG_EAX
                                                        : REG_EDX;

            /* Don't forget to mark the first operand as using EAX and EDX */

            op1->gtRegNum    = reg;

            genCodeForTree_DONE(tree, reg);
            return;
            
#elif   TGT_SH3
            assert(!"div/mod should have been morphed into a helper call");
#else
#error  Unexpected target
#endif

#if     TGT_x86

        case GT_LSH: ins = INS_shl; goto SHIFT;
        case GT_RSH: ins = INS_sar; goto SHIFT;
        case GT_RSZ: ins = INS_shr; goto SHIFT;

        SHIFT:

            /* Is the shift count constant? */

            assert(op2);
            if  (op2->gtOper == GT_CNS_INT)
            {
                // UNDONE: Check to see if we could generate a LEA instead!

                assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

                /* Compute the left operand into any free register */

                genCompIntoFreeReg(op1, needReg, KEEP_REG);
                assert(op1->gtFlags & GTF_REG_VAL);

                reg   = op1->gtRegNum;

                /* Are we shifting left by 1 bit? */

                if  (op2->gtIntCon.gtIconVal == 1 && oper == GT_LSH)
                {
                    /* "add reg, reg" is cheaper than "shl reg, 1" */

                    inst_RV_RV(INS_add, reg, reg, tree->TypeGet());
                }
                else
                {
                    /* Generate the appropriate shift instruction */

                    inst_RV_SH(ins, reg, op2->gtIntCon.gtIconVal);
                }

                /* The register is now trashed */

                genReleaseReg(op1);
                rsTrackRegTrash (reg);
            }
            else
            {
                /* Calculate a usefull register mask for computing op1 */
                /* We must not target ECX for op1 */

                regMaskTP needRegOrig = needReg;
                needReg = rsMustExclude(needReg, RBM_ECX);
                needReg = rsNarrowHint(rsRegMaskFree(), needReg);
                needReg = rsMustExclude(needReg, RBM_ECX);
                
                /* Which operand are we supposed to evaluate first? */

                if (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    /* Load the shift count, hopefully into ECX */

                    genComputeReg(op2, RBM_ECX, ANY_REG, KEEP_REG);

                    /* Now evaluate 'op1' into a free register besides ECX */

                    genComputeReg(op1, needReg, ANY_REG, KEEP_REG, true);

                    /* It is possible that op1 is not in needReg, or that needReg
                       is no longer valid (because some variable was born into it
                       during one of the genComputeReg above).  This case is handled
                       by the genRecoverReg below which makes sure op1 is in a valid
                       register. */
                    
                    needReg = rsMustExclude(needRegOrig, RBM_ECX);
                    needReg = rsNarrowHint(rsRegMaskFree(), needReg);
                    needReg = rsMustExclude(needReg, RBM_ECX);
                    genRecoverReg(op1, needReg, FREE_REG);

                    /* Make sure that op2 wasn't displaced */

                    rsLockReg(genRegMask(op1->gtRegNum));
                    genRecoverReg(op2, RBM_ECX, FREE_REG);
                    rsUnlockReg(genRegMask(op1->gtRegNum));
                }
                else
                {
                    /* Compute op1 into a register, trying to avoid op2->rsvdRegs */

                    needReg = rsNarrowHint (needReg, ~op2->gtRsvdRegs);

                    genComputeReg(op1, needReg, ANY_REG, KEEP_REG);

                    /* Load the shift count into ECX and lock it */

                    genComputeReg(op2, RBM_ECX, EXACT_REG, FREE_REG, true);

                    /* Make sure that op1 wasn't displaced.  Recompute needReg in case
                       it uses a register that is no longer available (some variable
                       could have been born into it during the computation of op1 or op2 */

                    needReg = rsMustExclude(needRegOrig, RBM_ECX);
                    needReg = rsNarrowHint(rsRegMaskFree(), needReg);
                    needReg = rsMustExclude(needReg, RBM_ECX);

                    rsLockReg(RBM_ECX);
                    genRecoverReg(op1, needReg, FREE_REG);
                    rsUnlockReg(RBM_ECX);
                }

                reg = op1->gtRegNum;
                assert((op2->gtFlags & GTF_REG_VAL) && (op2->gtRegNum == REG_ECX));

                /* Perform the shift */
                inst_RV_CL(ins, reg);

                /* The register is now trashed */
                rsTrackRegTrash(reg);
            }

            assert(op1->gtFlags & GTF_REG_VAL);
            reg = op1->gtRegNum;
            
            genCodeForTree_DONE(tree, reg);
            return;

#elif   TGT_SH3

        case GT_LSH:
        case GT_RSH:
        case GT_RSZ:

            /* Compute the first operand into any free register */

            genCompIntoFreeReg(op1, needReg, KEEP_REG);
            assert(op1->gtFlags & GTF_REG_VAL);

            reg   = op1->gtRegNum;

            /* Is the shift count constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                instruction ins01;
                instruction ins02;
                instruction ins08;
                instruction ins16;

                unsigned    scnt = op2->gtIntCon.gtIconVal;

                /* Arithmetic right shifts only work by one bit */

                if  (oper == GT_RSH)
                {
                    if  (scnt > 2)
                        goto SHF_VAR;
                }
                else
                {
                    /* If '4' is present, it must be alone */

                    if  ((scnt & 4) && scnt != 4)
                        goto SHF_VAR;

                    /* Make sure no more than 2 bits are set */

                    if  (scnt)
                    {
                        if  (!genMaxOneBit(scnt - genFindLowestBit(scnt)))
                            goto SHF_VAR;
                    }

                    /* Figure out the instructions we'll need */

                    if  (oper == GT_LSH)
                    {
                        ins01 = INS_shll;
                        ins02 = INS_shll2;
                        ins08 = INS_shll8;
                        ins16 = INS_shll16;
                    }
                    else
                    {
                        ins01 = INS_shlr;
                        ins02 = INS_shlr2;
                        ins08 = INS_shlr8;
                        ins16 = INS_shlr16;
                    }
                }

                /* Is this an arithmetic shift right? */

                if  (oper == GT_RSH)
                {
                    while (scnt)
                    {
                        /* Generate "shar reg" for each shift */

                        genEmitter->emitIns_R(INS_shar,
                                               EA_4BYTE,
                                               (emitRegs)reg);

                        scnt--;
                    }
                }
                else
                {
                    /* Generate the appropriate shift instruction(s) */

                    if  (scnt & 4)
                    {
                        assert(scnt == 4);

                        genEmitter->emitIns_R(ins02,
                                               EA_4BYTE,
                                               (emitRegs)reg);

                        /* Get another shift by 2 below */

                        scnt = 2;
                    }

                    if  (scnt & 16)
                        genEmitter->emitIns_R(ins16,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                    if  (scnt &  8)
                        genEmitter->emitIns_R(ins08,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                    if  (scnt &  2)
                        genEmitter->emitIns_R(ins02,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                    if  (scnt &  1)
                        genEmitter->emitIns_R(ins01,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                }
            }
            else
            {
                /* We don't have a constant and convenient shift count */

            SHF_VAR:

                /* Compute the second operand into any register */

                genComputeReg(op2, needReg, ANY_REG, KEEP_REG, false);
                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);

                /* Make sure the first operand is still in a register */

                genRecoverReg(op1, 0, KEEP_REG);
                assert(op1->gtFlags & GTF_REG_VAL);
                reg = op1->gtRegNum;

                /* Make sure the second operand is still addressable */

                addrReg = genKeepAddressable(op2, addrReg, genRegMask(reg));

                /* Free up the second operand */

                genUpdateLife(op2);
                genReleaseReg(op2);

                /* Now do the shifting */

                switch (oper)
                {
                case GT_LSH: ins = INS_shad; break;
                case GT_RSH: ins = INS_shad; break;
                case GT_RSZ: ins = INS_shld; break;
                }

                genEmitter->emitIns_R_R(ins, EA_4BYTE, (emitRegs)reg,
                                                           (emitRegs)op2->gtRegNum);
            }

            /* The result register is now trashed */

            genReleaseReg(op1);
            rsTrackRegTrash(reg);

            genCodeForTree_DONE(tree, reg);
            return;

#else
#error  Unexpected target
#endif

        case GT_NEG:
        case GT_NOT:

#if TGT_x86

            /* Generate the operand into some register */

            genCompIntoFreeReg(op1, needReg, FREE_REG);
            assert(op1->gtFlags & GTF_REG_VAL);

            reg   = op1->gtRegNum;

            /* Negate/reverse the value in the register */

            inst_RV((oper == GT_NEG) ? INS_neg
                                     : INS_not, reg, tree->TypeGet());

#elif   TGT_SH3

            /* Compute the operand into any register */

            genComputeReg(op1, needReg, ANY_REG, FREE_REG);
            assert(op1->gtFlags & GTF_REG_VAL);
            rg2  = op1->gtRegNum;

            /* Get hold of a free register for the result */

            reg  = rsGrabReg(needReg);

            /* Compute the result into the register */

            genEmitter->emitIns_R_R((oper == GT_NEG) ? INS_neg
                                                     : INS_not,
                                      EA_4BYTE,
                                      (emitRegs)reg,
                                      (emitRegs)rg2);

#else
#error  Unexpected target
#endif

            /* The register is now trashed */

            rsTrackRegTrash(reg);

            genCodeForTree_DONE(tree, reg);
            return;

        case GT_IND:

            /* Make sure the operand is addressable */

            addrReg = genMakeAddressable(tree, RBM_ALL, KEEP_REG, true);
            /* Fix for RAID bug #12002 */
            genDoneAddressable(tree, addrReg, KEEP_REG);

            /* Figure out the size of the value being loaded */

            size = EA_ATTR(genTypeSize(tree->gtType));

            /* Pick a register for the value */

#if     TGT_SH3
            if  (size < EA_4BYTE && genAddressMode == AM_IND_REG1_DISP)
            {
                /* Small loads with a displacement have to go via R0 */

                reg = REG_r00; rsPickReg(reg);
            }
            else
#endif
            {

                if  (needReg == RBM_ALL && bestReg == 0)
                {
                    /* Absent a better suggestion, pick a useless register */

                    bestReg = rsExcludeHint(rsRegMaskFree(), ~rsUselessRegs());
                }

                reg = rsPickReg(needReg, bestReg, tree->TypeGet());
            }

#if     TGT_x86

            if ( (op1->gtOper                       == GT_CNS_INT)       &&
                ((op1->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_TLS_HDL))
            {
                assert(size == EA_4BYTE);
                genEmitter->emitIns_R_C (INS_mov,
                                         EA_4BYTE,
                                         (emitRegs)reg,
                                         FLD_GLOBAL_FS,
                                         op1->gtIntCon.gtIconVal);
            }
            else
            {
                /* Generate "mov reg, [addr]" or "movsx/movzx reg, [addr]" */

                inst_mov_RV_ST(reg, tree);
            }

#elif   TGT_SH3

            /* Load the value into the chosen register */

            inst_RV_TT(INS_mov, reg, tree, 0, size);

            /* Do we need to zero-extend the value? */

            if  (size < EA_4BYTE && varTypeIsUnsigned(tree->TypeGet()))
            {
                assert(size == EA_1BYTE || size == EA_2BYTE);

                /* ISSUE: The following isn't the smartest thing */

                genEmitter->emitIns_R_R((size == EA_1BYTE) ? INS_extub : INS_extuw,
                                         EA_4BYTE,
                                         (emitRegs)reg,
                                         (emitRegs)reg);
            }

#else
#error  Unexpected target
#endif

            /* Note the new contents of the register we used */

            rsTrackRegTrash(reg);

            /* Update the live set of register variables */

#ifdef DEBUG
            if (varNames) genUpdateLife(tree);
#endif

            /* Now we can update the register pointer information */

//          genDoneAddressable(tree, addrReg, KEEP_REG);
            gcMarkRegPtrVal(reg, tree->TypeGet());
         
            genCodeForTree_DONE_LIFE(tree, reg);
            return;

        case GT_CAST:

            /* Constant casts should have been folded earlier */

            assert(op1->gtOper != GT_CNS_INT &&
                   op1->gtOper != GT_CNS_LNG &&
                   op1->gtOper != GT_CNS_DBL || tree->gtOverflow());

            var_types   dstType; dstType = tree->gtCast.gtCastType;

            assert(dstType != TYP_VOID);

#if TGT_x86

            /* What type are we casting from? */

            switch (op1->TypeGet())
            {
            case TYP_LONG:

                /* Special case: the long is generated via the mod of long
                   with an int.  This is really an int and need not be
                   converted to a reg pair. */

                if (((op1->gtOper == GT_MOD) || (op1->gtOper == GT_UMOD)) &&
                    (op1->gtFlags & GTF_MOD_INT_RESULT))
                {
#ifdef DEBUG
                    /* Verify that the op2 of the mod node is
                       1) An integer tree, or
                       2) A long constant that is small enough to fit in an integer
                    */

                    GenTreePtr modop2 = op1->gtOp.gtOp2;
                    assert(((modop2->gtOper == GT_CNS_LNG) && 
                            (modop2->gtLngCon.gtLconVal == int(modop2->gtLngCon.gtLconVal))));
#endif
                    
                    genCodeForTree(op1, destReg, bestReg);

                    reg = genRegPairLo(op1->gtRegPair);

                    genCodeForTree_DONE(tree, reg);
                    return;
                }

                /* Make the operand addressable. gtOverflow(), hold on to
                   addrReg as we will need to access the higher dword */

                addrReg = genMakeAddressable(op1, 0, tree->gtOverflow() ? KEEP_REG
                                                                        : FREE_REG);

                /* Load the lower half of the value into some register */

                if  (op1->gtFlags & GTF_REG_VAL)
                {
                    /* Can we simply use the low part of the value? */
                    reg = genRegPairLo(op1->gtRegPair);

                    if (tree->gtOverflow())
                        goto REG_OK;

                    regMaskTP loMask;
                    loMask = genRegMask(reg);
                    if  (loMask & rsRegMaskFree())
                        bestReg = loMask;
                }

                // for cast overflow we need to preserve addrReg for testing the hiDword
                // so we lock it to prevent rsPickReg from picking it.
                if (tree->gtOverflow())
                    rsLockUsedReg(addrReg);

                reg   = rsPickReg(needReg, bestReg);

                if (tree->gtOverflow())
                    rsUnlockUsedReg(addrReg);

                assert(genStillAddressable(op1));
REG_OK:
                /* Generate "mov reg, [addr-mode]" */

                if  (!(op1->gtFlags & GTF_REG_VAL) || reg != genRegPairLo(op1->gtRegPair))
                    inst_RV_TT(INS_mov, reg, op1);

                /* conv.ovf.i8i4, or conv.ovf.u8u4 */

                if (tree->gtOverflow())
                {
                    regNumber hiReg = (op1->gtFlags & GTF_REG_VAL) ? genRegPairHi(op1->gtRegPair)
                                                                   : REG_NA;

                    switch(dstType)
                    {
                    case TYP_INT:   // conv.ovf.i8.i4
                        /*  Generate the following sequence

                                test loDWord, loDWord   // set flags
                                jl neg
                           pos: test hiDWord, hiDWord   // set flags
                                jne ovf
                                jmp done
                           neg: cmp hiDWord, 0xFFFFFFFF
                                jne ovf
                          done:

                        */

                        inst_RV_RV(INS_test, reg, reg);
                        if (tree->gtFlags & GTF_UNSIGNED)       // conv.ovf.u8.i4       (i4 > 0 and upper bits 0)
                        {
                            genJumpToThrowHlpBlk(EJ_jl, ACK_OVERFLOW);
                            goto UPPER_BITS_ZERO;
                        }

                        BasicBlock * neg;
                        BasicBlock * done;

                        neg  = genCreateTempLabel();
                        done = genCreateTempLabel();

                        // Is the loDWord positive or negative

                        inst_JMP(EJ_jl, neg, true, genCanSchedJMP2THROW(), true);

                        // If loDWord is positive, hiDWord should be 0 (sign extended loDWord)

                        if (hiReg < REG_STK)
                        {
                            inst_RV_RV(INS_test, hiReg, hiReg);
                        }
                        else
                        {
                            inst_TT_IV(INS_cmp, op1, 0x00000000, EA_4BYTE);
                        }

                        genJumpToThrowHlpBlk(EJ_jne, ACK_OVERFLOW);
                        inst_JMP(EJ_jmp, done, false, false, true);

                        // If loDWord is negative, hiDWord should be -1 (sign extended loDWord)

                        genDefineTempLabel(neg, true);

                        if (hiReg < REG_STK)
                        {
                            inst_RV_IV(INS_cmp, hiReg, 0xFFFFFFFFL);
                        }
                        else
                        {
                            inst_TT_IV(INS_cmp, op1, 0xFFFFFFFFL, EA_4BYTE);
                        }
                        genJumpToThrowHlpBlk(EJ_jne, ACK_OVERFLOW);

                        // Done

                        genDefineTempLabel(done, true);

                        break;

                    case TYP_UINT:  // conv.ovf.u8u4
UPPER_BITS_ZERO:
                        // Just check that the upper DWord is 0

                        if (hiReg < REG_STK)
                        {
                            inst_RV_RV(INS_test, hiReg, hiReg);
                        }
                        else
                        {
                            inst_TT_IV(INS_cmp, op1, 0, EA_4BYTE);
                        }

                        genJumpToThrowHlpBlk(EJ_jne, ACK_OVERFLOW);
                        break;

                    default:
                        assert(!"Unexpected dstType");
                        break;
                    }

                    genDoneAddressable(op1, addrReg, KEEP_REG);
                }

                rsTrackRegTrash(reg);
                genDoneAddressable(op1, addrReg, FREE_REG);
                
                genCodeForTree_DONE(tree, reg);
                return;

            case TYP_BOOL:
            case TYP_BYTE:
            case TYP_SHORT:
            case TYP_CHAR:
            case TYP_UBYTE:
                break;

            case TYP_UINT:
            case TYP_INT:
                break;

            case TYP_FLOAT:
                assert(!"This should have been converted into a helper call");
            case TYP_DOUBLE:

                /* Using a call (to a helper-function) for this cast will cause
                   all FP variable which are live across the call to not be
                   enregistered. Since we know that gtDblWasInt() varaiables
                   will not overflow when cast to TYP_INT, we just use a
                   memory spill and load to do the cast and avoid the call */

                assert(gtDblWasInt(op1));

                /* Load the FP value onto the coprocessor stack */

                genCodeForTreeFlt(op1, false);

                /* Allocate a temp for the result */

                TempDsc * temp;
                temp = tmpGetTemp(TYP_INT);

                /* Store the FP value into the temp */

                inst_FS_ST(INS_fistp, EA_4BYTE, temp, 0);
                genTmpAccessCnt++;
                genFPstkLevel--;

                /* Pick a register for the value */

                reg = rsPickReg(needReg);

                /* Load the converted value into the registers */

                inst_RV_ST(INS_mov, reg, temp, 0, TYP_INT, EA_4BYTE);
                genTmpAccessCnt += 1;

                /* The value in the register is now trashed */

                rsTrackRegTrash(reg);

                /* We no longer need the temp */

                tmpRlsTemp(temp);
                
                genCodeForTree_DONE(tree, reg);
                return;

            default:
                assert(!"unexpected cast type");
            }

            if (tree->gtOverflow())
            {
                /* Compute op1 into a register, and free the register */

                genComputeReg(op1, destReg, ANY_REG, FREE_REG);
                reg = op1->gtRegNum;

                /* Do we need to compare the value, or just check masks */

                int typeMin, typeMax, mask;

                switch(dstType)
                {
                case TYP_BYTE:
                    mask = 0xFFFFFF80;
                    typeMin = SCHAR_MIN; typeMax = SCHAR_MAX;
                    unsv = (tree->gtFlags & GTF_UNSIGNED);
                    break;
                case TYP_SHORT:
                    mask = 0xFFFF8000;
                    typeMin = SHRT_MIN;  typeMax = SHRT_MAX;
                    unsv = (tree->gtFlags & GTF_UNSIGNED);
                    break;
                case TYP_INT:   unsv = true;    mask = 0x80000000L; assert((tree->gtFlags & GTF_UNSIGNED) != 0); break;
                case TYP_UBYTE: unsv = true;    mask = 0xFFFFFF00L; break;
                case TYP_CHAR:  unsv = true;    mask = 0xFFFF0000L; break;
                case TYP_UINT:  unsv = true;    mask = 0x80000000L; assert((tree->gtFlags & GTF_UNSIGNED) == 0); break;
                default:        
                    NO_WAY("Unknown type");
                }

                // If we just have to check a mask.
                // This must be conv.ovf.u4u1, conv.ovf.u4u2, conv.ovf.u4i4,
                // or conv.i4u4

                if (unsv)
                {
                    inst_RV_IV(INS_test, reg, mask);
                    genJumpToThrowHlpBlk(EJ_jne, ACK_OVERFLOW);
                }

                // Check the value is in range.
                // This must be conv.ovf.i4i1, etc.

                else
                {
                    // Compare with the MAX

                    inst_RV_IV(INS_cmp, reg, typeMax);
                    genJumpToThrowHlpBlk(EJ_jg, ACK_OVERFLOW);

                    // Compare with the MIN

                    inst_RV_IV(INS_cmp, reg, typeMin);
                    genJumpToThrowHlpBlk(EJ_jl, ACK_OVERFLOW);
                }

                genCodeForTree_DONE(tree, reg);
                return;

            }

            /* Make the operand addressable */

            addrReg = genMakeAddressable(op1, needReg, FREE_REG, true);

            andv = false;

            if  (genTypeSize(op1->gtType) < genTypeSize(dstType))
            {
                // Widening cast

                /* we need the source size */

                size = EA_ATTR(genTypeSize(op1->gtType));

                assert(size == EA_1BYTE || size == EA_2BYTE);

                unsv = varTypeIsUnsigned(op1->TypeGet());

                /*
                    Special case: for a cast of byte to char we first
                    have to expand the byte (w/ sign extension), then
                    mask off the high bits.
                    Use 'movsx' followed by 'and'
                */
                if (!unsv && varTypeIsUnsigned(dstType) && genTypeSize(dstType) != EA_4BYTE)
                {
                    assert(genTypeSize(dstType) == EA_2BYTE && size == EA_1BYTE);
                    andv = true;
                }
            }
            else
            {
                // Narrowing cast, or sign-changing cast

                assert(genTypeSize(op1->gtType) >= genTypeSize(dstType));

                size = EA_ATTR(genTypeSize(dstType));

                unsv = varTypeIsUnsigned(dstType);
            }

            assert(size == EA_1BYTE || size == EA_2BYTE);

            if (unsv)
                ins = INS_movzx;
            else
                ins = INS_movsx;

            /* Is the value sitting in a non-byte-addressable register? */

            if  (op1->gtFlags & GTF_REG_VAL &&
                (size == EA_1BYTE) &&
                !isByteReg(op1->gtRegNum))
            {
                if (unsv)
                {
                    // for unsigned values we can AND, so it needs not be a byte register

                    reg = rsPickReg(needReg, bestReg);

                    ins = INS_and;
                }
                else
                {
                    /* Move the value into a byte register */

                    reg   = rsGrabReg(RBM_BYTE_REGS);
                }

                if (reg != op1->gtRegNum)
                {
                    /* Move the value into that register */

                    rsTrackRegCopy(reg, op1->gtRegNum);
                    inst_RV_RV(INS_mov, reg, op1->gtRegNum, op1->TypeGet());

                    /* The value has a new home now */

                    op1->gtRegNum = reg;
                }
            }
            else
            {
                /* Pick a register for the value (general case) */

                reg   = rsPickReg(needReg, bestReg);

                // if the value is already in the same register, use AND instead of MOVZX
                if  ((op1->gtFlags & GTF_REG_VAL) && 
                     op1->gtRegNum == reg &&
                     unsv)
                {
                    assert(ins == INS_movzx);
                    ins = INS_and;
                }

            }

            if (ins == INS_and)
            {
                assert(andv == false && unsv);

                /* Generate "and reg, xxxx" */

                inst_RV_IV(INS_and, reg, (size == EA_1BYTE) ? 0xFF : 0xFFFF);

                genFlagsEqualToReg(tree, reg, false);
            }
            else
            {
                assert(ins == INS_movsx || ins == INS_movzx);

                /* Generate "movsx/movzx reg, [addr]" */

                inst_RV_ST(ins, size, reg, op1);

                /* Mask off high bits for cast from byte to char */

                if  (andv)
                {
                    assert(genTypeSize(dstType) == 2 && ins == INS_movsx);

                    inst_RV_IV(INS_and, reg, 0xFFFF);

                    genFlagsEqualToReg(tree, reg, false);
                }
            }

            rsTrackRegTrash(reg);
            genDoneAddressable(op1, addrReg, FREE_REG);
            
            genCodeForTree_DONE(tree, reg);
            return;
            

#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

        case GT_JTRUE:

            /* Is this a test of a relational operator? */

            if  (op1->OperIsCompare())
            {
                /* Generate the conditional jump */

                genCondJump(op1);

                genUpdateLife(tree);
                return;
            }

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"ISSUE: can we ever have a jumpCC without a compare node?");

        case GT_SWITCH:
            genCodeForSwitch(tree);
            return;

        case GT_RETFILT:
            assert(tree->gtType == TYP_VOID || op1 != 0);
            if (op1 == 0)   // endfinally
            {
                reg  = REG_NA;

                /* Return using a pop-jmp sequence. As the "try" block calls
                   the finally with a jmp, this leaves the x86 call-ret stack
                   balanced in the normal flow of path. */


                assert(genFPreqd);
                inst_RV(INS_pop_hide, REG_EAX, TYP_I_IMPL);
                inst_RV(INS_i_jmp, REG_EAX, TYP_I_IMPL);
            }
            else            // endfilter
            {
                genComputeReg(op1, RBM_INTRET, EXACT_REG, FREE_REG);
                assert(op1->gtFlags & GTF_REG_VAL);
                assert(op1->gtRegNum == REG_INTRET);
                /* The return value has now been computed */
                reg   = op1->gtRegNum;

                /* Return */
                instGen(INS_ret);
            }

            genCodeForTree_DONE(tree, reg);
            return;
            

        case GT_RETURN:

#if INLINE_NDIRECT

            // UNDONE: this should be done AFTER we called exit mon so that
            //         we are sure that we don't have to keep 'this' alive

            if (info.compCallUnmanaged && (compCurBB == genReturnBB))
            {
                /* either it's an "empty" statement or the return statement
                   of a synchronized method
                 */

                assert(!op1 || op1->gtType == TYP_VOID);

                genPInvokeMethodEpilog();
            }

#endif

#ifdef PROFILER_SUPPORT
            if (opts.compEnterLeaveEventCB && (compCurBB == genReturnBB))
            {
#if     TGT_x86
                BOOL                      bHookFunction = TRUE;
                CORINFO_PROFILING_HANDLE  profHandle;
                CORINFO_PROFILING_HANDLE *pProfHandle;

                // This will query the profiler as to whether or not to hook this function, and will
                // also get the method desc handle (or a pointer to it in the prejit case).
                profHandle = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pProfHandle);
                assert((!profHandle) != (!pProfHandle));

                // Only hook if profiler says it's okay.
                if (bHookFunction)
                {
                    TempDsc *    temp;

                    // If there is an OBJECTREF or FP return type, then it must
                    // be preserved if in-process debugging is enabled
                    if (opts.compInprocDebuggerActiveCB)
                    {
                        switch (genActualType(info.compRetType))
                        {
                        case TYP_REF:
                        case TYP_BYREF:
                            assert(genTypeStSz(TYP_REF)   == genTypeStSz(TYP_INT));
                            assert(genTypeStSz(TYP_BYREF) == genTypeStSz(TYP_INT));
                            inst_RV(INS_push, REG_INTRET, info.compRetType);

                            genSinglePush(true);
                            gcMarkRegSetNpt(RBM_INTRET);
                            break;

                        case TYP_FLOAT:
                        case TYP_DOUBLE:
                            assert(genFPstkLevel == 0); genFPstkLevel++;
                            temp = genSpillFPtos(info.compRetType);
                            break;

                        default:
                            break;
                        }
                    }

                    // Need to save on to the stack level, since the callee will pop the argument
                    unsigned        saveStackLvl2 = genStackLevel;
                    
                    // Can we directly use the profilingHandle?
                    if (profHandle)
                        inst_IV(INS_push, (long)profHandle);
                    else
                        genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                                 SR_NA, SR_NA, (int)pProfHandle);

                    genSinglePush(false);

                    genEmitHelperCall(CORINFO_HELP_PROF_FCN_LEAVE,
                                      sizeof(int),      // argSize
                                      0);               // retSize

                    /* Restore the stack level */

                    genStackLevel = saveStackLvl2;
                    genOnStackLevelChanged();

                    // If there is an OBJECTREF or FP return type, then it must
                    // be preserved if in-process debugging is enabled
                    if (opts.compInprocDebuggerActiveCB)
                    {
                        switch (genActualType(info.compRetType))
                        {
                        case TYP_REF:
                        case TYP_BYREF:
                            assert(genTypeStSz(TYP_REF)   == genTypeStSz(TYP_INT));
                            assert(genTypeStSz(TYP_BYREF) == genTypeStSz(TYP_INT));
                            inst_RV(INS_pop, REG_INTRET, info.compRetType);
    
                            genStackLevel -= sizeof(void *);
                            genOnStackLevelChanged();
                            gcMarkRegPtrVal(REG_INTRET, info.compRetType);
                            break;
    
                        case TYP_FLOAT:
                        case TYP_DOUBLE:
                            genReloadFPtos(temp, INS_fld);
                            assert(genFPstkLevel == 0);
                            break;
    
                        default:
                            break;
                        }
                    }
                }

#else
                assert(!"profiler support not implemented for non x86");
#endif
            }
#endif
            /* Is there a return value and/or an exit statement? */

            if  (op1)
            {
                /* Is there really a non-void return value? */

#if     TGT_x86
                if  (op1->gtType == TYP_VOID)
                {
                    TempDsc *    temp;

                    /* This must be a synchronized method */

                    assert(info.compFlags & CORINFO_FLG_SYNCH);

                    /* Save the return value of the method, if any */

                    switch (genActualType(info.compRetType))
                    {
                    case TYP_VOID:
                        break;

                    case TYP_REF:
                    case TYP_BYREF:
                        assert(genTypeStSz(TYP_REF)   == genTypeStSz(TYP_INT));
                        assert(genTypeStSz(TYP_BYREF) == genTypeStSz(TYP_INT));
                        inst_RV(INS_push, REG_INTRET, info.compRetType);

                        genSinglePush(true);
                        gcMarkRegSetNpt(RBM_INTRET);
                        break;

                    case TYP_INT:
                    case TYP_LONG:

                        inst_RV(INS_push, REG_INTRET, TYP_INT);
                        genSinglePush(false);

                        if (info.compRetType == TYP_LONG)
                        {
                            inst_RV(INS_push, REG_EDX, TYP_INT);
                            genSinglePush(false);
                        }
                        break;

                    case TYP_FLOAT:
                    case TYP_DOUBLE:
                        assert(genFPstkLevel == 0); genFPstkLevel++;
                        temp = genSpillFPtos(info.compRetType);
                        break;

                    case TYP_STRUCT:

                        // Don't need to do anything for TYP_STRUCT, because the return
                        // value is on the stack (not in eax).

                        break;


                    default:
                        assert(!"unexpected return type");
                    }

                    /* Generate the 'exitCrit' call */

                    genCodeForTree(op1, 0);

                    /* Restore the return value of the method, if any */

                    switch (genActualType(info.compRetType))
                    {
                    case TYP_VOID:
                        break;

                    case TYP_REF:
                    case TYP_BYREF:
                        assert(genTypeStSz(TYP_REF)   == genTypeStSz(TYP_INT));
                        assert(genTypeStSz(TYP_BYREF) == genTypeStSz(TYP_INT));
                        inst_RV(INS_pop, REG_INTRET, info.compRetType);

                        genStackLevel -= sizeof(void *);
                        genOnStackLevelChanged();
                        gcMarkRegPtrVal(REG_INTRET, info.compRetType);
                        break;

                    case TYP_LONG:
                        inst_RV(INS_pop, REG_EDX, TYP_INT);
                        genSinglePop();
                        gcMarkRegSetNpt(RBM_EDX);

                        /* fall through */

                    case TYP_INT:
                        inst_RV(INS_pop, REG_INTRET, TYP_INT);
                        genStackLevel -= sizeof(void*);
                        genOnStackLevelChanged();
                        gcMarkRegSetNpt(RBM_INTRET);
                        break;

                    case TYP_FLOAT:
                    case TYP_DOUBLE:
                        genReloadFPtos(temp, INS_fld);
                        assert(genFPstkLevel == 0);
                        break;

                    case TYP_STRUCT:

                        // Don't need to do anything for TYP_STRUCT, because the return
                        // value is on the stack (not in eax).

                        break;
                    
                    default:
                        assert(!"unexpected return type");
                    }
                }
                else

#endif // TGT_x86

                {
                    assert(op1->gtType != TYP_VOID);

                    /* Generate the return value into the return register */

                    genComputeReg(op1, RBM_INTRET, EXACT_REG, FREE_REG);

                    /* The result must now be in the return register */

                    assert(op1->gtFlags & GTF_REG_VAL);
                    assert(op1->gtRegNum == REG_INTRET);
                }

#ifdef DEBUG
                if (opts.compGcChecks && op1->gtType == TYP_REF) 
                {
                    inst_RV_RV(INS_mov, REG_ECX, REG_EAX, TYP_REF);
                    genEmitHelperCall(CORINFO_HELP_CHECK_OBJ, 0, 0);
                }

#endif
                /* The return value has now been computed */

                reg   = op1->gtRegNum;

                genCodeForTree_DONE(tree, reg);

            }
#ifdef DEBUG
            if (opts.compStackCheckOnRet) 
            {
                assert(lvaReturnEspCheck != 0xCCCCCCCC && lvaTable[lvaReturnEspCheck].lvVolatile && lvaTable[lvaReturnEspCheck].lvOnFrame);
                genEmitter->emitIns_S_R(INS_cmp, EA_4BYTE, SR_ESP, lvaReturnEspCheck, 0);
                
                BasicBlock  *   esp_check = genCreateTempLabel();
                inst_JMP(genJumpKindForOper(GT_EQ, true), esp_check);
                genEmitter->emitIns(INS_int3);
                genDefineTempLabel(esp_check, true);
            }
#endif
            return;

        case GT_COMMA:

            if (tree->gtFlags & GTF_REVERSE_OPS)
            {
                if  (tree->gtType == TYP_VOID)
                {
                    genEvalSideEffects(op2);
                    genUpdateLife (op2);
                    genEvalSideEffects(op1);
                    genUpdateLife(tree);
                    return;
                    
                }

                // Generate op2
                genCodeForTree(op2, needReg);
                genUpdateLife(op2);

                assert(op2->gtFlags & GTF_REG_VAL);

                rsMarkRegUsed(op2);

                // Do side effects of op1
                genEvalSideEffects(op1);

                // Recover op2 if spilled
                genRecoverReg(op2, RBM_NONE, KEEP_REG);

                rsMarkRegFree(genRegMask(op2->gtRegNum));

                // set gc info if we need so
                gcMarkRegPtrVal(op2->gtRegNum, tree->TypeGet());

                genUpdateLife(tree);
                genCodeForTree_DONE(tree, op2->gtRegNum);

                return;
            }
            else
            {
                assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

                /* Generate side effects of the first operand */

    #if 0
                // op1 is required to have a side effect, otherwise
                // the GT_COMMA should have been morphed out
                assert(op1->gtFlags & (GTF_GLOB_EFFECT | GTFD_NOP_BASH));
    #endif

                genEvalSideEffects(op1);
                genUpdateLife (op1);

                /* Is the value of the second operand used? */

                if  (tree->gtType == TYP_VOID)
                {
                    /* The right operand produces no result. The morpher is
                    responsible for resetting the type of GT_COMMA nodes
                    to TYP_VOID if op2 isnt meant to yield a result. */

                    genEvalSideEffects(op2);
                    genUpdateLife(tree);
                    return;
                }

                /* Generate the second operand, i.e. the 'real' value */

                genCodeForTree(op2, needReg);

                assert(op2->gtFlags & GTF_REG_VAL);

                /* The result of 'op2' is also the final result */

                reg  = op2->gtRegNum;

                /* Remember whether we set the flags */

                tree->gtFlags |= (op2->gtFlags & (GTF_CC_SET|GTF_ZF_SET));

                genCodeForTree_DONE(tree, reg);
                return;
            }           

        case GT_QMARK:

#if TGT_x86
            genCodeForQmark(tree, destReg, bestReg);
            return;
#else // not TGT_x86

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif // not TGT_x86

        case GT_BB_COLON:

#if TGT_x86
            /* @TODO [CONSIDER] [04/16/01] []: Don't always load the value into EAX! */

            genComputeReg(op1, RBM_EAX, EXACT_REG, FREE_REG);

            /* The result must now be in EAX */

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_EAX);

            /* The "_:" value has now been computed */

            reg = op1->gtRegNum;

            genCodeForTree_DONE(tree, reg);
            return;


#else // not TGT_x86

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif // not TGT_x86

        case GT_LOG0:
        case GT_LOG1:

            genCodeForTree_GT_LOG(tree, destReg, bestReg);

        case GT_RET:

#if TGT_x86

            /* Make the operand addressable */

            addrReg = genMakeAddressable(op1, needReg, FREE_REG, true);

            /* Jump indirect to the operand address */

            inst_TT(INS_i_jmp, op1);

            genDoneAddressable(op1, addrReg, FREE_REG);

            return;

#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

        case GT_NOP:

#if INLINING || OPT_BOOL_OPS
            if  (op1 == 0)
                return;
#endif

            /* Generate the operand into some register */

            genCodeForTree(op1, needReg);

            /* The result is the same as the operand */

            reg  = op1->gtRegNum;

            genCodeForTree_DONE(tree, reg);
            return;


#if INLINE_MATH

        case GT_MATH:

#if TGT_x86

            switch (tree->gtMath.gtMathFN)
            {
#if 0
              /*  seems like with the inliner, we don't need a non-floating
               *  point ABS intrinsic.  If we think we do, we need the EE
               *  to tell us (it currently does not)
               */
                BasicBlock *    skip;

            case CORINFO_INTRINSIC_Abs:

                skip = genCreateTempLabel();

                /* Generate the operand into some register */

                genCompIntoFreeReg(op1, needReg, FREE_REG);
                assert(op1->gtFlags & GTF_REG_VAL);

                reg   = op1->gtRegNum;

                /* Generate "test reg, reg" */

                inst_RV_RV(INS_test, reg, reg);

                /* Generate "jns skip" followed by "neg reg" */

                inst_JMP(EJ_jns, skip, false, false, true);
                inst_RV (INS_neg, reg, TYP_INT);

                /* Define the 'skip' label and we're done */

                genDefineTempLabel(skip, true);

                /* The register is now trashed */

                rsTrackRegTrash(reg);

                /* The result is the same as the operand */

                reg  = op1->gtRegNum;

                break;
#endif // 0

            case CORINFO_INTRINSIC_Round: {
                assert(tree->gtType == TYP_INT);
                genCodeForTreeFlt(op1, false);

                /* Store the FP value into the temp */
                TempDsc* temp = tmpGetTemp(TYP_INT);
                inst_FS_ST(INS_fistp, EA_4BYTE, temp, 0);
                genFPstkLevel--;

                reg = rsPickReg(needReg, bestReg, TYP_INT);
                rsTrackRegTrash(reg);

                inst_RV_ST(INS_mov, reg, temp, 0, TYP_INT);
                genTmpAccessCnt += 2;

                tmpRlsTemp(temp);
            } break;

            default:
                assert(!"unexpected math intrinsic");

            }

            genCodeForTree_DONE(tree, reg);
            return;


#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

#endif

        case GT_LCLHEAP:

            reg = genLclHeap(op1);
            genCodeForTree_DONE(tree, reg);
            return;


        case GT_COPYBLK:

            assert(op1->OperGet() == GT_LIST);

            /* If the value class doesn't have any fields that are GC refs or
               the target isnt on the GC-heap, we can merge it with CPBLK.
               GC fields cannot be copied directly, instead we will
               need to use a jit-helper for that. */

            if ((op2->OperGet() == GT_CNS_INT) &&
                ((op2->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_CLASS_HDL))
            {
                GenTreePtr  srcObj  = op1->gtOp.gtOp2;
                GenTreePtr  dstObj  = op1->gtOp.gtOp1;

                assert(dstObj->gtType == TYP_BYREF || dstObj->gtType == TYP_I_IMPL);

                CORINFO_CLASS_HANDLE clsHnd = (CORINFO_CLASS_HANDLE) op2->gtIntCon.gtIconVal;

                unsigned  blkSize = roundUp(eeGetClassSize(clsHnd), sizeof(void*));

                    // TODO since we round up, we are not handling the case where we have a non-dword sized struct with GC pointers.
                    // The EE currently does not allow this, but we may chnage.  Lets assert it just to be safe         
                    // going forward we should simply  handle this case
                assert(eeGetClassSize(clsHnd) == blkSize);

                unsigned  slots   = blkSize / sizeof(void*);
                BYTE *    gcPtrs  = (BYTE*) compGetMemArrayA(slots, sizeof(BYTE));

                eeGetClassGClayout(clsHnd, gcPtrs);

#if TGT_x86
                GenTreePtr  treeFirst, treeSecond;
                regNumber    regFirst,  regSecond;

                // Check what order the object-ptrs have to be evaluated in ?

                if (op1->gtFlags & GTF_REVERSE_OPS)
                {
                    treeFirst   = srcObj;
                    treeSecond  = dstObj;

                    regFirst    = REG_ESI;
                    regSecond   = REG_EDI;
                }
                else
                {
                    treeFirst   = dstObj;
                    treeSecond  = srcObj;

                    regFirst    = REG_EDI;
                    regSecond   = REG_ESI;
                }

                // Materialize the trees in the order desired

                genComputeReg(treeFirst,  genRegMask(regFirst),  EXACT_REG, KEEP_REG);
                genComputeReg(treeSecond, genRegMask(regSecond), EXACT_REG, KEEP_REG);

                genRecoverReg(treeFirst,  genRegMask(regFirst),             KEEP_REG);

                /* Grab ECX because it will be trashed by the helper        */
                /* It needs a scratch register (actually 2) and we know     */
                /* ECX is available because we expected to use rep movsd    */

                regNumber  reg1 = rsGrabReg(RBM_ECX);

                assert(reg1 == REG_ECX);

                /* @TODO [REVISIT] [04/16/01] []: use rep instruction after all GC pointers copied. */

                bool dstIsOnStack = (dstObj->gtOper == GT_ADDR && (dstObj->gtFlags & GTF_ADDR_ONSTACK));
                while (blkSize >= sizeof(void*))
                {
                    if (*gcPtrs++ == TYPE_GC_NONE || dstIsOnStack)
                    {
                        // Note that we can use movsd even if it is a GC poitner being transfered
                        // because the value is not cached anywhere.  If we did this in two moves,
                        // we would have to make certain we passed the appropriate GC info on to
                        // the emitter.  
                        instGen(INS_movsd);
                    }
                    else
                    {
                        genEmitHelperCall(CORINFO_HELP_ASSIGN_BYREF,
                                         0,             // argSize
                                         sizeof(void*));// retSize
                    }

                    blkSize -= sizeof(void*);
                }

                if (blkSize > 0)
                {
                    // Presently the EE makes this code path impossible
                    assert(!"TEST ME");
                    inst_RV_IV(INS_mov, REG_ECX, blkSize);
                    instGen(INS_r_movsb);
                }

                // "movsd" as well as CPX_BYREF_ASG modify all three registers

                rsTrackRegTrash(REG_EDI);
                rsTrackRegTrash(REG_ESI);
                rsTrackRegTrash(REG_ECX);

                gcMarkRegSetNpt(RBM_ESI|RBM_EDI);

                /* The emitter wont record CORINFO_HELP_ASSIGN_BYREF in the GC tables as
                   emitNoGChelper(CORINFO_HELP_ASSIGN_BYREF). However, we have to let the
                   emitter know that the GC liveness has changed.
                   HACK: We do this by creating a new label. */

                assert(emitter::emitNoGChelper(CORINFO_HELP_ASSIGN_BYREF));

                static BasicBlock dummyBB;
                genDefineTempLabel(&dummyBB, true);

                genReleaseReg(treeFirst);
                genReleaseReg(treeSecond);

                reg  = REG_COUNT;

                genCodeForTree_DONE(tree, reg);
                return;

#endif
            }

            // fall through

        case GT_INITBLK:

            assert(op1->OperGet() == GT_LIST);
#if TGT_x86

            regs = (oper == GT_INITBLK) ? RBM_EAX : RBM_ESI; // reg for Val/Src

            /* Some special code for block moves/inits for constant sizes */

            /* @TODO [CONSIDER] [04/16/01] []:
               we should avoid using the string instructions altogether,
               there are numbers that indicate that using regular instructions
               (normal mov instructions through a register) is faster than
               even the single string instructions
            */

            assert(op1 && op1->OperGet() == GT_LIST);
            assert(op1->gtOp.gtOp1 && op1->gtOp.gtOp2);

            if (op2->OperGet() == GT_CNS_INT &&
                ((oper == GT_COPYBLK) ||
                 (op1->gtOp.gtOp2->OperGet() == GT_CNS_INT))
                )
            {
                unsigned length = (unsigned) op2->gtIntCon.gtIconVal;
                instruction ins_D, ins_DR, ins_B, ins_BR;

                if (oper == GT_INITBLK)
                {
                    ins_D  = INS_stosd;
                    ins_DR = INS_r_stosd;
                    ins_B  = INS_stosb;
                    ins_BR = INS_r_stosb;

                    /* Properly extend the init constant from a U1 to a U4 */
                    unsigned val = 0xFF & ((unsigned) op1->gtOp.gtOp2->gtIntCon.gtIconVal);
                    
                    /* If it is a non-zero value we have to replicate      */
                    /* the byte value four times to form the DWORD         */
                    /* Then we bash this new value into the tree-node      */
                    
                    if (val)
                    {
                        val  = val | (val << 8) | (val << 16) | (val << 24);
                        op1->gtOp.gtOp2->gtIntCon.gtIconVal = val;
                    }
                }
                else
                {
                    ins_D  = INS_movsd;
                    ins_DR = INS_r_movsd;
                    ins_B  = INS_movsb;
                    ins_BR = INS_r_movsb;
                }

                /* Evaluate dest and src/val */

                if (op1->gtFlags & GTF_REVERSE_OPS)
                {
                    genComputeReg(op1->gtOp.gtOp2, regs,    EXACT_REG, KEEP_REG);
                    genComputeReg(op1->gtOp.gtOp1, RBM_EDI, EXACT_REG, KEEP_REG);
                    genRecoverReg(op1->gtOp.gtOp2, regs,               KEEP_REG);
                }
                else
                {
                    genComputeReg(op1->gtOp.gtOp1, RBM_EDI, EXACT_REG, KEEP_REG);
                    genComputeReg(op1->gtOp.gtOp2, regs,    EXACT_REG, KEEP_REG);
                    genRecoverReg(op1->gtOp.gtOp1, RBM_EDI,            KEEP_REG);
                }

                if (compCodeOpt() == SMALL_CODE)
                {
                    /* For small code, we can only use ins_DR to generate fast
                       and small code. Else, there's nothing we can do */

                    if ((length % 4) == 0)
                        goto USE_DR;
                    else
                    {
                        genSetRegToIcon(REG_ECX, length, TYP_INT);
                        instGen(ins_BR);
                        rsTrackRegTrash(REG_ECX);
                        goto DONE_CNS_BLK;
                    }
                }

                if (length <= 16)
                {
                    while (length > 3)
                    {
                        instGen(ins_D);
                        length -= 4;
                    }
                }
                else
                {
                USE_DR:

                    /* set ECX to length/4 (in dwords) */
                    genSetRegToIcon(REG_ECX, length/4, TYP_INT);

                    length &= 0x3;

                    instGen(ins_DR);

                    rsTrackRegTrash(REG_ECX);
                }

                /* Now take care of the remainder */
                while (length--)
                {
                    instGen(ins_B);
                }

            DONE_CNS_BLK:

                rsTrackRegTrash(REG_EDI);

                if (oper == GT_COPYBLK)
                    rsTrackRegTrash(REG_ESI);
                // else No need to trash EAX as it wasnt destroyed by the "rep stos"

                genReleaseReg(op1->gtOp.gtOp1);
                genReleaseReg(op1->gtOp.gtOp2);

            }
            else
            {

                // What order should the Dest, Val/Src, and Size be calculated

                fgOrderBlockOps(tree, RBM_EDI, regs, RBM_ECX,
                                      opsPtr,  regsPtr); // OUT arguments

                genComputeReg(opsPtr[0], regsPtr[0], EXACT_REG, KEEP_REG);
                genComputeReg(opsPtr[1], regsPtr[1], EXACT_REG, KEEP_REG);
                genComputeReg(opsPtr[2], regsPtr[2], EXACT_REG, KEEP_REG);

                genRecoverReg(opsPtr[0], regsPtr[0],            KEEP_REG);
                genRecoverReg(opsPtr[1], regsPtr[1],            KEEP_REG);

                assert( (op1->gtOp.gtOp1->gtFlags & GTF_REG_VAL) && // Dest
                        (op1->gtOp.gtOp1->gtRegNum == REG_EDI));

                assert( (op1->gtOp.gtOp2->gtFlags & GTF_REG_VAL) && // Val/Src
                        (genRegMask(op1->gtOp.gtOp2->gtRegNum) == regs));

                assert( (            op2->gtFlags & GTF_REG_VAL) && // Size
                        (            op2->gtRegNum == REG_ECX));


                // @TODO [CONSIDER] [04/16/01] []: 
                // Use "rep stosd" for the bulk of the operation, and
                // "rep stosb" for the remaining 3 or less bytes.
                // Will need an extra register.

                if (oper == GT_INITBLK)
                    instGen(INS_r_stosb);
                else
                    instGen(INS_r_movsb);

                rsTrackRegTrash(REG_EDI);
                rsTrackRegTrash(REG_ECX);

                if (oper == GT_COPYBLK)
                    rsTrackRegTrash(REG_ESI);
                // else No need to trash EAX as it wasnt destroyed by the "rep stos"

                genReleaseReg(opsPtr[0]);
                genReleaseReg(opsPtr[1]);
                genReleaseReg(opsPtr[2]);
            }

            reg  = REG_COUNT;

            genCodeForTree_DONE(tree, reg);
            return;


#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif // TGT_x86

        case GT_EQ:
        case GT_NE:
        case GT_LT:
        case GT_LE:
        case GT_GE:
        case GT_GT:

            // Longs and float comparisons are converted to "?:"
            assert(genActualType(op1->gtType) == TYP_INT ||
                   varTypeGCtype(op1->TypeGet()));

#if TGT_x86
            // Check if we can use the currently set flags. Else set them

            emitJumpKind jumpKind;
            jumpKind = genCondSetFlags(tree);

            // Grab a register to materialize the bool value into

            bestReg = rsRegMaskCanGrab() & RBM_BYTE_REGS;

            // Check that the predictor did the right job
            assert(bestReg);

            // If needReg is in bestReg then use it
            if (needReg & bestReg)
                reg = rsGrabReg(needReg & bestReg);
            else
                reg = rsGrabReg(bestReg);

            // @TODO [NICE] [04/16/01] []: Assert that no instructions were generated while
            // grabbing the register which would set the flags

            regs = genRegMask(reg);
            assert(regs & RBM_BYTE_REGS);

            // Set (lower byte of) reg according to the flags

            /* Look for the special case where just want to transfer the carry bit */

            if (jumpKind == EJ_jb)
            {
                inst_RV_RV(INS_sbb, reg, reg);
                inst_RV   (INS_neg, reg, TYP_INT);
                rsTrackRegTrash(reg);
            }
            else if (jumpKind == EJ_jae)
            {
                inst_RV_RV(INS_sbb, reg, reg);
                genIncRegBy(reg, 1, tree, TYP_INT);
                rsTrackRegTrash(reg);
            }
            else
            {
                // @TODO [CONSIDER] [04/16/01] []:
                // using this sequence (Especially on Pentium 4)
                //           mov   reg,0
                //           setcc reg

                inst_SET(jumpKind, reg);

                rsTrackRegTrash(reg);

                if (tree->TypeGet() == TYP_INT)
                {
                    // Set the higher bytes to 0
                    inst_RV_RV(INS_movzx, reg, reg, TYP_UBYTE, emitTypeSize(TYP_UBYTE));
                }
                else
                {
                    assert(tree->TypeGet() == TYP_BYTE);
                }
            }
#else
            assert(!"need RISC code");
#endif

            genCodeForTree_DONE(tree, reg);
            return;


        case GT_VIRT_FTN:

            CORINFO_METHOD_HANDLE   methHnd;
            methHnd = CORINFO_METHOD_HANDLE(tree->gtVal.gtVal2);

            // op1 is the vptr
#ifdef DEBUG
            GenTreePtr op;
            op = op1;
            while (op->gtOper == GT_COMMA)
                op = op->gtOp.gtOp2;
            assert((op->gtOper == GT_IND || op->gtOper == GT_LCL_VAR) && op->gtType == TYP_I_IMPL);
            assert(op->gtOper != GT_IND || op->gtOp.gtOp1->gtType == TYP_REF);
#endif

            /* Load the vptr into a register */

            genCompIntoFreeReg(op1, needReg, FREE_REG);
            assert(op1->gtFlags & GTF_REG_VAL);

            reg = op1->gtRegNum;

            if (tree->gtFlags & GTF_CALL_INTF)
            {
                /* @TODO [REVISIT] [04/16/01] []: add that to DLLMain and make info a DLL global */

                CORINFO_EE_INFO *     pInfo = eeGetEEInfo();
                CORINFO_CLASS_HANDLE  cls   = eeGetMethodClass(methHnd);

                assert(eeGetClassAttribs(cls) & CORINFO_FLG_INTERFACE);

                /* Load the vptr into a register */

                genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                         (emitRegs)reg, (emitRegs)reg,
                                         pInfo->offsetOfInterfaceTable);

                // Access the correct slot in the vtable for the interface

                unsigned interfaceID, *pInterfaceID;
                interfaceID = eeGetInterfaceID(cls, &pInterfaceID);
                assert(!pInterfaceID || !interfaceID);

                // Can we directly access the interfaceID ?

                if (!pInterfaceID)
                {
                    genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                             (emitRegs)reg, (emitRegs)reg,
                                             interfaceID * 4);
                }
                else
                {
                    genEmitter->emitIns_R_AR(INS_add, EA_4BYTE_DSP_RELOC,
                                             (emitRegs)reg, SR_NA, (int)pInterfaceID);
                    genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                             (emitRegs)reg, (emitRegs)reg, 0);
                }
            }

            /* Get hold of the vtable offset (note: this might be expensive) */

            val = (unsigned)eeGetMethodVTableOffset(methHnd);

            /* Grab the function pointer out of the vtable */

            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                     (emitRegs)reg, (emitRegs)reg, val);

            rsTrackRegTrash(reg);

            genCodeForTree_DONE(tree, reg);
            return;


        case GT_JMPI:
            /* Compute the function pointer in EAX */

            genComputeReg(tree->gtOp.gtOp1, RBM_EAX, EXACT_REG, FREE_REG);
            genCodeForTreeLeaf_GT_JMP(tree);
            return;

        case GT_ADDR:

            genCodeForTreeSmpOp_GT_ADDR(tree, destReg, bestReg);
            return;

#ifdef  DEBUG
        default:
            gtDispTree(tree);
            assert(!"unexpected unary/binary operator");
#endif
    }
 
    /* Do we ever get here?  If so, can we just call genCodeForTree_DONE? */

    assert(false);
    genCodeForTreeSpecialOp(tree, destReg, bestReg); 
}


/*****************************************************************************
 *
 *  Generate code for the a leaf node of type GT_ADDR
 */

void                Compiler::genCodeForTreeSmpOp_GT_ADDR(GenTreePtr tree,
                                                          regMaskTP  destReg,
                                                          regMaskTP  bestReg)
{
    genTreeOps      oper     = tree->OperGet();
    const var_types treeType = tree->TypeGet();
    GenTreePtr      op1      = tree->gtOp.gtOp1;
    regNumber       reg;
    regMaskTP       needReg  = destReg;
    regMaskTP       addrReg;

#ifdef DEBUG
    reg     =  (regNumber)0xFEEFFAAF;          // to detect uninitialized use
    addrReg = 0xDEADCAFE;
#endif

    // We should get here for ldloca, ldarga, ldslfda, ldelema,
    // or ldflda. 
    if (oper == GT_ARR_ELEM)
        op1 = tree;

#if     TGT_x86

    // (tree=op1, needReg=0, keepReg=FREE_REG, smallOK=true)
    addrReg = genMakeAddressable(op1, 0, FREE_REG, true);

    if (op1->gtOper == GT_IND && (op1->gtFlags & GTF_IND_FIELD))
    {
        GenTreePtr opAddr = op1->gtOp.gtOp1;
        assert((opAddr->gtOper == GT_ADD) || (opAddr->gtOper == GT_CNS_INT));
        /* Generate "cmp al, [addr]" to trap null pointers */
        inst_RV_AT(INS_cmp, EA_1BYTE, TYP_BYTE, REG_EAX, opAddr, 0);
    }

    assert( treeType == TYP_BYREF || treeType == TYP_I_IMPL );

    // We want to reuse one of the scratch registers that were used
    // in forming the address mode as the target register for the lea.
    // If bestReg is unset or if it is set to one of the registers used to
    // form the address (i.e. addrReg), we calculate the scratch register
    // to use as the target register for the LEA

    bestReg = rsUseIfZero (bestReg, addrReg);
    bestReg = rsNarrowHint(bestReg, addrReg);

    /* Even if addrReg is rsRegMaskCanGrab(), rsPickReg() wont spill
       it since keepReg==false.
       If addrReg cant be grabbed, rsPickReg() wont touch it anyway.
       So this is guaranteed not to spill addrReg */

    reg = rsPickReg(needReg, bestReg, treeType);

    // Slight hack, force the inst routine to think that
    // value being loaded is an int (since that is what what
    // LEA will return)  otherwise it would try to allocate
    // two registers for a long etc.
    assert(treeType == TYP_I_IMPL || treeType == TYP_BYREF);
    op1->gtType = treeType;

    inst_RV_TT(INS_lea, reg, op1, 0, (treeType == TYP_BYREF) ? EA_BYREF : EA_4BYTE);

    // The Lea instruction above better not have tried to put the
    // 'value' pointed to by 'op1' in a register, LEA will not work.
    assert(!(op1->gtFlags & GTF_REG_VAL));

    genDoneAddressable(op1, addrReg, FREE_REG);
//    gcMarkRegSetNpt(genRegMask(reg));
    assert((gcRegGCrefSetCur & genRegMask(reg)) == 0);

    rsTrackRegTrash(reg);       // reg does have foldable value in it
    gcMarkRegPtrVal(reg, treeType);

#else

    if  (op1->gtOper == GT_LCL_VAR)
    {
        bool            FPbased;

        // ISSUE:   The following assumes that it's OK to ask for
        //          the frame offset of a variable at this point;
        //          depending on when the layout of the frame is
        //          finalized, this may or may not be legal.

        emitRegs        base;
        unsigned        offs;

        /* Get info about the variable */

        offs = lvaFrameAddress(op1->gtLclVar.gtLclNum, &FPbased);

        base = FPbased ? (emitRegs)REG_FPBASE
            : (emitRegs)REG_SPBASE;

        /* Pick a register for the value */

        reg = rsPickReg(needReg, bestReg, treeType);

        /* Compute "basereg+frameoffs" into the chosen register */

        if  (offs)
        {
            genSetRegToIcon(reg, offs, treeType);

            genEmitter->emitIns_R_R(INS_add, EA_4BYTE, (emitRegs) reg,
                                                               (emitRegs) base);
        }
        else
        {
            genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, (emitRegs) reg,
                                                               (emitRegs) base);
        }
    }
    else
    {
        assert(!"need RISC code to take addr of general expression");
    }

    /* Mark the register contents appropriately */

    rsTrackRegTrash(reg);
    gcMarkRegPtrVal(reg, treeType);

#endif //TGT_x86

    genCodeForTree_DONE(tree, reg);
}


/*****************************************************************************
*/

void                Compiler::genCodeForTree_GT_LOG(GenTreePtr     tree,
                                                    regMaskTP      destReg,
                                                    regMaskTP      bestReg)
{
    if (!USE_GT_LOG)
    {
        assert(!"GT_LOG tree even though USE_GT_LOG=0");
        return;
    }

    GenTreePtr      op1 = tree->gtOp.gtOp1;
    regMaskTP       needReg = destReg;

    assert(varTypeIsFloating(op1->TypeGet()) == false);

    // @TODO [CONSIDER] [04/16/01] []: allow to materialize comparison result

    // @TODO [CONSIDER] [04/16/01] []: special-case variables known to be boolean

    assert(op1->OperIsCompare() == false);

#if !TGT_x86


#ifdef  DEBUG
    gtDispTree(tree);
#endif
    assert(!"need non-x86 code");
    return;

#else // TGT_x86

#if USE_SET_FOR_LOGOPS

    /*
        Generate the following sequence:

            xor     reg, reg
            cmp     op1, 0  (or "test reg, reg")
            set[n]e reg
     */

    regNumber       bit;

#if !SETEONP5
    /* Sete/Setne are slow on P5. */

    if (genCPU == 5)
        goto NO_SETE1;
#endif

    /* Don't use SETE/SETNE for some kinds of operands */

    if  (op1->gtOper == GT_CALL)
        goto NO_SETE1;

    /* Prepare the operand */

    /*
        The following is rude - the idea is to try to keep
        a bit register for multiple conditionals in a row.
     */

    rsNextPickRegIndex = 0;

    // ISSUE: is the following reasonable?

    switch (op1->gtType)
    {
    default:

        /* Not an integer - only allow simple values */

        if  (op1->gtOper != GT_LCL_VAR && op1->gtOper != GT_LCL_FLD)
            break;

    case TYP_INT:

        /* Load the value to create scheduling opportunities */

        genCodeForTree(op1, needReg);
        break;

    case TYP_REF:
    case TYP_BYREF:

        /* Stay away from pointer values! */

        break;
    }

    regMaskTP   addrReg = genMakeRvalueAddressable(op1, needReg, KEEP_REG);

    /* Don't use SETE/SETNE if no registers are free */

    if  (!rsFreeNeededRegCount(RBM_ALL))
        goto NO_SETE2;

    /* Pick a target register */

    assert(needReg);

    /* Can we reuse a register that has all upper bits cleared? */

    regNumber   reg;

#if REDUNDANT_LOAD
    /* Request free, byte-addressable register */
    reg = bit = rsFindRegWithBit(true, true);
#else
    reg = bit = REG_NA;
#endif

    if  (reg == REG_NA || !(genRegMask(reg) & RBM_BYTE_REGS))
    {
        /* Didn't find a suitable register with a bit in it */

        needReg &= RBM_BYTE_REGS;
        if  (!(needReg & rsRegMaskFree()))
            needReg = RBM_BYTE_REGS;

        /* Make sure the desired mask contains a free register */

        if  (!(needReg & rsRegMaskFree()))
            goto NO_SETE2;

        /*
            The following is rude - the idea is to try to keep
            a bit register for multiple conditionals in a row.
         */

        rsNextPickRegIndex = 1;

        /* Pick the target register */

        bit = REG_NA;
        reg = rsPickReg(needReg);
    }

    assert(genRegMask(reg) & rsRegMaskFree());

    /* Temporarily lock the register */

    rsLockReg(genRegMask(reg));

    /* Clear the target register */

    if  (bit == REG_NA)
        genSetRegToIcon(reg, 0);

    /* Make sure the operand is still addressable */

    addrReg = genKeepAddressable(op1, addrReg);

    /* Test the value against 0 */

    if  (op1->gtFlags & GTF_REG_VAL)
        inst_RV_RV(INS_test, op1->gtRegNum, op1->gtRegNum);
    else
        inst_TT_IV(INS_cmp, op1, 0);

    /* The operand value is no longer needed */

    genDoneAddressable(op1, addrReg, KEEP_REG);
    genUpdateLife (op1);

    /* Now set the target register based on the comparison result */

    inst_RV((tree->gtOper == GT_LOG0) ? INS_sete
                                      : INS_setne, reg, TYP_INT);

    rsTrackRegOneBit(reg);

    /* Now unlock the target register */

    rsUnlockReg(genRegMask(reg));

    genCodeForTree_DONE(tree, reg);
    return;


NO_SETE1:

#endif // USE_SET_FOR_LOGOPS

    /* Make the operand addressable */

    addrReg = genMakeRvalueAddressable(op1, needReg, KEEP_REG);

#if USE_SET_FOR_LOGOPS
NO_SETE2:
#endif

    /*
        Generate the 'magic' sequence:

            cmp op1, 1
            sbb reg, reg
            neg reg

        or

            cmp op1, 1
            sbb reg, reg
            [inc reg]
               or
            [add reg, 1]
     */

    inst_TT_IV(INS_cmp, op1, 1);

    /* The operand value is no longer needed */

    genDoneAddressable(op1, addrReg, KEEP_REG);
    genUpdateLife (op1);

    /* Pick a register for the value */

    reg   = rsPickReg(needReg, bestReg);

    inst_RV_RV(INS_sbb, reg, reg, tree->TypeGet());

    if (tree->gtOper == GT_LOG0)
        inst_RV(INS_neg,  reg, TYP_INT);
    else
        genIncRegBy(reg, 1, tree, TYP_INT);

    /* The register is now trashed */

    rsTrackRegTrash(reg);

    genCodeForTree_DONE(tree, reg);
    return;

#endif // TGT_x86
}

/*****************************************************************************
 *
 *  Generate code for a GT_ASG tree
 */

void                Compiler::genCodeForTreeSmpOpAsg(GenTreePtr tree,
                                                     regMaskTP  destReg,
                                                     regMaskTP  bestReg)
{
    genTreeOps      oper     = tree->OperGet();
    GenTreePtr      op1      = tree->gtOp.gtOp1;
    GenTreePtr      op2      = tree->gtOp.gtOp2;
    regNumber       reg;
    regMaskTP       needReg  = destReg;
    regMaskTP       addrReg;
    bool            ovfl = false;        // Do we need an overflow check
    regMaskTP       regGC;
    unsigned        mask;

#ifdef DEBUG
    reg     =  (regNumber)0xFEEFFAAF;              // to detect uninitialized use
    addrReg = 0xDEADCAFE;
#endif

    assert(oper == GT_ASG);

    /* Is the target a register or local variable? */

    switch (op1->gtOper)
    {
        unsigned        varNum;
        LclVarDsc   *   varDsc;
        VARSET_TP       varBit;

    case GT_CATCH_ARG:
        break;

    case GT_LCL_VAR:

        varNum = op1->gtLclVar.gtLclNum;
        assert(varNum < lvaCount);
        varDsc = lvaTable + varNum;
        varBit = genVarIndexToBit(varDsc->lvVarIndex);

#ifdef DEBUGGING_SUPPORT

        /* For non-debuggable code, every definition of a lcl-var has
         * to be checked to see if we need to open a new scope for it.
         */
        if (opts.compScopeInfo && !opts.compDbgCode &&
            info.compLocalVarsCount>0)
        {
            siCheckVarScope(varNum, op1->gtLclVar.gtLclILoffs);
        }
#endif

        /* Check against dead store ? */

        assert(!varDsc->lvTracked || (varBit & tree->gtLiveSet));

        /* Does this variable live in a register? */

        if  (genMarkLclVar(op1))
            goto REG_VAR2;

#if OPT_BOOL_OPS
#if TGT_x86

        /* Special case: not'ing of a boolean variable */

        if  (varDsc->lvIsBoolean && op2->gtOper == GT_LOG0)
        {
            GenTreePtr      opr = op2->gtOp.gtOp1;

            if  (opr->gtOper            == GT_LCL_VAR &&
                 opr->gtLclVar.gtLclNum == varNum)
            {
                inst_TT_IV(INS_xor, op1, 1);

                rsTrashLcl(op1->gtLclVar.gtLclNum);

                addrReg = 0;
                
                genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, tree->gtRegNum, ovfl);
                return;
            }
        }

#endif
#endif
        break;

    case GT_LCL_FLD:

        // We only use GT_LCL_FLD for lvAddrTaken vars, so we dont have
        // to worry about it being enregistered.
        assert(lvaTable[op1->gtLclFld.gtLclNum].lvRegister == 0);
        break;

    case GT_CLS_VAR:

        /* ISSUE: is it OK to always assign an entire int ? */

        /*** If we do this, we can only do it for statics that we
             allocate.  In particular, statics with RVA's should
             not be widened in this way.  :
        if  (varTypeIsSmall(op1->TypeGet()))
             op1->gtType = TYP_INT;
        ***/

        break;

    case GT_REG_VAR:
        assert(!"This was used before. Now it should never be reached directly");
        NO_WAY("This was used before. Now it should never be reached directly");

        REG_VAR2:

        /* Get hold of the target register */

        reg = op1->gtRegVar.gtRegNum;

        /* Special case: assignment of 'return address' */

        if  (op2->gtOper == GT_RET_ADDR)
        {
            /* Make sure the target of the store is available */

            assert((rsMaskUsed & genRegMask(reg)) == 0);

            goto RET_ADR;
        }

        /* Special case: assignment by popping off the stack */

        if  (op2->gtOper == GT_POP)
        {
            /* Make sure the target of the store is available */

            assert((rsMaskUsed & genRegMask(reg)) == 0);
#if TGT_x86
            /* Generate 'pop reg' and we're done */

            genStackLevel -= sizeof(void *);
            inst_RV(INS_pop, reg, op2->TypeGet());
            genStackLevel += sizeof(void *);

            genSinglePop();
#else
            assert(!"need non-x86 code");
#endif
            /* Make sure we track the values properly */

            rsTrackRegTrash(reg);
            gcMarkRegPtrVal(reg, tree->TypeGet());

            addrReg = 0;
            
            genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
            return;
        }

#if OPT_BOOL_OPS
#if TGT_x86

        /* Special case: not'ing of a boolean variable */

        if  (varDsc->lvIsBoolean && op2->gtOper == GT_LOG0)
        {
            GenTreePtr      opr = op2->gtOp.gtOp1;

            if  (opr->gtOper            == GT_LCL_VAR &&
                 opr->gtLclVar.gtLclNum == varNum)
            {
                inst_RV_IV(INS_xor, reg, 1);

                rsTrackRegTrash(reg);

                addrReg = 0;
                
                genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
                return;
            }
        }
#endif
#endif
        /* Compute the RHS (hopefully) into the variable's register
           For debuggable code, reg may already be part of rsMaskVars,
           as variables are kept alive everywhere. So we have to be
           careful if we want to compute the value directly into
           the variable's register.

           @TODO [REVISIT] [04/16/01] []: Do we need to be careful for longs/floats too ? */

        if (varBit & op2->gtLiveSet)
        {
            assert(opts.compDbgCode);

            /* The predictor might expect us to generate op2 directly
               into the var's register. However, since the variable is
               already alive, first kill it and its register. */

            if (rpCanAsgOperWithoutReg(op2, true))
            {
                genUpdateLife(genCodeCurLife & ~varBit);
                op2->gtLiveSet &= ~varBit;
                needReg = rsNarrowHint(needReg, genRegMask(reg));
            }
        }
        else
        {
            needReg = rsNarrowHint(needReg, genRegMask(reg));
        }

#ifdef DEBUG

        /* Special cases: op2 is a GT_CNS_INT */

        if  (op2->gtOper == GT_CNS_INT)
        {
            /* Save the old life status */

            genTempOldLife = genCodeCurLife;
            genCodeCurLife = op1->gtLiveSet;

            /* Set a flag to avoid printing the stupid message
               and remember that life was changed. */

            genTempLiveChg = false;
        }
#endif

        genCodeForTree(op2, needReg, genRegMask(reg));
        assert(op2->gtFlags & GTF_REG_VAL);

        /* Make sure the value ends up in the right place ... */

        if  (op2->gtRegNum != reg)
        {
            /* Make sure the target of the store is available */
            /* @TODO [CONSIDER] [04/16/01] []: We should be able to avoid this situation somehow */

            if  (rsMaskUsed & genRegMask(reg))
                rsSpillReg(reg);
#if TGT_x86
            inst_RV_RV(INS_mov, reg, op2->gtRegNum, op1->TypeGet());
#else
            genEmitter->emitIns_R_R(INS_mov,
                                    emitActualTypeSize(op1->TypeGet()),
                                    (emitRegs)reg,
                                    (emitRegs)op2->gtRegNum);

#endif

            /* The value has been transferred to 'reg' */

            rsTrackRegCopy (reg, op2->gtRegNum);

            gcMarkRegSetNpt(genRegMask(op2->gtRegNum));
            gcMarkRegPtrVal(reg, tree->TypeGet());
        }
        else
        {
            gcMarkRegPtrVal(reg, tree->TypeGet());
#ifdef DEBUG
            // @TODO [REVISIT] [04/16/01] []:  we use assignments to convert from GC references 
            // to non-gc references. that feels needlessly heavy, and we should do better.

            // The emitter has logic that tracks the GCness of registers and asserts if you
            // try to do evil things to a GC pointer (like loose its GCness).  

            // an explict cast of a GC poitner ot an int (which is legal if the pointer is pinned
            // is encoded as a assignement of a GC source to a integer variable.  Unfortunate if the 
            // source was the last use and the source gets reused destination, no code gets emitted 
            // (That is where we are at right now).  This causes asserts to fire because the emitter
            // things the register is a GC pointer (it did not see the cast).   Force it to see
            // the change in the types of variable by placing a label  We only need to do this in
            // debug since we are just trying to supress an assert.  
            if (op2->TypeGet() == TYP_REF && !varTypeGCtype(op1->TypeGet())) 
            {
                void* label;
                genEmitter->emitAddLabel(&label, gcVarPtrSetCur, gcRegGCrefSetCur, gcRegByrefSetCur);
            }
#endif

#if 0
            /* The lvdNAME stuff is busted */

            /* Couldn't print the var name because it wasn't marked live */

            if  (dspCode  &&
                 varNames && info.compLocalVarsCount>0
                 && genTempLiveChg && op2->gtOper != GT_CNS_INT)
            {
                unsigned        blkBeg = compCurBB->bbCodeOffs;
                unsigned        blkEnd = compCurBB->bbCodeSize + blkBeg;
                unsigned        varNum = op1->gtRegVar.gtRegVar;
                LocalVarDsc *   lvd    = compFindLocalVar(varNum,
                                                          blkBeg,
                                                          blkEnd);
                if (lvd)
                {
                    printf("            ;       %s now holds '%s'\n",
                           compRegVarName(op1->gtRegVar.gtRegNum),
                           lvdNAMEstr(lvd->lvdName));
                }
            }
#endif
        }

        addrReg = 0;
        
        genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
        return;
    }

#if GEN_COUNT_PTRASG
#if TGT_x86

    /* Are we assigning a persistent pointer value? */

    if  (op1->gtType == TYP_REF)
    {
        switch (op1->gtOper)
        {
        case GT_IND:
        case GT_CLS_VAR:
            genEmitter.emitCodeGenByte(0xFF);
            genEmitter.emitCodeGenByte(0x05);
            genEmitter.emitCodeGenLong((int)&ptrAsgCount);
            break;
        }
    }

#endif
#endif

    /* Is the value being assigned a simple one? */

    assert(op2);
    switch (op2->gtOper)
    {
    case GT_LCL_VAR:

        if  (!genMarkLclVar(op2))
            goto SMALL_ASG;

        // Fall through ...

    case GT_REG_VAR:

        /* Is the target a byte/short/char value? */

        if  (varTypeIsSmall(op1->TypeGet()))
            goto SMALL_ASG;

#if CSE

        /* This can happen when the RHS becomes a CSE */

        if  (tree->gtFlags & GTF_REVERSE_OPS)
            goto SMALL_ASG;

#endif

        /* Make the target addressable */

        addrReg = genMakeAddressable(op1, needReg, KEEP_REG, true);

        // UNDONE: Write barrier for non-x86

#if TGT_x86

        /* Write barrier helper does the assignment */

        regGC = WriteBarrier(op1, op2->gtRegVar.gtRegNum, addrReg);

        if  (regGC == 0)
        {
            /* Move the value into the target */

            inst_TT_RV(INS_mov, op1, op2->gtRegVar.gtRegNum);
        }

#else

        /* Move the value into the target */

        inst_TT_RV(INS_mov, op1, op2->gtRegVar.gtRegNum);

#endif

        /* Free up anything that was tied up by the LHS */

        genDoneAddressable(op1, addrReg, KEEP_REG);

        /* Remember that we've also touched the op2 register */

        addrReg |= genRegMask(op2->gtRegVar.gtRegNum);
        break;

#if TGT_x86

    case GT_CNS_INT:

        /* Make the target addressable */

        addrReg = genMakeAddressable(op1, needReg, KEEP_REG, true);

        /* Move the value into the target */

        assert(op1->gtOper != GT_REG_VAR);
        if (opts.compReloc && (op2->gtFlags & GTF_ICON_HDL_MASK))
        {
            /* The constant is actually a handle that may need relocation
               applied to it.  genComputeReg will do the right thing (see
               code in genCodeForTreeConst), so we'll just call it to load
               the constant into a register. */
                
            genComputeReg(op2, needReg & ~addrReg, ANY_REG, KEEP_REG);
            addrReg = genKeepAddressable(op1, addrReg, genRegMask(op2->gtRegNum));
            assert(op2->gtFlags & GTF_REG_VAL);
            inst_TT_RV(INS_mov, op1, op2->gtRegNum);
            genReleaseReg(op2); 
        }
        else
        {
#if REDUNDANT_LOAD
            reg = rsIconIsInReg(op2->gtIntCon.gtIconVal);

            if  (reg != REG_NA &&
                 (isByteReg(reg) || genTypeSize(tree->TypeGet()) == genTypeSize(TYP_INT)))
            {
                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, reg);
            }
            else
#endif
            {
                inst_TT_IV(INS_mov, op1, op2->gtIntCon.gtIconVal);
            }
        }

        /* Free up anything that was tied up by the LHS */

        genDoneAddressable(op1, addrReg, KEEP_REG);
        break;

#endif

    case GT_RET_ADDR:

        RET_ADR:

        /* this should only happen at the start of a finally-clause,
           i.e. we start with the return-value pushed onto the stack.
           Right now any try-block requires an EBP frame, so we don't
           have to deal with proper stack-depth tracking for BBs with
           non-empty stack on entry.
        */

#if TGT_x86
        assert(genFPreqd);

        /* We pop the return address off the stack into the target */

        addrReg = genMakeAddressable(op1, needReg, KEEP_REG, true);

        /* Move the value into the target */

        inst_TT(INS_pop_hide, op1);

        /* Free up anything that was tied up by the LHS */

        genDoneAddressable(op1, addrReg, KEEP_REG);

#else

#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"need non-x86 code");

#endif

        break;

    case GT_POP:

        assert(op1->gtOper == GT_LCL_VAR);

#if TGT_x86

        /* Generate 'pop [lclVar]' and we're done */

        genStackLevel -= sizeof(void*);
        inst_TT(INS_pop, op1);
        genStackLevel += sizeof(void*);

        genSinglePop();

        addrReg = 0;

#else

#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"need non-x86 code");

#endif
        break;

    default:

        SMALL_ASG:

            bool            isWriteBarrier = false;

#if TGT_x86
        /*  Is the LHS more complex than the RHS? */

        if  (tree->gtFlags & GTF_REVERSE_OPS)
        {
            /* Is the target a byte/short/char value? */

            if (varTypeIsSmall(op1->TypeGet()) /* && (op1->gtType != TYP_BOOL) @TODO [REVISIT] [04/16/01] [vancem]: */)
            {
                assert(op1->gtOper != GT_LCL_VAR ||
                       lvaTable[op1->gtLclVar.gtLclNum].lvNormalizeOnLoad());

                if  (op2->gtOper == GT_CAST && !op2->gtOverflow())
                {
                    /* Special case: cast to small type */

                    if  (op2->gtCast.gtCastType >= op1->gtType)
                    {
                        /* Make sure the cast operand is not > int */

                        if  (op2->gtCast.gtCastOp->gtType <= TYP_INT)
                        {
                            /* Cast via a non-smaller type */

                            op2 = op2->gtCast.gtCastOp;
                        }
                    }
                }

                if (op2->gtOper             == GT_AND &&
                    op2->gtOp.gtOp2->gtOper == GT_CNS_INT)
                {
                    switch (op1->gtType)
                    {
                    case TYP_BYTE : mask = 0x000000FF; break;
                    case TYP_SHORT: mask = 0x0000FFFF; break;
                    case TYP_CHAR : mask = 0x0000FFFF; break;
                    default: goto SIMPLE_SMALL;
                    }

                    if  (unsigned(op2->gtOp.gtOp2->gtIntCon.gtIconVal) == mask)
                    {
                        /* Redundant AND */

                        op2 = op2->gtOp.gtOp1;
                    }
                }

                /* Must get the new value into a byte register */

                SIMPLE_SMALL:

                    if (varTypeIsByte(op1->TypeGet()))
                        genComputeReg(op2, RBM_BYTE_REGS, EXACT_REG, KEEP_REG);
                    else
                        goto NOT_SMALL;
            }
            else
            {
                NOT_SMALL:

                    /* Generate the RHS into a register */

                isWriteBarrier = Compiler::gcIsWriteBarrierAsgNode(tree);
                if  (isWriteBarrier)
                    needReg = exclude_EDX(needReg);
                ExactReg mustReg = isWriteBarrier ? EXACT_REG : ANY_REG;
                genComputeReg(op2, needReg, mustReg, KEEP_REG);
            }

            assert(op2->gtFlags & GTF_REG_VAL);

            /* Make the target addressable */

            addrReg = genMakeAddressable(op1, 
                                         needReg & ~op2->gtRsvdRegs, 
                                         KEEP_REG, true);

            /*  Make sure the RHS register hasn't been spilled;
                keep the register marked as "used", otherwise
                we might get the pointer lifetimes wrong.
            */

            if (varTypeIsByte(op1->TypeGet()))
                needReg = rsNarrowHint(RBM_BYTE_REGS, needReg);

            genRecoverReg(op2, needReg, KEEP_REG);
            assert(op2->gtFlags & GTF_REG_VAL);

            /* Lock the RHS temporarily (lock only already used) */

            rsLockUsedReg(genRegMask(op2->gtRegNum));

            /* Make sure the LHS is still addressable */

            addrReg = genKeepAddressable(op1, addrReg);

            /* We can unlock (only already used ) the RHS register */

            rsUnlockUsedReg(genRegMask(op2->gtRegNum));

            /* Write barrier helper does the assignment */

            regGC = WriteBarrier(op1, op2->gtRegNum, addrReg);

            if  (regGC != 0)
            {
                assert(isWriteBarrier);
            }
            else
            {
                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, op2->gtRegNum);
            }

            /* Update the current liveness info */

#ifdef DEBUG
            if (varNames) genUpdateLife(tree);
#endif

            /* free reg left used in Recover call */
            rsMarkRegFree(genRegMask(op2->gtRegNum));

            /* Free up anything that was tied up by the LHS */

            genDoneAddressable(op1, addrReg, KEEP_REG);
        }
        else
        {
            /* Make the target addressable */

            isWriteBarrier = Compiler::gcIsWriteBarrierAsgNode(tree);

            if  (isWriteBarrier)
            {
                /* Try to avoid EAX and op2 reserved regs */
                addrReg = genMakeAddressable(op1,
                                             rsNarrowHint(needReg, ~(RBM_EAX | op2->gtRsvdRegs)),
                                             KEEP_REG, true);
            }
            else
                addrReg = genMakeAddressable(op1,
                                             needReg & ~op2->gtRsvdRegs,
                                             KEEP_REG, true);

            /* Is the target a byte value? */
            if (varTypeIsByte(op1->TypeGet()))
            {
                /* Must get the new value into a byte register */
                needReg = rsNarrowHint(RBM_BYTE_REGS, needReg);

                if  (op2->gtType >= op1->gtType)
                    op2->gtFlags |= GTF_SMALL_OK;
            }
            else
            {
                /* For WriteBarrier we can't use EDX */
                if  (isWriteBarrier)
                    needReg = exclude_EDX(needReg);
            }

            /* If possible avoid using the addrReg(s) */
            bestReg = rsNarrowHint(needReg, ~addrReg);

            /* If we have a reg available to grab then use bestReg */
            if (bestReg & rsRegMaskCanGrab())
            {
                needReg = bestReg;
            }

            /* Generate the RHS into a register */
            genComputeReg(op2, needReg, EXACT_REG, KEEP_REG);

            /* Make sure the target is still addressable */

            assert(op2->gtFlags & GTF_REG_VAL);
            addrReg = genKeepAddressable(op1, addrReg, genRegMask(op2->gtRegNum));
            assert(op2->gtFlags & GTF_REG_VAL);

            /* Write barrier helper does the assignment */

            regGC = WriteBarrier(op1, op2->gtRegNum, addrReg);

            if  (regGC != 0)
            {
                assert(isWriteBarrier);
            }
            else
            {
                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, op2->gtRegNum);
            }

            /* The new value is no longer needed */

            genReleaseReg(op2);

            /* Update the current liveness info */

#ifdef DEBUG
            if (varNames) genUpdateLife(tree);
#endif

            /* Free up anything that was tied up by the LHS */
            genDoneAddressable(op1, addrReg, KEEP_REG);
        }

#else // not TGT_x86

        assert(!"UNDONE: GC write barrier for RISC");

        /*  Is the LHS more complex than the RHS? Also, if
            target (op1) is a local variable, start with op2.
         */

        if  ((tree->gtFlags & GTF_REVERSE_OPS) ||
             op1->gtOper == GT_LCL_VAR || op1->gtOper == GT_LCL_FLD)
        {
            /* Generate the RHS into a register */

            genComputeReg(op2, rsExcludeHint(needReg, op1->gtRsvdRegs), ANY_REG, KEEP_REG);
            assert(op2->gtFlags & GTF_REG_VAL);

            /* Make the target addressable */

            addrReg = genMakeAddressable(op1, needReg, KEEP_REG, true, true);

            /*  Make sure the RHS register hasn't been spilled;
                keep the register marked as "used", otherwise
                we might get the pointer lifetimes wrong.
            */

            genRecoverReg(op2, 0, KEEP_REG);
            assert(op2->gtFlags & GTF_REG_VAL);

            /* Lock the RHS temporarily (lock only already used) */

            rsLockUsedReg(genRegMask(op2->gtRegNum));

            /* Make sure the LHS is still addressable */

            if  (genDeferAddressable(op1))
                addrReg = genNeedAddressable(op1, addrReg, needReg);
            else
                addrReg = genKeepAddressable(op1, addrReg);

            /* We can unlock the register holding the RHS */

            rsUnlockUsedReg(genRegMask(op2->gtRegNum));

            /* Move the value into the target */

            inst_TT_RV(INS_mov, op1, op2->gtRegNum);

            /* Update the current liveness info */

#ifdef DEBUG
            if (varNames) genUpdateLife(tree);
#endif

            /* Free up anything that was tied up by either operand */

            rsMarkRegFree(genRegMask(op2->gtRegNum));
            genDoneAddressable(op1, addrReg, KEEP_REG);
        }
        else
        {
            /* Make the target addressable */

            addrReg = genMakeAddressable(op1, needReg & ~op2->gtRsvdRegs,
                                         KEEP_REG, true);

            /* Generate the RHS into any register */

            genComputeReg(op2, needReg & ~addrReg, 
                          ANY_REG, KEEP_REG);

            /* Make sure the target is still addressable */

            assert(op2->gtFlags & GTF_REG_VAL);
            addrReg = genKeepAddressable(op1, addrReg, genRegMask(op2->gtRegNum));
            assert(op2->gtFlags & GTF_REG_VAL);

            /* Move the value into the target */

            inst_TT_RV(INS_mov, op1, op2->gtRegNum);

            /* The new value is no longer needed */

            genReleaseReg(op2);

            /* Update the current liveness info */

#ifdef DEBUG
            if (varNames) genUpdateLife(tree);
#endif

            /* Free up anything that was tied up by the LHS */

            genDoneAddressable(op1, addrReg, KEEP_REG);
        }

#endif // not TGT_x86

        addrReg = 0;
        break;
    }

    genCodeForTreeSmpOpAsg_DONE_ASSG(tree, addrReg, reg, ovfl);
}

/*****************************************************************************
 *
 *  Generate code to complete the assignment operation
 */

void                Compiler::genCodeForTreeSmpOpAsg_DONE_ASSG(GenTreePtr tree,
                                                               regMaskTP  addrReg,
                                                               regNumber  reg,
                                                               bool       ovfl)
{
    const var_types treeType = tree->TypeGet();
    genTreeOps      oper     = tree->OperGet();
    GenTreePtr      op1      = tree->gtOp.gtOp1;
    GenTreePtr      op2      = tree->gtOp.gtOp2;
    assert(op2);

    genUpdateLife(tree);

#if REDUNDANT_LOAD

    if (op1->gtOper == GT_LCL_VAR)
        rsTrashLcl(op1->gtLclVar.gtLclNum);
    else if (op1->gtOper == GT_CLS_VAR)
        rsTrashClsVar(op1->gtClsVar.gtClsVarHnd);
    else
        rsTrashAliasedValues(op1);

    /* Have we just assigned a value that is in a register? */

    if ((op2->gtFlags & GTF_REG_VAL) && tree->gtOper == GT_ASG)
    {
        /* Constant/bitvalue has precedence over local */

        switch (rsRegValues[op2->gtRegNum].rvdKind)
        {
        case RV_INT_CNS:
#if USE_SET_FOR_LOGOPS
        case RV_BIT:
#endif
            break;

        default:

            /* Mark RHS register as containing the value */

            switch(op1->gtOper)
            {
            case GT_LCL_VAR:
                rsTrackRegLclVar(op2->gtRegNum, op1->gtLclVar.gtLclNum);
                break;
            case GT_CLS_VAR:
                rsTrackRegClsVar(op2->gtRegNum, op1);
                break;
            }
        }
    }

#endif

    assert(addrReg != 0xDEADCAFE);
    gcMarkRegSetNpt(addrReg);

    if (ovfl)
    {
        assert(oper == GT_ASG_ADD || oper == GT_ASG_SUB);

        /* If GTF_REG_VAL is not set, and it is a small type, then
           we must have loaded it up from memory, done the increment,
           checked for overflow, and then stored it back to memory */

        bool ovfCheckDone =  (genTypeSize(treeType) < sizeof(int)) &&
            !(op1->gtFlags & GTF_REG_VAL);

        if (!ovfCheckDone)
        {
            // For small sizes, reg should be set as we sign/zero extend it.

            assert(genIsValidReg(reg) ||
                   genTypeSize(treeType) == sizeof(int));

            /* Currently we dont morph x=x+y into x+=y in try blocks
             * if we need overflow check, as x+y may throw an exception.
             * We can do it if x is not live on entry to the catch block
             */
            assert(!compCurBB->bbTryIndex);

            genCheckOverflow(tree, reg);
        }
    }
}


/*****************************************************************************
 *
 *  Generate code for a special op tree
 */

void                Compiler::genCodeForTreeSpecialOp(GenTreePtr tree,
                                                      regMaskTP  destReg,
                                                      regMaskTP  bestReg)
{
    genTreeOps oper         = tree->OperGet();
    regNumber       reg;
    regMaskTP       regs    = rsMaskUsed;

#ifdef DEBUG
    reg  =  (regNumber)0xFEEFFAAF;              // to detect uninitialized use
#endif
    
    assert((tree->OperKind() & (GTK_CONST | GTK_LEAF | GTK_SMPOP)) == 0);

    switch  (oper)
    {
    case GT_CALL:

        regs = genCodeForCall(tree, true);

        /* If the result is in a register, make sure it ends up in the right place */

        if (regs != RBM_NONE)
        {
            tree->gtFlags |= GTF_REG_VAL;
            tree->gtRegNum = genRegNumFromMask(regs);
        }

        genUpdateLife(tree);
        return;

#if TGT_x86
    case GT_LDOBJ:

        /* Should only happen when we evaluate the side-effects of ldobj */
        /* In case the base address points to one of our locals, we are  */
        /* sure that there aren't any, i.e. we don't generate any code   */

        /* @TODO [CONSIDER] [04/16/01] []: can we ensure that ldobj      */
        /* isn't really being used?                                      */

        GenTreePtr      ptr;

        assert(tree->TypeGet() == TYP_STRUCT);
        ptr = tree->gtLdObj.gtOp1;
        if (ptr->gtOper != GT_ADDR || ptr->gtOp.gtOp1->gtOper != GT_LCL_VAR)
        {
            genCodeForTree(ptr, 0);
            assert(ptr->gtFlags & GTF_REG_VAL);
            reg = ptr->gtRegNum;

            genEmitter->emitIns_AR_R(INS_test, EA_4BYTE,
                                      SR_EAX, (emitRegs)reg, 0);

            rsTrackRegTrash(reg);

            gcMarkRegSetNpt(genRegMask(reg));
            genUpdateLife(tree);
        }
        return;

#endif // TGT_x86

    case GT_FIELD:
        NO_WAY("should not see this operator in this phase");
        break;

#if CSELENGTH

    case GT_ARR_LENREF:
    {
        /* This must be an array length CSE def hoisted out of a loop */

        assert(tree->gtFlags & GTF_ALN_CSEVAL);

        GenTreePtr addr = tree->gtArrLen.gtArrLenAdr; assert(addr);

        genCodeForTree(addr, 0);
        rsMarkRegUsed(addr);

        /* Generate code for the CSE definition */

        genEvalCSELength(tree, addr, NULL);

        genReleaseReg(addr);

        reg  = REG_COUNT;
        break;
    }

#endif

    case GT_ARR_ELEM:
        genCodeForTreeSmpOp_GT_ADDR(tree, destReg, bestReg);
        return;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
        NO_WAY("unexpected operator");
    }

    genCodeForTree_DONE(tree, reg);
}


/*****************************************************************************
 *
 *  Generate code for the given tree (if 'destReg' is non-zero, we'll do our
 *  best to compute the value into a register that is in that register set).
 */

void                Compiler::genCodeForTree(GenTreePtr tree,
                                             regMaskTP  destReg,
                                             regMaskTP  bestReg)
{
#ifdef DEBUG
    // if  (verbose) printf("Generating code for tree 0x%x destReg = 0x%x bestReg = 0x%x\n", tree, destReg, bestReg);
    genStressRegs(tree);
#endif

    assert(tree);
    assert(tree->gtOper != GT_STMT);
    assert(tree->IsNodeProperlySized());

    /* 'destReg' of 0 really means 'any' */

    destReg = rsUseIfZero(destReg, RBM_ALL);

    if (destReg != RBM_ALL)
        bestReg = rsUseIfZero(bestReg, destReg);

    /* Is this a floating-point or long operation? */

    switch (tree->TypeGet())
    {
    case TYP_LONG:
#if !   CPU_HAS_FP_SUPPORT
    case TYP_DOUBLE:
#endif
        genCodeForTreeLng(tree, destReg);
        return;

#if     CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
    case TYP_DOUBLE:
        genCodeForTreeFlt(tree, false);
        return;
#endif

#ifdef DEBUG
    case TYP_UINT:
    case TYP_ULONG:
        assert(!"These types are only used as markers in GT_CAST nodes");
#endif
    }

    /* Is the value already in a register? */

    if  (tree->gtFlags & GTF_REG_VAL)
    {
        genCodeForTree_REG_VAR1(tree, rsMaskUsed);
        return;
    }

    /* We better not have a spilled value here */

    assert((tree->gtFlags & GTF_SPILLED) == 0);

    /* Figure out what kind of a node we have */

    unsigned kind = tree->OperKind();

    if  (kind & GTK_CONST)
    {
        /* Handle constant nodes */
        
        genCodeForTreeConst(tree, destReg, bestReg);
    }
    else if (kind & GTK_LEAF)
    {
        /* Handle leaf nodes */

        genCodeForTreeLeaf(tree, destReg, bestReg);
    }
    else if (kind & GTK_SMPOP)
    {
        /* Handle 'simple' unary/binary operators */

        genCodeForTreeSmpOp(tree, destReg, bestReg);
    }
    else
    {
        /* Handle special operators */
        
        genCodeForTreeSpecialOp(tree, destReg, bestReg);
    }
}

/*****************************************************************************
 *
 *  Generate code for all the basic blocks in the function.
 */

void                Compiler::genCodeForBBlist()
{
    BasicBlock *    block;
    BasicBlock *    lblk;  /* previous block */

    unsigned        varNum;
    LclVarDsc   *   varDsc;

    unsigned        savedStkLvl;

#ifdef  DEBUG
    genIntrptibleUse            = true;
    unsigned        stmtNum     = 0;
    unsigned        totalCostEx = 0;
    unsigned        totalCostSz = 0;
#endif

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)
    /* The last IL-offset noted for IP-mapping. We have not generated
       any IP-mapping records yet, so initilize to invalid */

    IL_OFFSET       lastILofs   = BAD_IL_OFFSET;
#endif

    assert(GTFD_NOP_BASH == GTFD_VAR_CSE_REF);

    /* Initialize the spill tracking logic */

    rsSpillBeg();

    /* Initialize the line# tracking logic */

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo)
    {
        siInit();

        compResetScopeLists();
    }
#endif

    /* We need to keep track of the number of temp-refs */

#if TGT_x86
    genTmpAccessCnt = 0;
#endif

    /* If we have any try blocks, we might potentially trash everything */

#if INLINE_NDIRECT
    if  (info.compXcptnsCount || info.compCallUnmanaged)
#else
    if  (info.compXcptnsCount)
#endif
    {
        assert(genFPused);
        rsMaskModf = RBM_ALL & ~RBM_FPBASE;
    }

    /* Initialize the pointer tracking code */

    gcRegPtrSetInit();
    gcVarPtrSetInit();

    /* If any arguments live in registers, mark those regs as such */

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        /* Is this variable a parameter assigned to a register? */

        if  (!varDsc->lvIsParam || !varDsc->lvRegister)
            continue;

        /* Is the argument live on entry to the method? */

        if  (!(genVarIndexToBit(varDsc->lvVarIndex) & fgFirstBB->bbLiveIn))
            continue;

#if CPU_HAS_FP_SUPPORT
        /* Is this a floating-point argument? */

        if (isFloatRegType(varDsc->lvType))
            continue;

        assert(!varTypeIsFloating(varDsc->TypeGet()));
#endif

        /* Mark the register as holding the variable */

        if  (isRegPairType(varDsc->lvType))
        {
            rsTrackRegLclVarLng(varDsc->lvRegNum, varNum, true);

            if  (varDsc->lvOtherReg != REG_STK)
                rsTrackRegLclVarLng(varDsc->lvOtherReg, varNum, false);
        }
        else
        {
            rsTrackRegLclVar(varDsc->lvRegNum, varNum);
        }
    }

    unsigned finallyNesting = 0;

    /*-------------------------------------------------------------------------
     *
     *  Walk the basic blocks and generate code for each one
     *
     */

    for (lblk =     0, block  = fgFirstBB;
                       block != NULL;
         lblk = block, block  = block->bbNext)
    {
        VARSET_TP       liveSet;

        regMaskTP       gcrefRegs = 0;
        regMaskTP       byrefRegs = 0;

#if TGT_x86
        /* Is block a loop entry point? */
        if (0 && (compCodeOpt() == FAST_CODE)
             &&  (lblk != 0)
             &&  (block->bbWeight > lblk->bbWeight)
             &&  ((lblk->bbWeight == 0) ||
                  ((block->bbWeight / lblk->bbWeight) > (BB_LOOP_WEIGHT / 2))))
        {
            /* We try to ensure that x86 I-Cache prefetch does not stall */
            genEmitter->emitLoopAlign(block->bbFallsThrough());
        }
#endif

#ifdef  DEBUG
        if  (dspCode)
            printf("\n      L_M%03u_BB%02u:\n", Compiler::s_compMethodsCount, block->bbNum);
#endif

        /* Does any other block jump to this point ? */

        if  (block->bbFlags & BBF_JMP_TARGET)
        {
            /* Someone may jump here, so trash all regs */

            rsTrackRegClr();

            genFlagsEqualToNone();
        }
        else
        {
            /* No jump, but pointers always need to get trashed for proper GC tracking */

            rsTrackRegClrPtr();
        }

        /* No registers are used or locked on entry to a basic block */

        rsMaskUsed  =
        rsMaskMult  =
        rsMaskLock  = 0;

        /* Figure out which registers hold variables on entry to this block */

        rsMaskVars     = DOUBLE_ALIGN_NEED_EBPFRAME ? RBM_SPBASE|RBM_FPBASE
                                                    : RBM_SPBASE;

        genCodeCurLife = 0;
#if TGT_x86
        genFPregVars   = block->bbLiveIn & optAllFPregVars;
        genFPregCnt    = genCountBits(genFPregVars);
        genFPdeadRegCnt= 0;
#endif

        gcResetForBB();

#if 0
        printf("BB%02u: used regs = %04X , free regs = %04X\n", block->bbNum,
                                                                rsMaskUsed,
                                                                rsRegMaskFree());
#endif

        liveSet = block->bbLiveIn & optAllNonFPvars; genUpdateLife(liveSet);

        /* Don't both with this loop unless we have some live variables here */
        if (liveSet)
        {
            /* Figure out which registers hold pointer variables */

            for (varNum = 0, varDsc = lvaTable;
                 varNum < lvaCount;
                 varNum++  , varDsc++)
            {
                /* Ignore the variable if it's not tracked or not in a reg */

                if  (!varDsc->lvTracked)
                    continue;
                if  (!varDsc->lvRegister)
                    continue;
                if (isFloatRegType(varDsc->lvType))
                    continue;

                /* Get hold of the index and the bitmask for the variable */

                unsigned   varIndex = varDsc->lvVarIndex;
                VARSET_TP  varBit   = genVarIndexToBit(varIndex);

                /* Is this variable live on entry? */

                if  (liveSet & varBit)
                {
                    regNumber  regNum  = varDsc->lvRegNum;
                    regMaskTP  regMask = genRegMask(regNum);

                    if       (varDsc->lvType == TYP_REF)
                        gcrefRegs |= regMask;
                    else if  (varDsc->lvType == TYP_BYREF)
                        byrefRegs |= regMask;

                    /* Mark the register holding the variable as such */

                    if  (isRegPairType(varDsc->lvType))
                    {
                        rsTrackRegLclVarLng(regNum, varNum, true);
                        if  (varDsc->lvOtherReg != REG_STK)
                        {
                            rsTrackRegLclVarLng(varDsc->lvOtherReg, varNum, false);
                            regMask |= genRegMask(varDsc->lvOtherReg);
                        }
                    }
                    else
                    {
                        rsTrackRegLclVar(regNum, varNum);
                    }

                    assert(rsMaskVars & regMask);
                }
            }
        }

        gcPtrArgCnt  = 0;

        /* Make sure we keep track of what pointers are live */

        assert((gcrefRegs & byrefRegs) == 0);
        gcRegGCrefSetCur = gcrefRegs;
        gcRegByrefSetCur = byrefRegs;

        /* The return register is live on entry to catch handlers and
            at the start of "the" return basic block.
         */

        if  (block == genReturnBB && info.compRetType == TYP_REF)
            gcRegGCrefSetCur |= RBM_INTRET;

        /* Blocks with handlerGetsXcptnObj()==true use GT_CATCH_ARG to
           represent the exception object (TYP_REF). We mark
           REG_EXCEPTION_OBJECT as holding a GC object on entry to such a
           block, but we dont mark it as used as we dont know if it is
           actually used or not
           .
           If GT_CATCH_ARG is actually used in the block, it should be the
           first thing evaluated (thanks to GTF_OTHER_SIDEEFF) and so
           REG_EXCEPTION_OBJECT will be marked as used at that time.

           If it is unused, we would have popped it.
           If it is unused in the incoming basic block, it would have been
           spilled to a temp and dead-assignment removal may get rid of
           the assignment depending on whether it is used or not in
           subsequent blocks.
           In either of these 2 cases, it doesnt matter if
           REG_EXCEPTION_OBJECT gets trashed.
         */

        if (block->bbCatchTyp && handlerGetsXcptnObj(block->bbCatchTyp))
            gcRegGCrefSetCur |= RBM_EXCEPTION_OBJECT;

        /* Start a new code output block */

        genEmitter->emitSetHasHandler((block->bbFlags & BBF_HAS_HANDLER) != 0);

        block->bbEmitCookie = NULL;

        if  (block->bbFlags & (BBF_JMP_TARGET|BBF_HAS_LABEL))
        {
            /* Mark a label and update the current set of live GC refs */

            genEmitter->emitAddLabel(&block->bbEmitCookie,
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur);
        }

#if     TGT_x86

        /* Both stacks are always empty on entry to a basic block */

        genStackLevel = 0;
        genFPstkLevel = 0;

#endif

#if TGT_x86

        /* Check for inserted throw blocks and adjust genStackLevel */

        if  (!genFPused && fgIsThrowHlpBlk(block))
        {
            assert(block->bbFlags & BBF_JMP_TARGET);

            genStackLevel = fgThrowHlpBlkStkLevel(block) * sizeof(int);
            genOnStackLevelChanged();

            if  (genStackLevel)
            {
                genEmitter->emitMarkStackLvl(genStackLevel);

                /* @TODO [CONSIDER] [07/10/01] []: We should be able to take out
                   the add instruction below, because the stack level is already
                   marked correctly in the GC info (because of the emitMarkStackLvl
                   call above). */
                
                inst_RV_IV(INS_add, REG_ESP, genStackLevel);
                genStackLevel = 0;
                genOnStackLevelChanged();
            }
        }

        savedStkLvl = genStackLevel;

#endif

        /* Tell everyone which basic block we're working on */

        compCurBB = block;

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0)
            siBeginBlock();

        // BBF_INTERNAL blocks dont correspond to any single IL instruction.
        if (opts.compDbgInfo && (block->bbFlags & BBF_INTERNAL) && block != fgFirstBB)
            genIPmappingAdd(ICorDebugInfo::MappingTypes::NO_MAPPING, true);

        bool    firstMapping = true;
#endif

        /*---------------------------------------------------------------------
         *
         *  Generate code for each statement-tree in the block
         *
         */

        for (GenTreePtr stmt = block->bbTreeList; stmt; stmt = stmt->gtNext)
        {
            assert(stmt->gtOper == GT_STMT);

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)

            /* Do we have a new IL-offset ? */

            const IL_OFFSET stmtOffs = jitGetILoffs(stmt->gtStmtILoffsx);
            assert(stmtOffs <= info.compCodeSize ||
                   stmtOffs == BAD_IL_OFFSET);

            if  (stmtOffs != BAD_IL_OFFSET &&
                 stmtOffs != lastILofs)
            {
                /* Create and append a new IP-mapping entry */

#ifdef DEBUGGING_SUPPORT
                if (opts.compDbgInfo)
                {
                    genIPmappingAdd(stmt->gtStmtILoffsx, firstMapping);
                    firstMapping = false;
                }
#endif

                /* Display the source lines and instrs */
#ifdef DEBUG
                genEmitter->emitRecordLineNo(compLineNumForILoffs(stmtOffs));

                if  (dspCode && dspLines)
                    compDspSrcLinesByILoffs(stmtOffs);
#endif
                lastILofs = stmtOffs;
            }

#endif // DEBUGGING_SUPPORT || DEBUG

#ifdef DEBUG
            assert(stmt->gtStmt.gtStmtLastILoffs <= info.compCodeSize ||
                   stmt->gtStmt.gtStmtLastILoffs == BAD_IL_OFFSET);

            if (dspCode && dspInstrs &&
                stmt->gtStmt.gtStmtLastILoffs != BAD_IL_OFFSET)
            {
                while (genCurDispOffset <= stmt->gtStmt.gtStmtLastILoffs)
                {
                    genCurDispOffset +=
                        dumpSingleInstr ((unsigned char*)info.compCode,
                                            genCurDispOffset, ">    ");
                }
            }
#endif

            /* Get hold of the statement tree */
            GenTreePtr  tree = stmt->gtStmt.gtStmtExpr;

#ifdef  DEBUG
            stmtNum++;
            if (verbose)
            {
                printf("\nGenerating BB%02u, stmt %d\n", block->bbNum, stmtNum);
                gtDispTree(opts.compDbgInfo ? stmt : tree);
                printf("\n");
            }
            totalCostEx += (stmt->gtCostEx * block->bbWeight);
            totalCostSz +=  stmt->gtCostSz;

            compCurStmt = NULL;
#endif
            switch (tree->gtOper)
            {
            case GT_CALL:
                genCodeForCall (tree, false);
                genUpdateLife  (tree);
                gcMarkRegSetNpt(RBM_INTRET);
                break;

            case GT_JTRUE:
                compCurStmt = stmt;
                goto GENCODE;

            case GT_IND:

                if  ((tree->gtFlags & GTF_IND_RNGCHK ) &&
                     (tree->gtFlags & GTF_STMT_CMPADD))
                {
                    regMaskTP   addrReg;

                    /* A range-checked array expression whose value isn't used */

                    if  (genMakeIndAddrMode(tree->gtInd.gtIndOp1,
                                            tree,
                                            false,
                                            RBM_ALL,
                                            FREE_REG,
                                            &addrReg))
                    {
                        genUpdateLife(tree);
                        gcMarkRegSetNpt(addrReg);
                        break;
                    }
                }

                // Fall through ....

            default:

GENCODE:
                /* Generate code for the tree */

                genCodeForTree(tree, 0);
            }

            rsSpillChk();

            /* The value of the tree isn't used, unless it's a return stmt */

            if  (tree->gtOper != GT_RETURN)
                gcMarkRegPtrVal(tree);

#if     TGT_x86

            /* Did the expression leave a value on the FP stack? */

            if  (genFPstkLevel)
            {
                assert(genFPstkLevel == 1);
                inst_FS(INS_fstp, 0);
                genFPstkLevel = 0;
            }

#endif

            /* Make sure we didn't screw up pointer register tracking */

#ifdef DEBUG
#if     TRACK_GC_REFS

            regMaskTP ptrRegs       = (gcRegGCrefSetCur|gcRegByrefSetCur);
            regMaskTP nonVarPtrRegs = ptrRegs & ~rsMaskVars;

            // If return is a gctype, clear it.  Note that if a common
            // epilog is generated (genReturnBB) it has a void return
            // even though we might return a ref.  We can't use the compRetType
            // as the determiner because something we are tracking as a byref
            // might be used as a return value of a int function (which is legal)
            if  (tree->gtOper == GT_RETURN && 
                (varTypeIsGC(info.compRetType) ||
                    (tree->gtOp.gtOp1 != 0 && varTypeIsGC(tree->gtOp.gtOp1->TypeGet()))))
                nonVarPtrRegs &= ~RBM_INTRET;

            if  (nonVarPtrRegs)
            {
                printf("Regset after  tree=%08X BB=%08X gcr=[", tree, block);
                gcRegPtrSetDisp(gcRegGCrefSetCur & ~rsMaskVars, false);
                printf("], byr=[");
                gcRegPtrSetDisp(gcRegByrefSetCur & ~rsMaskVars, false);
                printf("], regVars = [");
                gcRegPtrSetDisp(rsMaskVars, false);
                printf("]\n");
            }

            assert(nonVarPtrRegs == 0);

#endif
#endif

#if     TGT_x86

            assert(stmt->gtOper == GT_STMT);

            if  (!opts.compMinOptim && stmt->gtStmtFPrvcOut != genFPregCnt)
            {

#ifdef  DEBUG
                /* For some kinds of blocks, we would already have issued the
                   branching instruction (ret, jCC, call JIT_Throw(), etc) in
                   the genCodeForTree() above if this was the last stmt in
                   the block. So it is too late to do the pops now. */

                if  (stmt->gtNext == NULL)
                {
                    switch (block->bbJumpKind)
                    {
                    case BBJ_RET:
                    case BBJ_COND:
                    case BBJ_THROW:
                    case BBJ_SWITCH:
                        assert(!"FP regvar left unpopped on stack on path from block");
                    }
                }
#endif

                // At the end of a isBBF_BB_COLON() block, we may need to
                // pop off any enregistered floating-point variables that
                // are dying due to having their last use in this block.
                //
                // However we have already computed a result (input for the
                // GT_BB_QMARK) that we must leave on the top of the FP stack.
                // Thus we must take care to leave the top of the floating point
                // stack undisturbed, while we pop the dying enregistered
                // floating point variables.

                bool saveTOS = false;

                if (tree->gtOper == GT_BB_COLON  &&
                    varTypeIsFloating(tree->TypeGet()))
                {
                    assert(isBBF_BB_COLON(block->bbFlags));
                    // We expect that GT_BB_COLON is the last statement
                    assert(tree->gtNext == 0);
                    saveTOS = true;
                }

                genChkFPregVarDeath(stmt, saveTOS);


                assert(stmt->gtStmtFPrvcOut == genFPregCnt);              
            }

#endif  // end TGT_x86

#ifdef DEBUGGING_SUPPORT
            if (opts.compDbgCode && stmtOffs != BAD_IL_OFFSET)
                genEnsureCodeEmitted(stmt->gtStmtILoffsx);
#endif

        } //-------- END-FOR each statement-tree of the current block ---------

#ifdef  DEBUGGING_SUPPORT

        if (opts.compScopeInfo && info.compLocalVarsCount>0)
        {
            siEndBlock();

            /* Is this the last block, and are there any open scopes left ? */

            if (block->bbNext == NULL && siOpenScopeList.scNext)
            {
                /* This assert no longer holds, because we may insert a throw
                   block to demarcate the end of a try or finally region when they
                   are at the end of the method.  It would be nice if we could fix
                   our code so that this throw block will no longer be necessary. */

                //assert(block->bbCodeOffs + block->bbCodeSize != info.compCodeSize);

                siCloseAllOpenScopes();
            }
        }

#endif

#if     TGT_x86
        genStackLevel -= savedStkLvl;
        genOnStackLevelChanged();
#endif

        gcMarkRegSetNpt(gcrefRegs|byrefRegs);

        if  (genCodeCurLife != block->bbLiveOut)
            genChangeLife(block->bbLiveOut DEBUGARG(NULL));

        /* Both stacks should always be empty on exit from a basic block */

#if     TGT_x86
        assert(genStackLevel == 0);
        assert(genFPstkLevel == 0);
#endif

        assert(genFullPtrRegMap == false || gcPtrArgCnt == 0);

        /* Do we need to generate a jump or return? */

        switch (block->bbJumpKind)
        {
        case BBJ_COND:
            break;

        case BBJ_ALWAYS:
#if TGT_x86
            inst_JMP(EJ_jmp, block->bbJumpDest);
#else
            genEmitter->emitIns_J(INS_bra, false, false, block->bbJumpDest);
#endif
            break;

        case BBJ_RETURN:
#if TGT_RISC
            genFnEpilog();
#endif
            genExitCode(block->bbNext == 0);
            break;

        case BBJ_SWITCH:
            break;

        case BBJ_THROW:

            /*
                If the subsequent block is throw-block, insert
                a NOP in order to separate both blocks by an instruction.
             */

            if  (!genFPused && block->bbNext
                            && fgIsThrowHlpBlk(block->bbNext))
            {
#if TGT_x86
                instGen(INS_int3); // This should never get executed
#else
                genEmitter->emitIns(INS_nop);
#endif
            }

            break;

        case BBJ_CALL:

            /* If we are about to invoke a finally locally from a try block,
               we have to set the hidden slot corresponding to the finally's
               nesting level. When invoked in response to an exception, the
               EE usually does it.

               We must have : BBJ_CALL followed by a BBJ_ALWAYS. 

               This code depends on this order not being messed up. 
               We will emit :
                    mov [ebp-(n+1)],0
                    mov [ebp-  n  ],0xFC
                    push &step
                    jmp  finallyBlock

              step: mov [ebp-  n  ],0
                    jmp leaveTarget
              leaveTarget:
             */

            assert(genFPused);
            assert((block->bbNext->bbJumpKind == BBJ_ALWAYS) ||
                   (block->bbFlags&BBF_RETLESS_CALL));

            // Get the nesting level which contains the finally
            fgHndNstFromBBnum(block->bbNum, &finallyNesting);

            unsigned shadowSPoffs;
            shadowSPoffs = lvaShadowSPfirstOffs + finallyNesting * sizeof(void*);

#if TGT_x86
            genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0, SR_EBP,
                                      SR_NA, -(shadowSPoffs+sizeof(void*)));
            // The ordering has to be maintained for fully-intr code
            // as the list of shadow slots has to be 0 terminated.
            if (genInterruptible && opts.compSchedCode)
                genEmitter->emitIns_SchedBoundary();
            genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0xFC, SR_EBP,
                                      SR_NA, -shadowSPoffs);

            // Now push the address of where the finally funclet should
            // return to directly.
            if ( !(block->bbFlags&BBF_RETLESS_CALL) )
            {
                genEmitter->emitIns_J(INS_push_hide, false, false, block->bbNext->bbJumpDest);
            }
            else
            {
                // EE expects a DWORD, so we give him 0
                inst_IV(INS_push_hide, 0);
            }

            // Jump to the finally BB
            inst_JMP(EJ_jmp, block->bbJumpDest);

#else
            assert(!"NYI for risc");
            genEmitter->emitIns_J(INS_bsr, false, false, block->bbJumpDest);
#endif

            // The BBJ_ALWAYS is used just because the BBJ_CALL cant point to
            // the jump target using bbJumpDest - that is already used to point
            // to the finally block. So now, just skip the BBJ_ALWAYS unless the
            // block is RETLESS
            if ( !(block->bbFlags&BBF_RETLESS_CALL) )
            {
                lblk = block; block = block->bbNext;
            }
            break;

        default:
            break;
        }

#ifdef  DEBUG
        compCurBB = 0;
#endif

    } //------------------ END-FOR each block of the method -------------------

    // If the last block before the epilog is a BBJ_THROW then insert 
    // a nop or int3 instruction to seperate it from the epilog and to
    // properly end the codegen (by defining labels) since BBJ_THROW blocks
    // can also indicate an empty unreachable block 
    //
    assert(lblk);
    if (lblk->bbJumpKind == BBJ_THROW)
    {
#if TGT_x86
        instGen(INS_int3);              // This will never get executed
#else
        genEmitter->emitIns(INS_nop);   // This will never get executed
#endif
    }

    /* Epilog block follows and is not inside a try region */
    genEmitter->emitSetHasHandler(false);

    /* Nothing is live at this point */

    genUpdateLife((VARSET_TP)0);

    /* Finalize the spill  tracking logic */

    rsSpillEnd();

    /* Finalize the temp   tracking logic */

    tmpEnd();
#ifdef  DEBUG
    if (verbose)
    {
        printf("# ");
        printf("totalCostEx = %6d, totalCostSz = %5d ", 
               totalCostEx, totalCostSz);
        printf("%s\n", info.compFullName);
    }
#endif

}

/*****************************************************************************
 *
 *  Generate code for a long operation.
 *  needReg is a recommendation of which registers to use for the tree.
 *  For partially enregistered longs, the tree will be marked as GTF_REG_VAL
 *    without loading the stack part into a register. Note that only leaf
 *    nodes (or if gtEffectiveVal() == leaf node) may be marked as partially
 *    enregistered so that we can know the memory location of the other half.
 */

void                Compiler::genCodeForTreeLng(GenTreePtr tree,
                                                regMaskTP  needReg)
{
    genTreeOps      oper;
    unsigned        kind;

    regPairNo       regPair;

#ifdef DEBUG
    regPair = (regPairNo)0xFEEFFAAF;  // to detect uninitialized use
#endif

    assert(tree);
    assert(tree->gtOper != GT_STMT);
    assert(genActualType(tree->gtType) == TYP_LONG);

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    if  (tree->gtFlags & GTF_REG_VAL)
    {
REG_VAR_LONG:
        regPair   = tree->gtRegPair;

        gcMarkRegSetNpt(genRegPairMask(regPair));

        goto DONE;
    }

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        __int64         lval;

        /* Pick a register pair for the value */

        regPair  = rsPickRegPair(needReg);

        /* Load the value into the registers */

#if !   CPU_HAS_FP_SUPPORT
        if  (oper == GT_CNS_DBL)
        {
            assert(sizeof(__int64) == sizeof(double));

            assert(sizeof(tree->gtLngCon.gtLconVal) ==
                   sizeof(tree->gtDblCon.gtDconVal));

            lval = *(__int64*)(&tree->gtDblCon.gtDconVal);
        }
        else
#endif
        {
            assert(oper == GT_CNS_LNG);

            lval = tree->gtLngCon.gtLconVal;
        }

        genSetRegToIcon(genRegPairLo(regPair), int(lval      ));
        genSetRegToIcon(genRegPairHi(regPair), int(lval >> 32));
        goto DONE;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:

#if REDUNDANT_LOAD

            /*  This case has to consider the case in which an int64 LCL_VAR
             *  may both be enregistered and also have a cached copy of itself
             *  in a different set of registers.
             *  We want to return the registers that have the most in common
             *  with the needReg mask
             */

            /*  Does the var have a copy of itself in the cached registers?
             *  And are these cached registers both free?
             *  If so use these registers if they match any needReg.
             */

            regPair = rsLclIsInRegPair(tree->gtLclVar.gtLclNum);

            if ( (                      regPair       != REG_PAIR_NONE)  &&
                 (        (rsRegMaskFree() & needReg) == needReg      )  &&
                 ((genRegPairMask(regPair) & needReg) != RBM_NONE     ))
            {
                goto DONE;
            }

            /*  Does the variable live in a register?
             *  If so use these registers.
             */
            if  (genMarkLclVar(tree))
                goto REG_VAR_LONG;

            /*  If tree is not an enregistered variable then
             *  be sure to use any cached register that contain
             *  a copy of this local variable
             */
            if (regPair != REG_PAIR_NONE)
            {
                goto DONE;
            }
#endif
            goto MEM_LEAF;

        case GT_LCL_FLD:

            // We only use GT_LCL_FLD for lvAddrTaken vars, so we dont have
            // to worry about it being enregistered.
            assert(lvaTable[tree->gtLclFld.gtLclNum].lvRegister == 0);
            goto MEM_LEAF;

        case GT_CLS_VAR:
        MEM_LEAF:

            /* Pick a register pair for the value */

            regPair  = rsPickRegPair(needReg);

            /* Load the value into the registers */

            rsTrackRegTrash(genRegPairLo(regPair));
            rsTrackRegTrash(genRegPairHi(regPair));

            inst_RV_TT(INS_mov, genRegPairLo(regPair), tree, 0);
            inst_RV_TT(INS_mov, genRegPairHi(regPair), tree, 4);

            goto DONE;

#if TGT_x86

        case GT_BB_QMARK:

            /* The "_?" value is always in EDX:EAX */

            regPair = REG_PAIR_EAXEDX;

            /* @TODO [CONSIDER] [04/16/01] []: Don't always load the value into EDX:EAX! */

            goto DONE;
#endif

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected leaf");
        }
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        regMaskTP       addrReg;

        instruction     insLo;
        instruction     insHi;

        regNumber       regLo;
        regNumber       regHi;

        int             helper;

        GenTreePtr      op1  = tree->gtOp.gtOp1;
        GenTreePtr      op2  = tree->gtGetOp2();

        switch (oper)
        {
            bool            doLo;
            bool            doHi;

        case GT_ASG:

            /* Is the target a local ? */

            if  (op1->gtOper == GT_LCL_VAR)
            {
                unsigned    varNum  = op1->gtLclVar.gtLclNum;
                unsigned    varIL   = op1->gtLclVar.gtLclILoffs;
                LclVarDsc * varDsc;

                assert(varNum < lvaCount);
                varDsc = lvaTable + varNum;

                // No dead stores
                assert(!varDsc->lvTracked ||
                       (tree->gtLiveSet & genVarIndexToBit(varDsc->lvVarIndex)));

#ifdef DEBUGGING_SUPPORT

                /* For non-debuggable code, every definition of a lcl-var has
                 * to be checked to see if we need to open a new scope for it.
                 */
                if (opts.compScopeInfo && !opts.compDbgCode && info.compLocalVarsCount>0)
                    siCheckVarScope (varNum, varIL);
#endif

                /* Has the variable been assigned to a register (pair) ? */

                if  (genMarkLclVar(op1))
                {
                    assert(op1->gtFlags & GTF_REG_VAL);
                    regPair = op1->gtRegPair;
                    regLo   = genRegPairLo(regPair);
                    regHi   = genRegPairHi(regPair);

#if     TGT_x86
                    /* Is the value being assigned a constant? */                    

                    if  (op2->gtOper == GT_CNS_LNG)
                    {
                        /* Move the value into the target */

                        genMakeRegPairAvailable(regPair);

                        inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal      ), 0);
                        inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal >> 32), 4);

                        goto DONE_ASSG_REGS;
                    }

                    /* Is the value being assigned actually a 'pop' ? */

                    if  (op2->gtOper == GT_POP)
                    {
                        assert(op1->gtOper == GT_LCL_VAR);

                        /* Generate 'pop [lclVar+0] ; pop [lclVar+4]' */

                        genStackLevel -= sizeof(void*);
                        inst_TT(INS_pop, op1, 0);
                        genStackLevel += sizeof(void*);

                        genSinglePop();

                        rsTrackRegTrash(regLo);

                        genStackLevel -= sizeof(void*);
                        inst_TT(INS_pop, op1, 4);
                        genStackLevel += sizeof(void*);

                        genSinglePop();

                        if  (regHi != REG_STK)
                            rsTrackRegTrash(regHi);

                        goto DONE_ASSG_REGS;
                    }
#endif
                    /* Compute the RHS into desired register pair */

                    if  (regHi != REG_STK)
                    {
                        genComputeRegPair(op2, regPair, RBM_NONE, KEEP_REG);
                        assert(op2->gtFlags & GTF_REG_VAL);
                        assert(op2->gtRegPair == regPair);
                    }
                    else
                    {
                        regPairNo curPair;
                        regNumber curLo;
                        regNumber curHi;

                        genComputeRegPair(op2, REG_PAIR_NONE, RBM_NONE, KEEP_REG);

                        assert(op2->gtFlags & GTF_REG_VAL);

                        curPair = op2->gtRegPair;
                        curLo   = genRegPairLo(curPair);
                        curHi   = genRegPairHi(curPair);

                        /* move high first, target is on stack */
#if     TGT_x86
                        inst_TT_RV(INS_mov, op1, curHi, 4);

                        if  (regLo != curLo)
                        {
                            if ((rsMaskUsed & genRegMask(regLo)) && (regLo != curHi))
                                rsSpillReg(regLo);
                            inst_RV_RV(INS_mov, regLo, curLo, TYP_LONG);
                            rsTrackRegCopy(regLo, curLo);
                        }
#elif   TGT_SH3
                        assert(!"need SH-3 code");

#else
#error  Unexpected target
#endif
                    }

                    genReleaseRegPair(op2);
                    goto DONE_ASSG_REGS;
                }
            }

#if     TGT_x86

            /* Is the value being assigned a constant? */

            if  (op2->gtOper == GT_CNS_LNG)
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, FREE_REG);

                /* Move the value into the target */

                inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal      ), 0);
                inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal >> 32), 4);

                genDoneAddressable(op1, addrReg, FREE_REG);

                return;
            }

            /* Is the value being assigned actually a 'pop' ? */

            if  (op2->gtOper == GT_POP)
            {
                assert(op1->gtOper == GT_LCL_VAR);

                /* Generate 'pop [lclVar+0] ; pop [lclVar+4]' */

                genStackLevel -= sizeof(void*);
                inst_TT(INS_pop, op1, 0);
                genStackLevel += sizeof(void*);

                genSinglePop();

                genStackLevel -= sizeof(void*);
                inst_TT(INS_pop, op1, 4);
                genStackLevel += sizeof(void*);

                genSinglePop();

                return;
            }

#endif
#if 0
            /* Catch a case where can avoid generating op reg, mem. Better pairing
             * from
             *     mov regHi, mem
             *     op  regHi, reg
             *
             * To avoid problems with order of evaluation, only do this if op2 is
             * a non-enregistered local variable
             */

            if (GenTree::OperIsCommutative(oper) &&
                op1->gtOper == GT_LCL_VAR &&
                op2->gtOper == GT_LCL_VAR)
            {
                regPair = rsLclIsInRegPair(op2->gtLclVar.gtLclNum);

                /* Is op2 a non-enregistered local variable? */
                if (regPair == REG_PAIR_NONE)
                {
                    regPair = rsLclIsInRegPair(op1->gtLclVar.gtLclNum);

                    /* Is op1 an enregistered local variable? */
                    if (regPair != REG_PAIR_NONE)
                    {
                        /* Swap the operands */
                        GenTreePtr op = op1;
                        op1 = op2;
                        op2 = op;
                    }
                }
            }
#endif

            /* Eliminate worthless assignment "lcl = lcl" */

            if  (op2->gtOper == GT_LCL_VAR &&
                 op1->gtOper == GT_LCL_VAR && op2->gtLclVar.gtLclNum ==
                                              op1->gtLclVar.gtLclNum)
            {
                return;
            }

#if     TGT_x86

            if (op2->gtOper  == GT_CAST &&
                TYP_ULONG == op2->gtCast.gtCastType &&
                op2->gtCast.gtCastOp->gtType <= TYP_INT &&
                // op1,op2 need to be materialized in the correct order.
                // @TODO [CONSIDER] [04/16/01] []: adding code for the non-reverse case too.
                (tree->gtFlags & GTF_REVERSE_OPS))
            {
                /* Generate the small RHS into a register pair */

                GenTreePtr smallOpr = op2->gtOp.gtOp1;

                genComputeReg(smallOpr, 0, ANY_REG, KEEP_REG);

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, KEEP_REG, true);

                /* Make sure everything is still addressable */

                genRecoverReg(smallOpr, 0, KEEP_REG);
                assert(smallOpr->gtFlags & GTF_REG_VAL);
                regHi   = smallOpr->gtRegNum;
                addrReg = genKeepAddressable(op1, addrReg, genRegMask(regHi));

                // conv.ovf.u8 could overflow if the original number was negative
                if (op2->gtOverflow())
                {
                    assert((op2->gtFlags & GTF_UNSIGNED) == 0); // conv.ovf.u8.un should be bashed to conv.u8.un
                    inst_RV_RV(INS_test, regHi, regHi);         // set flags
                    genJumpToThrowHlpBlk(EJ_jl, ACK_OVERFLOW);
                }
                
                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, regHi, 0);
                inst_TT_IV(INS_mov, op1, 0,     4); // Store 0 in hi-word
                
                /* Free up anything that was tied up by either side */

                genDoneAddressable(op1, addrReg, KEEP_REG);
                genReleaseReg     (smallOpr);

#if REDUNDANT_LOAD
                if (op1->gtOper == GT_LCL_VAR)
                {
                    /* clear this local from reg table */
                    rsTrashLclLong(op1->gtLclVar.gtLclNum);

                    /* mark RHS registers as containing the local var */
                    rsTrackRegLclVarLng(regHi, op1->gtLclVar.gtLclNum, true);
                }
                else
                {
                    rsTrashAliasedValues(op1);
                }
#endif
                return;
            }

#endif

            /* Is the LHS more complex than the RHS? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Generate the RHS into a register pair */

                genComputeRegPair(op2, REG_PAIR_NONE, op1->gtUsedRegs, KEEP_REG);
                assert(op2->gtFlags & GTF_REG_VAL);

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, KEEP_REG);

                /* Make sure the RHS register hasn't been spilled */

                genRecoverRegPair(op2, REG_PAIR_NONE, KEEP_REG);
            }
            else
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, RBM_ALL & ~op2->gtRsvdRegs, KEEP_REG, true);

                /* Generate the RHS into a register pair */

                genComputeRegPair(op2, REG_PAIR_NONE, RBM_NONE, KEEP_REG, false);
            }

            /* Lock 'op2' and make sure 'op1' is still addressable */

            assert(op2->gtFlags & GTF_REG_VAL);
            regPair = op2->gtRegPair;

            addrReg = genKeepAddressable(op1, addrReg, genRegPairMask(regPair));

            /* Move the value into the target */

            inst_TT_RV(INS_mov, op1, genRegPairLo(regPair), 0);
            inst_TT_RV(INS_mov, op1, genRegPairHi(regPair), 4);

            /* Free up anything that was tied up by either side */

            genDoneAddressable(op1, addrReg, KEEP_REG);
            genReleaseRegPair(op2);

        DONE_ASSG_REGS:

#if REDUNDANT_LOAD

            if (op1->gtOper == GT_LCL_VAR)
            {
                /* Clear this local from reg table */

                rsTrashLclLong(op1->gtLclVar.gtLclNum);

                if ((op2->gtFlags & GTF_REG_VAL) &&
                    /* constant has precedence over local */
//                    rsRegValues[op2->gtRegNum].rvdKind != RV_INT_CNS &&
                    tree->gtOper == GT_ASG)
                {
                    regNumber regNo;

                    /* mark RHS registers as containing the local var */

                    regNo = genRegPairLo(op2->gtRegPair);
                    if  (regNo != REG_STK)
                        rsTrackRegLclVarLng(regNo, op1->gtLclVar.gtLclNum, true);

                    regNo = genRegPairHi(op2->gtRegPair);
                    if  (regNo != REG_STK)
                    {
                        /* For partially enregistered longs, we might have
                           stomped on op2's hiReg */
                        if (!(op1->gtFlags & GTF_REG_VAL) ||
                            regNo != genRegPairLo(op1->gtRegPair))
                        {
                            rsTrackRegLclVarLng(regNo, op1->gtLclVar.gtLclNum, false);
                        }
                    }
                }
            }
            else
            {
                rsTrashAliasedValues(op1);
            }

#endif

            genUpdateLife(tree);

            return;

#if     TGT_x86

        case GT_SUB: insLo = INS_sub; insHi = INS_sbb; goto BINOP_OVF;
        case GT_ADD: insLo = INS_add; insHi = INS_adc; goto BINOP_OVF;

            bool ovfl;

        BINOP_OVF:
            ovfl = tree->gtOverflow();
            goto _BINOP;

        case GT_AND: insLo =          insHi = INS_and; goto BINOP;
        case GT_OR : insLo =          insHi = INS_or ; goto BINOP;
        case GT_XOR: insLo =          insHi = INS_xor; goto BINOP;

        BINOP: ovfl = false; goto _BINOP;

       _BINOP:

            /* The following makes an assumption about gtSetEvalOrder(this) */

            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

            /* Special case: check for "(long(intval) << 32) | longval" */

            if  (oper == GT_OR && op1->gtOper == GT_LSH)
            {
                GenTreePtr      lshLHS = op1->gtOp.gtOp1;
                GenTreePtr      lshRHS = op1->gtOp.gtOp2;

                if  (lshLHS->gtOper             == GT_CAST    &&
                     lshRHS->gtOper             == GT_CNS_INT &&
                     lshRHS->gtIntCon.gtIconVal == 32         &&
                     genTypeSize(TYP_INT)       == genTypeSize(lshLHS->gtCast.gtCastOp->gtType))
                {

                    /* Throw away the cast of the shift operand. */

                    op1 = lshLHS->gtCast.gtCastOp;

                    /* Special case: check op2 for "ulong(intval)" */
                    if ((op2->gtOper            == GT_CAST) &&
                        (op2->gtCast.gtCastType == TYP_ULONG) &&
                        genTypeSize(TYP_INT)    == genTypeSize(op2->gtCast.gtCastOp->gtType))
                    {
                        /* Throw away the cast of the second operand. */

                        op2 = op2->gtCast.gtCastOp;
                        goto SIMPLE_OR_LONG;
                    }
                    /* Special case: check op2 for "long(intval) & 0xFFFFFFFF" */
                    else if  (op2->gtOper == GT_AND)
                    {
                        GenTreePtr      andLHS = op2->gtOp.gtOp1;
                        GenTreePtr      andRHS = op2->gtOp.gtOp2;

                        if  (andLHS->gtOper             == GT_CAST            &&
                             andRHS->gtOper             == GT_CNS_LNG         &&
                             andRHS->gtLngCon.gtLconVal == 0x00000000FFFFFFFF &&
                             genTypeSize(TYP_INT)       == genTypeSize(andLHS->gtCast.gtCastOp->gtType))
                        {
                            /* Throw away the cast of the second operand. */

                            op2 = andLHS->gtCast.gtCastOp;

SIMPLE_OR_LONG:                            
                            // Load the high DWORD, ie. op1

                            genCodeForTree(op1, needReg & ~op2->gtRsvdRegs);

                            assert(op1->gtFlags & GTF_REG_VAL);
                            regHi = op1->gtRegNum;
                            rsMarkRegUsed(op1);

                            // Load the low DWORD, ie. op2

                            genCodeForTree(op2, needReg & ~genRegMask(regHi));

                            assert(op2->gtFlags & GTF_REG_VAL);
                            regLo = op2->gtRegNum;

                            /* Make sure regHi is still around. Also, force
                               regLo to be excluded in case regLo==regHi */

                            genRecoverReg(op1, ~genRegMask(regLo), FREE_REG);
                            regHi = op1->gtRegNum;

                            regPair = gen2regs2pair(regLo, regHi);
                            goto DONE;
                        }
                    }

                    /*  Generate the following sequence:
                           Prepare op1 (discarding shift)
                           Compute op2 into some regpair
                           OR regpairhi, op1
                     */

                    /* First, make op1 addressable */

                    /* tempReg must avoid both needReg and op2->RsvdRegs */
                    regMaskTP tempReg = RBM_ALL & ~needReg & ~op2->gtRsvdRegs;

                    addrReg = genMakeAddressable(op1, tempReg, KEEP_REG);

                    genCompIntoFreeRegPair(op2, RBM_NONE, KEEP_REG);

                    assert(op2->gtFlags & GTF_REG_VAL);
                    regPair  = op2->gtRegPair;
                    regHi    = genRegPairHi(regPair);

                    /* The operand might have interfered with the address */

                    addrReg = genKeepAddressable(op1, addrReg, genRegPairMask(regPair));

                    /* Now compute the result */

                    inst_RV_TT(insHi, regHi, op1, 0);

                    rsTrackRegTrash(regHi);

                    /* Free up anything that was tied up by the LHS */

                    genDoneAddressable(op1, addrReg, KEEP_REG);

                    /* The result is where the second operand is sitting */

                    genRecoverRegPair(op2, REG_PAIR_NONE, FREE_REG);

                    regPair = op2->gtRegPair;
                    goto DONE;
                }
            }

            /* Special case: check for "longval | (long(intval) << 32)" */

            if  (oper == GT_OR && op2->gtOper == GT_LSH)
            {
                GenTreePtr      lshLHS = op2->gtOp.gtOp1;
                GenTreePtr      lshRHS = op2->gtOp.gtOp2;

                if  (lshLHS->gtOper             == GT_CAST    &&
                     lshRHS->gtOper             == GT_CNS_INT &&
                     lshRHS->gtIntCon.gtIconVal == 32         &&
                     genTypeSize(TYP_INT)       == genTypeSize(lshLHS->gtCast.gtCastOp->gtType))

                {
                    /* We throw away the cast of the shift operand. */

                    op2 = lshLHS->gtCast.gtCastOp;

                   /* Special case: check op1 for "long(intval) & 0xFFFFFFFF" */

                    if  (op1->gtOper == GT_AND)
                    {
                        GenTreePtr      andLHS = op1->gtOp.gtOp1;
                        GenTreePtr      andRHS = op1->gtOp.gtOp2;

                        if  (andLHS->gtOper             == GT_CAST            &&
                             andRHS->gtOper             == GT_CNS_LNG         &&
                             andRHS->gtLngCon.gtLconVal == 0x00000000FFFFFFFF &&
                             genTypeSize(TYP_INT)       == genTypeSize(andLHS->gtCast.gtCastOp->gtType))
                        {
                            /* Throw away the cast of the first operand. */

                            op1 = andLHS->gtCast.gtCastOp;

                            // Load the low DWORD, ie. op1

                            genCodeForTree(op1, needReg & ~op2->gtRsvdRegs);

                            assert(op1->gtFlags & GTF_REG_VAL);
                            regLo = op1->gtRegNum;
                            rsMarkRegUsed(op1);

                            // Load the high DWORD, ie. op2

                            genCodeForTree(op2, needReg & ~genRegMask(regLo));

                            assert(op2->gtFlags & GTF_REG_VAL);
                            regHi = op2->gtRegNum;

                            /* Make sure regLo is still around. Also, force
                               regHi to be excluded in case regLo==regHi */

                            genRecoverReg(op1, ~genRegMask(regHi), FREE_REG);
                            regLo = op1->gtRegNum;

                            regPair = gen2regs2pair(regLo, regHi);
                            goto DONE;
                        }
                    }

                    /*  Generate the following sequence:
                          Compute op1 into some regpair
                          Make op2 (ignoring shift) addressable
                          OR regPairHi, op2
                     */

                    // First, generate the first operand into some register

                    genCompIntoFreeRegPair(op1, op2->gtRsvdRegs, KEEP_REG);
                    assert(op1->gtFlags & GTF_REG_VAL);


                    /* Make the second operand addressable */

                    addrReg = genMakeAddressable(op2, needReg, KEEP_REG);

                    /* Make sure the result is in a free register pair */

                    genRecoverRegPair(op1, REG_PAIR_NONE, KEEP_REG);
                    regPair  = op1->gtRegPair;
                    regHi    = genRegPairHi(regPair);

                    /* The operand might have interfered with the address */

                    addrReg = genKeepAddressable(op2, addrReg, genRegPairMask(regPair));

                    /* Compute the new value */

                    inst_RV_TT(insHi, regHi, op2, 0);

                    /* The value in the high register has been trashed */

                    rsTrackRegTrash(regHi);

                    goto DONE_OR;
                }
            }

            /* Generate the first operand into some register */

            genCompIntoFreeRegPair(op1, op2->gtRsvdRegs, KEEP_REG);
            assert(op1->gtFlags & GTF_REG_VAL);

            /* Make the second operand addressable */

            addrReg = genMakeAddressable(op2, needReg, KEEP_REG);

            // UNDONE: If 'op1' got spilled and 'op2' happens to be
            // UNDONE: in a register, and we have add/mul/and/or/xor,
            // UNDONE: reverse the operands since we can perform the
            // UNDONE: operation directly with the spill temp, e.g.
            // UNDONE: 'add regHi, [temp]'.

            /* Make sure the result is in a free register pair */

            genRecoverRegPair(op1, REG_PAIR_NONE, KEEP_REG);
            regPair  = op1->gtRegPair;

            regLo    = genRegPairLo(regPair);
            regHi    = genRegPairHi(regPair);

            /* The operand might have interfered with the address */

            addrReg = genKeepAddressable(op2, addrReg, genRegPairMask(regPair));

            /* The value in the register pair is about to be trashed */

            rsTrackRegTrash(regLo);
            rsTrackRegTrash(regHi);

            /* Compute the new value */

            doLo =
            doHi = true;

            if  (op2->gtOper == GT_CNS_LNG)
            {
                __int64     icon = op2->gtLngCon.gtLconVal;

                /* Check for "(op1 AND -1)" and "(op1 [X]OR 0)" */

                switch (oper)
                {
                case GT_AND:
                    if  ((int)(icon      ) == -1) doLo = false;
                    if  ((int)(icon >> 32) == -1) doHi = false;

                    if  (!(icon & 0x00000000FFFFFFFF))
                    {
                        genSetRegToIcon(regLo, 0);
                        doLo = false;
                    }

                    if  (!(icon & 0xFFFFFFFF00000000))
                    {
                        /* Just to always set low first*/

                        if  (doLo)
                        {
                            inst_RV_TT(insLo, regLo, op2, 0);
                            doLo = false;
                        }
                        genSetRegToIcon(regHi, 0);
                        doHi = false;
                    }

                    break;

                case GT_OR:
                case GT_XOR:
                    if  (!(icon & 0x00000000FFFFFFFF)) doLo = false;
                    if  (!(icon & 0xFFFFFFFF00000000)) doHi = false;
                    break;
                }
            }

            if (doLo) inst_RV_TT(insLo, regLo, op2, 0);
            if (doHi) inst_RV_TT(insHi, regHi, op2, 4);

        DONE_OR:

            /* Free up anything that was tied up by the LHS */

            genDoneAddressable(op2, addrReg, KEEP_REG);

            /* The result is where the first operand is sitting */

            genRecoverRegPair(op1, REG_PAIR_NONE, FREE_REG);

            regPair = op1->gtRegPair;

            if (ovfl)
                genCheckOverflow(tree);

            goto DONE;

#if LONG_MATH_REGPARAM

        case GT_MUL:    if (tree->gtOverflow())
                        {
                            if (tree->gtFlags & GTF_UNSIGNED)
                                helper = CORINFO_HELP_ULMUL_OVF; goto MATH;
                            else
                                helper = CORINFO_HELP_LMUL_OVF;  goto MATH;
                        }
                        else
                        {
                            helper = CORINFO_HELP_LMUL;          goto MATH;
                        }

        case GT_DIV:    helper = CORINFO_HELP_LDIV;          goto MATH;
        case GT_UDIV:   helper = CORINFO_HELP_ULDIV;         goto MATH;

        case GT_MOD:    helper = CORINFO_HELP_LMOD;          goto MATH;
        case GT_UMOD:   helper = CORINFO_HELP_ULMOD;         goto MATH;

        MATH:

            // UNDONE: Be smarter about the choice of register pairs

            /* Which operand are we supposed to compute first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Compute the second operand into ECX:EBX */

                genComputeRegPair(op2, REG_PAIR_ECXEBX, RBM_NONE, KEEP_REG, false);
                assert(op2->gtFlags & GTF_REG_VAL);
                assert(op2->gtRegNum == REG_PAIR_ECXEBX);

                /* Compute the first  operand into EAX:EDX */

                genComputeRegPair(op1, REG_PAIR_EAXEDX, RBM_NONE, KEEP_REG, false);
                assert(op1->gtFlags & GTF_REG_VAL);
                assert(op1->gtRegNum == REG_PAIR_EAXEDX);

                /* Lock EDX:EAX so that it doesn't get trashed */

                assert((rsMaskLock &  RBM_EDX) == 0);
                        rsMaskLock |= RBM_EDX;
                assert((rsMaskLock &  RBM_EAX) == 0);
                        rsMaskLock |= RBM_EAX;

                /* Make sure the second operand hasn't been displaced */

                genRecoverRegPair(op2, REG_PAIR_ECXEBX, KEEP_REG);

                /* We can unlock EDX:EAX now */

                assert((rsMaskLock &  RBM_EDX) != 0);
                        rsMaskLock -= RBM_EDX;
                assert((rsMaskLock &  RBM_EAX) != 0);
                        rsMaskLock -= RBM_EAX;
            }
            else
            {
                // Special case: both operands promoted from int
                // i.e. (long)i1 * (long)i2.

                if (oper == GT_MUL
                    && op1->gtOper                  == GT_CAST
                    && op2->gtOper                  == GT_CAST
                    && op1->gtCast.gtCastOp->gtType == TYP_INT
                    && op2->gtCast.gtCastOp->gtType == TYP_INT)
                {
                    /* Bash to an integer multiply temporarily */

                    tree->gtOp.gtOp1 = op1->gtCast.gtCastOp;
                    tree->gtOp.gtOp2 = op2->gtCast.gtCastOp;
                    tree->gtType     = TYP_INT;
                    genCodeForTree(tree, 0);
                    tree->gtType     = TYP_LONG;

                    /* The result is now in EDX:EAX */

                    regPair  = REG_PAIR_EAXEDX;
                    goto DONE;
                }
                else
                {
                    /* Compute the first  operand into EAX:EDX */

                    genComputeRegPair(op1, REG_PAIR_EAXEDX, RBM_NONE, KEEP_REG, false);
                    assert(op1->gtFlags & GTF_REG_VAL);
                    assert(op1->gtRegNum == REG_PAIR_EAXEDX);

                    /* Compute the second operand into ECX:EBX */

                    genComputeRegPair(op2, REG_PAIR_ECXEBX, RBM_NONE, KEEP_REG, false);
                    assert(op2->gtRegNum == REG_PAIR_ECXEBX);
                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Lock ECX:EBX so that it doesn't get trashed */

                    assert((rsMaskLock &  RBM_EBX) == 0);
                            rsMaskLock |= RBM_EBX;
                    assert((rsMaskLock &  RBM_ECX) == 0);
                            rsMaskLock |= RBM_ECX;

                    /* Make sure the first operand hasn't been displaced */

                    genRecoverRegPair(op1, REG_PAIR_EAXEDX, KEEP_REG);

                    /* We can unlock ECX:EBX now */

                    assert((rsMaskLock &  RBM_EBX) != 0);
                            rsMaskLock -= RBM_EBX;
                    assert((rsMaskLock &  RBM_ECX) != 0);
                            rsMaskLock -= RBM_ECX;
                }
            }

            /* Perform the math by calling a helper function */

            assert(op1->gtRegNum == REG_PAIR_EAXEDX);
            assert(op2->gtRegNum == REG_PAIR_ECXEBX);

            genEmitHelperCall(CPX,
                             2*sizeof(__int64), // argSize
                             sizeof(void*));    // retSize

            /* The values in both register pairs now trashed */

            rsTrackRegTrash(REG_EAX);
            rsTrackRegTrash(REG_EDX);
            rsTrackRegTrash(REG_EBX);
            rsTrackRegTrash(REG_ECX);

            /* Release both operands */

            genReleaseRegPair(op1);
            genReleaseRegPair(op2);

            assert(op1->gtFlags & GTF_REG_VAL);
            regPair  = op1->gtRegPair;
            goto DONE;

#else // not LONG_MATH_REGPARAM

        case GT_MOD:
        case GT_UMOD:

            regPair = genCodeForLongModInt(tree, needReg);
            goto DONE;

        case GT_MUL:

            /* Special case: both operands promoted from int */

            assert(op1->gtOper == GT_CAST);
            assert(genActualType(op1->gtCast.gtCastOp->gtType) == TYP_INT);

            assert(tree->gtIsValid64RsltMul());

            if (op2->gtOper == GT_CAST)
            {
                assert(genActualType(op2->gtCast.gtCastOp->gtType) == TYP_INT);
                tree->gtOp.gtOp2 = op2->gtCast.gtCastOp;
            }
            else
            {
                assert(op2->gtOper == GT_CNS_LNG);

                /* If op2 was long(intCns), it would have been folded to lngVal.
                   Thats OK. Just bash it to an intCon node */

                op2->ChangeOperConst(GT_CNS_INT);
                op2->gtIntCon.gtIconVal = int(op2->gtLngCon.gtLconVal);
                op2->gtType = TYP_INT;
            }

            /* Bash to an integer multiply temporarily */

            tree->gtType     = TYP_INT;
            tree->gtOp.gtOp1 = op1->gtOp.gtOp1;

            genCodeForTree(tree, 0);

            assert(tree->gtFlags & GTF_REG_VAL);
            assert(tree->gtRegNum == REG_EAX);

            tree->gtType     = TYP_LONG;
            tree->gtOp.gtOp1 = op1;
            tree->gtOp.gtOp2 = op2;

            /* The result is now in EDX:EAX */

            regPair  = REG_PAIR_EAXEDX;
            goto DONE;

#endif // not LONG_MATH_REGPARAM

        case GT_LSH: helper = CORINFO_HELP_LLSH; goto SHIFT;
        case GT_RSH: helper = CORINFO_HELP_LRSH; goto SHIFT;
        case GT_RSZ: helper = CORINFO_HELP_LRSZ; goto SHIFT;

        SHIFT:

            assert(op1->gtType == TYP_LONG);
            assert(genActualType(op2->gtType) == TYP_INT);

            /* Is the second operand a small constant? */

            if  (op2->gtOper == GT_CNS_INT && op2->gtIntCon.gtIconVal >= 0
                                           && op2->gtIntCon.gtIconVal <= 32)
            {
                long        count = op2->gtIntCon.gtIconVal;

                /* Compute the left operand into a free register pair */

                genCompIntoFreeRegPair(op1, op2->gtRsvdRegs, FREE_REG);
                assert(op1->gtFlags & GTF_REG_VAL);

                regPair = op1->gtRegPair;
                regLo   = genRegPairLo(regPair);
                regHi   = genRegPairHi(regPair);

                /* Generate the appropriate shift instructions */

                if (count == 32)
                {
                   switch (oper)
                   {
                   case GT_LSH:
                       inst_RV_RV     (INS_mov , regHi, regLo);
                       genSetRegToIcon(regLo, 0);
                       break;

                   case GT_RSH:
                       inst_RV_RV     (INS_mov , regLo, regHi);

                       /* Propagate sign bit in high dword */

                       inst_RV_SH     (INS_sar , regHi, 31);
                       break;

                   case GT_RSZ:
                       inst_RV_RV     (INS_mov , regLo, regHi);
                       genSetRegToIcon(regHi, 0);
                       break;
                   }
                }
                else
                {
                   switch (oper)
                   {
                   case GT_LSH:
                       inst_RV_RV_IV(INS_shld, regHi, regLo, count);
                       inst_RV_SH   (INS_shl , regLo,        count);
                       break;

                   case GT_RSH:
                       inst_RV_RV_IV(INS_shrd, regLo, regHi, count);
                       inst_RV_SH   (INS_sar , regHi,        count);
                       break;

                   case GT_RSZ:
                       inst_RV_RV_IV(INS_shrd, regLo, regHi, count);
                       inst_RV_SH   (INS_shr , regHi,        count);
                       break;
                   }
                }

                /* The value in the register pair is trashed */

                rsTrackRegTrash(regLo);
                rsTrackRegTrash(regHi);

                goto DONE_SHF;
            }

            /* Which operand are we supposed to compute first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* The second operand can't be a constant */

                assert(op2->gtOper != GT_CNS_INT);

                /* Load the shift count, hopefully into ECX */

                genComputeReg(op2, RBM_ECX, ANY_REG, KEEP_REG);

                /* Compute the left operand into EAX:EDX */

                genComputeRegPair(op1, REG_PAIR_EAXEDX, RBM_NONE, KEEP_REG, false);
                assert(op1->gtFlags & GTF_REG_VAL);

                /* Lock EAX:EDX so that it doesn't get trashed */

                assert((rsMaskLock &  (RBM_EAX|RBM_EDX)) == 0);
                        rsMaskLock |= (RBM_EAX|RBM_EDX);

                /* Make sure the shift count wasn't displaced */

                genRecoverReg(op2, RBM_ECX, KEEP_REG);

                /* We can now unlock EAX:EDX */

                assert((rsMaskLock &  (RBM_EAX|RBM_EDX)) == (RBM_EAX|RBM_EDX));
                        rsMaskLock -= (RBM_EAX|RBM_EDX);
            }
            else
            {
                /* Compute the left operand into EAX:EDX */

                genComputeRegPair(op1, REG_PAIR_EAXEDX, RBM_NONE, KEEP_REG, false);
                assert(op1->gtFlags & GTF_REG_VAL);

                /* Compute the shift count into ECX */

                genComputeReg(op2, RBM_ECX, EXACT_REG, KEEP_REG);

                /* Lock ECX so that it doesn't get trashed */

                assert((rsMaskLock &  RBM_ECX) == 0);
                        rsMaskLock |= RBM_ECX;

                /* Make sure the value hasn't been displaced */

                genRecoverRegPair(op1, REG_PAIR_EAXEDX, KEEP_REG);

                /* We can unlock ECX now */

                assert((rsMaskLock &  RBM_ECX) != 0);
                        rsMaskLock -= RBM_ECX;
            }

            /* Perform the shift by calling a helper function */

            assert(op1->gtRegNum == REG_PAIR_EAXEDX);
            assert(op2->gtRegNum == REG_ECX);

            genEmitHelperCall(helper,
                             0,             // argSize
                             sizeof(void*));// retSize

            /* The value in the register pair is trashed */

            rsTrackRegTrash(REG_EAX);
            rsTrackRegTrash(REG_EDX);

            /* Release both operands */

            genReleaseRegPair(op1);
            genReleaseReg    (op2);

        DONE_SHF:

            assert(op1->gtFlags & GTF_REG_VAL);
            regPair  = op1->gtRegPair;
            goto DONE;

        case GT_NEG:
        case GT_NOT:

            /* Generate the operand into some register pair */

            genCompIntoFreeRegPair(op1, RBM_NONE, FREE_REG);
            assert(op1->gtFlags & GTF_REG_VAL);

            regPair  = op1->gtRegPair;

            /* Figure out which registers the value is in */

            regLo = genRegPairLo(regPair);
            regHi = genRegPairHi(regPair);

            /* The value in the register pair is about to be trashed */

            rsTrackRegTrash(regLo);
            rsTrackRegTrash(regHi);

            if  (oper == GT_NEG)
            {
                /* Unary "neg": negate the value  in the register pair */

                inst_RV   (INS_neg, regLo, TYP_LONG);
                inst_RV_IV(INS_adc, regHi, 0);
                inst_RV   (INS_neg, regHi, TYP_LONG);
            }
            else
            {
                /* Unary "not": flip all the bits in the register pair */

                inst_RV   (INS_not, regLo, TYP_LONG);
                inst_RV   (INS_not, regHi, TYP_LONG);
            }

            goto DONE;

#if LONG_ASG_OPS

        case GT_ASG_OR : insLo =          insHi = INS_or ; goto ASG_OPR;
        case GT_ASG_XOR: insLo =          insHi = INS_xor; goto ASG_OPR;
        case GT_ASG_AND: insLo =          insHi = INS_and; goto ASG_OPR;
        case GT_ASG_SUB: insLo = INS_sub; insHi = INS_sbb; goto ASG_OPR;
        case GT_ASG_ADD: insLo = INS_add; insHi = INS_adc; goto ASG_OPR;

        ASG_OPR:

            if  (op2->gtOper == GT_CNS_LNG)
            {
                __int64     lval = op2->gtLngCon.gtLconVal;

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, FREE_REG);

                /* Optimize some special cases */

                doLo =
                doHi = true;

                /* Check for "(op1 AND -1)" and "(op1 [X]OR 0)" */

                switch (oper)
                {
                case GT_ASG_AND:
                    if  ((int)(lval      ) == -1) doLo = false;
                    if  ((int)(lval >> 32) == -1) doHi = false;
                    break;

                case GT_ASG_OR:
                case GT_ASG_XOR:
                    if  (!(lval & 0x00000000FFFFFFFF)) doLo = false;
                    if  (!(lval & 0xFFFFFFFF00000000)) doHi = false;
                    break;
                }

                if (doLo) inst_TT_IV(insLo, op1, (long)(lval      ), 0);
                if (doHi) inst_TT_IV(insHi, op1, (long)(lval >> 32), 4);

                bool    isArith = (oper == GT_ASG_ADD || oper == GT_ASG_SUB);
                if (doLo || doHi)
                    tree->gtFlags |= (GTF_ZF_SET | (isArith ? GTF_CC_SET : 0));

                genDoneAddressable(op1, addrReg, FREE_REG);
                goto DONE_ASSG_REGS;
            }

            /* UNDONE: allow non-const long assignment operators */

            assert(!"non-const long asgop NYI");

#endif // LONG_ASG_OPS

        case GT_IND:
            {
                regMaskTP   tmpMask;
                int         hiFirst;

                regMaskTP   availMask = RBM_ALL & ~needReg;

                /* Make sure the operand is addressable */

                addrReg = genMakeAddressable(tree, availMask, FREE_REG);

                GenTreePtr addr = oper == GT_IND ? op1 : tree;

                /* Pick a register for the value */

                regPair = rsPickRegPair(needReg);
                tmpMask = genRegPairMask(regPair);

                /* Is there any overlap between the register pair and the address? */

                hiFirst = FALSE;

                if  (tmpMask & addrReg)
                {
                    /* Does one or both of the target registers overlap? */

                    if  ((tmpMask & addrReg) != tmpMask)
                    {
                        /* Only one register overlaps */

                        assert(genMaxOneBit(tmpMask & addrReg) == TRUE);

                        /* If the low register overlaps, load the upper half first */

                        if  (addrReg & genRegMask(genRegPairLo(regPair)))
                            hiFirst = TRUE;
                    }
                    else
                    {
                        regMaskTP  regFree;

                        /* The register completely overlaps with the address */

                        assert(genMaxOneBit(tmpMask & addrReg) == FALSE);

                        /* Can we pick another pair easily? */

                        regFree = rsRegMaskFree() & ~addrReg;
                        if  (needReg)
                            regFree &= needReg;

                        /* More than one free register available? */

                        if  (regFree && !genMaxOneBit(regFree))
                        {
                            regPair = rsPickRegPair(regFree);
                            tmpMask = genRegPairMask(regPair);
                        }
                        else
                        {
//                          printf("Overlap: needReg = %08X\n", needReg);

                            // Reg-prediction wont allow this
                            assert((rsMaskVars & addrReg) == 0);

                            // Grab one fresh reg, and use any one of addrReg

                            if (regFree)    // Try to follow 'needReg'
                                regLo = rsGrabReg(regFree);
                            else            // Pick any reg besides addrReg
                                regLo = rsGrabReg(RBM_ALL & ~addrReg);

                            unsigned regBit = 0x1;
                            for (regNumber regNo = REG_FIRST; regNo < REG_COUNT; regNo = REG_NEXT(regNo), regBit <<= 1)
                            {
                                if (regBit & addrReg)
                                {
                                    // Found one of addrReg. Use it.
                                    regHi = regNo;
                                    break;
                                }
                            }
                            assert(genIsValidReg(regNo)); // Should have found regHi

                            regPair = gen2regs2pair(regLo, regHi);
                            tmpMask = genRegPairMask(regPair);
                        }
                    }
                }

                /* Make sure the value is still addressable */

                assert(genStillAddressable(tree));

                /* Figure out which registers the value is in */

                regLo = genRegPairLo(regPair);
                regHi = genRegPairHi(regPair);

                /* The value in the register pair is about to be trashed */

                rsTrackRegTrash(regLo);
                rsTrackRegTrash(regHi);

                /* Load the target registers from where the value is */

                if  (hiFirst)
                {
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, regHi, addr, 4);
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, regLo, addr, 0);
                }
                else
                {
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, regLo, addr, 0);
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, regHi, addr, 4);
                }

                genUpdateLife(tree);
                genDoneAddressable(tree, addrReg, FREE_REG);

            }
            goto DONE;

        case GT_CAST:

            /* What are we casting from? */

            switch (op1->gtType)
            {
            case TYP_BOOL:
            case TYP_BYTE:
            case TYP_CHAR:
            case TYP_SHORT:
            case TYP_INT:
            case TYP_UBYTE:
            case TYP_BYREF:
                {
                    regMaskTP hiRegMask;
                    regMaskTP loRegMask;

                    // For an unsigned cast we don't need to sign-extend the 32 bit value
                    if (tree->gtFlags & GTF_UNSIGNED)
                    {
                        // Does needReg have exactly two bits on and thus
                        // specifies the exact register pair that we want to use
                        if (!genMaxOneBit(needReg))
                        {
                            regPair   = rsFindRegPairNo(needReg);
                            if (needReg != genRegPairMask(regPair))
                                goto ANY_FREE_REG_UNSIGNED;
                            loRegMask = genRegMask(genRegPairLo(regPair));
                            if ((loRegMask & rsRegMaskCanGrab()) == 0)
                                goto ANY_FREE_REG_UNSIGNED;
                            hiRegMask = genRegMask(genRegPairHi(regPair));
                        }
                        else
                        {
ANY_FREE_REG_UNSIGNED:
                            loRegMask = needReg;
                            hiRegMask = RBM_NONE;
                        }

                        genComputeReg(op1, loRegMask, ANY_REG, KEEP_REG);
                        assert(op1->gtFlags & GTF_REG_VAL);

                        regLo     = op1->gtRegNum;
                        loRegMask = genRegMask(regLo);
                        rsLockUsedReg(loRegMask);
                        regHi     = rsPickReg(hiRegMask);
                        rsUnlockUsedReg(loRegMask);

                        regPair = gen2regs2pair(regLo, regHi);

                        // Move 0 to the higher word of the ULong
                        genSetRegToIcon(regHi, 0, TYP_INT);

                        /* We can now free up the operand */
                        genReleaseReg(op1);

                        goto DONE;
                    }

                    /*
                       Cast of 'int' to 'long' --> Use cdq if EAX,EDX are available
                       and we need the result to be in those registers.
                       cdq is smaller so we use it for SMALL_CODE
                       cdq is slower for 486 and P5, but faster on P6
                    */

                    if  (((compCodeOpt() == SMALL_CODE) || (genCPU >= 6)) &&
                         (needReg & (RBM_EAX|RBM_EDX)) == (RBM_EAX|RBM_EDX)  &&
                         (rsRegMaskFree() & RBM_EDX)                            )
                    {
                        genCodeForTree(op1, RBM_EAX);
                        rsMarkRegUsed(op1);

                        /* If we have to spill EDX, might as well use the faster
                           sar as the spill will increase code size anyway */

                        if (op1->gtRegNum != REG_EAX || 
                            !(rsRegMaskFree() & RBM_EDX))
                        {
                            hiRegMask = rsRegMaskFree();
                            goto USE_SAR_FOR_CAST;
                        }

                        rsGrabReg      (RBM_EDX);
                        rsTrackRegTrash(REG_EDX);

                        /* Convert the int in EAX into a long in EDX:EAX */

                        instGen(INS_cdq);

                        /* The result is in EDX:EAX */

                        regPair  = REG_PAIR_EAXEDX;
                    }
                    else
                    {
                        /* use the sar instruction to sign-extend a 32-bit integer */

                        // Does needReg have exactly two bits on and thus
                        // specifies the exact register pair that we want to use
                        if (!genMaxOneBit(needReg))
                        {
                            regPair = rsFindRegPairNo(needReg);
                            if (needReg != genRegPairMask(regPair))
                                goto ANY_FREE_REG_SIGNED;
                            loRegMask = genRegMask(genRegPairLo(regPair));
                            if ((loRegMask & rsRegMaskCanGrab()) == 0)
                                goto ANY_FREE_REG_SIGNED;
                            hiRegMask = genRegMask(genRegPairHi(regPair));
                        }
                        else
                        {
ANY_FREE_REG_SIGNED:
                            loRegMask = needReg;
                            hiRegMask = RBM_NONE;
                        }

                        genComputeReg(op1, loRegMask, ANY_REG, KEEP_REG);
USE_SAR_FOR_CAST:
                        assert(op1->gtFlags & GTF_REG_VAL);

                        regLo     = op1->gtRegNum;
                        loRegMask = genRegMask(regLo);
                        rsLockUsedReg(loRegMask);
                        regHi     = rsPickReg(hiRegMask);
                        rsUnlockUsedReg(loRegMask);

                        regPair = gen2regs2pair(regLo, regHi);

                        /* Copy the lo32 bits from regLo to regHi and sign-extend it */

                        inst_RV_RV(INS_mov, regHi, regLo, TYP_INT);
                        inst_RV_SH(INS_sar, regHi, 31);

                        /* The value in the upper register is trashed */

                        rsTrackRegTrash(regHi);
                    }

                    /* We can now free up the operand */
                    genReleaseReg(op1);

                    // conv.ovf.u8 could overflow if the original number was negative
                    if (tree->gtOverflow() && TYP_ULONG == tree->gtCast.gtCastType)
                    {
                        regNumber hiReg = genRegPairHi(regPair);
                        inst_RV_RV(INS_test, hiReg, hiReg);         // set flags
                        genJumpToThrowHlpBlk(EJ_jl, ACK_OVERFLOW);
                    }
                }
                goto DONE;

            case TYP_FLOAT:
            case TYP_DOUBLE:

#if 0
                /* Load the FP value onto the coprocessor stack */

                genCodeForTreeFlt(op1, false);

                /* Allocate a temp for the long value */

                temp = tmpGetTemp(TYP_LONG);

                /* Store the FP value into the temp */

                inst_FS_ST(INS_fistpl, sizeof(long), temp, 0);
                genTmpAccessCnt++;
                genFPstkLevel--;

                /* Pick a register pair for the value */

                regPair  = rsPickRegPair(needReg);

                /* Figure out which registers the value is in */

                regLo = genRegPairLo(regPair);
                regHi = genRegPairHi(regPair);

                /* The value in the register pair is about to be trashed */

                rsTrackRegTrash(regLo);
                rsTrackRegTrash(regHi);

                /* Load the converted value into the registers */

                inst_RV_ST(INS_mov, EA_4BYTE, regLo, temp, 0);
                inst_RV_ST(INS_mov, EA_4BYTE, regHi, temp, 4);
                genTmpAccessCnt += 2;

                /* We no longer need the temp */

                tmpRlsTemp(temp);
                goto DONE;
#else
                assert(!"this cast supposed to be done via a helper call");
#endif
            case TYP_LONG:
            case TYP_ULONG:

                assert(tree->gtOverflow()); // conv.ovf.u8 or conv.ovf.i8

                genComputeRegPair(op1, REG_PAIR_NONE, RBM_ALL & ~needReg, FREE_REG);
                regPair = op1->gtRegPair;

                // Do we need to set the sign-flag, or can be check if it
                // set, and not do this "test" if so.

                if (op1->gtFlags & GTF_REG_VAL)
                {
                    regNumber hiReg = genRegPairHi(op1->gtRegPair);
                    assert(hiReg != REG_STK);

                    inst_RV_RV(INS_test, hiReg, hiReg);
                }
                else
                {
                    inst_TT_IV(INS_cmp, op1, 0, sizeof(int));
                }

                genJumpToThrowHlpBlk(EJ_jl, ACK_OVERFLOW);
                goto DONE;

            default:
#ifdef  DEBUG
                gtDispTree(tree);
#endif
                assert(!"unexpected cast to long");
            }

#endif // TGT_x86

        case GT_RETURN:

            /* There must be a long return value */

            assert(op1);

            /* Evaluate the return value into EDX:EAX */

            genEvalIntoFreeRegPair(op1, REG_LNGRET);

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_LNGRET);

            return;

#if TGT_x86

#if INLINING
        case GT_QMARK:
            assert(!"inliner-generated ?: for longs NYI");
            NO_WAY("inliner-generated ?: for longs NYI");
#endif

        case GT_BB_COLON:

            /* @TODO [CONSIDER] [04/16/01] []: 
               Don't always load the value into EDX:EAX! */

            genEvalIntoFreeRegPair(op1, REG_LNGRET);

            /* The result must now be in EDX:EAX */

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_LNGRET);

            return;

#endif // TGT_x86

        case GT_COMMA:
            if (tree->gtFlags & GTF_REVERSE_OPS)
            {
                // Generate op2
                genCodeForTreeLng(op2, needReg);
                genUpdateLife (op2);

                assert(op2->gtFlags & GTF_REG_VAL);

                rsMarkRegPairUsed(op2);

                // Do side effects of op1
                genEvalSideEffects(op1);

                // Recover op2 if spilled
                genRecoverRegPair(op2, REG_PAIR_NONE, KEEP_REG);

                genReleaseRegPair(op2);
                
                genUpdateLife (tree);

                regPair = op2->gtRegPair;
            }
            else
            {

                assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

                /* Generate side effects of the first operand */

    #if 0
                // op1 is required to have a side effect, otherwise
                // the GT_COMMA should have been morphed out
                assert(op1->gtFlags & (GTF_GLOB_EFFECT | GTFD_NOP_BASH));
    #endif
                genEvalSideEffects(op1);
                genUpdateLife (op1);

                /* Is the value of the second operand used? */

                if  (tree->gtType == TYP_VOID)
                {
                    /* The right operand produces no result */

                    genEvalSideEffects(op2);
                    genUpdateLife(tree);
                    return;
                }

                /* Generate the second operand, i.e. the 'real' value */

                genCodeForTreeLng(op2, needReg);

                /* The result of 'op2' is also the final result */

                regPair = op2->gtRegPair;
            }

            goto DONE;
        }

#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected 64-bit operator");
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        regMaskTP retMask;
    case GT_CALL:
        retMask = genCodeForCall(tree, true);
        if (retMask == RBM_NONE)
            regPair = REG_PAIR_NONE;
        else
            regPair = rsFindRegPairNo(retMask);
        break;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        NO_WAY("unexpected long operator");
    }

DONE:

    genUpdateLife(tree);

    /* Here we've computed the value of 'tree' into 'regPair' */

    assert(regPair != 0xFEEFFAAF);

    tree->gtFlags   |= GTF_REG_VAL;
    tree->gtRegPair  = regPair;
}


/*****************************************************************************
 *
 *  Generate code for a mod of a long by an int.
 */

regPairNo           Compiler::genCodeForLongModInt(GenTreePtr tree,
                                                   regMaskTP needReg)
{
    regPairNo       regPair;
    regMaskTP       addrReg;
    
    genTreeOps      oper = tree->OperGet();    
    GenTreePtr      op1  = tree->gtOp.gtOp1;
    GenTreePtr      op2  = tree->gtOp.gtOp2;
    
    /* op2 must be a long constant in the range 2 to 0x3fffffff */
    
    assert((op2->gtOper == GT_CNS_LNG) &&
           (op2->gtLngCon.gtLconVal >= 2) &&
           (op2->gtLngCon.gtLconVal <= 0x3fffffff)); 
    long val = (long) op2->gtLngCon.gtLconVal;

    op2->ChangeOperConst(GT_CNS_INT); // it's effectively an integer constant

    op2->gtType             = TYP_INT;
    op2->gtIntCon.gtIconVal = val;

    /* Which operand are we supposed to compute first? */

    if  (tree->gtFlags & GTF_REVERSE_OPS)
    {
        /* Compute the second operand into a scratch register, other
           than EAX or EDX */

        needReg = rsMustExclude(needReg, RBM_EAX | RBM_EDX);

        /* Special case: if op2 is a local var we are done */

        if  (op2->gtOper == GT_LCL_VAR ||
             op2->gtOper == GT_LCL_FLD ||
             op2->gtOper == GT_CLS_VAR)
        {
            addrReg = genMakeRvalueAddressable(op2, needReg, KEEP_REG);
        }
        else
        {
            genComputeReg(op2, needReg, ANY_REG, KEEP_REG);

            assert(op2->gtFlags & GTF_REG_VAL);
            addrReg = genRegMask(op2->gtRegNum);
        }

        /* Compute the first operand into EAX:EDX */

        genComputeRegPair(op1, REG_PAIR_EAXEDX, RBM_NONE, KEEP_REG, true);
        assert(op1->gtFlags & GTF_REG_VAL);
        assert(op1->gtRegNum == REG_PAIR_EAXEDX);

        /* And recover the second argument while locking the first one */

        addrReg = genKeepAddressable(op2, addrReg, RBM_EAX | RBM_EDX);
    }
    else
    {
        /* Compute the first operand into EAX:EDX */

        genComputeRegPair(op1, REG_PAIR_EAXEDX, RBM_NONE, KEEP_REG, true);
        assert(op1->gtFlags & GTF_REG_VAL);
        assert(op1->gtRegNum == REG_PAIR_EAXEDX);

        /* Compute the second operand into a scratch register, other
           than EAX or EDX */

        needReg = rsMustExclude(needReg, RBM_EAX | RBM_EDX);

        /* Special case: if op2 is a local var we are done */

        if  (op2->gtOper == GT_LCL_VAR ||
             op2->gtOper == GT_LCL_FLD ||
             op2->gtOper == GT_CLS_VAR)
        {
            addrReg = genMakeRvalueAddressable(op2, needReg, KEEP_REG);
        }
        else
        {
            genComputeReg(op2, needReg, ANY_REG, KEEP_REG);

            assert(op2->gtFlags & GTF_REG_VAL);
            addrReg = genRegMask(op2->gtRegNum);
        }

        /* Recover the first argument */

        genRecoverRegPair(op1, REG_PAIR_EAXEDX, KEEP_REG);

        /* And recover the second argument while locking the first one */

        addrReg = genKeepAddressable(op2, addrReg, RBM_EAX | RBM_EDX);
    }

    {
        /* At this point, EAX:EDX contains the 64bit dividend and op2->gtRegNum
           contains the 32bit divisor.  We want to generate the following code:

           ==========================
           Unsigned (GT_UMOD)

           cmp edx, op2->gtRegNum
           jb  lab_no_overflow

           mov temp, eax
           mov eax, edx
           xor edx, edx
           div op2->g2RegNum
           mov eax, temp

           lab_no_overflow:
           idiv

           ==========================
           Signed: (GT_MOD)

           cmp edx, op2->gtIntCon.gtIconVal / 2
           jb  lab_no_overflow

           mov temp, eax
           mov eax, edx
           cdq
           idiv op2->gtRegNum
           mov  eax, temp
           mov  temp, op2->gtIntCon.gtIconVal * 2
           idiv temp
           mov  eax, edx
           cdq

           lab_no_overflow:
           idiv op2->gtRegNum  

           ==========================

           This works because (a * 2^32 + b) % c = ((a % c) * 2^32 + b) % c

           Note that in the signed case, even if (a < c) is true, we may not
           be able to fit the result in a signed 32bit remainder.  The trick
           there is to first mod by 2*c which is guaranteed not to overflow,
           and only then to mod by c.
        */

        BasicBlock * lab_no_overflow = genCreateTempLabel();

        // grab a temporary register other than eax, edx, and op2->gtRegNum

        regNumber tempReg = rsGrabReg(RBM_ALL & ~(RBM_EAX | RBM_EDX | genRegMask(op2->gtRegNum)));

        // EAX and tempReg will be trashed by the mov instructions.  Doing
        // this early won't hurt, and might prevent confusion in genSetRegToIcon.

        rsTrackRegTrash (REG_EAX);
        rsTrackRegTrash (tempReg);
        
        if (oper == GT_UMOD)
        {
            inst_RV_RV(INS_cmp, REG_EDX, op2->gtRegNum);
            inst_JMP(EJ_jb ,lab_no_overflow);

            inst_RV_RV(INS_mov, tempReg, REG_EAX, TYP_INT);
            inst_RV_RV(INS_mov, REG_EAX, REG_EDX, TYP_INT);
            genSetRegToIcon(REG_EDX, 0, TYP_INT);
            inst_TT(INS_div,  op2);
            inst_RV_RV(INS_mov, REG_EAX, tempReg, TYP_INT);
        }
        else
        {
            int val = op2->gtIntCon.gtIconVal;

            inst_RV_IV(INS_cmp, REG_EDX, val >> 1);
            inst_JMP(EJ_jb ,lab_no_overflow);

            inst_RV_RV(INS_mov, tempReg, REG_EAX, TYP_INT);
            inst_RV_RV(INS_mov, REG_EAX, REG_EDX, TYP_INT);
            instGen(INS_cdq);
            inst_TT(INS_idiv, op2);
            inst_RV_RV(INS_mov, REG_EAX, tempReg, TYP_INT);
            genSetRegToIcon(tempReg, val << 1, TYP_INT);
            inst_RV(INS_idiv, tempReg, TYP_INT);
            inst_RV_RV(INS_mov, REG_EAX, REG_EDX, TYP_INT);
            instGen(INS_cdq);
        }

        // Jump point for no overflow divide

        genDefineTempLabel(lab_no_overflow, true);

        // Issue the divide instruction

        if (oper == GT_UMOD)
            inst_TT(INS_div,  op2);
        else
            inst_TT(INS_idiv, op2);

        /* EAX, EDX, tempReg and op2->gtRegNum are now trashed */

        rsTrackRegTrash (REG_EAX);
        rsTrackRegTrash (REG_EDX);
        rsTrackRegTrash (tempReg);
        rsTrackRegTrash (op2->gtRegNum);
    }

    if (tree->gtFlags & GTF_MOD_INT_RESULT)
    {
        /* We don't need to normalize the result, because the caller wants
           an int (in edx) */

        regPair = REG_PAIR_EDXEAX;
    }
    else
    {
        /* The result is now in EDX, we now have to normalize it, i.e. we have
           to issue either
                mov eax, edx; cdq          (for MOD)        or
                mov eax, edx; xor edx, edx (for UMOD)
         */

        inst_RV_RV(INS_mov, REG_EAX, REG_EDX, TYP_INT);

        if (oper == GT_UMOD)
            genSetRegToIcon(REG_EDX, 0, TYP_INT);
        else
            instGen(INS_cdq);

        regPair = REG_PAIR_EAXEDX;
    }

    genReleaseRegPair(op1);
    genDoneAddressable(op2, addrReg, KEEP_REG);

    return regPair;
}


/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  A register FP variable is being evaluated and this is the final reference
 *  to it (i.e. it's dead after this node and needs to be popped off the x87
 *  stack). We try to remove the variable from the stack now, but in some
 *  cases we can't do it and it has to be postponed.
 */

void                Compiler::genFPregVarLoadLast(GenTreePtr tree)
{
    assert(tree->gtOper   == GT_REG_VAR);
    assert(tree->gtRegNum == 0);
    assert(tree->gtFlags & GTF_REG_DEATH);

    bool    popped = true;

    /* Is the variable dying at the bottom of the FP stack? */

    if  (genFPstkLevel == 0)
    {
        /* Just leave the last copy of the variable on the stack */
        genFPstkLevel++;
    }
    else
    {
        #if  FPU_DEFEREDDEATH

        if  (genFPstkLevel == 1)
        {
            /* Swap the variable's value into place */

            inst_FN(INS_fxch, 1);
        }
        else
        {
            /* Its too expensive to pop the variable immedidately.
               We'll do it later ... */

            inst_FN(INS_fld, tree->gtRegNum + genFPstkLevel);
            popped = false;
        }
        genFPstkLevel++;
        
        #else        

        // Bubble up to the TOS the dying regvar
        genFPstkLevel++;
        genFPmovRegTop();       

        #endif // FPU_DEFEREDDEATH
    }

    /* Record the fact that 'tree' is now dead */

    genFPregVarDeath(tree, popped);
    
    return;
}

/*****************************************************************************
 *
 *  One or more FP register variables have died without us noticing, so we
 *  need to pop them now before it's too late. The argument gives the final
 *  desired FP regvar count (i.e. we must have more than 'newCnt' currently
 *  and will pop enough to reach that value).
 */

void                Compiler::genFPregVarKill(unsigned newCnt, bool saveTOS)
{
    int         popCnt = genFPregCnt - newCnt; assert(popCnt > 0);

    genFPdeadRegCnt -= popCnt;

#ifdef DEBUG
    // So that compFPregVarName() will work
    int oldStkLvl  = genFPstkLevel;
    genFPstkLevel += (genFPregCnt - newCnt);
#endif

    if (saveTOS)
    {
        do
        {
            inst_FS(INS_fstp ,  1);
            popCnt      -= 1;
            genFPregCnt -= 1;
        }
        while (popCnt);
    }
    else
    {
        do
        {
            if  (popCnt > 1)
            {
                inst_FS(INS_fcompp, 1);
                popCnt      -= 2;
                genFPregCnt -= 2;
            }
            else
            {
                inst_FS(INS_fstp ,  0);
                popCnt      -= 1;
                genFPregCnt -= 1;
            }
        }
        while (popCnt);
    }

    // Update genFPregVars if we can.
    genFPregVars &= genCodeCurLife;

#ifdef DEBUG
    genFPstkLevel = oldStkLvl;
    assert(genFPregCnt == genCountBits(genFPregVars));
#endif
}

/*****************************************************************************
 *
 *  Called whenever we see a tree node which is an enregistered FP var
 *  going live.
 */

void                Compiler::genFPregVarBirth(GenTreePtr   tree)
{
    unsigned        varNum  = tree->gtRegVar.gtRegVar;
    VARSET_TP       varBit  = raBitOfRegVar(tree);

    assert((tree->gtOper == GT_REG_VAR) && (tree->gtFlags & GTF_REG_BIRTH));
    assert(tree->gtRegVar.gtRegNum == 0);
    assert(varBit & optAllFPregVars);

    assert(isFloatRegType(lvaTable[varNum].lvType));
    assert(lvaTable[varNum].lvRegister);

#ifdef  DEBUG
    if  (verbose) printf("[%08X]: FP regvar V%02u born\n", tree, varNum);
#endif

    /* Mark the target variable as live */

    genFPregVars |= varBit;

#if 0
    /* lvaTable[varNum].lvRegNum is the (max) position from the bottom of the
       FP stack. This assert is relaxed from == to <= as different webs of the
       variable's lifetime might be enregistered at different distances
       from the bottom of the FP stack. */

    assert((genFPregCnt - genFPdeadRegCnt) <= unsigned(lvaTable[varNum].lvRegNum));
#endif

    genFPregCnt++;
    assert(genFPregCnt == genCountBits(genFPregVars));

#if defined(DEBUGGING_SUPPORT) || defined(LATE_DISASM)

    /* For optimized code, open a new scope */

    if (opts.compDbgInfo && !opts.compDbgCode)
    {
        siNewScopeNear(varNum, compCurBB->bbCodeOffs);
    }

#endif

}

/*****************************************************************************
 * Called whenever we see a tree node which is an enregistered FP var
 * going dead.
 * 'popped' should indicate if the variable will be popped immediately.
 */

void            Compiler::genFPregVarDeath(GenTreePtr   tree,
                                           bool         popped /* = true */)
{
    unsigned        varNum = tree->gtRegVar.gtRegVar;
    VARSET_TP       varBit = raBitOfRegVar(tree);

    #if FPU_DEFEREDDEATH
    #else
    // We shouldn't ever get popped=false with defered deaths turned off.
    assert(popped);
    #endif // FPU_DEFEREDDEATH

    assert((tree->gtOper == GT_REG_VAR) && (tree->gtFlags & GTF_REG_DEATH));
    assert(varBit & optAllFPregVars);

    assert(isFloatRegType(lvaTable[varNum].lvType));
    assert(lvaTable[varNum].lvRegister);

#ifdef DEBUG
    if  (verbose) printf("[%08X]: FP regvar V%02u dies at stklvl %u%s\n",
            tree, varNum, genFPstkLevel, popped ? "" : " without being popped");
#endif

    if (popped)
    {
        /* Record the fact that 'varNum' is now dead and popped */

        genFPregVars &= ~varBit;
        genFPregCnt--;
        assert(genFPregCnt == genCountBits(genFPregVars));
    }
    else
    {        
        genFPdeadRegCnt++;
    }

#if 0
    /* lvaTable[varNum].lvRegNum is the (max) position from the bottom of the
       FP stack. This assert is relaxed from == to <= as different webs of the
       variable's lifetime might be enregistered at different distances
       from the bottom of the FP stack. */

    assert((genFPregCnt - genFPdeadRegCnt) <= unsigned(lvaTable[varNum].lvRegNum));
#endif

#if defined(DEBUGGING_SUPPORT) || defined(LATE_DISASM)

    /* For optimized code, close existing open scope */

    if (opts.compDbgInfo && !opts.compDbgCode)
    {
        siEndScope(varNum);
    }

#endif

}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if     CPU_HAS_FP_SUPPORT
/*****************************************************************************
 *
 *  Generate code for a floating-point operation.
 */

void                Compiler::genCodeForTreeFlt(GenTreePtr  tree,
                                                bool        roundResult)
{
    genTreeOps      oper;
    unsigned        kind;

    assert(tree);
    assert(tree->gtOper != GT_STMT);
    assert(varTypeIsFloating(tree->gtType));

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

#if     TGT_x86

    /* There better not be any calls if the FP stack is non-empty */

    assert(genFPstkLevel == 0 || !(tree->gtFlags & GTF_CALL));

    /* We must not overflow the stack */

    assert(genFPstkLevel + genFPregCnt < FP_STK_SIZE);

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        GenTreePtr      fval;

#ifdef DEBUG
        if (oper != GT_CNS_DBL) 
        {
            gtDispTree(tree);
            assert(!"bogus float const");
        }
#endif
        /* Special case: the constants 0 and 1 */

        if  (*((__int64 *)&(tree->gtDblCon.gtDconVal)) == 0x3ff0000000000000)
        {
            instGen(INS_fld1);
            genFPstkLevel++;
            return;
        }

        if  (*((__int64 *)&(tree->gtDblCon.gtDconVal)) == 0)
        {
            instGen(INS_fldz);
            genFPstkLevel++;
            return;
        }

        if (tree->gtType == TYP_FLOAT) 
        {
            float f = tree->gtDblCon.gtDconVal;
            fval = genMakeConst(&f, sizeof(float), TYP_FLOAT, tree, false, true);
        }
        else 
            fval = genMakeConst(&tree->gtDblCon.gtDconVal, sizeof(double), tree->gtType, tree, true, true);

        inst_FS_TT(INS_fld, fval);
        genFPstkLevel++;
        return;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:
        case GT_LCL_FLD:
            assert(!lvaTable[tree->gtLclVar.gtLclNum].lvRegister);
            inst_FS_TT(INS_fld, tree);
            genFPstkLevel++;
            break;

        case GT_REG_VAR:
            genFPregVarLoad(tree);
            if (roundResult && tree->gtType == TYP_FLOAT)
                genRoundFpExpression(tree);
            break;

        case GT_CLS_VAR:
            inst_FS_TT(INS_fld, tree);
            genFPstkLevel++;
            break;

        case GT_BB_QMARK:
            /* Simply pretend the value is already pushed on the FP stack */
            genFPstkLevel++;
            return;

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected leaf");
        }

        genUpdateLife(tree);
        return;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        TempDsc  *      temp;

        GenTreePtr      top;    // First operand which is evaluated to the FP stack top
        GenTreePtr      opr;    // The other operand which could be used in place

        regMaskTP       addrReg;

        emitAttr        size;
        int             offs;

#if ROUND_FLOAT
        bool            roundTop;
#endif

        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtGetOp2();

        // N=normal, R=reverse, P=pop
const static  BYTE  FPmathNN[] = { INS_fadd , INS_fsub  , INS_fmul , INS_fdiv   };
const static  BYTE  FPmathNP[] = { INS_faddp, INS_fsubp , INS_fmulp, INS_fdivp  };
const static  BYTE  FPmathRN[] = { INS_fadd , INS_fsubr , INS_fmul , INS_fdivr  };
const static  BYTE  FPmathRP[] = { INS_faddp, INS_fsubrp, INS_fmulp, INS_fdivrp };

#ifdef  DEBUG
        addrReg = 0xDDDD;
#endif

        switch (oper)
        {
            instruction     ins_NN;
            instruction     ins_RN;
            instruction     ins_RP;
            instruction     ins_NP;

        case GT_ADD:
        case GT_SUB:
        case GT_MUL:
        case GT_DIV:

#ifdef DEBUG
            /* For risc code there better be two slots available */
            if (riscCode)
                assert(genFPstkLevel + genFPregCnt < FP_STK_SIZE - 1);
#endif

            /* Make sure the instruction tables look correctly ordered */

            assert(FPmathNN[GT_ADD - GT_ADD] == INS_fadd  );
            assert(FPmathNN[GT_SUB - GT_ADD] == INS_fsub  );
            assert(FPmathNN[GT_MUL - GT_ADD] == INS_fmul  );
            assert(FPmathNN[GT_DIV - GT_ADD] == INS_fdiv  );

            assert(FPmathNP[GT_ADD - GT_ADD] == INS_faddp );
            assert(FPmathNP[GT_SUB - GT_ADD] == INS_fsubp );
            assert(FPmathNP[GT_MUL - GT_ADD] == INS_fmulp );
            assert(FPmathNP[GT_DIV - GT_ADD] == INS_fdivp );

            assert(FPmathRN[GT_ADD - GT_ADD] == INS_fadd  );
            assert(FPmathRN[GT_SUB - GT_ADD] == INS_fsubr );
            assert(FPmathRN[GT_MUL - GT_ADD] == INS_fmul  );
            assert(FPmathRN[GT_DIV - GT_ADD] == INS_fdivr );

            assert(FPmathRP[GT_ADD - GT_ADD] == INS_faddp );
            assert(FPmathRP[GT_SUB - GT_ADD] == INS_fsubrp);
            assert(FPmathRP[GT_MUL - GT_ADD] == INS_fmulp );
            assert(FPmathRP[GT_DIV - GT_ADD] == INS_fdivrp);

            /* Are we supposed to generate operand 2 first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                top    = op2;
                opr    = op1;

                ins_NN = (instruction)FPmathRN[oper - GT_ADD];
                ins_NP = (instruction)FPmathRP[oper - GT_ADD];
                ins_RN = (instruction)FPmathNN[oper - GT_ADD];
                ins_RP = (instruction)FPmathNP[oper - GT_ADD];
            }
            else
            {
                top    = op1;
                opr    = op2;

                ins_NN = (instruction)FPmathNN[oper - GT_ADD];
                ins_NP = (instruction)FPmathNP[oper - GT_ADD];
                ins_RN = (instruction)FPmathRN[oper - GT_ADD];
                ins_RP = (instruction)FPmathRP[oper - GT_ADD];
            }

#if ROUND_FLOAT

            /* if we're going to spill due to call, no need to round the
             * result of computation of top
             */

            roundTop = (opr->gtFlags & GTF_CALL) ? false
                                                 : genShouldRoundFP();
#endif
            /* Is either of the operands a register variable? */

            if  (top->gtOper == GT_REG_VAR)
            {
                if  (opr->gtOper == GT_REG_VAR)
                {
                    /* Both operands are register variables
                     * Special case: 'top' and 'opr' are the same variable */

                    if (top->gtLclVar.gtLclNum == opr->gtLclVar.gtLclNum)
                    {
                        assert(opr->gtRegNum == top->gtRegNum);
                        assert(opr->gtLclVar.gtLclNum == opr->gtRegVar.gtRegVar);

                        /* This is an "a op a" operation - only 'opr' can go dead */

                        assert(!(top->gtFlags & GTF_REG_DEATH));

                        if (opr->gtFlags & GTF_REG_DEATH)
                        {
                            /* The variable goes dead here */

                            assert(top->gtRegNum == 0);
                            assert(opr->gtRegNum == 0);

                            /* Record the fact that 'opr' is dead */

                            genFPregVarDeath(opr);
                            genFPstkLevel++;

                            /* If there are no temps on the stack things are great,
                             * we just over-write 'opr' with the result, otherwise shift 'opr' up */

                            genFPmovRegTop();
                        }
                        else
                        {
                            /* The variable remains live - make a copy of it on TOS */

                            genCodeForTreeFlt(top, roundTop);
                        }

                        /* Simply generate "ins ST(0)" */

                        inst_FS(ins_NN);

                        goto DONE_FP_BINOP;
                    }

                    /* 'top' and 'opr' are different variables - check if
                       any of them go dead */

                    if  (top->gtFlags & GTF_REG_DEATH)
                    {
                        /* 'top' dies here - check if 'opr' also dies */

                        if  (opr->gtFlags & GTF_REG_DEATH)
                        {
                            /* Both are going dead at this operation!
                             * In the evaluation order 'top' dies first so we must
                             * have the lifetime of 'top' nested into the lifetime
                             * of 'opr' - thus 'top' is right above 'opr' */

                            assert(top->gtRegNum == 0);
                            assert(opr->gtRegNum == 0);

                            /* Record the fact that 'top' is dead  - top becomes a temp */

                            genFPregVarDeath(top);
                            genFPstkLevel++;

                            /* If there are temps above 'top' we have to bubble it up */

                            genFPmovRegTop();

                            /* Compute the result replacing 'opr' and pop 'top' */

                            inst_FS(ins_RP, genFPstkLevel);    // @MIHAI this should be ins_RP ???

                            /* Record the fact that 'opr' is dead */

                            genFPregVarDeath(opr);

                            /* If there are temps move the result (the modified 'opr') up */

                            genFPmovRegTop();
                        }
                        else
                        {
                            /* 'top' dies, 'opr' stays alive */
                            assert(top->gtRegNum == 0);

                            /* Record the fact that 'top' is dead */

                            genFPregVarDeath(top);
                            genFPstkLevel++;

                            /* If there are no temps on the stack things are great,
                             * we just over-write 'top' with the result, otherwise shift top up */

                            genFPmovRegTop();

                            /* Compute the result over 'top' */

                            inst_FN(ins_NN, opr->gtRegNum + genFPstkLevel);
                        }
                    }
                    else if  (opr->gtFlags & GTF_REG_DEATH)
                    {
                        /* Only 'opr' dies here */

                        assert(opr->gtRegNum == 0);
                        assert(top->gtRegNum  > 0);

                        /* Record the fact that 'opr' is dead */

                        genFPregVarDeath(opr);
                        genFPstkLevel++;

                        /* If there are no temps on the stack things are great,
                           we just over-write 'opr' with the result, otherwise shift 'opr' up */

                        genFPmovRegTop();

                        /* Perform the operation with the other register, over-write 'opr'.
                           Since opr's lifetime is nested within top's but top is first in
                           the evaluation order, we need to access top using the depth before
                           we did genFPstkLevel++ on opr's death. Hence "-1" */

                        inst_FN(ins_RN, top->gtRegNum + genFPstkLevel - 1);
                    }
                    else
                    {
                        /* None of the operands goes dead */

                        assert(opr->gtRegNum != top->gtRegNum);

                        /* Make a copy of 'top' on TOS */

                        genCodeForTreeFlt(top, roundTop);

                        /* Perform the operation with the other operand */

                        inst_FN(ins_NN, opr->gtRegNum + genFPstkLevel);
                    }

                    goto DONE_FP_BINOP;
                }
                else
                {
                    /* 'top' is in a register, 'opr' is not */

                    if  (top->gtFlags & GTF_REG_DEATH)
                    {
                        assert(top->gtRegNum == 0);

                        /* Mark top as dead, i.e becomes a temp, and bubble it to the TOS */

                        genFPregVarDeath(top);
                        genFPstkLevel++;

                        genFPmovRegTop();

                        goto DONE_FP_OP1;
                    }
                    else
                    {
                        // Does top go dead somewhere inside of opr (eg. a+(a*2.0)). If so
                        // we have to handle it in a special way

                        unsigned index = lvaTable[top->gtRegVar.gtRegVar].lvVarIndex;

                        if (genVarIndexToBit(index) & opr->gtLiveSet)
                        {
                            // top reg stays alive. As we do the operation after the
                            // right hand side of the tree has been computed, we have
                            // to take in account any fp enreg vars that may have been
                            // born or died in the right hand side  (as the gtRegNum gives
                            // us the number at the evaluation point only). To do this we 
                            // just take the difference between after and before the evaluation
                            // of the right hand side.

                            int iFPEnregBefore=genFPregCnt;

                            genCodeForTreeFlt(opr, genShouldRoundFP());

                            int iFPEnregAfter=genFPregCnt;
                            
                            inst_FN(ins_RN, top->gtRegNum + genFPstkLevel +
                                    (iFPEnregAfter-iFPEnregBefore) );                                                            
                        }
                        else
                        {
                            // top reg will die in opr, so have to load it again, as opr will
                            // modify the value of top while it operates with it in the evaluation
                            // stack (if it wasn't operated on, it opr would also be a REG_VAR).
                            genFPregVarLoad(top);
                            genCodeForTreeFlt(opr, genShouldRoundFP());

                            // Generate instruction, top will be in ST(1) and we will pop ST(0), 
                            // so we do the op targeting ST(1) and popping ST(0)
                            inst_FS(ins_NP, 1);

                            // Take off one element out of the evaluation stack
                            genFPstkLevel--;
                        }                        
                    }

                    goto DONE_FP_BINOP;
                }
            }
            else if (opr->gtOper == GT_REG_VAR)
            {
                /* 'opr' is in a register, 'top' is not - need to compute 'top' first */

                genCodeForTreeFlt(top, roundTop);

                if  (opr->gtFlags & GTF_REG_DEATH)
                {
                    /* 'opr' dies here - Compute the result over-writting 'opr' and popping 'top' */

                    assert(opr->gtRegNum == 0);
                    assert(genFPstkLevel >= 1);

                    inst_FS(ins_RP, genFPstkLevel);
                    genFPstkLevel++;

                    /* Record the fact that 'opr' is now dead */

                    genFPregVarDeath(opr);
                    genFPstkLevel--;

                    /* If there are temps above the result we have to bubble it to the top */

                    genFPmovRegTop();
                }
                else
                {
                    inst_FN(ins_NN, opr->gtRegNum + genFPstkLevel);
                }

                goto DONE_FP_BINOP;
            }

            /* Compute the value of the initial operand onto the FP stack */

            genCodeForTreeFlt(top, roundTop);

            /* Special case: "x+x" or "x*x" */

            if  (top->OperIsLeaf() &&
                 opr->OperIsLeaf() && GenTree::Compare(top, opr))
            {
                /* Simply generate "ins ST(0)" */

                inst_FS(ins_NN);

                goto DONE_FP_BINOP;
            }

DONE_FP_OP1:

            /* Spill the stack (first operand) if the other operand contains
             * a call or we are in danger of overflowing the stack (i.e. we
             * must make room for the second operand by leaving at least one
             * slot free - for Risc code we must leave two slots free.
             */

            temp = 0;

            if  (opr->gtFlags & GTF_CALL)
            {
                /* We must spill the first operand */

                assert(genFPstkLevel == 1);
                temp = genSpillFPtos(top);
            }
            else if (genFPstkLevel + genFPregCnt >= FP_STK_SIZE - 1)
            {
                /* One or no slot left on the FPU stack - check if we need to spill */
                if (riscCode)
                {
                    assert(genFPstkLevel + genFPregCnt == FP_STK_SIZE - 1);

                    /* If second operand is not a leaf node we better spill */
                    if(!(opr->OperKind() & (GTK_LEAF | GTK_CONST)))
                        temp = genSpillFPtos(top);
                }
                else if (genFPstkLevel + genFPregCnt == FP_STK_SIZE)
                {
                    temp = genSpillFPtos(top);
                }
            }

            if  (riscCode)
            {
                genCodeForTreeFlt(opr, genShouldRoundFP()); addrReg = 0;

                opr = 0;
            }
            else
                opr = genMakeAddrOrFPstk(opr, &addrReg, genShouldRoundFP());

            /* Did we have to spill the first operand? */

            if  (temp)
            {
                instruction     ldi;

                /* Reverse the sense of the operation */

                ldi    = (tree->gtFlags & GTF_REVERSE_OPS) ? ins_NN : ins_RN;
                ins_NP = ins_RP;

                /*  Either reload the temp back onto the FP stack (if the other
                    operand is not itself on the FP stack), or just compute the
                    result directly from the temp (if the operand is on the FP
                    stack).
                 */

                if  (opr || riscCode)
                {
                    ldi = INS_fld;
                    genFPstkLevel++;
                }

                genReloadFPtos(temp, ldi);
            }

            if  (opr)
            {
                /* We have the address of the other operand */

                inst_FS_TT(ins_NN, opr);
            }
            else
            {
                /* The other operand is on the FP stack */

                if  (!temp || riscCode)
                {
                    inst_FS(ins_NP, 1);
                    genFPstkLevel--;
                }
            }

            genDoneAddressable(opr, addrReg, FREE_REG); assert(addrReg != 0xDDDD);

        DONE_FP_BINOP:

#if ROUND_FLOAT
            if  (roundResult && tree->gtType == TYP_FLOAT)
                genRoundFpExpression(tree);
#endif

            return;

#ifdef DEBUG

        case GT_MOD:
            assert(!"float modulo should have been converted into a helper call");

#endif

        case GT_ASG:

            if  ((op1->gtOper != GT_REG_VAR)     &&
                 (op2->gtOper == GT_CAST)        &&
                 (op1->gtType == op2->gtType)    &&
                 varTypeIsFloating(op2->gtCast.gtCastOp->TypeGet()))
            {
                /* We can discard the cast */
                op2 = op2->gtCast.gtCastOp;
            }

            size = EA_ATTR(genTypeSize(op1->gtType));
            offs = 0;

            if  (op1->gtOper == GT_LCL_VAR)
            {
#ifdef DEBUG
                LclVarDsc * varDsc = &lvaTable[op1->gtLclVar.gtLclNum];
                // No dead stores
                assert(!varDsc->lvTracked ||
                       (tree->gtLiveSet & genVarIndexToBit(varDsc->lvVarIndex)));
#endif

#ifdef DEBUGGING_SUPPORT

                /* For non-debuggable code, every definition of a lcl-var has
                 * to be checked to see if we need to open a new scope for it.
                 */

                if  ( opts.compScopeInfo &&
                     !opts.compDbgCode   && info.compLocalVarsCount > 0)
                {
                    siCheckVarScope(op1->gtLclVar.gtLclNum,
                                    op1->gtLclVar.gtLclILoffs);
                }
#endif
            }

            /* Is the value being assigned a variable, constant, or indirection? */

            assert(op2);
            switch (op2->gtOper)
            {
                long *  addr;
                float   f;

            case GT_CNS_DBL: 
                addr = (long*) &op2->gtDblCon.gtDconVal;
                if (op1->gtType == TYP_FLOAT)
                {
                    f = op2->gtDblCon.gtDconVal;
                    addr = (long*) &f;
                }

                if  (op1->gtOper == GT_REG_VAR)
                    break;

                addrReg = genMakeAddressable(op1, 0, FREE_REG);

                // Special idiom for zeroing a double
                if ( (*((__int64 *)&(op2->gtDblCon.gtDconVal)) == 0) &&
                     genTypeSize(op1->gtType) == 8)
                { 
                    // Will we overflow the stack? We shouldn't because
                    // the fpu enregistrator code assumes that op2 will be loaded
                    // to the fpu evaluation stack
                    assert(genFPstkLevel + genFPregCnt < FP_STK_SIZE);

                    instGen(INS_fldz);
                    inst_FS_TT(INS_fstp, op1);
                }
                // Moving 1.0 into a double is also easy 
                else if ( (*((__int64 *)&(op2->gtDblCon.gtDconVal)) == 0x3ff0000000000000) &&
                     genTypeSize(op1->gtType) == 8)
                { 
                    // Will we overflow the stack? We shouldn't because
                    // the fpu enregistrator code assumes that op2 will be loaded
                    // to the fpu evaluation stack
                    assert(genFPstkLevel + genFPregCnt < FP_STK_SIZE);

                    instGen(INS_fld1);
                    inst_FS_TT(INS_fstp, op1);
                }
                else
                {
                    do
                    {
                        inst_TT_IV(INS_mov, op1, *addr++, offs);
                        offs += sizeof(long);
                    }
                    while (offs < size);
                }

                genDoneAddressable(op1, addrReg, FREE_REG);

#if REDUNDANT_LOAD
                if (op1->gtOper != GT_LCL_VAR)
                    rsTrashAliasedValues(op1);
#endif
                return;

#if SPECIAL_DOUBLE_ASG

            case GT_IND:

                if  (op1->gtOper == GT_REG_VAR)
                    break;

                /* Process float indirections in the usual way */
                if (op1->gtType == TYP_FLOAT || op2->gtType == TYP_FLOAT)
                    break;

                /* This needs too many registers, especially when op1
                 * is an two register address mode */
                if (op1->gtOper == GT_IND)
                    break;

                /* If there are enough registers, process double mem->mem assignments
                 * with a register pair, to get pairing.
                 * @TODO [CONSIDER] [04/16/01] []: - check for Processor here???
                 */
                if (rsFreeNeededRegCount(RBM_ALL) > 3)
                {
                    genCodeForTreeLng(tree, RBM_ALL);
                    return;
                }

                /* Otherwise evaluate RHS to fp stack */
                break;

#endif

            case GT_REG_VAR:

                /* If the TOS is dying and being used for the assignment,
                   we can just leave it as is, and use it as op1 */

                if  ((op1->gtOper == GT_REG_VAR) &&
                     (op2->gtFlags & GTF_REG_DEATH) &&
                     op2->gtRegNum == 0 &&
                     genFPstkLevel)
                {
                    /* Record the fact that 'op2' is now dead */

                    genFPregVarDeath(op2);

                    /* Mark the target variable as live */

                    assert(op1->gtFlags & GTF_REG_BIRTH);

                    genFPregVarBirth(op1);

                    genUpdateLife(tree);
                    return;
                }

                break;

            case GT_LCL_VAR:
            case GT_LCL_FLD:
            case GT_CLS_VAR:

                if  (op1->gtOper == GT_REG_VAR)
                    break;

#if SPECIAL_DOUBLE_ASG

                /* If there are enough registers, process double mem->mem assignments
                 * with a register pair, to get pairing.
                 * @TODO [CONSIDER] [04/16/01] []: check for Processor here???
                 */

                if  (tree->gtType == TYP_DOUBLE && (op1->gtType == op2->gtType) && rsFreeNeededRegCount(RBM_ALL) > 1)
                {
                    genCodeForTreeLng(tree, RBM_ALL);
                    return;
                }

                /* Otherwise use only one register for the copy */

#endif
                {
                    assert(varTypeIsFloating(op1->gtType) && varTypeIsFloating(op2->gtType));
                    regNumber   regNo;

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, KEEP_REG);

                    /* Lock the address temporarily */

                    assert((rsMaskLock &  addrReg) == 0);
                            rsMaskLock |= addrReg;

                    /* Can we use the general purpose registers to do the copy? */
                    /* The types must match and there must be a free register   */

                    if  ((op1->gtType == op2->gtType) && rsRegMaskFree())
                    {
                        /* Yes, grab one */

                        regNo = rsPickReg(0);

                        /* Move the value through the register */

                        do
                        {
                            rsTrackRegTrash(regNo);    // not very smart, but ....

                            inst_RV_TT(INS_mov, regNo, op2, offs);
                            inst_TT_RV(INS_mov, op1, regNo, offs);

                            offs += sizeof(long);
                        }
                        while (offs < size);
                    }
                    else
                    {
                        /* No register available, transfer through FPU */

                        inst_FS_TT(INS_fld,  op2);
                        inst_FS_TT(INS_fstp, op1);
                    }

                    /* Unlock the register(s) holding the address */

                    assert((rsMaskLock &  addrReg) == addrReg);
                            rsMaskLock -= addrReg;

                    /* Free up anything that was tied up by the LHS */

                    genDoneAddressable(op1, addrReg, KEEP_REG);
                }

#if REDUNDANT_LOAD
                if (op1->gtOper != GT_LCL_VAR)
                    rsTrashAliasedValues(op1);
#endif
                return;

            case GT_POP:

                assert(op1->gtOper == GT_LCL_VAR);

                /* Generate 'pop [lclVar]' and 'pop [lclVar+4]' (if double) */

                genStackLevel -= sizeof(void*);
                inst_TT(INS_pop, op1, 0);
                genStackLevel += sizeof(void*);
                genSinglePop();

                if  (tree->gtType == TYP_DOUBLE)
                {
                    genStackLevel -= sizeof(void*);
                    inst_TT(INS_pop, op1, 4);
                    genStackLevel += sizeof(void*);
                    genSinglePop();
                }

                return;

            } // end switch (op2->gtOper)

            /* Is the LHS more complex than the RHS? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Is the RHS a surviving register variable at TOS? */

                if  ((op2->gtOper  == GT_REG_VAR  )      &&
                     (op2->gtFlags & GTF_REG_DEATH) == 0 &&
                     (op2->gtRegNum               ) == 0 &&
                     genFPstkLevel                  == 0 &&
                     op1->gtOper   != GT_REG_VAR  )
                {
                    /* The LHS better not contain a call */

                    assert((op1->gtFlags & GTF_CALL) == 0);

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, FREE_REG);

                    /* Store a copy of the register value into the target */

                    inst_FS_TT(INS_fst, op1);

                    /* We no longer need the target address */

                    genDoneAddressable(op1, addrReg, FREE_REG);

                    genUpdateLife(tree);
                    return;
                }

                /* Evaluate the RHS onto the FP stack.
                   We dont need to round it as we will be doing a spill for
                   the assignment anyway (unless op1 is a GT_REG_VAR) */

                roundTop = genShouldRoundFP() ? (op1->gtOper == GT_REG_VAR)
                                              : false;

                genCodeForTreeFlt(op2, roundTop);

                /* Does the target address contain a function call? */

                if  (op1->gtFlags & GTF_CALL)
                {
                    /* We must spill the new value - grab a temp */

                    temp = tmpGetTemp(op2->TypeGet());

                    /* Pop the value from the FP stack into the temp */

                    assert(genFPstkLevel == 1);
                    inst_FS_ST(INS_fstp, EA_ATTR(genTypeSize(op2->gtType)), temp, 0);
                    genTmpAccessCnt++;

                    genFPstkLevel--;

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, KEEP_REG);

                    /* UNDONE: Assign the value via simple moves through regs */

                    assert(genFPstkLevel == 0);

                    inst_FS_ST(INS_fld, EA_ATTR(genTypeSize(op2->gtType)), temp, 0);
                    genTmpAccessCnt++;

                    genFPstkLevel++;

                    inst_FS_TT(INS_fstp, op1);

                    /* We no longer need the temp */

                    tmpRlsTemp(temp);

                    /* Free up anything that was tied up by the target address */

                    genDoneAddressable(op1, addrReg, KEEP_REG);
#if REDUNDANT_LOAD
                    rsTrashAliasedValues(op1);
#endif
                }
                else
                {
                    assert(genFPstkLevel);

                    /* Has the target been enregistered on the FP stack? */

                    if  (op1->gtOper == GT_REG_VAR)
                    {
                        /* This better be marked as a birth */

                        assert(op1->gtFlags & GTF_REG_BIRTH);

                        /* Is the new value already in the right place (i.e top of stack)?
                         * If not bubble it to the bottom */

                        genFPmovRegBottom();

                        /* Mark the variable as live */

                        genFPregVarBirth(op1);

                        /* We've effectively consumed the FP value, i.e. genFPstkLevel only
                         * counts temps on the stack not enregistered variables */

                        genFPstkLevel--;

                        genUpdateLife(tree);
                        return;
                    }

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, FREE_REG);

                    /* Pop and store the new value into the target */

                    inst_FS_TT(INS_fstp, op1);

                    /* We no longer need the target address */

                    genDoneAddressable(op1, addrReg, FREE_REG);
#if REDUNDANT_LOAD
                    if (op1->gtOper != GT_LCL_VAR)
                        rsTrashAliasedValues(op1);
#endif
                }
            }
            else
            {
                assert(op1->gtOper != GT_REG_VAR);

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, RBM_ALL & ~op2->gtRsvdRegs, KEEP_REG);

                /* Is the RHS a register variable at the bottom of the stack? */

                if  (op2->gtOper == GT_REG_VAR &&
                     op2->gtRegNum + genFPstkLevel == 0)
                {
                    /* Store a copy of the RHS into the target */

                    ins_NN = INS_fst;

                    if  (op2->gtFlags & GTF_REG_DEATH)
                    {
                        /* The variable dies right here */

                        ins_NN = INS_fstp;

                        /* Record the fact that we're killing this var */

                        genFPregVarDeath(op2);
                    }

                    inst_FS_TT(ins_NN, op1);

                    /* This merely compensates for the decrement below */

                    genFPstkLevel++;
                }
                else
                {
                    /* Evaluate the RHS onto the FP stack */

                    genCodeForTreeFlt(op2, false);

                    /* Make sure the target is still addressable */

                    addrReg = genKeepAddressable(op1, addrReg);

                    /* Pop and store the new value into the target */

                    inst_FS_TT(INS_fstp, op1);
                }

                /* Free up anything that was tied up by the target address */

                genDoneAddressable(op1, addrReg, KEEP_REG);

#if REDUNDANT_LOAD
                if (op1->gtOper != GT_LCL_VAR)
                    rsTrashAliasedValues(op1);
#endif
            }

            genFPstkLevel--;

            genUpdateLife(tree);
            return;

        case GT_ASG_ADD:
        case GT_ASG_SUB:
        case GT_ASG_MUL:
        case GT_ASG_DIV:

            /* Make sure the instruction tables look correctly ordered */

            assert(FPmathRN[GT_ASG_ADD - GT_ASG_ADD] == INS_fadd  );
            assert(FPmathRN[GT_ASG_SUB - GT_ASG_ADD] == INS_fsubr );
            assert(FPmathRN[GT_ASG_MUL - GT_ASG_ADD] == INS_fmul  );
            assert(FPmathRN[GT_ASG_DIV - GT_ASG_ADD] == INS_fdivr );

            assert(FPmathRP[GT_ASG_ADD - GT_ASG_ADD] == INS_faddp );
            assert(FPmathRP[GT_ASG_SUB - GT_ASG_ADD] == INS_fsubrp);
            assert(FPmathRP[GT_ASG_MUL - GT_ASG_ADD] == INS_fmulp );
            assert(FPmathRP[GT_ASG_DIV - GT_ASG_ADD] == INS_fdivrp);

            ins_NN = (instruction)FPmathNN[oper - GT_ASG_ADD];
            ins_NP = (instruction)FPmathRP[oper - GT_ASG_ADD];

            ins_RN = (instruction)FPmathRN[oper - GT_ASG_ADD];
            ins_RP = (instruction)FPmathNP[oper - GT_ASG_ADD];

            if  ((op1->gtOper != GT_REG_VAR)     &&
                 (op2->gtOper == GT_CAST)        &&
                 (op1->gtType == op2->gtType)    &&
                 varTypeIsFloating(op2->gtCast.gtCastOp->TypeGet()))
            {
                /* We can discard the cast */
                op2 = op2->gtOp.gtOp1;
            }

            /* Is the value or the address to be computed first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Is the target a register variable? */

                if  (op1->gtOper == GT_REG_VAR)
                {
                    /* Is the RHS also a register variable? */

                    if  (op2->gtOper == GT_REG_VAR)
                    {
                        /* Is the source at the bottom of the stack? */

                        if  (op2->gtRegNum + genFPstkLevel == 0)
                        {
                            /* Is the RHS a dying register variable? */

                            if  (op2->gtFlags & GTF_REG_DEATH)
                            {
                                /* We'll pop the dead value off the FP stack */

                                inst_FS(ins_RP, op1->gtRegNum + 1);

                                /* Record the fact that 'op2' is now dead */

                                genFPregVarDeath(op2);
                            }
                            else
                            {
                                inst_FS(ins_RN, op1->gtRegNum);
                            }

                            genUpdateLife(tree);
                            return;
                        }

                        /* Is the destination at the bottom of the stack? */

                        if  (op1->gtRegNum + genFPstkLevel == 0)
                        {
                            unsigned    lvl = op2->gtRegNum + genFPstkLevel;

                            /* Simply compute the new value into the target */

                            if  ((op2->gtFlags & GTF_REG_DEATH) && lvl == 1)
                            {
                                /* @TODO [REVISIT] [04/16/01] []:  Will this be ever reached as op1's lifetime
                                   should be nested within op2's. */

                                /* Compute the new value into the target, popping the source */

                                inst_FN(ins_NP, lvl);

                                /* Record the fact that 'op2' is now dead */

                                genFPregVarDeath(op2);
                            }
                            else
                            {
                                /* Compute the new value into the target */

                                inst_FN(ins_NN, lvl);
                            }

                            genUpdateLife(tree);
                            return;
                        }
                    }

                    /* Compute the second operand onto the FP stack */

                    genCodeForTreeFlt(op2, genShouldRoundFP());

                    switch (oper)
                    {
                    case GT_ASG_ADD: ins_NN = INS_faddp; break;
                    case GT_ASG_SUB: ins_NN = INS_fsubp; break;
                    case GT_ASG_MUL: ins_NN = INS_fmulp; break;
                    case GT_ASG_DIV: ins_NN = INS_fdivp; break;
                    }

                    inst_FS(ins_NN, op1->gtRegNum + genFPstkLevel);

                    genFPstkLevel--;
                    genUpdateLife(tree);
                    return;
                }

                /* Compute the second operand onto the FP stack */

                genCodeForTreeFlt(op2, genShouldRoundFP());

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, RBM_ALL, KEEP_REG);
            }
            else
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, RBM_ALL & ~op2->gtRsvdRegs, KEEP_REG);

                /* For "lcl = ...." we always expect GTF_REVERSE to be set */

                assert(op1->gtOper != GT_REG_VAR);

                /* Is the RHS a register variable? */

                if  (op2->gtOper == GT_REG_VAR)
                {
                    /* The RHS is a register variable */

                    inst_FS_TT(INS_fld, op1);
                    genFPstkLevel++;

                    /* Does the regvar die here? */

                    if  (op2->gtFlags & GTF_REG_DEATH)
                    {
                        assert(op2->gtRegNum == 0);
                        assert(genFPstkLevel >= 1);

                        /* Can we pop the dead variable now? */

                        if  (genFPstkLevel == 1)
                        {
                            /* Compute&pop and store the result */

                            inst_FS   (ins_NP  ,   1);
                            inst_FS_TT(INS_fstp, op1);

                            /* Record the fact that 'op2' is now dead */

                            genFPregVarDeath(op2);

                            goto DONE_ASGOP;
                        }

                        /* The dead variable will need to be popped later */
                    }

                    inst_FN   (ins_NN     , op2->gtRegNum + genFPstkLevel);
                    inst_FS_TT(INS_fstp, op1);

                    goto DONE_ASGOP;
                }

                /* Compute the second operand onto the FP stack */

                genCodeForTreeFlt(op2, genShouldRoundFP());

                /* Make sure the target is still addressable */

                addrReg = genKeepAddressable(op1, addrReg);
            }

            /* Perform the operation on the old value and store the new value */

            if  (op1->gtOper == GT_REG_VAR)
            {
                inst_FS(ins_NP, op1->gtRegNum + genFPstkLevel); // @WRONG, but UNREACHABLE
            }
            else
            {
                if  (riscCode)
                {
                    inst_FS_TT(INS_fld , op1);
                    genFPstkLevel++;
                    inst_FS   (ins_NP    , 1);			
                    genFPstkLevel--;
                    inst_FS_TT(INS_fstp, op1);
                }
                else
                {
                    inst_FS_TT(ins_RN  , op1);
                    inst_FS_TT(INS_fstp, op1);
                }
            }

        DONE_ASGOP:

            genFPstkLevel--;

            /* Free up anything that is tied up by the address */

            genDoneAddressable(op1, addrReg, KEEP_REG);

#if REDUNDANT_LOAD
            if (op1->gtOper != GT_LCL_VAR)
                rsTrashAliasedValues(op1);
#endif
            genUpdateLife(tree);
            return;

        case GT_IND:

            /* Make sure the address value is 'addressable' */

            addrReg = genMakeAddressable(tree, 0, FREE_REG);

            /* Load the value onto the FP stack */

            inst_FS_TT(INS_fld, tree);
            genFPstkLevel++;

            genDoneAddressable(tree, addrReg, FREE_REG);

            return;

        case GT_NEG:

            /* fneg in place, since we have a last use reg var */
            genCodeForTreeFlt(op1, roundResult);

            instGen(INS_fchs);

            return;

        case GT_NOP:

            if  (tree->gtFlags & GTF_NOP_DEATH)
            {
                /* The operand must be a dying register variable */

                assert(op1->gtOper   == GT_REG_VAR);
                assert(op1->gtRegNum == 0);
                assert(genFPstkLevel == 0);

                /* Toss the variable by popping it away */

                inst_FS(INS_fstp, 0);

                /* Record that we're killing this var */

                genFPregVarDeath(op1);
            }
            else
            {
                genCodeForTreeFlt(tree, roundResult);
            }

            return;

#if INLINE_MATH

        case GT_MATH:

#if 0  /* We don't Exp because it gives incorrect answers for +Infinity and -Infinity */
            switch (tree->gtMath.gtMathFN)
            {
                GenTreePtr      tmp;
                bool            rev;

            case CORINFO_INTRINSIC_Exp:

                tmp = genMakeAddrOrFPstk(op1, &addrReg, false);

                instGen(INS_fldl2e);

                /* Mutliply by the operand */

                if  (tmp)
                    inst_FS_TT(INS_fmul , tmp);
                else
                    inst_FS   (INS_fmulp, 1);

                inst_FN(INS_fld  , 0);
                instGen(INS_frndint );
                inst_FN(INS_fxch , 1);
                inst_FN(INS_fsub , 1);
                instGen(INS_f2xm1   );
                instGen(INS_fld1    );
                inst_FS(INS_faddp, 1);
                instGen(INS_fscale  );
                inst_FS(INS_fstp,  1);

                /* If operand hasn't been already on the stack, adjust FP stack level */

                if  (tmp)
                    genFPstkLevel++;

                genDoneAddressable(op1, addrReg, FREE_REG);
                return;


            case CORINFO_INTRINSIC_Pow:

                /* Are we supposed to generate operand 2 first? */

                if  (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    top = op2;
                    opr = op1;
                    rev = true;
                }
                else
                {
                    top = op1;
                    opr = op2;
                    rev = false;
                }

                /* Compute the first operand */

                genCodeForTreeFlt(top, false);

                /* Does the other operand contain a call? */

                temp = 0;

                if  (opr->gtFlags & GTF_CALL)
                {
                    /* We must spill the first operand */

                    assert(genFPstkLevel == 1);
                    temp = genSpillFPtos(top);
                }

                genCodeForTreeFlt(opr, roundResult);

                /* Did we have to spill the first operand? */

                if  (temp)
                    genReloadFPtos(temp, INS_fld);

                /* Swap the operands if we loaded in reverse order */

                if  (rev)
                    inst_FN(INS_fxch, 1);

#if TGT_RISC
                assert(genNonLeaf);
#endif

                genEmitHelperCall(CPX_MATH_POW,
                                 0,             // argSize. Use 2*sizeof(double) if args on stack!!!
                                 sizeof(void*));// retSize

                genFPstkLevel--;
                return;
            }
#endif


            genCodeForTreeFlt(op1, roundResult);

//      CONSIDER:
//
//          Math_tan PROC NEAR
//           00020  dd 44 24 04 fld QWORD PTR _f$[esp-4]
//           00024  d9 f2       fptan
//           00026  dd d8       fstp    ST(0)
//
//          Math_atan PROC NEAR
//
//           00050  dd 44 24 04 fld QWORD PTR _f$[esp-4]
//           00054  d9 e8       fld1
//           00056  d9 f3       fpatan
//
//          Math_log PROC NEAR
//           00080  d9 ed       fldln2
//           00082  dd 44 24 04 fld QWORD PTR _f$[esp-4]
//           00086  d9 f1       fyl2x
//
//          Math_sqrt PROC NEAR
//           00090  dd 44 24 04 fld QWORD PTR _f$[esp-4]
//          00094  d9 fa       fsqrt
//
//          Math_atan2 PROC NEAR
//           00130  dd 44 24 04 fld QWORD PTR _f1$[esp-4]
//           00134  dd 44 24 0c fld QWORD PTR _f2$[esp-4]
//           00138  d9 f3       fpatan
//

        {
            static const
            BYTE        mathIns[] =
            {
                INS_fsin,
                INS_fcos,
                INS_fsqrt,
                INS_fabs,
                INS_frndint,
            };

            assert(mathIns[CORINFO_INTRINSIC_Sin ]  == INS_fsin );
            assert(mathIns[CORINFO_INTRINSIC_Cos ]  == INS_fcos );
            assert(mathIns[CORINFO_INTRINSIC_Sqrt]  == INS_fsqrt);
            assert(mathIns[CORINFO_INTRINSIC_Abs ]  == INS_fabs );
            assert(mathIns[CORINFO_INTRINSIC_Round] == INS_frndint);
            assert(tree->gtMath.gtMathFN < sizeof(mathIns)/sizeof(mathIns[0]));
            instGen((instruction)mathIns[tree->gtMath.gtMathFN]);

            return;

        }
#endif

        case GT_CAST:

#if ROUND_FLOAT
            
            /* Need to round result of casts in order to insure compliance with
               the spec */
            
            roundResult = true;
#endif
            /* What are we casting from? */

            switch (op1->gtType)
            {
            case TYP_BOOL:
            case TYP_BYTE:
            case TYP_UBYTE:
            case TYP_CHAR:
            case TYP_SHORT:

                /* Operand too small for 'fild', load it into a register */

                genCodeForTree(op1, 0);

#if ROUND_FLOAT
                /* no need to round, can't overflow float or dbl */
                roundResult = false;
#endif

                // Fall through, now the operand is in a register ...

            //
            // UNSIGNED_ISSUE : Implement casting
            //
            case TYP_INT:
            case TYP_BYREF:
            case TYP_LONG:

                /* Can't 'fild' a constant, it has to be loaded from memory */

                switch (op1->gtOper)
                {
                case GT_CNS_INT:
                    op1 = genMakeConst(&op1->gtIntCon.gtIconVal, sizeof(int ), TYP_INT , tree, false, true);
                    break;

                case GT_CNS_LNG:
                    op1 = genMakeConst(&op1->gtLngCon.gtLconVal, sizeof(long), TYP_LONG, tree, false, true);
                    break;
                }

                addrReg = genMakeAddressable(op1, 0, FREE_REG);

                /* Is the value now sitting in a register? */

                if  (op1->gtFlags & GTF_REG_VAL)
                {
                    /* We'll have to store the value into the stack */

                    size = EA_ATTR(roundUp(genTypeSize(op1->gtType)));
                    temp = tmpGetTemp(op1->TypeGet());

                    /* Move the value into the temp */

                    if  (op1->gtType == TYP_LONG)
                    {
                        regPairNo  reg = op1->gtRegPair;

                        // ISSUE: This code is pretty ugly, but straightforward
                        // 
                        // @TODO [CONSIDER] [04/16/01] []: 
                        // As long as we always reserve both dwords
                        // of a partially enregistered long,
                        // just "spill" the enregistered half!

                        if  (genRegPairLo(reg) == REG_STK)
                        {
                            regNumber rg1 = genRegPairHi(reg);

                            assert(rg1 != REG_STK);

                            /* Move enregistered half to temp */

                            inst_ST_RV(INS_mov, temp, 4, rg1, TYP_LONG);

                            /* Move lower half to temp via "high register" */

                            inst_RV_TT(INS_mov, rg1, op1, 0);
                            inst_ST_RV(INS_mov, temp, 0, rg1, TYP_LONG);

                            /* Reload transfer register */

                            inst_RV_ST(INS_mov, rg1, temp, 4, TYP_LONG);

                            genTmpAccessCnt += 4;
                        }
                        else if  (genRegPairHi(reg) == REG_STK)
                        {
                            regNumber rg1 = genRegPairLo(reg);

                            assert(rg1 != REG_STK);

                            /* Move enregistered half to temp */

                            inst_ST_RV(INS_mov, temp, 0, rg1, TYP_LONG);

                            /* Move high half to temp via "low register" */

                            inst_RV_TT(INS_mov, rg1, op1, 4);
                            inst_ST_RV(INS_mov, temp, 4, rg1, TYP_LONG);

                            /* Reload transfer register */

                            inst_RV_ST(INS_mov, rg1, temp, 0, TYP_LONG);

                            genTmpAccessCnt += 4;
                        }
                        else
                        {
                            /* Move the value into the temp */

                            inst_ST_RV(INS_mov, temp, 0, genRegPairLo(reg), TYP_LONG);
                            inst_ST_RV(INS_mov, temp, 4, genRegPairHi(reg), TYP_LONG);
                            genTmpAccessCnt += 2;

                        }
                        genDoneAddressable(op1, addrReg, FREE_REG);

                        /* Load the long from the temp */

                        inst_FS_ST(INS_fildl, size, temp, 0);
                        genTmpAccessCnt++;
                    }
                    else
                    {
                        /* Move the value into the temp */

                        inst_ST_RV(INS_mov  ,       temp, 0, op1->gtRegNum, TYP_INT);
                        genTmpAccessCnt++;

                        genDoneAddressable(op1, addrReg, FREE_REG);

                        /* Load the integer from the temp */

                        inst_FS_ST(INS_fild , size, temp, 0);
                        genTmpAccessCnt++;
                    }

                    /* We no longer need the temp */

                    tmpRlsTemp(temp);
                }
                else
                {
                    /* Load the value from its address */

                    if  (op1->gtType == TYP_LONG)
                        inst_TT(INS_fildl, op1);
                    else
                        inst_TT(INS_fild , op1);

                    genDoneAddressable(op1, addrReg, FREE_REG);
                }

                genFPstkLevel++;

#if ROUND_FLOAT
                /* integer to fp conversions can overflow. roundResult
                 * is cleared above in cases where it can't
                 */
                if (roundResult && 
                    ((tree->gtType == TYP_FLOAT) ||
                     ((tree->gtType == TYP_DOUBLE) && (op1->gtType == TYP_LONG))))
                    genRoundFpExpression(tree);
#endif

                break;

            case TYP_FLOAT:
                /* This is a cast from float to double. */

                /* Note that conv.r(r4/r8) and conv.r8(r4/r9) are indistinguishable
                   as we will generate GT_CAST-TYP_DOUBLE for both. This would
                   cause us to truncate precision in either case. However,
                   conv.r was needless in the first place, and should have
                   been removed */

                
                genCodeForTreeFlt(op1, true);         // Trucate its precision

                break;

            case TYP_DOUBLE:

                /* This is a cast from double to float or double */
                /* Load the value, store as destType, load back */

                genCodeForTreeFlt(op1, false);

                genRoundFpExpression(op1, tree->TypeGet());

                break;

            default:
                assert(!"unsupported cast to float");
            }

            genUpdateLife(tree);
            return;

        case GT_RETURN:

            assert(op1);

            /* Compute the result onto the FP stack */

            if (op1->gtType == TYP_FLOAT)
            {
#if ROUND_FLOAT
                bool   roundOp1 = false;

                switch (getRoundFloatLevel())
                {
                case ROUND_NEVER:
                    /* No rounding at all */
                    break;

                case ROUND_CMP_CONST:
                    break;

                case ROUND_CMP:
                    /* Round all comparands and return values*/
                    roundOp1 = true;
                    break;

                case ROUND_ALWAYS:
                    /* Round everything */
                    roundOp1 = true;
                    break;

                default:
                    assert(!"Unsupported Round Level");
                    break;
                }
#endif
                genCodeForTreeFlt(op1, roundOp1);
            }
            else
            {
                assert(op1->gtType == TYP_DOUBLE);
                genCodeForTreeFlt(op1, false);

#if ROUND_FLOAT
                if ((op1->gtOper == GT_CAST) && (op1->gtCast.gtCastOp->gtType == TYP_LONG))
                    genRoundFpExpression(op1);
#endif
            }

            /* Make sure we pop off any dead FP regvars */

            if  (genFPregCnt)
                genFPregVarKill(0, true);

            /* The return effectively pops the value */

            genFPstkLevel--;
            return;

#if INLINING
        case GT_QMARK:
            assert(!"inliner-generated ?: for floats/doubles NYI");
            return;
#endif

        case GT_BB_COLON:

            /* Compute the result onto the FP stack */

            genCodeForTreeFlt(op1, roundResult);

            /* Decrement the FP stk level here so that we don't end up popping the result */
            /* the GT_BB_QMARK will increment the stack to rematerialize the result */
            genFPstkLevel--;

            return;

        case GT_COMMA:
            if (tree->gtFlags & GTF_REVERSE_OPS)
            {
                TempDsc  *      temp = 0;

                // generate op2
                genCodeForTreeFlt(op2, roundResult);
                genUpdateLife(op2);

                // This can happen if strict effects is turned off
                if  (op1->gtFlags & GTF_CALL)
                {
                    /* We must spill the first operand */
                    assert(genFPstkLevel == 1);
                    temp = genSpillFPtos(op2);
                }

                genEvalSideEffects(op1);
                
                if  (temp)
                {
                    genReloadFPtos(temp, INS_fld);
                    genFPstkLevel++;
                }

                genUpdateLife (tree);                

                return;
            }
            else
            {
                assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

                /* Check for special case: "lcl = val , lcl" */

                if  (op1->gtOper == GT_ASG     &&
                    op1->gtType == TYP_DOUBLE && op2->            gtOper == GT_LCL_VAR
                                            && op1->gtOp.gtOp1->gtOper == GT_LCL_VAR)
                {
                    if  (op2            ->gtLclVar.gtLclNum ==
                        op1->gtOp.gtOp1->gtLclVar.gtLclNum)
                    {
                        /* Evaluate the RHS onto the FP stack */

                        genCodeForTreeFlt(op1->gtOp.gtOp2, false);

                        /* Store the new value into the target */

                        if  (op2->gtOper == GT_REG_VAR)
                        {
                            inst_FS   (INS_fst, op2->gtRegNum + genFPstkLevel);
                        }
                        else
                        {
                            inst_FS_TT(INS_fst, op2);
                        }

                        /* We're leaving the new value on the FP stack */

                        genUpdateLife(tree);
                        return;
                    }
                }

                /* Generate side effects of the first operand */

#if 0
            // op1 is required to have a side effect, otherwise
            // the GT_COMMA should have been morphed out
            assert(op1->gtFlags & (GTF_GLOB_EFFECT | GTFD_NOP_BASH));
#endif

                genEvalSideEffects(op1);
                genUpdateLife (op1);

                /* Now generate the second operand, i.e. the 'real' value */

                genCodeForTreeFlt(op2, roundResult);

                genUpdateLife(tree);
                return;
            }

        regNumber   reg;

        case GT_CKFINITE:

            /* We use the fact that the exponent for both the Infinities
             * and any NaN is all 1's
             */

            // Make it addressable if we can

            op2 = genMakeAddrOrFPstk(op1, &addrReg, roundResult);

            reg = rsGrabReg(RBM_ALL);

            // Offset of the DWord containing the exponent

            offs = (op1->gtType == TYP_FLOAT) ? 0 : sizeof(int);

            if (op2)
            {
                /* If it is addressable, we dont have to spill it to memory
                 * to load it into a general-purpose register. But we do
                 * have to load it onto the FP-stk
                 */

                genCodeForTreeFlt(op2, roundResult);

                // Load the DWord containing the exponent into a register

                inst_RV_TT(INS_mov, reg, op2, offs, EA_4BYTE);

                genDoneAddressable(op2, addrReg, FREE_REG);

                op2 = 0;
            }
            else
            {
                temp          = tmpGetTemp (op1->TypeGet());
                emitAttr size = EA_ATTR(genTypeSize(op1->TypeGet()));

                /* Store the value from the FP stack into the temp */

                genEmitter->emitIns_S(INS_fst, size, temp->tdTempNum(), 0);

                genTmpAccessCnt++;

                // Load the DWord containing the exponent into a general reg.

                inst_RV_ST(INS_mov, reg, temp, offs, op1->TypeGet(), EA_4BYTE);

                tmpRlsTemp(temp);
            }

            // 'reg' now contains the DWord containing the exponent

            rsTrackRegTrash(reg);

            // Mask of exponent with all 1's - appropriate for given type

            int expMask;
            expMask = (op1->gtType == TYP_FLOAT) ? 0x7F800000   // TYP_FLOAT
                                                 : 0x7FF00000;  // TYP_DOUBLE

            // Check if the exponent is all 1's

            inst_RV_IV(INS_and, reg, expMask);
            inst_RV_IV(INS_cmp, reg, expMask);

            // If exponent was all 1's, we need to throw ArithExcep

            genJumpToThrowHlpBlk(EJ_je, ACK_ARITH_EXCPN);

            genUpdateLife(tree);
            return;

#ifdef DEBUG
        default:
            gtDispTree(tree); assert(!"unexpected/unsupported float operator");
#endif
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_CALL:
        genCodeForCall(tree, true);
        if (roundResult && tree->gtType == TYP_FLOAT)
            genRoundFpExpression(tree);
        break;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected/unsupported float operator");
    }

#else//TGT_x86

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        assert(!"fp const");
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:

            /* Has this local been enregistered? */

#if!CPU_HAS_FP_SUPPORT
            if (!genMarkLclVar(tree))
#endif
            {
#ifdef  DEBUG
                gtDispTree(tree);
#endif
                assert(!"fp lclvar");
                return;
            }

#if!CPU_HAS_FP_SUPPORT

            assert(tree->gtOper == GT_REG_VAR);

            // Fall through ....

        case GT_REG_VAR:
            return;
#endif

        case GT_CLS_VAR:
        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected FP leaf");
        }
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        GenTreePtr      op1 = tree->gtOp.gtOp1;

        switch (oper)
        {
        case GT_RETURN:

            /* Generate the return value into the return register */

            genComputeReg(op1, RBM_INTRET, EXACT_REG, FREE_REG);

            /* The result must now be in the return register */

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_INTRET);

            return;

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"gen SH-3 code");
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_CALL:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"gen FP call");

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"gen RISC FP code");
    }

#endif

}

/*****************************************************************************/
#endif//CPU_HAS_FP_SUPPORT
/*****************************************************************************
 *
 *  Generate a table switch - the switch value (0-based) is in register 'reg'.
 */

void            Compiler::genTableSwitch(regNumber      reg,
                                         unsigned       jumpCnt,
                                         BasicBlock **  jumpTab,
                                         bool           chkHi,
                                         int            prefCnt,
                                         BasicBlock *   prefLab,
                                         int            offset)
{
    unsigned    jmpTabOffs;
    unsigned    jmpTabBase;

    assert(jumpCnt > 1);

    assert(chkHi);

    /* Is the number of cases right for a test and jump switch? */

    if  (false &&
         jumpCnt > 2 &&
         jumpCnt < 5 && (rsRegMaskFree() & genRegMask(reg)))
    {
        /* Does the first case label follow? */

        if  (compCurBB->bbNext == jumpTab[0])
        {
            /* Check for the default case */

            inst_RV_IV(INS_cmp, reg, jumpCnt - 1);
            inst_JMP  (EJ_jae, jumpTab[jumpCnt-1], false, false, true);

            /* No need to jump to the first case */

            jumpCnt -= 2;
            jumpTab += 1;

            /* Generate a series of "dec reg; jmp label" */

            assert(jumpCnt);

            for (;;)
            {
                genIncRegBy(reg, -1, NULL, TYP_INT);

                if (--jumpCnt == 0)
                    break;

                inst_JMP(EJ_je, *jumpTab++, false, false, true);
            }

            inst_JMP(EJ_je, *jumpTab, false, false, false);
        }
        else
        {
            bool        jmpDef;

            /* Check for case0 first */

            inst_RV_RV(INS_test, reg, reg);
            inst_JMP  (EJ_je, *jumpTab, false, false, true);

            /* No need to jump to the first case or the default */

            jumpCnt -= 2;
            jumpTab += 1;

            /* Are we going to need to jump to the defualt? */

            jmpDef = true;

            if  (compCurBB->bbNext == jumpTab[jumpCnt])
                jmpDef = false;

            /* Generate a series of "dec reg; jmp label" */

            assert(jumpCnt);

            for (;;)
            {
                genIncRegBy(reg, -1, NULL, TYP_INT);

                if  (--jumpCnt == 0)
                    break;

                inst_JMP(EJ_je, *jumpTab++, false, false, true);
            }

            if (jmpDef)
            {
                inst_JMP(EJ_je,  *jumpTab++, false, false,  true);
                inst_JMP(EJ_jmp, *jumpTab  , false, false, false);
            }
            else
            {
                inst_JMP(EJ_je,  *jumpTab  , false, false, false);
            }
        }

        return;
    }

    /* First take care of the default case */

    if  (chkHi)
    {
#if TGT_x86
        inst_RV_IV(INS_cmp, reg, jumpCnt - 1);
        inst_JMP  (EJ_jae, jumpTab[jumpCnt-1], false, false, true);
#else
        genCompareRegIcon(reg, jumpCnt-2, true, GT_GT);
        genEmitter->emitIns_J(INS_bt, false, false, jumpTab[jumpCnt-1]);
#endif
    }

    /* Include the 'prefix' count in the label count */

    jumpCnt += prefCnt;

#if TGT_x86

    /* Generate the jump table contents */

    jmpTabBase = genEmitter->emitDataGenBeg(sizeof(void *)*(jumpCnt - 1), false, true, true);
    jmpTabOffs = 0;

#ifdef  DEBUG

    static  unsigned    jtabNum; ++jtabNum;

    if  (dspCode)
        printf("\n      J_%u_%u LABEL   DWORD\n", Compiler::s_compMethodsCount, jtabNum);

#endif

    while (--jumpCnt)
    {
        BasicBlock *    target = (prefCnt > 0) ? prefLab : *jumpTab++;

        assert(target->bbFlags & BBF_JMP_TARGET);

#ifdef  DEBUG
        if  (dspCode)
            printf("            DD      L_M%03u_BB%02u\n", Compiler::s_compMethodsCount, target->bbNum);
#endif

        genEmitter->emitDataGenData(jmpTabOffs, target);

        jmpTabOffs += sizeof(void *);

        prefCnt--;
    };

    genEmitter->emitDataGenEnd();
    genEmitter->emitIns_IJ(EA_4BYTE_DSP_RELOC, (emitRegs)reg, jmpTabBase, offset);

#elif   TGT_SH3

    /* The emitter does all the hard work of generating the table jump */

    genEmitter->emitIns_JmpTab((emitRegs)reg, jumpCnt-1, jumpTab);

#else
#error  Unexpected target
#endif

}

/*****************************************************************************
 *
 *  Generate code for a switch statement.
 */

void                Compiler::genCodeForSwitch(GenTreePtr tree)
{
    unsigned        jumpCnt;
    BasicBlock * *  jumpTab;

    GenTreePtr      oper;
    regNumber       reg;

    assert(tree->gtOper == GT_SWITCH);
    oper = tree->gtOp.gtOp1;
    assert(oper->gtType <= TYP_INT);

    /* Get hold of the jump table */

    assert(compCurBB->bbJumpKind == BBJ_SWITCH);

    jumpCnt = compCurBB->bbJumpSwt->bbsCount;
    jumpTab = compCurBB->bbJumpSwt->bbsDstTab;

    /* Compute the switch value into some register */

#if TGT_SH3
    genComputeReg (oper, RBM_ALL & ~RBM_r00, EXACT_REG, FREE_REG);
#else
    genCodeForTree(oper, 0);
#endif

    /* Get hold of the register the value is in */

    assert(oper->gtFlags & GTF_REG_VAL);
    reg = oper->gtRegNum;

    genTableSwitch(reg, jumpCnt, jumpTab, true);
}

/*****************************************************************************/
#if     TGT_RISC
/*****************************************************************************
 *
 *  Generate a call - this is accomplished by loading the target address
 *  into some temp register and calling through it.
 */

void                Compiler::genCallInst(gtCallTypes callType,
                                          void   *    callHand,
                                          size_t      argSize,
                                          int         retSize)
{
    assert(genNonLeaf);
    assert(callType != CT_INDIRECT);

    /* Grab a temp register for the address */

    regNumber       areg = rsGrabReg(RBM_ALL);

    /* Load the method address into the register */

    genEmitter->emitIns_R_LP_M((emitRegs)areg,
                                callType,
                                callHand);

    // UNDONE: Track method addresses to reuse them!!!!

    rsTrackRegTrash(areg);

    /* Call through the address */

    genEmitter->emitIns_Call(argSize,
                             retSize,
#if     TRACK_GC_REFS
                             gcVarPtrSetCur,
                             gcRegGCrefSetCur,
                             gcRegByrefSetCur,
#endif
                             false,
                             (emitRegs)areg);
}

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************
 *  Emit a call to a helper function.
 */

inline
void        Compiler::genEmitHelperCall(unsigned    helper,
                                        int         argSize,
                                        int         retSize)
{
    // Can we call the helper function directly

    emitter::EmitCallType emitCallType;

    void * ftnAddr, **pFtnAddr;
    ftnAddr = eeGetHelperFtn(info.compCompHnd, (CorInfoHelpFunc)helper, &pFtnAddr);
    assert((!ftnAddr) != (!pFtnAddr));

    emitCallType = ftnAddr ? emitter::EC_FUNC_TOKEN
                           : emitter::EC_FUNC_TOKEN_INDIR;

    genEmitter->emitIns_Call(emitCallType,
                             eeFindHelper(helper),
                             argSize,
                             retSize,
                             gcVarPtrSetCur,
                             gcRegGCrefSetCur,
                             gcRegByrefSetCur);

    // @TODO [REVISIT] [04/16/01] []:  this turns off load suppression across all helpers.
    // some helpers are special, and we can do better.  Not
    // clear if it is worth it.
    rsTrashRegSet(RBM_CALLEE_TRASH);
}

/*****************************************************************************
 *
 *  Push the given argument list, right to left; returns the total amount of
 *  stuff pushed.
 */

size_t              Compiler::genPushArgList(GenTreePtr   objRef,
                                             GenTreePtr   regArgs,
                                             unsigned     encodeMask,
                                             GenTreePtr * realThis)
{
    size_t          size = 0;

    regMaskTP       addrReg;

    size_t          opsz;
    var_types       type;
    GenTreePtr      args  = objRef;
    GenTreePtr      list  = args;

#if STK_FASTCALL
    size_t          argBytes  = 0;
#endif

    struct
    {
        GenTreePtr  node;
        regNumber   regNum;
    }
    regArgTab[MAX_REG_ARG];

AGAIN:

#ifdef DEBUG
    addrReg = 0xBEEFCAFE;   // to detect uninitialized use
#endif

    /* Get hold of the next argument value */

    args = list;
    if  (args->gtOper == GT_LIST)
    {
        args = list->gtOp.gtOp1;
        list = list->gtOp.gtOp2;
    }
    else
    {
        list = 0;
    }

    /* See what type of a value we're passing */

    type = args->TypeGet();

    opsz = genTypeSize(genActualType(type));

#if STK_FASTCALL

    argBytes = opsz;

    /* Register arguments are typed as "void" */

    if  (!argBytes)
    {

#if!OPTIMIZE_TAIL_REC
        assert(gtIsaNothingNode(args));
#else
        if    (gtIsaNothingNode(args))
#endif
        {
            assert(args->gtFlags & GTF_REG_ARG);

            // ISSUE: What about 64-bit register args? There appears to be
            // ISSUE: no obvious way of getting hold of the argument type.

            argBytes = sizeof(int);
        }
    }

#endif

    switch (type)
    {
    case TYP_BOOL:
    case TYP_BYTE:
    case TYP_SHORT:
    case TYP_CHAR:
    case TYP_UBYTE:

        /* Don't want to push a small value, make it a full word */

        genCodeForTree(args, 0);

        // Fall through, now the value should be in a register ...

    case TYP_INT:
    case TYP_REF:
    case TYP_BYREF:
#if !   CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
#endif

        if (args->gtFlags & GTF_REG_ARG)
        {
            /* one more argument is passed in a register */
            assert(rsCurRegArg < MAX_REG_ARG);

            /* arg is passed in the register, nothing on the stack */

            opsz = 0;
        }


        /* Is this value a handle? */

        if  (args->gtOper == GT_CNS_INT &&
             (args->gtFlags & GTF_ICON_HDL_MASK))
        {

#if     SMALL_TREE_NODES
            // GTF_ICON_HDL_MASK implies GTF_NODE_LARGE,
            //   unless we have a GTF_ICON_FTN_ADDR
            assert((args->gtFlags & GTF_NODE_LARGE)     ||
                   (args->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_FTN_ADDR);
#endif
#if !   INLINING
            assert(args->gtIntCon.gtIconCls == info.compScopeHnd);
#endif

            /* Emit a fixup for the push instruction */

            inst_IV_handle(INS_push, args->gtIntCon.gtIconVal, args->gtFlags,
#if defined(JIT_AS_COMPILER) || defined (LATE_DISASM)
                           args->gtIntCon.gtIconCPX, args->gtIntCon.gtIconCls);
#else
                           0, 0);
#endif
            genSinglePush(false);

            addrReg = 0;
            break;
        }

#if     TGT_x86

        /* Is the value a constant? */

        if  (args->gtOper == GT_CNS_INT)
        {

#if     REDUNDANT_LOAD
            regNumber       reg = rsIconIsInReg(args->gtIntCon.gtIconVal);

            if  (reg != REG_NA)
            {
                inst_RV(INS_push, reg, TYP_INT);
            }
            else
#endif
            {
                inst_IV(INS_push, args->gtIntCon.gtIconVal);
            }

            /* If the type is TYP_REF, then this must be a "null". So we can
               treat it as a TYP_INT as we dont need to report it as a GC ptr */

            assert(args->TypeGet() == TYP_INT ||
                   (varTypeIsGC(args->TypeGet()) && args->gtIntCon.gtIconVal == 0));

            genSinglePush(false);

            addrReg = 0;
            break;
        }

#endif

        if (args->gtFlags & GTF_REG_ARG)
        {
            /* This must be a register arg temp assignment */

            assert(args->gtOper == GT_ASG);

            /* Evaluate it to the temp */

            genCodeForTree(args, 0);

            /* Increment the current argument register counter */

            rsCurRegArg++;

            addrReg = 0;
        }
        else
#if     TGT_x86
        if  (0)
        {
            // @TODO [CONSIDER] [04/16/01] []: 
            // Use "mov reg, [mem] ; push reg" when compiling for
            // speed (not size) and if the value isn't already in
            // a register and if a register is available (is this
            // true on the P6 as well, though?).

            genCompIntoFreeReg(args, RBM_ALL, KEEP_REG);
            assert(args->gtFlags & GTF_REG_VAL);
            addrReg = genRegMask(args->gtRegNum);
            inst_RV(INS_push, args->gtRegNum, args->TypeGet());
            genSinglePush((type == TYP_REF ? true : false));
            rsMarkRegFree(addrReg);
        }
        else
#endif
        {
            /* This is a 32-bit integer non-register argument */

#if     STK_FASTCALL

            /* Pass this argument on the stack */

            genCompIntoFreeReg(args, RBM_ALL, KEEP_REG);
            assert(args->gtFlags & GTF_REG_VAL);
            addrReg = genRegMask(args->gtRegNum);

#if     TGT_RISC
            // UNDONE: Need to handle large stack offsets!!!!!
            assert(rsCurArgStkOffs <= MAX_SPBASE_OFFS);
            genEmitter->emitIns_A_R((emitRegs)args->gtRegNum, rsCurArgStkOffs);
#else
#error  Unexpected target
#endif

            rsMarkRegFree(addrReg);

#else

            addrReg = genMakeRvalueAddressable(args, 0, KEEP_REG);
#if     TGT_x86
            inst_TT(INS_push, args);
#else
#error  Unexpected target
#endif
            genSinglePush((type == TYP_REF ? true : false));
            genDoneAddressable(args, addrReg, KEEP_REG);
#endif

        }
        break;

    case TYP_LONG:
#if !   CPU_HAS_FP_SUPPORT
    case TYP_DOUBLE:
#endif

#if     TGT_x86

        /* Is the value a constant? */

        if  (args->gtOper == GT_CNS_LNG)
        {
            inst_IV(INS_push, (long)(args->gtLngCon.gtLconVal >> 32));
            genSinglePush(false);
            inst_IV(INS_push, (long)(args->gtLngCon.gtLconVal      ));
            genSinglePush(false);

            addrReg = 0;
        }
        else
        {
            addrReg = genMakeAddressable(args, 0, FREE_REG);

            inst_TT(INS_push, args, sizeof(int));
            genSinglePush(false);
            inst_TT(INS_push, args);
            genSinglePush(false);
        }

#else

        regPairNo       regPair;

        /* Generate the argument into some register pair */

        genComputeRegPair(args, REG_PAIR_NONE, RBM_NONE, KEEP_REG, false);
        assert(args->gtFlags & GTF_REG_VAL);
        regPair = args->gtRegPair;
        addrReg = genRegPairMask(regPair);

        // UNDONE: Need to handle large stack offsets!!!!!

        assert(rsCurArgStkOffs+4 <= MAX_SPBASE_OFFS);

        genEmitter->emitIns_A_R((emitRegs)genRegPairLo(regPair), rsCurArgStkOffs);
        genEmitter->emitIns_A_R((emitRegs)genRegPairHi(regPair), rsCurArgStkOffs+4);

        genReleaseRegPair(args);

#endif

        break;

#if     CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
    case TYP_DOUBLE:
#endif

#if     TGT_x86

        /* Special case constants and casts from double */

        switch (args->gtOper)
        {
            GenTreePtr      temp;

        case GT_CNS_DBL:
            {
            float f;
            long* addr;
            if (args->TypeGet() == TYP_FLOAT) {
                f = args->gtDblCon.gtDconVal;
                addr = (long*) &f;
            }
            else {
                addr = (long *)&args->gtDblCon.gtDconVal;
                inst_IV(INS_push, addr[1]);
                genSinglePush(false);
            }
            inst_IV(INS_push, *addr);
            genSinglePush(false);
            addrReg = 0;
            }
            break;

        case GT_CAST:

            /* Is the value a cast from double ? */

            if ((args->gtOper                  == GT_CAST   ) &&
                (args->gtCast.gtCastOp->gtType == TYP_DOUBLE)    )
            {
                /* Load the value onto the FP stack */

                genCodeForTreeFlt(args->gtCast.gtCastOp, false);

                /* Go push the value as a float/double */

                addrReg = 0;
                goto PUSH_FLT;
            }

            // Fall through ....

        default:

            temp = genMakeAddrOrFPstk(args, &addrReg, false);
            if  (temp)
            {
                unsigned        offs;

                /* We have the address of the float operand, push its bytes */

                offs = opsz; assert(offs % sizeof(long) == 0);
                do
                {
                    offs -= sizeof(int);
                    inst_TT(INS_push, temp, offs);
                    genSinglePush(false);
                }
                while (offs);
            }
            else
            {
                /* The argument is on the FP stack -- pop it into [ESP-4/8] */

            PUSH_FLT:

                inst_RV_IV(INS_sub, REG_ESP, opsz);

                genSinglePush(false);
                if  (opsz == 2*sizeof(unsigned))
                    genSinglePush(false);

                genEmitter->emitIns_AR_R(INS_fstp, EA_ATTR(opsz), SR_NA, SR_ESP, 0);

                genFPstkLevel--;
            }

            gcMarkRegSetNpt(addrReg);
            break;
        }

#else

        assert(!"need non-x86 code to pass FP argument");

#endif

        break;

    case TYP_VOID:

        /* Is this a nothing node, defered register argument? */

        if (args->gtFlags & GTF_REG_ARG)
        {
            /* increment the register count and continue with the next argument */
            assert(gtIsaNothingNode(args));
            rsCurRegArg++;

            assert(opsz == 0);

            addrReg = 0;
            break;
        }

        // fall through...

#if OPTIMIZE_TAIL_REC

        /* This is the last argument for a tail-recursive call */

        if  (args->gtOper == GT_ASG)
            args->gtType = args->gtOp.gtOp1->gtType;

        genCodeForTree(args, 0);

        if  (args->gtOper == GT_ASG)
            args->gtType = TYP_VOID;

        /* The call above actually popped any preceding arguments, BTW */

        opsz    = 0;
        addrReg = 0;
        break;

#endif

    case TYP_STRUCT:
    {
        GenTree* arg = args;
        while(arg->gtOper == GT_COMMA)
        {
            GenTreePtr op1 = arg->gtOp.gtOp1;
#if 0
            // op1 is required to have a side effect, otherwise
            // the GT_COMMA should have been morphed out
            assert(op1->gtFlags & (GTF_GLOB_EFFECT | GTFD_NOP_BASH));
#endif
            genEvalSideEffects(op1);
            genUpdateLife(op1);
            arg = arg->gtOp.gtOp2;
        }

        assert(arg->gtOper == GT_LDOBJ || arg->gtOper == GT_MKREFANY);
        genCodeForTree(arg->gtLdObj.gtOp1, 0);
        assert(arg->gtLdObj.gtOp1->gtFlags & GTF_REG_VAL);
        regNumber reg = arg->gtLdObj.gtOp1->gtRegNum;

        if (arg->gtOper == GT_MKREFANY)
        {
            // create a new REFANY, class handle on top, then the byref data
            GenTreePtr dummy;
            opsz = genPushArgList(arg->gtOp.gtOp2, NULL, 0, &dummy);
            assert(opsz == sizeof(void*));

            genEmitter->emitIns_R(INS_push, EA_BYREF, (emitRegs)reg);
            genSinglePush(true);

            opsz = 2 * sizeof(void*);
        }
        else
        {
            assert(arg->gtOper == GT_LDOBJ);
            // Get the number of DWORDS to copy to the stack
            opsz = roundUp(eeGetClassSize(arg->gtLdObj.gtClass), sizeof(void*));
            unsigned slots = opsz / sizeof(void*);
            
            BYTE* gcLayout = (BYTE*) compGetMemArrayA(slots, sizeof(BYTE));

            eeGetClassGClayout(arg->gtLdObj.gtClass, gcLayout);

            for (int i = slots-1; i >= 0; --i)
            {
                emitAttr size;
                if      (gcLayout[i] == TYPE_GC_NONE)
                    size = EA_4BYTE;
                else if (gcLayout[i] == TYPE_GC_REF)
                    size = EA_GCREF;
                else 
                {
                    assert(gcLayout[i] == TYPE_GC_BYREF);
                    size = EA_BYREF;
                }
                genEmitter->emitIns_AR_R(INS_push, size, SR_NA, (emitRegs)reg, i*sizeof(void*));
                genSinglePush(gcLayout[i] != 0);
            }
        }
        gcMarkRegSetNpt(genRegMask(reg));    // Kill the pointer in op1
        addrReg = 0;
        break;
    }

    default:
        assert(!"unhandled/unexpected arg type");
        NO_WAY("unhandled/unexpected arg type");
    }

    /* Update the current set of live variables */

    genUpdateLife(args);

    /* Update the current set of register pointers */

    assert(addrReg != 0xBEEFCAFE); genDoneAddressable(args, addrReg, FREE_REG);

    /* Remember how much stuff we've pushed on the stack */

    size            += opsz;

    /* Update the current argument stack offset */

#if STK_FASTCALL
    rsCurArgStkOffs += argBytes;
#endif

    /* Continue with the next argument, if any more are present */

    if  (list) goto AGAIN;

    if (regArgs)
    {
        unsigned    regIndex;
        GenTreePtr  unwrapArg = NULL;

        /* Move the deferred arguments to registers */

        assert(rsCurRegArg);
        assert(rsCurRegArg <= MAX_REG_ARG);

#ifdef  DEBUG
        assert((REG_ARG_0 != REG_EAX) && (REG_ARG_1 != REG_EAX));

        for(regIndex = 0; regIndex < rsCurRegArg; regIndex++)
            assert((rsMaskLock & genRegMask(genRegArgNum(regIndex))) == 0);
#endif

        /* Construct the register argument table */

        for (list = regArgs, regIndex = 0; 
             list; 
             regIndex++, encodeMask >>= 4)
        {
TOP:
            args = list;

            if  (args->gtOper == GT_LIST)
            {
                args = list->gtOp.gtOp1;
                list = list->gtOp.gtOp2;
            }
            else
            {
                list = NULL;
            }

            regNumber regNum = (regNumber)(encodeMask & 0x000F);

            if (regNum == REG_EAX)
            {
                assert(unwrapArg == NULL);
                unwrapArg = args;
                if (list == NULL)
                    break;
                else
                    goto TOP;
            }

            assert(regIndex < MAX_REG_ARG);

            regArgTab[regIndex].node   = args;
            regArgTab[regIndex].regNum = regNum;

            if (regNum == REG_ARG_0)
                compHasThisArg = impIsThis(args);
        }

        assert(regIndex == rsCurRegArg);
        assert(list == NULL);

        // An optimization for Contextful classes:
        // we may unwrap the proxy when we have a 'this reference'
        if (compHasThisArg && unwrapArg)
        {
            *realThis = unwrapArg;
        }

        /* Generate code to move the arguments to registers */

        for(regIndex = 0; regIndex < rsCurRegArg; regIndex++)
        {
            regNumber   regNum;

            regNum = regArgTab[regIndex].regNum;
            args   = regArgTab[regIndex].node;

            assert(isRegParamType(args->TypeGet()));
            assert(args->gtType != TYP_VOID);

            /* Evaluate the argument to a register [pair] */

            if  (genTypeSize(genActualType(args->TypeGet())) == sizeof(int))
            {
                /* Check if this is the guess area for the resolve interface call
                 * Pass a size of EA_OFFSET*/
                if  (args->gtOper == GT_CLS_VAR && eeGetJitDataOffs(args->gtClsVar.gtClsVarHnd) >= 0)
                {
#if TGT_x86
                    genEmitter->emitIns_R_C(INS_mov,
                                            EA_OFFSET,
                                            (emitRegs)regNum,
                                            args->gtClsVar.gtClsVarHnd,
                                            0);

#else
                    assert(!"whoever added the above, please fill this in");
#endif
                    /* The value is now in the appropriate register */

                    args->gtFlags |= GTF_REG_VAL;
                    args->gtRegNum = regNum;

                }
                else
                {
                    genComputeReg(args, genRegMask(regNum), EXACT_REG, FREE_REG, false);
                }

                assert(args->gtRegNum == regNum);

                /* If the register is already marked as used, it will become
                   multi-used. However, since it is a callee-trashed register,
                   we will have to spill it before the call anyway. So do it now */

                if (rsMaskUsed & genRegMask(regNum))
                {
                    assert(genRegMask(regNum) & RBM_CALLEE_TRASH);
                    rsSpillReg(regNum);
                }

                /* Mark the register as 'used' */

                rsMarkRegUsed(args);
            }
            else
            {
#ifdef  DEBUG
                gtDispTree(args);
#endif
                assert(!"UNDONE: how do we know which reg pair to use?");
//              genComputeRegPair(args, (regPairNo)regNum, RBM_NONE, KEEP_REG, false);
                assert(args->gtRegNum == regNum);
            }

            /* If any of the previously loaded arguments was spilled - reload it */

            for(unsigned i = 0; i < regIndex; i++)
            {
                if (regArgTab[i].node->gtFlags & GTF_SPILLED)
                    rsUnspillReg(regArgTab[i].node, 
                                 genRegMask(regArgTab[i].regNum), 
                                 KEEP_REG);
            }
        }
    }

    /* Return the total size pushed */

    return size;
}

/*****************************************************************************/

#if GEN_COUNT_CALLS

unsigned            callCount[10];
const   char *      callNames[10] =
{
    "VM helper",    // 0
    "virtual",      // 1
    "interface",    // 2
    "recursive",    // 3
    "unknown",      // 4
    " 1 ..  4",     // 5
    " 5 ..  8",     // 6
    " 9 .. 16",     // 7
    "17 .. 32",     // 8
    "   >= 33",     // 9
};
unsigned            callHelper[JIT_HELP_LASTVAL+1];

#endif


/*****************************************************************************/
#if INLINE_NDIRECT
/*****************************************************************************
 * Initialize the TCB local and the NDirect stub, afterwards "push"
 * the hoisted NDirect stub.
 * 'initRegs' is the set of registers which will be zeroed out by the prolog
 */

regMaskTP           Compiler::genPInvokeMethodProlog(regMaskTP initRegs)
{
    assert(info.compCallUnmanaged);

    unsigned        baseOffset = lvaTable[lvaScratchMemVar].lvStkOffs
                                 + info.compNDFrameOffset;

#ifdef DEBUG
    if (verbose && 0)
        printf(">>>>>>%s has unmanaged callee\n", info.compFullName);
#endif
    /* let's find out if compLvFrameListRoot is enregistered */

    LclVarDsc *     varDsc = &lvaTable[info.compLvFrameListRoot];

    assert(!varDsc->lvIsParam);
    assert(varDsc->lvType == TYP_I_IMPL);

    regNumber      regNum;
    regNumber      regNum2 = REG_EDI;

    if (varDsc->lvRegister)
    {
        regNum = regNumber(varDsc->lvRegNum);
        if (regNum == regNum2)
            regNum2 = REG_EAX;

        // we are about to initialize it. So turn the mustinit bit off to prevent 
        // the prolog reinitializing it.
        initRegs &= ~genRegMask(regNum);
    }
    else
        regNum = REG_EAX;

    /* get TCB,  mov reg, FS:[info.compEEInfo.threadTlsIndex] */

    DWORD threadTlsIndex, *pThreadTlsIndex;
    CORINFO_EE_INFO * pInfo;

    pInfo = eeGetEEInfo();

    if (pInfo->noDirectTLS)
        threadTlsIndex = NULL;
    else
    {
        threadTlsIndex = eeGetThreadTLSIndex(&pThreadTlsIndex);
        assert((!threadTlsIndex) != (!pThreadTlsIndex));
    }

    if (threadTlsIndex == NULL)
    {
        /* We must use the helper call since we don't know where the TLS index will be */

        genEmitHelperCall(CORINFO_HELP_GET_THREAD, 0, 0);

        if (regNum != REG_EAX)
            genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, (emitRegs)regNum, (emitRegs) REG_EAX);
    }
    else
    {
#define WIN_NT_TLS_OFFSET (0xE10)
#define WIN_NT5_TLS_HIGHOFFSET (0xf94)
#define WIN_9x_TLS_OFFSET (0x2c)

        if (threadTlsIndex < 64 && pInfo->osType == CORINFO_WINNT)
        {
            //  mov  reg, FS:[0xE10+threadTlsIndex*4]
            genEmitter->emitIns_R_C (INS_mov,
                                     EA_4BYTE,
                                     (emitRegs)regNum,
                                     FLD_GLOBAL_FS,
                                     WIN_NT_TLS_OFFSET + threadTlsIndex * sizeof(int));
        }
        else
        {
            DWORD basePtr;

            if (pInfo->osType == CORINFO_WINNT && threadTlsIndex >= 64)
            {
                assert(pInfo->osMajor >= 5);

                basePtr         = WIN_NT5_TLS_HIGHOFFSET;
                threadTlsIndex -= 64;
            }
            else
            {
                basePtr         = WIN_9x_TLS_OFFSET;
            }

            // mov reg, FS:[0x2c] or mov reg, fs:[0xf94]
            // mov reg, [reg+threadTlsIndex*4]

            genEmitter->emitIns_R_C (INS_mov,
                                     EA_4BYTE,
                                     (emitRegs)regNum,
                                     FLD_GLOBAL_FS,
                                     basePtr);
            genEmitter->emitIns_R_AR(INS_mov,
                                     EA_4BYTE,
                                     (emitRegs)regNum,
                                     (emitRegs)regNum,
                                     threadTlsIndex*sizeof(int));
        }
    }

    /* save TCB in local var if not enregistered */

    if (!varDsc->lvRegister)
        genEmitter->emitIns_AR_R (INS_mov,
                                  EA_4BYTE,
                                  (emitRegs)regNum,
                                  SR_EBP,
                                  lvaTable[info.compLvFrameListRoot].lvStkOffs);

    /* set frame's vptr */

    const void * inlinedCallFrameVptr, **pInlinedCallFrameVptr;
    inlinedCallFrameVptr = eeGetInlinedCallFrameVptr(&pInlinedCallFrameVptr);
    assert((!inlinedCallFrameVptr) != (!pInlinedCallFrameVptr));

    if (inlinedCallFrameVptr)
    {
        genEmitter->emitIns_I_AR (INS_mov,
                                  EA_4BYTE,
                                  (int) inlinedCallFrameVptr,
                                  SR_EBP,
                                  baseOffset + pInfo->offsetOfFrameVptr);
    }
    else
    {
        genEmitter->emitIns_R_AR (INS_mov, EA_4BYTE_DSP_RELOC,
                                  (emitRegs)regNum2,
                                  SR_NA, (int)pInlinedCallFrameVptr);

        genEmitter->emitIns_AR_R (INS_mov,
                                  EA_4BYTE,
                                  (emitRegs)regNum2,
                                  SR_EBP,
                                  baseOffset + pInfo->offsetOfFrameVptr);
    }

    /* Get current frame root (mov reg2, [reg+offsetOfThreadFrame]) and
       set next field in frame */


    genEmitter->emitIns_R_AR (INS_mov,
                              EA_4BYTE,
                              (emitRegs)regNum2,
                              (emitRegs)regNum,
                              pInfo->offsetOfThreadFrame);

    genEmitter->emitIns_AR_R (INS_mov,
                              EA_4BYTE,
                              (emitRegs)regNum2,
                              SR_EBP,
                              baseOffset + pInfo->offsetOfFrameLink);

    /* set EBP value in frame */

    genEmitter->emitIns_AR_R (INS_mov,
                              EA_4BYTE,
                              SR_EBP,
                              SR_EBP,
                              baseOffset + 0xC +
                    pInfo->offsetOfInlinedCallFrameCalleeSavedRegisters);

    /* get address of our frame */

    genEmitter->emitIns_R_AR (INS_lea,
                              EA_4BYTE,
                              (emitRegs)regNum2,
                              SR_EBP,
                              baseOffset + pInfo->offsetOfFrameVptr);

    /* reset track field in frame */

    genEmitter->emitIns_I_AR (INS_mov,
                              EA_4BYTE,
                              0,
                              SR_EBP,
                              baseOffset
                              + pInfo->offsetOfInlinedCallFrameCallSiteTracker);

    /* now "push" our N/direct frame */

    genEmitter->emitIns_AR_R (INS_mov,
                              EA_4BYTE,
                              (emitRegs)regNum2,
                              (emitRegs)regNum,
                              pInfo->offsetOfThreadFrame);

    return initRegs;
}


/*****************************************************************************
 * Unchain the InlinedCallFrame
 */

void                Compiler::genPInvokeMethodEpilog()
{
    assert(info.compCallUnmanaged);
    assert(compCurBB == genReturnBB ||
           (compTailCallUsed && compCurBB->bbJumpKind == BBJ_THROW));

    unsigned baseOffset = lvaTable[lvaScratchMemVar].lvStkOffs +
                          info.compNDFrameOffset;

    CORINFO_EE_INFO *   pInfo = eeGetEEInfo();
    LclVarDsc   *       varDsc = &lvaTable[info.compLvFrameListRoot];
    regNumber           reg;
    regNumber           reg2 = REG_EDI;

    if (varDsc->lvRegister)
    {
        reg = regNumber(varDsc->lvRegNum);
        if (reg == reg2)
            reg2 = REG_ESI;
    }
    else
    {
        /* mov esi, [tcb address]    */

        genEmitter->emitIns_R_AR (INS_mov,
                                  EA_4BYTE,
                                  SR_ESI,
                                  SR_EBP,
                                  varDsc->lvStkOffs);
        reg = REG_ESI;
    }



    /* mov edi, [ebp-frame.next] */

    genEmitter->emitIns_R_AR (INS_mov,
                              EA_4BYTE,
                              (emitRegs)reg2,
                              SR_EBP,
                              baseOffset + pInfo->offsetOfFrameLink);

    /* mov [esi+offsetOfThreadFrame], edi */

    genEmitter->emitIns_AR_R (INS_mov,
                              EA_4BYTE,
                              (emitRegs)reg2,
                              (emitRegs)reg,
                              pInfo->offsetOfThreadFrame);

}


/*****************************************************************************
    This function emits the call-site prolog for direct calls to unmanaged code.
    It does all the necessary setup of the InlinedCallFrame.
    varDsc specifies the local containing the thread control block.
    argSize or methodToken is the value to be copied into the m_datum 
            field of the frame (methodToken may be indirected & have a reloc)
    freeRegMask specifies the scratch register(s) available.
    The function returns  the register now containing the thread control block,
    (it could be either enregistered or loaded into one of the scratch registers)
*/

regNumber          Compiler::genPInvokeCallProlog(LclVarDsc*  varDsc,
                                                   int         argSize,
                                          CORINFO_METHOD_HANDLE methodToken,
                                                   BasicBlock* returnLabel,
                                                  regMaskTP     freeRegMask)
{
    /* Since we are using the InlinedCallFrame, we should have spilled all
       GC pointers to it - even from callee-saved registers */

    assert(((gcRegGCrefSetCur|gcRegByrefSetCur) & ~RBM_ARG_REGS) == 0);

    /* must specify only one of these parameters */
    assert((argSize == 0) || (methodToken == NULL));

    /* We are about to call unmanaged code directly.
       Before we can do that we have to emit the following sequence:

       mov  dword ptr [frame.callTarget], MethodToken
       mov  dword ptr [frame.callSiteTracker], esp
       mov  reg, dword ptr [tcb_address]
       mov  byte  ptr [tcb+offsetOfGcState], 0

     */
    regNumber      reg = REG_NA;

    unsigned    baseOffset  = lvaTable[lvaScratchMemVar].lvStkOffs +
                                  info.compNDFrameOffset;
    CORINFO_EE_INFO * pInfo = eeGetEEInfo();

    /* mov   dword ptr [frame.callSiteTarget], "MethodDesc" */

    if (methodToken == NULL)
    {
        genEmitter->emitIns_I_AR (INS_mov,
                                  EA_4BYTE,
                                  argSize, 
                                  SR_EBP,
                                  baseOffset
                                  + pInfo->offsetOfInlinedCallFrameCallTarget,
                                  0,
                                  NULL);
    }
    else
    {
        if (freeRegMask & RBM_EAX)
            reg     = REG_EAX;
        else if (freeRegMask & RBM_ECX)
            reg     = REG_ECX;
        else
            assert(!"neither eax nor ecx free in front of a call");

        void * embedMethHnd, * pEmbedMethHnd;

        embedMethHnd = (void*)info.compCompHnd->embedMethodHandle(
                                          methodToken, 
                                          &pEmbedMethHnd);

        assert((!embedMethHnd) != (!pEmbedMethHnd));

        if (embedMethHnd != NULL)
        {
            genEmitter->emitIns_I_AR (INS_mov,
                                      EA_4BYTE_CNS_RELOC,
                                      (int) embedMethHnd, 
                                      SR_EBP,
                                      baseOffset
                                      + pInfo->offsetOfInlinedCallFrameCallTarget,
                                      0,
                                      NULL);
        }
        else
        {
            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE_DSP_RELOC,
                                     (emitRegs)reg, SR_NA, (int) pEmbedMethHnd);

            genEmitter->emitIns_AR_R (INS_mov,
                                      EA_4BYTE,
                                      (emitRegs)reg,
                                      SR_EBP,
                                      baseOffset
                                      + pInfo->offsetOfInlinedCallFrameCallTarget);
        }
    }

    /* mov   dword ptr [frame.callSiteTracker], esp */

    genEmitter->emitIns_AR_R (INS_mov,
                              EA_4BYTE,
                              SR_ESP,
                              SR_EBP,
                              baseOffset
                  + pInfo->offsetOfInlinedCallFrameCallSiteTracker);


    if (varDsc->lvRegister)
    {
        reg = regNumber(varDsc->lvRegNum);
        assert((genRegMask(reg) & freeRegMask) == 0);
    }
    else
    {
        if (freeRegMask & RBM_EAX)
            reg     = REG_EAX;
        else if (freeRegMask & RBM_ECX)
            reg     = REG_ECX;
        else
            assert(!"neither eax nor ecx free in front of a call");

        /* mov reg, dword ptr [tcb address]    */

        genEmitter->emitIns_R_AR (INS_mov,
                                  EA_4BYTE,
                                  (emitRegs)reg,
                                  SR_EBP,
                                  varDsc->lvStkOffs);
    }


    // As a quick hack (and proof of concept) I generate
    // push returnLabel, pop dword ptr [frame.callSiteReturnAddress]
#if 1
    // Now push the address of where the finally funclet should
    // return to directly.

    genEmitter->emitIns_J(INS_push, false, false, returnLabel);
    genSinglePush(false);

    genEmitter->emitIns_AR_R (INS_pop,
                              EA_4BYTE,
                              SR_NA,
                              SR_EBP,
                              baseOffset
                  + pInfo->offsetOfInlinedCallFrameReturnAddress,
                              0,
                              NULL);
    genSinglePop();


#else
    /* mov   dword ptr [frame.callSiteReturnAddress], label */

    genEmitter->emitIns_J_AR (INS_mov,
                              EA_4BYTE,
                              returnLabel,
                              SR_EBP,
                              baseOffset
                  + pInfo->offsetOfInlinedCallFrameReturnAddress,
                              0,
                              NULL);
#endif
    /* mov   byte  ptr [tcb+offsetOfGcState], 0 */

    genEmitter->emitIns_I_AR (INS_mov,
                              EA_1BYTE,
                              0,
                              (emitRegs)reg,
                              pInfo->offsetOfGCState);

    return reg;
}


/*****************************************************************************
 *
   First we have to mark in the hoisted NDirect stub that we are back
   in managed code. Then we have to check (a global flag) whether GC is
   pending or not. If so, we just call into a jit-helper.
   Right now we have this call always inlined, i.e. we always skip around
   the jit-helper call.
   Note:
   The tcb address is a regular local (initialized in the prolog), so it is either
   enregistered or in the frame:

        [mov ecx, tcb_address] OR tcb_address is already in a reg
        mov  byte ptr[reg+offsetOfGcState], 1
        cmp  "global GC pending flag', 0
        je   @f
        push reg         ; the would like to get the tcb
        call @callGC
    @@:
 */

void                Compiler::genPInvokeCallEpilog(LclVarDsc *  varDsc,
                                                   regMaskTP    retVal)
{
    BasicBlock  *       clab_nostop;
    CORINFO_EE_INFO *   pInfo = eeGetEEInfo();
    regNumber           reg;

    if (varDsc->lvRegister)
    {
        /* make sure that register is live across the call */

        reg = varDsc->lvRegNum;
        assert(genRegMask(reg) & RBM_CALLEE_SAVED);
    }
    else
    {
        /* mov   ecx, dword ptr [tcb address]    */

        genEmitter->emitIns_R_AR (INS_mov,
                                  EA_4BYTE,
                                  SR_ECX,
                                  SR_EBP,
                                  varDsc->lvStkOffs);
        reg = REG_ECX;
    }

    /* mov   byte ptr [tcb+offsetOfGcState], 1 */

    genEmitter->emitIns_I_AR (INS_mov,
                              EA_1BYTE,
                              1,
                              (emitRegs)reg,
                              pInfo->offsetOfGCState);

#if 0
    // @TODO [REVISIT] [04/16/01] []: maybe we need to reset the track field on return */
    // reset track field in frame 

    genEmitter->emitIns_I_AR (INS_mov,
                              EA_4BYTE,
                              0,
                              SR_EBP,
                              lvaTable[lvaScratchMemVar].lvStkOffs
                              + info.compNDFrameOffset
                              + pInfo->offsetOfInlinedCallFrameCallSiteTracker);
#endif

    /* test global flag (we return to managed code) */

    LONG * addrOfCaptureThreadGlobal, **pAddrOfCaptureThreadGlobal;

    addrOfCaptureThreadGlobal = eeGetAddrOfCaptureThreadGlobal(&pAddrOfCaptureThreadGlobal);
    assert((!addrOfCaptureThreadGlobal) != (!pAddrOfCaptureThreadGlobal));

    // Can we directly use addrOfCaptureThreadGlobal?

    if (addrOfCaptureThreadGlobal)
    {
        genEmitter->emitIns_C_I  (INS_cmp,
                                  EA_1BYTE,
                                  FLD_GLOBAL_DS,
                                  (int) addrOfCaptureThreadGlobal,
                                  0);
    }
    else
    {
        genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE_DSP_RELOC, SR_EDX,
                                 SR_NA, (int)pAddrOfCaptureThreadGlobal);
        genEmitter->emitIns_I_AR(INS_cmp, EA_1BYTE, 0, SR_EDX, 0);
    }

    /* */
    clab_nostop = genCreateTempLabel();

    /* Generate the conditional jump */

    inst_JMP(genJumpKindForOper(GT_EQ, true), clab_nostop);

    /* save return value (if necessary) */
    if  (retVal != RBM_NONE)
    {
        // @TODO [REVISIT] [04/16/01] []: 
        // what about float/double returns?                    
        // right now we just leave the result on the FPU stack 
        // in the hope that the jit-helper will leave it there. 

        if (retVal == RBM_INTRET || retVal == RBM_LNGRET)
        {
            /* mov [frame.callSiteTracker], esp */

            genEmitter->emitIns_AR_R (INS_mov,
                                      EA_4BYTE,
                                      SR_EAX,
                                      SR_EBP,
                                      lvaTable[lvaScratchMemVar].lvStkOffs
                                      + info.compNDFrameOffset
                                      + pInfo->sizeOfFrame);
        }

        if (retVal == RBM_LNGRET)
        {
            /* mov [frame.callSiteTracker], esp */

            genEmitter->emitIns_AR_R (INS_mov,
                                      EA_4BYTE,
                                      SR_EDX,
                                      SR_EBP,
                                      lvaTable[lvaScratchMemVar].lvStkOffs
                                      + info.compNDFrameOffset
                                      + pInfo->sizeOfFrame
                                      + sizeof(int));
        }
    }

    /* calling helper with internal convention */
    if (reg != REG_ECX)
        genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, SR_ECX, (emitRegs)reg);

    /* emit the call to the EE-helper that stops for GC (or other reasons) */

    genEmitHelperCall(CORINFO_HELP_STOP_FOR_GC,
                     0,             /* argSize */
                     0);            /* retSize */

    /* restore return value (if necessary) */

    if  (retVal != RBM_NONE)
    {
        // @TODO [REVISIT] [04/16/01] []: 
        // what about float/double returns? right now we just 
        // leave the result on the FPU stack in the hope that the jit-helper 
        // will leave it there. 
        if (retVal == RBM_INTRET || retVal == RBM_LNGRET)
        {
            /* mov [frame.callSiteTracker], esp */

            genEmitter->emitIns_R_AR (INS_mov,
                                      EA_4BYTE,
                                      SR_EAX,
                                      SR_EBP,
                                      lvaTable[lvaScratchMemVar].lvStkOffs
                                      + info.compNDFrameOffset
                                      + pInfo->sizeOfFrame);
        }

        if (retVal == RBM_LNGRET)
        {
            /* mov [frame.callSiteTracker], esp */

            genEmitter->emitIns_R_AR (INS_mov,
                                      EA_4BYTE,
                                      SR_EDX,
                                      SR_EBP,
                                      lvaTable[lvaScratchMemVar].lvStkOffs
                                      + info.compNDFrameOffset
                                      + pInfo->sizeOfFrame
                                      + sizeof(int));
        }

    }

    /* genCondJump() closes the current emitter block */

    genDefineTempLabel(clab_nostop, true);

}


/*****************************************************************************/
#endif // INLINE_NDIRECT
/*****************************************************************************
 *
 *  Generate code for a call. If the call returns a value in register(s), the
 *  register mask that describes where the result will be found is returned;
 *  otherwise, RBM_NONE is returned.
 */

regMaskTP           Compiler::genCodeForCall(GenTreePtr  call,
                                             bool        valUsed)
{
    int             retSize;
    size_t          argSize;
    size_t          args;
    regMaskTP       retVal;

#if     TGT_x86
    unsigned        saveStackLvl;
#if     INLINE_NDIRECT
#ifdef DEBUG
    BasicBlock  *   returnLabel = NULL;
#else
    BasicBlock  *   returnLabel;
#endif
    regNumber       reg    = REG_NA;
    LclVarDsc   *   varDsc = NULL;
#endif
#endif

#if     NST_FASTCALL
    unsigned        savCurArgReg;
#else
#ifdef  DEBUG
    assert(genCallInProgress == false); genCallInProgress = true;
#endif
#endif

    unsigned        areg;

    regMaskTP       fptrRegs;

#if     TGT_x86
#ifdef  DEBUG

    unsigned        stackLvl = genEmitter->emitCurStackLvl;


    if (verbose)
    {
        printf("Beg call [%08X] stack %02u [E=%02u]\n", call, genStackLevel, stackLvl);
    }

#endif
#endif
    regMaskTP       vptrMask;
    bool            didUnwrap = false;
    GenTreePtr      realThis  = NULL;

    gtCallTypes     callType  = call->gtCall.gtCallType;

    compHasThisArg = false;

    /* Make some sanity checks on the call node */

    // This is a call
    assert(call->gtOper == GT_CALL);
    // "this" only makes sense for user functions
    assert(call->gtCall.gtCallObjp == 0 || callType == CT_USER_FUNC || callType == CT_INDIRECT);
    // tailcalls wont be done for helpers, caller-pop args, and check that
    // the global flag is set
    assert(!(call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL) ||
           (callType != CT_HELPER && !(call->gtFlags & GTF_CALL_POP_ARGS) &&
            compTailCallUsed));

#if TGT_x86

    unsigned pseudoStackLvl = 0;

    /* @TODO [FIXHACK] [04/16/01] []: throw-helper-blocks might start with a non-empty stack !
       We need to let the emitter know this so it can update the GC info */

    if (!genFPused && genStackLevel != 0 && fgIsThrowHlpBlk(compCurBB))
    {
        assert(compCurBB->bbTreeList->gtStmt.gtStmtExpr == call);

        pseudoStackLvl = genStackLevel;

        assert(!"Blocks with non-empty stack on entry are NYI in the emitter "
                "so fgAddCodeRef() should have set genFPreqd");
    }

    /* Mark the current stack level and list of pointer arguments */

    saveStackLvl = genStackLevel;

#else

    assert(genNonLeaf);

#endif

    /*-------------------------------------------------------------------------
     *  Set up the registers and arguments
     */

    /* We'll keep track of how much we've pushed on the stack */

    argSize = 0;

#if TGT_x86
#if INLINE_NDIRECT

    /* We need to get a lable for the return address with the proper stack depth. */
    /* For the callee pops case (the default) that is before the args are pushed. */

    if ((call->gtFlags & GTF_CALL_UNMANAGED) &&
        !(call->gtFlags & GTF_CALL_POP_ARGS))
    {
       returnLabel = genCreateTempLabel();
    }
#endif
#endif

#if STK_FASTCALL

    /* Keep track of the argument stack offset */

    rsCurArgStkOffs = 0;

#else

    /*
        Make sure to save the current argument register status
        in case we have nested calls.
     */

    assert(rsCurRegArg <= MAX_REG_ARG);

    savCurArgReg = rsCurRegArg;

#endif

    rsCurRegArg = 0;

    /* Pass object pointer first */

    if  (call->gtCall.gtCallObjp)
    {
        if  (call->gtCall.gtCallArgs)
        {
            argSize += genPushArgList(call->gtCall.gtCallObjp,
                                      0,
                                      0,
                                      &realThis);
        }
        else
        {
            argSize += genPushArgList(call->gtCall.gtCallObjp,
                                      call->gtCall.gtCallRegArgs,
                                      call->gtCall.regArgEncode,
                                      &realThis);
        }
    }

    /* Then pass the arguments */

    if  (call->gtCall.gtCallArgs)
    {
        argSize += genPushArgList(call->gtCall.gtCallArgs,
                                  call->gtCall.gtCallRegArgs,
                                  call->gtCall.regArgEncode,
                                  &realThis);
    }

#if INLINE_NDIRECT

    /* We need to get a lable for the return address with the proper stack depth. */
    /* For the caller pops case (cdecl) that is after the args are pushed. */

    if (call->gtFlags & GTF_CALL_UNMANAGED)
    {
        if (call->gtFlags & GTF_CALL_POP_ARGS)
            returnLabel = genCreateTempLabel();

        /* Make sure that we now have a label */
        assert(returnLabel);
    }
#endif
    /* Record the register(s) used for the indirect call func ptr */

    fptrRegs = 0;

    if (callType == CT_INDIRECT)
    {
        regMaskTP usedRegArg = RBM_ARG_REGS & rsMaskUsed;
        rsLockUsedReg  (usedRegArg);

        fptrRegs  = genMakeRvalueAddressable(call->gtCall.gtCallAddr,
                                             0,
                                             KEEP_REG);

        rsUnlockUsedReg(usedRegArg);
    }

#if OPTIMIZE_TAIL_REC

    /* Check for a tail-recursive call */

    if  (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILREC)
        goto DONE;

#endif

    /* Make sure any callee-trashed registers are saved */

    regMaskTP   calleeTrashedRegs = RBM_NONE;

#if GTF_CALL_REG_SAVE
    if  (call->gtFlags & GTF_CALL_REG_SAVE)
    {
        /* The return value reg(s) will definitely be trashed */

        switch (call->gtType)
        {
        case TYP_INT:
        case TYP_REF:
        case TYP_BYREF:
#if!CPU_HAS_FP_SUPPORT
        case TYP_FLOAT:
#endif
            calleeTrashedRegs = RBM_INTRET;
            break;

        case TYP_LONG:
#if!CPU_HAS_FP_SUPPORT
        case TYP_DOUBLE:
#endif
            calleeTrashedRegs = RBM_LNGRET;
            break;

        case TYP_VOID:
#if CPU_HAS_FP_SUPPORT
        case TYP_FLOAT:
        case TYP_DOUBLE:
#endif
            calleeTrashedRegs = 0;
            break;

        default:
            assert(!"unhandled/unexpected type");
        }
    }
    else
#endif
    {
        calleeTrashedRegs = RBM_CALLEE_TRASH;
    }

    /* Spill any callee-saved registers which are being used */

    regMaskTP       spillRegs = calleeTrashedRegs & rsMaskUsed;

#if     TGT_x86
#if     INLINE_NDIRECT

    /* We need to save all GC registers to the InlinedCallFrame.
       Instead, just spill them to temps. */

    if (call->gtFlags & GTF_CALL_UNMANAGED)
        spillRegs |= (gcRegGCrefSetCur|gcRegByrefSetCur) & rsMaskUsed;
#endif
#endif

    // Ignore fptrRegs as it is needed only to perform the indirect call

    spillRegs &= ~fptrRegs;

    /* Do not spill the argument registers.
       Multi-use of RBM_ARG_REGS should be prevented by genPushArgList() */

    assert((rsMaskMult & rsCurRegArg) == 0);
    spillRegs &= ~genRegArgMask(rsCurRegArg);

    if (spillRegs)
    {
        rsSpillRegs(spillRegs);
    }

    /* All float temps must be spilled around function calls using
       genSpillFPtos(). Also, there should be no live FP stk variables */

    assert(genFPstkLevel == 0);

    if  (genFPregCnt)
    {
        assert(genFPregCnt == genFPdeadRegCnt);
        genFPregVarKill(0, false);
    }

    /* If the method returns a GC ref, set size to EA_GCREF or EA_BYREF */

    retSize = sizeof(void *);

#if TRACK_GC_REFS

    if  (valUsed)
    {
        if      (call->gtType == TYP_REF ||
                 call->gtType == TYP_ARRAY)
        {
            retSize = EA_GCREF;
        }
        else if (call->gtType == TYP_BYREF)
        {
            retSize = EA_BYREF;
        }
    }

#endif

    /*-------------------------------------------------------------------------
     *  Generate the call
     */

    /* For caller-pop calls, the GC info will report the arguments as pending
       arguments as the caller explicitly pops them. Also should be
       reported as non-GC arguments as they effectively go dead at the
       call site (callee owns them)
     */

    args = (call->gtFlags & GTF_CALL_POP_ARGS) ? -argSize
                                               :  argSize;

    /* Treat special cases first */

#ifdef PROFILER_SUPPORT
#if     TGT_x86

    if (opts.compCallEventCB)
    {
        /* fire the event at the call site */
        /* alas, right now I can only handle calls via a method handle */
        if (call->gtCall.gtCallType == CT_USER_FUNC)
        {
            unsigned         saveStackLvl2 = genStackLevel;
            BOOL             bHookFunction = TRUE;
            CORINFO_PROFILING_HANDLE handleTo, *pHandleTo;
            CORINFO_PROFILING_HANDLE handleFrom, *pHandleFrom;

            handleTo = eeGetProfilingHandle(call->gtCall.gtCallMethHnd, &bHookFunction, &pHandleTo);
            assert((!handleTo) != (!pHandleTo));

            // Give profiler a chance to back out of hooking this method
            if (bHookFunction)
            {
                handleFrom = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandleFrom);
                assert((!handleFrom) != (!pHandleFrom));

                // Give profiler a chance to back out of hooking this method
                if (bHookFunction)
                {
                    if (handleTo)
                        inst_IV(INS_push, (unsigned) handleTo);
                    else
                        genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                                 SR_NA, SR_NA, (int)pHandleTo);

                    genSinglePush(false);

                    if (handleFrom)
                        inst_IV(INS_push, (unsigned) handleFrom);
                    else
                        genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                                 SR_NA, SR_NA, (int)pHandleFrom);

                    genSinglePush(false);

                    genEmitHelperCall(CORINFO_HELP_PROF_FCN_CALL,
                                      2*sizeof(int), // argSize
                                      0);            // retSize

                    /* Restore the stack level */

                    genStackLevel = saveStackLvl2;
                    genOnStackLevelChanged();
                }
            }
        }
    }

    else if (opts.compEnterLeaveEventCB && (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL))
    {
        /* fire the event at the call site */
        /* alas, right now I can only handle calls via a method handle */
        if (call->gtCall.gtCallType == CT_USER_FUNC)
        {
            unsigned         saveStackLvl2 = genStackLevel;
            BOOL             bHookFunction = TRUE;
            CORINFO_PROFILING_HANDLE handleFrom, *pHandleFrom;

            handleFrom = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandleFrom);
            assert((!handleFrom) != (!pHandleFrom));

            // Give profiler a chance to back out of hooking this method
            if (bHookFunction)
            {
                if (handleFrom)
                    inst_IV(INS_push, (unsigned) handleFrom);
                else
                    genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                             SR_NA, SR_NA, (int)pHandleFrom);

                genSinglePush(false);

                genEmitHelperCall(CORINFO_HELP_PROF_FCN_TAILCALL,
                                  sizeof(int), // argSize
                                  0);          // retSize

                /* Restore the stack level */

                genStackLevel = saveStackLvl2;
                genOnStackLevelChanged();
            }
        }
    }

#endif // TGT_x86
#endif // PROFILER_SUPPORT

#ifdef DEBUG
    if (opts.compStackCheckOnCall && call->gtCall.gtCallType == CT_USER_FUNC) 
    {
        assert(lvaCallEspCheck != 0xCCCCCCCC && lvaTable[lvaCallEspCheck].lvVolatile && lvaTable[lvaCallEspCheck].lvOnFrame);
        genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, SR_ESP, lvaCallEspCheck, 0);
    }
#endif

    /* Check for Delegate.Invoke. If so, we inline it. We get the
       target-object and target-function from the delegate-object, and do
       an indirect call.
     */

    if  (call->gtCall.gtCallMoreFlags & GTF_CALL_M_DELEGATE_INV)
    {
        assert(call->gtCall.gtCallType == CT_USER_FUNC);
        assert(eeGetMethodAttribs(call->gtCall.gtCallMethHnd) & CORINFO_FLG_DELEGATE_INVOKE);
        assert(eeGetMethodAttribs(call->gtCall.gtCallMethHnd) & CORINFO_FLG_FINAL);

        /* Find the offsets of the 'this' pointer and new target */

        CORINFO_EE_INFO *  pInfo;
        unsigned           instOffs;     // offset of new 'this' pointer
        unsigned           firstTgtOffs; // offset of first target to invoke

        /* @TODO [REVISIT] [04/16/01] []: The offsets returned by the following helper are off by 4 - should be fixed
         * QUESTION: In the final version will the offsets be statically known? */

        pInfo = eeGetEEInfo();
        instOffs = pInfo->offsetOfDelegateInstance;
        firstTgtOffs = pInfo->offsetOfDelegateFirstTarget;

#if !TGT_x86
        assert(!"Delegates NYI for non-x86");
#else
        /* Save the invoke-target-function in EAX (in ECX we have the pointer
         * to our delegate object) 'mov EAX, dword ptr [ECX + firstTgtOffs]' */

        genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)REG_EAX, (emitRegs)REG_ECX, firstTgtOffs);

        /* Set new 'this' in ECX - 'mov ECX, dword ptr [ECX + instOffs]' */

        genEmitter->emitIns_R_AR(INS_mov, EA_GCREF, (emitRegs)REG_ECX, (emitRegs)REG_ECX, instOffs);

        /* Call through EAX */

        genEmitter->emitIns_Call(emitter::EC_INDIR_R,
                                 NULL,      // Will be ignored
                                 args,
                                 retSize,
                                 gcVarPtrSetCur,
                                 gcRegGCrefSetCur,
                                 gcRegByrefSetCur,
                                 (emitRegs)REG_EAX);
#endif // !TGT_x86

    }
    else

    /*-------------------------------------------------------------------------
     *  Virtual calls
     */

    if  (call->gtFlags & GTF_CALL_VIRT)
    {
        regNumber       vptrReg;
        unsigned        vtabOffs;

        assert(callType == CT_USER_FUNC);

        // An optimization for Contextful classes:
        // we unwrap the proxy when we have a 'this reference'
        if (realThis != NULL)
        {
            assert(compHasThisArg);
            assert(info.compIsContextful);
            assert(info.compUnwrapContextful);
            assert(info.compUnwrapCallv);

            /* load realThis into a register not RBM_ARG_0 */
            genComputeReg(realThis, RBM_ALL & ~RBM_ARG_0, ANY_REG, FREE_REG, false);
            assert(realThis->gtFlags & GTF_REG_VAL);

            vptrReg   = realThis->gtRegNum;
            vptrMask  = genRegMask(vptrReg);
            didUnwrap = true;
        }
        else
        {
            /* For virtual methods, EAX = [REG_ARG_0+VPTR_OFFS] */
            vptrMask = RBM_EAX;

            /* The EAX register no longer holds a live pointer value */
            gcMarkRegSetNpt(vptrMask);
            vptrReg = rsGrabReg(RBM_EAX);       assert(vptrReg == REG_EAX);
            
            // MOV EAX, [ECX+offs]
            genEmitter->emitIns_R_AR (INS_mov, EA_4BYTE,
                                      (emitRegs)vptrReg, (emitRegs)REG_ARG_0, VPTR_OFFS);
        }

        assert((call->gtFlags & GTF_CALL_INTF) ||
               (vptrMask & ~genRegArgMask(rsCurRegArg)));
        
        /* Get hold of the vtable offset (note: this might be expensive) */

        vtabOffs = eeGetMethodVTableOffset(call->gtCall.gtCallMethHnd);

        /* Is this an interface call? */

        if  (call->gtFlags & GTF_CALL_INTF)
        {
            /* @TODO [REVISIT] [04/16/01] []: add that to DLLMain and make info a DLL global */

            CORINFO_EE_INFO *     pInfo = eeGetEEInfo();
            CORINFO_CLASS_HANDLE  cls   = eeGetMethodClass(call->gtCall.gtCallMethHnd);

            assert(eeGetClassAttribs(cls) & CORINFO_FLG_INTERFACE);

            /* Load the vptr into a register */

            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                     (emitRegs)vptrReg, (emitRegs)vptrReg,
                                     pInfo->offsetOfInterfaceTable);

            unsigned interfaceID, *pInterfaceID;
            interfaceID = eeGetInterfaceID(cls, &pInterfaceID);
            assert(!pInterfaceID || !interfaceID);

            // Can we directly use the interfaceID?

            if (!pInterfaceID)
            {
                genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                         (emitRegs)vptrReg, (emitRegs)vptrReg,
                                         interfaceID * 4);
            }
            else
            {
                genEmitter->emitIns_R_AR(INS_add, EA_4BYTE_DSP_RELOC,
                                         (emitRegs)vptrReg, SR_NA, (int)pInterfaceID);
                genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                         (emitRegs)vptrReg, (emitRegs)vptrReg, 0);
            }
        }

        /* Call through the appropriate vtable slot */

#if     GEN_COUNT_CALLS
        genEmitter.emitCodeGenByte(0xFF);
        genEmitter.emitCodeGenByte(0x05);
        genEmitter.emitCodeGenLong((int)&callCount[(call->gtFlags & GTF_CALL_INTF) ? 2 : 1]);
#endif

        if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
        {
            /* Load the function address: "[vptrReg+vtabOffs] -> reg_intret" */

#if     TGT_x86
            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)REG_TAILCALL_ADDR,
                                     (emitRegs)vptrReg, vtabOffs);
#else
            if  (vtabOffs)
                genEmitter->emitIns_R_RD((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         vtabOffs,
                                         sizeof(void*));
            else
                genEmitter->emitIns_R_IR((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         false,
                                         sizeof(void*));
#endif
        }
        else
        {
#if     TGT_x86

            genEmitter->emitIns_Call(emitter::EC_FUNC_VIRTUAL,
                                     call->gtCall.gtCallMethHnd,
                                     args,
                                     retSize,
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur,
                                     (emitRegs)vptrReg,     // ireg
                                     SR_NA,                 // xreg
                                     0,                     // xmul
                                     vtabOffs);             // disp

#else //TGT_x86

            /* Load the function address: "[vptrReg+vtabOffs] -> vptrReg" */

            if  (vtabOffs)
                genEmitter->emitIns_R_RD((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         vtabOffs,
                                         sizeof(void*));
            else
                genEmitter->emitIns_R_IR((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         false,
                                         sizeof(void*));

            /* Call through the address */

            genEmitter->emitIns_Call(args,
                                     retSize,
#if     TRACK_GC_REFS
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur,
#endif
                                     false,
                                     (emitRegs)vptrReg);
#endif//TGT_x86

        }

    }
    else //------------------------ Non-virtual calls -------------------------
    {
        gtCallTypes             callType = call->gtCall.gtCallType;
        CORINFO_METHOD_HANDLE   methHnd  = call->gtCall.gtCallMethHnd;

#if     GEN_COUNT_CALLS

        genEmitter.emitCodeGenByte(0xFF);
        genEmitter.emitCodeGenByte(0x05);

        if (callType == CT_HELPER)
        {
            int         index = CPX;

            genEmitter.emitCodeGenLong((int)&callCount[0]);

            assert(index >= 0 && index < sizeof(callHelper)/sizeof(callHelper[0]));

            genEmitter.emitCodeGenByte(0xFF);
            genEmitter.emitCodeGenByte(0x05);
            genEmitter.emitCodeGenLong((int)(callHelper+index));
        }
        else if (eeIsOurMethod(callType, CPX, CLS))
        {
            genEmitter.emitCodeGenLong((int)&callCount[3]);
        }
        else
        {
            unsigned            codeSize;
            BYTE    *           codeAddr;

            JITGetMethodCode(JITgetMethod(CLS, CPX), &codeAddr,
                                                     &codeSize);

            genEmitter.emitCodeGenLong((int)&callCount[0]);

            assert(index >= 0 && index < sizeof(callHelper)/sizeof(callHelper[0]));

            genEmitter.emitCodeGenByte(0xFF);
            genEmitter.emitCodeGenByte(0x05);
            genEmitter.emitCodeGenLong((int)(callHelper+index));
        }
        else if (eeIsOurMethod(callType, CPX, CLS))
        {
            genEmitter.emitCodeGenLong((int)&callCount[3]);
        }
        else
        {
            genEmitter.emitCodeGenLong((int)&callCount[9]);
        }

#endif // GEN_COUNT_CALLS

        /*  For (final and private) functions which were called with
            invokevirtual, but which we call directly, we need to
            dereference the object pointer to make sure it's not NULL.
         */

        if (call->gtFlags & GTF_CALL_VIRT_RES)
        {
            /* Generate "cmp ECX, [ECX]" to trap null pointers */
            genEmitter->emitIns_AR_R(INS_cmp, EA_4BYTE, SR_ECX, SR_ECX, 0);
        }

#if     INDIRECT_CALLS

        bool    callDirect = false;

        // Check is we can directly call the function, or if we need to
        // use an (single/double) indirection.

        void *  ftnAddr = NULL, **pFtnAddr = NULL, ***ppFtnAddr = NULL;

        if (callType == CT_HELPER)
        {
            ftnAddr = eeGetHelperFtn(info.compCompHnd,
                                     eeGetHelperNum(methHnd),
                                     &pFtnAddr);
            assert((!ftnAddr) != (!pFtnAddr));

            if (ftnAddr)
                callDirect = true;
        }
        else if (!opts.compDbgEnC && eeIsOurMethod(methHnd))
        {
            callDirect = true;
        }
        else if (callType == CT_USER_FUNC)
        {
            CORINFO_ACCESS_FLAGS  aflags    = CORINFO_ACCESS_ANY;

            if (compHasThisArg)
            {
                aflags = CORINFO_ACCESS_THIS;
            }
            // direct access or single or double indirection

            CORINFO_METHOD_HANDLE callHnd = methHnd;
            if (call->gtFlags & GTF_CALL_UNMANAGED)
                callHnd = eeMarkNativeTarget(methHnd);

            InfoAccessType accessType = IAT_VALUE;
            void * addr = eeGetMethodEntryPoint(callHnd, &accessType, aflags);

#if GEN_COUNT_CALL_TYPES
            extern int countDirectCalls;
            extern int countIndirectCalls;
            if (accessType == IAT_VALUE)
                countDirectCalls++;
            else
                countIndirectCalls++;
#endif

            switch(accessType)
            {
            case IAT_VALUE  :   ftnAddr = (void *  )addr; callDirect = true; break;
            case IAT_PVALUE :  pFtnAddr = (void ** )addr;                    break;
            case IAT_PPVALUE: ppFtnAddr = (void ***)addr;                    break;
            default: assert(!"Bad accessType");
            }
        }

#if INLINE_NDIRECT
#if !TGT_x86
#error hoisting of NDirect stub NYI for RISC platforms
#else
                if (call->gtFlags & GTF_CALL_UNMANAGED)
                {
                    assert(info.compCallUnmanaged != 0);

                    /* args shouldn't be greater than 64K */

                    assert((argSize&0xffff0000) == 0);

            regMaskTP  freeRegMask = RBM_EAX | RBM_ECX;

                    /* Remember the varDsc for the callsite-epilog */

                    varDsc = &lvaTable[info.compLvFrameListRoot];

            CORINFO_METHOD_HANDLE   nMethHnd = NULL;
            int                     nArgSize = 0;

            regNumber  indCallReg = REG_NA;

            if (callType == CT_INDIRECT)
            {
                assert(genStillAddressable(call->gtCall.gtCallAddr));

                    if (call->gtCall.gtCallAddr->gtFlags & GTF_REG_VAL)
                    {
                    indCallReg  = call->gtCall.gtCallAddr->gtRegNum;

                        /* Don't use this register for the call-site prolog */
                    freeRegMask &= ~genRegMask(indCallReg);
                }

                nArgSize = (call->gtFlags & GTF_CALL_POP_ARGS) ? 0 : argSize;
            }
            else
            {
                assert(callType == CT_USER_FUNC);
                nMethHnd = call->gtCall.gtCallMethHnd;
                    }

                    reg = genPInvokeCallProlog(
                                    varDsc,
                            nArgSize,
                            nMethHnd,
                                    returnLabel,
                            freeRegMask);

            emitter::EmitCallType       emitCallType;

            if (callType == CT_INDIRECT)
            {
                    /* Double check that the callee didn't use/trash the
                       registers holding the call target.
                     */
                assert(reg != indCallReg);

                if (indCallReg == REG_NA)
                    {
                        /* load eax with the real target */

                        /* Please note that this even works with reg == REG_EAX
                           reg contains an interesting value only if varDsc is an
                           enregistered local that stays alive across the call
                           (certainly not EAX). If varDsc has been moved into EAX
                           we can trash it since it wont survive across the call
                           anyways.
                        */

                        inst_RV_TT(INS_mov, REG_EAX, call->gtCall.gtCallAddr);

                    indCallReg = REG_EAX;
                }

                emitCallType = emitter::EC_INDIR_R;
                nMethHnd = NULL;
            }
            else if (ftnAddr || pFtnAddr)
            {
                emitCallType = ftnAddr ? emitter::EC_FUNC_TOKEN
                                       : emitter::EC_FUNC_TOKEN_INDIR;

                nMethHnd = eeMarkNativeTarget(call->gtCall.gtCallMethHnd);
                indCallReg = REG_NA;
            }
            else
            {
                // Double-indirection. Load the address into a register
                // and call indirectly through the register

                // @TODO [REVISIT] [04/16/01] []:  the code for  fetching the entry point for the PINVOKE vs normal
                // case is way too fragile.  we need to streamline all of this - vancem
                info.compCompHnd->getAddressOfPInvokeFixup(call->gtCall.gtCallMethHnd, (void**)&ppFtnAddr);
                assert(ppFtnAddr);

                genEmitter->emitIns_R_AR(INS_mov,
                                         EA_4BYTE_DSP_RELOC,
                                         SR_EAX,
                                         SR_NA, (int)ppFtnAddr);
                emitCallType = emitter::EC_INDIR_ARD;
                nMethHnd = NULL;
                indCallReg = REG_EAX;
                    }

            genEmitter->emitIns_Call(emitCallType,
                                     nMethHnd,
                                     args,
                                     retSize,
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur,
                                     emitRegs(indCallReg));

            if (callType == CT_INDIRECT)
                genDoneAddressable(call->gtCall.gtCallAddr, fptrRegs, KEEP_REG);
                }
                else
#endif // TGT_x86
#endif // INLINE_NDIRECT
        if  (!callDirect)
        {
            if  (callType == CT_INDIRECT)
            {
                assert(genStillAddressable(call->gtCall.gtCallAddr));

                if (call->gtCall.gtCallCookie)
                {
                    GenTreePtr cookie = call->gtCall.gtCallCookie;

                    assert((call->gtFlags & GTF_CALL_POP_ARGS) == 0);

                    /* load eax with the real target */

                    inst_RV_TT(INS_mov, REG_EAX, call->gtCall.gtCallAddr);

                    assert(cookie->gtOper == GT_CNS_INT ||
                           cookie->gtOper == GT_IND && cookie->gtInd.gtIndOp1->gtOper == GT_CNS_INT);
                    if (cookie->gtOper == GT_CNS_INT)
                        inst_IV_handle(INS_push, cookie->gtIntCon.gtIconVal, GTF_ICON_PINVKI_HDL, 0, 0);
                    else
                        inst_TT(INS_push, call->gtCall.gtCallCookie);

                    /* Keep track of ESP for EBP-less frames */

                    genSinglePush(false);

                    assert(args == argSize);
                    argSize += sizeof(void *);
                    args     = argSize;

                    genEmitHelperCall(CORINFO_HELP_PINVOKE_CALLI, args, retSize);
                }
                else
                {
#if     TGT_x86
                    if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                        inst_RV_TT(INS_mov, REG_TAILCALL_ADDR, call->gtCall.gtCallAddr);
                    else
                        instEmit_indCall(call, args, retSize);
#else
                    assert(!"non-x86 indirect call");
#endif
                }

                genDoneAddressable(call->gtCall.gtCallAddr, fptrRegs, KEEP_REG);
            }
            else // callType != CT_INDIRECT
            {
                assert(callType == CT_USER_FUNC || callType == CT_HELPER);

#if     TGT_x86

                    if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                    {
                        assert(callType == CT_USER_FUNC);
                        assert((pFtnAddr == 0) != (ppFtnAddr == 0));
                        if (pFtnAddr)
                        {
                            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE_DSP_RELOC, (emitRegs)REG_TAILCALL_ADDR,
                                                     (emitRegs)REG_NA, (int)pFtnAddr);
                        }
                        else
                        {
                            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE_DSP_RELOC, (emitRegs)REG_TAILCALL_ADDR,
                                                     (emitRegs)REG_NA, (int)ppFtnAddr);
                            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)REG_TAILCALL_ADDR,
                                                     (emitRegs)REG_TAILCALL_ADDR, 0);
                        }
                    }
                    else
                    {
                        if (pFtnAddr)
                        {
                            genEmitter->emitIns_Call( emitter::EC_FUNC_TOKEN_INDIR,
                                                      methHnd,
                                                      args,
                                                      retSize,
                                                      gcVarPtrSetCur,
                                                      gcRegGCrefSetCur,
                                                      gcRegByrefSetCur);
                        }
                        else
                        {
                            // Double-indirection. Load the address into a register
                            // and call indirectly through the register

                            assert(ppFtnAddr);
                            genEmitter->emitIns_R_AR(INS_mov,
                                                     EA_4BYTE_DSP_RELOC,
                                                     SR_EAX,
                                                     SR_NA, (int)ppFtnAddr);
                            genEmitter->emitIns_Call(emitter::EC_INDIR_ARD,
                                                     NULL, // will be ignored
                                                     args,
                                                     retSize,
                                                     gcVarPtrSetCur,
                                                     gcRegGCrefSetCur,
                                                     gcRegByrefSetCur,
                                                     SR_EAX);
                        }
                    }
#endif
            }
        }
        else

#endif // INDIRECT_CALLS
        {
            if (callType == CT_INDIRECT)
            {
                assert(genStillAddressable(call->gtCall.gtCallAddr));

#if     TGT_x86
                if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                    inst_RV_TT(INS_mov, REG_TAILCALL_ADDR, call->gtCall.gtCallAddr);
                else
                    instEmit_indCall(call, args, retSize);
#else
                assert(!"non-x86 indirect call");
#endif

                genDoneAddressable(call->gtCall.gtCallAddr, fptrRegs, KEEP_REG);
            }
            else
            {
                assert(callType == CT_USER_FUNC || callType == CT_HELPER);

                if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                {
                    assert(callType == CT_USER_FUNC);
                    genEmitter->emitIns_R_I(INS_mov, EA_4BYTE_CNS_RELOC,
                        (emitRegs)REG_TAILCALL_ADDR, int(ftnAddr));
                }
                else
                {
#if     TGT_x86
                    genEmitter->emitIns_Call(emitter::EC_FUNC_TOKEN,
                                             methHnd,
                                             args,
                                             retSize,
                                             gcVarPtrSetCur,
                                             gcRegGCrefSetCur,
                                             gcRegByrefSetCur);
#else
                                 genCallInst(callType,
                                             methHnd,
                                             args,
                                             retSize);
#endif
                }
            }
        }
    }

    /*-------------------------------------------------------------------------
     *  For tailcalls, REG_INTRET contains the address of the target function,
     *  enregistered args are in the correct registers, and the stack arguments
     *  have been pushed on the stack. Now call the stub-sliding helper
     */

    if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
    {
        if (info.compCallUnmanaged)
            genPInvokeMethodEpilog();

        assert(0 <= (int)args); // caller-pop args not supported for tailcall

#if TGT_x86

        // Push the count of the incoming stack arguments

        int nOldStkArgs = (compArgSize - (rsCalleeRegArgNum * sizeof(void *))) / sizeof(void*);
        genEmitter->emitIns_I(INS_push, EA_4BYTE, nOldStkArgs);
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Push the count of the outgoing stack arguments

        genEmitter->emitIns_I(INS_push, EA_4BYTE, argSize/sizeof(void*));
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Push info about the callee-saved registers to be restored
        // For now, we always spill all registers if compTailCallUsed

        DWORD calleeSavedRegInfo = (0x7 << 29) | // mask of EDI, ESI, EBX
                                   (0x0 << 28) | // accessed relative to esp
                                            0;   // offset of first saved reg
        genEmitter->emitIns_I(INS_push, EA_4BYTE, calleeSavedRegInfo);
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Push the address of the target function

        genEmitter->emitIns_R(INS_push, EA_4BYTE, (emitRegs)REG_TAILCALL_ADDR);
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Now call the helper

        genEmitHelperCall(CORINFO_HELP_TAILCALL, args, retSize);

#endif // TG_x86

    }

    /*-------------------------------------------------------------------------
     *  Done with call.
     *  Trash registers, pop arguments if needed, etc
     */

    /* Mark the argument registers as free */

    assert(rsCurRegArg <= MAX_REG_ARG);

    for(areg = 0; areg < rsCurRegArg; areg++)
        rsMarkRegFree(genRegMask(genRegArgNum(areg)));

    /* restore the old argument register status */

#if NST_FASTCALL
    rsCurRegArg = savCurArgReg; assert(rsCurRegArg <= MAX_REG_ARG);
#endif

    /* Mark all trashed registers as such */

    if  (calleeTrashedRegs)
        rsTrashRegSet(calleeTrashedRegs);

    if (MORE_REDUNDANT_LOAD)
    {
        /* Kill all (tracked but really dead) GC pointers as we would
           not have reported them to the emitter when we issued the call.
           Actually only needed if rsCanTrackGCreg() isnt pessimistic
           and allows GC ptrs to be tracked in callee-saved registers. */
        rsTrackRegClrPtr();

        rsTrashAliasedValues();
    }

#if OPTIMIZE_TAIL_REC
DONE:
#endif

#if     TGT_x86

#ifdef  DEBUG

    if  (!(call->gtFlags & GTF_CALL_POP_ARGS))
    {
        if (verbose) printf("End call [%08X] stack %02u [E=%02u] argSize=%u\n",
                            call, saveStackLvl, genEmitter->emitCurStackLvl, argSize);

        assert(stackLvl == genEmitter->emitCurStackLvl);
    }

#endif

    /* All float temps must be spilled around function calls */

    assert(genFPstkLevel == 0);

    /* The function will pop all arguments before returning */

    genStackLevel = saveStackLvl;
    genOnStackLevelChanged();

#endif

    /* No trashed registers may possibly hold a pointer at this point */

#ifdef  DEBUG
#if     TRACK_GC_REFS
    regMaskTP ptrRegs = (gcRegGCrefSetCur|gcRegByrefSetCur);
    if  (ptrRegs & calleeTrashedRegs & ~rsMaskVars & ~vptrMask)
    {
        printf("Bad call handling for %08X\n", call);
        assert(!"A callee trashed reg is holding a GC pointer");
    }
#endif
#endif

#if TGT_x86

#if     INLINE_NDIRECT

    if (call->gtFlags & GTF_CALL_UNMANAGED)
    {
        genDefineTempLabel(returnLabel, true);

        if (getInlinePInvokeCheckEnabled())
        {
            unsigned    baseOffset  = lvaTable[lvaScratchMemVar].lvStkOffs +
                                          info.compNDFrameOffset;
            BasicBlock  *   esp_check;

            CORINFO_EE_INFO * pInfo = eeGetEEInfo();

            /* mov   ecx, dword ptr [frame.callSiteTracker] */

            genEmitter->emitIns_R_AR (INS_mov,
                                      EA_4BYTE,
                                      SR_ECX,
                                      SR_EBP,
                                      baseOffset
                          + pInfo->offsetOfInlinedCallFrameCallSiteTracker);

            /* Generate the conditional jump */

            if (!(call->gtFlags & GTF_CALL_POP_ARGS))
            {
                if (argSize)
                {
                    genEmitter->emitIns_R_I  (INS_add,
                                              EA_4BYTE,
                                              SR_ECX,
                                              argSize);
                }
            }

            /* cmp   ecx, esp */

            genEmitter->emitIns_R_R(INS_cmp, EA_4BYTE, SR_ECX, SR_ESP);

            esp_check = genCreateTempLabel();

            inst_JMP(genJumpKindForOper(GT_EQ, true), esp_check);

            genEmitter->emitIns(INS_int3);

            /* genCondJump() closes the current emitter block */

            genDefineTempLabel(esp_check, true);
        }
    }
#endif

    /* Are we supposed to pop the arguments? */

    if  (call->gtFlags & GTF_CALL_POP_ARGS)
    {
        assert(args == -argSize);

        if (argSize)
        {
            genAdjustSP(argSize);

            /* @TODO [FIXHACK] [04/16/01] []: don't schedule the stack adjustment away from 
               the call instruction We ran into problems with displacement sizes, so for 
               now we take the sledge hammer. The real fix would be in the instruction 
               scheduler to take the instructions accessing a local into account */

            if (!genFPused && opts.compSchedCode)
                genEmitter->emitIns_SchedBoundary();
        }
    }

    /* @TODO [FIXHACK] [04/16/01] [] (Part II): If we emitted the throw-helper call
       on a non-empty stack, we now have to separate the argument pop from
       popping the temps. Otherwise the stack crawler would not know about
       the temps. */

    if  (pseudoStackLvl)
    {
        assert(call->gtType == TYP_VOID);

        /* Generate NOP */

        instGen(INS_nop);
    }

#endif

#if defined(DEBUG) && !NST_FASTCALL
    assert(genCallInProgress == true); genCallInProgress = false;
#endif

    /* What does the function return? */

    retVal = RBM_NONE;

    switch (call->gtType)
    {
    case TYP_REF:
    case TYP_ARRAY:
    case TYP_BYREF:
        gcMarkRegPtrVal(REG_INTRET, call->TypeGet());

        // Fall through ...

    case TYP_INT:
#if!CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
#endif
        retVal = RBM_INTRET;
        break;

    case TYP_LONG:
#if!CPU_HAS_FP_SUPPORT
    case TYP_DOUBLE:
#endif
        retVal = RBM_LNGRET;
        break;

#if CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
    case TYP_DOUBLE:

#if TGT_x86

        /* Tail-recursive calls leave nothing on the FP stack */

#if OPTIMIZE_TAIL_REC
        if  (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILREC)
            break;
#endif

        genFPstkLevel++;
#else
#error  Unexpected target
#endif

        break;
#endif

    case TYP_VOID:
        break;

    default:
        assert(!"unexpected/unhandled fn return type");
    }

#if INLINE_NDIRECT
    // We now have to generate the "call epilog" (if it was a call to unmanaged code).
    /* if it is a call to unmanaged code, varDsc must be set */

    assert((call->gtFlags & GTF_CALL_UNMANAGED) == 0 || varDsc);

    if (varDsc)
        genPInvokeCallEpilog(varDsc, retVal);

#endif  //INLINE_NDIRECT

#ifdef DEBUG
    if (opts.compStackCheckOnCall && call->gtCall.gtCallType == CT_USER_FUNC) 
    {
        assert(lvaCallEspCheck != 0xCCCCCCCC && lvaTable[lvaCallEspCheck].lvVolatile && lvaTable[lvaCallEspCheck].lvOnFrame);
        if (argSize > 0) 
        {
            genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, SR_ECX, SR_ESP);
            genEmitter->emitIns_R_I(INS_sub, EA_4BYTE, SR_ECX, argSize);
            genEmitter->emitIns_S_R(INS_cmp, EA_4BYTE, SR_ECX, lvaCallEspCheck, 0);
        }            
        else 
            genEmitter->emitIns_S_R(INS_cmp, EA_4BYTE, SR_ESP, lvaCallEspCheck, 0);
        
        BasicBlock  *   esp_check = genCreateTempLabel();
        inst_JMP(genJumpKindForOper(GT_EQ, true), esp_check);
        genEmitter->emitIns(INS_int3);
        genDefineTempLabel(esp_check, true);
    }
#endif

#ifdef PROFILER_SUPPORT
#if     TGT_x86

    if (opts.compCallEventCB)
    {
        /* fire the event at the call site */
        /* alas, right now I can only handle calls via a method handle */
        if (call->gtCall.gtCallType == CT_USER_FUNC)
        {
            unsigned        saveStackLvl2 = genStackLevel;
            BOOL            bHookFunction = TRUE;
            CORINFO_PROFILING_HANDLE handle, *pHandle;

            handle = eeGetProfilingHandle(call->gtCall.gtCallMethHnd, &bHookFunction, &pHandle);

            if (bHookFunction)
            {
                handle = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandle);
                assert((!handle) != (!pHandle));

                if (pHandle)
                    genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC, SR_NA,
                                             SR_NA, (int)pHandle);
                else
                    inst_IV(INS_push, (unsigned) handle);

                genSinglePush(false);

                genEmitHelperCall(CORINFO_HELP_PROF_FCN_RET,
                                 sizeof(int),   // argSize
                                 0);            // retSize

                /* Restore the stack level */
                genStackLevel = saveStackLvl2;
                genOnStackLevelChanged();

            }
        }
    }

#endif
#endif

#ifdef DEBUGGING_SUPPORT
    if (opts.compDbgCode && !valUsed && !genFPused &&
        args > 0 && compCurBB->bbJumpKind == BBJ_RETURN)
    {
        /* @TODO [FIXHACK] [04/16/01] []: If we have pushed args on the stack and the epilog
           immediately follows the call instruction, we would not have reported
           the stack variables with the adjusted ESP (Bug 44064). Hence they
           will not be displayed correctly while we are within the call. So
           insert a nop so that they will be reported with the adjusted ESP */

        instGen(INS_nop);
    }
#endif

    return retVal;
}

/*****************************************************************************/
#if ROUND_FLOAT
/*****************************************************************************
 *
 *  Force floating point expression results to memory, to get rid of the extra
 *  80 byte "temp-real" precision.
 *  Assumes the tree operand has been computed to the top of the stack.
 *  If type!=TYP_UNDEF, that is the desired presicion, else it is op->gtType
 */

void                Compiler::genRoundFpExpression(GenTreePtr op,
                                                   var_types type)
{
    // Do nothing with memory resident opcodes - these are the right precision
    // (even if genMakeAddrOrFPstk loads them to the FP stack)

    if (type == TYP_UNDEF)
        type = op->TypeGet();

    switch (op->gtOper)
    {
    case GT_LCL_VAR:
    case GT_LCL_FLD:
    case GT_CLS_VAR:
    case GT_CNS_DBL:
    case GT_IND:
    if (type == op->TypeGet())
        return;
    }

    /* Allocate a temp for the expression */

    TempDsc *       temp = tmpGetTemp(type);

    /* Store the FP value into the temp */

    inst_FS_ST(INS_fstp, EA_ATTR(genTypeSize(type)), temp, 0);

    /* Load the value back onto the FP stack */

    inst_FS_ST(INS_fld , EA_ATTR(genTypeSize(type)), temp, 0);

     genTmpAccessCnt += 2;

   /* We no longer need the temp */

    tmpRlsTemp(temp);
}

/*****************************************************************************/
#endif
/*****************************************************************************/
#ifdef  DEBUG

static
void                hexDump(FILE *dmpf, const char *name, BYTE *addr, size_t size)
{
    if  (!size)
        return;

    assert(addr);

    fprintf(dmpf, "Hex dump of %s:\n\n", name);

    for (unsigned i = 0; i < size; i++)
    {
        if  (!(i % 16))
            fprintf(dmpf, "\n    %04X: ", i);

        fprintf(dmpf, "%02X ", *addr++);
    }

    fprintf(dmpf, "\n\n");
}

#endif
/*****************************************************************************
 *
 *  Generate code for the function.
 */

void                Compiler::genGenerateCode(void * * codePtr,
                                              SIZE_T * nativeSizeOfCode,
                                              void * * consPtr,
                                              void * * dataPtr,
                                              void * * infoPtr)
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In genGenerateCode()\n");
    if  (verboseTrees) fgDispBasicBlocks(true);
#endif
    size_t          codeSize;
    unsigned        prologSize;
    unsigned        prologFinalSize;
    unsigned        epilogSize;
    BYTE            temp[64];
    InfoHdr         header;
    size_t          ptrMapSize;

#ifdef  DEBUG
    size_t          headerSize;
    genIntrptibleUse = true;

    fgDebugCheckBBlist();

    // fix NOW:
    // Can be removed after silly .cctors that do big array inits are gone
    // This causes the scheduler to take too long to run
    if (info.compMethodInfo->ILCodeSize  > 1024 &&
        (fgFirstBB->bbNext == 0 || fgFirstBB->bbNext->bbNext == 0))
    {
        opts.compSchedCode = false;
    }
#endif

//  if  (testMask & 2) assert(genInterruptible == false);

    /* This is the real thing */

    genPrepForCompiler();

    /* Prepare the emitter/scheduler */

    /* Estimate the offsets of locals/arguments and size of frame */

    size_t  lclSize    = lvaFrameSize();
    size_t  maxTmpSize =   sizeof(double) + sizeof(float)
                         + sizeof(__int64)+ sizeof(void*);
 
    maxTmpSize += (tmpDoubleSpillMax * sizeof(double)) + 
                  (tmpIntSpillMax    * sizeof(int));

#ifdef DEBUG

    /* When StressRegs is >=1, there will be a bunch of spills not predicted by
       the predictor (see logic in rsPickReg).  It will be very hard to teach
       the predictor about the behavior of rsPickReg for StressRegs >= 1, so
       instead let's make maxTmpSize large enough so that we won't be wrong.
       This means that at StressRegs >= 1, we will not be testing the logic
       that sets the maxTmpSize size.
    */

    if (rsStressRegs() >= 1)
    {
        maxTmpSize += 8 * sizeof(int);
    }
#endif

    genEmitter->emitBegFN(genFPused,
#if defined(DEBUG) && TGT_x86
                          (compCodeOpt() != SMALL_CODE),
#endif
                          lclSize,
                          maxTmpSize);

    /* Now generate code for the function */

    genCodeForBBlist();

#ifdef  DEBUG
    if  (disAsm)
    {
        printf("; Assembly listing for method '");
        printf("%s:",   info.compClassName);
        printf("%s'\n", info.compMethodName);

        const   char *  doing   = "Emit";
        const   char *  machine = "i486";

#if     SCHEDULER
        if  (opts.compSchedCode)
            doing = "Schedul";
#endif
        if (genCPU == 5)
            machine = "Pentium";
        if (genCPU == 6)
            machine = "Pentium II";
        if (genCPU == 7)
            machine = "Pentium 4";

        if (compCodeOpt() == SMALL_CODE)
            printf("; %sing SMALL_CODE for %s\n",   doing, machine);
        else if (compCodeOpt() == FAST_CODE)
            printf("; %sing FAST_CODE for %s\n",    doing, machine);
        else
            printf("; %sing BLENDED_CODE for %s\n", doing, machine);

        if (opts.compDbgCode)
            printf("; debuggable code\n");
        else
            printf("; optimized code\n");

        if (genDoubleAlign)
            printf("; double-aligned frame\n");
        else if (genFPused)
            printf("; EBP based frame\n");
        else
            printf("; ESP based frame\n");

        if (genInterruptible)
            printf("; fully interruptible\n");
        else
            printf("; partially interruptible\n");

    }
#endif

    /* We can now generate the function prolog and epilog */

    prologSize = genFnProlog();
#if!TGT_RISC
                 genFnEpilog();
#endif

#if VERBOSE_SIZES || DISPLAY_SIZES

    size_t          dataSize =  genEmitter->emitDataSize(false) +
                                genEmitter->emitDataSize( true);

#endif

#ifdef DEBUG

    // We trigger the fallback here, because if not we will leak mem, as the current codebase
    // can't free the mem if after the emitter ask the EE for it. As this is only a stress mode, we only
    // want the functionality, and don't care about the relative ugliness of having the failure
    // here
    static ConfigDWORD fJitForceFallback(L"JitForceFallback", 0);

    if (fJitForceFallback.val() && !jitFallbackCompile)
    {
        NO_WAY_NOASSERT("Stress failure");
    }
#endif


    /* We're done generating code for this function */
    codeSize = genEmitter->emitEndCodeGen( this,
                                           !opts.compDbgEnC, // are tracked stk-ptrs contiguous ?
                                           genInterruptible,
                                           genFullPtrRegMap,
                                           (info.compRetType == TYP_REF),
                                           &prologFinalSize,
                                           &epilogSize,
                                           codePtr,
                                           consPtr,
                                           dataPtr);

    // Ok, now update the final prolog size
    if (prologFinalSize <= prologSize)
    {
        prologSize = prologFinalSize;
    }
    else
    {
        // This can only be true for partially interruptible methods. 
        // or functions with varargs or when we're checking that ESP is ok on return.
        // We do this because genfnProlog emits instructions for this but doesn't
        // take them in account for the size.
        assert(!genInterruptible || info.compIsVarArgs || opts.compStackCheckOnRet);
    }

    /* Check our max stack level. Needed for fgAddCodeRef().
       We need to relax the assert as our estimation wont include code-gen
       stack changes (which we know dont affect fgAddCodeRef()) */
    assert(genEmitter->emitMaxStackDepth <= (fgPtrArgCntMax +
                                             info.compXcptnsCount + // Return address for locall-called finallys
                                             genTypeStSz(TYP_LONG) + // longs/doubles may be transferred via stack, etc
                                             (compTailCallUsed?4:0))); // CORINFO_HELP_TAILCALL args

    *nativeSizeOfCode = (SIZE_T)codeSize;
//  printf("%6u bytes of code generated for %s.%s\n", codeSize, info.compFullName);

#if TGT_x86
    // Make sure that the x86 alignment and cache prefetch optimization rules
    // were obeyed.

    // Don't start a method in the last 7 bytes of a 16-byte alignment area
    //   unless we are generating SMALL_CODE
    assert( (((unsigned)(*codePtr) % 16) <= 8) || (compCodeOpt() == SMALL_CODE));
#endif

#ifdef DEBUGGING_SUPPORT

    /* Finalize the line # tracking logic after we know the exact block sizes/offsets */

    if (opts.compDbgInfo)
        genIPmappingGen();

    /* Finalize the Local Var info in terms of generated code */

    if (opts.compScopeInfo)
        genSetScopeInfo();

#endif

#ifdef LATE_DISASM
    if (opts.compLateDisAsm)
        genDisAsm.disAsmCode((BYTE*)*codePtr, codeSize);
#endif

    /* Are there any exception handlers? */

    if  (info.compXcptnsCount)
    {
        unsigned        XTnum;
        EHblkDsc *      HBtab;

        eeSetEHcount(info.compCompHnd, info.compXcptnsCount);

        for (XTnum = 0, HBtab = compHndBBtab;
             XTnum < info.compXcptnsCount;
             XTnum++  , HBtab++)
        {
            DWORD       flags = HBtab->ebdFlags;

            NATIVE_IP   tryBeg, tryEnd, hndBeg, hndEnd, hndTyp;

            assert(HBtab->ebdTryBeg);
            assert(HBtab->ebdHndBeg);
            tryBeg = genEmitter->emitCodeOffset(HBtab->ebdTryBeg->bbEmitCookie, 0);
            hndBeg = genEmitter->emitCodeOffset(HBtab->ebdHndBeg->bbEmitCookie, 0);

            // If HBtab->ebdTryEnd or HBtab->ebdHndEnd are NULL,
            // it means use the end of the method
            tryEnd = (HBtab->ebdTryEnd == 0) ? codeSize
                    : genEmitter->emitCodeOffset(HBtab->ebdTryEnd->bbEmitCookie, 0);
            hndEnd = (HBtab->ebdHndEnd == 0) ? codeSize
                    : genEmitter->emitCodeOffset(HBtab->ebdHndEnd->bbEmitCookie, 0);

            if (HBtab->ebdFlags & CORINFO_EH_CLAUSE_FILTER)
            {
                assert(HBtab->ebdFilter);
                hndTyp = genEmitter->emitCodeOffset(HBtab->ebdFilter->bbEmitCookie, 0);
            }
            else
            {
                hndTyp = HBtab->ebdTyp;
            }

            CORINFO_EH_CLAUSE clause;
            clause.ClassToken    = hndTyp;
            clause.Flags         = (CORINFO_EH_CLAUSE_FLAGS)flags;
            clause.TryOffset     = tryBeg;
            clause.TryLength     = tryEnd;
            clause.HandlerOffset = hndBeg;
            clause.HandlerLength = hndEnd;
            eeSetEHinfo(info.compCompHnd, XTnum, &clause);
#ifdef  DEBUG
            if  (verbose&&dspCode)
                printf("try [%04X..%04X] handled by [%04X..%04X] (class: %004X)\n",
                       tryBeg, tryEnd, hndBeg, hndEnd, hndTyp);
#endif

        }
    }

#if TRACK_GC_REFS
    int s_cached;
#ifdef  DEBUG
    headerSize      =
#endif
    compInfoBlkSize = gcInfoBlockHdrSave(temp,
                                         0,
                                         codeSize,
                                         prologSize,
                                         epilogSize,
                                         &header,
                                         &s_cached);

    ptrMapSize      = gcPtrTableSize(header, codeSize);

#if DISPLAY_SIZES

    if (genInterruptible)
    {
        gcHeaderISize += compInfoBlkSize;
        gcPtrMapISize += ptrMapSize;
    }
    else
    {
        gcHeaderNSize += compInfoBlkSize;
        gcPtrMapNSize += ptrMapSize;
    }

#endif

    compInfoBlkSize += ptrMapSize;

    /* Allocate the info block for the method */

    compInfoBlkAddr = (BYTE *)eeAllocGCInfo(info.compCompHnd, compInfoBlkSize);

    if  (!compInfoBlkAddr)
    {
        /* No need to deallocate the other VM blocks, VM will clean up on failure */

        NOMEM();
    }

#if VERBOSE_SIZES

//  if  (compInfoBlkSize > codeSize && compInfoBlkSize > 100)
    {
        printf("[%7u VM, %7u+%7u/%7u x86 %03u/%03u%%] %s.%s\n", info.compCodeSize,
                                                             compInfoBlkSize,
                                                             codeSize + dataSize,
                                                             codeSize + dataSize - prologSize - epilogSize,
                                                             100*(codeSize+dataSize)/info.compCodeSize,
                                                             100*(codeSize+dataSize+compInfoBlkSize)/info.compCodeSize,
                                                             info.compClassName, info.compMethodName);
    }

#endif

    /* Fill in the info block and return it to the caller */

    *infoPtr = compInfoBlkAddr;

    /* Create the method info block: header followed by GC tracking tables */

    compInfoBlkAddr += gcInfoBlockHdrSave(compInfoBlkAddr, -1,
                                          codeSize,
                                          prologSize,
                                          epilogSize,
                                          &header,
                                          &s_cached);

    assert(compInfoBlkAddr == (BYTE*)*infoPtr + headerSize);
    compInfoBlkAddr = gcPtrTableSave(compInfoBlkAddr, header, codeSize);
    assert(compInfoBlkAddr == (BYTE*)*infoPtr + headerSize + ptrMapSize);

#ifdef  DEBUG

    if  (0)
    {
        BYTE    *   temp = (BYTE *)*infoPtr;
        unsigned    size = compInfoBlkAddr - temp;
        BYTE    *   ptab = temp + headerSize;

        assert(size == headerSize + ptrMapSize);

        printf("Method info block - header [%u bytes]:", headerSize);

        for (unsigned i = 0; i < size; i++)
        {
            if  (temp == ptab)
            {
                printf("\nMethod info block - ptrtab [%u bytes]:", ptrMapSize);
                printf("\n    %04X: %*c", i & ~0xF, 3*(i&0xF), ' ');
            }
            else
            {
                if  (!(i % 16))
                    printf("\n    %04X: ", i);
            }

            printf("%02X ", *temp++);
        }

        printf("\n");
    }

#endif

#if TGT_x86
#if DUMP_GC_TABLES

    if  ((dspInfoHdr || dspGCtbls) && savCode)
    {
        const BYTE *base = (BYTE *)*infoPtr;
        unsigned    size;
        unsigned    methodSize;
        InfoHdr     header;

        printf("GC Info for method %s\n", info.compFullName);
        printf("GC info size = %3u\n", compInfoBlkSize);

        size = gcInfoBlockHdrDump(base, &header, &methodSize);
        // printf("size of header encoding is %3u\n", size);
        printf("\n");

        if  (dspGCtbls)
        {
            base   += size;
            size    = gcDumpPtrTable(base, header, methodSize);
            // printf("size of pointer table is %3u\n", size);
            printf("\n");
            assert(compInfoBlkAddr == (base+size));
        }

    }

    if  (testMask & 128)
    {
        for (unsigned offs = 0; offs < codeSize; offs++)
        {
            gcFindPtrsInFrame(*infoPtr, *codePtr, offs);
        }
    }

#endif
#endif

    /* Make sure we ended up generating the expected number of bytes */

    assert(compInfoBlkAddr == (BYTE *)*infoPtr + compInfoBlkSize);

#ifdef  DEBUG

    FILE    *   dmpf = stdout;

    dmpHex = false;
    if  (!strcmp(info.compMethodName, "<name of method you want the hex dump for"))
    {
        FILE    *   codf = fopen("C:\\JIT.COD", "at");  // NOTE: file append mode

        if  (codf)
        {
            dmpf   = codf;
            dmpHex = true;
        }
    }
    if  (dmpHex)
    {
        size_t          dataSize = genEmitter->emitDataSize(false);

        size_t          consSize = genEmitter->emitDataSize(true);

        size_t          infoSize = compInfoBlkSize;


        fprintf(dmpf, "Generated code for %s.%s:\n", info.compFullName);
        fprintf(dmpf, "\n");

        if (codeSize) fprintf(dmpf, "    Code  at %08X [%04X bytes]\n", *codePtr, codeSize);
        if (consSize) fprintf(dmpf, "    Const at %08X [%04X bytes]\n", *consPtr, consSize);
        if (dataSize) fprintf(dmpf, "    Data  at %08X [%04X bytes]\n", *dataPtr, dataSize);
        if (infoSize) fprintf(dmpf, "    Info  at %08X [%04X bytes]\n", *infoPtr, infoSize);

        fprintf(dmpf, "\n");

        if (codeSize) hexDump(dmpf, "Code" , (BYTE*)*codePtr, codeSize);
        if (consSize) hexDump(dmpf, "Const", (BYTE*)*consPtr, consSize);
        if (dataSize) hexDump(dmpf, "Data" , (BYTE*)*dataPtr, dataSize);
        if (infoSize) hexDump(dmpf, "Info" , (BYTE*)*infoPtr, infoSize);

        fflush(dmpf);
    }

#endif

#endif // TRACK_GC_REFS

    /* Tell the emitter/scheduler that we're done with this function */

    genEmitter->emitEndFN();

    /* Shut down the spill logic */

    rsSpillDone();

    /* Shut down the temp logic */

    tmpDone();

#if DISPLAY_SIZES

    grossVMsize += info.compCodeSize;
    totalNCsize += codeSize + dataSize + compInfoBlkSize;
    grossNCsize += codeSize + dataSize;

#endif

}

/*****************************************************************************
 *
 *  Generates code for moving incoming register arguments to their
 *  assigned location, in the function prolog.
 */

void            Compiler::genFnPrologCalleeRegArgs()
{
    assert(rsCalleeRegArgMaskLiveIn);
    assert(rsCalleeRegArgNum <= MAX_REG_ARG);

    unsigned    argNum         = 0;
    unsigned    regArgNum;
    unsigned    nonDepCount    = 0;
    regMaskTP   regArgMaskLive = rsCalleeRegArgMaskLiveIn;

    /* Construct a table with the register arguments
     * To make it easier to detect circular dependencies
     * the table is constructed in the order the arguments
     * are passed in registers (i.e. first reg arg in tab[0], etc.) */

    struct
    {
        unsigned    varNum;
        unsigned    trashBy;
        bool        stackArg;
        bool        processed;
        bool        circular;
    } regArgTab [MAX_REG_ARG];

    unsigned    varNum;
    LclVarDsc * varDsc;

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        /* Is this variable a register arg? */

        if  (!varDsc->lvIsParam)
            continue;

        if  (!varDsc->lvIsRegArg)
            continue;

        /* Bingo - add it to our table */

        assert(argNum < rsCalleeRegArgNum);
        argNum++;

        regArgNum = genRegArgIdx(varDsc->lvArgReg);
        assert(regArgNum < rsCalleeRegArgNum);

        regArgTab[regArgNum].varNum    = varNum;

        // Is the arg dead on entry to the method ?

        if ((regArgMaskLive & genRegMask(varDsc->lvArgReg)) == 0)
        {
            assert(varDsc->lvTracked &&
                   (genVarIndexToBit(varDsc->lvVarIndex) & fgFirstBB->bbLiveIn) == 0);

            // Mark it as processed and be done with it
            regArgTab[regArgNum].processed = true;
            goto NON_DEP;
        }

        assert(regArgMaskLive & genRegMask(varDsc->lvArgReg));

        regArgTab[regArgNum].processed = false;

        /* If it goes on the stack or in a register that doesn't hold
         * an argument anymore -> CANNOT form a circular dependency */

        if ( varDsc->lvRegister                              &&
            (genRegMask(varDsc->lvRegNum) & regArgMaskLive)   )
        {
            /* will trash another argument -> posible dependency
             * We may need several passes after the table is constructed
             * to decide on that */

            regArgTab[regArgNum].stackArg  = false;

            /* Maybe the argument stays in the register (IDEAL) */

            if (varDsc->lvRegNum == varDsc->lvArgReg)
                goto NON_DEP;
            else
                regArgTab[regArgNum].circular  = true;
        }
        else
        {
            /* either stack argument or goes to a free register */
            assert((!varDsc->lvRegister)                                                   ||
                    (varDsc->lvRegister && !(genRegMask(varDsc->lvRegNum) & regArgMaskLive)) );

            /* mark stack arguments since we will take care of those first */
            regArgTab[regArgNum].stackArg  = (varDsc->lvRegister) ? false : true;

        NON_DEP:

            regArgTab[regArgNum].circular  = false;
            nonDepCount++;

            /* mark the argument register as free */
            regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
        }
    }

    assert(argNum == rsCalleeRegArgNum);

    /* Find the circular dependencies for the argument registers if any
     * A circular dependency is a set of registers R1, R2, ..., Rn
     * such that R1->R2, R2->R3, ..., Rn->R1 */

    bool    change = true;

    if (nonDepCount < rsCalleeRegArgNum)
    {
        /* possible circular dependencies - the previous pass was not enough
         * to filter them out -> use a "sieve" strategy to find all circular
         * dependencies */

        assert(regArgMaskLive);

        while (change)
        {
            change = false;

            for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
            {
                /* If we already marked the argument as non-circular continue */

                if (!regArgTab[argNum].circular)
                     continue;

                varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
                varDsc = lvaTable + varNum;
                assert(varDsc->lvIsParam && varDsc->lvIsRegArg);

                /* cannot possibly have stack arguments */
                assert(varDsc->lvRegister);
                assert(!regArgTab[argNum].stackArg);

                assert(argNum == genRegArgIdx(varDsc->lvArgReg));

                if (genRegMask(varDsc->lvRegNum) & regArgMaskLive)
                {
                    /* we are trashing a live argument register - record it */
                    regArgNum = genRegArgIdx(varDsc->lvRegNum);
                    assert(regArgNum < rsCalleeRegArgNum);
                    regArgTab[regArgNum].trashBy  = argNum;
                }
                else
                {
                    /* argument goes to a free register */
                    regArgTab[argNum].circular  = false;
                    nonDepCount++;
                    change = true;

                    /* mark the argument register as free */
                    regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
                }
            }
        }
    }

    /* At this point, everything that has the "circular" flag
     * set to "true" forms a circular dependency */

#ifdef DEBUG
    if (nonDepCount < rsCalleeRegArgNum)
    {
        assert(rsCalleeRegArgNum - nonDepCount >= 2);
        assert(regArgMaskLive);

        // assert(!"Circular dependencies!");

        if (verbose)
        {
            printf("Circular dependencies found:\n");

        }
    }
#endif

    /* Now move the arguments to their locations
     * First consider ones that go on the stack since they may
     * free some registers */

    regArgMaskLive = rsCalleeRegArgMaskLiveIn;

    for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
    {
        int             stkOfs;
        emitAttr        size;

        /* If the arg is dead on entry to the method, skip it */

        if (regArgTab[argNum].processed)
            continue;

        /* If not a stack arg go to the next one */

        if (!regArgTab[argNum].stackArg)
            continue;

        assert(regArgTab[argNum].circular  == false);

        varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
        varDsc = lvaTable + varNum;

        assert(varDsc->lvIsParam);
        assert(varDsc->lvIsRegArg);
        assert(varDsc->lvRegister == false);
        assert(genTypeSize(genActualType(varDsc->TypeGet())) == sizeof(void *));

        size = emitActualTypeSize(genActualType(varDsc->TypeGet()));

        /* Stack argument - if the ref count is 0 don't care about it */

        if (!varDsc->lvOnFrame)
        {
            assert(varDsc->lvRefCnt == 0);
        }
        else
        {
            stkOfs = varDsc->lvStkOffs;
#if TGT_x86
            genEmitter->emitIns_S_R(INS_mov,
                                    size,
                                    (emitRegs)(regNumber)varDsc->lvArgReg,
                                    varNum,
                                    0);
#else
            assert(!"need RISC code");
#endif

#ifdef DEBUGGING_SUPPORT
            if (opts.compScopeInfo && info.compLocalVarsCount>0)
                psiMoveToStack(varNum);
#endif
        }

        /* mark the argument as processed */

        regArgTab[argNum].processed = true;
        regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
    }

    /* Process any circular dependencies */

    if (nonDepCount < rsCalleeRegArgNum)
    {
        unsigned        begReg, destReg, srcReg;
        unsigned        varNumDest, varNumSrc;
        LclVarDsc   *   varDscDest;
        LclVarDsc   *   varDscSrc;
        regNumber       xtraReg;

        assert(rsCalleeRegArgNum - nonDepCount >= 2);

        for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
        {
            /* If not a circular dependency continue */

            if (!regArgTab[argNum].circular)
                continue;

            /* If already processed the dependency continue */

            if (regArgTab[argNum].processed)
                continue;

#if TGT_x86

            destReg = begReg = argNum;
            srcReg  = regArgTab[argNum].trashBy; assert(srcReg < rsCalleeRegArgNum);

            varNumDest = regArgTab[destReg].varNum; assert(varNumDest < lvaCount);
            varDscDest = lvaTable + varNumDest;
            assert(varDscDest->lvIsParam && varDscDest->lvIsRegArg);

            varNumSrc = regArgTab[srcReg].varNum; assert(varNumSrc < lvaCount);
            varDscSrc = lvaTable + varNumSrc;
            assert(varDscSrc->lvIsParam && varDscSrc->lvIsRegArg);

            emitAttr size = EA_4BYTE;

            if (destReg == regArgTab[srcReg].trashBy)
            {
                /* only 2 registers form the circular dependency - use "xchg" */

                varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
                varDsc = lvaTable + varNum;
                assert(varDsc->lvIsParam && varDsc->lvIsRegArg);

                assert(genTypeSize(genActualType(varDscSrc->TypeGet())) == sizeof(int));

                /* Set "size" to indicate GC if one and only one of
                 * the operands is a pointer
                 * RATIONALE: If both are pointers, nothing changes in
                 * the GC pointer tracking. If only one is a pointer we
                 * have to "swap" the registers in the GC reg pointer mask
                 */

                if  (varTypeGCtype(varDscSrc->TypeGet()) !=
                     varTypeGCtype(varDscDest->TypeGet()))
                {
                    size = EA_GCREF;
                }

                assert(varDscDest->lvArgReg == varDscSrc->lvRegNum);

                genEmitter->emitIns_R_R(INS_xchg,
                                        size,
                                        (emitRegs)(regNumber)varDscSrc->lvRegNum,
                                        (emitRegs)(regNumber)varDscSrc->lvArgReg);

                /* mark both arguments as processed */
                regArgTab[destReg].processed = true;
                regArgTab[srcReg].processed  = true;

                regArgMaskLive &= ~genRegMask(varDscSrc->lvArgReg);
                regArgMaskLive &= ~genRegMask(varDscDest->lvArgReg);

#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                {
                    psiMoveToReg(varNumSrc );
                    psiMoveToReg(varNumDest);
                }
#endif
            }
            else
            {
                /* more than 2 registers in the dependency - need an
                 * additional register. Pick a callee saved,
                 * if none pick a callee thrashed that is not in
                 * regArgMaskLive (i.e. register arguments that end up on
                 * stack), otherwise push / pop one of the circular
                 * registers */

                xtraReg = REG_STK;

                if  (rsMaskModf & RBM_ESI)
                    xtraReg = REG_ESI;
                else if (rsMaskModf & RBM_EDI)
                    xtraReg = REG_EDI;
                else if (rsMaskModf & RBM_EBX)
                    xtraReg = REG_EBX;
                else if (!(regArgMaskLive & RBM_EDX))
                    xtraReg = REG_EDX;
                else if (!(regArgMaskLive & RBM_ECX))
                    xtraReg = REG_ECX;
                else if (!(regArgMaskLive & RBM_EAX))
                    xtraReg = REG_EAX;

                if (xtraReg == REG_STK)
                {
                    /* This can never happen for x86 - in the RISC case
                     * REG_STK will be the temp register */
                    assert(!"Couldn't find an extra register to solve circular dependency!");
                    NO_WAY("Cannot solve circular dependency!");
                }

                /* move the dest reg (begReg) in the extra reg */

                if  (varDscDest->lvType == TYP_REF)
                    size = EA_GCREF;

                genEmitter->emitIns_R_R (INS_mov,
                                         size,
                                         (emitRegs)(regNumber)xtraReg,
                                         (emitRegs)(regNumber)varDscDest->lvArgReg);

#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                    psiMoveToReg(varNumDest, xtraReg);
#endif

                /* start moving everything to its right place */

                while (srcReg != begReg)
                {
                    /* mov dest, src */

                    assert(varDscDest->lvArgReg == varDscSrc->lvRegNum);

                    size = (varDscSrc->lvType == TYP_REF) ? EA_GCREF
                                                          : EA_4BYTE;

                    genEmitter->emitIns_R_R(INS_mov,
                                             size,
                                             (emitRegs)(regNumber)varDscDest->lvArgReg,
                                             (emitRegs)(regNumber)varDscSrc->lvArgReg);

                    /* mark 'src' as processed */
                    regArgTab[srcReg].processed  = true;
                    regArgMaskLive &= ~genRegMask(varDscSrc->lvArgReg);

                    /* move to the next pair */
                    destReg = srcReg;
                    srcReg = regArgTab[srcReg].trashBy; assert(srcReg < rsCalleeRegArgNum);

                    varDscDest = varDscSrc;

                    varNumSrc = regArgTab[srcReg].varNum; assert(varNumSrc < lvaCount);
                    varDscSrc = lvaTable + varNumSrc;
                    assert(varDscSrc->lvIsParam && varDscSrc->lvIsRegArg);
                }

                /* take care of the beginning register */

                assert(srcReg == begReg);
                assert(varDscDest->lvArgReg == varDscSrc->lvRegNum);

                /* move the dest reg (begReg) in the extra reg */

                size = (varDscSrc->lvType == TYP_REF) ? EA_GCREF
                                                      : EA_4BYTE;

                genEmitter->emitIns_R_R(INS_mov,
                                        size,
                                        (emitRegs)(regNumber)varDscSrc->lvRegNum,
                                        (emitRegs)(regNumber)xtraReg);

#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                    psiMoveToReg(varNumSrc);
#endif
                /* mark the beginning register as processed */

                regArgTab[srcReg].processed  = true;
                regArgMaskLive &= ~genRegMask(varDscSrc->lvArgReg);
            }
#else
            assert(!"need RISC code");
#endif
        }
    }

    /* Finally take care of the remaining arguments that must be enregistered */

    while (regArgMaskLive)
    {
        for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
        {
            emitAttr        size;

            /* If already processed go to the next one */
            if (regArgTab[argNum].processed)
                continue;

            varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
            varDsc = lvaTable + varNum;
            assert(varDsc->lvIsParam && varDsc->lvIsRegArg);
            assert(genTypeSize(genActualType(varDsc->TypeGet())) == sizeof (void *));

            size = emitActualTypeSize(varDsc->TypeGet());

            assert(varDsc->lvRegister && !regArgTab[argNum].circular);

            /* Register argument - hopefully it stays in the same register */

            if (varDsc->lvRegNum != varDsc->lvArgReg)
            {
                /* Cannot trash a currently live register argument
                 * Skip this one until its source will be free
                 * which is guaranteed to happen since we have no circular dependencies */

                if (genRegMask(varDsc->lvRegNum) & regArgMaskLive)
                    continue;

                /* Move it to the new register */

                genEmitter->emitIns_R_R(INS_mov,
                                         size,
                                         (emitRegs)(regNumber)varDsc->lvRegNum,
                                         (emitRegs)(regNumber)varDsc->lvArgReg);
#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                    psiMoveToReg(varNum);
#endif
            }

            /* mark the argument as processed */

            regArgTab[argNum].processed = true;
            regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
        }
    }
}

/*****************************************************************************
 *
 *  Generates code for a function prolog.
 */

/* <EMAIL>
 * *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***
 * 
 * If you change the instructions emitted for the prolog of a method, you may
 * break some external profiler vendors that have dependencies on the current
 * prolog sequences.  Make sure to discuss any such changes with Jim Miller,
 * who will notify the external vendors as appropriate.
 *
 * *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***
 * </EMAIL> */

size_t              Compiler::genFnProlog()
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In genFnProlog()\n");
#endif

    size_t          size;

    unsigned        varNum;
    LclVarDsc   *   varDsc;

    TempDsc *       tempThis;

#ifdef  DEBUG
    genIntrptibleUse = true;
#endif

#if TGT_x86

    /*-------------------------------------------------------------------------
     *
     *  We have to decide whether we're going to use "REP STOS" in
     *  the prolog before we assign final stack offsets. Whether
     *  we push EDI in the prolog affects ESP offsets of locals,
     *  and the saving/restoring of EDI may depend on whether we
     *  use "REP STOS".
     *
     *  We'll count the number of locals we have to initialize,
     *  and if there are lots of them we'll use "REP STOS".
     *
     *  At the same time we set lvMustInit for locals (enregistred or on stack)
     *  that must be initialized (e.g. initiliaze memory (comInitMem),
     *  untracked pointers or disable DFA
     */

    bool            useRepStosd = false;

#endif

    gcResetForBB();

    unsigned        initStkLclCnt = 0;
    unsigned        largeGcStructs = 0;

    // @TODO [REVISIT] [04/16/01] []: factor the logic that computes the initialization range,
    // and use that here to decide whether to use REP STOD - vancem

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        if  (varDsc->lvIsParam)
            continue;

        if (!varDsc->lvRegister && !varDsc->lvOnFrame)
        {
            assert(varDsc->lvRefCnt == 0);
            continue;
        }

        if (info.compInitMem || varTypeIsGC(varDsc->TypeGet()) || varDsc->lvMustInit)
        {
            if (varDsc->lvTracked)
            {
                /* For uninitialized use of tracked variables, the liveness
                 * will bubble to the top (fgFirstBB) in fgGlobalDataFlow()
                 */

                VARSET_TP varBit = genVarIndexToBit(varDsc->lvVarIndex);

                if (varDsc->lvMustInit || (varBit & fgFirstBB->bbLiveIn))
                {
                    /* This var must be initialized */
                    /* This must get set in rpPredictAssignRegVars */

                    assert(varDsc->lvMustInit);

                    /* See if the variable is on the stack will be initialized
                     * using rep stos - compute the total size to be zero-ed */

                    if (varDsc->lvOnFrame)
                    {
                        if (!varDsc->lvRegister)
                        {
                            // Var is completely on the stack
                            initStkLclCnt += genTypeStSz(varDsc->TypeGet());
                        }
                        else
                        {
                            // Var is paritally enregistered
                            assert(genTypeSize(varDsc->TypeGet()) > sizeof(int) &&
                                   varDsc->lvOtherReg == REG_STK);
                            initStkLclCnt += genTypeStSz(TYP_INT);
                        }
                    }
                }
            }
            else if (varDsc->lvOnFrame)
            {
                /* With compInitMem, all untracked vars will have to be init'ed */

                varDsc->lvMustInit = true;

                initStkLclCnt += roundUp(lvaLclSize(varNum)) / sizeof(int);
            }

            continue;
        }

        /* Ignore if not a pointer variable or value class with a GC field */

        if    (!lvaTypeIsGC(varNum))
                continue;

#if CAN_DISABLE_DFA

        /* If we don't know lifetimes of variables, must be conservative */

        if  (opts.compMinOptim)
        {
            varDsc->lvMustInit = true;
            assert(!varDsc->lvRegister);
        }
        else
#endif
        {
            if (!varDsc->lvTracked)
                varDsc->lvMustInit = true;
        }

        /* Is this a 'must-init' stack pointer local? */

        if  (varDsc->lvMustInit && varDsc->lvOnFrame)
            initStkLclCnt += varDsc->lvStructGcCount;

        if (lvaLclSize(varNum) > 3 * sizeof(void*) && largeGcStructs <= 4)
            largeGcStructs++;
    }

    /* Don't forget about spill temps that hold pointers */

    if  (!TRACK_GC_TEMP_LIFETIMES)
    {
        for (tempThis = tmpListBeg();
             tempThis;
             tempThis = tmpListNxt(tempThis))
        {
            if  (varTypeIsGC(tempThis->tdTempType()))
                initStkLclCnt++;
        }
    }

#if TGT_x86

    /* If we have more than 4 untracked locals, use "rep stosd" */
    /* Hack, if we have large structs, bias toward not using rep stosd since 
       we waste all the other slots.  Really need to compute the correct
       and compare that against zeroing the slots individually */

    if  (initStkLclCnt > largeGcStructs + 4)
        useRepStosd = true;

    /* If we're going to use "REP STOS", remember that we will trash EDI */

    if  (useRepStosd)
    {
        /* For fastcall we will have to save ECX, EAX
         * so reserve two extra callee saved
         * This is better than pushing eax, ecx, because we in the later
         * we will mess up already computed offsets on the stack (for ESP frames)
         * @TODO [CONSIDER] [04/16/01] []: once the final calling convention is established
         * clean up this (i.e. will already have a callee trashed register handy
         */

        rsMaskModf |= RBM_EDI;

        if  (rsCalleeRegArgMaskLiveIn & RBM_ECX)
            rsMaskModf |= RBM_ESI;

        if  (rsCalleeRegArgMaskLiveIn & RBM_EAX)
            rsMaskModf |= RBM_EBX;
    }

    if (compTailCallUsed)
        rsMaskModf |= RBM_CALLEE_SAVED;

    /* Count how many callee-saved registers will actually be saved (pushed) */

    compCalleeRegsPushed = 0;

    if  (               rsMaskModf & RBM_EDI)    compCalleeRegsPushed++;
    if  (               rsMaskModf & RBM_ESI)    compCalleeRegsPushed++;
    if  (               rsMaskModf & RBM_EBX)    compCalleeRegsPushed++;
    if  (!genFPused && (rsMaskModf & RBM_EBP))   compCalleeRegsPushed++;

    /* Assign offsets to things living on the stack frame */

    lvaAssignFrameOffsets(true);

    /* We want to make sure that the prolog size calculated here is accurate
       (that is instructions will not shrink because of concervative stack
       frame approximations).  We do this by filling in the correct size
       here (were we have committed to the final numbers for the frame offsets)
       This will insure that the prolog size is always correct 

       @TODO [CONSIDER] [5/1/01] This is too fragile.  It seems to me that 
        we should simply get the prolog size after we emit the code (when we
        know its right).  The only problem with doing this is that we end
        the 'official' prolog early for partially interruptable code and it
        so we need add a label (or start a new code group), to mark that spot.
        The fix below is easier for now.
    */
    genEmitter->emitMaxTmpSize = tmpSize;

#endif

#ifdef DEBUG
    if  (dspCode || disAsm || disAsm2 || verbose)
        lvaTableDump(false);
#endif

    /* Ready to start on the prolog proper */

    genEmitter->emitBegProlog();

#ifdef DEBUGGING_SUPPORT
    if (opts.compDbgInfo)
    {
        // Do this so we can put the prolog instruction group ahead of
        // other instruction groups
        genIPmappingAddToFront( ICorDebugInfo::MappingTypes::PROLOG );
    }
#endif //DEBUGGING_SUPPORT

#ifdef  DEBUG
    if  (dspCode) printf("\n__prolog:\n");
#endif

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo && info.compLocalVarsCount>0)
    {
        // Create new scopes for the method-parameters for the prolog-block.
        psiBegProlog();
    }
#endif

#if defined(DEBUG)

    /* Use the following to step into the generated native code */
    static ConfigMethodSet fJitHalt(L"JitHalt");
    if (fJitHalt.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig)))
    {
        /* put a nop first because the debugger and other tools are likely to
           put an int3 at the begining and we don't want to confuse them */

        instGen(INS_nop);
        instGen(INS_int3);

        // Don't do an assert, but just put up the dialog box so we get just-in-time debugger
        // launching.  When you hit 'retry' it will continue and naturally stop at the INT 3
        // that the JIT put in the code
        _DbgBreakCheck(__FILE__, __LINE__, "JitHalt");
    }

#endif // DLL_JIT

    /*-------------------------------------------------------------------------
     *
     *  Record the stack frame ranges that will cover all of the tracked
     *  and untracked pointer variables.
     *  Also find which registers will need to be zero-initialized
     */

    int             untrLclLo   =  +INT_MAX;
    int             untrLclHi   =  -INT_MAX;

    int             GCrefLo     =  +INT_MAX;
    int             GCrefHi     =  -INT_MAX;

    regMaskTP       initRegs    =  RBM_NONE;       // Registers which must be init'ed

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        if  (varDsc->lvIsParam && !varDsc->lvIsRegArg)
            continue;

        if  (!varDsc->lvRegister && !varDsc->lvOnFrame)
        {
            assert(varDsc->lvRefCnt == 0);
            continue;
        }

        signed int loOffs =   varDsc->lvStkOffs;
        signed int hiOffs =   varDsc->lvStkOffs
                            + lvaLclSize(varNum)
                            - sizeof(int);

        /* We need to know the offset range of tracked stack GC refs */
        /* We assume that the GC reference can be anywhere in the TYP_STRUCT */

        if (lvaTypeIsGC(varNum) && varDsc->lvTracked && varDsc->lvOnFrame)
        {
            if (loOffs < GCrefLo)  GCrefLo = loOffs;
            if (hiOffs > GCrefHi)  GCrefHi = hiOffs;
        }

        /* For lvMustInit vars, gather pertinent info */

        if  (!varDsc->lvMustInit)
            continue;

        if (varDsc->lvRegister)
        {
			// We take care of floating point vars later
			if (!isFloatRegType(varDsc->lvType))
			{
				initRegs            |= genRegMask(varDsc->lvRegNum);

				if (varDsc->lvType == TYP_LONG)
				{
					if (varDsc->lvOtherReg != REG_STK)
					{
						initRegs    |= genRegMask(varDsc->lvOtherReg);
					}
					else
					{
						/* Upper DWORD is on the stack, and needs to be inited */

						loOffs += sizeof(int);
						goto INIT_STK;
					}
		               }
	            }
        }
        else
        {
        INIT_STK:

            if  (loOffs < untrLclLo) untrLclLo = loOffs;
            if  (hiOffs > untrLclHi) untrLclHi = hiOffs;
        }
    }

    /* Don't forget about spill temps that hold pointers */

    if  (!TRACK_GC_TEMP_LIFETIMES)
    {
        for (tempThis = tmpListBeg();
             tempThis;
             tempThis = tmpListNxt(tempThis))
        {
            if  (!varTypeIsGC(tempThis->tdTempType()))
                continue;

            int         stkOffs = tempThis->tdTempOffs();

            assert(stkOffs != BAD_TEMP_OFFSET);
            assert(!genFPused || stkOffs);

//          printf("    Untracked tmp at [EBP-%04X]\n", -stkOffs);

            if  (stkOffs < untrLclLo) untrLclLo = stkOffs;
            if  (stkOffs > untrLclHi) untrLclHi = stkOffs;
        }
    }

#ifdef DEBUG
    if  (verbose)
    {
        if  (initStkLclCnt)
        {
            printf("Found %u lvMustInit stk vars, frame offsets %d through %d\n",
                    initStkLclCnt,                      -untrLclLo, -untrLclHi - sizeof(void *));
        }
    }
#endif

    /*-------------------------------------------------------------------------
     *
     * Now start emitting the part of the prolog which sets up the frame
     */

#if     TGT_x86

    if  (DOUBLE_ALIGN_NEED_EBPFRAME)
    {
        inst_RV   (INS_push, REG_EBP, TYP_REF);

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0) psiAdjustStackLevel(sizeof(int));
#endif

        inst_RV_RV(INS_mov , REG_EBP, REG_ESP);

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0) psiMoveESPtoEBP();
#endif

    }

#if DOUBLE_ALIGN

    if  (genDoubleAlign)
    {
        assert(genFPused == false);
        assert((rsMaskModf & RBM_EBP) == 0);    /* Trashing EBP is out.    */

        inst_RV_IV(INS_and, REG_ESP, -8);
    }

#endif

    if  (compLclFrameSize > 0)
    {
#if DOUBLE_ALIGN

        /* Need to keep ESP aligned if double aligning */

        if (genDoubleAlign && (compLclFrameSize & 4) != 0)
            compLclFrameSize += 4;
#endif

        if (compLclFrameSize == 4)
        {
            // Frame size is 4
            inst_RV(INS_push, REG_EAX, TYP_INT);
        }
        else if (compLclFrameSize < CORINFO_PAGE_SIZE)
        {
            // Frame size is (0x0008..0x1000)
            inst_RV_IV(INS_sub, REG_ESP, compLclFrameSize);
        }
        else if (compLclFrameSize < 3 * CORINFO_PAGE_SIZE)
        {
            // Frame size is (0x1000..0x3000)
            genEmitter->emitIns_AR_R(INS_test, EA_4BYTE,
                                      SR_EAX, SR_ESP, -CORINFO_PAGE_SIZE);
            if (compLclFrameSize >= 0x2000)
                genEmitter->emitIns_AR_R(INS_test, EA_4BYTE,
                                          SR_EAX, SR_ESP, -2 * CORINFO_PAGE_SIZE);
            inst_RV_IV(INS_sub, REG_ESP, compLclFrameSize);
        }
        else
        {
            // Frame size >= 0x3000

            // Emit that following sequence to 'tickle' the pages.
            // Note it is important that ESP not change until this is complete
            // since the tickles could cause a stack overflow, and we need to
            // be able to crawl the stack afterward (which means ESP needs to be known)
            //      xor eax, eax                2
            // loop:
            //      test [esp + eax], eax       3
            //      sub eax, 0x1000             5
            //      cmp EAX, -size              5
            //      jge loop                    2
            //      sub esp, size               6

            inst_RV_RV(INS_xor,  REG_EAX, REG_EAX);         
            genEmitter->emitIns_R_ARR(INS_test, EA_4BYTE, SR_EAX, SR_ESP, SR_EAX, 0);
            inst_RV_IV(INS_sub,  REG_EAX, CORINFO_PAGE_SIZE);
            inst_RV_IV(INS_cmp,  REG_EAX, -compLclFrameSize);
            inst_IV   (INS_jge, -15);   // Branch backwards to Start of Loop

            inst_RV_IV(INS_sub, REG_ESP, compLclFrameSize);
        }

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(compLclFrameSize);
#endif

    }

    assert(RBM_CALLEE_SAVED == (RBM_EBX|RBM_ESI|RBM_EDI|RBM_EBP));

    if  (rsMaskModf & RBM_EDI)
    {
        inst_RV(INS_push, REG_EDI, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

    if  (rsMaskModf & RBM_ESI)
    {
        inst_RV(INS_push, REG_ESI, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

    if  (rsMaskModf & RBM_EBX)
    {
        inst_RV(INS_push, REG_EBX, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

    if  (!genFPused && (rsMaskModf & RBM_EBP))
    {
        inst_RV(INS_push, REG_EBP, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

#ifdef PROFILER_SUPPORT
    if (opts.compEnterLeaveEventCB && !opts.compInprocDebuggerActiveCB)
    {
#if     TGT_x86
        unsigned        saveStackLvl2 = genStackLevel;
        BOOL            bHookFunction = TRUE;
        CORINFO_PROFILING_HANDLE handle, *pHandle;

        handle = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandle);

        // Give profiler a chance to back out of hooking this method
        if (bHookFunction)
        {
            assert((!handle) != (!pHandle));

            if (handle)
                inst_IV(INS_push, (unsigned) handle);
            else
                genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC, SR_NA,
                                         SR_NA, (int)pHandle);

            /* @TODO [FIXHACK] [04/16/01] []: Inside the prolog we don't have proper stack depth tracking */
            /* Therefore we have to lie about it the fact that we are pushing an I4   */
            /* as the argument to the profiler event */

            /*          genSinglePush(false);   */

            genEmitHelperCall(CORINFO_HELP_PROF_FCN_ENTER,
                              0,    // argSize. Again, we have to lie about it
                              0);   // retSize

            /* Restore the stack level */

            genStackLevel = saveStackLvl2;

            genOnStackLevelChanged();
        }
#endif // TGT_x86
    }
#endif // PROFILER_SUPPORT

    genMethodCount();

    /*-------------------------------------------------------------------------
     *
     * Do we have any untracked pointer locals at all,
     * or do we need to initialize memory for locspace?
     */

    if  (useRepStosd)
    {
        /*
            Generate the following code:

                lea     edi, [ebp/esp-OFFS]
                mov     ecx, <size>
                xor     eax, eax
                rep     stosd
         */

        assert(rsMaskModf & RBM_EDI);

        /* For register arguments we may have to save ECX */

        if  (rsCalleeRegArgMaskLiveIn & RBM_ECX)
        {
            assert(rsMaskModf & RBM_ESI);
            inst_RV_RV(INS_mov, REG_ESI, REG_ECX);
        }

        assert((rsCalleeRegArgMaskLiveIn & RBM_EAX) == 0);

        genEmitter->emitIns_R_AR(INS_lea,
                                 EA_4BYTE,
                                 SR_EDI,
                                 genFPused ? SR_EBP : SR_ESP,
                                 untrLclLo);

        inst_RV_IV(INS_mov, REG_ECX, (untrLclHi - untrLclLo)/sizeof(int) + 1);
        inst_RV_RV(INS_xor, REG_EAX, REG_EAX);
        instGen   (INS_r_stosd);

        /* Move back the argument registers */

        if  (rsCalleeRegArgMaskLiveIn & RBM_ECX)
            inst_RV_RV(INS_mov, REG_ECX, REG_ESI);
    }
    else if (initStkLclCnt)
    {
        /* Chose the register to use for initialization */

        regNumber initReg;

        if ((initRegs & ~rsCalleeRegArgMaskLiveIn) != RBM_NONE)
        {
            /* We will use one of the registers that we were planning to zero init anyway */
            /* pick the lowest one */
            regMaskTP tempMask = genFindLowestBit(initRegs & ~rsCalleeRegArgMaskLiveIn);
            initReg = genRegNumFromMask(tempMask);            /* set initReg */
        }
        else
        {
            initReg = REG_EAX;                      // otherwise we use EAX
        }
        assert((genRegMask(initReg) & rsCalleeRegArgMaskLiveIn) == 0);  // initReg is not a argument reg

        bool initRegZeroed = false;

        /* Initialize any lvMustInit vars on the stack */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount;
             varNum++  , varDsc++)
        {
            if  (!varDsc->lvMustInit)
                continue;

            assert(varDsc->lvRegister || varDsc->lvOnFrame);

            // lvMustInit can only be set for GC types or TYP_STRUCT types
            // or when compInitMem is true

            assert(varTypeIsGC(varDsc->TypeGet())    ||
                   (varDsc->TypeGet() == TYP_STRUCT) || info.compInitMem);

            if (varDsc->lvRegister)
            {
                if (varDsc->lvOnFrame)
                {
                    /* This is a partially enregistered TYP_LONG var */
                    assert(varDsc->lvOtherReg == REG_STK);
                    assert(varDsc->lvType == TYP_LONG);

                    assert(info.compInitMem);

                    if (initRegZeroed == false)
                    {
                        inst_RV_RV(INS_xor, initReg, initReg);
                        initRegZeroed = true;
                    }
                    genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, sizeof(int));
                }

                continue;
            }

            if ((varDsc->TypeGet() == TYP_STRUCT) && !info.compInitMem)
            {
                // We only initialize the GC variables in the TYP_STRUCT
                unsigned slots  = lvaLclSize(varNum) / sizeof(void*);
                BYTE *   gcPtrs = lvaGetGcLayout(varNum);

                for (unsigned i = 0; i < slots; i++)
                {
                    if (gcPtrs[i] != TYPE_GC_NONE)
                    {
                        if (initRegZeroed == false)
                        {
                            inst_RV_RV(INS_xor, initReg, initReg);
                            initRegZeroed = true;
                        }

                        genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, i*sizeof(void*));
                    }
                }
            }
            else
            {
                if (initRegZeroed == false)
                {
                    inst_RV_RV(INS_xor, initReg, initReg);
                    initRegZeroed = true;
                }

                // zero out the whole thing
                genEmitter->emitIns_S_R    (INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, 0);

                unsigned lclSize = lvaLclSize(varNum);
                for(unsigned i=sizeof(void*); i < lclSize; i +=sizeof(void*))
                {
                    genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, i);
                }
            }
        }

        if  (!TRACK_GC_TEMP_LIFETIMES)
        {
            for (tempThis = tmpListBeg();
                 tempThis;
                 tempThis = tmpListNxt(tempThis))
            {
                if  (!varTypeIsGC(tempThis->tdTempType()))
                    continue;

//              printf("initialize untracked spillTmp [EBP-%04X]\n", stkOffs);

                if (initRegZeroed == false)
                {
                    inst_RV_RV(INS_xor, initReg, initReg);
                    initRegZeroed = true;
                }

                inst_ST_RV(INS_mov, tempThis, 0, initReg, TYP_INT);

                genTmpAccessCnt++;
            }
        }

        if (initRegZeroed && (initRegs != RBM_NONE))
        {
            /* We don't need to zeroInit this register again */
            initRegs &= ~genRegMask(initReg);
        }
    }

#if INLINE_NDIRECT

    if (info.compCallUnmanaged)
        initRegs = genPInvokeMethodProlog(initRegs);
#endif

    if  (opts.compNeedSecurityCheck)
    {

#if DOUBLE_ALIGN
        assert(genDoubleAlign == false);
#endif

        genEmitter->emitIns_I_AR(INS_mov,
                                  EA_4BYTE,
                                  0,
                                  SR_EBP,
                                  -4);
    }

#else  //TGT_x86

    regMaskTP       save;

    int             adjOffs = 0;

    // UNDONE: Zeroing out locals and frame for IL on RISC .....

    /* Save any callee-saved registers we use */

    save = rsMaskModf & RBM_CALLEE_SAVED & ~RBM_SPBASE;

    if  (save)
    {
        for (regNumber rnum = REG_FIRST; rnum < REG_COUNT; rnum = REG_NEXT(rnum))
        {
            if  (save & genRegMask(rnum))
            {
                /* Generate "mov.l reg, @-sp" */

                genEmitter->emitIns_IR_R((emitRegs)REG_SPBASE,
                                          (emitRegs)rnum,
                                          true,
                                          sizeof(int));

                adjOffs += sizeof(int);
            }
        }
    }

#if TGT_SH3

    /* Save the return address register if non-leaf */

    if  (genNonLeaf)
    {
        genEmitter->emitIns_IR((emitRegs)REG_SPBASE,
                                INS_stspr,
                                true,
                                sizeof(int));

        adjOffs += sizeof(int);
    }

#endif

    /*
        Incoming arguments will be handled before the stack frame is
        set up (i.e. arguments that come on the stack but live in
        registers will be loaded, and those coming in in registers
        but not enregistered within the method will be homed on the
        stack).

        For this to work properly, we'll need to figure out what
        adjustment to apply to the arguments offsets in the code
        below that handles incoming args.
     */

    if  (genFixedArgBase)
        adjOffs = 0;

//  printf("ADJ=%d, FRM=%u\n", adjOffs, compLclFrameSize);

    adjOffs -= compLclFrameSize;

#endif//TGT_x86

    // Initialize any "hidden" slots/locals

#if TGT_x86

    if (compLocallocUsed)
    {
        genEmitter->emitIns_AR_R(INS_mov, EA_4BYTE, SR_ESP,
                                 SR_EBP, -lvaLocAllocSPoffs());
    }

    if (info.compXcptnsCount)
    {
        genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0,
                                SR_EBP, SR_NA, -lvaShadowSPfirstOffs);
    }
#else
    assert(!compLocallocUsed && !info.compXcptnsCount);
#endif

    if  (!genInterruptible)
    {
        /*-------------------------------------------------------------------------
         *
         * The 'real' prolog ends here for non-interruptible methods
         */
        size = genEmitter->emitSetProlog();
    }

    /* Take care of register arguments first */

    if (rsCalleeRegArgMaskLiveIn)
        genFnPrologCalleeRegArgs();

    /* If any arguments live in registers, load them */

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        /* Is this variable a parameter? */

        if  (!varDsc->lvIsParam)
            continue;

        /* If a register argument it's already been taken care of */

        if  (varDsc->lvIsRegArg)
            continue;

        /* Has the parameter been assigned to a register? */

        if  (!varDsc->lvRegister)
            continue;

        var_types type = genActualType(varDsc->TypeGet());

#if TGT_x86
        /* Floating point locals are loaded onto the x86-FPU in the next section */
        if (varTypeIsFloating(type))
            continue;
#endif

        /* Is the variable dead on entry */

        if (!(genVarIndexToBit(varDsc->lvVarIndex) & fgFirstBB->bbLiveIn))
            continue;

        /* Load the incoming parameter into the register */

        /* Figure out the home offset of the incoming argument */

        regNumber regNum = (regNumber)varDsc->lvRegNum;
#if     TGT_RISC
        int        stkOfs =             varDsc->lvStkOffs;
        stkOfs += adjOffs;
#endif

#if     TGT_x86

        assert(!varTypeIsFloating(type));

        if (type != TYP_LONG)
        {
            /* Not a long - this is the easy/common case */

            genEmitter->emitIns_R_S(INS_mov,
                                    emitTypeSize(type),
                                    (emitRegs)regNum,
                                    varNum,
                                    0);
        }
        else
        {
            /* long - at least the low half must be enregistered */


            genEmitter->emitIns_R_S(INS_mov,
                                    EA_4BYTE,
                                    (emitRegs)regNum,
                                    varNum,
                                    0);

            /* Is the upper half also enregistered? */

            if (varDsc->lvOtherReg != REG_STK)
            {
                genEmitter->emitIns_R_S(INS_mov,
                                        EA_4BYTE,
                                        (emitRegs)varDsc->lvOtherReg,
                                        varNum,
                                        sizeof(int));
            }
        }

#elif   TGT_SH3

        printf("WARNING:  Skipping code to load incoming register argument(s) into its reg\n");
        printf("          Argument %u needs to be loaded from sp+%u\n", varNum, stkOfs);

#else

        assert(!"unexpected target");

#endif

#ifdef  DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0)
            psiMoveToReg(varNum);
#endif

    }

    /* Initialize any must-init registers variables now */
    if (initRegs)
    {
        unsigned regMask = 0x1;

        for (regNumber reg = REG_FIRST; reg < REG_COUNT; reg = REG_NEXT(reg), regMask<<=1)
        {
            if (regMask & initRegs)
                inst_RV_RV(INS_xor, reg, reg);
        }
    }

#if TGT_x86
    //
    // Here is where we load the enregistered floating point arguments
    //   and locals onto the x86-FPU.
    //
    // We load them in the order specified by lvaFPRegVarOrder[]
    //
    unsigned fpRegVarCnt = 0;
    varNum = lvaFPRegVarOrder[fpRegVarCnt];
    while (varNum != -1)
    {
        assert(varNum < lvaCount);

        varDsc = &lvaTable[varNum];
        var_types type = varDsc->TypeGet();

        assert(varDsc->lvRegister && varTypeIsFloating(type));

        if (varDsc->lvIsParam)
        {
            /* Enregistered argument */

            genEmitter->emitIns_S(INS_fld,
                                  EA_ATTR(genTypeSize(type)),
                                  varNum,
                                  0);
        }
        else
        {
            /* Enregistered local, with possible read before write */
            /* Load a floating-point zero: 0.0 */

            genEmitter->emitIns(INS_fldz);
        }

        fpRegVarCnt++;
        varNum = lvaFPRegVarOrder[fpRegVarCnt];
    }
#endif

//-----------------------------------------------------------------------------

#if !TGT_x86

    /* Do we need to allocate a stack frame? */

    if  (compLclFrameSize)
    {
        if  (genFPused)
        {

//          2fe6          mov.l       r14,@-sp
//          4f22          sts.l       pr,@-sp
//          7fe8          add.l       #-24,sp
//          6ef3          mov.l       sp,r14
//          7fc0          add.l       #-64,sp

            if  (genFPtoSP)
            {
                assert(!"add size [1] to fp -> sp");
            }
            else
            {
                assert(!"add size [2] to fp -> sp");
            }
        }
        else
        {
            /* Subtract the stack frame size from sp */

            genIncRegBy(REG_SPBASE, -compLclFrameSize, NULL, TYP_INT, false);
        }
    }

#endif // TGT_x86

    /* Increase the prolog size here only if fully interruptible */

    if  (genInterruptible)
    {
        size = genEmitter->emitSetProlog();
    }

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo && info.compLocalVarsCount>0)
        psiEndProlog();
#endif

#ifdef  DEBUG
    if  (dspCode) printf("\n");
#endif

    if  (GCrefLo == +INT_MAX)
    {
        assert(GCrefHi ==  -INT_MAX);
    }
    else
    {
        genEmitter->emitSetFrameRangeGCRs(GCrefLo, GCrefHi);
    }

    // Load up the VARARG argument pointer register so it doesn't get clobbered.
    // only do this if we actually access any statically declared args (our
    // argument poitner register has a refcount > 0
    unsigned argsStartVar = lvaVarargsBaseOfStkArgs;

    if (info.compIsVarArgs && lvaTable[argsStartVar].lvRefCnt > 0)
    {
        varDsc = &lvaTable[argsStartVar];

#if !TGT_x86
        NO_WAY("varargs NYI for RISC");
#else
            // MOV EAX, <VARARGS HANDLE>
        genEmitter->emitIns_R_S(INS_mov, EA_4BYTE, SR_EAX, info.compArgsCount-1, 0);
            // MOV EAX, [EAX]
        genEmitter->emitIns_R_AR (INS_mov, EA_4BYTE, SR_EAX, SR_EAX, 0);
            // LEA EDX, &<VARARGS HANDLE>
        genEmitter->emitIns_R_S(INS_lea, EA_4BYTE, SR_EDX, info.compArgsCount-1, 0);
            // ADD EDX, EAX
        genEmitter->emitIns_R_R(INS_add, EA_4BYTE, SR_EDX, SR_EAX);

        if  (varDsc->lvRegister)
        {
            if (varDsc->lvRegNum != REG_EDX)
                genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, emitRegs(varDsc->lvRegNum), SR_EDX);
        }
        else
            genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, SR_EDX, argsStartVar, 0);
#endif

    }

#ifdef DEBUG
    if (opts.compStackCheckOnRet) 
    {
        assert(lvaReturnEspCheck != 0xCCCCCCCC && lvaTable[lvaReturnEspCheck].lvVolatile && lvaTable[lvaReturnEspCheck].lvOnFrame);
        genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, SR_ESP, lvaReturnEspCheck, 0);
    }
#endif

    genEmitter->emitEndProlog();

    return  size;
}


/*****************************************************************************
 *
 *  Generates code for a function epilog.
 */

void                Compiler::genFnEpilog()
{
    assert(!opts.compMinOptim || genFPused);    // FPO not allowed with minOpt

#ifdef  DEBUG
    genIntrptibleUse = true;
#endif

#if TGT_x86

    BYTE            epiCode[MAX_EPILOG_SIZE];   // buffer for epilog code
    BYTE    *       epiNext = epiCode;          // next byte in the buffer
    size_t          epiSize;                    // total epilog code size

    unsigned        popCount = 0;               // popped callee-saved reg #

#ifdef  DEBUG
    if  (dspCode) printf("\n__epilog:\n");
#endif

    /* Restore any callee-saved registers we have used */

    const unsigned  INS_pop_ebp = 0x5D;
    const unsigned  INS_pop_ebx = 0x5B;
    const unsigned  INS_pop_esi = 0x5E;
    const unsigned  INS_pop_edi = 0x5F;
    const unsigned  INS_pop_ecx = 0x59;

    /*  NOTE:   The EBP-less frame code below depends on the fact that
                all of the pops are generated right at the start and
                each takes one byte of machine code.
     */

#ifdef  DEBUG
    if  (dspCode)
    {
        if  (!DOUBLE_ALIGN_NEED_EBPFRAME && (rsMaskModf & RBM_EBP))
            instDisp(INS_pop, false, "EBP");

        if  (compLocallocUsed && (rsMaskModf & (RBM_EBX|RBM_ESI|RBM_EDI)))
        {
            int offset = compCalleeRegsPushed*sizeof(int) + compLclFrameSize;
            instDisp(INS_lea, false, "ESP, [EBP-%d]", offset);
        }
        if  (rsMaskModf & RBM_EBX)
            instDisp(INS_pop, false, "EBX");
        if  (rsMaskModf & RBM_ESI)
            instDisp(INS_pop, false, "ESI");
        if  (rsMaskModf & RBM_EDI)
            instDisp(INS_pop, false, "EDI");
    }
#endif

    if  (!DOUBLE_ALIGN_NEED_EBPFRAME && (rsMaskModf & RBM_EBP))
    {
        popCount++;
        *epiNext++ = INS_pop_ebp;
    }

    if  (compLocallocUsed && (rsMaskModf & (RBM_EBX|RBM_ESI|RBM_EDI)))
    {
        int offset = compCalleeRegsPushed*sizeof(int) + compLclFrameSize;
        /* esp points might not point to the callee saved regs, we need to */
        /* reset it first via lea esp, [ebp-compCalleeRegsPushed*4-compLclFrameSize] */
        *epiNext++ = 0x8d;
        if (offset < 128)
        {
            *epiNext++ = 0x65;
            *epiNext++ = ((-offset)&0xFF);
        }
        else
        {
            *epiNext++ = 0xA5;
            *((int*)epiNext) = -offset;
            epiNext += sizeof(int);
        }
    }
    if  (rsMaskModf & RBM_EBX)
    {
        popCount++;
        *epiNext++ = INS_pop_ebx;
    }
    if  (rsMaskModf & RBM_ESI)
    {
        popCount++;
        *epiNext++ = INS_pop_esi;
    }
    if  (rsMaskModf & RBM_EDI)
    {
        popCount++;
        *epiNext++ = INS_pop_edi;
    }

    assert(compCalleeRegsPushed == popCount);

    /* Compute the size in bytes we've pushed/popped */


    if  (!DOUBLE_ALIGN_NEED_EBPFRAME)
    {
        assert(compLocallocUsed == false); // Only used with frame-pointer

        /* Get rid of our local variables */

        if  (compLclFrameSize)
        {
            /* Add 'compLclFrameSize' to ESP */

            /* Use pop ECX to increment ESP by 4, unless compJmpOpUsed is true */

            if  ( (compLclFrameSize == 4) && !compJmpOpUsed )
            {
#ifdef  DEBUG
                if  (dspCode) instDisp(INS_pop, false, "ECX");
#endif
                *epiNext++ = INS_pop_ecx;
            }
            else
            {
                /* Generate "add esp, <stack-size>" */

#ifdef  DEBUG
                if  (dspCode) instDisp(INS_add, false, "ESP, %d", compLclFrameSize);
#endif

                if  ((signed char)compLclFrameSize == (int)compLclFrameSize)
                {
                    /* The value fits in a signed byte */

                    *epiNext++ = 0x83;
                    *epiNext++ = 0xC4;
                    *epiNext++ = compLclFrameSize;
                }
                else
                {
                    /* Generate a full 32-bit value */

                    *epiNext++ = 0x81;
                    *epiNext++ = 0xC4;
                    *epiNext++ = (compLclFrameSize      );
                    *epiNext++ = (compLclFrameSize >>  8);
                    *epiNext++ = (compLclFrameSize >> 16);
                    *epiNext++ = (compLclFrameSize >> 24);
                }
            }
        }

//      int     popSize = popCount * sizeof(int);
//      printf("popped size = %d, final frame = %d\n", popSize, compLclFrameSize);
    }
    else
    {
        /* Tear down the stack frame */

        if  (compLclFrameSize || compLocallocUsed ||
             genDoubleAlign)
        {
            /* Generate "mov esp, ebp" */

#ifdef  DEBUG
            if  (dspCode) instDisp(INS_mov, false, "ESP, EBP");
#endif

            *epiNext++ = 0x8B;
            *epiNext++ = 0xE5;
        }

        /* Generate "pop ebp" */

#ifdef  DEBUG
        if  (dspCode) instDisp(INS_pop, false, "EBP");
#endif

        *epiNext++ = INS_pop_ebp;
    }

    epiSize = epiNext - epiCode; assert(epiSize <= MAX_EPILOG_SIZE);

    genEmitter->emitDefEpilog(epiCode, epiSize);

#elif   TGT_SH3

    regMaskTP       rest;

    /* Does the method call any others or need any stack space? */

    if  (genNonLeaf || compLclFrameSize)
    {
        if  (compLclFrameSize)
        {
            if  (genFPused)
            {

//              2fe6          mov.l       r14,@-sp
//              4f22          sts.l       pr,@-sp
//              7fe8          add.l       #-24,sp
//              6ef3          mov.l       sp,r14
//              7fc0          add.l       #-64,sp
//
//                            ...
//                            ...
//
//              ef18          mov.b       #24,sp
//              3fec          add.l       r14,sp
//              4f26          lds.l       @sp+,pr
//              6ef6          mov.l       @sp+,r14
//              000b          rts

                if  (genFPtoSP)
                {
                    assert(!"add size [1] to fp -> sp");
                }
                else
                {
                    assert(!"add size [2] to fp -> sp");
                }
            }
            else
            {
                /* Add the stack frame size to sp */

                genIncRegBy(REG_SPBASE, compLclFrameSize, NULL, TYP_INT, false);
            }
        }

        /* Restore the "PR" register if non-leaf */

        if  (genNonLeaf)
        {
            genEmitter->emitIns_IR((emitRegs)REG_SPBASE,
                                    INS_ldspr,
                                    true,
                                    sizeof(int));
        }
    }

    /* Restore any callee-saved registers we use */

    rest = rsMaskModf & RBM_CALLEE_SAVED & ~RBM_SPBASE;

    if  (rest)
    {
        for (unsigned rnum = REG_COUNT - 1; rnum; rnum--)
        {
            if  (rest & genRegMask((regNumber)rnum))
            {
                /* Generate "mov.l @sp+, reg" */

                genEmitter->emitIns_R_IR((emitRegs)rnum,
                                          (emitRegs)REG_SPBASE,
                                          true,
                                          sizeof(int));
            }
        }
    }

#else

    assert(!"unexpected target");

#endif

}

/*****************************************************************************
 *  For CEE_LOCALLOC
 */

regNumber           Compiler::genLclHeap(GenTreePtr size)
{
    assert(genActualType(size->gtType) == TYP_I_IMPL);

    regNumber   reg;

#if !TGT_x86

#ifdef  DEBUG
    gtDispTree(tree);
#endif
    assert(!"need non-x86 code");

#else // TGT_x86

    assert(genFPused);
    assert(genStackLevel == 0); // Cant have anything on the stack

    BasicBlock* endLabel = NULL; 

    if (info.compInitMem)
    {
        /* Since we have to zero out the allocated memory AND ensure that
           ESP is always valid by tickling the pages, we will just push 0's
           on the stack */

        reg = REG_ECX;

        if (size->gtOper == GT_CNS_INT)
       {
            // amount is the number of DWORDS
            unsigned amount           = size->gtIntCon.gtIconVal;
            amount                   +=  (sizeof(void*) - 1); // DWORD-align the size
            amount                   /=  sizeof(void*);
            size->gtIntCon.gtIconVal  = amount;

            // Compute the size (in dwords) of the block to allocate
            genComputeReg(size, RBM_ECX, EXACT_REG, FREE_REG);

            /* For small allocations we will generate up to five push 0 inline */
            if (amount <= 5)
            {
                /* If amount is zero then return null in ECX */
                if (amount == 0)
                    goto DONE;

                while (amount != 0)
                {
                    inst_IV(INS_push_hide, 0);  // push_hide means don't track the stack
                    amount--;
                }
                goto SET_ECX_FROM_ESP;
            }
        }
        else
        {
            // Compute the size (in bytes) of the block to allocate
            genComputeReg(size, RBM_ECX, EXACT_REG, FREE_REG);

            endLabel = genCreateTempLabel();   
            // If 0 we bail out
            inst_RV_RV(INS_test, reg, reg, TYP_INT);                        
            inst_JMP(EJ_je, endLabel, false, false, true);

            // DWORD-align the size, and convert to # of DWORDs
            inst_RV_IV(INS_add, reg,  (sizeof(int) - 1));
            rsTrackRegTrash(reg);
            // --- shr ecx, 2 ---   
            inst_RV_SH(INS_shr, reg, 2);
        }

        // At this point ECX is set to the number of dwords to locAlloc

        BasicBlock* loop = genCreateTempLabel();
        genDefineTempLabel(loop, true);
                                     // Loop:
        inst_IV(INS_push_hide, 0);   // --- push 0

        // Are we done?
        inst_RV(INS_dec, REG_ECX, TYP_INT);
        inst_JMP(EJ_jne, loop, false, false, true);

SET_ECX_FROM_ESP:
        rsTrackRegTrash(REG_ECX);
        // --- move ECX, ESP
        inst_RV_RV(INS_mov, REG_ECX, REG_ESP);
    }
    else
    {
        /* We dont need to zero out the allocated memory. However, we do have
           to tickle the pages to ensure that ESP is always valid and is
           in sync with the "stack guard page".  Note that in the worst
           case ESP is on the last byte of the guard page.  Thus you must
           touch ESP+0 first not ESP+x01000.
        
           Another subtlety is that you dont want ESP to be exactly on the
           boundary of the guard page because PUSH is predecrement, thus 
           call setup would not touch the guard page but just beyond it */

        if (size->gtOper == GT_CNS_INT)
        {
            // amount is the number of bytes
            unsigned amount           = size->gtIntCon.gtIconVal;
            amount                   +=  (sizeof(int) - 1); // DWORD-align the size
            amount                   &= ~(sizeof(int) - 1);
            size->gtIntCon.gtIconVal  = amount;

            if (unsigned(size->gtIntCon.gtIconVal) < CORINFO_PAGE_SIZE) // must be < not <=
            {
                /* Since the size is small, simply adjust ESP
                   We do the adjustment in a temporary register
                   as a hack to prevent the emitter from tracking
                   the adjustment to ESP. */

                reg = rsPickReg();

                /* For small allocations we will generate up to five push 0 inline */
                if (amount <= 20)
                {
                    /* If amount is zero then return null in reg */
                    if (amount == 0)
                    {
                        inst_RV_RV(INS_xor, reg, reg);
                    }
                    else
                    {
                        assert((amount % sizeof(void*)) == 0);
                        while (amount != 0)
                        {
                            inst_IV(INS_push_hide, 0);  // push_hide means don't track the stack
                            amount -= 4;
                        }
                    
                        // --- move reg, ESP
                        inst_RV_RV(INS_mov, reg, REG_ESP);
                    }
                }
                else 
                {
                        // since ESP might already be in the guard page, must touch it BEFORE
                        // the alloc, not after.  
                    inst_RV_RV(INS_mov, reg, REG_ESP);
                    genEmitter->emitIns_AR_R(INS_test, EA_4BYTE, SR_ESP, SR_ESP, 0);
                    inst_RV_IV(INS_sub, reg, amount);
                    inst_RV_RV(INS_mov, REG_ESP, reg);
                }
                rsTrackRegTrash(reg);
                goto DONE;
            }
            else
            {
                /* The size is very large */
                genCompIntoFreeReg(size, RBM_NONE, FREE_REG);
                reg = size->gtRegNum;
            }         
        }
        else
        {
            genCompIntoFreeReg(size, RBM_NONE, FREE_REG);
            reg = size->gtRegNum;

            // @TODO [CONSIDER] [04/16/01] [dnotario]: 
            // We can redo this routine to make it faster.
            // We can have a very fast path for allocations that are less
            // than PAGE_SIZE and call a helper if not. It will help code size 
            // and speed. If we want to inline all this stuff anyway, we should
            // have a fast path for positive numbers. 
            
            endLabel = genCreateTempLabel();   
            // If it's zero, bail out                
            inst_RV_RV(INS_test, reg, reg, TYP_INT);            
            inst_JMP(EJ_je, endLabel , false, false, true);

            // DWORD-align the size
            inst_RV_IV(INS_add, reg,  (sizeof(int) - 1));
            inst_RV_IV(INS_and, reg, ~(sizeof(int) - 1));
        }

        /* Note that we go through a few hoops so that ESP never points to
           illegal pages at any time during the ticking process

                  neg REG
                  add REG, ESP          // reg now holds ultimate ESP
                  jb loop               // result is smaller than orignial ESP (no wrap around)
                  xor REG, REG,         // Overflow, pick lowest possible number
             loop:
                  test [ESP], ESP       // tickle the page
                  sub ESP, PAGE_SIZE
                  cmp ESP, REG
                  jae loop

                  mov ESP, REG
             end:
          */
        
        inst_RV(INS_neg, reg, TYP_INT);
        inst_RV_RV(INS_add, reg, REG_ESP);
        rsTrackRegTrash(reg);

        BasicBlock* loop = genCreateTempLabel();
        inst_JMP(EJ_jb, loop, false, false, true);
        inst_RV_RV(INS_xor, reg, reg);


        genDefineTempLabel(loop, true);

        // Tickle the decremented value, and move back to ESP,
        // note that it has to be done BEFORE the update of ESP since
        // ESP might already be on the guard page.  It is OK to leave
        // the final value of ESP on the guard page 

        genEmitter->emitIns_AR_R(INS_test, EA_4BYTE, SR_ESP, SR_ESP, 0);


        // This is a hack to avoid the emitter trying to track the
        // decrement of the ESP - we do the subtraction in another reg
        // instead of adjusting ESP directly. 

        rsLockReg  (genRegMask(reg));
        regNumber   regHack = rsPickReg();
        rsUnlockReg(genRegMask(reg));

        inst_RV_RV(INS_mov, regHack, REG_ESP);
        rsTrackRegTrash(regHack);

        inst_RV_IV(INS_sub, regHack, CORINFO_PAGE_SIZE);
        inst_RV_RV(INS_mov, REG_ESP, regHack);

        inst_RV_RV(INS_cmp, REG_ESP, reg);
        inst_JMP(EJ_jae, loop, false, false, true);

        // Move the final value to ESP 
        inst_RV_RV(INS_mov, REG_ESP, reg);
        

        /*
        We should have this code, that only commits ESP once 

        // Get a new register
        rsLockReg  (genRegMask(reg));
        regNumber   regHack = rsPickReg();
        rsUnlockReg(genRegMask(reg));

        inst_RV_RV(INS_mov, regHack, REG_ESP);
        rsTrackRegTrash(regHack);

        genDefineTempLabel(loop, true);
        
        // Tickle the page to get a stack overflow if needed. It is OK to leave
        // the final value of ESP on the guard page 
        genEmitter->emitIns_AR_R(INS_test, EA_4BYTE, (emitRegs) regHack, (emitRegs) regHack, 0);

        inst_RV_IV(INS_sub, regHack, CORINFO_PAGE_SIZE);

        // Are we done?
        inst_RV_RV(INS_cmp, regHack, reg);

        inst_JMP(EJ_jae, loop, false, false, true);

        inst_RV_RV(INS_mov, REG_ESP, reg);                
        */
    }

DONE:
    if (endLabel != NULL)
        genDefineTempLabel(endLabel, true);

    /* Write the lvaShadowSPfirst stack frame slot */
    genEmitter->emitIns_AR_R(INS_mov, EA_4BYTE, SR_ESP,
                             SR_EBP, -lvaLocAllocSPoffs());

#endif // TGT_x86

    return reg;
}

/*****************************************************************************
 *
 *  Record the constant (readOnly==true) or data section (readOnly==false) and
 *  return a tree node that yields its address.
 */

GenTreePtr          Compiler::genMakeConst(const void *   cnsAddr,
                                           size_t         cnsSize,
                                           var_types      cnsType,
                                           GenTreePtr     cnsTree,
                                           bool           dblAlign,
                                           bool           readOnly)
{
    int             cnum;
    GenTreePtr      cval;

    /* When generating SMALL_CODE, we don't bother with dblAlign */
    if (dblAlign && (compCodeOpt() == SMALL_CODE))
        dblAlign = false;

    /* Assign the constant an offset in the data section */

    cnum = genEmitter->emitDataGenBeg(cnsSize, dblAlign, readOnly, false);

    cval = gtNewOperNode(GT_CLS_VAR, cnsType);
    cval->gtClsVar.gtClsVarHnd = eeFindJitDataOffs(cnum);

#ifdef  DEBUG

    if  (dspCode)
    {
        printf("   @%s%02u   ", readOnly ? "CNS" : "RWD", cnum & ~1);

        switch (cnsType)
        {
        case TYP_INT   : printf("DD      %d \n", *(int     *)cnsAddr); break;
        case TYP_LONG  : printf("DQ      %D \n", *(__int64 *)cnsAddr); break;
        case TYP_FLOAT : printf("DF      %f \n", *(float   *)cnsAddr); break;
        case TYP_DOUBLE: printf("DQ      %lf\n", *(double  *)cnsAddr); break;

        default:
            assert(!"unexpected constant type");
        }
    }

#endif

    genEmitter->emitDataGenData(0, cnsAddr, cnsSize);
    genEmitter->emitDataGenEnd ();

    /* Transfer life info from the original tree node, if given */

    if  (cnsTree)
        cval->gtLiveSet = cnsTree->gtLiveSet;

    return cval;
}

/*****************************************************************************
 *
 *  Return non-zero if the given register is free after the given tree is
 *  evaluated (i.e. the register is either not used at all, or it holds a
 *  register variable which is not live after the given node).
 */

bool                Compiler::genRegTrashable(regNumber reg, GenTreePtr tree)
{
    unsigned        vars;
    regMaskTP       mask = genRegMask(reg);

    /* Is the register used for something else? */

    if  (rsMaskUsed & mask)
        return  false;

    /* Will the register hold a variable after the operation? */

//  genUpdateLife(tree);

    vars = rsMaskVars;

    if  (genCodeCurLife != tree->gtLiveSet)
    {
        VARSET_TP       aset;
        VARSET_TP       dset;
        VARSET_TP       bset;

        unsigned        varNum;
        LclVarDsc   *   varDsc;

        /* Life is changing at this node - figure out the changes */

        dset = ( genCodeCurLife & ~tree->gtLiveSet);
        bset = (~genCodeCurLife &  tree->gtLiveSet);

        aset = (dset | bset) & genCodeCurRvm;

        /* Visit all variables and update the register variable set */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount && aset;
             varNum++  , varDsc++)
        {
            VARSET_TP       varBit;
            regMaskTP       regBit;

            /* Ignore the variable if not tracked or not in a register */

            if  (!varDsc->lvTracked)
                continue;
            if  (!varDsc->lvRegister)
                continue;

            /* Ignore the variable if it's not changing state here */

            varBit = genVarIndexToBit(varDsc->lvVarIndex);
            if  (!(aset & varBit))
                continue;

            /* Remove this variable from the 'interesting' bit set */

            aset &= ~varBit;

            /* Get hold of the appropriate register bit(s) */

            regBit = genRegMask(varDsc->lvRegNum);

            if  (isRegPairType(varDsc->lvType) && varDsc->lvOtherReg != REG_STK)
                regBit |= genRegMask(varDsc->lvOtherReg);

            /* Is the variable becoming live or dead? */

            if  (dset & varBit)
            {
                assert((vars &  regBit) != 0);
                        vars &=~regBit;
            }
            else
            {
                assert((vars &  regBit) == 0);
                        vars |= regBit;
            }
        }
    }

    if  (vars & mask)
        return  false;
    else
        return  true;
}

/*****************************************************************************/
#ifdef DEBUGGING_SUPPORT
/*****************************************************************************
 *                          genSetScopeInfo
 *
 * Called for every scope info piece to record by the main genSetScopeInfo()
 */

void        Compiler::genSetScopeInfo  (unsigned        which,
                                        unsigned        startOffs,
                                        unsigned        length,
                                        unsigned        varNum,
                                        unsigned        LVnum,
                                        bool            avail,
                                        siVarLoc &      varLoc)
{
    /* We need to do some mapping while reporting back these variables */

    unsigned ilVarNum = compMap2ILvarNum(varNum);
    assert(ilVarNum != UNKNOWN_ILNUM);

    // Is this a varargs function?

    if (info.compIsVarArgs &&
        varNum < info.compArgsCount && varNum != lvaVarargsHandleArg &&
        !lvaTable[varNum].lvIsRegArg)
    {
        assert(varLoc.vlType == VLT_STK || varLoc.vlType == VLT_STK2);

        // All stack arguments (except the varargs handle) have to be
        // accessed via the varargs cookie. Discard generated info,
        // and just find its position relative to the varargs handle

        if (!lvaTable[lvaVarargsHandleArg].lvOnFrame)
        {
            assert(!opts.compDbgCode);
            return;
        }

        // Cant check lvaTable[varNum].lvOnFrame as we dont set it for
        // arguments of vararg functions to avoid reporting them to GC.
        assert(!lvaTable[varNum].lvRegister);
        unsigned cookieOffset = lvaTable[lvaVarargsHandleArg].lvStkOffs;
        unsigned varOffset    = lvaTable[varNum].lvStkOffs;

        assert(cookieOffset < varOffset);
        unsigned offset = varOffset - cookieOffset;
        unsigned stkArgSize = compArgSize - rsCalleeRegArgNum * sizeof(void *);
        assert(offset < stkArgSize);
        offset = stkArgSize - offset;

        varLoc.vlType = VLT_FIXED_VA;
        varLoc.vlFixedVarArg.vlfvOffset = offset;
    }

    lvdNAME name = 0;

#ifdef DEBUG

    for (unsigned lvd=0; lvd<info.compLocalVarsCount; lvd++)
    {
        if (LVnum == info.compLocalVars[lvd].lvdLVnum)
        {
            name = info.compLocalVars[lvd].lvdName;
        }
    }

    // Hang on to this info.

    TrnslLocalVarInfo &tlvi = genTrnslLocalVarInfo[which];

    tlvi.tlviVarNum         = ilVarNum;
    tlvi.tlviLVnum          = LVnum;
    tlvi.tlviName           = name;
    tlvi.tlviStartPC        = startOffs;
    tlvi.tlviLength         = length;
    tlvi.tlviAvailable      = avail;
    tlvi.tlviVarLoc         = varLoc;

#endif // DEBUG

    eeSetLVinfo(which, startOffs, length, ilVarNum, LVnum, name, avail, varLoc);
}

/*****************************************************************************
 *                          genSetScopeInfo
 *
 * This function should be called only after the sizes of the emitter blocks
 * have been finalized.
 */

void                Compiler::genSetScopeInfo()
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In genSetScopeInfo()\n");
#endif

    if (!(opts.compScopeInfo && info.compLocalVarsCount>0))
    {
        eeSetLVcount(0);
        eeSetLVdone();
        return;
    }

    assert(opts.compScopeInfo && info.compLocalVarsCount>0);
    assert(psiOpenScopeList.scNext == NULL);

    unsigned    i;
    unsigned    scopeCnt = siScopeCnt + psiScopeCnt;

    eeSetLVcount(scopeCnt);

#ifdef DEBUG
    genTrnslLocalVarCount     = scopeCnt;
    if (scopeCnt)
        genTrnslLocalVarInfo  = (TrnslLocalVarInfo*)compGetMemArray(scopeCnt, sizeof(*genTrnslLocalVarInfo));
#endif

    // Record the scopes found for the parameters over the prolog.
    // The prolog needs to be treated differently as a variable may not
    // have the same info in the prolog block as is given by lvaTable.
    // eg. A register parameter is actually on the stack, before it is loaded to reg

    Compiler::psiScope *  scopeP;

    for (i=0, scopeP = psiScopeList.scNext;
         i < psiScopeCnt;
         i++, scopeP = scopeP->scNext)
    {
        assert(scopeP);
        assert(scopeP->scStartBlock);
        assert(scopeP->scEndBlock);

        NATIVE_IP   startOffs = genEmitter->emitCodeOffset(scopeP->scStartBlock,
                                                           scopeP->scStartBlkOffs);
        NATIVE_IP   endOffs   = genEmitter->emitCodeOffset(scopeP->scEndBlock,
                                                           scopeP->scEndBlkOffs);
        assert(startOffs < endOffs);

        siVarLoc        varLoc;

        // @TODO [REVISIT] [04/16/01] []:  Doesnt handle the big types correctly

        if (scopeP->scRegister)
        {
            varLoc.vlType           = VLT_REG;
            varLoc.vlReg.vlrReg     = scopeP->scRegNum;
        }
        else
        {
            varLoc.vlType           = VLT_STK;
            varLoc.vlStk.vlsBaseReg = scopeP->scBaseReg;
            varLoc.vlStk.vlsOffset  = scopeP->scOffset;
        }

        genSetScopeInfo(i,
            startOffs, endOffs-startOffs, scopeP->scSlotNum, scopeP->scLVnum,
            true, varLoc);
    }

    // Record the scopes for the rest of the method.

    // Check that the LocalVarInfo scopes look OK
    assert(siOpenScopeList.scNext == NULL);

    Compiler::siScope *  scopeL;

    for (i=0, scopeL = siScopeList.scNext;
         i < siScopeCnt;
         i++, scopeL = scopeL->scNext)
    {
        assert(scopeL);
        assert(scopeL->scStartBlock);
        assert(scopeL->scEndBlock);

        // Find the start and end IP

        NATIVE_IP   startOffs = genEmitter->emitCodeOffset(scopeL->scStartBlock,
                                                           scopeL->scStartBlkOffs);
        NATIVE_IP   endOffs   = genEmitter->emitCodeOffset(scopeL->scEndBlock,
                                                           scopeL->scEndBlkOffs);

        assert(scopeL->scStartBlock   != scopeL->scEndBlock ||
               scopeL->scStartBlkOffs != scopeL->scEndBlkOffs);

        // For stack vars, find the base register, and offset

        regNumber   baseReg;
        signed      offset = lvaTable[scopeL->scVarNum].lvStkOffs;

        if (!lvaTable[scopeL->scVarNum].lvFPbased)
        {
            baseReg     = REG_SPBASE;
#if TGT_x86
            offset     += scopeL->scStackLevel;
#endif
        }
        else
        {
            baseReg     = REG_FPBASE;
        }

        // Now fill in the varLoc

        siVarLoc        varLoc;

        if (lvaTable[scopeL->scVarNum].lvRegister)
        {
            var_types type = genActualType(lvaTable[scopeL->scVarNum].TypeGet());
            switch(type)
            {
            case TYP_INT:
            case TYP_REF:
            case TYP_BYREF:

                varLoc.vlType               = VLT_REG;
                varLoc.vlReg.vlrReg         = lvaTable[scopeL->scVarNum].lvRegNum;
                break;

            case TYP_LONG:
#if!CPU_HAS_FP_SUPPORT
            case TYP_DOUBLE:
#endif

                if (lvaTable[scopeL->scVarNum].lvOtherReg != REG_STK)
                {
                    varLoc.vlType            = VLT_REG_REG;
                    varLoc.vlRegReg.vlrrReg1 = lvaTable[scopeL->scVarNum].lvRegNum;
                    varLoc.vlRegReg.vlrrReg2 = lvaTable[scopeL->scVarNum].lvOtherReg;
                }
                else
                {
                    varLoc.vlType                        = VLT_REG_STK;
                    varLoc.vlRegStk.vlrsReg              = lvaTable[scopeL->scVarNum].lvRegNum;
                    varLoc.vlRegStk.vlrsStk.vlrssBaseReg = baseReg;
                    varLoc.vlRegStk.vlrsStk.vlrssOffset  = offset + sizeof(int);
                }
                break;

#if CPU_HAS_FP_SUPPORT
            case TYP_FLOAT:
            case TYP_DOUBLE:
                if (isFloatRegType(type))
                {
                    varLoc.vlType               = VLT_FPSTK;
                    varLoc.vlFPstk.vlfReg       = lvaTable[scopeL->scVarNum].lvRegNum;
                }
                break;
#endif
            default:
                assert(!"Invalid type");
            }
        }
        else
        {
            switch(genActualType(lvaTable[scopeL->scVarNum].TypeGet()))
            {
            case TYP_INT:
            case TYP_REF:
            case TYP_BYREF:
            case TYP_FLOAT:
            case TYP_STRUCT:

                varLoc.vlType               = VLT_STK;
                varLoc.vlStk.vlsBaseReg     = baseReg;
                varLoc.vlStk.vlsOffset      = offset;
                break;

            case TYP_LONG:
            case TYP_DOUBLE:

                varLoc.vlType               = VLT_STK2;
                varLoc.vlStk2.vls2BaseReg   = baseReg;
                varLoc.vlStk2.vls2Offset    = offset;
                break;

            default:
                assert(!"Invalid type");
            }
        }

        genSetScopeInfo(psiScopeCnt + i,
            startOffs, endOffs-startOffs, scopeL->scVarNum, scopeL->scLVnum,
            scopeL->scAvailable, varLoc);
    }

    eeSetLVdone();
}

/*****************************************************************************/
#ifdef LATE_DISASM
/*****************************************************************************
 *                          CompilerRegName
 *
 * Can be called only after lviSetLocalVarInfo() has been called
 */

const char *        Compiler::siRegVarName (unsigned offs, unsigned size,
                                            unsigned reg)
{
    if (! (opts.compScopeInfo && info.compLocalVarsCount>0))
        return NULL;

    assert(genTrnslLocalVarCount==0 || genTrnslLocalVarInfo);

    for (unsigned i=0; i<genTrnslLocalVarCount; i++)
    {
        if (   (genTrnslLocalVarInfo[i].tlviVarLoc.vlIsInReg((regNumber)reg))
            && (genTrnslLocalVarInfo[i].tlviAvailable == true)
            && (genTrnslLocalVarInfo[i].tlviStartPC   <= offs+size)
            && (genTrnslLocalVarInfo[i].tlviStartPC
                 + genTrnslLocalVarInfo[i].tlviLength > offs)
           )
        {
            return genTrnslLocalVarInfo[i].tlviName ?
                   lvdNAMEstr(genTrnslLocalVarInfo[i].tlviName) : NULL;
        }

    }

    return NULL;
}

/*****************************************************************************
 *                          CompilerStkName
 *
 * Can be called only after lviSetLocalVarInfo() has been called
 */

const char *        Compiler::siStackVarName (unsigned offs, unsigned size,
                                              unsigned reg,  unsigned stkOffs)
{
    if (!(opts.compScopeInfo && info.compLocalVarsCount>0))
        return NULL;

    assert(genTrnslLocalVarCount==0 || genTrnslLocalVarInfo);

    for (unsigned i=0; i<genTrnslLocalVarCount; i++)
    {
        if (   (genTrnslLocalVarInfo[i].tlviVarLoc.vlIsOnStk((regNumber)reg, stkOffs))
            && (genTrnslLocalVarInfo[i].tlviAvailable == true)
            && (genTrnslLocalVarInfo[i].tlviStartPC   <= offs+size)
            && (genTrnslLocalVarInfo[i].tlviStartPC
                 + genTrnslLocalVarInfo[i].tlviLength >  offs)
           )
        {
            return genTrnslLocalVarInfo[i].tlviName ?
                   lvdNAMEstr(genTrnslLocalVarInfo[i].tlviName) : NULL;
        }
    }

    return NULL;
}

/*****************************************************************************/
#endif // LATE_DISASM
/*****************************************************************************
 *
 *  Append an IPmappingDsc struct to the list that we're maintaining
 *  for the debugger.
 *  Record the instr offset as being at the current code gen position.
 */

void                Compiler::genIPmappingAdd(IL_OFFSETX offset, bool isLabel)
{
    IPmappingDsc *  addMapping;

    /* Create a mapping entry and append it to the list */

    addMapping = (IPmappingDsc *)compGetMem(sizeof(*addMapping));

    addMapping->ipmdBlock       = genEmitter->emitCurBlock();
    addMapping->ipmdBlockOffs   = genEmitter->emitCurOffset();
    addMapping->ipmdILoffsx     = offset;
    addMapping->ipmdIsLabel     = isLabel;
    addMapping->ipmdNext        = 0;

    if  (genIPmappingList)
        genIPmappingLast->ipmdNext  = addMapping;
    else
        genIPmappingList            = addMapping;

    genIPmappingLast                = addMapping;
}


/*****************************************************************************
 *
 *  Prepend an IPmappingDsc struct to the list that we're maintaining
 *  for the debugger.
 *  Record the instr offset as being at the current code gen position.
 */
void                Compiler::genIPmappingAddToFront(IL_OFFSETX offset)
{
    IPmappingDsc *  addMapping;

    /* Create a mapping entry and append it to the list */

    addMapping = (IPmappingDsc *)compGetMem(sizeof(*addMapping));

    addMapping->ipmdBlock       = genEmitter->emitCurBlock();
    addMapping->ipmdBlockOffs   = genEmitter->emitCurOffset();
    addMapping->ipmdILoffsx    = offset;
    addMapping->ipmdIsLabel     = true;
    addMapping->ipmdNext        = 0;

    //prepend to list
    addMapping->ipmdNext = genIPmappingList;

    genIPmappingList = addMapping;

    if  (genIPmappingLast == NULL)
        genIPmappingLast            = addMapping;
}

/*****************************************************************************/

IL_OFFSET   jitGetILoffs(IL_OFFSETX offsx)
{
    switch(offsx)
    {
    case ICorDebugInfo::NO_MAPPING:
    case ICorDebugInfo::PROLOG:
    case ICorDebugInfo::EPILOG:
        return IL_OFFSET(offsx);

    default:
        return IL_OFFSET(offsx & ~IL_OFFSETX_STKBIT);
    }
}

bool        jitIsStackEmpty(IL_OFFSETX offsx)
{
    switch(offsx)
    {
    case ICorDebugInfo::NO_MAPPING:
    case ICorDebugInfo::PROLOG:
    case ICorDebugInfo::EPILOG:
        return true;

    default:
        return (offsx & IL_OFFSETX_STKBIT) == 0;
    }
}

/*****************************************************************************/

inline
void            Compiler::genEnsureCodeEmitted(IL_OFFSETX offsx)
{
    assert(opts.compDbgCode && offsx != BAD_IL_OFFSET);

    /* If other IL were offsets reported, skip */

    if (!genIPmappingLast || genIPmappingLast->ipmdILoffsx != offsx)
        return;

    /* offsx was the last reported offset. Make sure that we generated native code */

    if (genIPmappingLast->ipmdBlockOffs ==  genEmitter->emitCurOffset() &&
        genIPmappingLast->ipmdBlock     == genEmitter->emitCurBlock())
    {
        instGen(INS_nop);
    }
}

/*****************************************************************************
 *
 *  Shut down the IP-mapping logic, report the info to the EE.
 */

void                Compiler::genIPmappingGen()
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In genIPmappingGen()\n");
#endif

    IPmappingDsc *  tmpMapping, * prevMapping;
    unsigned        mappingCnt;
    NATIVE_IP       lastNativeOfs;

    if  (!genIPmappingList)
    {
        eeSetLIcount(0);
        eeSetLIdone();
        return;
    }

    /* First count the number of distinct mapping records */

    mappingCnt      = 0;
    lastNativeOfs   = NATIVE_IP(~0);

    for (prevMapping = NULL, tmpMapping = genIPmappingList;
         tmpMapping;
         tmpMapping = tmpMapping->ipmdNext)
    {
        NATIVE_IP   nextNativeOfs;
        nextNativeOfs = genEmitter->emitCodeOffset(tmpMapping->ipmdBlock,
                                                   tmpMapping->ipmdBlockOffs);

        if  (nextNativeOfs != lastNativeOfs)
        {
            mappingCnt++;
            lastNativeOfs = nextNativeOfs;
            prevMapping = tmpMapping;
            continue;
        }
        
        /* If there are mappings with the same native offset, then:
           o If one of them is NO_MAPPING, ignore it
           o If one of them is a label, report that and ignore the other one
           o Else report the higher IL offset
         */

        IL_OFFSET   srcIP   = tmpMapping->ipmdILoffsx;

        if (prevMapping->ipmdILoffsx == ICorDebugInfo::MappingTypes::NO_MAPPING)
        {
            // If the previous entry was NO_MAPPING, ignore it
            prevMapping->ipmdBlock = NULL;
            prevMapping = tmpMapping;
        }
        else if (srcIP == ICorDebugInfo::MappingTypes::NO_MAPPING)
        {
            // If the current entry is NO_MAPPING, ignore it
            // Leave prevMapping unchanged as tmpMapping is no longer valid
            tmpMapping->ipmdBlock = NULL;
        }
        else if (srcIP == ICorDebugInfo::MappingTypes::EPILOG ||
                 srcIP == 0)
        {   //counting for special cases: see below
            mappingCnt++;
            prevMapping = tmpMapping;
        }
        else
        {
            assert(prevMapping);
            assert(prevMapping->ipmdBlock == 0 ||
                   lastNativeOfs == genEmitter->emitCodeOffset(prevMapping->ipmdBlock,
                                                               prevMapping->ipmdBlockOffs));

            /* The previous block had the same native offset. We have to
               discard one of the mappings. Simply set ipmdBlock
               to NULL and prevMapping will be ignored later */
            
            if (prevMapping->ipmdIsLabel)
            {
                // Leave prevMapping unchanged as tmpMapping is no longer valid
                tmpMapping->ipmdBlock = NULL;
            }
            else
            {
                prevMapping->ipmdBlock = NULL;
                prevMapping = tmpMapping;
            }
        }
    }

    /* Tell them how many mapping record's we've got */

    eeSetLIcount(mappingCnt);

    /* Now tell them about the mappings */

    mappingCnt      = 0;
    lastNativeOfs   = (NATIVE_IP)-1;

    for (tmpMapping = genIPmappingList; tmpMapping;
         tmpMapping = tmpMapping->ipmdNext)
    {
        // Do we have to skip this record ?
        if (tmpMapping->ipmdBlock == NULL)
            continue;

        NATIVE_IP nextNativeOfs;
        nextNativeOfs = genEmitter->emitCodeOffset(tmpMapping->ipmdBlock,
                                                   tmpMapping->ipmdBlockOffs);
        IL_OFFSET   srcIP   = tmpMapping->ipmdILoffsx;

        if  (nextNativeOfs != lastNativeOfs)
        {
            eeSetLIinfo(mappingCnt++, nextNativeOfs, jitGetILoffs(srcIP), jitIsStackEmpty(srcIP));

            lastNativeOfs = nextNativeOfs;
        }
        else if (srcIP == ICorDebugInfo::MappingTypes::EPILOG ||
                 srcIP == 0)
        {
            // For the special case of an IL instruction with no body
            // followed by the epilog (say ret void immediately preceeding
            // the method end), we put two entries in, so that we'll stop
            // at the (empty) ret statement if the user tries to put a
            // breakpoint there, and then have the option of seeing the
            // epilog or not based on SetUnmappedStopMask for the stepper.
            // @TODO [REVISIT] [04/16/01] []: 
            // Likewise, we can (sometimes) put in a prolog that has
            // the same  nativeoffset as it's following IL instruction,
            // so we have to account for that here as well.
            eeSetLIinfo(mappingCnt++, nextNativeOfs, jitGetILoffs(srcIP), jitIsStackEmpty(srcIP));
        }
    }

    eeSetLIdone();
}

/*****************************************************************************/
#endif  // DEBUGGING_SUPPORT
/*****************************************************************************/


/*============================================================================
 *
 *   These are empty stubs to help the late dis-assembler to compile
 *   if DEBUGGING_SUPPORT is not enabled
 *
 *============================================================================
 */

#if defined(LATE_DISASM) && !defined(DEBUGGING_SUPPORT)

const char * siRegVarName(unsigned offs, unsigned size, int reg)
{    return NULL;   }

const char * siStackVarName(unsigned offs, unsigned size, unsigned disp)
{    return NULL;   }

/*****************************************************************************/
#endif//DEBUGGING_SUPPORT
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\compiler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Compiler                                        XX
XX                                                                           XX
XX  Represents the method data we are currently JIT-compiling                XX
XX  An instance of this class is created for every method we JIT.            XX
XX  This contains all the info needed for the method. So allocating a        XX
XX  a new instance per method makes it thread-safe.                          XX
XX  It should be used to do all the memory management for the compiler run.  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#ifndef _COMPILER_H_
#define _COMPILER_H_
/*****************************************************************************/

#include "jit.h"
#include "opcode.h"
#include "block.h"
#include "instr.h"

#ifdef    LATE_DISASM
#include "DisAsm.h"
#endif

/* This is included here and not earlier as it needs the definition of "CSE"
 * which is defined in the section above */

#include "GenTree.h"
/*****************************************************************************/

#ifdef  DEBUG
#define DEBUGARG(x)         , x
#else
#define DEBUGARG(x)
#endif

/*****************************************************************************/

unsigned                 genVarBitToIndex(VARSET_TP bit);
VARSET_TP                genVarIndexToBit(unsigned  num);

unsigned                 genLog2(unsigned           value);
unsigned                 genLog2(unsigned __int64   value);

var_types                genActualType  (var_types   type);
var_types                genUnsignedType(var_types   type);
var_types                genSignedType  (var_types   type);

/*****************************************************************************/

const unsigned      lclMAX_TRACKED  = VARSET_SZ;  // The # of vars we can track

const size_t        TEMP_MAX_SIZE   = sizeof(double);

const unsigned      FLG_CCTOR = (CORINFO_FLG_CONSTRUCTOR|CORINFO_FLG_STATIC);

/*****************************************************************************
 *                  Forward declarations
 */

struct  InfoHdr;        // defined in GCInfo.h

enum    rpPredictReg;   // defined in RegAlloc.cpp
enum    FrameType;      // defined in RegAlloc.cpp
enum    GCtype;         // defined in emit.h
class   emitter;        // defined in emit.h

#if NEW_EMIT_ATTR
  enum emitAttr;        // defined in emit.h
#else
# define emitAttr          int
#endif
#define EA_UNKNOWN         ((emitAttr) 0)

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX   The big guy. The sections are currently organized as :                  XX
XX                                                                           XX
XX    o  GenTree and BasicBlock                                              XX
XX    o  LclVarsInfo                                                         XX
XX    o  Importer                                                            XX
XX    o  FlowGraph                                                           XX
XX    o  Optimizer                                                           XX
XX    o  RegAlloc                                                            XX
XX    o  EEInterface                                                         XX
XX    o  TempsInfo                                                           XX
XX    o  RegSet                                                              XX
XX    o  GCInfo                                                              XX
XX    o  Instruction                                                         XX
XX    o  ScopeInfo                                                           XX
XX    o  PrologScopeInfo                                                     XX
XX    o  CodeGenerator                                                       XX
XX    o  Compiler                                                            XX
XX    o  typeInfo                                                            XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

class   Compiler
{
    friend  emitter;

    emitter       *         genEmitter;

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX  Misc structs definitions                                                 XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    typedef const char *    lvdNAME;        // Actual ASCII string

#ifdef DEBUG
    const char *            lvdNAMEstr(lvdNAME name) { return name; }
#endif

    // The following holds the Local var info (scope information)

    struct  LocalVarDsc
    {
        IL_OFFSET           lvdLifeBeg;     // instr offset of beg of life
        IL_OFFSET           lvdLifeEnd;     // instr offset of end of life
        unsigned            lvdVarNum;      // (remapped) LclVarDsc number

#ifdef DEBUG
        lvdNAME             lvdName;        // name of the var
#endif

        // @TODO [REVISIT] [04/16/01] []: Remove for IL
        unsigned            lvdLVnum;       // 'which' in eeGetLVinfo()

    };

    enum    ImplicitStmtOffsets
    {
        STACK_EMPTY_BOUNDARIES  = 0x01,
        CALL_SITE_BOUNDARIES    = 0x02,
        ALL_BOUNDARIES          = 0x04
    };

    struct  srcLineDsc
    {
        unsigned short      sldLineNum;
        IL_OFFSET           sldLineOfs;
    };

    // The following is used for validating format of EH table
    struct  EHNodeDsc;
    typedef struct EHNodeDsc* pEHNodeDsc;

    EHNodeDsc* ehnTree;                    // root of the tree comprising the EHnodes.
    EHNodeDsc* ehnNext;                    // root of the tree comprising the EHnodes.

    struct  EHNodeDsc
    {
        enum EHBlockType {
            TryNode,
            FilterNode,
            HandlerNode,
            FinallyNode,
            FaultNode
        };

        EHBlockType             ehnBlockType;      // kind of EH block
        unsigned                ehnStartOffset;    // IL offset of start of the EH block
        unsigned                ehnEndOffset;      // IL offset past end of the EH block
        pEHNodeDsc              ehnNext;           // next (non-nested) block in sequential order
        pEHNodeDsc              ehnChild;          // leftmost nested block
        union {
            pEHNodeDsc          ehnTryNode;        // for filters and handlers, the corresponding try node
            pEHNodeDsc          ehnHandlerNode;    // for a try node, the corresponding handler node
        };
        pEHNodeDsc              ehnFilterNode;     // if this is a try node and has a filter, otherwise 0
        pEHNodeDsc              ehnEquivalent;     // if blockType=tryNode, start offset and end offset is same,


        inline void ehnSetTryNodeType()        {ehnBlockType = TryNode;}
        inline void ehnSetFilterNodeType()     {ehnBlockType = FilterNode;}
        inline void ehnSetHandlerNodeType()    {ehnBlockType = HandlerNode;}
        inline void ehnSetFinallyNodeType()    {ehnBlockType = FinallyNode;}
        inline void ehnSetFaultNodeType()      {ehnBlockType = FaultNode;}

        inline BOOL ehnIsTryBlock()            {return ehnBlockType == TryNode;}
        inline BOOL ehnIsFilterBlock()         {return ehnBlockType == FilterNode;}
        inline BOOL ehnIsHandlerBlock()        {return ehnBlockType == HandlerNode;}
        inline BOOL ehnIsFinallyBlock()        {return ehnBlockType == FinallyNode;}
        inline BOOL ehnIsFaultBlock()          {return ehnBlockType == FaultNode;}

        // returns true if there is any overlap between the two nodes
        static inline BOOL ehnIsOverlap(pEHNodeDsc node1, pEHNodeDsc node2)
        {
            if (node1->ehnStartOffset < node2->ehnStartOffset)
            {
                return (node1->ehnEndOffset >= node2->ehnStartOffset);
            }
            else  
            {
                return (node1->ehnStartOffset <= node2->ehnEndOffset);
            }
        }

        // fails with BADCODE if inner is not completely nested inside outer
        static inline BOOL ehnIsNested(pEHNodeDsc inner, pEHNodeDsc outer)
        {
            return ((inner->ehnStartOffset >= outer->ehnStartOffset) &&
                    (inner->ehnEndOffset <= outer->ehnEndOffset));
        }


    };


    // The following holds the table of exception handlers.

#define NO_ENCLOSING_INDEX    USHRT_MAX

    struct  EHblkDsc
    {
        CORINFO_EH_CLAUSE_FLAGS ebdFlags;
        BasicBlock *        ebdTryBeg;  // First block of "try"
        BasicBlock *        ebdTryEnd;  // Block past the last block in "try"
        BasicBlock *        ebdHndBeg;  // First block of handler
        BasicBlock *        ebdHndEnd;  // Block past the last block of handler
        union
        {
            BasicBlock *    ebdFilter;  // First block of filter, if (ebdFlags & CORINFO_EH_CLAUSE_FILTER)
            unsigned        ebdTyp;     // Exception type,        otherwise
        };
        unsigned short      ebdNesting;   // How nested is the handler - 0 for outermost clauses
        unsigned short      ebdEnclosing; // The index of the enclosing outer region
    };

    IL_OFFSET           ebdTryEndOffs       (EHblkDsc *     ehBlk);
    unsigned            ebdTryEndBlkNum     (EHblkDsc *     ehBlk);
    IL_OFFSET           ebdHndEndOffs       (EHblkDsc *     ehBlk);
    unsigned            ebdHndEndBlkNum     (EHblkDsc *     ehBlk);

    bool                ebdIsSameTry        (unsigned t1, unsigned t2);
    bool                bbInFilterBlock     (BasicBlock * blk);

    void                verInitEHTree       (unsigned       numEHClauses);
    void                verInsertEhNode     (CORINFO_EH_CLAUSE* clause, EHblkDsc* handlerTab);
    void                verInsertEhNodeInTree(EHNodeDsc**   ppRoot,  EHNodeDsc* node);
    void                verInsertEhNodeParent(EHNodeDsc**   ppRoot,  EHNodeDsc*  node);
    void                verCheckNestingLevel(EHNodeDsc*     initRoot);

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                        GenTree and BasicBlock                             XX
XX                                                                           XX
XX  Functions to allocate and display the GenTrees and BasicBlocks           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


    // Functions to create nodes

    GenTreePtr FASTCALL     gtNewNode       (genTreeOps     oper,
                                             var_types      type);

    GenTreePtr              gtNewStmt       (GenTreePtr     expr = NULL,
                                             IL_OFFSETX     offset = BAD_IL_OFFSET);

    GenTreePtr              gtNewOperNode   (genTreeOps     oper);

    GenTreePtr              gtNewOperNode   (genTreeOps     oper,
                                             var_types      type);

    GenTreePtr              gtNewOperNode   (genTreeOps     oper,
                                             var_types      type,
                                             GenTreePtr     op1);

    GenTreePtr FASTCALL     gtNewOperNode   (genTreeOps     oper,
                                             var_types      type,
                                             GenTreePtr     op1,
                                             GenTreePtr     op2);

    GenTreePtr FASTCALL     gtNewLargeOperNode(genTreeOps   oper,
                                             var_types      type = TYP_INT,
                                             GenTreePtr     op1  = NULL,
                                             GenTreePtr     op2  = NULL);

    GenTreePtr FASTCALL     gtNewIconNode   (long           value,
                                             var_types      type = TYP_INT);

    GenTreePtr              gtNewIconHandleNode(long        value,
                                             unsigned       flags,
                                             unsigned       handle1 = 0,
                                             void *         handle2 = 0);

    GenTreePtr              gtNewIconEmbHndNode(void *      value,
                                             void *         pValue,
                                             unsigned       flags,
                                             unsigned       handle1 = 0,
                                             void *         handle2 = 0);

    GenTreePtr              gtNewIconEmbScpHndNode (CORINFO_MODULE_HANDLE    scpHnd, unsigned hnd1 = 0, void * hnd2 = 0);
    GenTreePtr              gtNewIconEmbClsHndNode (CORINFO_CLASS_HANDLE    clsHnd, unsigned hnd1 = 0, void * hnd2 = 0);
    GenTreePtr              gtNewIconEmbMethHndNode(CORINFO_METHOD_HANDLE  methHnd, unsigned hnd1 = 0, void * hnd2 = 0);
    GenTreePtr              gtNewIconEmbFldHndNode (CORINFO_FIELD_HANDLE    fldHnd, unsigned hnd1 = 0, void * hnd2 = 0);

    GenTreePtr FASTCALL     gtNewLconNode   (__int64        value);

    GenTreePtr FASTCALL     gtNewDconNode   (double         value);

    GenTreePtr              gtNewSconNode   (int            CPX,
                                             CORINFO_MODULE_HANDLE   scpHandle);

    GenTreePtr              gtNewZeroConNode(var_types      type);

    GenTreePtr              gtNewCallNode   (gtCallTypes    callType,
                                             CORINFO_METHOD_HANDLE  handle,
                                             var_types      type,
                                             GenTreePtr     args);

    GenTreePtr              gtNewHelperCallNode(unsigned    helper,
                                             var_types      type,
                                             unsigned       flags = 0,
                                             GenTreePtr     args = NULL);

    GenTreePtr FASTCALL     gtNewLclvNode   (unsigned       lnum,
                                             var_types      type,
                                             IL_OFFSETX     ILoffs = BAD_IL_OFFSET);
#if INLINING
    GenTreePtr FASTCALL     gtNewLclLNode   (unsigned       lnum,
                                             var_types      type,
                                             IL_OFFSETX     ILoffs = BAD_IL_OFFSET);
#endif
    GenTreePtr FASTCALL     gtNewClsvNode   (CORINFO_FIELD_HANDLE   fldHnd,
                                             var_types      type);

    GenTreePtr FASTCALL     gtNewCodeRef    (BasicBlock *   block);

    GenTreePtr              gtNewFieldRef   (var_types      typ,
                                             CORINFO_FIELD_HANDLE   fldHnd,
                                             GenTreePtr     obj = NULL);

    GenTreePtr              gtNewIndexRef   (var_types      typ,
                                             GenTreePtr     adr,
                                             GenTreePtr     ind);

    GenTreePtr              gtNewArgList    (GenTreePtr     op);

    GenTreePtr              gtNewArgList    (GenTreePtr     op1,
                                             GenTreePtr     op2);

    GenTreePtr FASTCALL     gtNewAssignNode (GenTreePtr     dst,
                                             GenTreePtr     src);

    GenTreePtr              gtNewTempAssign (unsigned       tmp,
                                             GenTreePtr     val);

    GenTreePtr              gtNewDirectNStructField
                                            (GenTreePtr     objPtr,
                                             unsigned       fldIndex,
                                             var_types      lclTyp,
                                             GenTreePtr     assg);

    GenTreePtr              gtNewRefCOMfield(GenTreePtr     objPtr,
                                             CorInfoFieldAccess accessKind,
                                             unsigned       fldIndex,
                                             var_types      lclTyp,
                                             CORINFO_CLASS_HANDLE   structType,
                                             GenTreePtr     assg);
#if     OPTIMIZE_RECURSION
    GenTreePtr              gtNewArithSeries(unsigned       argNum,
                                             var_types      argTyp);
#endif

    GenTreePtr              gtNewCommaNode  (GenTreePtr     op1,
                                             GenTreePtr     op2);


    GenTreePtr              gtNewNothingNode();

    bool                    gtIsaNothingNode(GenTreePtr     tree);

    GenTreePtr              gtUnusedValNode (GenTreePtr     expr);

    GenTreePtr              gtNewCastNode   (var_types      typ,
                                             GenTreePtr     op1,
                                             var_types      castType);

    GenTreePtr              gtNewCastNodeL  (var_types      typ,
                                             GenTreePtr     op1,
                                             var_types      castType);

    GenTreePtr              gtNewRngChkNode (GenTreePtr     tree,
                                             GenTreePtr     addr,
                                             GenTreePtr     indx,
                                             var_types      type,
                                             unsigned       elemSize,
                                             bool           isString=false);

     //------------------------------------------------------------------------
     // Other GenTree functions

    GenTreePtr              gtClone         (GenTree *      tree,
                                             bool           complexOK = false);

    GenTreePtr              gtCloneExpr     (GenTree *      tree,
                                             unsigned       addFlags = 0,
                                             unsigned       varNum   = (unsigned)-1,
                                             long           varVal   = 0);

    GenTreePtr FASTCALL     gtReverseCond   (GenTree *      tree);

    bool                    gtHasRef        (GenTree *      tree,
                                             int            lclNum,
                                             bool           defOnly);

    unsigned                gtHashValue     (GenTree *      tree);

    unsigned                gtSetListOrder  (GenTree *      list,
                                             bool           regs);

    void                    gtWalkOp        (GenTree * *    op1,
                                             GenTree * *    op2,
                                             GenTree *      adr,
                                             bool           constOnly);

    unsigned                gtSetEvalOrder  (GenTree *      tree);

    void                    gtSetStmtInfo   (GenTree *      stmt);


    bool                    gtHasSideEffects(GenTreePtr     tree);

    void                    gtExtractSideEffList(GenTreePtr expr,
                                                 GenTreePtr * list);

    GenTreePtr              gtCrackIndexExpr(GenTreePtr     tree,
                                             GenTreePtr   * indxPtr,
                                             long         * indvPtr,
                                             long         * basvPtr,
                                             bool         * mvarPtr,
                                             long         * offsPtr,
                                             unsigned     * multPtr);

    //-------------------------------------------------------------------------

    GenTreePtr              gtFoldExpr       (GenTreePtr    tree);
    GenTreePtr              gtFoldExprConst  (GenTreePtr    tree);
    GenTreePtr              gtFoldExprSpecial(GenTreePtr    tree);
    GenTreePtr              gtFoldExprCompare(GenTreePtr    tree);

    //-------------------------------------------------------------------------
    // Functions to display the trees

#ifdef DEBUG
    bool                    gtDblWasInt     (GenTree *      tree);

    void                    gtDispNode      (GenTree *      tree,
                                             unsigned       indent,
                                             bool           terse,
                                             char    *      msg);
    void                    gtDispRegVal    (GenTree *      tree);
    void                    gtDispTree      (GenTree *      tree,
                                             unsigned       indent  = 0,
                                             char *         msg     = NULL,
                                             bool           topOnly = false);
    void                    gtDispLclVar    (unsigned       varNum);
    void                    gtDispTreeList  (GenTree *      tree, unsigned indent = 0);
    void                    gtDispArgList   (GenTree *      tree, unsigned indent = 0);
#endif

    // For tree walks

    enum fgWalkResult { WALK_CONTINUE, WALK_SKIP_SUBTREES, WALK_ABORT };
    typedef fgWalkResult   (fgWalkPreFn )(GenTreePtr tree, void * pCallBackData);
    typedef fgWalkResult   (fgWalkPostFn)(GenTreePtr tree, void * pCallBackData, bool prefix);

#ifdef DEBUG
    static fgWalkPreFn      gtAssertColonCond;
#endif
    static fgWalkPreFn      gtMarkColonCond;
    static fgWalkPreFn      gtClearColonCond;

#if 0
#if CSELENGTH
    static fgWalkPreFn      gtRemoveExprCB;
    void                    gtRemoveSubTree (GenTreePtr     tree,
                                             GenTreePtr     list,
                                             bool           dead = false);
#endif
#endif


    //=========================================================================
    // BasicBlock functions

    BasicBlock *            bbNewBasicBlock (BBjumpKinds     jumpKind);


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           LclVarsInfo                                     XX
XX                                                                           XX
XX   The variables to be used by the code generator.                         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


    static int __cdecl            RefCntCmp(const void *op1, const void *op2);
    static int __cdecl         WtdRefCntCmp(const void *op1, const void *op2);

/*****************************************************************************
 *
 *  The following holds the local variable counts and the descriptor table.
 */

    struct  LclVarDsc
    {
        unsigned char       lvType      :5; // TYP_INT/LONG/FLOAT/DOUBLE/REF
        unsigned char       lvIsParam   :1; // is this a parameter?
        unsigned char       lvIsRegArg  :1; // is this a register argument?
        unsigned char       lvFPbased   :1; // 0 = off of SP, 1 = off of FP

        unsigned char       lvStructGcCount :3; // if struct, how many GC pointer (stop counting at 7)
        unsigned char       lvOnFrame   :1; // (part of) variables live on frame
        unsigned char       lvDependReg :1; // did the predictor depend upon this being enregistered
        unsigned char       lvRegister  :1; // assigned to live in a register?
        unsigned char       lvTracked   :1; // is this a tracked variable?
        unsigned char       lvPinned    :1; // is this a pinned variable?

        unsigned char       lvMustInit  :1; // must be initialized
        unsigned char       lvVolatile  :1; // don't enregister
        unsigned char       lvRefAssign :1; // involved in pointer assignment
        unsigned char       lvAddrTaken :1; // variable has its address taken?
        unsigned char       lvArgWrite  :1; // variable is a parameter and STARG was used on it
        unsigned char       lvIsTemp    :1; // Short-lifetime compiler temp
#if OPT_BOOL_OPS
        unsigned char       lvIsBoolean :1; // set if variable is boolean
#endif
#if CSE
        unsigned char       lvRngOptDone:1; // considered for range check opt?

        unsigned char       lvLoopInc   :1; // incremented in the loop?
        unsigned char       lvLoopAsg   :1; // reassigned  in the loop (other than a monotonic inc/dec for the index var)?
        unsigned char       lvArrIndx   :1; // used as an array index?
        unsigned char       lvArrIndxOff:1; // used as an array index with an offset?
        unsigned char       lvArrIndxDom:1; // index dominates loop exit
#endif
#if ASSERTION_PROP
        unsigned char       lvSingleDef:1;    // variable has a single def
        unsigned char       lvDisqualify:1;   // variable is no longer OK for add copy optimization
        unsigned char       lvVolatileHint:1; // hint for AssertionProp
#endif
#if FANCY_ARRAY_OPT
        unsigned char       lvAssignOne :1; // assigned at least  once?
        unsigned char       lvAssignTwo :1; // assigned at least twice?
#endif
#ifdef DEBUG
        unsigned char       lvDblWasInt :1; // Was this TYP_DOUBLE originally a TYP_INT?
        unsigned char       lvKeepType  :1; // Don't change the type of this variable
#endif

        regNumberSmall      lvRegNum;       // used if lvRegister non-zero
        regNumberSmall      lvOtherReg;     // used for "upper half" of long var
        regNumberSmall      lvArgReg;       // the register in which this argument is passed
        regMaskSmall        lvPrefReg;      // set of regs it prefers to live in

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)
        unsigned short      lvSlotNum;      // original slot # (if remapped)
#endif

        unsigned short      lvVarIndex;     // variable tracking index
        unsigned short      lvRefCnt;       // unweighted (real) reference count
        unsigned            lvRefCntWtd;    // weighted reference count
        int                 lvStkOffs;      // stack offset of home
        unsigned            lvSize;         // sizeof the type in bytes

        typeInfo            lvVerTypeInfo;  // type info needed for verification
        
        BYTE  *             lvGcLayout;     // GC layout info for structs


#if FANCY_ARRAY_OPT
        GenTreePtr          lvKnownDim;     // array size if known
#endif

        RNGSET_TP           lvRngDep;       // range checks that depend on us
#if CSE
        EXPSET_TP           lvExpDep;       // expressions  that depend on us
#endif

#if ASSERTION_PROP
        unsigned            lvRefBlks;      // Bitmask mask of which block numbers contain refs
        GenTreePtr          lvDefStmt;      // Pointer to the statement with the single definition
        EXPSET_TP           lvAssertionDep; // Assertions that depend on us (i.e to this var)
#endif
        var_types           TypeGet()       { return (var_types) lvType; }

        bool                lvNormalizeOnLoad()
                            {
                                return varTypeIsSmall(TypeGet()) &&
                                       /* (TypeGet() != TYP_BOOL) && @TODO [REVISIT] [04/16/01] [vancem] */
                                       (lvIsParam || lvAddrTaken);
                            }

        bool                lvNormalizeOnStore()
                            {
                                return varTypeIsSmall(TypeGet()) &&
                                       /* (TypeGet() != TYP_BOOL) && @TODO [REVISIT] [04/16/01] [vancem] */
                                       !(lvIsParam || lvAddrTaken);
                            }

        void                decRefCnts(unsigned   weight,  Compiler * pComp);
        void                incRefCnts(unsigned   weight,  Compiler * pComp);
        void                setPrefReg(regNumber  reg,     Compiler * pComp);
        void                addPrefReg(regMaskTP  regMask, Compiler * pComp);
    };

/*****************************************************************************/


public :

    bool                lvaSortAgain;       // will need to resort the lvaTable
    unsigned            lvaCount;           // total number of locals
    LclVarDsc   *       lvaTable;           // variable descriptor table
    unsigned            lvaTableCnt;        // lvaTable size (>= lvaCount)

    LclVarDsc   *   *   lvaRefSorted;       // table sorted by refcount

    unsigned            lvaTrackedCount;    // actual # of locals being tracked
    VARSET_TP           lvaTrackedVars;     // set of tracked variables

                        // reverse map of tracked number to var number
    unsigned            lvaTrackedToVarNum[lclMAX_TRACKED];

                        // variable interference graph
    VARSET_TP           lvaVarIntf[lclMAX_TRACKED];

                        // variable preference graph
    VARSET_TP           lvaVarPref[lclMAX_TRACKED];

    unsigned            lvaFPRegVarOrder[FP_STK_SIZE];

#if DOUBLE_ALIGN
#ifdef DEBUG
                        // # of procs compiled a with double-aligned stack
    static unsigned     s_lvaDoubleAlignedProcsCount;
#endif
#endif

    bool                lvaVarAddrTaken     (unsigned varNum);

    #define             lvaVarargsHandleArg     (info.compArgsCount - 1)
    #define             lvaVarargsBaseOfStkArgs (info.compLocalsCount)

    unsigned            lvaScratchMemVar;               // dummy TYP_LCLBLK var for scratch space
    unsigned            lvaScratchMem;                  // amount of scratch frame memory for Ndirect calls

#ifdef DEBUG
    unsigned            lvaReturnEspCheck;             // confirms ESP not corrupted on return
    unsigned            lvaCallEspCheck;               // confirms ESP not corrupted after a call
#endif

        /* These are used for the callable handlers */
    unsigned            lvaShadowSPfirstOffs;   // First slot to store base SP

    unsigned            lvaLastFilterOffs();
    unsigned            lvaLocAllocSPoffs();

    void                lvaAssignFrameOffsets(bool final);

#ifdef  DEBUG
    void                lvaTableDump(bool early);
#endif

    size_t              lvaFrameSize();

    //------------------------ For splitting types ----------------------------

    void                lvaInitTypeRef      ();

    void                lvaInitVarDsc       (LclVarDsc *              varDsc,
                                             unsigned                 varNum,
                                             var_types                type,
                                             CORINFO_CLASS_HANDLE     typeHnd, 
                                             CORINFO_ARG_LIST_HANDLE  varList, 
                                             CORINFO_SIG_INFO *       varSig);

    static unsigned     lvaTypeRefMask      (var_types type);

    var_types           lvaGetActualType    (unsigned  lclNum);
    var_types           lvaGetRealType      (unsigned  lclNum);

    //-------------------------------------------------------------------------

    void                lvaInit             ();

    size_t              lvaArgSize          (const void *   argTok);
    size_t              lvaLclSize          (unsigned       varNum);

    VARSET_TP           lvaLclVarRefs       (GenTreePtr     tree,
                                             GenTreePtr  *  findPtr,
                                             varRefKinds *  refsPtr);

    unsigned            lvaGrabTemp         (bool shortLifetime = true);

    unsigned            lvaGrabTemps        (unsigned cnt);

    void                lvaSortOnly         ();
    void                lvaSortByRefCount   ();

    void                lvaMarkLocalVars    (BasicBlock* block);

    void                lvaMarkLocalVars    (); // Local variable ref-counting

    VARSET_TP           lvaStmtLclMask      (GenTreePtr stmt);

    static fgWalkPreFn  lvaIncRefCntsCB;
    void                lvaIncRefCnts       (GenTreePtr tree);

    static fgWalkPreFn  lvaDecRefCntsCB;
    void                lvaDecRefCnts       (GenTreePtr tree);

    void                lvaAdjustRefCnts    ();

#ifdef  DEBUG
    static fgWalkPreFn  lvaStressFloatLclsCB;
    void                lvaStressFloatLcls  ();

    static fgWalkPreFn  lvaStressLclFldCB;
    void                lvaStressLclFld     ();

    void                lvaDispVarSet       (VARSET_TP set, VARSET_TP allVars);

#endif

    int                 lvaFrameAddress     (int      varNum, bool *EBPbased);
    bool                lvaIsEBPbased       (int      varNum);

    bool                lvaIsParameter      (unsigned varNum);
    bool                lvaIsRegArgument    (unsigned varNum);
    BOOL                lvaIsThisArg        (unsigned varNum);

    // If the class is a TYP_STRUCT, get/set a class handle describing it

    CORINFO_CLASS_HANDLE lvaGetStruct       (unsigned varNum);
    void                 lvaSetStruct       (unsigned varNum, CORINFO_CLASS_HANDLE typeHnd);
    BYTE *               lvaGetGcLayout     (unsigned varNum);
    bool                 lvaTypeIsGC        (unsigned varNum);


    //=========================================================================
    //                          PROTECTED
    //=========================================================================

protected:

    int                 lvaDoneFrameLayout;

protected :

    //---------------- Local variable ref-counting ----------------------------

#if ASSERTION_PROP
    BasicBlock *        lvaMarkRefsCurBlock;
    GenTreePtr          lvaMarkRefsCurStmt;
#endif
    unsigned            lvaMarkRefsWeight;

    static fgWalkPreFn  lvaMarkLclRefsCallback;
    void                lvaMarkLclRefs          (GenTreePtr tree);


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Importer                                        XX
XX                                                                           XX
XX   Imports the given method and converts it to semantic trees              XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    void                impInit          ();

    void                impImport        (BasicBlock *    method);

#if INLINING

    CorInfoInline       impExpandInline  (GenTreePtr      tree,
                                          CORINFO_METHOD_HANDLE   fncHandle,
                                          GenTreePtr   *  pInlinedTree);
#endif


    //=========================================================================
    //                          PROTECTED
    //=========================================================================

protected :

    //-------------------- Stack manipulation ---------------------------------

    unsigned            impStkSize;   // Size of the full stack
    StackEntry          impSmallStack[16];  // Use this array is possible


    struct SavedStack                   // used to save/restore stack contents.
    {
        unsigned        ssDepth;        // number of values on stack
        StackEntry  *   ssTrees;        // saved tree values
    };

    unsigned __int32    impGetToken         (const BYTE*    addr, 
                                             CORINFO_MODULE_HANDLE    callerScpHandle,
                                             BOOL           verificationNeeded);
    void                impPushOnStackNoType(GenTreePtr     tree);

    void                impPushOnStack      (GenTreePtr     tree, 
                                             typeInfo       ti);
    void                impPushNullObjRefOnStack();
    StackEntry          impPopStack         ();                                            
    StackEntry          impPopStack         (CORINFO_CLASS_HANDLE&  structTypeRet);
    GenTreePtr          impPopStack         (typeInfo&      ti);
    StackEntry&         impStackTop         (unsigned       n = 0);

    void                impSaveStackState   (SavedStack *   savePtr,
                                             bool           copy);
    void                impRestoreStackState(SavedStack *   savePtr);

    var_types           impImportCall       (OPCODE         opcode,
                                             int            memberRef,
                                             GenTreePtr     newobjThis,
                                             bool           tailCall);
    static void         impBashVarAddrsToI  (GenTreePtr     tree1,
                                             GenTreePtr     tree2 = NULL);
    void                impImportLeave      (BasicBlock   * block);
    void                impResetLeaveBlock  (BasicBlock   * block,
                                             unsigned       jmpAddr);
    BOOL                impLocAllocOnStack  ();
    GenTreePtr          impIntrinsic        (CORINFO_CLASS_HANDLE   clsHnd,
                                             CORINFO_METHOD_HANDLE  method,
                                             CORINFO_SIG_INFO *     sig,
                                             int memberRef);

    //----------------- Manipulating the trees and stmts ----------------------

    GenTreePtr          impTreeList;        // Trees for the BB being imported
    GenTreePtr          impTreeLast;        // The last tree for the current BB

    enum { CHECK_SPILL_ALL = -1, CHECK_SPILL_NONE = -2 };

    void FASTCALL       impBeginTreeList    ();
    void                impEndTreeList      (BasicBlock *   block,
                                             GenTreePtr     firstStmt,
                                             GenTreePtr     lastStmt);
    void FASTCALL       impEndTreeList      (BasicBlock  *  block);
    void FASTCALL       impAppendStmtCheck  (GenTreePtr     stmt,
                                             unsigned       chkLevel);
    void FASTCALL       impAppendStmt       (GenTreePtr     stmt,
                                             unsigned       chkLevel);
    void FASTCALL       impInsertStmt       (GenTreePtr     stmt);
    void FASTCALL       impAppendTree       (GenTreePtr     tree,
                                             unsigned       chkLevel,
                                             IL_OFFSETX     offset);
    void FASTCALL       impInsertTree       (GenTreePtr     tree,
                                             IL_OFFSETX     offset);
    GenTreePtr          impAssignTempGen    (unsigned       tmp,
                                             GenTreePtr     val,
                                             unsigned       curLevel);
    GenTreePtr          impAssignTempGen    (unsigned       tmpNum,
                                             GenTreePtr     val,
                                             CORINFO_CLASS_HANDLE   structHnd,
                                             unsigned       curLevel);
    void                impAssignTempGenTop (unsigned       tmp,
                                             GenTreePtr     val);
    GenTreePtr          impCloneExpr        (GenTreePtr     tree,
                                             GenTreePtr   * clone,
                                             CORINFO_CLASS_HANDLE   structHnd,
                                             unsigned       curLevel);

    GenTreePtr          impAssignStruct     (GenTreePtr     dest,
                                             GenTreePtr     src,
                                             CORINFO_CLASS_HANDLE   structHnd,
                                             unsigned       curLevel);
    GenTreePtr          impHandleBlockOp    (genTreeOps     oper,
                                             GenTreePtr     dest,
                                             GenTreePtr     src,
                                             GenTreePtr     blkShape,
                                             bool           volatil);
    GenTreePtr          impAssignStructPtr  (GenTreePtr     dest,
                                             GenTreePtr     src,
                                             CORINFO_CLASS_HANDLE   structHnd,
                                             unsigned       curLevel);

    GenTreePtr          impGetStructAddr    (GenTreePtr     structVal,
                                             CORINFO_CLASS_HANDLE   structHnd,
                                             unsigned       curLevel,
                                             bool           willDeref);
    GenTreePtr          impNormStructVal    (GenTreePtr     structVal,
                                             CORINFO_CLASS_HANDLE   structHnd,
                                             unsigned       curLevel);



    //----------------- Importing the method ----------------------------------

#ifdef DEBUG
    unsigned            impCurOpcOffs;
    const char  *       impCurOpcName;

    // For displaying instrs with generated native code (-n:B)
    GenTreePtr          impLastILoffsStmt;  // oldest stmt added for which we did not gtStmtLastILoffs
    void                impNoteLastILoffs       ();
#endif

    /* IL offset of the stmt currently being imported. It gets set to
       BAD_IL_OFFSET after it has been set in the appended trees. Then it gets
       updated at IL offsets for which we have to report mapping info.
       It also includes a bit for stack-empty, so use jitGetILoffs()
       to get the actual IL offset value */

    IL_OFFSETX          impCurStmtOffs;
    void                impCurStmtOffsSet       (IL_OFFSET      offs);

    void                impNoteBranchOffs       ();

    unsigned            impInitBlockLineInfo    ();

    GenTreePtr          impCheckForNullPointer  (GenTreePtr     obj);
    bool                impIsThis               (GenTreePtr     obj);

    GenTreePtr          impPopList              (unsigned       count,
                                                 unsigned *     flagsPtr,
                                                 CORINFO_SIG_INFO*  sig,
                                                 GenTreePtr     treeList=0);

    GenTreePtr          impPopRevList           (unsigned       count,
                                                 unsigned *     flagsPtr,
                                                 CORINFO_SIG_INFO*  sig);

    //---------------- Spilling the importer stack ----------------------------

    struct PendingDsc
    {
        PendingDsc *    pdNext;
        BasicBlock *    pdBB;
        SavedStack      pdSavedStack;
        BOOL            pdThisPtrInit;
    };

    PendingDsc *        impPendingList; // list of BBs currently waiting to be imported.
    PendingDsc *        impPendingFree; // Freed up dscs that can be reused

    bool                impCanReimport;

    bool                impSpillStackEntry      (unsigned       level,
                                                 unsigned       varNum = BAD_VAR_NUM);
    void                impSpillStackEnsure     (bool           spillLeaves = false);
    void                impEvalSideEffects      ();
    void                impSpillSpecialSideEff  ();
    void                impSpillSideEffects     (bool           spillGlobEffects,
                                                 unsigned       chkLevel);
    void                impSpillValueClasses    ();
    static fgWalkPreFn  impFindValueClasses;
    void                impSpillLclRefs         (int            lclNum);

    BasicBlock *        impMoveTemps            (BasicBlock *   srcBlk,
                                                 BasicBlock *   destBlk,
                                                 unsigned       baseTmp);

    var_types           impBBisPush             (BasicBlock *   block,
                                                 bool       *   pHasFloat);

    bool                impCheckForQmarkColon   (BasicBlock *   block,
                                                 BasicBlock * * trueBlkPtr,
                                                 BasicBlock * * falseBlkPtr,
                                                 BasicBlock * * rsltBlkPtr,
                                                 var_types    * rsltTypPtr,
                                                 bool         * pHasFloat);
    bool                impCheckForQmarkColon   (BasicBlock *   block);

    CORINFO_CLASS_HANDLE  impGetRefAnyClass     ();
    CORINFO_CLASS_HANDLE  impGetRuntimeArgumentHandle();
    CORINFO_CLASS_HANDLE  impGetTypeHandleClass ();
    CORINFO_CLASS_HANDLE  impGetStringClass     ();
    CORINFO_CLASS_HANDLE  impGetObjectClass     ();

    GenTreePtr          impGetCpobjHandle       (CORINFO_CLASS_HANDLE   structHnd);

    void                impImportBlockCode      (BasicBlock *   block);

    void                impReimportMarkBlock    (BasicBlock *   block);
    void                impReimportMarkSuccessors(BasicBlock *  block);

    void                impImportBlockPending   (BasicBlock *   block,
                                                 bool           copyStkState);

    void                impImportBlock          (BasicBlock *   block);

    //--------------------------- Inlining-------------------------------------

#if INLINING
    #define             MAX_NONEXPANDING_INLINE_SIZE    8

    unsigned            impInlineSize; // max size for inlining

    GenTreePtr          impInlineExpr; // list of "statements" in a GT_COMMA chain

    CorInfoInline       impCanInline1 (CORINFO_METHOD_HANDLE  fncHandle,
                                       unsigned               methAttr,
                                       CORINFO_CLASS_HANDLE   clsHandle,
                                       unsigned               clsAttr);
  
    CorInfoInline       impCanInline2 (CORINFO_METHOD_HANDLE  fncHandle,
                                       unsigned               methAttr,
                                       CORINFO_METHOD_INFO *  methInfo);
    struct InlArgInfo
    {
        GenTreePtr  argNode;
        unsigned    argTmpNum;          // the argument tmp number
        unsigned    argIsUsed     :1;   // is this arg used at all?
        unsigned    argIsConst    :1;   // the argument is a constant
        unsigned    argIsLclVar   :1;   // the argument is a local variable
        unsigned    argHasSideEff :1;   // the argument has side effects
        unsigned    argHasGlobRef :1;   // the argument has a global ref
        unsigned    argHasTmp     :1;   // the argument will be evaluated to a temp
        GenTreePtr  argBashTmpNode;     // tmp node created, if it may be replaced with actual arg
    };

    struct InlLclVarInfo
    {
        var_types       lclTypeInfo;
        typeInfo        lclVerTypeInfo;

    };

    CorInfoInline        impInlineInitVars       (GenTreePtr         call,
                                                 CORINFO_METHOD_HANDLE      fncHandle,
                                                 CORINFO_CLASS_HANDLE       clsHandle,
                                                 CORINFO_METHOD_INFO *  methInfo,
                                                 unsigned           clsAttr,
                                                 InlArgInfo      *  inlArgInfo,
                                                 InlLclVarInfo   *  lclTypeInfo);

    GenTreePtr          impInlineFetchArg(unsigned lclNum, 
                                          InlArgInfo *inlArgInfo, 
                                          InlLclVarInfo *lclTypeInfo);

    void                impInlineSpillStackEntry(unsigned       level);
    void                impInlineSpillGlobEffects();
    void                impInlineSpillLclRefs   (int            lclNum);

    GenTreePtr          impConcatExprs          (GenTreePtr     exp1,
                                                 GenTreePtr     exp2);
    GenTreePtr          impExtractSideEffect    (GenTreePtr     val,
                                                 GenTreePtr *   lstPtr);
#endif


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           FlowGraph                                       XX
XX                                                                           XX
XX   Info about the basic-blocks, their contents and the flow analysis       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    BasicBlock *        fgFirstBB;      // Beginning of the basic block list
    BasicBlock *        fgLastBB;       // End of the basic block list

    flowList *          fgReturnBlocks; // list of BBJ_RETURN blocks
    unsigned            fgBBcount;      // # of BBs in the procedure
    unsigned            fgDomBBcount;   // # of BBs for which we have dominator and reachability information

    BasicBlock *        fgNewBasicBlock   (BBjumpKinds jumpKind);
    BasicBlock *        fgNewBBafter      (BBjumpKinds  jumpKind,
                                           BasicBlock * block);
    BasicBlock  *       fgPrependBB       (GenTreePtr tree);
    BasicBlock *        fgNewBBinRegion   (BBjumpKinds  jumpKind,
                                           unsigned     tryIndex,
                                           BasicBlock * nearBlk = NULL);
    void                fgCloseTryRegions (BasicBlock*  newBlk);

#if     OPT_BOOL_OPS    // Used to detect multiple logical "not" assignments.
    bool                fgMultipleNots;
#endif

    bool                fgModified;     // True if the flow graph has been modified recently

    bool                fgDomsComputed; // Have we computed the dominator sets valid?

    bool                fgHasPostfix;   // any postfix ++/-- found?
    unsigned            fgIncrCount;    // number of increment nodes found

    unsigned            fgPerBlock;     // Max index for fgEnterBlks
    unsigned *          fgEnterBlks;    // Blocks which have a special transfere of cintrol 

#if RET_64BIT_AS_STRUCTS
    unsigned            fgRetArgNum;    // index of "retval addr" argument
    bool                fgRetArgUse;
#endif

    bool                fgRemoveRestOfBlock;  // true if we know that we will throw
    bool                fgStmtRemoved;    // true if we remove statements -> need new DFA

    // The following are boolean flags that keep track of the state of internal data structures
    // @TODO [CONSIDER] [04/16/01] []: make them DEBUG only if sure about the consistency of those structures

    bool                fgStmtListThreaded;

    bool                fgGlobalMorph;    // indicates if we are during the global morphing phase
                                          // since fgMorphTree can be called from several places
    bool                fgAssertionProp;  // indicates if we should perform local assertion prop
    bool                fgExpandInline;   // indicates that we are creating tree for the inliner

    bool                impBoxTempInUse;  // the temp below is valid and available
    unsigned            impBoxTemp;       // a temporary that is used for boxing

#ifdef DEBUG
    bool                jitFallbackCompile;
#endif

    //-------------------------------------------------------------------------

    void                fgInit            ();

    void                fgImport          ();

    bool                fgAddInternal     ();

    bool                fgFoldConditional (BasicBlock * block);

    void                fgMorphStmts      (BasicBlock * block, 
                                           bool * mult, bool * lnot, bool * loadw);
    bool                fgMorphBlocks     ();

    void                fgSetOptions      ();

    void                fgMorph           ();
    
    GenTreePtr          fgGetStaticsBlock(CORINFO_CLASS_HANDLE cls);

    void                fgDataFlowInit    ();
    void                fgPerBlockDataFlow();

    VARSET_TP           fgGetHandlerLiveVars(BasicBlock *block);

    void                fgLiveVarAnalisys (bool         updIntrOnly = false);

    void                fgMarkIntf        (VARSET_TP    varSet);

    void                fgMarkIntf        (VARSET_TP    varSet1,
                                           VARSET_TP    varSet2,
                                           bool *       newIntf = NULL);

    void                fgUpdateRefCntForExtract(GenTreePtr  wholeTree, 
                                                 GenTreePtr  keptTree);

    VARSET_TP           fgComputeLife     (VARSET_TP    life,
                                           GenTreePtr   startNode,
                                           GenTreePtr   endNode,
                                           VARSET_TP    volatileVars
                                 DEBUGARG( bool *       treeModf));

    void                fgGlobalDataFlow  ();

    bool                fgDominate        (BasicBlock *b1, BasicBlock *b2);

    bool                fgReachable       (BasicBlock *b1, BasicBlock *b2);

    bool                fgComputeDoms     ();

    void                fgComputePreds    ();

    bool                fgIsPredForBlock  (BasicBlock * block,
                                           BasicBlock * blockPred);

    void                fgRemovePred      (BasicBlock * block,
                                           BasicBlock * blockPred);

    void                fgRemoveBlockAsPred(BasicBlock * block);

    void                fgReplacePred     (BasicBlock * block,
                                           BasicBlock * oldPred,
                                           BasicBlock * newPred);

    void                fgAddRefPred      (BasicBlock * block,
                                           BasicBlock * blockPred);

    void                fgFindBasicBlocks ();

    static BasicBlock * fgFindInsertPoint (unsigned     tryIndex,
                                           BasicBlock * startBlk,
                                           BasicBlock * endBlk,
                                           BasicBlock * nearBlk = NULL);

    unsigned            fgHndNstFromBBnum (unsigned     blkNum,
                                           unsigned   * pFinallyNesting = NULL);

    void                fgRemoveEmptyBlocks();

    void                fgRemoveStmt      (BasicBlock * block,
                                           GenTreePtr   stmt,
                                           bool updateRefCnt = false);

    bool                fgCheckRemoveStmt (BasicBlock * block,
                                           GenTreePtr   stmt);

    void                fgCreateLoopPreHeader(unsigned  lnum);

    void                fgUnreachableBlock(BasicBlock * block,
                                           BasicBlock * bPrev);

    void                fgRemoveJTrue     (BasicBlock *block);

    void                fgRemoveBlock     (BasicBlock * block,
                                           BasicBlock * bPrev,
                                           bool         empty);

    void                fgCompactBlocks   (BasicBlock * block);

    void                fgUpdateLoopsAfterCompacting(BasicBlock * block, BasicBlock* bNext);

    BasicBlock *        fgConnectFallThrough(BasicBlock * bSrc,
                                             BasicBlock * bDst);

    void                fgReorderBlocks   ();

    void                fgUpdateFlowGraph ();

    void                fgFindOperOrder   ();

    void                fgSetBlockOrder   ();

    void                fgRemoveReturnBlock(BasicBlock * block);


    /* Helper code that has been factored out */
    inline void         fgConvertBBToThrowBB(BasicBlock * block);    
    GenTreePtr          fgDoNormalizeOnStore(GenTreePtr tree);

    /* The following check for loops that don't execute calls */

    bool                fgLoopCallMarked;

    void                fgLoopCallTest    (BasicBlock *srcBB,
                                           BasicBlock *dstBB);
    void                fgLoopCallMark    ();

    void                fgMarkLoopHead    (BasicBlock *   block);

#ifdef DEBUG
    void                fgDispPreds       (BasicBlock * block);
    void                fgDispDoms        ();
    void                fgDispReach       ();
    void                fgDispHandlerTab  ();
    void                fgDispBBLiveness  ();
    void                fgDispBasicBlock  (BasicBlock * block,
                                           bool dumpTrees = false);
    void                fgDispBasicBlocks (bool dumpTrees = false);
    void                fgDebugCheckUpdate();
    void                fgDebugCheckBBlist();
    void                fgDebugCheckLinks ();
    void                fgDebugCheckFlags (GenTreePtr   tree);
#endif

    static void         fgOrderBlockOps   (GenTreePtr   tree,
                                           regMaskTP    reg0,
                                           regMaskTP    reg1,
                                           regMaskTP    reg2,
                                           GenTreePtr * opsPtr,   // OUT
                                           regMaskTP  * regsPtr); // OUT

    inline bool         fgIsInlining()  { return fgExpandInline; }

    //--------------------- Walking the trees in the IR -----------------------

    //----- Preorder

    struct              fgWalkPreData
    {
        fgWalkPreFn     *   wtprVisitorFn;
        void *              wtprCallbackData;
        bool                wtprLclsOnly;
        bool                wtprSkipCalls;
    }
                        fgWalkPre;

    fgWalkResult        fgWalkTreePreRec  (GenTreePtr   tree);

    fgWalkResult        fgWalkTreePre     (GenTreePtr   tree,
                                           fgWalkPreFn *visitor,
                                           void        *pCallBackData = NULL,
                                           bool         lclVarsOnly   = false,
                                           bool         skipCalls     = false);

    void                fgWalkAllTreesPre (fgWalkPreFn *visitor,
                                           void        *pCallBackData);

    // The following must be used for recursive calls to fgWalkTreePre

    #define fgWalkTreePreReEnter()                          \
                                                            \
        fgWalkPreData savedPreData = fgWalkPre;             \
        /* Reset anti-reentrancy checks */                  \
        fgWalkPre.wtprVisitorFn    = NULL;                  \
        fgWalkPre.wtprCallbackData = NULL;

    #define fgWalkTreePreRestore()  fgWalkPre = savedPreData;


    //----- Postorder

    struct fgWalkPostData
    {
        fgWalkPostFn *      wtpoVisitorFn;
        void *              wtpoCallbackData;
        genTreeOps          wtpoPrefixNode;
    }
                        fgWalkPost;

    fgWalkResult        fgWalkTreePostRec (GenTreePtr   tree);

    fgWalkResult        fgWalkTreePost    (GenTreePtr   tree,
                                           fgWalkPostFn *visitor,
                                           void         *pCallBackData = NULL,
                                           genTreeOps   prefixNode = GT_NONE);

    // The following must be used for recursive calls to fgWalkTreePost

    #define fgWalkTreePostReEnter()                         \
                                                            \
        fgWalkPostData savedPostData = fgWalkPost;          \
        /* Reset anti-reentrancy checks */                  \
        fgWalkPost.wtpoVisitorFn    = NULL;                 \
        fgWalkPost.wtpoCallbackData = NULL;

    #define fgWalkTreePostRestore() fgWalkPost = savedPostData;


    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

    //--------------------- Detect the basic blocks ---------------------------

    BasicBlock *    *   fgBBs;      // Table of pointers to the BBs

    void                fgInitBBLookup    ();
    BasicBlock *        fgLookupBB        (unsigned       addr);

    void                fgMarkJumpTarget  (BYTE *         jumpTarget,
                                           unsigned       offs);

    void                fgFindJumpTargets (const BYTE *   codeAddr,
                                           size_t         codeSize,
                                           BYTE *         jumpTarget);

    void                fgLinkBasicBlocks();

    void                fgMakeBasicBlocks (const BYTE *   codeAddr,
                                           size_t         codeSize,
                                           BYTE *         jumpTarget);

    void                fgCheckBasicBlockControlFlow();

    void                fgControlFlowPermitted(BasicBlock*  blkSrc, 
                                               BasicBlock*  blkDest,
                                               BOOL IsLeave = false /* is the src a leave block */);

    bool                fgIsStartofCatchOrFilterHandler(BasicBlock*  blk);

    bool                fgFlowToFirstBlockOfInnerTry(BasicBlock*  blkSrc, 
                                                     BasicBlock*  blkDest,
                                                     bool         sibling);

    EHblkDsc *          fgInitHndRange(BasicBlock *  src,
                                       unsigned   *  hndBeg,
                                       unsigned   *  hndEnd,
                                       bool       *  inFilter);

    EHblkDsc *          fgInitTryRange(BasicBlock *  src,
                                       unsigned   *  tryBeg,
                                       unsigned   *  tryEnd);

    static BasicBlock * fgSkipRmvdBlocks  (BasicBlock *   block);


    //-------- Insert a statement at the start or end of a basic block --------

    void                fgInsertStmtAtEnd (BasicBlock   * block,
                                           GenTreePtr     stmt);
    void                fgInsertStmtNearEnd(BasicBlock *  block,
                                           GenTreePtr     stmt);
    void                fgInsertStmtAtBeg (BasicBlock   * block,
                                           GenTreePtr     stmt);

    //-------- Determine the order in which the trees will be evaluated -------

    unsigned            fgTreeSeqNum;
    GenTree *           fgTreeSeqLst;
    GenTree *           fgTreeSeqBeg;

    void                fgSetTreeSeq      (GenTree    *   tree);
    void                fgSetStmtSeq      (GenTree    *   tree);
    void                fgSetBlockOrder   (BasicBlock *   block);

#if TGT_x86

    bool                fgFPstLvlRedo;
    void                fgComputeFPlvls   (GenTreePtr     tree);

#endif

    //------------------------- Morphing --------------------------------------

    unsigned            fgPtrArgCntCur;
    unsigned            fgPtrArgCntMax;

#if CSELENGTH
    bool                fgHasRangeChks;
#endif

    GenTreePtr          fgStoreFirstTree    (BasicBlock *   block,
                                             GenTree    *   tree);
    BasicBlock *        fgRngChkTarget      (BasicBlock *   block,
                                             unsigned       stkDepth);
    void                fgSetRngChkTarget   (GenTreePtr     treeInd,
                                             bool           delay = true);

#if OPTIMIZE_TAIL_REC
    void                fgCnvTailRecArgList (GenTreePtr *   argsPtr);
#endif

#if REARRANGE_ADDS
    void                fgMoveOpsLeft       (GenTreePtr     tree);
#endif

    inline bool         fgIsCommaThrow      (GenTreePtr     tree,
                                             bool           forFolding = false);

    inline bool         fgIsThrow           (GenTreePtr     tree);

    GenTreePtr          fgMorphIntoHelperCall(GenTreePtr    tree,
                                              int           helper,
                                              GenTreePtr    args);

    GenTreePtr          fgMorphCast         (GenTreePtr     tree);
    GenTreePtr          fgUnwrapProxy       (GenTreePtr     objRef);
    GenTreePtr          fgMorphArgs         (GenTreePtr     call);
    GenTreePtr          fgMorphLocalVar     (GenTreePtr     tree);
    GenTreePtr          fgMorphField        (GenTreePtr     tree);
    GenTreePtr          fgMorphCall         (GenTreePtr     call);
    GenTreePtr          fgMorphLeaf         (GenTreePtr     tree);
    GenTreePtr          fgMorphSmpOp        (GenTreePtr     tree);
    GenTreePtr          fgMorphConst        (GenTreePtr     tree);

    GenTreePtr          fgMorphTree         (GenTreePtr     tree);
    void                fgMorphTreeDone     (GenTreePtr     tree, 
                                             GenTreePtr     oldTree = NULL);

    GenTreePtr          fgMorphStmt;

    //----------------------- Liveness analysis -------------------------------

    VARSET_TP           fgCurUseSet;    // vars used     by block (before an assignment)
    VARSET_TP           fgCurDefSet;    // vars assigned by block (before a use)

    void                fgMarkUseDef(GenTreePtr tree, GenTreePtr asgdLclVar = NULL);

#ifdef DEBUGGING_SUPPORT
    VARSET_TP           fgLiveCb;

    static void         fgBeginScopeLife(LocalVarDsc * var, unsigned clientData);
    static void         fgEndScopeLife  (LocalVarDsc * var, unsigned clientData);

    void                fgExtendDbgLifetimes();
#endif

    //-------------------------------------------------------------------------
    //
    //  The following keeps track of any code we've added for things like array
    //  range checking or explicit calls to enable GC, and so on.
    //

    enum        addCodeKind
    {
        ACK_NONE,
        ACK_RNGCHK_FAIL,                // target when range check fails
        ACK_PAUSE_EXEC,                 // target to stop (e.g. to allow GC)
        ACK_ARITH_EXCPN,                // target on arithmetic exception
        ACK_OVERFLOW = ACK_ARITH_EXCPN, // target on overflow
        ACK_COUNT
    };

    struct      AddCodeDsc
    {
        AddCodeDsc  *   acdNext;
        BasicBlock  *   acdDstBlk;      // block  to  which we jump
        unsigned        acdData;
        addCodeKind     acdKind;        // what kind of a label is this?
#if TGT_x86
        unsigned short  acdStkLvl;
#endif
    };

    static unsigned     acdHelper       (addCodeKind    codeKind);

    AddCodeDsc  *       fgAddCodeList;
    bool                fgAddCodeModf;
    bool                fgRngChkThrowAdded;
    AddCodeDsc  *       fgExcptnTargetCache[ACK_COUNT];

    BasicBlock *        fgAddCodeRef    (BasicBlock *   srcBlk,
                                         unsigned       refData,
                                         addCodeKind    kind,
                                         unsigned       stkDepth = 0);
    AddCodeDsc  *       fgFindExcptnTarget(addCodeKind  kind,
                                         unsigned       refData);

    bool                fgIsCodeAdded   ();

    bool                fgIsThrowHlpBlk (BasicBlock *   block);
    unsigned            fgThrowHlpBlkStkLevel(BasicBlock *block);


    //--------------- The following are used when copying trees ---------------

#if CSELENGTH
    GenTreePtr          gtCopyAddrVal;
    GenTreePtr          gtCopyAddrNew;
#endif

    //-----------------------------------------------------------------------------
    //
    //  The following keeps track of the currently expanded inline functions.
    //  Any method currently on the list should not be inlined since that
    //  implies that it's being called recursively.
    //

#if INLINING

    typedef
    struct      inlExpLst
    {
        inlExpLst *     ixlNext;
        CORINFO_METHOD_HANDLE   ixlMeth;
    }
              * inlExpPtr;

    inlExpPtr           fgInlineExpList;

#endif//INLINING



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Optimizer                                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    void            optInit            ();

protected :

    LclVarDsc    *  optIsTrackedLocal  (GenTreePtr tree);

    void            optMorphTree       (BasicBlock * block, GenTreePtr stmt
                                        DEBUGARG(const char * msg) );

    void            optRemoveRangeCheck(GenTreePtr tree, GenTreePtr stmt, bool updateCSEcounts);

    bool            optIsRangeCheckRemovable(GenTreePtr tree);
    static fgWalkPreFn optValidRangeCheckIndex;



    /**************************************************************************
     *                          optHoist "this"
     *************************************************************************/

#if HOIST_THIS_FLDS

public :

    void                optHoistTFRinit    ();
    void                optHoistTFRoptimize();
    void                optHoistTFRhasCall () {  optThisFldDont = true; }
    void                optHoistTFRasgThis () {  optThisFldDont = true; }
    void                optHoistTFRhasLoop ();
    void                optHoistTFRrecRef  (CORINFO_FIELD_HANDLE hnd, GenTreePtr tree);
    void                optHoistTFRrecDef  (CORINFO_FIELD_HANDLE hnd, GenTreePtr tree);
    GenTreePtr          optHoistTFRupdate  (GenTreePtr tree);

protected :

    typedef struct  thisFldRef
    {
        thisFldRef *    tfrNext;
   CORINFO_FIELD_HANDLE tfrField;
        GenTreePtr      tfrTree;            // Some field-access tree. Used in the init block

#ifdef DEBUG
        bool            optTFRHoisted;
#endif
        unsigned short  tfrUseCnt   :8;
        unsigned short  tfrIndex    :7;
        unsigned short  tfrDef      :1;
        unsigned short  tfrTempNum  :16;
    }
      * thisFldPtr;

    thisFldPtr          optThisFldLst;
    unsigned            optThisFldCnt;
    bool                optThisFldDont;     // Dont do any TFR opts
    bool                optThisFldLoop;     // TFR inside loop

    thisFldPtr          optHoistTFRlookup  (CORINFO_FIELD_HANDLE hnd);
    GenTreePtr          optHoistTFRreplace (GenTreePtr          tree);

#endif // HOIST_THIS_FLDS

    /* The following set if the 'this' pointer is modified in the method */

    bool                optThisPtrModified;

    /**************************************************************************
     *
     *************************************************************************/

protected:

    void                optHoistLoopCode();

    bool                optIsTreeLoopInvariant(unsigned        lnum,
                                               BasicBlock  *   top,
                                               BasicBlock  *   bottom,
                                               GenTreePtr      tree);

private:

    static fgWalkPostFn optHoistLoopCodeCB;

    int                 optFindHoistCandidate(unsigned      lnum,
                                              unsigned      lbeg,
                                              unsigned      lend,
                                              BasicBlock *  block,
                                              GenTreePtr *  hoistxPtr);

    void                optHoistCandidateFound(unsigned     lnum,
                                              GenTreePtr    hoist);

protected:
    void                optOptimizeIncRng();
private:
    static fgWalkPreFn  optIncRngCB;

public:
    void                optOptimizeBools();
private:
    GenTree *           optIsBoolCond   (GenTree *      condBranch,
                                         GenTree * *    compPtr,
                                         bool      *    boolPtr);

public :

    void                optOptimizeLoops();    // for "while-do" loops duplicates simple loop conditions and transforms
                                                // the loop into a "do-while" loop
                                                // Also finds all natural loops and records them in the loop table

    void                optUnrollLoops  ();    // Unrolls loops (needs to have cost info)

protected :

    struct  LoopDsc
    {
        BasicBlock *        lpHead;     // HEAD of the loop (block before loop TOP)
        BasicBlock *        lpEnd;      // loop BOTTOM (from here we have the back edge to the TOP)
        BasicBlock *        lpEntry;    // the ENTRY in the loop (in most cases TOP or BOTTOM)
        BasicBlock *        lpExit;     // if a single exit loop this is the EXIT (in most cases BOTTOM)

        unsigned char       lpExitCnt;  // number of exits from the loop

        unsigned char       lpAsgCall;  // "callIntf" for calls in the loop
        VARSET_TP           lpAsgVars;  // set of vars assigned within the loop
        varRefKinds         lpAsgInds:8;// set of inds modified within the loop

        unsigned short      lpFlags;

#define LPFLG_DO_WHILE      0x0001      // it's a do-while loop (i.e ENTRY is at the TOP)
#define LPFLG_ONE_EXIT      0x0002      // the loop has only one exit

#define LPFLG_ITER          0x0004      // for (i = icon or lclVar; test_condition(); i++)
#define LPFLG_SIMPLE_TEST   0x0008      // Iterative loop (as above), but the test_condition() is a simple comparisson
                                        // between the iterator and something simple (e.g. i < icon or lclVar or instanceVar)
#define LPFLG_CONST         0x0010      // for (i=icon;i<icon;i++){ ... } - constant loop

#define LPFLG_VAR_INIT      0x0020      // iterator is initialized with a local var (var # found in lpVarInit)
#define LPFLG_CONST_INIT    0x0040      // iterator is initialized with a constant (found in lpConstInit)

#define LPFLG_VAR_LIMIT     0x0080      // for a simple test loop (LPFLG_SIMPLE_TEST) iterator is compared
                                        // with a local var (var # found in lpVarLimit)
#define LPFLG_CONST_LIMIT   0x0100      // for a simple test loop (LPFLG_SIMPLE_TEST) iterator is compared
                                        // with a constant (found in lpConstLimit)

#define LPFLG_HAS_PREHEAD   0x0800      // lpHead is known to be a preHead for this loop
#define LPFLG_REMOVED       0x1000      // has been removed from the loop table (unrolled or optimized away)
#define LPFLG_DONT_UNROLL   0x2000      // do not unroll this loop

#define LPFLG_ASGVARS_YES   0x4000      // "lpAsgVars" has been  computed
#define LPFLG_ASGVARS_BAD   0x8000      // "lpAsgVars" cannot be computed

        /* The following values are set only for iterator loops, i.e. has the flag LPFLG_ITER set */

        GenTreePtr          lpIterTree;     // The "i <op>= const" tree
        unsigned            lpIterVar  ();  // iterator variable #
        long                lpIterConst();  // the constant with which the iterator is incremented
        genTreeOps          lpIterOper ();  // the type of the operation on the iterator (ASG_ADD, ASG_SUB, etc.)
        void                VERIFY_lpIterTree();

        var_types           lpIterOperType();// For overflow instructions

        union
        {
            long            lpConstInit;  // initial constant value of iterator                           : Valid if LPFLG_CONST_INIT
            unsigned short  lpVarInit;    // initial local var number to which we initialize the iterator : Valid if LPFLG_VAR_INIT
        };

        /* The following is for LPFLG_SIMPLE_TEST loops only (i.e. the loop condition is "i RELOP const or var" */

        GenTreePtr          lpTestTree;   // pointer to the node containing the loop test
        genTreeOps          lpTestOper(); // the type of the comparisson between the iterator and the limit (GT_LE, GT_GE, etc.)
        void                VERIFY_lpTestTree();

        long                lpConstLimit(); // limit   constant value of iterator - loop condition is "i RELOP const" : Valid if LPFLG_CONST_LIMIT
        unsigned            lpVarLimit();   // the lclVar # in the loop condition ( "i RELOP lclVar" )                : Valid if LPFLG_VAR_LIMIT

    };

    LoopDsc             optLoopTable[MAX_LOOP_NUM]; // loop descriptor table
    unsigned            optLoopCount;               // number of tracked loops

#ifdef DEBUG
    void                optCheckPreds      ();
#endif

    void                optSetBlockWeights ();

    void                optMarkLoopBlocks  (BasicBlock *begBlk,
                                            BasicBlock *endBlk,
                                            bool        excludeEndBlk);

    void                optUnmarkLoopBlocks(BasicBlock *begBlk,
                                            BasicBlock *endBlk);

    void                optUpdateLoopsBeforeRemoveBlock(BasicBlock * block,
                                                        BasicBlock * bPrev,
                                                        bool         skipUnmarkLoop = false);
    
    void                optRecordLoop      (BasicBlock * head,
                                            BasicBlock * tail,
                                            BasicBlock * entry,
                                            BasicBlock * exit,
                                            unsigned char exitCnt);

    void                optFindNaturalLoops();

    void                fgOptWhileLoop     (BasicBlock * block);

    bool                optComputeLoopRep  (long        constInit,
                                            long        constLimit,
                                            long        iterInc,
                                            genTreeOps  iterOper,
                                            var_types   iterType,
                                            genTreeOps  testOper,
                                            bool        unsignedTest,
                                            bool        dupCond,
                                            unsigned *  iterCount);

    VARSET_TP           optAllFloatVars;// mask of all tracked      FP variables
    VARSET_TP           optAllFPregVars;// mask of all enregistered FP variables
    VARSET_TP           optAllNonFPvars;// mask of all tracked  non-FP variables

private:
    static fgWalkPreFn  optIsVarAssgCB;
protected:
    bool                optIsVarAssigned(BasicBlock *   beg,
                                         BasicBlock *   end,
                                         GenTreePtr     skip,
                                         long           var);

    bool                optIsVarAssgLoop(unsigned       lnum,
                                         long           var);

    int                 optIsSetAssgLoop(unsigned       lnum,
                                         VARSET_TP      vars,
                                         varRefKinds    inds = VR_NONE);

    bool                optNarrowTree   (GenTreePtr     tree,
                                         var_types      srct,
                                         var_types      dstt,
                                         bool           doit);


    /**************************************************************************
     *                          Code Motion
     *************************************************************************/

#ifdef CODE_MOTION

public :

    void                optLoopCodeMotion();

protected :

    // Holds the set of variables live on exit (during loop code motion).

    VARSET_TP           optLoopLiveExit;

    // Holds the set of variables that current part of the loop depends on.

#if !RMV_ENTIRE_LOOPS_ONLY
    VARSET_TP           optLoopCondTest;
#endif

    // Holds the set of variables assigned within the current loop.

    VARSET_TP           optLoopAssign;

#if RMV_ENTIRE_LOOPS_ONLY
    #define             optFindLiveRefs(tree, used, cond) optFindLiveRefs(tree)
#endif
    bool                optFindLiveRefs(GenTreePtr tree, bool used, bool cond);

#endif


    /**************************************************************************
     *                          CSE
     *************************************************************************/

#if CSE

public :

    void                optOptimizeCSEs();

protected :

    unsigned            optCSEweight;

    // The following holds the set of expressions that contain indirections.

    EXPSET_TP           optCSEindPtr;       // CSEs which use an indirect pointer
    EXPSET_TP           optCSEindScl;       // CSEs which use an indirect scalar
    EXPSET_TP           optCSEglbRef;       // CSEs which use a  global   pointer
    EXPSET_TP           optCSEaddrTakenVar; // CSEs which use an aliased variable
    EXPSET_TP           optCSEneverKilled;  // CSEs which are never killed

    /* Generic list of nodes - used by the CSE logic */

    struct  treeLst
    {
        treeLst *       tlNext;
        GenTreePtr      tlTree;
    };

    typedef struct treeLst *      treeLstPtr;

    struct  treeStmtLst
    {
        treeStmtLst *   tslNext;
        GenTreePtr      tslTree;            // tree node
        GenTreePtr      tslStmt;            // statement containing the tree
        BasicBlock  *   tslBlock;           // block containing the statement
    };

    typedef struct treeStmtLst *  treeStmtLstPtr;


    // The following logic keeps track of expressions via a simple hash table.

    struct  CSEdsc
    {
        CSEdsc *        csdNextInBucket;    // used by the hash table

        unsigned        csdHashValue;       // to make matching faster

        unsigned short  csdIndex;           // 1..optCSEcount
        unsigned short  csdVarNum;          // assigned temp number or 0xFFFF

        unsigned short  csdDefCount;        // definition   count
        unsigned short  csdUseCount;        // use          count  (excluding the implicit uses at defs)

        unsigned        csdDefWtCnt;        // weighted def count
        unsigned        csdUseWtCnt;        // weighted use count  (excluding the implicit uses at defs)

//      unsigned short  csdNewCount;        // 'updated' use count
//      unsigned short  csdNstCount;        //  'nested' use count (excluding the implicit uses at defs)

        GenTreePtr      csdTree;            // the array index tree
        GenTreePtr      csdStmt;            // stmt containing the 1st occurance
        BasicBlock  *   csdBlock;           // block containing the 1st occurance

        treeStmtLstPtr  csdTreeList;        // list of matching tree nodes: head
        treeStmtLstPtr  csdTreeLast;        // list of matching tree nodes: tail
    };

    // This enumeration describes what is killed by a call.

    enum    callInterf
    {
        CALLINT_NONE,                       // no interference (most helpers)
        CALLINT_INDIRS,                     // kills indirections (array addr store)
        CALLINT_ALL,                        // kills everything (method call)
    };

    static const size_t s_optCSEhashSize;
    CSEdsc   *   *      optCSEhash;
    CSEdsc   *   *      optCSEtab;
    unsigned            optCSEcount;
    bool                optDoCSE;           // True when we have found a duplicate CSE tree
#ifdef DEBUG
    unsigned            optCSEstart;        // first lva that is a cse
#endif

    bool                optIsCSEcandidate(GenTreePtr tree);
    void                optCSEinit     ();
    void                optCSEstop     ();
    CSEdsc   *          optCSEfindDsc  (unsigned index);
    int                 optCSEindex    (GenTreePtr tree, GenTreePtr stmt);

    void                optUnmarkCSE   (GenTreePtr tree);
    static fgWalkPreFn  optUnmarkCSEs;
    GenTreePtr          optUnmarkCSEtree;

    static int __cdecl  optCSEcostCmpEx(const void *op1, const void *op2);
    static int __cdecl  optCSEcostCmpSz(const void *op1, const void *op2);
    static callInterf   optCallInterf  (GenTreePtr call);

#endif


#if ASSERTION_PROP
    /**************************************************************************
     *               Value/Assertion propagation
     *************************************************************************/

public :

    void                optAssertionInit  ();
    static fgWalkPreFn  optAddCopiesCallback;
    void                optAddCopies      ();
    void                optAssertionReset (unsigned   limit);
    void                optAssertionRemove(unsigned   i);
    void                optAssertionAdd   (GenTreePtr tree,
                                           bool       localProp);
    bool            optAssertionIsSubrange(unsigned   lclNum,
                                           var_types  toType,
                                           EXPSET_TP  assertions, 
                                           bool       localProp
                                           DEBUGARG(unsigned* pIndex));
    GenTreePtr          optAssertionProp  (EXPSET_TP  exp, 
                                           GenTreePtr tree,
                                           bool       localProp);
    void                optAssertionPropMain();

protected :
    unsigned            optAssertionCount;      // total number of assertions in table
    bool                optAssertionPropagated; // set to true if we modified the trees
    unsigned            optAddCopyLclNum;
    GenTreePtr          optAddCopyAsgnNode;

#define MAX_ASSERTION_PROP_TAB   EXPSET_SZ

    // data structures for assertion prop
    enum optAssertion { OA_EQUAL, OA_NOT_EQUAL, OA_SUBRANGE };

    struct AssertionDsc
    {
        optAssertion    assertion;          // assertion property

        struct
        {
            unsigned            lclNum;     // assigned to local var number
        }           
                        op1;
        struct
        {
            genTreeOps          type;       // const or copy assignment
            union
            { 
                unsigned        lclNum;     // assigned from local var number
                struct
                {
                    long        iconVal;    // integer
#define PROP_ICON_FLAGS 0
#if PROP_ICON_FLAGS
                    unsigned    iconFlags;  // gtFlags
                    /* @TODO [REVISIT] [04/16/01] []: Need to add handle1 and handle2 arguments if LATE_DISASM is on */
#endif
                };

                __int64         lconVal;    // long
                double          dconVal;    // double
                struct                      // integer subrange
                {
                    long        loBound;
                    long        hiBound;
                };
            };
        }
                        op2;
    };

    AssertionDsc optAssertionTab[EXPSET_SZ]; // table that holds info about value assignments
#endif

    /**************************************************************************
     *                          Range checks
     *************************************************************************/

public :

    void                optRemoveRangeChecks();
    void                optOptimizeIndexChecks();

#if COUNT_RANGECHECKS
    static unsigned     optRangeChkRmv;
    static unsigned     optRangeChkAll;
#endif

protected :

    struct  RngChkDsc
    {
        RngChkDsc *     rcdNextInBucket;    // used by the hash table

        unsigned        rcdHashValue;       // to make matching faster
        unsigned        rcdIndex;           // 0..optRngChkCount-1

        GenTreePtr      rcdTree;            // the array index tree
    };

    unsigned            optRngChkCount;
    static const size_t optRngChkHashSize;

    RNGSET_TP           optRngIndPtr;       // RngChecks which use an indirect pointer
    RNGSET_TP           optRngIndScl;       // RngChecks which use an indirect scalar
    RNGSET_TP           optRngGlbRef;       // RngChecks which use a  global   pointer
    RNGSET_TP           optRngAddrTakenVar; // RngChecks which use an aliased variable

    RngChkDsc   *   *   optRngChkHash;
    bool                optDoRngChk;        // True when we have found a duplicate range-check tree

    void                optRngChkInit      ();
    int                 optRngChkIndex     (GenTreePtr tree);
    GenTreePtr    *     optParseArrayRef   (GenTreePtr tree,
                                            GenTreePtr *pmul,
                                            GenTreePtr *parrayAddr);
    GenTreePtr          optFindLocalInit   (BasicBlock *block,
                                            GenTreePtr local);
#if FANCY_ARRAY_OPT
    bool                optIsNoMore        (GenTreePtr op1, GenTreePtr op2,
                                            int add1 = 0,   int add2 = 0);
#endif
    void                optOptimizeInducIndexChecks(unsigned    loopNum);

    bool                optReachWithoutCall(BasicBlock * srcBB,
                                            BasicBlock * dstBB);

private:
    static fgWalkPreFn  optFindRangeOpsCB;



    /**************************************************************************
     *                          Recursion
     *************************************************************************/

#if     OPTIMIZE_RECURSION

public :

    void                optOptimizeRecursion();

#endif


    /**************************************************************************
     *                     Optimize array initializers
     *************************************************************************/

public :

    void                optOptimizeArrayInits();

protected :

    bool                optArrayInits;
    bool                optLoopsMarked;

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           RegAlloc                                        XX
XX                                                                           XX
XX  Does the register allocation and puts the remaining lclVars on the stack XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    void                raInit      ();
    void                raAssignVars(); // register allocation

protected:

    //------------------ Things used for register-allocation ------------------

#if ALLOW_MIN_OPT
    unsigned            raMinOptLclVarRegs;
#endif

    unsigned            raAvoidArgRegMask;              // Mask of incoming argument registers that we may need to avoid
    VARSET_TP           raLclRegIntf[REG_COUNT];        // variable to register interference graph

#if TGT_x86
    VARSET_TP           raFPlvlLife [FP_STK_SIZE];      // variable to fpu stk interference graph
    bool                raNewBlocks;                    // True is we added killing blocks for FPU registers
    unsigned            rpPasses;                       // Number of passes made by the register predicter
    unsigned            rpPassesMax;                    // Maximum number of passes made by the register predicter
    unsigned            rpPassesPessimize;              // Number of passes non-pessimizing made by the register predicter
    unsigned            rpStkPredict;                   // Weighted count of variables were predicted STK
    unsigned            rpPredictSpillCnt;              // Predicted number of integer spill tmps for the current tree
    FrameType           rpFrameType;
    regMaskTP           rpPredictAssignMask;            // Mask of registers to consider in rpPredictAssignRegVars()
    VARSET_TP           rpLastUseVars;                  // Set of last use variables in rpPredictTreeRegUse
    VARSET_TP           rpUseInPlace;                   // Set of variables that we used in place
    int                 rpAsgVarNum;                    // VarNum for the target of GT_ASG node
    bool                rpPredictAssignAgain;           // Must rerun the rpPredictAssignRegVars()
    bool                rpAddedVarIntf;                 // Set to true if we need to add a new var intf
    bool                rpLostEnreg;                    // Set to true if we lost an enregister var that had lvDependReg set
    bool                rpReverseEBPenreg;              // Decided to reverse the enregistration of EBP
#endif

    void                raSetupArgMasks();
#ifdef DEBUG
    void                raDumpVarIntf       ();         // Dump the variable to variable interference graph
    void                raDumpRegIntf       ();         // Dump the variable to register interference graph
#endif
    void                raAdjustVarIntf     ();

#if TGT_x86
  /******************** New Register Predictor **************************/

    regMaskTP           rpPredictRegMask    (rpPredictReg   predictReg);

    void                rpRecordRegIntf     (regMaskTP      regMask,
                                             VARSET_TP      life
                                   DEBUGARG( char *         msg));

    void                rpRecordVarIntf     (int            varNum,
                                             VARSET_TP      intfVar
                                   DEBUGARG( char *         msg));

    regMaskTP           rpPredictRegPick    (var_types      type,
                                             rpPredictReg   predictReg,
                                             regMaskTP      lockedRegs);

    regMaskTP           rpPredictGrabReg    (var_types      type,
                                             rpPredictReg   predictReg,
                                             regMaskTP      lockedRegs);

    static fgWalkPreFn  rpMarkRegIntf;

    regMaskTP           rpPredictAddressMode(GenTreePtr     tree,
                                             regMaskTP      lockedRegs,
                                             regMaskTP      rsvdRegs,
                                             GenTreePtr     lenCSE);

    void                rpPredictRefAssign  (unsigned       lclNum);

    regMaskTP           rpPredictTreeRegUse (GenTreePtr     tree,
                                             rpPredictReg   predictReg,
                                             regMaskTP      lockedRegs,
                                             regMaskTP      rsvdRegs);

    regMaskTP           rpPredictAssignRegVars(regMaskTP    regAvail);

    void                rpPredictRegUse     ();         // Entry point

    unsigned            raPredictTreeRegUse (GenTreePtr     tree);
    unsigned            raPredictListRegUse (GenTreePtr     list);

#endif


    void                raSetRegVarOrder    (regNumber   *  regVarList,
                                             regMaskTP      prefReg,
                                             regMaskTP      avoidReg);

    void                raMarkStkVars       ();

    /* raIsVarargsStackArg is called by raMaskStkVars and by
       lvaSortByRefCount.  It identifies the special case
       where a varargs function has a parameter passed on the
       stack, other than the special varargs handle.  Such parameters
       require special treatment, because they cannot be tracked
       by the GC (their offsets in the stack are not known
       at compile time).
    */

    bool                raIsVarargsStackArg(unsigned lclNum)
    {
        LclVarDsc *varDsc = &lvaTable[lclNum];

        assert(varDsc->lvIsParam);

        return (info.compIsVarArgs &&
                !varDsc->lvIsRegArg &&
                (lclNum != lvaVarargsHandleArg));
    }


#if TGT_x86

    void                raInsertFPregVarPop (BasicBlock *   srcBlk,
                                             BasicBlock * * dstPtr,
                                             unsigned       varNum);

    bool                raMarkFPblock       (BasicBlock *   srcBlk,
                                             BasicBlock *   dstBlk,
                                             unsigned       icnt,
                                             VARSET_TP      life,
                                             VARSET_TP      lifeOuter,
                                             VARSET_TP      varBit,
                                             VARSET_TP      intVars,
                                             bool    *       deathPtr,
                                             bool    *      repeatPtr);

    bool                raEnregisterFPvar   (unsigned       varNum,
                                             bool           convert);
    bool                raEnregisterFPvar   (LclVarDsc   *  varDsc,
                                             unsigned    *  pFPRegVarLiveInCnt);

#else

    void                raMarkRegSetIntf    (VARSET_TP      vars,
                                             regMaskTP      regs);

#endif

    VARSET_TP           raBitOfRegVar       (GenTreePtr     tree);

#ifdef  DEBUG
    void                raDispFPlifeInfo    ();
#endif


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           EEInterface                                     XX
XX                                                                           XX
XX   Get to the class and method info from the Execution Engine given        XX
XX   tokens for the class and method                                         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    /* These are the differnet addressing modes used to access a local var.
     * The JIT has to report the location of the locals back to the EE
     * for debugging purposes
     */

    enum siVarLocType
    {
        VLT_REG,
        VLT_STK,
        VLT_REG_REG,
        VLT_REG_STK,
        VLT_STK_REG,
        VLT_STK2,
        VLT_FPSTK,
        VLT_FIXED_VA,
        VLT_MEMORY,

        VLT_COUNT,
        VLT_INVALID
    };

    struct siVarLoc
    {
        siVarLocType    vlType;

        union
        {
            // VLT_REG -- Any 32 bit enregistered value (TYP_INT, TYP_REF, etc)
            // eg. EAX

            struct
            {
                regNumber   vlrReg;
            }
                        vlReg;

            // VLT_STK -- Any 32 bit value which is on the stack
            // eg. [ESP+0x20], or [EBP-0x28]

            struct
            {
                regNumber       vlsBaseReg;
                NATIVE_OFFSET   vlsOffset;
            }
                        vlStk;

            // VLT_REG_REG -- TYP_LONG/TYP_DOUBLE with both DWords enregistred
            // eg. RBM_EAXEDX

            struct
            {
                regNumber       vlrrReg1;
                regNumber       vlrrReg2;
            }
                        vlRegReg;

            // VLT_REG_STK -- Partly enregistered TYP_LONG/TYP_DOUBLE
            // eg { LowerDWord=EAX UpperDWord=[ESP+0x8] }

            struct
            {
                regNumber       vlrsReg;

                struct
                {
                    regNumber       vlrssBaseReg;
                    NATIVE_OFFSET   vlrssOffset;
                }
                            vlrsStk;
            }
                        vlRegStk;

            // VLT_STK_REG -- Partly enregistered TYP_LONG/TYP_DOUBLE
            // eg { LowerDWord=[ESP+0x8] UpperDWord=EAX }

            struct
            {
                struct
                {
                    regNumber       vlsrsBaseReg;
                    NATIVE_OFFSET   vlsrsOffset;
                }
                            vlsrStk;

                regNumber   vlsrReg;
            }
                        vlStkReg;

            // VLT_STK2 -- Any 64 bit value which is on the stack, in 2 successsive DWords
            // eg 2 DWords at [ESP+0x10]

            struct
            {
                regNumber       vls2BaseReg;
                NATIVE_OFFSET   vls2Offset;
            }
                        vlStk2;

            // VLT_FPSTK -- enregisterd TYP_DOUBLE (on the FP stack)
            // eg. ST(3). Actually it is ST("FPstkHeigth - vpFpStk")

            struct
            {
                unsigned        vlfReg;
            }
                        vlFPstk;

            // VLT_FIXED_VA -- fixed argument of a varargs function.
            // The argument location depends on the size of the variable
            // arguments (...). Inspecting the VARARGS_HANDLE indicates the
            // location of the first arg. This argument can then be accessed
            // relative to the position of the first arg

            struct
            {
                unsigned        vlfvOffset;
            }
                        vlFixedVarArg;

            // VLT_MEMORY

            struct
            {
                void            *rpValue;
                // pointer to the in-process location of the value.
            }           vlMemory;
        };

        // Helper functions

        bool        vlIsInReg(regNumber reg);
        bool        vlIsOnStk(regNumber reg, signed offset);
    };

    /*************************************************************************/

public :

    void                        eeInit              ();

    // Get handles

    CORINFO_CLASS_HANDLE        eeFindClass         (unsigned       metaTok,
                                                     CORINFO_MODULE_HANDLE   scope,
                                                     CORINFO_METHOD_HANDLE  context,
                                                     bool           giveUp = true);

    CORINFO_CLASS_HANDLE        eeGetMethodClass    (CORINFO_METHOD_HANDLE  hnd);

    CORINFO_CLASS_HANDLE        eeGetFieldClass     (CORINFO_FIELD_HANDLE   hnd);

    CORINFO_METHOD_HANDLE       eeFindMethod        (unsigned       metaTok,
                                                     CORINFO_MODULE_HANDLE   scope,
                                                     CORINFO_METHOD_HANDLE  context,
                                                     bool           giveUp = true);

    CORINFO_FIELD_HANDLE        eeFindField         (unsigned       metaTok,
                                                     CORINFO_MODULE_HANDLE   scope,
                                                     CORINFO_METHOD_HANDLE  context,
                                                     bool           giveUp = true);

    unsigned                    eeGetStaticBlkHnd   (CORINFO_FIELD_HANDLE   handle);

    unsigned                    eeGetStringHandle   (unsigned       strTok,
                                                     CORINFO_MODULE_HANDLE   scope,
                                                     unsigned *    *ppIndir);

    void *                      eeFindPointer       (CORINFO_MODULE_HANDLE   cls,
                                                     unsigned       ptrTok,
                                                     bool           giveUp = true);

    void *                      embedGenericHandle  (unsigned       metaTok,
                                                     CORINFO_MODULE_HANDLE   scope,
                                                     CORINFO_METHOD_HANDLE  context,
                                                     void         **ppIndir,
                                                     CORINFO_CLASS_HANDLE& tokenType,
                                                     bool           giveUp = true);

#ifdef DEBUG
    void                        eeUnresolvedMDToken (CORINFO_MODULE_HANDLE   cls,
                                                     unsigned       token,
                                                     const char *   errMsg);
#endif


    // Get the flags

    unsigned                    eeGetClassAttribs   (CORINFO_CLASS_HANDLE   hnd);
    unsigned                    eeGetClassSize      (CORINFO_CLASS_HANDLE   hnd);
    unsigned                    eeGetClassGClayout  (CORINFO_CLASS_HANDLE   hnd, BYTE* gcPtrs);
    unsigned                    eeGetClassNumInstanceFields (CORINFO_CLASS_HANDLE   hnd);

    unsigned                    eeGetMethodAttribs  (CORINFO_METHOD_HANDLE  hnd);
    void                        eeSetMethodAttribs  (CORINFO_METHOD_HANDLE  hnd, unsigned attr);

    void    *                   eeGetMethodSync     (CORINFO_METHOD_HANDLE  hnd,
                                                     void **       *ppIndir);
    unsigned                    eeGetFieldAttribs   (CORINFO_FIELD_HANDLE   hnd,
                                                     CORINFO_ACCESS_FLAGS   flags = CORINFO_ACCESS_ANY);
    unsigned                    eeGetFieldNumber    (CORINFO_FIELD_HANDLE   hnd);

    const char*                 eeGetMethodName     (CORINFO_METHOD_HANDLE  hnd, const char** className);
#ifdef DEBUG
    const char*                 eeGetMethodFullName (CORINFO_METHOD_HANDLE  hnd);
#endif
    CORINFO_MODULE_HANDLE       eeGetMethodScope    (CORINFO_METHOD_HANDLE  hnd);

    CORINFO_ARG_LIST_HANDLE     eeGetArgNext        (CORINFO_ARG_LIST_HANDLE list);
    var_types                   eeGetArgType        (CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO* sig);
    var_types                   eeGetArgType        (CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO* sig, bool* isPinned);
    CORINFO_CLASS_HANDLE        eeGetArgClass       (CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO * sig);
    unsigned                    eeGetArgSize        (CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO* sig);


    // VOM permissions
    BOOL                        eeIsOurMethod       (CORINFO_METHOD_HANDLE  hnd);
    BOOL                        eeCheckCalleeFlags  (unsigned               flags,
                                                     unsigned               opCode);
    bool                        eeCheckPutFieldFinal(CORINFO_FIELD_HANDLE   CPfield,
                                                     unsigned               flags,
                                                     CORINFO_CLASS_HANDLE   cls,
                                                     CORINFO_METHOD_HANDLE  method);
    bool                        eeCanPutField       (CORINFO_FIELD_HANDLE   CPfield,
                                                     unsigned               flags,
                                                     CORINFO_CLASS_HANDLE   cls,
                                                     CORINFO_METHOD_HANDLE  method);

    // VOM info, method sigs

    void                        eeGetSig            (unsigned               sigTok,
                                                     CORINFO_MODULE_HANDLE  scope,
                                                     CORINFO_SIG_INFO*      retSig,
                                                     bool                   giveUp = true);

    void                        eeGetCallSiteSig    (unsigned               sigTok,
                                                     CORINFO_MODULE_HANDLE  scope,
                                                     CORINFO_SIG_INFO*      retSig,
                                                     bool                   giveUp = true);

    void                        eeGetMethodSig      (CORINFO_METHOD_HANDLE  methHnd,
                                                     CORINFO_SIG_INFO*      retSig,
                                                     bool                   giveUp = true);

    unsigned                    eeGetMethodVTableOffset(CORINFO_METHOD_HANDLE methHnd);

    unsigned                    eeGetInterfaceID    (CORINFO_CLASS_HANDLE   methHnd,
                                                     unsigned *            *ppIndir);

    var_types                   eeGetFieldType      (CORINFO_FIELD_HANDLE   handle,
                                                     CORINFO_CLASS_HANDLE * structType=0);

    int                         eeGetNewHelper      (CORINFO_CLASS_HANDLE   newCls,
                                                     CORINFO_METHOD_HANDLE  context);

    int                         eeGetIsTypeHelper   (CORINFO_CLASS_HANDLE   newCls);

    int                         eeGetChkCastHelper  (CORINFO_CLASS_HANDLE   newCls);

    CORINFO_CLASS_HANDLE        eeGetBuiltinClass   (CorInfoClassId         classId) const;

    // Method entry-points, instrs

    void    *                   eeGetMethodPointer  (CORINFO_METHOD_HANDLE   methHnd,
                                                     InfoAccessType *        pAccessType,
                                                     CORINFO_ACCESS_FLAGS    flags = CORINFO_ACCESS_ANY);

    void    *                   eeGetMethodEntryPoint(CORINFO_METHOD_HANDLE  methHnd,
                                                      InfoAccessType *       pAccessType,
                                                      CORINFO_ACCESS_FLAGS   flags = CORINFO_ACCESS_ANY);

    bool                        eeGetMethodInfo     (CORINFO_METHOD_HANDLE  method,
                                                     CORINFO_METHOD_INFO *  methodInfo);

    CorInfoInline               eeCanInline         (CORINFO_METHOD_HANDLE  callerHnd,
                                                     CORINFO_METHOD_HANDLE  calleeHnd,
                                                     CORINFO_ACCESS_FLAGS   flags = CORINFO_ACCESS_ANY);

    bool                        eeCanTailCall       (CORINFO_METHOD_HANDLE  callerHnd,
                                                     CORINFO_METHOD_HANDLE  calleeHnd,
                                                     CORINFO_ACCESS_FLAGS   flags = CORINFO_ACCESS_ANY);

    void    *                   eeGetHintPtr        (CORINFO_METHOD_HANDLE  methHnd,
                                                     void **       *ppIndir);

    void    *                   eeGetFieldAddress   (CORINFO_FIELD_HANDLE   handle,
                                                     void **       *ppIndir);

    unsigned                    eeGetFieldThreadLocalStoreID (
                                                     CORINFO_FIELD_HANDLE   handle,
                                                     void **       *ppIndir);

    unsigned                    eeGetFieldOffset    (CORINFO_FIELD_HANDLE   handle);

     // Native Direct Optimizations

        // return the unmanaged calling convention for a PInvoke

    CorInfoUnmanagedCallConv    eeGetUnmanagedCallConv(CORINFO_METHOD_HANDLE method);

        // return if any marshaling is required for PInvoke methods

    BOOL                        eeNDMarshalingRequired(CORINFO_METHOD_HANDLE method,
                                                       CORINFO_SIG_INFO*     sig);

    bool                        eeIsNativeMethod(CORINFO_METHOD_HANDLE method);

    CORINFO_METHOD_HANDLE       eeMarkNativeTarget(CORINFO_METHOD_HANDLE method);

    CORINFO_METHOD_HANDLE       eeGetMethodHandleForNative(CORINFO_METHOD_HANDLE method);

    CORINFO_EE_INFO *           eeGetEEInfo();

    DWORD                       eeGetThreadTLSIndex(DWORD * *ppIndir);

    const void  *               eeGetInlinedCallFrameVptr(const void ** *ppIndir);

    LONG        *               eeGetAddrOfCaptureThreadGlobal(LONG ** *ppIndir);

    GenTreePtr                  eeGetPInvokeCookie(CORINFO_SIG_INFO *szMetaSig);

#ifdef PROFILER_SUPPORT
    CORINFO_PROFILING_HANDLE    eeGetProfilingHandle(CORINFO_METHOD_HANDLE      method,
                                                     BOOL                               *pbHookMethod,
                                                     CORINFO_PROFILING_HANDLE **ppIndir);
#endif

    // Exceptions

    unsigned                    eeGetEHcount        (CORINFO_METHOD_HANDLE handle);
    void                        eeGetEHinfo         (unsigned       EHnum,
                                                     CORINFO_EH_CLAUSE* EHclause);

    // Debugging support - Line number info

    void                        eeGetStmtOffsets();

    unsigned                    eeBoundariesCount;

    struct      boundariesDsc
    {
        NATIVE_IP       nativeIP;
        IL_OFFSET       ilOffset;
        SIZE_T          sourceReason; // @TODO [REVISIT] [04/16/01] []: make sure this 
                                      // lines up with the ICorDebugInfo::OffsetMapping struct
                                      // (ie, fill in this field appropriately)
    }
                              * eeBoundaries;   // Boundaries to report to EE
    void        FASTCALL        eeSetLIcount        (unsigned       count);
    void        FASTCALL        eeSetLIinfo         (unsigned       which,
                                                     NATIVE_IP      offs,
                                                     unsigned       srcIP,
                                                     bool           stkEmpty);
    void                        eeSetLIdone         ();


    // Debugging support - Local var info

    bool                        compGetVarsExtendOthers(unsigned    varNum,
                                                     bool *         varInfoProvided,
                                                     LocalVarDsc *  localVarPtr);

    void                        eeGetVars           ();

    unsigned                    eeVarsCount;

    struct VarResultInfo
    {
        DWORD           startOffset;
        DWORD           endOffset;
        DWORD           varNumber;
        siVarLoc        loc;
    }
                              * eeVars;
    void FASTCALL               eeSetLVcount        (unsigned       count);
    void                        eeSetLVinfo         (unsigned       which,
                                                     unsigned       startOffs,
                                                     unsigned       length,
                                                     unsigned       varNum,
                                                     unsigned       LVnum,
                                                     lvdNAME        namex,
                                                     bool           avail,
                                                     const siVarLoc &loc);
    void                        eeSetLVdone         ();

    // Utility functions

#if defined(DEBUG)
    const wchar_t * FASTCALL    eeGetCPString       (unsigned stringHandle);
    const char * FASTCALL       eeGetCPAsciiz       (unsigned       cpx);
#endif

#if defined(DEBUG) || INLINE_MATH
    static const char *         eeHelperMethodName  (int            helper);
    const char *                eeGetFieldName      (CORINFO_FIELD_HANDLE   fieldHnd,
                                                     const char **  classNamePtr = NULL);
#endif
    static CORINFO_METHOD_HANDLE eeFindHelper       (unsigned       helper);
    static CorInfoHelpFunc      eeGetHelperNum      (CORINFO_METHOD_HANDLE  method);

    static CORINFO_FIELD_HANDLE eeFindJitDataOffs   (unsigned       jitDataOffs);
        // returns a number < 0 if not a Jit Data offset
    static int                  eeGetJitDataOffs    (CORINFO_FIELD_HANDLE   field);
protected :

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           TempsInfo                                       XX
XX                                                                           XX
XX  The temporary lclVars allocated by the compiler for code generation      XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  The following keeps track of temporaries allocated by the compiler in
 *  the stack frame.
 */

    struct  TempDsc
    {
        TempDsc  *          tdNext;
        int                 tdOffs;
#define BAD_TEMP_OFFSET     0xDDDDDDDD

        BYTE                tdSize;
        var_types           tdType;
        short               tdNum;

        size_t              tdTempSize() {  return            tdSize;  }
        var_types           tdTempType() {  return            tdType;  }
        int                 tdTempNum () {  return            tdNum ;  }
        int                 tdTempOffs() {  assert(tdOffs != BAD_TEMP_OFFSET);
                                            return            tdOffs;  }
    };

/*****************************************************************************/

public :

    void                tmpInit     ();

    static unsigned     tmpFreeSlot (size_t      size); // which slot in tmpFree[] to use
    TempDsc  *          tmpGetTemp  (var_types   type); // get temp for the given type
    void                tmpRlsTemp  (TempDsc *   temp);
    TempDsc *           tmpFindNum  (int         temp);

    void                tmpEnd      ();
    TempDsc *           tmpListBeg  ();
    TempDsc *           tmpListNxt  (TempDsc * curTemp);
    void                tmpDone     ();

protected :

    unsigned            tmpIntSpillMax;    // number of int-sized spill temps
    unsigned            tmpDoubleSpillMax; // number of int-sized spill temps

    unsigned            tmpCount;       // Number of temps
    size_t              tmpSize;        // Size of all the temps
#ifdef DEBUG
    unsigned            tmpGetCount;    // Temps which havent been released yet
#endif

    TempDsc  *          tmpFree[TEMP_MAX_SIZE / sizeof(int)];

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           RegSet                                          XX
XX                                                                           XX
XX  Represents the register set, and their states during code generation     XX
XX  Can select an unused register, keeps track of the contents of the        XX
XX  registers, and can spill registers                                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/



/*****************************************************************************
 *
 *  Keep track of the current state of each register. This is intended to be
 *  used for things like register reload suppression, but for now the only
 *  thing it does is note which registers we use in each method.
 */

enum    regValKind
{
    RV_TRASH,           // random unclassified garbage
    RV_INT_CNS,         // integer constant
    RV_LCL_VAR,         // local variable value
    RV_CLS_VAR,         // instance variable value (danger: aliasing!)
    RV_LCL_VAR_LNG_LO,  // lower half of long local variable
    RV_LCL_VAR_LNG_HI,
#if USE_SET_FOR_LOGOPS
    RV_BIT,             // low bit unknown, the rest is cleared
#endif
};

/*****************************************************************************/


public :

    void                rsInit();


    // The same descriptor is also used for 'multi-use' register tracking, BTW.

    struct  SpillDsc
    {
        SpillDsc   *        spillNext;    // next spilled value of same reg
        GenTreePtr          spillTree;    // the value that was spilled
        GenTreePtr          spillAddr;    // owning complex address mode or 0
        TempDsc    *        spillTemp;    // the temp holding the spilled value
        bool                spillMoreMultis;
    };

    SpillDsc   *        rsSpillFree;      // list of unused spill descriptors

    //-------------------------------------------------------------------------
    //
    //  Track the status of the registers
    //

    // trees currently sitting in the registers
    GenTreePtr          rsUsedTree[REG_COUNT];

    // addr for which rsUsedTree[reg] is a part of the addressing mode
    GenTreePtr          rsUsedAddr[REG_COUNT];

    // keeps track of 'multiple-use' registers.
    SpillDsc   *        rsMultiDesc[REG_COUNT];

    regMaskTP           rsMaskUsed;   // currently 'used' registers mask
    regMaskTP           rsMaskVars;   // mask of registers currently allocated to variables
    regMaskTP           rsMaskLock;   // currently 'locked' registers mask
    regMaskTP           rsMaskModf;   // mask of the registers modified by the current function.
    regMaskTP           rsMaskMult;   // currently 'multiply used' registers mask

    regPairNo           rsFindRegPairNo   (regMaskTP  regMask);

    regMaskTP           rsRegMaskFree     ();
    regMaskTP           rsRegMaskCanGrab  ();
    void                rsMarkRegUsed     (GenTreePtr tree, GenTreePtr addr = 0);
    void                rsMarkRegPairUsed (GenTreePtr tree);
    bool                rsIsTreeInReg     (regNumber  reg, GenTreePtr tree);
    void                rsMarkRegFree     (regMaskTP  regMask);
    void                rsMarkRegFree     (regNumber  reg, GenTreePtr tree);
    void                rsMultRegFree     (regMaskTP  regMask);
    unsigned            rsFreeNeededRegCount(regMaskTP  needReg);

    void                rsLockReg         (regMaskTP  regMask);
    void                rsUnlockReg       (regMaskTP  regMask);
    void                rsLockUsedReg     (regMaskTP  regMask);
    void                rsUnlockUsedReg   (regMaskTP  regMask);
    void                rsLockReg         (regMaskTP  regMask, regMaskTP * usedMask);
    void                rsUnlockReg       (regMaskTP  regMask, regMaskTP   usedMask);

    regMaskTP           rsRegExclMask     (regMaskTP  regMask, regMaskTP   rmvMask);

    //-------------------- Register selection ---------------------------------

    unsigned            rsCurRegArg;            // current argument register (for caller)

    unsigned            rsCalleeRegArgNum;      // total number of incoming register arguments
    regMaskTP           rsCalleeRegArgMaskLiveIn;   // mask of register arguments (live on entry to method)

#if STK_FASTCALL
    size_t              rsCurArgStkOffs;        // stack offset of current arg
#endif

#if defined(DEBUG) && !NST_FASTCALL
    bool                genCallInProgress;
#endif

#if SCHEDULER || USE_SET_FOR_LOGOPS
                        // Remembers the table index where we start
                        // the round robin register selection.
    unsigned            rsNextPickRegIndex;

    unsigned            rsREGORDER_SIZE();
#endif

#if SCHEDULER
    bool                rsRiscify         (var_types type, regMaskTP needReg);
#endif

    regNumber           rsGrabReg         (regMaskTP    regMask);
    void                rsUpdateRegOrderIndex(regNumber reg);
    regNumber           rsPickReg         (regMaskTP    regMask = RBM_NONE,
                                           regMaskTP    regBest = RBM_NONE,
                                           var_types    regType = TYP_INT);
    regPairNo           rsGrabRegPair     (regMaskTP    regMask);
    regPairNo           rsPickRegPair     (regMaskTP    regMask);
    void                rsRmvMultiReg     (regNumber    reg);
    void                rsRecMultiReg     (regNumber    reg);

#ifdef DEBUG
    int                 rsStressRegs      ();
#endif

    //-------------------------------------------------------------------------
    //
    //  The following tables keep track of spilled register values.
    //

    // When a register gets spilled, the old information is stored here
    SpillDsc   *        rsSpillDesc[REG_COUNT];

    void                rsSpillChk      ();
    void                rsSpillInit     ();
    void                rsSpillDone     ();
    void                rsSpillBeg      ();
    void                rsSpillEnd      ();

    void                rsSpillReg      (regNumber      reg);
    void                rsSpillRegs     (regMaskTP      regMask);

    SpillDsc *          rsGetSpillInfo  (GenTreePtr     tree,
                                         regNumber      reg,
                                         SpillDsc **    pPrevDsc = NULL,
                                         SpillDsc **    pMultiDsc = NULL);

    TempDsc     *       rsGetSpillTempWord(regNumber    oldReg,
                                         SpillDsc *     dsc,
                                         SpillDsc *     prevDsc);

    enum                ExactReg {  ANY_REG, EXACT_REG };
    enum                KeepReg  { FREE_REG, KEEP_REG  };

    regNumber           rsUnspillOneReg (GenTreePtr     tree,
                                         regNumber      oldReg, 
                                         KeepReg        willKeepNewReg,
                                         regMaskTP      needReg);

    TempDsc *           rsUnspillInPlace(GenTreePtr     tree,
                                         bool           freeTemp = false);

    void                rsUnspillReg    (GenTreePtr     tree, 
                                         regMaskTP      needReg,
                                         KeepReg        keepReg);

    void                rsUnspillRegPair(GenTreePtr     tree, 
                                         regMaskTP      needReg,
                                         KeepReg        keepReg);

    void                rsMarkSpill     (GenTreePtr     tree,
                                         regNumber      reg);

    void                rsMarkUnspill   (GenTreePtr     tree,
                                         regNumber      reg);

    //-------------------------------------------------------------------------
    //
    //  These are used to track the contents of the registers during
    //  code generation.
    //

    struct      RegValDsc
    {
        regValKind          rvdKind;
        union
        {
            long            rvdIntCnsVal;
            unsigned        rvdLclVarNum;
       CORINFO_FIELD_HANDLE rvdClsVarHnd;
        };
    };

    RegValDsc           rsRegValues[REG_COUNT];


    bool                rsCanTrackGCreg   (regMaskTP regMask);

    void                rsTrackRegClr     ();
    void                rsTrackRegClrPtr  ();
    void                rsTrackRegTrash   (regNumber reg);
    void                rsTrackRegIntCns  (regNumber reg, long val);
    void                rsTrackRegLclVar  (regNumber reg, unsigned var);
#if USE_SET_FOR_LOGOPS
    void                rsTrackRegOneBit  (regNumber reg);
#endif
    void                rsTrackRegLclVarLng(regNumber reg, unsigned var, bool low);
    bool                rsTrackIsLclVarLng(regValKind rvKind);
    void                rsTrackRegClsVar  (regNumber reg, GenTreePtr clsVar);
    void                rsTrackRegCopy    (regNumber reg1, regNumber reg2);
    void                rsTrackRegSwap    (regNumber reg1, regNumber reg2);


    //---------------------- Load suppression ---------------------------------

#if REDUNDANT_LOAD

#if USE_SET_FOR_LOGOPS
    regNumber           rsFindRegWithBit  (bool     free    = true,
                                           bool     byteReg = true);
#endif
    regNumber           rsIconIsInReg     (long     val,  long * closeDelta = NULL);
    bool                rsIconIsInReg     (long     val,  regNumber reg);
    regNumber           rsLclIsInReg      (unsigned var);
    regPairNo           rsLclIsInRegPair  (unsigned var);
    regNumber           rsClsVarIsInReg   (CORINFO_FIELD_HANDLE fldHnd);

    void                rsTrashLclLong    (unsigned     var);
    void                rsTrashLcl        (unsigned     var);
    void                rsTrashClsVar     (CORINFO_FIELD_HANDLE fldHnd);
    void                rsTrashRegSet     (regMaskTP    regMask);
    void                rsTrashAliasedValues(GenTreePtr asg = NULL);

    regMaskTP           rsUselessRegs     ();

#endif // REDUNDANT_LOAD


    //-------------------------------------------------------------------------

protected :


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           GCInfo                                          XX
XX                                                                           XX
XX  Garbage-collector information                                            XX
XX  Keeps track of which variables hold pointers.                            XX
XX  Generates the GC-tables                                                  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    void                gcInit              ();
    void                gcResetForBB        ();

    void                gcMarkRegSetGCref   (regMaskTP  regMask);
    void                gcMarkRegSetByref   (regMaskTP  regMask);
    void                gcMarkRegSetNpt     (regMaskTP  regMask);
    void                gcMarkRegPtrVal     (regNumber  reg, var_types type);
    void                gcMarkRegPtrVal     (GenTreePtr tree);

/*****************************************************************************/


    //-------------------------------------------------------------------------
    //
    //  The following keeps track of which registers currently hold pointer
    //  values.
    //

    regMaskTP           gcRegGCrefSetCur;   // current regs holding GCrefs
    regMaskTP           gcRegByrefSetCur;   // current regs holding Byrefs

    VARSET_TP           gcTrkStkPtrLcls;    // set of tracked stack ptr lcls (GCref and Byref) - no args
    VARSET_TP           gcVarPtrSetCur;     // currently live part of "gcTrkStkPtrLcls"

#ifdef  DEBUG
    void                gcRegPtrSetDisp(regMaskTP regMask, bool fixed);
#endif

    //-------------------------------------------------------------------------
    //
    //  The following keeps track of the lifetimes of non-register variables that
    //  hold pointers.
    //

    struct varPtrDsc
    {
        varPtrDsc   *   vpdNext;
        varPtrDsc   *   vpdPrev;

        unsigned        vpdVarNum;         // which variable is this about?

        unsigned        vpdBegOfs ;        // the offset where life starts
        unsigned        vpdEndOfs;         // the offset where life starts
    };

    varPtrDsc   *       gcVarPtrList;
    varPtrDsc   *       gcVarPtrLast;

    void                gcVarPtrSetInit();

/*****************************************************************************/

    //  'pointer value' register tracking and argument pushes/pops tracking.

    enum    rpdArgType_t    { rpdARG_POP, rpdARG_PUSH, rpdARG_KILL };

    struct  regPtrDsc
    {
        regPtrDsc  *          rpdNext;            // next entry in the list
        unsigned              rpdOffs;            // the offset of the instruction

        union                                     // two byte union
        {
            struct                                // two byte structure
            {
                regMaskSmall  rpdAdd;             // regptr bitset being added
                regMaskSmall  rpdDel;             // regptr bitset being removed
            }
                              rpdCompiler;

            unsigned short    rpdPtrArg;          // arg offset or popped arg count
        };

        unsigned short        rpdArg          :1;  // is this an argument descriptor?
        unsigned short        rpdArgType      :2;  // is this an argument push,pop, or kill?
        rpdArgType_t          rpdArgTypeGet() { return (rpdArgType_t) rpdArgType; }
        unsigned short        rpdEpilog       :1;  // is this part of an epilog?
        unsigned short        rpdGCtype       :2;  // is this a pointer, after all?
        GCtype                rpdGCtypeGet()  { return (GCtype) rpdGCtype; }

        unsigned short        rpdIsThis       :1;  // is it the 'this' pointer
        unsigned short        rpdCall         :1;  // is this a true call site?
        unsigned short        rpdCallGCrefRegs:4; // Are EBX,EBP,ESI,EDI live?
        unsigned short        rpdCallByrefRegs:4; // Are EBX,EBP,ESI,EDI live?
    };

    regPtrDsc  *        gcRegPtrList;
    regPtrDsc  *        gcRegPtrLast;
    unsigned            gcPtrArgCnt;

#if MEASURE_PTRTAB_SIZE
    static unsigned     s_gcRegPtrDscSize;
    static unsigned     s_gcTotalPtrTabSize;
#endif

    regPtrDsc  *        gcRegPtrAllocDsc      ();

/*****************************************************************************/


    //-------------------------------------------------------------------------
    //
    //  If we're not generating fully interruptible code, we create a simple
    //  linked list of call descriptors.
    //

    struct  CallDsc
    {
        CallDsc     *       cdNext;
        void        *       cdBlock;        // the code block of the call
        unsigned            cdOffs;         // the offset     of the call

        unsigned short      cdArgCnt;
        unsigned short      cdArgBaseOffset;

        union
        {
            struct                          // used if cdArgCnt == 0
            {
                unsigned    cdArgMask;      // ptr arg bitfield
                unsigned    cdByrefArgMask; // byref qualifier for cdArgMask
            };

            unsigned    *   cdArgTable;     // used if cdArgCnt != 0
        };

        regMaskSmall        cdGCrefRegs;
        regMaskSmall        cdByrefRegs;
    };

    CallDsc    *        gcCallDescList;
    CallDsc    *        gcCallDescLast;

    //-------------------------------------------------------------------------

    void                gcCountForHeader  (unsigned short* untrackedCount,
                                           unsigned short* varPtrTableSize);
    size_t              gcMakeRegPtrTable (BYTE *         dest,
                                           int            mask,
                                           const InfoHdr& header,
                                           unsigned       codeSize);
    size_t              gcPtrTableSize    (const InfoHdr& header,
                                           unsigned       codeSize);
    BYTE    *           gcPtrTableSave    (BYTE *         destPtr,
                                           const InfoHdr& header,
                                           unsigned       codeSize);
    void                gcRegPtrSetInit   ();


    struct genLivenessSet
    {
        VARSET_TP      liveSet;
        VARSET_TP      varPtrSet;
        regMaskSmall   maskVars;
        regMaskSmall   gcRefRegs;
        regMaskSmall   byRefRegs;
    };

    void saveLiveness    (genLivenessSet * ls);
    void restoreLiveness (genLivenessSet * ls);
    void checkLiveness   (genLivenessSet * ls);

/*****************************************************************************/

    static bool         gcIsWriteBarrierCandidate(GenTreePtr tgt);
    static bool         gcIsWriteBarrierAsgNode  (GenTreePtr op);

protected :



    //-------------------------------------------------------------------------
    //
    //  These record the info about the procedure in the info-block
    //

    BYTE    *           gcEpilogTable;

    unsigned            gcEpilogPrevOffset;

    size_t              gcInfoBlockHdrSave(BYTE *       dest,
                                           int          mask,
                                           unsigned     methodSize,
                                           unsigned     prologSize,
                                           unsigned     epilogSize,
                                           InfoHdr *    header,
                                           int *        s_cached);

    static size_t       gcRecordEpilog    (void *       pCallBackData,
                                           unsigned     offset);

#if DUMP_GC_TABLES

    void                gcFindPtrsInFrame (const void * infoBlock,
                                           const void * codeBlock,
                                           unsigned     offs);

    unsigned            gcInfoBlockHdrDump(const BYTE * table,
                                           InfoHdr    * header,       /* OUT */
                                           unsigned   * methodSize);  /* OUT */

    unsigned            gcDumpPtrTable    (const BYTE *   table,
                                           const InfoHdr& header,
                                           unsigned       methodSize);
#endif



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Instruction                                     XX
XX                                                                           XX
XX  The interface to generate a machine-instruction.                         XX
XX  Currently specific to x86                                                XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/* Double alignment macros for passing extra information to the inst_SV routines. */

/*****************************************************************************/
#if     DOUBLE_ALIGN
/*****************************************************************************/


#define DOUBLE_ALIGN_PARAM         , bool isEBPRelative
#define DOUBLE_ALIGN_ARG           , isEBPRelative

// this replaces the tests genFPused

#define DOUBLE_ALIGN_FPUSED         (genFPused || isEBPRelative)
#define DOUBLE_ALIGN_NEED_EBPFRAME  (genFPused || genDoubleAlign)


/*****************************************************************************/
#else // DOUBLE_ALIGN
/*****************************************************************************/

/* Without double alignment, the arg/param macros go away, and ebp-rel <==> genFPused */

#define DOUBLE_ALIGN_PARAM
#define DOUBLE_ALIGN_ARG
#define DOUBLE_ALIGN_FPUSED         (genFPused)
#define DOUBLE_ALIGN_NEED_EBPFRAME  (genFPused)


/*****************************************************************************/
#endif // DOUBLE_ALIGN
/*****************************************************************************/


public :

    void                instInit();

    static
    BYTE                instInfo[INS_count];

#if TGT_x86
    #define INST_FP     0x01                // is it a FP instruction?
    static
    bool                instIsFP        (instruction    ins);
#else
    #define INST_BD     0x01                // is it a branch-delayed ins?
    static
    bool                instBranchDelay (instruction    ins);
    #define INST_BD_C   0x02                // is it a conditionally BD ins?
    static
    bool                instBranchDelayC(instruction    ins);
    static
    unsigned            instBranchDelayL(instruction    ins);
    #define INST_BR     0x04                // is it a branch/call/ret ins?
    static
    bool                instIsBranch    (instruction    ins);
#endif

    #define INST_DEF_FL 0x20                // does the instruction set flags?
    #define INST_USE_FL 0x40                // does the instruction use flags?
    #define INST_SPSCHD 0x80                // "special" scheduler handling

#if SCHEDULER

    static
    bool                instDefFlags    (instruction    ins);
    static
    bool                instUseFlags    (instruction    ins);
    static
    bool                instSpecialSched(instruction    ins);

#endif

#if TGT_x86

    void                instGen         (instruction    ins);

    void                inst_JMP        (emitJumpKind   jmp,
                                         BasicBlock *   tgtBlock,
                                         bool           except   = false,
                                         bool           moveable = false,
                                         bool           newBlock = false);

    void                inst_SET        (emitJumpKind   condition,
                                         regNumber      reg);

    static
    regNumber           inst3opImulReg  (instruction    ins);
    static 
    instruction         inst3opImulForReg(regNumber     reg);

    void                inst_RV         (instruction    ins,
                                         regNumber      reg,
                                         var_types      type,
                                         emitAttr       size = EA_UNKNOWN);
    void                inst_RV_RV      (instruction    ins,
                                         regNumber      reg1,
                                         regNumber      reg2,
                                         var_types      type = TYP_INT,
                                         emitAttr       size = EA_UNKNOWN);
    void                inst_IV         (instruction    ins,
                                         long           val);
    void                inst_IV_handle  (instruction    ins,
                                         long           val,
                                         unsigned       flags,
                                         unsigned       metaTok,
                                         CORINFO_CLASS_HANDLE   CLS);
    void                inst_FS         (instruction    ins, unsigned stk = 0);
    void                inst_FN         (instruction    ins, unsigned stk);

    void                inst_RV_IV      (instruction    ins,
                                         regNumber      reg,
                                         long           val,
                                         var_types      type = TYP_INT);

    void                inst_ST_RV      (instruction    ins,
                                         TempDsc    *   tmp,
                                         unsigned       ofs,
                                         regNumber      reg,
                                         var_types      type);
    void                inst_ST_IV      (instruction    ins,
                                         TempDsc    *   tmp,
                                         unsigned       ofs,
                                         long           val,
                                         var_types      type);
    void                inst_RV_ST      (instruction    ins,
                                         regNumber      reg,
                                         TempDsc    *   tmp,
                                         unsigned       ofs,
                                         var_types      type,
                                         emitAttr       size = EA_UNKNOWN);
    void                inst_FS_ST      (instruction    ins,
                                         emitAttr       size,
                                         TempDsc    *   tmp,
                                         unsigned       ofs);

    void                inst_AV         (instruction    ins,
                                         GenTreePtr     tree, unsigned offs = 0);

    void                instEmit_indCall(GenTreePtr     call,
                                         size_t         argSize,
                                         size_t         retSize);

    void                instEmit_RM     (instruction    ins,
                                         GenTreePtr     tree,
                                         GenTreePtr     addr,
                                         unsigned       offs);

    void                instEmit_RM_RV  (instruction    ins,
                                         emitAttr       size,
                                         GenTreePtr     tree,
                                         regNumber      reg,
                                         unsigned       offs);

    void                instEmit_RV_RM  (instruction    ins,
                                         emitAttr       size,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs);

    void                instEmit_RV_RIA (instruction    ins,
                                         regNumber      reg1,
                                         regNumber      reg2,
                                         unsigned       offs);

    void                inst_TT         (instruction    ins,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0,
                                         int            shfv = 0,
                                         emitAttr       size = EA_UNKNOWN);

    void                inst_TT_RV      (instruction    ins,
                                         GenTreePtr     tree,
                                         regNumber      reg,
                                         unsigned       offs = 0);

    void                inst_TT_IV      (instruction    ins,
                                         GenTreePtr     tree,
                                         long           val,
                                         unsigned       offs = 0);

    void                inst_RV_AT      (instruction    ins,
                                         emitAttr       size,
                                         var_types      type,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0);

    void                inst_AT_IV      (instruction    ins,
                                         emitAttr       size,
                                         GenTreePtr     tree,
                                         long           icon,
                                         unsigned       offs = 0);

    void                inst_RV_TT      (instruction    ins,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0,
                                         emitAttr       size = EA_UNKNOWN);

    void                inst_RV_TT_IV   (instruction    ins,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         long           val);

    void                inst_FS_TT      (instruction    ins,
                                         GenTreePtr tree);

    void                inst_RV_SH      (instruction    ins,
                                         regNumber reg, unsigned val);

    void                inst_TT_SH      (instruction    ins,
                                         GenTreePtr     tree,
                                         unsigned       val, unsigned offs = 0);

    void                inst_RV_CL      (instruction    ins, regNumber reg);

    void                inst_TT_CL      (instruction    ins,
                                         GenTreePtr     tree, unsigned offs = 0);

    void                inst_RV_RV_IV   (instruction    ins,
                                         regNumber      reg1,
                                         regNumber      reg2,
                                         unsigned       ival);

    void                inst_RV_RR      (instruction    ins,
                                         emitAttr       size,
                                         regNumber      reg1,
                                         regNumber      reg2);

    void                inst_RV_ST      (instruction    ins,
                                         emitAttr       size,
                                         regNumber      reg,
                                         GenTreePtr     tree);

    void                inst_mov_RV_ST (regNumber      reg,
                                        GenTreePtr     tree);

    void                instGetAddrMode (GenTreePtr     addr,
                                         regNumber *    baseReg,
                                         unsigned *     indScale,
                                         regNumber *    indReg,
                                         unsigned *     cns);

    void                sched_AM        (instruction    ins,
                                         emitAttr       size,
                                         regNumber      ireg,
                                         bool           rdst,
                                         GenTreePtr     tree,
                                         unsigned       offs,
                                         bool           cons = false,
                                         int            cval = 0);

    void                inst_set_SV_var (GenTreePtr     tree);

#else

    void                sched_AM        (instruction    ins,
                                         var_types      type,
                                         regNumber      ireg,
                                         bool           rdst,
                                         GenTreePtr     tree,
                                         unsigned       offs);

    void                inst_TT_RV      (instruction    ins,
                                         GenTreePtr     tree,
                                         regNumber      reg,
                                         unsigned       offs = 0);

    void                inst_RV_TT      (instruction    ins,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0,
                                         emitAttr       size = EA_UNKNOWN);
#endif

#ifdef  DEBUG
    void    __cdecl     instDisp(instruction ins, bool noNL, const char *fmt, ...);
#endif

protected :


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           ScopeInfo                                       XX
XX                                                                           XX
XX  Keeps track of the scopes during code-generation.                        XX
XX  This is used to translate the local-variable debuggin information        XX
XX  from instr offsets to offsets into the generated native code.         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/
#ifdef DEBUGGING_SUPPORT
/*****************************************************************************
 *                              ScopeInfo
 *
 * This class is called during code gen at block-boundaries, and when the
 * set of live variables changes. It keeps track of the scope of the variables
 * in terms of the native code PC.
 */


public:

    void                siInit          ();

    void                siBeginBlock    ();

    void                siEndBlock      ();

    void                siUpdate        ();

    void                siCheckVarScope (unsigned varNum, IL_OFFSET offs);

    void                siNewScopeNear  (unsigned varNum, NATIVE_IP offs);

    void                siStackLevelChanged();

    void                siCloseAllOpenScopes();

#ifdef DEBUG
    void                siDispOpenScopes();
#endif


    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

    struct siScope
    {
        void *          scStartBlock;   // emitter block at start of scope
        unsigned        scStartBlkOffs; // offset within the emitter block

        void *          scEndBlock;     // emitter block at end of scope
        unsigned        scEndBlkOffs;   // offset within the emitter block

        unsigned        scVarNum;       // index into lclVarTab
        unsigned        scLVnum;        // 'which' in eeGetLVinfo() - @TODO [REVISIT] [04/16/01] []: Remove for IL

        unsigned        scStackLevel;   // Only for stk-vars
        bool            scAvailable :1; // It has a home / Home recycled

        siScope *       scPrev;
        siScope *       scNext;
    };

    siScope             siOpenScopeList,   siScopeList,
                      * siOpenScopeLast, * siScopeLast;

    unsigned            siScopeCnt;

    unsigned            siLastStackLevel;

    VARSET_TP           siLastLife;     // Life at last call to Update()

    // Tracks the last entry for each tracked register variable

    siScope *           siLatestTrackedScopes[lclMAX_TRACKED];

    unsigned short      siLastEndOffs;  // BC offset of the last block

    // Functions

    siScope *           siNewScope          (unsigned short LVnum,
                                             unsigned       varNum,
                                             bool           avail = true);

    void                siRemoveFromOpenScopeList(siScope * scope);

    void                siEndTrackedScope   (unsigned       varIndex);

    void                siEndScope          (unsigned       varNum);

    void                siEndScope          (siScope *      scope);

    static bool         siIgnoreBlock       (BasicBlock *);

    static void         siNewScopeCallback  (LocalVarDsc *  var,
                                             unsigned       clientData);

    static void         siEndScopeCallback  (LocalVarDsc *  var,
                                             unsigned       clientData);

    void                siBeginBlockSkipSome();

#ifdef DEBUG
    bool                siVerifyLocalVarTab ();
#endif



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          PrologScopeInfo                                  XX
XX                                                                           XX
XX We need special handling in the prolog block, as a the parameter variablesXX
XX may not be in the same position described by genLclVarTable - they all    XX
XX start out on the stack                                                    XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    void                psiBegProlog    ();

    void                psiAdjustStackLevel(unsigned size);

    void                psiMoveESPtoEBP ();

    void                psiMoveToReg    (unsigned   varNum,
                                         regNumber  reg      = REG_NA,
                                         regNumber  otherReg = REG_NA);

    void                psiMoveToStack  (unsigned   varNum);

    void                psiEndProlog    ();


    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

    struct  psiScope
    {
        void *          scStartBlock;   // emitter block at start of scope
        unsigned        scStartBlkOffs; // offset within the emitter block

        void *          scEndBlock;     // emitter block at end of scope
        unsigned        scEndBlkOffs;   // offset within the emitter block

        unsigned        scSlotNum;      // index into lclVarTab
        unsigned short  scLVnum;        // 'which' in eeGetLVinfo() - @TODO [REVISIT] [04/16/01] []: Remove for IL

        bool            scRegister;

        union
        {
            struct
            {
                regNumberSmall  scRegNum;
                regNumberSmall  scOtherReg; // used for "other half" of long var
            };

            struct
            {
                regNumberSmall  scBaseReg;
                NATIVE_OFFSET   scOffset;
            };
        };

        psiScope *      scPrev;
        psiScope *      scNext;
    };

    psiScope            psiOpenScopeList,   psiScopeList,
                      * psiOpenScopeLast, * psiScopeLast;

    unsigned            psiScopeCnt;

    // Implementation Functions

    psiScope *          psiNewPrologScope(unsigned          LVnum,
                                          unsigned          slotNum);

    void                psiEndPrologScope(psiScope *        scope);






/*****************************************************************************
 *                        TrnslLocalVarInfo
 *
 * This struct holds the LocalVarInfo in terms of the generated native code
 * after a call to genSetScopeInfo()
 */

#ifdef DEBUG


    struct TrnslLocalVarInfo
    {
        unsigned            tlviVarNum;
        unsigned            tlviLVnum;      // @TODO [REVISIT] [04/16/01] [] : Remove for IL
        lvdNAME             tlviName;
        NATIVE_IP           tlviStartPC;
        unsigned            tlviLength;
        bool                tlviAvailable;
        siVarLoc            tlviVarLoc;
    };


#endif // DEBUG


public :

#ifdef LATE_DISASM
    const char *        siRegVarName    (unsigned offs, unsigned size,
                                         unsigned reg);
    const char *        siStackVarName  (unsigned offs, unsigned size,
                                         unsigned reg,  unsigned stkOffs);
#endif

/*****************************************************************************/
#endif // DEBUGGING_SUPPORT
/*****************************************************************************/

#ifdef  DEBUG
    const char *        jitCurSource;       // file being compiled
#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           CodeGenerator                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    emitter *           getEmitter() { return genEmitter; }

#ifdef LATE_DISASM
    DisAssembler        genDisAsm;
#endif

    //-------------------------------------------------------------------------

    //  The following variable indicates whether the current method sets up
    //  an explicit stack frame or not. It is used by the scheduler if scheduling
    //  of pushes is enabled.
    bool                genFPused;

#if     TGT_RISC

    //  If we've assigned a variable to the FP register it won't be available
    //  for setting up a stack frame and the following will be set to true.
    bool                genFPcant;

    //  The following holds the distance between SP and FP if known - it is
    //  only meaningful when it's non-zero and 'genFPused' is true.
    unsigned            genFPtoSP;

#else

    //  The following variable indicates whether the current method is eligible
    //  to not set up an explicit stack frame.
    bool                genFPreqd;

#endif

    //-------------------------------------------------------------------------

#if TGT_RISC

    bool                genNonLeaf;         // routine makes calls

    size_t              genMaxCallArgs;     // max. arg bytes passed to callee

    regMaskTP           genEstRegUse;       // estimate of callee-saved reg use
    bool                genFixedArgBase;    // did we commit to an arg base?

#endif

    //-------------------------------------------------------------------------

    BasicBlock  *       genReturnBB;        // jumped to when not optimizing for speed.

#if TGT_RISC

    unsigned            genReturnCnt;       // number of returns in the method
    unsigned            genReturnLtm;       // number of returns not morphed

    GenTreePtr          genMonExitExp;      // exitCrit expression or NULL

#endif

#if TGT_x86
    unsigned            genTmpAccessCnt;    // # of access to temporary variables
#endif

#if DOUBLE_ALIGN
    bool                genDoubleAlign;
#endif

    //-------------------------------------------------------------------------

    VARSET_TP           genCodeCurLife;     // current  live non-FP variables
    VARSET_TP           genCodeCurRvm;      // current  live non-FP reg. vars

#if TGT_x86
    unsigned            genFPregCnt;        // count of current FP reg. vars (including dead but unpopped ones)
    VARSET_TP           genFPregVars;       // mask corresponding to genFPregCnt
    unsigned            genFPdeadRegCnt;    // The dead unpopped part of genFPregCnt
#endif

#ifdef DEBUG
    VARSET_TP           genTempOldLife;
    bool                genTempLiveChg;
#endif

#if TGT_x86

    //  Keeps track of how many bytes we've pushed on the processor's stack.
    //
    unsigned            genStackLevel;

    //  Keeps track of the current level of the FP coprocessor stack
    //  (excluding FP reg. vars).
    //
    unsigned            genFPstkLevel;

#endif

    //  The following will be set to true if we've determined that we need to
    //  generate a full-blown pointer register map for the current method.
    //  Currently it is equal to (genInterruptible || !genFPused)
    //  (i.e. We generate the full-blown map for EBP-less methods and
    //        for fully interruptible methods)
    //
    bool                genFullPtrRegMap;

    // The following is set to true if we've determined that the current method
    // is to be fully interruptible.
    //
    bool                genInterruptible;

#ifdef  DEBUG
    // The following is used to make sure the value of 'genInterruptible' isn't
    // changed after it's been used by any logic that depends on its value.
    bool                genIntrptibleUse;
#endif

    //-------------------------------------------------------------------------

                        // Changes lclVar nodes to refVar nodes if possible

    GenTreePtr          genMarkLclVar   (GenTreePtr     tree);

    bool                genCreateAddrMode(GenTreePtr    addr,
                                          int           mode,
                                          bool          fold,
                                          regMaskTP     regMask,
#if!LEA_AVAILABLE
                                          var_types     optp,
#endif
                                          bool        * revPtr,
                                          GenTreePtr  * rv1Ptr,
                                          GenTreePtr  * rv2Ptr,
#if SCALED_ADDR_MODES
                                          unsigned    * mulPtr,
#endif
                                          unsigned    * cnsPtr,
                                          bool          nogen = false);

    void                genGenerateCode  (void * *      codePtr,
                                          SIZE_T *      nativeSizeOfCode,
                                          void * *      consPtr,
                                          void * *      dataPtr,
                                          void * *      infoPtr);


    void                genInit         ();


#ifdef DEBUGGING_SUPPORT

    //  The following holds information about instr offsets in terms of generated code.

    struct IPmappingDsc
    {
        IPmappingDsc *      ipmdNext;       // next line# record

        IL_OFFSETX          ipmdILoffsx;    // the instr offset

        void         *      ipmdBlock;      // the block with the line
        unsigned            ipmdBlockOffs;  // the offset of  the line

        bool                ipmdIsLabel;    // Can this code be a branch label?
    };

    // Record the instr offset mapping to the genreated code

    IPmappingDsc *      genIPmappingList;
    IPmappingDsc *      genIPmappingLast;

#endif


    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

#ifdef DEBUG
    // Last instr we have displayed for dspInstrs
    unsigned            genCurDispOffset;
#endif

#ifdef  DEBUG
    static  const char *genInsName(instruction ins);
#endif

    //-------------------------------------------------------------------------
    //
    //  If we know that the flags register is set to a value that corresponds
    //  to the current value of a register or variable, the following values
    //  record that information.
    //

    void    *           genFlagsEqBlk;
    unsigned            genFlagsEqOfs;
    bool                genFlagsEqAll;
    regNumber           genFlagsEqReg;
    unsigned            genFlagsEqVar;

    void                genFlagsEqualToNone ();
    void                genFlagsEqualToReg  (GenTreePtr tree, regNumber reg, bool allFlags);
    void                genFlagsEqualToVar  (GenTreePtr tree, unsigned  var, bool allFlags);
    int                 genFlagsAreReg      (regNumber reg);
    int                 genFlagsAreVar      (unsigned  var);

    //-------------------------------------------------------------------------

#ifdef  DEBUG
    static
    const   char *      genSizeStr          (emitAttr       size);

    void                genStressRegs       (GenTreePtr     tree);
#endif

    //-------------------------------------------------------------------------

    void                genBashLclVar       (GenTreePtr     tree,
                                             unsigned       varNum,
                                             LclVarDsc *    varDsc);

    GenTreePtr          genMakeConst        (const void *   cnsAddr,
                                             size_t         cnsSize,
                                             var_types      cnsType,
                                             GenTreePtr     cnsTree,
                                             bool           dblAlign,
                                             bool           readOnly);

    bool                genRegTrashable     (regNumber      reg,
                                             GenTreePtr     tree);

    void                genSetRegToIcon     (regNumber      reg,
                                             long           val,
                                             var_types      type = TYP_INT);

    void                genIncRegBy         (regNumber      reg,
                                             long           ival,
                                             GenTreePtr     tree,
                                             var_types      dstType = TYP_INT,
                                             bool           ovfl    = false);

    void                genDecRegBy         (regNumber      reg,
                                             long           ival,
                                             GenTreePtr     tree);

    void                genMulRegBy         (regNumber      reg,
                                             long           ival,
                                             GenTreePtr     tree,
                                             var_types      dstType = TYP_INT,
                                             bool           ovfl    = false);

    void                genAdjustSP         (int            delta);

    void                genPrepForCompiler  ();

    void                genFnPrologCalleeRegArgs();

    size_t              genFnProlog         ();

    regNumber           genLclHeap          (GenTreePtr     size);

    void                genCodeForBBlist    ();

    BasicBlock *        genCreateTempLabel  ();

    void                genDefineTempLabel  (BasicBlock *   label,
                                             bool           inBlock);

    void                genOnStackLevelChanged();

    void                genSinglePush       (bool           isRef);

    void                genSinglePop        ();

    void                genChangeLife       (VARSET_TP      newLife
                                   DEBUGARG( GenTreePtr     tree));

    void                genDyingVars        (VARSET_TP      commonMask,
                                             GenTreePtr     opNext);

    void                genUpdateLife       (GenTreePtr     tree);

    void                genUpdateLife       (VARSET_TP      newLife);

    void                genComputeReg       (GenTreePtr     tree,
                                             regMaskTP      needReg,
                                             ExactReg       mustReg,
                                             KeepReg        keepReg,
                                             bool           freeOnly = false);

    void                genCompIntoFreeReg  (GenTreePtr     tree,
                                             regMaskTP      needReg,
                                             KeepReg        keepReg);

    void                genReleaseReg       (GenTreePtr     tree);

    void                genRecoverReg       (GenTreePtr     tree,
                                             regMaskTP      needReg,
                                             KeepReg        keepReg);

    void                genMoveRegPairHalf  (GenTreePtr     tree,
                                             regNumber      dst,
                                             regNumber      src,
                                             int            off = 0);

    void                genMoveRegPair      (GenTreePtr     tree,
                                             regMaskTP      needReg,
                                             regPairNo      newPair);

    void                genComputeRegPair   (GenTreePtr     tree,
                                             regPairNo      needRegPair,
                                             regMaskTP      avoidReg,
                                             KeepReg        keepReg,
                                             bool           freeOnly = false);

    void              genCompIntoFreeRegPair(GenTreePtr     tree,
                                             regMaskTP      avoidReg,
                                             KeepReg        keepReg);

    void               genComputeAddressable(GenTreePtr     tree,
                                             regMaskTP      addrReg,
                                             KeepReg        keptReg,
                                             regMaskTP      needReg,
                                             KeepReg        keepReg,
                                             bool           freeOnly = false);

    void                genReleaseRegPair   (GenTreePtr     tree);

    void                genRecoverRegPair   (GenTreePtr     tree,
                                             regPairNo      regPair,
                                             KeepReg        keepReg);

    void              genEvalIntoFreeRegPair(GenTreePtr     tree,
                                             regPairNo      regPair);

    void             genMakeRegPairAvailable(regPairNo regPair);
    
    void                genRangeCheck       (GenTreePtr     oper,
                                             GenTreePtr     rv1,
                                             GenTreePtr     rv2,
                                             long           ixv,
                                             regMaskTP      regMask,
                                             KeepReg        keptReg);

#if TGT_RISC

    /* The following is filled in by genMakeIndAddrMode/genMakeAddressable */

    addrModes           genAddressMode;

#endif

    bool                genMakeIndAddrMode  (GenTreePtr     addr,
                                             GenTreePtr     oper,
                                             bool           forLea,
                                             regMaskTP      regMask,
                                             KeepReg        keepReg,
                                             regMaskTP *    useMaskPtr,
                                             bool           deferOp = false);

    regMaskTP           genMakeRvalueAddressable(GenTreePtr tree,
                                             regMaskTP      needReg,
                                             KeepReg        keepReg,
                                             bool           smallOK = false);

    regMaskTP           genMakeAddressable  (GenTreePtr     tree,
                                             regMaskTP      needReg,
                                             KeepReg        keepReg,
                                             bool           smallOK = false,
                                             bool           deferOK = false);

    regMaskTP           genMakeAddrArrElem  (GenTreePtr     arrElem,
                                             GenTreePtr     tree,
                                             regMaskTP      needReg,
                                             KeepReg        keepReg);

    regMaskTP           genMakeAddressable2 (GenTreePtr     tree,
                                             regMaskTP      needReg,
                                             KeepReg        keepReg,
                                             bool           smallOK = false,
                                             bool           deferOK = false,
                                             bool           evalSideEffs = false,
                                             bool           evalConsts = false);

    bool                genStillAddressable (GenTreePtr     tree);

#if TGT_RISC

    regMaskTP           genNeedAddressable  (GenTreePtr     tree,
                                             regMaskTP      addrReg,
                                             regMaskTP      needReg);

    bool                genDeferAddressable (GenTreePtr     tree);

#endif

    regMaskTP           genRestoreAddrMode  (GenTreePtr     addr,
                                             GenTreePtr     tree,
                                             bool           lockPhase);

    regMaskTP           genRestAddressable  (GenTreePtr     tree,
                                             regMaskTP      addrReg,
                                             regMaskTP      lockMask);

    regMaskTP           genKeepAddressable  (GenTreePtr     tree,
                                             regMaskTP      addrReg,
                                             regMaskTP      avoidMask = RBM_NONE);

    void                genDoneAddressable  (GenTreePtr     tree,
                                             regMaskTP      addrReg,
                                             KeepReg        keptReg);

    GenTreePtr          genMakeAddrOrFPstk  (GenTreePtr     tree,
                                             regMaskTP *    regMaskPtr,
                                             bool           roundResult);

    void                genExitCode         (bool           endFN);

    void                genFnEpilog         ();

    void                genEvalSideEffects  (GenTreePtr     tree);

#if TGT_x86

    TempDsc  *          genSpillFPtos       (var_types      type);

    TempDsc  *          genSpillFPtos       (GenTreePtr     oper);

    void                genReloadFPtos      (TempDsc *      temp,
                                             instruction    ins);

#endif

    void                genCondJump         (GenTreePtr     cond,
                                             BasicBlock *   destTrue  = NULL,
                                             BasicBlock *   destFalse = NULL);


#if TGT_x86

    emitJumpKind        genCondSetFlags     (GenTreePtr     cond);

#else

    bool                genCondSetTflag     (GenTreePtr     cond,
                                             bool           trueOnly);

    void                genCompareRegIcon   (regNumber      reg,
                                             int            val,
                                             bool           uns,
                                             genTreeOps     cmp);

#endif

#if TGT_x86
    
    void                genFPregVarLoad     (GenTreePtr     tree);
    void                genFPregVarLoadLast (GenTreePtr     tree);
    void                genFPmovRegTop      ();
    void                genFPmovRegBottom   ();
#endif

    void                genFPregVarBirth    (GenTreePtr     tree);
    void                genFPregVarDeath    (GenTreePtr     tree,
                                             bool           popped = true);

    void                genChkFPregVarDeath (GenTreePtr     stmt,
                                             bool           saveTOS);

    void                genFPregVarKill     (unsigned       newCnt,
                                             bool           saveTOS = false);

    void                genJCC              (genTreeOps     cmp,
                                             BasicBlock *   block,
                                             var_types      type);

    void                genJccLongHi        (genTreeOps     cmp,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse,
                                             bool           unsOper = false);

    void                genJccLongLo        (genTreeOps     cmp,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse);

    void                genCondJumpLng      (GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse);

    void                genCondJumpFlt      (GenTreePtr      cond,
                                             BasicBlock *    jumpTrue,
                                             BasicBlock *    jumpFalse);

    bool                genUse_fcomip();
    bool                gen_fcomp_FN(unsigned stk);
    bool                gen_fcomp_FS_TT(GenTreePtr addr, bool *reverseJumpKind);
    bool                gen_fcompp_FS();

    void                genTableSwitch      (regNumber      reg,
                                             unsigned       jumpCnt,
                                             BasicBlock **  jumpTab,
                                             bool           chkHi,
                                             int            prefCnt = 0,
                                             BasicBlock *   prefLab = NULL,
                                             int            offset  = 0);

    regMaskTP           WriteBarrier        (GenTreePtr     tree,
                                             regNumber      reg,
                                             regMaskTP      addrReg);


    bool                genCanSchedJMP2THROW();

    void                genCheckOverflow    (GenTreePtr     tree,
                                             regNumber      reg     = REG_NA);

    void                genCodeForTreeConst (GenTreePtr     tree,
                                             regMaskTP      destReg,
                                             regMaskTP      bestReg = RBM_NONE);
    
    void                genCodeForTreeLeaf  (GenTreePtr     tree,
                                             regMaskTP      destReg,
                                             regMaskTP      bestReg = RBM_NONE);

    void                genCodeForTreeLeaf_GT_JMP (GenTreePtr     tree);
    
    void                genCodeForQmark     (GenTreePtr tree,
                                             regMaskTP  destReg,
                                             regMaskTP  bestReg);

    bool                genCodeForQmarkWithCMOV (GenTreePtr tree,
                                                 regMaskTP  destReg,
                                                 regMaskTP  bestReg);

    void                genCodeForTreeSmpOp (GenTreePtr     tree,
                                             regMaskTP      destReg,
                                             regMaskTP      bestReg = RBM_NONE);

    void                genCodeForTreeSmpOp_GT_ADDR (GenTreePtr     tree,
                                                     regMaskTP      destReg,
                                                     regMaskTP      bestReg = RBM_NONE);

    void                genCodeForTreeSmpOpAsg (GenTreePtr     tree,
                                                regMaskTP      destReg,
                                                regMaskTP      bestReg = RBM_NONE);
    
    void                genCodeForTree_GT_LOG  (GenTreePtr     tree,
                                                regMaskTP      destReg,
                                                regMaskTP      bestReg = RBM_NONE);
    
    void                genCodeForTreeSmpOpAsg_DONE_ASSG(GenTreePtr tree,
                                                         regMaskTP  addrReg,
                                                         regNumber  reg,
                                                         bool       ovfl);
    
    void                genCodeForTreeSpecialOp (GenTreePtr     tree,
                                                 regMaskTP      destReg,
                                                 regMaskTP      bestReg = RBM_NONE);
    
    void                genCodeForTree      (GenTreePtr     tree,
                                             regMaskTP      destReg,
                                             regMaskTP      bestReg = RBM_NONE);

    void                genCodeForTree_DONE_LIFE (GenTreePtr     tree,
                                                  regNumber      reg)
    {
        /* We've computed the value of 'tree' into 'reg' */

        assert(reg != 0xFEEFFAAF);

        tree->gtFlags   |= GTF_REG_VAL;
        tree->gtRegNum   = reg;
    }

    void                genCodeForTree_DONE (GenTreePtr     tree,
                                             regNumber      reg)
    {
        /* Check whether this subtree has freed up any variables */

        genUpdateLife(tree);

        genCodeForTree_DONE_LIFE(tree, reg);
    }

    void                genCodeForTree_REG_VAR1 (GenTreePtr     tree,
                                                 regMaskTP      regs)
    {
        /* Value is already in a register */

        regNumber reg   = tree->gtRegNum;
        regs |= genRegMask(reg);

        gcMarkRegPtrVal(reg, tree->TypeGet());

        genCodeForTree_DONE(tree, reg);
    }

    void                genCodeForTreeLng   (GenTreePtr     tree,
                                             regMaskTP      needReg);

    regPairNo           genCodeForLongModInt(GenTreePtr     tree,
                                             regMaskTP      needReg);


#if CPU_HAS_FP_SUPPORT
#if ROUND_FLOAT
    void                genRoundFpExpression(GenTreePtr     op,
                                             var_types      type = TYP_UNDEF);

    void                genCodeForTreeFlt   (GenTreePtr     tree,
                                             bool           roundResult);
#else
    void                genCodeForTreeFlt   (GenTreePtr     tree);
#define                 genCodeForTreeFlt(tree, round)  genCodeForTreeFlt(tree)
#endif
#endif

#if TGT_RISC
    void                genCallInst         (gtCallTypes    callType,
                                             void   *       callHand,
                                             size_t         argSize,
                                             int            retSize);
#endif

    void                genCodeForSwitch    (GenTreePtr     tree);

    void                genFltArgPass       (size_t     *   argSzPtr);

    size_t              genPushArgList      (GenTreePtr     args,
                                             GenTreePtr     regArgs,
                                             unsigned       encodeMask,
                                             GenTreePtr *   realThis);

#if INLINE_NDIRECT

    regMaskTP           genPInvokeMethodProlog(regMaskTP    initRegs);
    void                genPInvokeMethodEpilog();

    regNumber           genPInvokeCallProlog(LclVarDsc *    varDsc,
                                             int            argSize,
                                      CORINFO_METHOD_HANDLE methodToken,
                                             BasicBlock *   returnLabel,
                                             regMaskTP      freeRegMask);

    void                genPInvokeCallEpilog(LclVarDsc *    varDsc,
                                             regMaskTP      retVal);
#endif

    regMaskTP           genCodeForCall      (GenTreePtr     call,
                                             bool           valUsed);

    void                genEmitHelperCall   (unsigned       helper,
                                             int            argSize,
                                             int            retSize);

    void                genJumpToThrowHlpBlk(emitJumpKind   jumpKind,
                                             addCodeKind    codeKind,
                                             GenTreePtr     failBlk = NULL);

#if CSELENGTH

    regNumber           genEvalCSELength    (GenTreePtr     ind,
                                             GenTreePtr     adr,
                                             GenTreePtr     ixv);

    regMaskTP           genCSEevalRegs      (GenTreePtr     tree);

#endif

    GenTreePtr          genIsAddrMode       (GenTreePtr     tree,
                                             GenTreePtr *   indxPtr);

    bool                genIsLocalLastUse   (GenTreePtr     tree);

    //=========================================================================
    //  Debugging support
    //=========================================================================

#ifdef DEBUGGING_SUPPORT

    void                genIPmappingAdd       (IL_OFFSETX   offset,
                                               bool         isLabel);
    void                genIPmappingAddToFront(IL_OFFSETX   offset);
    void                genIPmappingGen       ();

    void                genEnsureCodeEmitted  (IL_OFFSETX   offsx);

    //-------------------------------------------------------------------------
    // scope info for the variables

    void                genSetScopeInfo (unsigned           which,
                                         unsigned           startOffs,
                                         unsigned           length,
                                         unsigned           varNum,
                                         unsigned           LVnum,
                                         bool               avail,
                                         siVarLoc &         loc);

    void                genSetScopeInfo ();

    // Array of scopes of LocalVars in terms of native code

#ifdef DEBUG
    TrnslLocalVarInfo *     genTrnslLocalVarInfo;
    unsigned                genTrnslLocalVarCount;
#endif

#endif //DEBUGGING_SUPPORT



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Compiler                                        XX
XX                                                                           XX
XX   Generic info about the compilation and the method being compiled.       XX
XX   It is resposible for driving the other phases.                          XX
XX   It is also responsible for all the memory management.                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    bool                compJmpOpUsed;      // Does the method do a JMP or JMPI
    bool                compBlkOpUsed;      // Does the method do a COPYBLK or INITBLK
    bool                compLongUsed;       // Does the method use 64-bit integer
    bool                compTailCallUsed;   // Does the method do a tailcall
    bool                compLocallocUsed;   // Does the method use localloc

    //---------------------------- JITing options -----------------------------

    enum    codeOptimize
    {
        BLENDED_CODE,
        SMALL_CODE,
        FAST_CODE,

        COUNT_OPT_CODE
    };

    struct Options
    {
        unsigned            eeFlags;        // flags passed from the EE
        unsigned            compFlags;

        codeOptimize        compCodeOpt;    // what type of code optimizations

        bool                compUseFCOMI;
        bool                compUseCMOV;

        // optimize maximally and/or favor speed over size?

#if   ALLOW_MIN_OPT
        bool                compMinOptim;
#else
        static const bool   compMinOptim;
#endif

#if     SCHEDULER
        bool                compSchedCode;
#endif

#ifdef DEBUGGING_SUPPORT
        bool                compScopeInfo;  // Generate the LocalVar info ?
        bool                compDbgCode;    // Generate debugger-friendly code?
        bool                compDbgInfo;    // Gather debugging info?
        bool                compDbgEnC;
#else
        static const bool   compDbgCode;
#endif

#ifdef PROFILER_SUPPORT
        bool                compEnterLeaveEventCB;
        bool                compCallEventCB;
        bool                compNoPInvokeInlineCB;
        bool                compInprocDebuggerActiveCB;
#else
        static const bool   compEnterLeaveEventCB;
        static const bool   compCallEventCB;
        static const bool   compNoPInvokeInlineCB;
        static const bool   compInprocDebuggerActiveCB;
#endif

#ifdef DEBUG
        bool                compGcChecks;           // Check arguments and return values to insure they are sane 
        bool                compStackCheckOnRet;    // Check ESP on return to insure it is correct
        bool                compStackCheckOnCall;   // Check ESP after every call to insure it is correct 
#endif

#ifdef LATE_DISASM
        bool                compDisAsm;
        bool                compLateDisAsm;
#endif

        bool                compNeedSecurityCheck; // need to allocate a "hidden" local of type ref.

#if     RELOC_SUPPORT
        bool                compReloc;
#endif
    }
        opts;


    enum                compStressArea
    {
        STRESS_NONE,

        /* "Variations" stress areas which we try to mix up with each other.
            These should not be exhaustively used as they might
            hide/trivialize other areas */

        STRESS_REGS, STRESS_DBL_ALN, STRESS_LCL_FLDS, STRESS_UNROLL_LOOPS,
        STRESS_MAKE_CSE, STRESS_ENREG_FP, STRESS_INLINE, STRESS_CLONE_EXPR,
        STRESS_SCHED, STRESS_USE_FCOMI, STRESS_USE_CMOV, STRESS_FOLD,
        STRESS_GENERIC_VARN,
        STRESS_REVERSEFLAG,     // Will set GTF_REVERSE_OPS whenever we can
        STRESS_REVERSECOMMA,    // Will reverse commas created  with gtNewCommaNode
        STRESS_COUNT_VARN,
        
        /* "Check" stress areas that can be exhaustively used if we
           dont care about performance at all */

        STRESS_CHK_FLOW_UPDATE, STRESS_CHK_FLOW, STRESS_CHK_STMTS,
        STRESS_EMITTER, STRESS_CHK_REIMPORT,
        STRESS_GENERIC_CHECK,
        STRESS_COUNT
    };

    #define             MAX_STRESS_WEIGHT   100

    bool                compStressCompile(compStressArea    stressArea,
                                          unsigned          weightPercentage);

    codeOptimize        compCodeOpt()
    {
#ifdef DEBUG
        return opts.compCodeOpt;
#else
        return BLENDED_CODE;
#endif
    }
    
    //--------------------- Info about the procedure --------------------------

    struct Info
    {
        COMP_HANDLE             compCompHnd;
        CORINFO_MODULE_HANDLE   compScopeHnd;
        CORINFO_CLASS_HANDLE    compClassHnd;
        CORINFO_METHOD_HANDLE   compMethodHnd;
        CORINFO_METHOD_INFO*    compMethodInfo;

#ifdef  DEBUG
        const   char *  compMethodName;
        const   char *  compClassName;
        const   char *  compFullName;
        unsigned        compFullNameHash;
#endif

        // The following holds the FLG_xxxx flags for the method we're compiling.
        unsigned        compFlags;

        // The following holds the class attributes for the method we're compiling.
        unsigned        compClassAttr;

        const BYTE *    compCode;
        IL_OFFSET       compCodeSize;
        bool            compIsStatic        : 1;
        bool            compIsVarArgs       : 1;
        bool            compIsContextful    : 1;   // contextful method
        bool            compInitMem         : 1;
        bool            compLooseExceptions : 1;   // JIT can ignore strict IL-ordering of exception
        bool            compUnwrapContextful: 1;   // JIT should unwrap proxies when possible
        bool            compUnwrapCallv     : 1;   // JIT should unwrap proxies on virtual calls when possible

        var_types       compRetType;
        unsigned        compILargsCount;            // Number of arguments (incl. implicit but not hidden)
        unsigned        compArgsCount;              // Number of arguments (incl. implicit and     hidden)
        int             compRetBuffArg;             // position of hidden return param var (0, 1) (neg means not present);
        unsigned        compILlocalsCount;          // Number of vars - args + locals (incl. implicit but not hidden)
        unsigned        compLocalsCount;            // Number of vars - args + locals (incl. implicit and     hidden)
        unsigned        compMaxStack;

        static unsigned compNStructIndirOffset;     // offset of real ptr in NStruct proxy object

#if INLINE_NDIRECT
        unsigned        compCallUnmanaged;
        unsigned        compLvFrameListRoot;
        unsigned        compNDFrameOffset;
#endif
        unsigned        compXcptnsCount;        // number of exceptions

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)

        /*  The following holds information about local variables.
         */

        unsigned                compLocalVarsCount;
        LocalVarDsc *           compLocalVars;

        /* The following holds information about instr offsets for
         * which we need to report IP-mappings
         */

        IL_OFFSET   *           compStmtOffsets;        // sorted
        unsigned                compStmtOffsetsCount;
        ImplicitStmtOffsets     compStmtOffsetsImplicit;

        //  The following holds the line# tables, if present.
        srcLineDsc  *           compLineNumTab;         // sorted by offset
        unsigned                compLineNumCount;

#endif // DEBUGGING_SUPPORT || DEBUG

    }
        info;


    //-------------------------- Global Compiler Data ------------------------------------

#ifdef  DEBUG
    static unsigned     s_compMethodsCount;     // to produce unique label names
#endif

    BasicBlock  *       compCurBB;              // the current basic block in process
    GenTreePtr          compCurStmt;            // the current statement in process
    bool                compHasThisArg;         // Set to true if we have impIsThis(arg0)

    //  The following is used to create the 'method JIT info' block.
    size_t              compInfoBlkSize;
    BYTE    *           compInfoBlkAddr;

    EHblkDsc *          compHndBBtab;

    //-------------------------------------------------------------------------
    //  The following keeps track of how many bytes of local frame space we've
    //  grabbed so far in the current function, and how many argument bytes we
    //  need to pop when we return.
    //

    size_t              compLclFrameSize;       // secObject+lclBlk+locals+temps
    unsigned            compCalleeRegsPushed;   // count of callee-saved regs we pushed in the prolog
    size_t              compArgSize;

#define    VARG_ILNUM  (-1)
#define  RETBUF_ILNUM  (-2)
#define UNKNOWN_ILNUM  (-3)

    unsigned            compMapILargNum (unsigned       ILargNum); // map accounting for hidden args
    unsigned            compMapILvarNum (unsigned       ILvarNum); // map accounting for hidden args
    unsigned            compMap2ILvarNum(unsigned         varNum); // map accounting for hidden args

    //-------------------------------------------------------------------------

    static void         compStartup     ();     // One-time initialization
    static void         compShutdown    ();     // One-time finalization

    void                compInit        (norls_allocator *);
    void                compDone        ();

    int FASTCALL        compCompile     (CORINFO_METHOD_HANDLE     methodHnd,
                                         CORINFO_MODULE_HANDLE      classPtr,
                                         COMP_HANDLE       compHnd,
                                         CORINFO_METHOD_INFO * methodInfo,
                                         void *          * methodCodePtr,
                                         SIZE_T          * methodCodeSize,
                                         void *          * methodConsPtr,
                                         void *          * methodDataPtr,
                                         void *          * methodInfoPtr,
                                         unsigned          compileFlags);


    void  *  FASTCALL   compGetMemArray     (size_t numElem, size_t elemSize);
    void  *  FASTCALL   compGetMemArrayA    (size_t numElem, size_t elemSize);
    void  *  FASTCALL   compGetMem          (size_t     sz);
    void  *  FASTCALL   compGetMemA         (size_t     sz);
    static
    void  *  FASTCALL   compGetMemCallback  (void *,    size_t);
    void                compFreeMem         (void *);

#ifdef DEBUG
    LocalVarDsc *       compFindLocalVar    (unsigned   varNum,
                                             unsigned   lifeBeg = 0,
                                             unsigned   lifeEnd = UINT_MAX);
    const   char *      compLocalVarName    (unsigned   varNum, unsigned offs);
    lvdNAME             compRegVarNAME      (regNumber  reg,
                                             bool       fpReg = false);
    const   char *      compRegVarName      (regNumber  reg,
                                             bool       displayVar = false);
#if TGT_x86
    const   char *      compRegPairName     (regPairNo  regPair);
    const   char *      compRegNameForSize  (regNumber  reg,
                                             size_t     size);
    const   char *      compFPregVarName    (unsigned   fpReg,
                                             bool       displayVar = false);
#endif

    void                compDspSrcLinesByNativeIP   (NATIVE_IP      curIP);
    void                compDspSrcLinesByILoffs     (IL_OFFSET      curOffs);
    void                compDspSrcLinesByLineNum    (unsigned       line,
                                                     bool           seek = false);

    unsigned            compFindNearestLine (unsigned lineNo);
    const char *        compGetSrcFileName  ();

#endif

    unsigned            compLineNumForILoffs(IL_OFFSET  offset);

    //-------------------------------------------------------------------------

#ifdef DEBUGGING_SUPPORT

    LocalVarDsc **      compEnterScopeList;  // List has the offsets where variables
                                            // enter scope, sorted by instr offset
    unsigned            compNextEnterScope;

    LocalVarDsc **      compExitScopeList;   // List has the offsets where variables
                                            // go out of scope, sorted by instr offset
    unsigned            compNextExitScope;


    void                compInitScopeLists      ();

    void                compResetScopeLists     ();

    LocalVarDsc *       compGetNextEnterScope   (unsigned offs, bool scan=false);

    LocalVarDsc *       compGetNextExitScope    (unsigned offs, bool scan=false);

    void                compProcessScopesUntil  (unsigned     offset,
                               void (*enterScopeFn)(LocalVarDsc *, unsigned),
                               void (*exitScopeFn) (LocalVarDsc *, unsigned),
                               unsigned     clientData);

#endif // DEBUGGING_SUPPORT


    //-------------------------------------------------------------------------
    /*               Statistical Data Gathering                               */

    void                compJitStats();             // call this function and enable
                                                    // various ifdef's below for statiscal data

#if CALL_ARG_STATS
    void                compCallArgStats();
    static void         compDispCallArgStats();
#endif


    //-------------------------------------------------------------------------

protected :

    norls_allocator *   compAllocator;

    void                compInitOptions (unsigned compileFlags);

    void                compInitDebuggingInfo();

    void                compCompile  (void * * methodCodePtr,
                                      SIZE_T * methodCodeSize,
                                      void * * methodConsPtr,
                                      void * * methodDataPtr,
                                      void * * methodInfoPtr,
                                      unsigned compileFlags);

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           typeInfo                                        XX
XX                                                                           XX
XX   Checks for type compatibility and merges types                          XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    // Set to TRUE if verification cannot be skipped for this method
    BOOL               tiVerificationNeeded;

    // Returns TRUE if child is equal to or a subtype of parent.
    BOOL               tiCompatibleWith          (const typeInfo& pChild, 
                                                  const typeInfo& pParent) const;

    // Merges pDest and pSrc. Returns FALSE if merge is undefined.
    // *pDest is modified to represent the merged type.

    BOOL               tiMergeToCommonParent     (typeInfo *pDest, 
                                                    const typeInfo *pSrc) const;

    // Set pDest from the primitive value type.
    // Eg. System.Int32 -> ELEMENT_TYPE_I4

    BOOL               tiFromPrimitiveValueClass (typeInfo *pDest, 
                                                    const typeInfo *pVC) const;
/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           IL verification stuff                           XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public:
    // The following is used to track liveness of local variables, initialization 
    // of valueclass constructors, and type safe use of IL instructions. 
 
    // dynamic state info needed for verification 
    EntryState      verCurrentState;      

    // static state info used for verification
    unsigned        verNumBytesLocVarLiveness;              // size of verLocVarLiveness bitmap
    unsigned        verNumValuetypeFields;                  // 0, if not a valueclass constructor
    unsigned        verNumBytesValuetypeFieldInitialized;   // size of verValuetypeFieldInitialized

    // this ptr of object type .ctors are considered intited only after
    // the base class ctor is called, or an alternate ctor is called.
    // An uninited this ptr can be used to access fields, but cannot
    // be used to call a member function.
    BOOL            verTrackObjCtorInitState;

    void            verInitBBEntryState(BasicBlock* block,
                                        EntryState* currentState);

    void            verSetThisInit(BasicBlock* block, BOOL init);
    void            verInitCurrentState();
    void            verResetCurrentState(BasicBlock* block,
                                         EntryState* currentState);
    BOOL            verEntryStateMatches(BasicBlock* block);
    BOOL            verMergeEntryStates(BasicBlock* block);
    void            verConvertBBToThrowVerificationException(BasicBlock* block DEBUGARG(bool logMsg));
    void            verHandleVerificationFailure(BasicBlock* block 
                                                 DEBUGARG(bool logMsg));
    typeInfo        verMakeTypeInfo(CORINFO_CLASS_HANDLE clsHnd);                       // converts from jit type representation to typeInfo
    typeInfo        verMakeTypeInfo(CorInfoType ciType, CORINFO_CLASS_HANDLE clsHnd);   // converts from jit type representation to typeInfo
    BOOL            verIsSDArray(typeInfo ti);
    typeInfo        verGetArrayElemType(typeInfo ti);

    typeInfo        verParseArgSigToTypeInfo(CORINFO_SIG_INFO*          sig, 
                                             CORINFO_ARG_LIST_HANDLE    args);
    BOOL            verNeedsVerification();
    BOOL            verIsByRefLike(const typeInfo& ti);

    void            verRaiseVerifyException();
    void            verRaiseVerifyExceptionIfNeeded(INDEBUG(const char* reason) DEBUGARG(const char* file) DEBUGARG(unsigned line));
    void            verVerifyCall (OPCODE       opcode,
                                   int          memberRef,
                                   bool                     tailCall,
                                   const BYTE*              delegateCreateStart,
                                   const BYTE*              codeAddr
                                   DEBUGARG(const char *    methodName));
    BOOL            verCheckDelegateCreation(const BYTE* delegateCreateStart, 
                                             const BYTE* codeAddr);
    typeInfo        verVerifySTIND(const typeInfo& ptr, const typeInfo& value, var_types instrType);
    typeInfo        verVerifyLDIND(const typeInfo& ptr, var_types instrType);
    typeInfo        verVerifyField(unsigned opcode, CORINFO_FIELD_HANDLE fldHnd, typeInfo tiField);
    void            verVerifyField(CORINFO_FIELD_HANDLE fldHnd, const typeInfo* tiThis, unsigned fieldFlags, BOOL mutator);
    void            verVerifyCond(const typeInfo& tiOp1, const typeInfo& tiOp2, unsigned opcode);
    void            verVerifyThisPtrInitialised();
    BOOL            verIsCallToInitThisPtr(CORINFO_CLASS_HANDLE context, 
                                           CORINFO_CLASS_HANDLE target);
};



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                   Miscellaneous Compiler stuff                            XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

// Values used to mark the types a stack slot is used for

const unsigned TYPE_REF_INT         = 0x01; // slot used as a 32-bit int
const unsigned TYPE_REF_LNG         = 0x02; // slot used as a 64-bit long
const unsigned TYPE_REF_FLT         = 0x04; // slot used as a 32-bit float
const unsigned TYPE_REF_DBL         = 0x08; // slot used as a 64-bit float
const unsigned TYPE_REF_PTR         = 0x10; // slot used as a 32-bit pointer
const unsigned TYPE_REF_BYR         = 0x20; // slot used as a byref pointer - @TODO [REVISIT] [04/16/01] []
const unsigned TYPE_REF_STC         = 0x40; // slot used as a struct
const unsigned TYPE_REF_TYPEMASK    = 0x7F; // bits that represent the type

//const unsigned TYPE_REF_ADDR_TAKEN  = 0x80; // slots address was taken

/*****************************************************************************
 * C-style pointers are implemented as TYP_INT or TYP_LONG depending on the
 * platform
 */

#ifdef _WIN64
#define TYP_I_IMPL          TYP_LONG
#define TYPE_REF_IIM        TYPE_REF_LNG
#else
#define TYP_I_IMPL          TYP_INT
#define TYPE_REF_IIM        TYPE_REF_INT
#endif

/*****************************************************************************
 *
 *  Variables to keep track of total code amounts.
 */

#if DISPLAY_SIZES

extern  unsigned    grossVMsize;
extern  unsigned    grossNCsize;
extern  unsigned    totalNCsize;

extern  unsigned   genMethodICnt;
extern  unsigned   genMethodNCnt;
extern  unsigned   gcHeaderISize;
extern  unsigned   gcPtrMapISize;
extern  unsigned   gcHeaderNSize;
extern  unsigned   gcPtrMapNSize;

#endif

/*****************************************************************************
 *
 *  Variables to keep track of basic block counts (more data on 1 BB methods)
 */

#if COUNT_BASIC_BLOCKS
extern  histo       bbCntTable;
extern  histo       bbOneBBSizeTable;
#endif

/*****************************************************************************
 *
 *  Variables to get inliner eligibility stats
 */

#if INLINER_STATS

extern  histo       bbStaticTable;
extern  histo       bbInitTable;
extern  histo       bbInlineTable;

extern  unsigned    synchMethCnt;
extern  unsigned    clinitMethCnt;

#endif

/*****************************************************************************
 *
 *  Used by optFindNaturalLoops to gather statistical information such as
 *   - total number of natural loops
 *   - number of loops with 1, 2, ... exit conditions
 *   - number of loops that have an iterator (for like)
 *   - number of loops that have a constant iterator
 */

#if COUNT_LOOPS

extern unsigned    totalLoopMethods;      // counts the total number of methods that have natural loops
extern unsigned    maxLoopsPerMethod;     // counts the maximum number of loops a method has
extern unsigned    totalLoopCount;        // counts the total number of natural loops
extern unsigned    exitLoopCond[8];       // counts the # of loops with 0,1,2,..6 or more than 6 exit conditions
extern unsigned    iterLoopCount;         // counts the # of loops with an iterator (for like)
extern unsigned    simpleTestLoopCount;   // counts the # of loops with an iterator and a simple loop condition (iter < const)
extern unsigned    constIterLoopCount;    // counts the # of loops with a constant iterator (for like)

extern bool        hasMethodLoops;        // flag to keep track if we already counted a method as having loops
extern unsigned    loopsThisMethod;       // counts the number of loops in the current method

#endif

/*****************************************************************************
 * variables to keep track of how many iterations we go in a dataflow pass
 */

#if DATAFLOW_ITER

extern unsigned    CSEiterCount;           // counts the # of iteration for the CSE dataflow
extern unsigned    CFiterCount;            // counts the # of iteration for the Const Folding dataflow

#endif

/*****************************************************************************
 *
 *  Used in the new DFA to catch dead assignments which are not removed
 *  because they contain calls
 */

#if COUNT_DEAD_CALLS

extern unsigned    deadHelperCount;           // counts the # of dead helper calls
extern unsigned    deadCallCount;             // counts the # of dead standard calls (like i=f(); where i is dead)
extern unsigned    removedCallCount;          // counts the # of dead standard calls that we removed

#endif

#if     MEASURE_BLOCK_SIZE
extern  size_t      genFlowNodeSize;
extern  size_t      genFlowNodeCnt;
#endif

/*****************************************************************************/
/*****************************************************************************/



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                        get                                                XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/
/*****************************************************************************/


#include "Compiler.hpp"     // All the shared inline functions

/*****************************************************************************/
#endif //_COMPILER_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\compiler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          Compiler                                         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#include "jitpch.h"
#pragma hdrstop
#include "emit.h"

#ifdef  UNDER_CE_GUI
#include "test.h"
#else
#include <time.h>
#endif

/*****************************************************************************/

#ifdef  DEBUG
static  double      CGknob = 0.1;
#endif


/*****************************************************************************/

#if TOTAL_CYCLES
static
unsigned            jitTotalCycles;
#endif

/*****************************************************************************/

inline
unsigned            getCurTime()
{
    SYSTEMTIME      tim;

    GetSystemTime(&tim);

    return  (((tim.wHour*60) + tim.wMinute)*60 + tim.wSecond)*1000 + tim.wMilliseconds;
}

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************/

const   char *      jitExeFileName;

const   char *      jitSrcFileName;

static
FILE    *           jitSrcFilePtr;

static
unsigned            jitCurSrcLine;

const char*         Compiler::compGetSrcFileName()
{
    return  jitSrcFileName;
}

void                Compiler::compDspSrcLinesByLineNum(unsigned line, bool seek)
{
    if  (!jitSrcFilePtr)
        return;

    if  (jitCurSrcLine == line)
        return;

    if  (jitCurSrcLine >  line)
    {
        if  (!seek)
            return;

        if (fseek(jitSrcFilePtr, 0, SEEK_SET) != 0)
        {
            printf("Compiler::compDspSrcLinesByLineNum:  fseek returned an error.\n");
        }
        jitCurSrcLine = 0;
    }

    if  (!seek)
        printf(";\n");

    do
    {
        char            temp[128];
        size_t          llen;

        if  (!fgets(temp, sizeof(temp), jitSrcFilePtr))
            return;

        if  (seek)
            continue;

        llen = strlen(temp);
        if  (llen && temp[llen-1] == '\n')
            temp[llen-1] = 0;

        printf(";   %s\n", temp);
    }
    while (++jitCurSrcLine < line);

    if  (!seek)
        printf(";\n");
}


/*****************************************************************************
 *
 * Given the starting line number of a method, this tries to back up a bit
 * to the end of the previous method
 */

unsigned            Compiler::compFindNearestLine(unsigned lineNo)
{
    if (lineNo < 6 )
        return 0;
    else
        return lineNo - 6;
}

/*****************************************************************************/

void        Compiler::compDspSrcLinesByNativeIP(NATIVE_IP curIP)
{
#ifdef DEBUGGING_SUPPORT

    static IPmappingDsc *   nextMappingDsc;
    static unsigned         lastLine;

    if (!dspLines)
        return;

    if (curIP==0)
    {
        if (genIPmappingList)
        {
            nextMappingDsc          = genIPmappingList;
            lastLine                = jitGetILoffs(nextMappingDsc->ipmdILoffsx);

            unsigned firstLine      = jitGetILoffs(nextMappingDsc->ipmdILoffsx);

            unsigned earlierLine    = (firstLine < 5) ? 0 : firstLine - 5;

            compDspSrcLinesByLineNum(earlierLine,  true); // display previous 5 lines
            compDspSrcLinesByLineNum(  firstLine, false);
        }
        else
        {
            nextMappingDsc = NULL;
        }

        return;
    }

    if (nextMappingDsc)
    {
        NATIVE_IP   offset = genEmitter->emitCodeOffset(nextMappingDsc->ipmdBlock,
                                                        nextMappingDsc->ipmdBlockOffs);

        if (offset <= curIP)
        {
            IL_OFFSET nextOffs = jitGetILoffs(nextMappingDsc->ipmdILoffsx);

            if (lastLine < nextOffs)
            {
                compDspSrcLinesByLineNum(nextOffs);
            }
            else
            {
                // This offset corresponds to a previous line. Rewind to that line

                compDspSrcLinesByLineNum(nextOffs - 2, true);
                compDspSrcLinesByLineNum(nextOffs);
            }

            lastLine        = nextOffs;
            nextMappingDsc  = nextMappingDsc->ipmdNext;
        }
    }

#endif
}

/*****************************************************************************/

void            Compiler::compDspSrcLinesByILoffs(IL_OFFSET curOffs)
{
    unsigned lineNum = BAD_LINE_NUMBER;

    if (info.compLineNumCount)
        lineNum = compLineNumForILoffs(curOffs);

    if (lineNum != BAD_LINE_NUMBER)
        compDspSrcLinesByLineNum(lineNum);
}


/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************
 * Finds the nearest line for the given instr offset. 0 if invalid
 */

unsigned            Compiler::compLineNumForILoffs(IL_OFFSET offset)
{
    if (info.compLineNumCount == 0 || offset == BAD_IL_OFFSET)
        return BAD_LINE_NUMBER;

    unsigned i = info.compLineNumCount * offset / info.compCodeSize;

    while(info.compLineNumTab[i].sldLineOfs > offset)
        i--;

    while((i+1) < info.compLineNumCount &&
          info.compLineNumTab[i+1].sldLineOfs <= offset)
        i++;

    return info.compLineNumTab[i].sldLineNum;
}

/*****************************************************************************/
#if defined(DEBUG) || MEASURE_MEM_ALLOC || MEASURE_NODE_SIZE || MEASURE_BLOCK_SIZE || DISPLAY_SIZES
static unsigned   genClassCnt;
static unsigned  genMethodCnt;
       unsigned genMethodICnt;
       unsigned genMethodNCnt;
#endif
/*****************************************************************************
 *
 *  Variables to keep track of total code amounts.
 */

#if DISPLAY_SIZES

unsigned    grossVMsize;
unsigned    grossNCsize;
unsigned    totalNCsize;
unsigned  gcHeaderISize;
unsigned  gcPtrMapISize;
unsigned  gcHeaderNSize;
unsigned  gcPtrMapNSize;

#endif

/*****************************************************************************
 *
 *  Variables to keep track of argument counts.
 */

#if CALL_ARG_STATS

unsigned    argTotalCalls;
unsigned    argHelperCalls;
unsigned    argStaticCalls;
unsigned    argNonVirtualCalls;
unsigned    argVirtualCalls;

unsigned    argTotalArgs; // total number of args for all calls (including objectPtr)
unsigned    argTotalDWordArgs;
unsigned    argTotalLongArgs;
unsigned    argTotalFloatArgs;
unsigned    argTotalDoubleArgs;

unsigned    argTotalRegArgs;
unsigned    argTotalTemps;
unsigned    argTotalLclVar;
unsigned    argTotalDeffered;
unsigned    argTotalConst;

unsigned    argTotalObjPtr;
unsigned    argTotalGTF_ASGinArgs;

unsigned    argMaxTempsPerMethod;

unsigned    argCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argCntTable(argCntBuckets);

unsigned    argDWordCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argDWordCntTable(argDWordCntBuckets);

unsigned    argDWordLngCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argDWordLngCntTable(argDWordLngCntBuckets);

unsigned    argTempsCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argTempsCntTable(argTempsCntBuckets);

#endif

/*****************************************************************************
 *
 *  Variables to keep track of basic block counts.
 */

#if COUNT_BASIC_BLOCKS

//          --------------------------------------------------
//          Basic block count frequency table:
//          --------------------------------------------------
//              <=         1 ===>  26872 count ( 56% of total)
//               2 ..      2 ===>    669 count ( 58% of total)
//               3 ..      3 ===>   4687 count ( 68% of total)
//               4 ..      5 ===>   5101 count ( 78% of total)
//               6 ..     10 ===>   5575 count ( 90% of total)
//              11 ..     20 ===>   3028 count ( 97% of total)
//              21 ..     50 ===>   1108 count ( 99% of total)
//              51 ..    100 ===>    182 count ( 99% of total)
//             101 ..   1000 ===>     34 count (100% of total)
//            1001 ..  10000 ===>      0 count (100% of total)
//          --------------------------------------------------

unsigned    bbCntBuckets[] = { 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000, 0 };
histo       bbCntTable(bbCntBuckets);

/* Histogram for the opcode size of 1 BB methods */

unsigned    bbSizeBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbOneBBSizeTable(bbSizeBuckets);

#endif

/*****************************************************************************
 *
 *  Variables to get inliner eligibility stats
 */

#if INLINER_STATS
unsigned    bbInlineBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbInlineTable(bbInlineBuckets);

unsigned    bbInitBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbInitTable(bbInitBuckets);

unsigned    bbStaticBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbStaticTable(bbStaticBuckets);

unsigned    synchMethCnt;
unsigned    clinitMethCnt;

#endif

/*****************************************************************************
 *
 *  Used by optFindNaturalLoops to gather statistical information such as
 *   - total number of natural loops
 *   - number of loops with 1, 2, ... exit conditions
 *   - number of loops that have an iterator (for like)
 *   - number of loops that have a constant iterator
 */

#if COUNT_LOOPS

unsigned    totalLoopMethods;      // counts the total number of methods that have natural loops
unsigned    maxLoopsPerMethod;     // counts the maximum number of loops a method has
unsigned    totalLoopCount;        // counts the total number of natural loops
unsigned    exitLoopCond[8];       // counts the # of loops with 0,1,2,..6 or more than 6 exit conditions
unsigned    iterLoopCount;         // counts the # of loops with an iterator (for like)
unsigned    simpleTestLoopCount;   // counts the # of loops with an iterator and a simple loop condition (iter < const)
unsigned    constIterLoopCount;    // counts the # of loops with a constant iterator (for like)

bool        hasMethodLoops;        // flag to keep track if we already counted a method as having loops
unsigned    loopsThisMethod;       // counts the number of loops in the current method

#endif

/*****************************************************************************
 *
 *  Used in the new DFA to catch dead assignments which are not removed
 *  because they contain calls
 */

#if COUNT_DEAD_CALLS

unsigned    deadHelperCount;           // counts the # of dead helper calls
unsigned    deadCallCount;             // counts the # of dead standard calls (like i=f(); where i is dead)
unsigned    removedCallCount;          // counts the # of dead standard calls that we removed

#endif

/*****************************************************************************
 * variables to keep track of how many iterations we go in a dataflow pass
 */

#if DATAFLOW_ITER

unsigned    CSEiterCount;           // counts the # of iteration for the CSE dataflow
unsigned    CFiterCount;            // counts the # of iteration for the Const Folding dataflow

#endif


#if     MEASURE_BLOCK_SIZE
size_t              genFlowNodeSize;
size_t              genFlowNodeCnt;
#endif


/*****************************************************************************/
// We keep track of methods we've already compiled.


/*****************************************************************************
 *  Declare the statics
 */

#ifdef DEBUG
/* static */
unsigned            Compiler::s_compMethodsCount = 0; // to produce unique label names
#endif

#ifndef DEBUGGING_SUPPORT
/* static */
const bool          Compiler::Options::compDbgCode = false;
#endif

#ifndef PROFILER_SUPPORT
const bool          Compiler::Options::compEnterLeaveEventCB      = false;
const bool          Compiler::Options::compCallEventCB            = false;
const bool          Compiler::Options::compNoPInvokeInlineCB      = false;
const bool          Compiler::Options::compInprocDebuggerActiveCB = false;
#endif

#if  !ALLOW_MIN_OPT
/* static */
const bool          Compiler::Options::compMinOptim = false;
#endif

/* static */
unsigned            Compiler::Info::compNStructIndirOffset;

/*****************************************************************************
 *
 *  One time initialization code
 */

/* static */
void                Compiler::compStartup()
{
#if DISPLAY_SIZES
    grossVMsize =
    grossNCsize =
    totalNCsize = 0;
#endif

    /* Initialize the single instance of the norls_allocator (with a page
     * preallocated) which we try to reuse for all non-simulataneous
     * uses (which is always, for the standalone)
     */

    nraInitTheAllocator();

    /* Initialize the table of tree node sizes */

    GenTree::InitNodeSize();

    /* Initialize the scheduler */

    emitter::emitInit();

    // Done in EE_Jit.cpp

}

/*****************************************************************************
 *
 *  One time finalization code
 */

#if GEN_COUNT_CALL_TYPES
int countDirectCalls = 0;
int countIndirectCalls = 0;
#endif

/* static */
void                Compiler::compShutdown()
{
    nraTheAllocatorDone();

    /* Shut down the emitter/scheduler */

    emitter::emitDone();

#if COUNT_RANGECHECKS
    if  (Compiler::optRangeChkAll)
        printf("Removed %u of %u range checks\n", Compiler::optRangeChkRmv,
                                                  Compiler::optRangeChkAll);
#endif

#if GEN_COUNT_PTRASG
    printf("Total number of pointer assignments: %u\n", ptrAsgCount);
#endif

#if COUNT_OPCODES

    unsigned            opcodeNum;

    for (opcodeNum = 0; opcodeNum < OP_Count; opcodeNum++)
        genOpcodeCnt[opcodeNum].ocNum = opcodeNum;

    printf("\nOpcode counts sorted by opcode number:\n\n");

    for (opcodeNum = 0; opcodeNum < OP_first_unused_index; opcodeNum++)
    {
        if  (genOpcodeCnt[opcodeNum].ocCnt)
        {
            printf("  %6u [%03u] %s\n", genOpcodeCnt[opcodeNum].ocCnt,
                                        genOpcodeCnt[opcodeNum].ocNum,
                                        opcodeNames[genOpcodeCnt[opcodeNum].ocNum]);
        }
    }

    printf("\nOpcode counts sorted by frequency:\n\n");

    qsort(genOpcodeCnt, OP_Count, sizeof(*genOpcodeCnt), genOpcCntCmp);

    for (opcodeNum = 0; opcodeNum < OP_first_unused_index; opcodeNum++)
    {
//      if  (genOpcodeCnt[opcodeNum].ocCnt)
        {
            printf("  %6u [%03u] %s\n", genOpcodeCnt[opcodeNum].ocCnt,
                                        genOpcodeCnt[opcodeNum].ocNum,
                                        opcodeNames[genOpcodeCnt[opcodeNum].ocNum]);
        }
    }

    printf("\n");

#endif

#ifdef  DEBUG
    if  (!genMethodCnt) return;
#endif

#if TOTAL_CYCLES
    printf("C-gen cycles: %8.3f mil (%5.2f sec/P133, %4.2f P200, %4.2f P233, %4.2f P266)\n",
                (float)jitTotalCycles/  1000000,
                (float)jitTotalCycles/133000000,
                (float)jitTotalCycles/200000000,
                (float)jitTotalCycles/233000000,
                (float)jitTotalCycles/266000000);
#endif

#if     DISPLAY_SIZES

    if    (grossVMsize && grossNCsize)
    {
        printf("--------------------------------------\n");

        printf("[%7u VM, %8u "CPU_NAME" %4u%%] %s\n",
                grossVMsize,
                grossNCsize,
                100*grossNCsize/grossVMsize,
                "Total (excluding GC info)");

#if TRACK_GC_REFS

        printf("[%7u VM, %8u "CPU_NAME" %4u%%] %s\n",
                grossVMsize,
                totalNCsize,
                100*totalNCsize/grossVMsize,
                "Total (including GC info)");

        if  (gcHeaderISize || gcHeaderNSize)
        {
            printf("\n");

            printf("GC tables   : [%7uI,%7uN] %7u byt  (%u%% of IL, %u%% of "CPU_NAME").\n",
                    gcHeaderISize+gcPtrMapISize,
                    gcHeaderNSize+gcPtrMapNSize,
                    totalNCsize - grossNCsize,
                    100*(totalNCsize - grossNCsize)/grossVMsize,
                    100*(totalNCsize - grossNCsize)/grossNCsize);

            printf("GC headers  : [%7uI,%7uN] %7u byt,"
                    " [%4.1fI,%4.1fN] %4.1f byt/meth\n",
                    gcHeaderISize, gcHeaderNSize, (gcHeaderISize+gcHeaderNSize),
                    (float)gcHeaderISize/(genMethodICnt+0.001),
                    (float)gcHeaderNSize/(genMethodNCnt+0.001),
                    (float)(gcHeaderISize+gcHeaderNSize)/genMethodCnt);
            printf("GC ptr maps : [%7uI,%7uN] %7u byt,"
                    " [%4.1fI,%4.1fN] %4.1f byt/meth\n",
                    gcPtrMapISize, gcPtrMapNSize, (gcPtrMapISize+gcPtrMapNSize),
                    (float)gcPtrMapISize/(genMethodICnt+0.001),
                    (float)gcPtrMapNSize/(genMethodNCnt+0.001),
                    (float)(gcPtrMapISize+gcPtrMapNSize)/genMethodCnt);
        }
        else
        {
            printf("\n");

            printf("GC tables   take up %u bytes (%u%% of instr, %u%% of "CPU_NAME" code).\n",
                    totalNCsize - grossNCsize,
                    100*(totalNCsize - grossNCsize)/grossVMsize,
                    100*(totalNCsize - grossNCsize)/grossNCsize);
        }

#endif

#ifdef  DEBUG
#if     DOUBLE_ALIGN
#if     0
        printf("%d out of %d methods generated with double-aligned stack\n",
                Compiler::s_lvaDoubleAlignedProcsCount, genMethodCnt);
#endif
#endif
#endif

    }

#endif

#if CALL_ARG_STATS
    Compiler::compDispCallArgStats();
#endif

#if COUNT_BASIC_BLOCKS
    printf("--------------------------------------------------\n");
    printf("Basic block count frequency table:\n");
    printf("--------------------------------------------------\n");
    bbCntTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("\n");

    printf("--------------------------------------------------\n");
    printf("One BB method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbOneBBSizeTable.histoDsp();
    printf("--------------------------------------------------\n");
#endif


#if INLINER_STATS
    printf("--------------------------------------------------\n");
    printf("One BB syncronized methods: %u\n", synchMethCnt);
    printf("--------------------------------------------------\n");
    printf("One BB clinit methods: %u\n", clinitMethCnt);

    printf("--------------------------------------------------\n");
    printf("Inlinable method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbInlineTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("Init method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbInitTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("Static method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbStaticTable.histoDsp();
    printf("--------------------------------------------------\n");

#endif


#if COUNT_LOOPS

    printf("---------------------------------------------------\n");
    printf("Total number of methods with loops is %5u\n", totalLoopMethods);
    printf("Total number of              loops is %5u\n", totalLoopCount);
    printf("Maximum number of loops per method is %5u\n", maxLoopsPerMethod);

    printf("\nTotal number of infinite loops is   %5u\n",              exitLoopCond[0]);
    for (int exitL = 1; exitL <= 6; exitL++)
    {
        printf("Total number of loops with %u exits is %5u\n", exitL,  exitLoopCond[exitL]);
    }
    printf("Total number of loops with more than 6 exits is %5u\n\n",  exitLoopCond[7]);

    printf("Total number of loops with an iterator is %5u\n",         iterLoopCount);
    printf("Total number of loops with a simple iterator is %5u\n",   simpleTestLoopCount);
    printf("Total number of loops with a constant iterator is %5u\n", constIterLoopCount);

#endif

#if DATAFLOW_ITER

    printf("---------------------------------------------------\n");
    printf("Total number of iterations in the CSE datatflow loop is %5u\n", CSEiterCount);
    printf("Total number of iterations in the  CF datatflow loop is %5u\n", CFiterCount);

#endif

#if COUNT_DEAD_CALLS

    printf("---------------------------------------------------\n");
    printf("Total number of dead helper   calls is %5u\n", deadHelperCount);
    printf("Total number of dead standard calls is %5u\n", deadCallCount);
    printf("Total number of removed standard calls is %5u\n", removedCallCount);

#endif

    /*
        IMPORTANT:  Use the following code to check the alignment of
                    GenTree members (in a retail build, of course).
     */

#if 0 //1
    printf("\n");
    printf("Offset of gtOper     = %2u\n", offsetof(GenTree, gtOper        ));
    printf("Offset of gtType     = %2u\n", offsetof(GenTree, gtType        ));
#if TGT_x86
    printf("Offset of gtFPlvl    = %2u\n", offsetof(GenTree, gtFPlvl       ));
#else
    printf("Offset of gtIntfRegs = %2u\n", offsetof(GenTree, gtIntfRegs    ));
#endif
#if CSE
    printf("Offset of gtCostEx   = %2u\n", offsetof(GenTree, gtCostEx      ));
    printf("Offset of gtCostSz   = %2u\n", offsetof(GenTree, gtCostSz      ));
    printf("Offset of gtCSEnum   = %2u\n", offsetof(GenTree, gtCSEnum      ));
    printf("Offset of gtConstNum = %2u\n", offsetof(GenTree, gtConstAsgNum ));
    printf("Offset of gtCopyNum  = %2u\n", offsetof(GenTree, gtCopyAsgNum  ));
    printf("Offset of gtFPrvcOut = %2u\n", offsetof(GenTree, gtStmtFPrvcOut));
#endif
#if !TGT_x86
    printf("Offset of gtLiveSet  = %2u\n", offsetof(GenTree, gtLiveSet     ));
#endif
    printf("Offset of gtRegNum   = %2u\n", offsetof(GenTree, gtRegNum      ));
#if TGT_x86
    printf("Offset of gtUsedRegs = %2u\n", offsetof(GenTree, gtUsedRegs    ));
#endif
#if TGT_x86
    printf("Offset of gtLiveSet  = %2u\n", offsetof(GenTree, gtLiveSet     ));
    printf("Offset ofgtStmtILoffsx=%2u\n", offsetof(GenTree, gtStmtILoffsx ));
#else
    printf("Offset of gtTempRegs = %2u\n", offsetof(GenTree, gtTempRegs    ));
#endif
    printf("Offset of gtRsvdRegs = %2u\n", offsetof(GenTree, gtRsvdRegs    ));
    printf("Offset of gtFlags    = %2u\n", offsetof(GenTree, gtFlags       ));
    printf("Offset of gtNext     = %2u\n", offsetof(GenTree, gtNext        ));
    printf("Offset of gtPrev     = %2u\n", offsetof(GenTree, gtPrev        ));
    printf("Offset of gtOp       = %2u\n", offsetof(GenTree, gtOp          ));
    printf("\n");
    printf("Size   of gtOp       = %2u\n", sizeof(((GenTreePtr)0)->gtOp    ));
    printf("Size   of gtIntCon   = %2u\n", sizeof(((GenTreePtr)0)->gtIntCon));
    printf("Size   of gtField    = %2u\n", sizeof(((GenTreePtr)0)->gtField));
    printf("Size   of gtLclVar   = %2u\n", sizeof(((GenTreePtr)0)->gtLclVar));
    printf("Size   of gtRegVar   = %2u\n", sizeof(((GenTreePtr)0)->gtRegVar));
    printf("Size   of gtCall     = %2u\n", sizeof(((GenTreePtr)0)->gtCall  ));
    printf("Size   of gtInd      = %2u\n", sizeof(((GenTreePtr)0)->gtInd  ));
    printf("Size   of gtStmt     = %2u\n", sizeof(((GenTreePtr)0)->gtStmt  ));
    printf("\n");
    printf("Size   of GenTree    = %2u\n", sizeof(GenTree));

#endif

#if     MEASURE_NODE_HIST

    printf("\nDistribution of GenTree node counts:\n");
    genTreeNcntHist.histoDsp();

    printf("\nDistribution of GenTree node  sizes:\n");
    genTreeNsizHist.histoDsp();

    printf("\n");

#elif   MEASURE_NODE_SIZE

    printf("\n");

    printf("Allocated %6u tree nodes (%7u bytes total, avg %4u per method)\n",
            genNodeSizeStats.genTreeNodeCnt, genNodeSizeStats.genTreeNodeSize,
            genNodeSizeStats.genTreeNodeSize / genMethodCnt);
#if     SMALL_TREE_NODES
    printf("OLD SIZE: %6u tree nodes (%7u bytes total, avg %4u per method)\n",
            genNodeSizeStats.genTreeNodeCnt, genNodeSizeStats.genTreeNodeCnt * sizeof(GenTree),
            genNodeSizeStats.genTreeNodeCnt * sizeof(GenTree) / genMethodCnt);

    printf("\n");
    printf("Small tree node size = %u\n", TREE_NODE_SZ_SMALL);
    printf("Large tree node size = %u\n", TREE_NODE_SZ_LARGE);
#endif

#endif

#if     MEASURE_BLOCK_SIZE

    printf("\n");
    printf("Offset of bbNext     = %2u\n", offsetof(BasicBlock, bbNext    ));
    printf("Offset of bbNum      = %2u\n", offsetof(BasicBlock, bbNum     ));
    printf("Offset of bbRefs     = %2u\n", offsetof(BasicBlock, bbRefs    ));
    printf("Offset of bbFlags    = %2u\n", offsetof(BasicBlock, bbFlags   ));
    printf("Offset of bbCodeOffs = %2u\n", offsetof(BasicBlock, bbCodeOffs));
    printf("Offset of bbCodeSize = %2u\n", offsetof(BasicBlock, bbCodeSize));
    printf("Offset of bbCatchTyp = %2u\n", offsetof(BasicBlock, bbCatchTyp));
    printf("Offset of bbJumpKind = %2u\n", offsetof(BasicBlock, bbJumpKind));

    printf("Offset of bbTreeList = %2u\n", offsetof(BasicBlock, bbTreeList));
    printf("Offset of bbStkDepth = %2u\n", offsetof(BasicBlock, bbStkDepth));
    printf("Offset of bbStkTemps = %2u\n", offsetof(BasicBlock, bbStkTemps));
    printf("Offset of bbTryIndex = %2u\n", offsetof(BasicBlock, bbTryIndex));
    printf("Offset of bbWeight   = %2u\n", offsetof(BasicBlock, bbWeight  ));
    printf("Offset of bbVarUse   = %2u\n", offsetof(BasicBlock, bbVarUse  ));
    printf("Offset of bbVarDef   = %2u\n", offsetof(BasicBlock, bbVarDef  ));
    printf("Offset of bbLiveIn   = %2u\n", offsetof(BasicBlock, bbLiveIn  ));
    printf("Offset of bbLiveOut  = %2u\n", offsetof(BasicBlock, bbLiveOut ));
    printf("Offset of bbScope    = %2u\n", offsetof(BasicBlock, bbScope   ));

    printf("Offset of bbExpGen   = %2u\n", offsetof(BasicBlock, bbExpGen  ));
    printf("Offset of bbExpKill  = %2u\n", offsetof(BasicBlock, bbExpKill ));
    printf("Offset of bbExpIn    = %2u\n", offsetof(BasicBlock, bbExpIn   ));
    printf("Offset of bbExpOut   = %2u\n", offsetof(BasicBlock, bbExpOut  ));

    printf("Offset of bbDom      = %2u\n", offsetof(BasicBlock, bbDom     ));
    printf("Offset of bbPreds    = %2u\n", offsetof(BasicBlock, bbPreds   ));

    printf("Offset of bbEmitCook = %2u\n", offsetof(BasicBlock, bbEmitCookie));
    printf("Offset of bbLoopNum  = %2u\n", offsetof(BasicBlock, bbLoopNum ));

    printf("Offset of bbJumpOffs = %2u\n", offsetof(BasicBlock, bbJumpOffs));
    printf("Offset of bbJumpDest = %2u\n", offsetof(BasicBlock, bbJumpDest));
    printf("Offset of bbJumpSwt  = %2u\n", offsetof(BasicBlock, bbJumpSwt ));

    printf("\n");
    printf("Size   of BasicBlock = %2u\n", sizeof(BasicBlock));

    printf("\n");
    printf("Allocated %6u basic blocks (%7u bytes total, avg %4u per method)\n",
           BasicBlock::s_Count, BasicBlock::s_Size, BasicBlock::s_Size / genMethodCnt);
    printf("Allocated %6u flow nodes (%7u bytes total, avg %4u per method)\n",
           genFlowNodeCnt, genFlowNodeSize, genFlowNodeSize / genMethodCnt);
#endif

#if MEASURE_MEM_ALLOC
    printf("\n");
    printf("Total allocation count: %9u (avg %5u per method)\n",
            genMemStats.allocCnt  , genMemStats.allocCnt   / genMethodCnt);
    printf("Total allocation size : %9u (avg %5u per method)\n",
            genMemStats.allocSiz  , genMemStats.allocSiz   / genMethodCnt);

    printf("\n");
    printf("Low-level used   size : %9u (avg %5u per method)\n",
            genMemStats.loLvlUsed , genMemStats.loLvlUsed  / genMethodCnt);
    printf("Low-level alloc  size : %9u (avg %5u per method)\n",
            genMemStats.loLvlAlloc, genMemStats.loLvlAlloc / genMethodCnt);

    printf("\n");
    printf("Largest method   alloc: %9u %s\n",
            genMemStats.loLvlBigSz, genMemStats.loLvlBigNm);

    printf("\nDistribution of alloc sizes:\n");
    genMemLoLvlHist.histoDsp();
#endif

#if SCHED_MEMSTATS
    SchedMemStats(genMethodCnt);
#endif

#if GEN_COUNT_CALL_TYPES
    printf(L"Direct:%d Indir:%d\n\n", countDirectCalls, countIndirectCalls);
#endif

#if MEASURE_PTRTAB_SIZE
    printf("Reg pointer descriptor size (internal): %8u (avg %4u per method)\n",
            s_gcRegPtrDscSize, s_gcRegPtrDscSize / genMethodCnt);

    printf("Total pointer table size: %8u (avg %4u per method)\n",
            s_gcTotalPtrTabSize, s_gcTotalPtrTabSize / genMethodCnt);

#endif

#if MEASURE_MEM_ALLOC || MEASURE_NODE_SIZE || MEASURE_BLOCK_SIZE || MEASURE_BLOCK_SIZE || DISPLAY_SIZES

    if  (genMethodCnt)
    {
        printf("\n");
        printf("A total of %6u classes compiled.\n",  genClassCnt);
        printf("A total of %6u methods compiled"   , genMethodCnt);
        if  (genMethodICnt||genMethodNCnt)
            printf(" (%uI,%uN)", genMethodICnt, genMethodNCnt);
        printf(".\n");
    }

#endif

#if EMITTER_STATS
    emitterStats();
#endif

#ifdef DEBUG
    LogEnv::cleanup();
#endif
}

/*****************************************************************************
 *
 *  Constructor
 */

void                Compiler::compInit(norls_allocator * pAlloc)
{
    assert(pAlloc);
    compAllocator = pAlloc;

     fgInit();
    lvaInit();
     raInit();
    genInit();
    optInit();
     eeInit();

    compJmpOpUsed       = false;
    compBlkOpUsed       = false;
    compLongUsed        = false;
    compTailCallUsed    = false;
    compLocallocUsed    = false;
#if ALLOW_MIN_OPT
    opts.compMinOptim   = false;
#endif
}

/*****************************************************************************
 *
 *  Destructor
 */

void                Compiler::compDone()
{

}

/******************************************************************************
 *
 *  The Emitter uses this callback function to allocate its memory
 */

/* static */
void  *  FASTCALL       Compiler::compGetMemCallback(void *p, size_t size)
{
    assert(p);

    return ((Compiler *)p)->compGetMem(size);
}

/*****************************************************************************
 *
 *  The central memory allocation routine used by the compiler. Normally this
 *  is a simple inline method defined in compiler.hpp, but for debugging it's
 *  often convenient to keep it non-inline.
 */

#ifdef DEBUG  

void  *  FASTCALL       Compiler::compGetMem(size_t sz)
{
#if 0
#if SMALL_TREE_NODES
    if  (sz != TREE_NODE_SZ_SMALL &&
         sz != TREE_NODE_SZ_LARGE && sz > 32)
    {
        printf("Alloc %3u bytes\n", sz);
    }
#else
    if  (sz != sizeof(GenTree)    && sz > 32)
    {
        printf("Alloc %3u bytes\n", sz);
    }
#endif
#endif

#if MEASURE_MEM_ALLOC
    genMemStats.allocCnt += 1;
    genMemStats.allocSiz += sz;
#endif

    void * ptr = compAllocator->nraAlloc(sz);

//  if ((int)ptr == 0x010e0ab0) debugStop(0);

    // Verify that the current block is aligned. Only then will the next
    // block allocated be on an aligned boundary.
    assert ((int(ptr) & (sizeof(int)- 1)) == 0);

    return ptr;
}

#endif

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************/

Compiler::lvdNAME       Compiler::compRegVarNAME(regNumber reg, bool fpReg)
{

#if TGT_x86
    if (fpReg)
        assert(reg < FP_STK_SIZE);
    else
#endif
        assert(genIsValidReg(reg));

    if  (info.compLocalVarsCount>0 && compCurBB && varNames)
    {
        unsigned        lclNum;
        LclVarDsc   *   varDsc;

        /* Look for the matching register */
        for (lclNum = 0, varDsc = lvaTable;
             lclNum < lvaCount;
             lclNum++  , varDsc++)
        {
            /* if variable not in a register or not the register we're looking for quit */
            /* also if a compiler generated variable (i.e. slot# > info.compLocalVarsCount) don't bother */
            if  ((varDsc->lvRegister != 0)                      &&
                 (varDsc->lvRegNum   == reg)                    &&
                 (isFloatRegType(varDsc->lvType) || !fpReg)     &&
                 (varDsc->lvSlotNum  < info.compLocalVarsCount))
            {
                /* check if variable in that register is live */
                if (genCodeCurLife & genVarIndexToBit(varDsc->lvVarIndex))
                {
                    /* variable is live - find the corresponding slot */
                    unsigned        blkBeg = compCurBB->bbCodeOffs;
                    unsigned        blkEnd = compCurBB->bbCodeSize + blkBeg;
                    LocalVarDsc *   lvd    = compFindLocalVar(varDsc->lvSlotNum,
                                                              blkBeg, blkEnd);
                    if (lvd)
                        return lvd->lvdName;
                }
            }
        }

        // maybe var is marked dead, but still used (last use)
        if (!fpReg && rsUsedTree[reg] != NULL)
        {
            GenTreePtr  nodePtr;

            if (GenTree::OperIsUnary(rsUsedTree[reg]->OperGet()))
            {
                assert(rsUsedTree[reg]->gtOp.gtOp1 != NULL);
                nodePtr = rsUsedTree[reg]->gtOp.gtOp1;
            }
            else
            {
                nodePtr = rsUsedTree[reg];
            }

            if ((nodePtr->gtOper == GT_REG_VAR) &&
                (nodePtr->gtRegVar.gtRegNum == (regNumber)reg) &&
                (nodePtr->gtRegVar.gtRegVar < info.compLocalVarsCount))
            {
                unsigned        blkBeg = compCurBB->bbCodeOffs;
                unsigned        blkEnd = compCurBB->bbCodeSize + blkBeg;
                unsigned        varNum = nodePtr->gtRegVar.gtRegVar;
                LocalVarDsc *   lvd    = compFindLocalVar(varNum,
                                                          blkBeg, blkEnd);

                if (lvd)
                    return lvd->lvdName;
            }
        }
    }
    return 0;
}

const   char *      Compiler::compRegVarName(regNumber reg, bool displayVar)
{
    assert(genIsValidReg(reg));

    if (displayVar)
    {
        lvdNAME varName = compRegVarNAME(reg);

        if (varName)
        {
            static char nameVarReg[2][4 + 256 + 1]; // to avoid overwriting the buffer when have 2 consecutive calls before printing
            static int  index = 0;                  // for circular index into the name array

            index = (index+1)%2;                    // circular reuse of index
            sprintf(nameVarReg[index], "%s'%s'",
                    getRegName(reg), lvdNAMEstr(varName));

            return nameVarReg[index];
        }
    }

    /* no debug info required or no variable in that register
       -> return standard name */

    return getRegName(reg);
}

#if TGT_x86

#define MAX_REG_PAIR_NAME_LENGTH 10

const   char *      Compiler::compRegPairName(regPairNo regPair)
{
    static char regNameLong[MAX_REG_PAIR_NAME_LENGTH];

    assert(regPair >= REG_PAIR_FIRST &&
           regPair <= REG_PAIR_LAST);

    strcpy(regNameLong, compRegVarName(genRegPairLo(regPair)));
    strcat(regNameLong, "|");
    strcpy(regNameLong, compRegVarName(genRegPairHi(regPair)));
    return regNameLong;
}


const   char *      Compiler::compRegNameForSize(regNumber reg, size_t size)
{
    if (size == 0 || size >= 4)
        return compRegVarName(reg, true);

    static
    const char  *   sizeNames[][2] =
    {
        { "AL", "AX" },
        { "CL", "CX" },
        { "DL", "DX" },
        { "BL", "BX" },
    };

    assert(isByteReg (reg));
    assert(genRegMask(reg) & RBM_BYTE_REGS);
    assert(size == 1 || size == 2);

    return sizeNames[reg][size-1];
}

const   char *      Compiler::compFPregVarName(unsigned fpReg, bool displayVar)
{
    /* 'reg' is the distance from the bottom of the stack, ie.
     * it is independant of the current FP stack level
     */

    assert(fpReg < FP_STK_SIZE);

    static char nameVarReg[2][4 + 256 + 1]; // to avoid overwriting the buffer when have 2 consecutive calls before printing
    static int  index = 0;                  // for circular index into the name array

    index = (index+1)%2;                    // circular reuse of index

    if (displayVar && genFPregCnt)
    {
        assert(fpReg <= (genFPregCnt + genFPstkLevel)-1);

        unsigned    pos     = genFPregCnt - (fpReg+1 -  genFPstkLevel);
        lvdNAME     varName = compRegVarNAME((regNumber)pos, true);

        if (varName)
        {
            sprintf(nameVarReg[index], "ST(%d)'%s'", fpReg, lvdNAMEstr(varName));

            return nameVarReg[index];
        }
    }

    /* no debug info required or no variable in that register
       -> return standard name */

    sprintf(nameVarReg[index], "ST(%d)", fpReg);
    return nameVarReg[index];
}

#endif

Compiler::LocalVarDsc *     Compiler::compFindLocalVar( unsigned    varNum,
                                                        unsigned    lifeBeg,
                                                        unsigned    lifeEnd)
{
    LocalVarDsc *   t;
    unsigned        i;

    for (i = 0, t = info.compLocalVars;
        i < info.compLocalVarsCount;
        i++  , t++)
    {
        if  (t->lvdVarNum  != varNum)   continue;
        if  (t->lvdLifeBeg >  lifeEnd)  continue;
        if  (t->lvdLifeEnd <= lifeBeg)  continue;

        return t;
    }

    return NULL;
}

const   char *      Compiler::compLocalVarName(unsigned varNum, unsigned offs)
{
    unsigned        i;
    LocalVarDsc *   t;

    for (i = 0, t = info.compLocalVars;
         i < info.compLocalVarsCount;
         i++  , t++)
    {
        if  (t->lvdVarNum != varNum)
            continue;

        if  (offs >= t->lvdLifeBeg &&
             offs <  t->lvdLifeEnd)
        {
            return lvdNAMEstr(t->lvdName);
        }
    }

    return  0;
}


/*****************************************************************************/
#endif //DEBUG
/*****************************************************************************/

inline
void                Compiler::compInitOptions(unsigned compileFlags)
{
    opts.eeFlags      = compileFlags;

#ifdef DEBUG

    /* In the DLL, this matches the command line options in the EXE */

    #define SET_OPTS(b) { dspCode = b;                      \
                          dspGCtbls = b; dspGCoffs = b;     \
                          disAsm2 = b;                      \
                          if (1) verbose      = b;          \
                          if (0) verboseTrees = b; }


    SET_OPTS(false);

    static ConfigMethodSet fJitDump(L"JitDump");
    if (fJitDump.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig)))
       SET_OPTS(true);

    static ConfigMethodSet fJitGCDump(L"JitGCDump");
    if (fJitGCDump.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig)))
        dspGCtbls = true;

    static ConfigMethodSet fJitDisasm(L"JitDisasm");
    if (fJitDisasm.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig)))
        disAsm = true;

    if (verbose)
    {
        printf("****** START compiling %s (MethodHash: %u)\n", 
               info.compFullName, info.compCompHnd->getMethodHash(info.compMethodHnd));
        printf("");         // in our logic this causes a flush
    }
    
    static ConfigMethodSet fJitBreak(L"JitBreak");
    if (fJitBreak.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig)))
        assert(!"JitBreak reached");
#endif

    opts.compUseFCOMI = ((opts.eeFlags & CORJIT_FLG_USE_FCOMI) != 0);
#ifdef DEBUG
    if (opts.compUseFCOMI)
        opts.compUseFCOMI = !compStressCompile(STRESS_USE_FCOMI, 50);
#endif

    opts.compUseCMOV = ((opts.eeFlags & CORJIT_FLG_USE_CMOV) != 0);
#ifdef DEBUG
    if (opts.compUseCMOV)
        opts.compUseCMOV = !compStressCompile(STRESS_USE_CMOV, 50);
#endif

    if  (opts.eeFlags & CORJIT_FLG_DEBUG_OPT)
        opts.compFlags = CLFLG_MINOPT;
    else if (false && // @TODO [CONSIDER] [04/16/01] [] Should we spend any time optimizing huge cctors?
             info.compCodeSize >= 0x8000 &&
             (info.compFlags & FLG_CCTOR) == FLG_CCTOR)
        opts.compFlags = CLFLG_MINOPT;
    else
        opts.compFlags = CLFLG_MAXOPT;

    // Default value is to generate a blend of size and speed optimizations
    opts.compCodeOpt = BLENDED_CODE;

    if (opts.eeFlags & CORJIT_FLG_SPEED_OPT)
    {
        opts.compCodeOpt = FAST_CODE;
        assert((opts.eeFlags & CORJIT_FLG_SIZE_OPT) == 0);
#ifdef DEBUG
        if (verbose) 
            printf("OPTIONS: compCodeOpt = FAST_CODE\n");
#endif
    }
    else if (opts.eeFlags & CORJIT_FLG_SIZE_OPT)
    {
        opts.compCodeOpt = SMALL_CODE;
#ifdef DEBUG
        if (verbose) 
            printf("OPTIONS: compCodeOpt = SMALL_CODE\n");
#endif
    }
#ifdef DEBUG
    else 
    {
        if (verbose) 
            printf("OPTIONS: compCodeOpt = BLENDED_CODE\n");
    }
#endif

    //-------------------------------------------------------------------------

#ifdef DEBUGGING_SUPPORT

    opts.compDbgCode = (opts.eeFlags & CORJIT_FLG_DEBUG_OPT)  != 0;
    opts.compDbgInfo = (opts.eeFlags & CORJIT_FLG_DEBUG_INFO) != 0;
    opts.compDbgEnC  = (opts.eeFlags & CORJIT_FLG_DEBUG_EnC)  != 0;

    // We never want to have debugging enabled when regenerating GC encoding patterns
#if REGEN_SHORTCUTS || REGEN_CALLPAT
    opts.compDbgCode = false;
    opts.compDbgInfo = false;
    opts.compDbgEnC  = false;
#endif

#ifdef DEBUG
    static ConfigDWORD fJitGCChecks(L"JitGCChecks");
    opts.compGcChecks = (fJitGCChecks.val() != 0);

    static ConfigDWORD fJitStackChecks(L"JitStackChecks");
    opts.compStackCheckOnRet = (fJitStackChecks.val() & 1) != 0;
    opts.compStackCheckOnCall = (fJitStackChecks.val() & 2) != 0;

    if (verbose) 
    {
        printf("OPTIONS: compDbgCode = %d\n", opts.compDbgCode);
        printf("OPTIONS: compDbgInfo = %d\n", opts.compDbgInfo);
        printf("OPTIONS: compDbgEnC = %d\n", opts.compDbgEnC);
    }
#endif 

#ifdef PROFILER_SUPPORT
    opts.compEnterLeaveEventCB =
        (opts.eeFlags & CORJIT_FLG_PROF_ENTERLEAVE)        ? true : false;
    opts.compCallEventCB = 
        (opts.eeFlags & CORJIT_FLG_PROF_CALLRET)           ? true : false;
    opts.compNoPInvokeInlineCB =
        (opts.eeFlags & CORJIT_FLG_PROF_NO_PINVOKE_INLINE) ? true : false;
    opts.compInprocDebuggerActiveCB =
        (opts.eeFlags & CORJIT_FLG_PROF_INPROC_ACTIVE)     ? true : false;


#endif

    opts.compScopeInfo  = opts.compDbgInfo;
#ifdef LATE_DISASM
    // For the late disassembly, we need the scope information
    opts.compDisAsm     = disAsm;
    opts.compLateDisAsm = disAsm2;
#endif

#endif // DEBUGGING_SUPPORT

#ifdef  LATE_DISASM
    static ConfigMethodSet fJitLateDisasm(L"JitLateDisasm");
    opts.compLateDisAsm  = fJitLateDisasm.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig));
    if (opts.compLateDisAsm) {
        disOpenForLateDisAsm(info.compClassName, info.compMethodName);
            /* Calling the late disassembler means we need to call the emitter. */
        savCode = true;
    }
#endif

    //-------------------------------------------------------------------------
    opts.compNeedSecurityCheck = false;

#if     RELOC_SUPPORT
        opts.compReloc = (opts.eeFlags & CORJIT_FLG_RELOC) ? true : false;
#endif

#ifdef  DEBUG
#if     ALLOW_MIN_OPT
    static ConfigDWORD fJitMinOps(L"JitMinOps");
    opts.compMinOptim = (fJitMinOps.val() != 0);
#endif
#endif

    /* Control the optimizations */

    if (opts.compMinOptim || opts.compDbgCode)
    {
        opts.compFlags &= ~CLFLG_MAXOPT;
        opts.compFlags |=  CLFLG_MINOPT;
    }

#if     TGT_x86
    genFPreqd  = opts.compMinOptim;
#ifdef  DEBUG
    static ConfigDWORD fJitFramed(L"JitFramed");
    if (fJitFramed.val())
        genFPreqd  = true;
#endif
#endif

    impInlineSize = DEFAULT_INLINE_SIZE;
#ifdef DEBUG
    static ConfigDWORD fJitInlineSize(L"JITInlineSize", DEFAULT_INLINE_SIZE);
    impInlineSize = fJitInlineSize.val();
#endif

    // If we are generating small code, only inline calls which we think
    // wont generate more code than reqired for setting up the call.
    
    if (compCodeOpt() == SMALL_CODE)
    {
        if (impInlineSize > MAX_NONEXPANDING_INLINE_SIZE)
            impInlineSize = MAX_NONEXPANDING_INLINE_SIZE;
    }
    else
    {
        // Bump up the size if optimizing for FAST_CODE
        if (compCodeOpt() == FAST_CODE)
            impInlineSize = (impInlineSize * 3) / 2;
#ifdef DEBUG
        if (compStressCompile(STRESS_INLINE, 50))
            impInlineSize *= 10;
#endif
    }
    

    //-------------------------------------------------------------------------
    //
    //                  Resolve some interrelated flags for scheduling.
    //

#if     SCHEDULER


#if !TGT_x86

    opts.compSchedCode = false;

#else // TGT_x86

    opts.compSchedCode = true;          // Default value

    if (opts.compDbgCode)
        opts.compSchedCode = false;     // Turn off for debuggable code

    //  Control scheduling via the registry

    static SchedCode  schedCode = getSchedCode();

    switch(schedCode)
    {
    case NO_SCHED:
        opts.compSchedCode = false;
        break;

    case CAN_SCHED:

        // Turn off scheduling if we are not optimizing
        // Turn off scheduling if we're not generating code for a Pentium.

        if ((opts.compMinOptim || genCPU != 5) &&
            !compStressCompile(STRESS_SCHED, 50))
            opts.compSchedCode = false;
        break;

    case MUST_SCHED:
        break;

    case RANDOM_SCHED:

        // Turn off scheduling only for odd-sized methods

        if  (info.compCodeSize%2)
            opts.compSchedCode = false;
        break;

    default:
        assert(!"Bad schedCode");
        break;
    }

#endif // TGT_x86

    /* RISCify the generated code only if we're scheduling */

    riscCode = opts.compSchedCode;

#endif // SCHEDULER

#if     TGT_RISC
     riscCode = false;
#if     SCHEDULER
//  opts.compSchedCode = false;
#endif
#endif

}

#ifdef DEBUG
/*****************************************************************************
 * Should we use a "stress-mode" for the given stressArea. We have different
 *   areas to allow the areas to be mixed in different combinations in 
 *   different methods.
 * 'weight' indicates how often (as a percentage) the area should be stressed.
 *    It should reflect the usefulness:overhead ratio.
 */

bool            Compiler::compStressCompile(compStressArea  stressArea,
                                            unsigned        weight)
{
    // 0:   No stress
    // !=2: Vary stress. Performance will be slightly/moderately degraded
    // 2:   Check-all stress. Performance will be REALLY horrible
    DWORD stressLevel = getJitStressLevel();

    assert(weight <= MAX_STRESS_WEIGHT);

    /* Check for boundary conditions */

    if (stressLevel == 0 || weight == 0)
        return false;

    if (weight == MAX_STRESS_WEIGHT)
        return true;

    // Should we allow unlimited stress ?
    if (stressArea > STRESS_COUNT_VARN && stressLevel == 2)
        return true;

    // Get a hash which can be compared with 'weight'

    assert(stressArea != 0);
    unsigned hash = (info.compFullNameHash ^ stressArea ^ stressLevel) % MAX_STRESS_WEIGHT;

    assert(hash < MAX_STRESS_WEIGHT && weight <= MAX_STRESS_WEIGHT);
    return (hash < weight);
}
#endif

/*****************************************************************************
 *
 *  Compare function passed to qsort() to sort line number records by offset.
 */

void            Compiler::compInitDebuggingInfo()
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In compInitDebuggingInfo() for %s\n", info.compFullName);
#endif
    /*-------------------------------------------------------------------------
     *
     * Get hold of the local variable records, if there are any
     */

    info.compLocalVarsCount = 0;

#ifdef  DEBUGGING_SUPPORT
    if (opts.compScopeInfo
#ifdef DEBUG
        || (verbose&&0)
#endif
        )
#endif
    {
        eeGetVars();

#ifdef DEBUG
        if  (verbose)
        {
            printf("info.compLocalVarsCount = %d\n", info.compLocalVarsCount);

            if (info.compLocalVarsCount)
                printf("    \tVarNum \t      Name \tBeg \tEnd\n");

            for (unsigned i = 0; i < info.compLocalVarsCount; i++)
            {
                LocalVarDsc * lvd = &info.compLocalVars[i];
                printf("%2d) \t%02Xh \t%10s \t%03Xh   \t%03Xh  \n",
                       i, lvd->lvdVarNum, lvdNAMEstr(lvd->lvdName), lvd->lvdLifeBeg, lvd->lvdLifeEnd);
            }
        }
#endif

    }

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo || opts.compDbgCode)
    {
        compInitScopeLists();
    }

    if (opts.compDbgCode)
    {
        /* Create a new empty basic block. fgExtendDbgLifetimes() may add
           initialization of variables which are in scope right from the
           start of the (real) first BB (and therefore artifically marked
           as alive) into this block.
         */

        BasicBlock* block = fgNewBasicBlock(BBJ_NONE);

        fgStoreFirstTree(block, gtNewNothingNode());

        block->bbFlags |= BBF_INTERNAL;

#ifdef DEBUG
        if (verbose)
        {
            printf("\nDebuggable code - Add new BB to perform initialization of variables [%08X]\n", block);
        }
#endif
    }

#endif

    /*-------------------------------------------------------------------------
     *
     * Read the stmt-offsets table and the line-number table
     */

    info.compStmtOffsetsImplicit = (ImplicitStmtOffsets)0;

    // We can only report debug info for EnC at places where the stack is empty.
    // Acutally at places where there are not live temps. Else, we wont be able
    // to map between the old and the new versions correctly as we wont have
    // any info for the live temps.
    // @TODO [CONSIDER] [04/16/01] [] If we can indicate offsets where 
    // the stack is empty, this
    // might work if the debugger avoided doing an update at such places.

    assert(!opts.compDbgEnC || !opts.compDbgInfo ||
           0 == (info.compStmtOffsetsImplicit & ~STACK_EMPTY_BOUNDARIES));

    info.compLineNumCount = 0;
    info.compStmtOffsetsCount = 0;

#ifdef  DEBUGGING_SUPPORT
    if (opts.compDbgInfo
#ifdef DEBUG
        || (verbose&&0)
#endif
        )
#endif
    {
        /* Get hold of the line# records, if there are any */

        eeGetStmtOffsets();

#ifdef DEBUG
        if (verbose)
        {
            printf("info.compStmtOffsetsCount = %d, info.compStmtOffsetsImplicit = %04Xh", 
                    info.compStmtOffsetsCount,      info.compStmtOffsetsImplicit);
            if (info.compStmtOffsetsImplicit)
            {
                printf(" ( ");
                if (info.compStmtOffsetsImplicit & STACK_EMPTY_BOUNDARIES) printf("STACK_EMPTY ");
                if (info.compStmtOffsetsImplicit & CALL_SITE_BOUNDARIES)   printf("CALL_SITE ");
                if (info.compStmtOffsetsImplicit & ALL_BOUNDARIES)         printf("ALL ");
                printf(")");
            }
            printf("\n");
            IL_OFFSET * pOffs = info.compStmtOffsets;
            for(unsigned i = 0; i < info.compStmtOffsetsCount; i++, pOffs++)
                printf("%02d) IL_%04Xh\n", i, *pOffs);
        }
#endif
    }


    /*-------------------------------------------------------------------------
     * Open the source file and seek within the file to close to
     * the start of the method without displaying anything yet
     */

}

/*****************************************************************************/

void                 Compiler::compCompile(void * * methodCodePtr,
                                           SIZE_T * methodCodeSize,
                                           void * * methodConsPtr,
                                           void * * methodDataPtr,
                                           void * * methodInfoPtr,
                                           unsigned compileFlags)
{
    /* Convert the instrs in each basic block to a tree based intermediate representation */

    fgImport();

        // Maybe the caller was not interested in generating code
    if (compileFlags & CORJIT_FLG_IMPORT_ONLY)
        return;

#ifdef DEBUG
    lvaStressLclFld();
    lvaStressFloatLcls();
#endif


    // @TODO [REVISIT] [04/16/01] []: We can allow ESP frames. Just need to reserve space for
    // pushing EBP if the method becomes an EBP-frame after an edit.

    // Note that requring a EBP Frame disallows double alignment.  Thus if we change this
    // we either have to disallow double alignment for E&C some other way or handle it in EETwain.
    if (opts.compDbgEnC)
    {
#if TGT_x86
        genFPreqd      = true;
#endif
    }

    if  (!opts.compMinOptim)
    {
        if  (!opts.compDbgCode)
        {
#if OPTIMIZE_RECURSION
            optOptimizeRecursion();
#endif

#if OPTIMIZE_INC_RNG
            optOptimizeIncRng();
#endif        
        }
    }

    /* Massage the trees so that we can generate code out of them */

    fgMorph();

    /* Compute bbNums, bbRefs and bbPreds */

    fgComputePreds();

    /* From this point on the flowgraph information such as bbNums,
     * bbRefs or bbPreds has to be kept updated */

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /*  Perform loop inversion (i.e. transform "while" loops into
            "repeat" loops) and discover and classify natural loops
            (e.g. mark iterative loops as such). Also marks loop blocks
            and sets bbWeight to the loop nesting levels
        */
  
        optOptimizeLoops();

        if (compCodeOpt() != SMALL_CODE)
        {
            /* Unroll loops */

            optUnrollLoops();
        }

        /* Hoist invariant code out of loops */

        optHoistLoopCode();

#ifdef DEBUG
        fgDebugCheckLinks();
#endif
    }

    /* Create the variable table (and compute variable ref counts) */

    lvaMarkLocalVars();

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /* Optimize boolean conditions */

        optOptimizeBools();

        /* Optimize range checks based on loop info */

        optRemoveRangeChecks();
    }

    /* Figure out the order in which operators are to be evaluated */
    fgFindOperOrder();

    /* Weave the tree lists. Anyone who modifies the tree shapes after
       this point is responsible for calling fgSetStmtSeq() to keep the
       nodes properly linked */
    fgSetBlockOrder();

    /* IMPORTANT, after this point, every place where tree topology changes must redo evaluation
       order (gtSetStmtInfo) and relink nodes (fgSetStmtSeq) if required.

    /* At this point we know if we are fully interruptible or not */

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /* Optimize array index range checks */

        optOptimizeIndexChecks();

#if CSE
        /* Remove common sub-expressions */
        optOptimizeCSEs();
#endif

#if ASSERTION_PROP
        /* Assertion propagation */
        optAssertionPropMain();
#endif

        /* update the flowgraph if we modified it during the optimization phase*/
        if  (fgModified)
            fgUpdateFlowGraph();
    }

#ifdef DEBUG
    fgDebugCheckLinks();
#endif

    /* Initialize for data flow analysis */

    fgDataFlowInit();

    /* Figure out use/def info for all basic blocks */

    fgPerBlockDataFlow();

    /* Data flow: live variable analysis and range check availability */

    fgGlobalDataFlow();

#ifdef DEBUG
    fgDebugCheckBBlist();
    fgDebugCheckLinks();
#endif

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /* Perform loop code motion / worthless code removal */

#if CODE_MOTION
        optLoopCodeMotion();
#endif

        /* Adjust ref counts based on interference levels */

        lvaAdjustRefCnts();

        /* Are there are any potential array initializers? */

        optOptimizeArrayInits();
    }

#ifdef DEBUG
    fgDebugCheckBBlist();
#endif

    /* Enable this to gather statistical data such as
     * call and register argument info, flowgraph and loop info, etc. */

    //compJitStats();

    /* Assign registers to variables, etc. */

    raAssignVars();

#ifdef DEBUG
    fgDebugCheckLinks();
#endif

    /* Generate code */

    genGenerateCode(methodCodePtr,
                    methodCodeSize,
                    methodConsPtr,
                    methodDataPtr,
                    methodInfoPtr);
}

/*****************************************************************************/

#if     REGVAR_CYCLES || TOTAL_CYCLES
#define CCNT_OVERHEAD32 13
unsigned GetCycleCount32 ();
#endif

#ifdef DEBUG
void* forceFrame;       // used to force to frame &useful for fastchecked debugging

static ConfigMethodRange fJitRange(L"JitRange");
static ConfigMethodSet   fJitInclude(L"JitInclude");
static ConfigMethodSet   fJitExclude(L"JitExclude");
static ConfigDWORD fJitForceVer(L"JitForceVer", 0);

#endif

/*****************************************************************************/

int FASTCALL  Compiler::compCompile(CORINFO_METHOD_HANDLE methodHnd,
                                    CORINFO_MODULE_HANDLE classPtr,
                                    COMP_HANDLE           compHnd,
                                    CORINFO_METHOD_INFO * methodInfo,
                                    void *              * methodCodePtr,
                                    SIZE_T              * methodCodeSize,
                                    void *              * methodConsPtr,
                                    void *              * methodDataPtr,
                                    void *              * methodInfoPtr,
                                    unsigned              compileFlags)
{
#ifdef DEBUG
    Compiler* me = this;
    forceFrame = (void*) &me;   // let us see the this pointer in fastchecked build
#endif

    int             result = CORJIT_INTERNALERROR;

//  if (s_compMethodsCount==0) setvbuf(stdout, NULL, _IONBF, 0);

#if TOTAL_CYCLES
    unsigned        cycleStart = GetCycleCount32();
#endif

    info.compCompHnd     = compHnd;
    info.compMethodHnd   = methodHnd;
    info.compMethodInfo  = methodInfo;
    info.compClassHnd    = eeGetMethodClass(methodHnd);
    info.compClassAttr   = eeGetClassAttribs(info.compClassHnd);

#ifdef  DEBUG
    const char * buf;

    info.compMethodName  = eeGetMethodName(methodHnd, &buf);
    info.compClassName   = (char *)compGetMem(roundUp(strlen(buf)+1));
    strcpy((char *)info.compClassName, buf);

    info.compFullName    = eeGetMethodFullName(methodHnd);
    info.compFullNameHash= HashStringA(info.compFullName);
    LogEnv::cur()->setCompiler(this);

#ifdef  UNDER_CE_GUI
    UpdateCompDlg(NULL, info.compMethodName);
#endif

    bool saveVerbose = verbose;
    bool saveDisAsm  = disAsm;

        // Have we been told to be more selective in our Jitting?

    if (!fJitRange.contains(compHnd, methodHnd))
        return CORJIT_SKIPPED;
    if (fJitExclude.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig)))
        return CORJIT_SKIPPED;
    if (!fJitInclude.isEmpty() && !fJitInclude.contains(info.compMethodName, info.compClassName, PCCOR_SIGNATURE(info.compMethodInfo->args.sig)))
        return CORJIT_SKIPPED;
#endif

    /* Setup an error trap */

    setErrorTrap()  // ERROR TRAP: Start normal block
    {
        // Set this before the first 'BADCODE'
       
        tiVerificationNeeded = (compileFlags & CORJIT_FLG_SKIP_VERIFICATION) == 0;
#ifdef DEBUG
		// Force verification if asked to do so
		if (fJitForceVer.val())
			tiVerificationNeeded = TRUE;
		
        if (tiVerificationNeeded)
            JITLOG((LL_INFO10000, "Verifying method %s\n", info.compFullName));
#endif
        /* Since tiVerificationNeeded can be turned off in the middle of
           compiling a method, and it might have caused blocks to be queued up
           for reimporting, impCanReimport can be used to check for reimporting. */

        impCanReimport          = (tiVerificationNeeded || compStressCompile(STRESS_CHK_REIMPORT, 15));

        info.compCode           = methodInfo->ILCode;
        
        if ((info.compCodeSize  = methodInfo->ILCodeSize) == 0)
            BADCODE("code size is zero");

        compInitOptions(compileFlags);

        /* Initialize set a bunch of global values */

        info.compScopeHnd       = classPtr;
                                
        info.compXcptnsCount    = methodInfo->EHcount;

        info.compMaxStack       = methodInfo->maxStack;

        compHndBBtab            = NULL;

#ifdef  DEBUG
        compCurBB               = 0;
        lvaTable                = 0;
#endif

        /* Initialize emitter */

        genEmitter = (emitter*)compGetMem(roundUp(sizeof(*genEmitter)));
        genEmitter->emitBegCG(this, compHnd);

        info.compFlags          = eeGetMethodAttribs(info.compMethodHnd);

        info.compIsStatic       = (info.compFlags & CORINFO_FLG_STATIC) != 0;

        info.compIsContextful   = (info.compClassAttr & CORINFO_FLG_CONTEXTFUL) != 0;

        info.compUnwrapContextful = !opts.compMinOptim && !opts.compDbgCode;
#if 0
        info.compUnwrapCallv      = !opts.compMinOptim && !opts.compDbgCode;
#else
        info.compUnwrapCallv      = 0;
#endif

        switch(methodInfo->args.getCallConv()) {
        case CORINFO_CALLCONV_VARARG:
            info.compIsVarArgs    = true;
            break;
        case CORINFO_CALLCONV_DEFAULT:
            info.compIsVarArgs    = false;
            break;
        default:
            BADCODE("bad calling convention");
        }
        info.compRetType        = JITtype2varType(methodInfo->args.retType);

        assert((methodInfo->args.getCallConv() & CORINFO_CALLCONV_PARAMTYPE) == 0);

#if INLINE_NDIRECT
        info.compCallUnmanaged  = 0;
#endif

        lvaScratchMem           = 0;

        // We also set info.compInitMem to true after impImport(), when tiVerificationNeeded is true
        info.compInitMem        = ((methodInfo->options & CORINFO_OPT_INIT_LOCALS) != 0);

        info.compLooseExceptions = (opts.eeFlags & CORJIT_FLG_LOOSE_EXCEPT_ORDER) == CORJIT_FLG_LOOSE_EXCEPT_ORDER;

        /* Allocate the local variable table */

        lvaInitTypeRef();

        compInitDebuggingInfo();

        /* Find and create the basic blocks */

        fgFindBasicBlocks();



#ifdef  DEBUG
        /* Give the function a unique number */

        s_compMethodsCount++;
#endif

#if COUNT_BASIC_BLOCKS
    bbCntTable.histoRec(fgBBcount, 1);

    if (fgBBcount == 1)
        bbOneBBSizeTable.histoRec(bodySize, 1);
#endif

#if INLINER_STATS
    /* Check to see if the method is eligible for inlining */

    if (fgBBcount == 1)
    {
        assert(!info.compXcptnsCount);

        if (info.compFlags & CORINFO_FLG_SYNCH)
            synchMethCnt++;
        else if ((info.compFlags & FLG_CCTOR) == FLG_CCTOR)
            clinitMethCnt++;
        else
        {
            if (info.compFlags & CORINFO_FLG_CONSTRUCTOR)
            {
                bbInitTable.histoRec(bodySize, 1);
                bbInlineTable.histoRec(bodySize, 1);
            }
            else if (info.compIsStatic)
            {
                if (strcmp(info.compMethodName, "main"))
                {
                    bbStaticTable.histoRec(bodySize, 1);
                    bbInlineTable.histoRec(bodySize, 1);
                }
            }
        }
    }
#endif

#ifdef  DEBUG
        if  (verbose)
        {
            printf("Basic block list for '%s'\n", info.compFullName);
            fgDispBasicBlocks();
        }
#endif

        compCompile(methodCodePtr,
                    methodCodeSize,
                    methodConsPtr,
                    methodDataPtr,
                    methodInfoPtr,
                    compileFlags);

        /* Success! */

        result = CORJIT_OK;
    }
    finallyErrorTrap()  // ERROR TRAP: The following block handles errors
    {
        /* Cleanup  */
        
        /* Tell the emitter/scheduler that we're done with this function */
        
        genEmitter->emitEndCG();
              
#if MEASURE_MEM_ALLOC
        if  (genMemStats.loLvlBigSz < allocator.nraTotalSizeUsed())
        {
            genMemStats.loLvlBigSz = allocator.nraTotalSizeUsed();
            strcpy(genMemStats.loLvlBigNm, info.compClassName);
            strcat(genMemStats.loLvlBigNm, ".");
            strcat(genMemStats.loLvlBigNm, info.compMethodName);
            
            // printf("Largest method   alloc: %9u %s\n", genMemStats.loLvlBigSz, genMemStats.loLvlBigNm);
        }
        
        size_t  genMemLLendUsed  = allocator.nraTotalSizeUsed();
        size_t  genMemLLendAlloc = allocator.nraTotalSizeAlloc();
        
        //  assert(genMemLLendAlloc >= genMemLLendUsed);
        
        genMemStats.loLvlUsed  += genMemLLendUsed;
        genMemStats.loLvlAlloc += genMemLLendAlloc;
        genMemStats.loLvlAllh  += genMemLLendAlloc;
#endif
        
#if defined(DEBUG) || MEASURE_MEM_ALLOC || MEASURE_NODE_SIZE || MEASURE_BLOCK_SIZE || DISPLAY_SIZES
        genMethodCnt++;
#endif
        
#if TOTAL_CYCLES
        jitTotalCycles += GetCycleCount32() - cycleStart - CCNT_OVERHEAD32;
#endif
        
#ifdef DEBUG
        if (verbose)
        {
            printf("****** DONE compiling %s\n", info.compFullName);
            printf("");         // in our logic this causes a flush
        }
        SET_OPTS(saveVerbose);
        disAsm = saveDisAsm;
#endif
        compDone();        
    }
    endErrorTrap()  // ERROR TRAP: End

    return  result;
}



#if defined(LATE_DISASM)

void            ProcInitDisAsm(void * ptr, unsigned codeSize)
{
    assert(ptr);
    Compiler * _this = (Compiler *) ptr;

    /* We have to allocate the jump target vector
     * because the scheduler might call DisasmBuffer */

    _this->genDisAsm.disJumpTarget =
                                (BYTE *)_this->compGetMem(roundUp(codeSize));
    memset(_this->genDisAsm.disJumpTarget, 0, roundUp(codeSize));

}

#endif

/*****************************************************************************/
#ifdef DEBUGGING_SUPPORT
/*****************************************************************************/


static
int __cdecl         genCmpLocalVarLifeBeg(const void * elem1, const void * elem2)
{
    return (*((Compiler::LocalVarDsc**) elem1))->lvdLifeBeg -
           (*((Compiler::LocalVarDsc**) elem2))->lvdLifeBeg;
}

static
int __cdecl         genCmpLocalVarLifeEnd(const void * elem1, const void * elem2)
{
    return (*((Compiler::LocalVarDsc**) elem1))->lvdLifeEnd -
           (*((Compiler::LocalVarDsc**) elem2))->lvdLifeEnd;
}

inline
void            Compiler::compInitScopeLists()
{
    if (info.compLocalVarsCount == 0)
    {
        compEnterScopeList =
        compExitScopeList  = NULL;
        return;
    }

    unsigned i;

    // Populate the 'compEnterScopeList' and 'compExitScopeList' lists

    compEnterScopeList =
        (LocalVarDsc**)
        compGetMemArray(info.compLocalVarsCount, sizeof(*compEnterScopeList));
    compExitScopeList =
        (LocalVarDsc**)
        compGetMemArray(info.compLocalVarsCount, sizeof(*compEnterScopeList));

    for (i=0; i<info.compLocalVarsCount; i++)
    {
        compEnterScopeList[i] = compExitScopeList[i] = & info.compLocalVars[i];
    }

    qsort(compEnterScopeList, info.compLocalVarsCount, sizeof(*compEnterScopeList), genCmpLocalVarLifeBeg);
    qsort(compExitScopeList,  info.compLocalVarsCount, sizeof(*compExitScopeList),  genCmpLocalVarLifeEnd);
}

void            Compiler::compResetScopeLists()
{
    if (info.compLocalVarsCount == 0)
        return;

    assert (compEnterScopeList && compExitScopeList);

    compNextEnterScope = compNextExitScope =0;
}


Compiler::LocalVarDsc *   Compiler::compGetNextEnterScope(unsigned  offs,
                                                          bool      scan)
{
    assert (info.compLocalVarsCount);
    assert (compEnterScopeList && compExitScopeList);

    if (compNextEnterScope < info.compLocalVarsCount)
    {
        assert (compEnterScopeList[compNextEnterScope]);
        unsigned nextEnterOff = compEnterScopeList[compNextEnterScope]->lvdLifeBeg;
        assert (scan || (offs <= nextEnterOff));

        if (!scan)
        {
            if (offs == nextEnterOff)
            {
                return compEnterScopeList[compNextEnterScope++];
            }
        }
        else
        {
            if (nextEnterOff <= offs)
            {
                return compEnterScopeList[compNextEnterScope++];
            }
        }
    }

    return NULL;
}


Compiler::LocalVarDsc *   Compiler::compGetNextExitScope(unsigned   offs,
                                                         bool       scan)
{
    assert (info.compLocalVarsCount);
    assert (compEnterScopeList && compExitScopeList);

    if (compNextExitScope < info.compLocalVarsCount)
    {
        assert (compExitScopeList[compNextExitScope]);
        unsigned nextExitOffs = compExitScopeList[compNextExitScope]->lvdLifeEnd;

        assert (scan || (offs <= nextExitOffs));

        if (!scan)
        {
            if (offs == nextExitOffs)
            {
                return compExitScopeList[compNextExitScope++];
            }
        }
        else
        {
            if (nextExitOffs <= offs)
            {
                return compExitScopeList[compNextExitScope++];
            }
        }
    }

    return NULL;
}


// The function will call the callback functions for scopes with boundaries
// at instrs from the current status of the scope lists to 'offset',
// ordered by instrs.

void        Compiler::compProcessScopesUntil (unsigned     offset,
                                   void (*enterScopeFn)(LocalVarDsc *, unsigned),
                                   void (*exitScopeFn) (LocalVarDsc *, unsigned),
                                   unsigned     clientData)
{
    bool            foundExit = false, foundEnter = true;
    LocalVarDsc *   scope;
    LocalVarDsc *   nextExitScope = NULL, * nextEnterScope = NULL;
    unsigned        offs = offset, curEnterOffs = 0;

    goto START_FINDING_SCOPES;

    // We need to determine the scopes which are open for the current block.
    // This loop walks over the missing blocks between the current and the
    // previous block, keeping the enter and exit offsets in lockstep.

    do
    {
        foundExit = foundEnter = false;

        if (nextExitScope)
        {
            exitScopeFn (nextExitScope, clientData);
            nextExitScope   = NULL;
            foundExit       = true;
        }

        offs = nextEnterScope ? nextEnterScope->lvdLifeBeg : offset;

        for(scope = compGetNextExitScope(offs, true); scope; scope = compGetNextExitScope(offs, true))
        {
            foundExit = true;

            if (!nextEnterScope || scope->lvdLifeEnd > nextEnterScope->lvdLifeBeg)
            {
                // We overshot the last found Enter scope. Save the scope for later
                // and find an entering scope

                nextExitScope = scope;
                break;
            }

            exitScopeFn (scope, clientData);
        }


        if (nextEnterScope)
        {
            enterScopeFn (nextEnterScope, clientData);
            curEnterOffs    = nextEnterScope->lvdLifeBeg;
            nextEnterScope  = NULL;
            foundEnter      = true;
        }

        offs = nextExitScope ? nextExitScope->lvdLifeEnd : offset;

START_FINDING_SCOPES :

        for(scope = compGetNextEnterScope(offs, true); scope; scope = compGetNextEnterScope(offs, true))
        {
            foundEnter = true;

            if (  (nextExitScope  && scope->lvdLifeBeg >= nextExitScope->lvdLifeEnd)
               || (scope->lvdLifeBeg > curEnterOffs) )
            {
                // We overshot the last found exit scope. Save the scope for later
                // and find an exiting scope

                nextEnterScope = scope;
                break;
            }

            enterScopeFn (scope, clientData);

            if (!nextExitScope)
            {
                curEnterOffs = scope->lvdLifeBeg;
            }
        }
    }
    while (foundExit || foundEnter);
}


/*****************************************************************************/
#endif // DEBUGGING_SUPPORT
/*****************************************************************************/
/*****************************************************************************/

// Compile a single method

int FASTCALL  jitNativeCode ( CORINFO_METHOD_HANDLE     methodHnd,
                              CORINFO_MODULE_HANDLE      classPtr,
                              COMP_HANDLE       compHnd,
                              CORINFO_METHOD_INFO*  methodInfo,
                              void *          * methodCodePtr,
                              SIZE_T          * methodCodeSize,
                              void *          * methodConsPtr,
                              void *          * methodDataPtr,
                              void *          * methodInfoPtr,
                              unsigned          compileFlags
                              )
{

    bool jitFallbackCompile = false;
START:
    int                 result        = CORJIT_INTERNALERROR;

    norls_allocator *   pAlloc;
    norls_allocator *   pTheAllocator = nraGetTheAllocator();
    norls_allocator     alloc;

    // Can we use the pre-inited allocator ?

    if (pTheAllocator)
    {
        pAlloc = pTheAllocator;
    }
    else
    {
        bool res = alloc.nraInit();
        if  (res) return CORJIT_OUTOFMEM;

        pAlloc = &alloc;
    }

    setErrorTrap() 
    {

        setErrorTrap()
        {
            // Allocate an instance of Compiler and initialize it

            Compiler * pComp = (Compiler *)pAlloc->nraAlloc(roundUp(sizeof(*pComp)));
            assert(pComp);
            pComp->compInit(pAlloc);

#ifdef DEBUG
            pComp->jitFallbackCompile = jitFallbackCompile;
#endif
            // Now generate the code
            result = pComp->compCompile(methodHnd,
                                        classPtr,
                                        compHnd,
                                        methodInfo,
                                        methodCodePtr,
                                        methodCodeSize,
                                        methodConsPtr,
                                        methodDataPtr,
                                        methodInfoPtr,
                                        compileFlags);            
        }
        finallyErrorTrap() 
        {
            // Now free up whichever allocator we were using
            if (pTheAllocator)
            {
                nraFreeTheAllocator();
            }
            else
            {
                alloc.nraFree();
            }
        }
        endErrorTrap()
    }
    impJitErrorTrap()
    {
        result              = __errc;                
    }
    endErrorTrap()


    if (result != CORJIT_OK && 
        result != CORJIT_BADCODE && 
        result != CORJIT_SKIPPED &&
        !jitFallbackCompile)
    {
        // If we failed the JIT, reattempt with debuggable code.
        jitFallbackCompile = true;

        // Update the flags for 'safer' code generation.
        compileFlags |= CORJIT_FLG_DEBUG_OPT;
        compileFlags &= ~(CORJIT_FLG_SIZE_OPT | CORJIT_FLG_SPEED_OPT);

        goto START;
    }
    return result;
}

/*****************************************************************************/
/*****************************************************************************/


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          jvc                                              XX
XX                                                                           XX
XX  Functions for the stand-alone version of the JIT .                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/
/*****************************************************************************/
void                codeGeneratorCodeSizeBeg(){}
/*****************************************************************************/
#if     REGVAR_CYCLES || TOTAL_CYCLES
#pragma warning( disable : 4035 )       // turn off "no return value" warning

__inline unsigned GetCycleCount32 ()    // enough for about 40 seconds
{
    __asm   push    EDX
    __asm   _emit   0x0F
    __asm   _emit   0x31    /* rdtsc */
    __asm   pop     EDX
    // return EAX       implied return causes annoying warning
};

#pragma warning( default : 4035 )
#endif

/*****************************************************************************
 *
 *  If any temporary tables are smaller than 'genMinSize2free' we won't bother
 *  freeing them.
 */

const
size_t              genMinSize2free = 64;

/*****************************************************************************/

#if COUNT_OPCODES

struct  opcCnt
{
    unsigned            ocNum;
    unsigned            ocCnt;
};

static
opcCnt              genOpcodeCnt[OP_Count];

static
int __cdecl         genOpcCntCmp(const void *op1, const void *op2)
{
    int             dif;

    dif = ((opcCnt *)op2)->ocCnt -
          ((opcCnt *)op1)->ocCnt;

    if  (dif) return dif;

    dif = ((opcCnt *)op1)->ocNum -
          ((opcCnt *)op2)->ocNum;

    return dif;
}

#endif



/*****************************************************************************
 *
 *  Used for counting pointer assignments.
 */

#if GEN_COUNT_PTRASG
unsigned            ptrAsgCount;
#endif

/*****************************************************************************/
/*****************************************************************************/
void                codeGeneratorCodeSizeEnd(){}
/*****************************************************************************
 *
 *  The following structure describes a single global variable.
 */

struct JIT_CG_Global
{
    void *              addr;
    size_t              size;
};

/*****************************************************************************
 *
 *  Declaration of global variables.
 *
 */

#define DeclareGlobal(name) { &name, sizeof(name) }

/*****************************************************************************
 *
 *  Declare all global variables that need to be preserved across
 *
 */
struct JIT_CG_Global genGlobals[] =
{
    NULL, 0,

    // @TODO [REVISIT] [04/16/01] []: These dont seem to be per method. So why are they here?

#if DISPLAY_SIZES
    DeclareGlobal(grossVMsize),
    DeclareGlobal(grossNCsize),
    DeclareGlobal(totalNCsize),
#endif

};


/*****************************************************************************
 *
 *  Gather statistics - mainly used for the standalone
 *  Enable various #ifdef's to get the information you need
 */

void            Compiler::compJitStats()
{
#if CALL_ARG_STATS

    /* Method types and argument statistics */
    compCallArgStats();
#endif
}

#if CALL_ARG_STATS

/*****************************************************************************
 *
 *  Gather statistics about method calls and arguments
 */

void            Compiler::compCallArgStats()
{
    GenTreePtr      args;
    GenTreePtr      argx;

    BasicBlock  *   block;
    GenTreePtr      stmt;
    GenTreePtr      call;

    unsigned        argNum;

    unsigned        argDWordNum;
    unsigned        argLngNum;
    unsigned        argFltNum;
    unsigned        argDblNum;

    unsigned        regArgNum;
    unsigned        regArgDeffered;
    unsigned        regArgTemp;

    unsigned        regArgLclVar;
    unsigned        regArgConst;

    unsigned        argTempsThisMethod = 0;

    assert(fgStmtListThreaded);

    for (block = fgFirstBB; block; block = block->bbNext)
    {
        for (stmt = block->bbTreeList; stmt; stmt = stmt->gtNext)
        {
            assert(stmt->gtOper == GT_STMT);

            for (call = stmt->gtStmt.gtStmtList; call; call = call->gtNext)
            {

                if  (call->gtOper != GT_CALL)
                    continue;

                argNum      =

                regArgNum   =
                regArgDeffered =
                regArgTemp  =

                regArgConst =
                regArgLclVar=

                argDWordNum =
                argLngNum   =
                argFltNum   =
                argDblNum   = 0;

                argTotalCalls++;

                if (!call->gtCall.gtCallObjp)
                {
                    if  (call->gtCall.gtCallType == CT_HELPER)
                        argHelperCalls++;
                    else
                        argStaticCalls++;
                }
                else
                {
                    /* We have a 'this' pointer */

                    argDWordNum++;
                    argNum++;
                    regArgNum++;
                    regArgDeffered++;
                    argTotalObjPtr++;

                    if (call->gtFlags & (GTF_CALL_VIRT|GTF_CALL_INTF|GTF_CALL_VIRT_RES))
                    {
                        /* virtual function */
                        argVirtualCalls++;
                    }
                    else
                    {
                        argNonVirtualCalls++;
                    }
                }

                /* Gather arguments information */

                for (args = call->gtCall.gtCallArgs; args; args = args->gtOp.gtOp2)
                {
                    argx = args->gtOp.gtOp1;

                    argNum++;

                    switch(genActualType(argx->TypeGet()))
                    {
                    case TYP_INT:
                    case TYP_REF:
                    case TYP_BYREF:
                        argDWordNum++;
                        break;

                    case TYP_LONG:
                        argLngNum++;
                        break;

                    case TYP_FLOAT:
                        argFltNum++;
                        break;

                    case TYP_DOUBLE:
                        argDblNum++;
                        break;
                    case TYP_VOID:
                        /* This is a deffered register argument */
                        assert(argx->gtOper == GT_NOP);
                        assert(argx->gtFlags & GTF_REG_ARG);
                        argDWordNum++;
                        break;
                    }

                    /* Is this argument a register argument? */

                    if  (argx->gtFlags & GTF_REG_ARG)
                    {
                        regArgNum++;

                        /* We either have a defered argument or a temp */

                        if  (argx->gtOper == GT_NOP)
                            regArgDeffered++;
                        else
                        {
                            assert(argx->gtOper == GT_ASG);
                            regArgTemp++;
                        }
                    }
                }

                /* Look at the register arguments and count how many constants, local vars */

                for (args = call->gtCall.gtCallRegArgs; args; args = args->gtOp.gtOp2)
                {
                    argx = args->gtOp.gtOp1;

                    switch(argx->gtOper)
                    {
                    case GT_CNS_INT:
                        regArgConst++;
                        break;

                    case GT_LCL_VAR:
                        regArgLclVar++;
                        break;
                    }
                }

                assert(argNum == argDWordNum + argLngNum + argFltNum + argDblNum);
                assert(regArgNum == regArgDeffered + regArgTemp);

                argTotalArgs      += argNum;
                argTotalRegArgs   += regArgNum;

                argTotalDWordArgs += argDWordNum;
                argTotalLongArgs  += argLngNum;
                argTotalFloatArgs += argFltNum;
                argTotalDoubleArgs+= argDblNum;

                argTotalDeffered  += regArgDeffered;
                argTotalTemps     += regArgTemp;
                argTotalConst     += regArgConst;
                argTotalLclVar    += regArgLclVar;

                argTempsThisMethod+= regArgTemp;

                argCntTable.histoRec(argNum, 1);
                argDWordCntTable.histoRec(argDWordNum, 1);
                argDWordLngCntTable.histoRec(argDWordNum + 2*argLngNum, 1);
            }
        }
    }

    argTempsCntTable.histoRec(argTempsThisMethod, 1);

    if (argMaxTempsPerMethod < argTempsThisMethod)
        argMaxTempsPerMethod = argTempsThisMethod;
    if (argTempsThisMethod > 10)
        printf("Function has %d temps\n", argTempsThisMethod);
}


void            Compiler::compDispCallArgStats()
{
    if (argTotalCalls == 0) return;

    printf("--------------------------------------------------\n");
    printf("Total # of calls = %d, calls / method = %.3f\n\n", argTotalCalls, (float) argTotalCalls / genMethodCnt);

    printf("Percentage of      helper calls = %4.2f %%\n", (float)(100 * argHelperCalls) / argTotalCalls);
    printf("Percentage of      static calls = %4.2f %%\n", (float)(100 * argStaticCalls) / argTotalCalls);
    printf("Percentage of     virtual calls = %4.2f %%\n", (float)(100 * argVirtualCalls) / argTotalCalls);
    printf("Percentage of non-virtual calls = %4.2f %%\n\n", (float)(100 * argNonVirtualCalls) / argTotalCalls);

    printf("Average # of arguments per call = %.2f%\n\n", (float) argTotalArgs / argTotalCalls);

    printf("Percentage of DWORD  arguments   = %.2f %%\n", (float)(100 * argTotalDWordArgs) / argTotalArgs);
    printf("Percentage of LONG   arguments   = %.2f %%\n", (float)(100 * argTotalLongArgs) / argTotalArgs);
    printf("Percentage of FLOAT  arguments   = %.2f %%\n", (float)(100 * argTotalFloatArgs) / argTotalArgs);
    printf("Percentage of DOUBLE arguments   = %.2f %%\n\n", (float)(100 * argTotalDoubleArgs) / argTotalArgs);

    if (argTotalRegArgs == 0) return;

/*
    printf("Total deffered arguments     = %d \n", argTotalDeffered);

    printf("Total temp arguments         = %d \n\n", argTotalTemps);

    printf("Total 'this' arguments       = %d \n", argTotalObjPtr);
    printf("Total local var arguments    = %d \n", argTotalLclVar);
    printf("Total constant arguments     = %d \n\n", argTotalConst);
*/

    printf("\nRegister Arguments:\n\n");

    printf("Percentage of defered arguments  = %.2f %%\n",   (float)(100 * argTotalDeffered) / argTotalRegArgs);
    printf("Percentage of temp arguments     = %.2f %%\n\n", (float)(100 * argTotalTemps)    / argTotalRegArgs);

    printf("Maximum # of temps per method    = %d\n\n", argMaxTempsPerMethod);

    printf("Percentage of ObjPtr arguments   = %.2f %%\n",   (float)(100 * argTotalObjPtr) / argTotalRegArgs);
    //printf("Percentage of global arguments   = %.2f %%\n", (float)(100 * argTotalDWordGlobEf) / argTotalRegArgs);
    printf("Percentage of constant arguments = %.2f %%\n",   (float)(100 * argTotalConst) / argTotalRegArgs);
    printf("Percentage of lcl var arguments  = %.2f %%\n\n", (float)(100 * argTotalLclVar) / argTotalRegArgs);

    printf("--------------------------------------------------\n");
    printf("Argument count frequency table (includes ObjPtr):\n");
    printf("--------------------------------------------------\n");
    argCntTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("DWORD argument count frequency table (w/o LONG):\n");
    printf("--------------------------------------------------\n");
    argDWordCntTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("Temps count frequency table (per method):\n");
    printf("--------------------------------------------------\n");
    argTempsCntTable.histoDsp();
    printf("--------------------------------------------------\n");

/*
    printf("--------------------------------------------------\n");
    printf("DWORD argument count frequency table (w/ LONG):\n");
    printf("--------------------------------------------------\n");
    argDWordLngCntTable.histoDsp();
    printf("--------------------------------------------------\n");
*/
}

#endif // CALL_ARG_STATS

/*****************************************************************************/
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\disasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***********************************************************************
*
* File: dis.cpp
*
* File Comments:
*
*  This file handles disassembly. It is adapted from the MS linker.
*
***********************************************************************/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/
#ifdef      LATE_DISASM
#if         TGT_x86
/*****************************************************************************/

#define _OLD_IOSTREAMS
#include "msdis.h"
#include "disx86.h"

/*****************************************************************************/

#undef  eeGetFieldName
#undef  eeGetMethodName
#undef  eeFindField
#define eeFindField             pDisAsm->disComp->eeFindField
#define eeGetFieldName          pDisAsm->disComp->eeGetFieldName
#define eeGetMethodName         pDisAsm->disComp->eeGetMethodName
#define MAX_CLASSNAME_LENGTH    1024


/* static */
FILE *              DisAssembler::s_disAsmFile = 0;

/*****************************************************************************/

void                DisAssembler::disInit(Compiler * pComp)
{
    assert(pComp);
    disComp         = pComp;
    disHasName      = 0;
    disJumpTarget   = NULL;
}

/*****************************************************************************/


static
size_t __stdcall    disCchAddr(const DIS * pdis,   DWORD addr, char * sz,
                                size_t cchMax,  DWORDLONG * pdwDisp);
static
size_t __stdcall    disCchFixup(const DIS * pdis,  DWORD addr, size_t callSize,
                                char * sz, size_t cchMax, DWORDLONG * pdwDisp);
static
size_t __stdcall    disCchRegRel(const DIS * pdis, DIS::REGA reg,
                                 DWORD disp, char * sz, size_t cchMax,
                                 DWORD * pdwDisp);
static
size_t __stdcall    disCchReg(const DIS * pdis, enum DIS::REGA reg,
                                          char * sz, size_t cchMax);

/*****************************************************************************
 * Given an absolute address from the beginning of the code
 * find the corresponding emitter block and the relative offset
 * of the current address in that block
 * Was used to get to the fixup list of each block. The new emitter has
 * no such fixups. Something needs to be added for this.
 */

// These structs were defined in emit.h. Fake them here so DisAsm.cpp can compile

typedef struct codeFix
{   codeFix  * cfNext;
    unsigned cfFixup;
}
             * codeFixPtr;

typedef struct codeBlk
{   codeFix  * cbFixupLst;  }
             * codeBlkPtr;

/*****************************************************************************
 *
 * The following is the callback for jump label and direct function calls fixups
 * "addr" represents the address of jump that has to be
 * replaced with a label or function name
 */

size_t __stdcall disCchAddr(const DIS * pdis,   DIS::ADDR addr, char * sz,
                                                        size_t cchMax,  DWORDLONG * pdwDisp)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    DIS::TRMTA terminationType;
    int disCallSize;

    /* First check the termination type of the instruction
     * because this might be a helper or static function call
     * check to see if we have a fixup for the current address */

    terminationType = pdis->Trmta();
    switch (terminationType)
    {
    case DISX86::trmtaJmpShort:
    case DISX86::trmtaJmpCcShort:

        /* here we have a short jump in the current code block - generate the label to which we jump */

        sprintf(sz, "short L_%02u", pDisAsm->disJumpTarget[pDisAsm->target]);
        break;

    case DISX86::trmtaJmpNear:
    case DISX86::trmtaJmpCcNear:

        /* here we have a near jump - check if is in the current code block
         * Otherwise is we have no target for it */

        if (pDisAsm->target <  pDisAsm->codeSize && pDisAsm->target >= 0)
        {
           sprintf(sz, "L_%02u", pDisAsm->disJumpTarget[pDisAsm->target]);
           break;
        }
        else
            return false;

    case DISX86::trmtaCallNear16:
    case DISX86::trmtaCallNear32:

        /* check for local calls (i.e. CALL label) */

        if (pDisAsm->target < pDisAsm->codeSize && pDisAsm->target >= 0)
        {
            {
                /* not a "call ds:[0000]" - go ahead */
                /* target within block boundary -> local call */

                sprintf(sz, "short L_%02u", pDisAsm->disJumpTarget[pDisAsm->target]);
                break;
            }
        }

        /* this is a near call - in our case usually VM helper functions */

        /* find the emitter block and the offset of the call fixup */
        /* for the fixup offset we have to add the opcode size for the call - in the case of a near call is 1 */

        disCallSize = 1;

        return false;

    default:

        printf("Termination type is %d\n", (int) terminationType);
        assert(!"treat this case\n");
        break;
    }

    /* no displacement */

    *pdwDisp = 0x0;

    return true;
}



/*****************************************************************************
 *
 * We annotate some instructions to get info needed to display the symbols
 * for that instruction
 */

size_t __stdcall disCchFixup(const DIS * pdis,  DIS::ADDR addr, size_t callSize,
                             char * sz, size_t cchMax, DWORDLONG * pdwDisp)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    DIS::TRMTA terminationType;
    //DIS::ADDR disIndAddr;
    int disCallSize;

    terminationType = pdis->Trmta();
    switch (terminationType)
    {
    case DISX86::trmtaFallThrough:

        /* memory indirect case */

        assert(addr > pdis->Addr());

        /* find the emitter block and the offset for the fixup
         * "addr" is the address of the immediate */

        return false;

    case DISX86::trmtaJmpInd:

        /* pretty rare case - something like "jmp [eax*4]"
         * not a function call or anything worth annotating */

        return false;

        case DISX86::trmtaJmpShort:
        case DISX86::trmtaJmpCcShort:

        case DISX86::trmtaJmpNear:
        case DISX86::trmtaJmpCcNear:

        case DISX86::trmtaCallNear16:
        case DISX86::trmtaCallNear32:

        /* these are treated by the CchAddr callback - skip them */

        return false;

    case DISX86::trmtaCallInd:

        /* here we have an indirect call - find the indirect address */

        //BYTE * code = (BYTE *) (pDisAsm->codeBlock+addr);
        //disIndAddr = (DIS::ADDR) (code+0);

        /* find the size of the call opcode - less the immediate */
        /* for the fixup offset we have to add the opcode size for the call */
        /* addr is the address of the immediate, pdis->Addr() returns the address of the dissasembled instruction */

        assert(addr > pdis->Addr());
        disCallSize = addr - pdis->Addr();

        /* find the emitter block and the offset of the call fixup */

        return false;

    default:

        printf("Termination type is %d\n", (int) terminationType);
        assert(!"treat this case\n");
        break;
    }

    /* no displacement */

    *pdwDisp = 0x0;

    return true;
}



/*****************************************************************************
 *
 * This the callback for register-relative operands in an instruction.
 * If the register is ESP or EBP, the operand may be a local variable
 * or a parameter, else the operand may be an instance variable
 */

size_t __stdcall disCchRegRel(const DIS * pdis, DIS::REGA reg, DWORD disp,
               char * sz, size_t cchMax, DWORD * pdwDisp)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    DIS::TRMTA terminationType;
    //DIS::ADDR disIndAddr;
    int disOpcodeSize;
    const char * var;


    terminationType = pdis->Trmta();
    switch (terminationType)
    {
    case DISX86::trmtaFallThrough:

        /* some instructions like division have a TRAP termination type - ignore it */

    case DISX86::trmtaTrap:
    case DISX86::trmtaTrapCc:

        var = pDisAsm->disComp->siStackVarName(
                                    pdis->Addr() - pDisAsm->startAddr,
                                    pdis->Cb(),
                                    reg,
                                    disp );
        if (var)
        {
            sprintf (sz, "%s+%Xh '%s'", getRegName(reg), disp, var);
            *pdwDisp = 0;

            return true;
        }

        /* This case consists of non-static members */

        /* find the emitter block and the offset for the fixup
         * fixup is emited after the coding of the instruction - size = word (2 bytes)
         * GRRRR!!! - for the 16 bit case we have to check for the address size prefix = 0x66
         */

        if (*((BYTE *)(pDisAsm->codeBlock + pDisAsm->curOffset)) == 0x66)
        {
            disOpcodeSize = 3;
        }
        else
        {
            disOpcodeSize = 2;
        }

        return false;

    case DISX86::trmtaCallNear16:
    case DISX86::trmtaCallNear32:
    case DISX86::trmtaJmpInd:

        break;

    case DISX86::trmtaCallInd:

        /* check if this is a one byte displacement */

        if  ((signed char)disp == (int)disp)
        {
            /* we have a one byte displacement -> there were no previous callbacks */

            /* find the size of the call opcode - less the immediate */
            /* this is a call R/M indirect -> opcode size is 2 */

            disOpcodeSize = 2;

            /* find the emitter block and the offset of the call fixup */

            return false;
        }
        else
        {
            /* check if we already have a symbol name as replacement */

            if (pDisAsm->disHasName)
            {
                /* CchFixup has been called before - we have a symbol name saved in global var pDisAsm->funcTempBuf */

                sprintf(sz, "%s+%u '%s'", getRegName(reg), disp, pDisAsm->funcTempBuf);
                *pdwDisp = 0;
                pDisAsm->disHasName = false;
                return true;
            }
            else                
                return false;
        }

    default:

        printf("Termination type is %d\n", (int) terminationType);
        assert(!"treat this case\n");

        break;
    }

    /* save displacement */

    *pdwDisp = disp;

    return true;
}



/*****************************************************************************
 *
 * Callback for register operands. Most probably, this is a local variable or
 * a parameter
 */

size_t __stdcall disCchReg(const DIS * pdis, enum DIS::REGA reg,
               char * sz, size_t cchMax)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    const char * var = pDisAsm->disComp->siRegVarName(
                                            pdis->Addr() - pDisAsm->startAddr,
                                            pdis->Cb(),
                                            reg);

    if (var)
    {
        if(pDisAsm->disHasName)
        {
            /* CchRegRel has been called before - we have a symbol name saved in global var pDisAsm->funcTempBuf */

            sprintf(sz, "%s'%s.%s'", getRegName(reg), var, pDisAsm->funcTempBuf);
            pDisAsm->disHasName = false;
            return true;
        }
        else
        {
            sprintf(sz, "%s'%s'", getRegName(reg), var);
            return true;
        }
    }
    else
    {
        if(pDisAsm->disHasName)
        {
            /* this is the ugly case when a varible is incorrectly presumed dead */

            sprintf(sz, "%s'%s.%s'", getRegName(reg), "<InstVar>", pDisAsm->funcTempBuf);
            pDisAsm->disHasName = false;
            return true;

        }

        /* just to make sure I don't screw up if var returns NULL */
        pDisAsm->disHasName = false;
        return false;
    }
}



/*****************************************************************************
 *
 */

size_t CbDisassemble(DIS *          pdis,
                     unsigned       offs,
                     DIS::ADDR      addr,
                     const BYTE *   pb,
                     size_t         cbMax,
                     FILE       *   pfile,
                     int            findJumps,
                     int            printit         = 0,
                     int            dispOffs        = 0,
                     bool           dispCodeBytes   = false)
{
    assert(pdis);
    DisAssembler * pDisAsm = (DisAssembler *)pdis->PvClient();
    assert (pDisAsm);

    size_t cb = pdis->CbDisassemble(addr, pb, cbMax);

    if (cb == 0)
    {
        assert(!"can't disassemble instruction!!!");
        fprintf(pfile, "%02Xh\n", *pb);
        return(1);
    }

    /* remember current offset and instruction size */

    pDisAsm->curOffset = addr;
    pDisAsm->instSize = cb;

    /* Check if instruction is a jump or local call */

    pDisAsm->target = pdis->AddrTarget();

    if (findJumps)
    {
    if (pDisAsm->target)
    {

        /* check the termination type of the instruction */

        DIS::TRMTA terminationType = pdis->Trmta();

        switch (terminationType)
        {
        case DISX86::trmtaCallNear16:
        case DISX86::trmtaCallNear32:

        /* fall through */

        case DISX86::trmtaJmpShort:
        case DISX86::trmtaJmpNear:
        case DISX86::trmtaJmpCcShort:
        case DISX86::trmtaJmpCcNear:

            /* a CALL is local iff the target is within the block boundary */

            /* mark the jump label in the target vector and return */

            if (pDisAsm->target <  pDisAsm->codeSize && pDisAsm->target >= 0)
            {
                /* we're OK, target within block boundary */

                pDisAsm->disJumpTarget[pDisAsm->target] = 1;
            }
            break;

        case DISX86::trmtaJmpInd:
        case DISX86::trmtaJmpFar:
        case DISX86::trmtaCallFar:
        default:

            /* jump is not in the current code block */
        break;
        }

    } // end if
    return cb;

    } // end for

    /* check if we have a label here */

    if (printit)
    {
        if (pDisAsm->disJumpTarget[addr])
        {
            /* print the label and the offset */

//          fprintf(pfile, "\n%08x", addr);
            fprintf(pfile, "L_%02u:\n", pDisAsm->disJumpTarget[addr]);
        }
    }

    char sz[MAX_CLASSNAME_LENGTH];
    pdis->CchFormatInstr(sz, sizeof(sz));

    if (printit)
    {
        if (dispOffs) fprintf(pfile, "%03X", offs);

        #define BYTES_OR_INDENT  24

        size_t cchIndent = BYTES_OR_INDENT;

        if (dispCodeBytes)
        {
            static size_t cchBytesMax = pdis->CchFormatBytesMax();

            char   szBytes[MAX_CLASSNAME_LENGTH];
            assert(cchBytesMax < MAX_CLASSNAME_LENGTH);

            size_t cchBytes = pdis->CchFormatBytes(szBytes, sizeof(szBytes));

            if (cchBytes > BYTES_OR_INDENT)
            {
                // Truncate the bytes if they are too long

                static int elipses = *(int*)"...";

                *(int*)&szBytes[BYTES_OR_INDENT-sizeof(int)] = elipses;

                cchBytes = BYTES_OR_INDENT;
            }

            fprintf(pfile, "  %s", szBytes);

            cchIndent = BYTES_OR_INDENT - cchBytes;
        }

        // print the dis-assembled instruction

        fprintf(pfile, "%*c%s\n", cchIndent, ' ', sz);
    }

    return cb;
}



size_t CbDisassembleWithBytes(
                  DIS        * pdis,
                  DIS::ADDR    addr,
                  const BYTE * pb,
                  size_t       cbMax,
                  FILE       * pfile)
{
    assert(pdis);
    DisAssembler * pDisAsm = (DisAssembler *)pdis->PvClient();
    assert (pDisAsm);

    char sz[MAX_CLASSNAME_LENGTH];

    pdis->CchFormatAddr(addr, sz, sizeof(sz));
    size_t cchIndent = (size_t) fprintf(pfile, "  %s: ", sz);

    size_t cb = pdis->CbDisassemble(addr, pb, cbMax);

    if (cb == 0)
    {
        fprintf(pfile, "%02Xh\n", *pb);
        return(1);
    }

    size_t cchBytesMax = pdis->CchFormatBytesMax();

    if (cchBytesMax > 18)
    {
        // Limit bytes coded to 18 characters

        cchBytesMax = 18;
    }

    char szBytes[64];
    size_t cchBytes = pdis->CchFormatBytes(szBytes, sizeof(szBytes));

    char *pszBytes;
    char *pszNext;

    for (pszBytes = szBytes; pszBytes != NULL; pszBytes = pszNext)
    {
        BOOL fFirst = (pszBytes == szBytes);

        cchBytes = strlen(pszBytes);

        if (cchBytes <= cchBytesMax)
        {
            pszNext = NULL;
        }

        else
        {
            char ch = pszBytes[cchBytesMax];
            pszBytes[cchBytesMax] = '\0';

            if (ch == ' ')
            {
                pszNext = pszBytes + cchBytesMax + 1;
            }

            else
            {
                pszNext = strrchr(pszBytes, ' ');
                assert(pszNext);

                pszBytes[cchBytesMax] = ch;
                *pszNext++ = '\0';
            }
        }

        if (fFirst)
        {
            pdis->CchFormatInstr(sz, sizeof(sz));
            fprintf(pfile, "%-*s %s\n", cchBytesMax, pszBytes, sz);
        }

        else
        {
            fprintf(pfile, "%*c%s\n", cchIndent, ' ', pszBytes);
        }
    }

    return(cb);
}


void DisAssembler::DisasmBuffer(DWORD         addr,
                                const BYTE *  rgb,
                                DWORD         cbBuffer,
                                FILE  *       pfile,
                                int           printit)
{
    DIS *pdis;

    pdis = DIS::PdisNew(DIS::distX86);

    if (pdis == NULL)
    {
        assert(!"out of memory in disassembler?");
    }

    // Store a pointer to the DisAssembler so that the callback functions
    // can get to it.

    pdis->PvClientSet((void*)this);

    /* Calculate addresses */

    IL_OFFSET   ibCur   = 0;
    const BYTE *pb      = rgb;

    startAddr   = addr;
    codeBlock   = (DIS::ADDR) rgb;
    codeSize    = cbBuffer;

    /* First walk the code to find all jump targets */

    while (ibCur < cbBuffer)
    {
        size_t  cb;
        int     findJumps = 1;

        cb = CbDisassemble(pdis,
                           ibCur,
                           addr + ibCur,
                           pb,
                           (size_t) (cbBuffer-ibCur),
                           pfile,
                           findJumps,
                           0,
                           0);

        ibCur += cb;
        pb    += cb;
    }

    /* reset the label counter and start assigning consecutive number labels to the target locations */

    label = 0;
    for(unsigned i = 0; i < codeSize; i++)
    {
        if (disJumpTarget[i] != 0)
        {
            disJumpTarget[i] = ++label;
        }
    }

    /* Re-initialize addresses for dissasemble phase */

    ibCur = 0;
    pb = rgb;

    // Set callbacks only if we are displaying it. Else, the scheduler has called it

    if (printit)
    {
        /* Set the callback functions for symbol lookup */

        pdis->PfncchaddrSet(disCchAddr);
        pdis->PfncchfixupSet(disCchFixup);
        pdis->PfncchregrelSet(disCchRegRel);
        pdis->PfncchregSet(disCchReg);
    }

    while (ibCur < cbBuffer)
    {
        size_t cb;


        cb = CbDisassemble (pdis,
                            ibCur,
                            addr + ibCur,
                            pb,
                            (size_t) (cbBuffer-ibCur),
                            pfile,
                            0,
                            printit,
                            verbose||1,  // display relative offset
                            dspEmit);
        ibCur += cb;
        pb += cb;
    }

    delete pdis;
}


/*****************************************************************************
 *
 * Disassemble the code which has been generated
 */

void    DisAssembler::disAsmCode(BYTE * codePtr, unsigned size)
{
    // As this writes to a common file, this is not reentrant.

    FILE * pfile;

    pfile = s_disAsmFile;
    fprintf(pfile, "Base address : %08Xh\n", codePtr);

    if (disJumpTarget == NULL) 
    {
        disJumpTarget = (BYTE *)disComp->compGetMem(roundUp(size));
    }

    /* Re-initialize the jump target vector */
    memset(disJumpTarget, 0, roundUp(size));

    DisasmBuffer(0, codePtr, size, pfile, 1);
    fprintf (pfile, "\n");

    if (pfile != stdout) fclose (pfile);

}



/*****************************************************************************/
// This function is called for every method. Checks if the method name
// matches the registry setting for dis-assembly

void                disOpenForLateDisAsm(const char * curClassName,
                                         const char * curMethodName)
{
    static ConfigString fJITLateDisasmTo(L"JITLateDisasmTo");

    LPWSTR fileName = fJITLateDisasmTo.val();
    if (fileName != 0)
        DisAssembler::s_disAsmFile = _wfopen (fileName, L"a+");

    if (!DisAssembler::s_disAsmFile)
        DisAssembler::s_disAsmFile  = stdout;

    fprintf(DisAssembler::s_disAsmFile, "************************** %s.%s "
                                        "**************************\n\n",
                                        curClassName, curMethodName);
}




/*****************************************************************************/
#endif //LATE_DISASM
#endif //TGT_x86
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\compiler.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                    Inline functions                                       XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#ifndef _COMPILER_HPP_
#define _COMPILER_HPP_

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX  Miscellaneous utility functions. Some of these are defined in Utils.cpp  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
/*****************************************************************************/

enum SchedCode
{
    NO_SCHED        = 0,    // Dont schedule the code at all
    CAN_SCHED       = 1,    // Schedule the code if it seems useful
    MUST_SCHED      = 2,    // Have to schedule the code (where possible)
    RANDOM_SCHED    = 3,    // Randomly pick methods for scheduling (code-coverage for both cases)

    COUNT_SCHED,
    DEFAULT_SCHED = CAN_SCHED
};

inline
SchedCode            getSchedCode()
{
#ifdef DEBUG
    static ConfigDWORD fJITSched(L"JITSched", DEFAULT_SCHED);
    SchedCode ret = (SchedCode) fJITSched.val();
    if (ret < NO_SCHED || ret >= COUNT_SCHED)
        ret = DEFAULT_SCHED;
    return ret;
#else
    return DEFAULT_SCHED;
#endif
}

inline
bool                 getInlinePInvokeEnabled()
{
#ifdef DEBUG
    static ConfigDWORD fJITPInvokeEnabled(L"JITPInvokeEnabled", 1);
    static ConfigDWORD fStressCOMCall(L"StressCOMCall", 0);

    return fJITPInvokeEnabled.val() && !fStressCOMCall.val();
#else
    return true;
#endif
}

inline
bool                 getInlinePInvokeCheckEnabled()
{
#ifdef DEBUG
    static ConfigDWORD fJITPInvokeCheckEnabled(L"JITPInvokeCheckEnabled", 0);
    return fJITPInvokeCheckEnabled.val() != 0;
#else
    return false;
#endif
}


/*****************************************************************************
 *  Identity function used to force the compiler to spill a float value to memory
 *  in order to avoid some fpu inconsistency issues, for example
 *  
 *   fild DWORD PTR 
 *   fstp QWORD PTR
 *
 *  in a (double)((float) i32Integer) casting if the i32Integer cannot be 
 *  represented with a float and it can with a double
 *
 *  This function will force a 
 *
 *  fild DWORD PTR
 *  fstp DWORD PTR
 *  fld  DWORD PTR
 *  fstp QWORD PTR
 *
 *  when used like this (double)(forceFloatSpill((float) i32Integer))
 *  We use this in order to workaround a vc bug, when the bug is fixed
 *  the function won't be needed any more
 *
 *  
 */
float forceFloatSpill(float f);


enum RoundLevel
{
    ROUND_NEVER     = 0,    // Never round 
    ROUND_CMP_CONST = 1,    // Round values compared against constants
    ROUND_CMP       = 2,    // Round comparands and return values
    ROUND_ALWAYS    = 3,    // Round always

    COUNT_ROUND_LEVEL,
    DEFAULT_ROUND_LEVEL = ROUND_NEVER
};

inline
RoundLevel          getRoundFloatLevel()
{
#ifdef DEBUG
    static ConfigDWORD fJITRoundFloat(L"JITRoundFloat", DEFAULT_ROUND_LEVEL);
    return (RoundLevel) fJITRoundFloat.val();
#else
    return DEFAULT_ROUND_LEVEL;
#endif
}

/*****************************************************************************/
/*****************************************************************************
 *
 *  Return the lowest bit that is set in the given 64-bit number.
 */

inline
unsigned __int64    genFindLowestBit(unsigned __int64 value)
{
    return (value & -value);
}

/*****************************************************************************
 *
 *  Return the lowest bit that is set in the given 32-bit number.
 */

inline
unsigned            genFindLowestBit(unsigned  value)
{
    return (value & -value);
}

/*****************************************************************************
 *
 *  Return true if the given 64-bit value has exactly zero or one bits set.
 */

inline
BOOL                genMaxOneBit(unsigned __int64 value)
{
    return  (genFindLowestBit(value) == value);
}

/*****************************************************************************
 *
 *  Return true if the given 32-bit value has exactly zero or one bits set.
 */

inline
BOOL                genMaxOneBit(unsigned value)
{
    return  (genFindLowestBit(value) == value);
}

/*****************************************************************************
 *
 *  Given a value that has exactly one bit set, return the position of that
 *  bit, in other words return the logarithm in base 2 of the given value.
 */

inline 
unsigned            genLog2(unsigned value)
{
    assert (value && genMaxOneBit(value));

    /* Use a prime bigger than sizeof(unsigned int), which is not of the
       form 2^n-1. modulo with this will produce a unique hash for all
       powers of 2 (which is what "value" is).
       Entries in hashTable[] which are -1 should never be used. There
       should be PRIME-8*sizeof(value)* entries which are -1 .
     */

    const unsigned PRIME = 37;

    static const char hashTable[PRIME] =
    {
        -1,  0,  1, 26,  2, 23, 27, -1,  3, 16,
        24, 30, 28, 11, -1, 13,  4,  7, 17, -1,
        25, 22, 31, 15, 29, 10, 12,  6, -1, 21,
        14,  9,  5, 20,  8, 19, 18
    };

    assert(PRIME >= 8*sizeof(value));
    assert(sizeof(hashTable) == PRIME);

    unsigned hash   = unsigned(value % PRIME);
    unsigned index  = hashTable[hash];
    assert(index != (char)-1);

    return index;
}

/*****************************************************************************
 *
 *  Given a value that has exactly one bit set, return the position of that
 *  bit, in other words return the logarithm in base 2 of the given value.
 */

inline
unsigned            genLog2(unsigned __int64 value)
{
    unsigned lo32 = (unsigned)  value;
    unsigned hi32 = (unsigned) (value >> 32);

    if  (lo32 != 0)
    {
        assert(hi32 == 0);
        return  genLog2(lo32);
    }
    else
    {
        return  genLog2(hi32) + 32;
    }
}

/*****************************************************************************
 *
 *  Return the lowest bit that is set in the given register mask.
 */

inline
unsigned            genFindLowestReg(unsigned value)
{
    return  (unsigned)genFindLowestBit(value);
}

/*****************************************************************************
 *
 *  A rather stupid routine that counts the number of bits in a given number.
 */

inline
unsigned            genCountBits(VARSET_TP set)
{
    unsigned        cnt = 0;

    while (set)
    {
        cnt++;
        set -= genFindLowestBit(set);
    }

    return  cnt;
}

/*****************************************************************************/

inline
bool                jitIsScaleIndexMul(unsigned val)
{
    switch(val)
    {
    case 1:
    case 2:
    case 4:
    case 8:
        return true;

    default:
        return false;
    }
}

/*****************************************************************************
 * Returns true is offs is between [start..end)
 */

inline
bool                jitIsBetween(IL_OFFSET offs, IL_OFFSET start, IL_OFFSET end)
{
     return (offs >= start && offs < end);
}

inline
bool                jitIsProperlyBetween(IL_OFFSET offs, IL_OFFSET start, IL_OFFSET end)
{
     return (offs > start && offs < end);
}

/*****************************************************************************/

inline  IL_OFFSET   Compiler::ebdTryEndOffs(EHblkDsc * ehBlk)
{
    return ehBlk->ebdTryEnd ? ehBlk->ebdTryEnd->bbCodeOffs : info.compCodeSize;
}

inline unsigned     Compiler::ebdTryEndBlkNum(EHblkDsc * ehBlk)
{
    return ehBlk->ebdTryEnd ? ehBlk->ebdTryEnd->bbNum : fgBBcount;
}

inline IL_OFFSET    Compiler::ebdHndEndOffs(EHblkDsc * ehBlk)
{
    return ehBlk->ebdHndEnd ? ehBlk->ebdHndEnd->bbCodeOffs : info.compCodeSize;
}

inline unsigned     Compiler::ebdHndEndBlkNum(EHblkDsc * ehBlk)
{
    return ehBlk->ebdHndEnd ? ehBlk->ebdHndEnd->bbNum : fgBBcount;
}

inline
bool                Compiler::ebdIsSameTry(unsigned t1, unsigned t2)
{
    if (t1 == t2)
        return 1;

    assert(t1 <= info.compXcptnsCount);
    assert(t2 <= info.compXcptnsCount);

    EHblkDsc * h1 = compHndBBtab + t1;
    EHblkDsc * h2 = compHndBBtab + t2;

    return ((h1->ebdTryBeg == h2->ebdTryBeg) && 
            (h1->ebdTryEnd == h2->ebdTryEnd));
}

inline bool         Compiler::bbInFilterBlock(BasicBlock * blk)
{
    if (!blk->hasHndIndex())
        return false;

    EHblkDsc * HBtab = compHndBBtab + blk->getHndIndex();

    return ((HBtab->ebdFlags & CORINFO_EH_CLAUSE_FILTER) &&
            (jitIsBetween(blk->bbCodeOffs, 
                          HBtab->ebdFilter->bbCodeOffs, 
                          HBtab->ebdHndBeg->bbCodeOffs)));
}

/*****************************************************************************
 *
 *  Map a register mask to a register number
 */

inline
regNumber           genRegNumFromMask(regMaskTP mask)
{
    /* Convert the mask to a register number */

    assert(sizeof(regMaskTP) == sizeof(unsigned));

    regNumber       regNum = (regNumber) genLog2((unsigned)mask);

    /* Make sure we got it right */

    assert(genRegMask(regNum) == mask);

    return  regNum;
}

/*****************************************************************************
 *
 *  Return the size in bytes of the given type.
 */

extern const
BYTE                genTypeSizes[TYP_COUNT];

inline
size_t              genTypeSize(var_types type)
{
    assert(type < sizeof(genTypeSizes)/sizeof(genTypeSizes[0]));

    return genTypeSizes[type];
}

/*****************************************************************************
 *
 *  Return the "stack slot count" of the given type (i.e. returns 1 for 32-bit
 *  types and 2 for 64-bit types).
 */

extern const
BYTE                genTypeStSzs[TYP_COUNT];

inline
size_t              genTypeStSz(var_types type)
{
    assert(type < sizeof(genTypeStSzs)/sizeof(genTypeStSzs[0]));

    return genTypeStSzs[type];
}

/*****************************************************************************
 *
 *  Return the number of registers required to hold a value of the given type.
 */

#if TGT_RISC

extern
BYTE                genTypeRegst[TYP_COUNT];

inline
unsigned            genTypeRegs(var_types type)
{
    assert(type < sizeof(genTypeRegst)/sizeof(genTypeRegst[0]));
    assert(genTypeRegst[type] <= 2);

    return  genTypeRegst[type];
}

#endif

/*****************************************************************************
 *
 *  The following function maps a 'precise' type to an actual type as seen
 *  by the VM (for example, 'byte' maps to 'int').
 */

extern const
BYTE                genActualTypes[TYP_COUNT];

inline
var_types           genActualType(var_types type)
{
    /* Spot check to make certain the table is in synch with the enum */

    assert(genActualTypes[TYP_DOUBLE] == TYP_DOUBLE);
    assert(genActualTypes[TYP_FNC   ] == TYP_FNC);
    assert(genActualTypes[TYP_REF   ] == TYP_REF);

    assert(type < sizeof(genActualTypes));
    return (var_types)genActualTypes[type];
}

/*****************************************************************************/

inline
var_types           genUnsignedType(var_types type)
{
    /* Force signed types into corresponding unsigned type */

    switch (type)
    {
      case TYP_BYTE:    type = TYP_UBYTE;  break;
      case TYP_SHORT:   type = TYP_CHAR;   break;
      case TYP_INT:     type = TYP_UINT;   break;
      case TYP_LONG:    type = TYP_ULONG;  break;
      default:          break;
    }

    return type;
}

/*****************************************************************************/

inline
var_types           genSignedType(var_types type)
{
    /* Force non-small unsigned type into corresponding signed type */
    /* Note that we leave the small types alone */

    switch (type)
    {
      case TYP_UINT:    type = TYP_INT;    break;
      case TYP_ULONG:   type = TYP_LONG;   break;
      default:          break;
    }

    return type;
}

/*****************************************************************************/

inline
bool                isRegParamType(var_types type)
{
    return  (type <= TYP_INT ||
             type == TYP_REF ||
             type == TYP_BYREF);
}

/*****************************************************************************/

#ifdef DEBUG

inline
const char *        varTypeGCstring(var_types type)
{
    switch(type)
    {
    case TYP_REF:   return "gcr";
    case TYP_BYREF: return "byr";
    default:        return "non";
    }
}

#endif

/*****************************************************************************/

const   char *      varTypeName(var_types);

/*****************************************************************************
 *
 *  Helpers to pull big-endian values out of a byte stream.
 */

inline  unsigned    genGetU1(const BYTE *addr)
{
    return  addr[0];
}

inline    signed    genGetI1(const BYTE *addr)
{
    return  (signed char)addr[0];
}

inline  unsigned    genGetU2(const BYTE *addr)
{
    return  (addr[0] << 8) | addr[1];
}

inline    signed    genGetI2(const BYTE *addr)
{
    return  (signed short)((addr[0] << 8) | addr[1]);
}

inline  unsigned    genGetU4(const BYTE *addr)
{
    return  (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
}

/*****************************************************************************/
//  Helpers to pull little-endian values out of a byte stream.

inline
unsigned __int8     getU1LittleEndian(const BYTE * ptr)
{ return *(unsigned __int8 *)ptr; }

inline
unsigned __int16    getU2LittleEndian(const BYTE * ptr)
{ return *(unsigned __int16 *)ptr; }

inline
unsigned __int32    getU4LittleEndian(const BYTE * ptr)
{ return *(unsigned __int32*)ptr; }

inline
  signed __int8     getI1LittleEndian(const BYTE * ptr)
{ return * (signed __int8 *)ptr; }

inline
  signed __int16    getI2LittleEndian(const BYTE * ptr)
{ return * (signed __int16 *)ptr; }

inline
  signed __int32    getI4LittleEndian(const BYTE * ptr)
{ return *(signed __int32*)ptr; }

inline
  signed __int64    getI8LittleEndian(const BYTE * ptr)
{ return *(signed __int64*)ptr; }

inline
float               getR4LittleEndian(const BYTE * ptr)
{ return *(float*)ptr; }

inline
double              getR8LittleEndian(const BYTE * ptr)
{ return *(double*)ptr; }


/*****************************************************************************/

#ifdef  DEBUG
const   char *      genVS2str(VARSET_TP set);
#endif





/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          GenTree                                          XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#ifndef DEBUG

inline
GenTreePtr FASTCALL Compiler::gtNewNode(genTreeOps oper, var_types  type)
{
#if     SMALL_TREE_NODES
    size_t          size = GenTree::s_gtNodeSizes[oper];
#else
    size_t          size = sizeof(*node);
#endif

    GenTreePtr      node = (GenTreePtr)compGetMem(size);

    node->SetOper     (oper);
    node->gtType     = type;
    node->gtFlags    = 0;
#if TGT_x86
    node->gtUsedRegs = 0;
#endif
#if CSE
    node->gtCSEnum   = NO_CSE;
#endif
    node->gtNext     = NULL;

#ifdef DEBUG
    node->gtPrev     = NULL;
    node->gtSeqNum   = 0;
#endif

    return node;
}

#endif

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewStmt(GenTreePtr expr, IL_OFFSETX offset)
{
    /* NOTE - GT_STMT is now a small node in retail */

    GenTreePtr  node = gtNewNode(GT_STMT, TYP_VOID);

    node->gtStmt.gtStmtExpr         = expr;

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)
    node->gtStmtILoffsx             = offset;
#endif

#ifdef DEBUG
    node->gtStmt.gtStmtLastILoffs   = BAD_IL_OFFSET;
#endif

#if TGT_x86
    node->gtStmtFPrvcOut = 0;
#endif

    return node;
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewOperNode(genTreeOps oper)
{
    GenTreePtr      node = gtNewNode(oper, TYP_VOID);

    node->gtOp.gtOp1 =
    node->gtOp.gtOp2 = 0;

    return node;
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewOperNode(genTreeOps oper, var_types  type)
{
    GenTreePtr      node = gtNewNode(oper, type);

    node->gtOp.gtOp1 =
    node->gtOp.gtOp2 = 0;

    return node;
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewOperNode(genTreeOps oper,
                                            var_types  type,  GenTreePtr op1)
{
    GenTreePtr      node = gtNewNode(oper, type);

    node->gtOp.gtOp1 = op1;
    node->gtOp.gtOp2 = 0;

    if  (op1) node->gtFlags |= op1->gtFlags & GTF_GLOB_EFFECT;

    return node;
}

/******************************************************************************
 *
 * Use to create nodes which may later be morphed to another (big) operator
 */

inline
GenTreePtr FASTCALL Compiler::gtNewLargeOperNode(genTreeOps     oper,
                                                 var_types      type,
                                                 GenTreePtr     op1,
                                                 GenTreePtr     op2)
{
    GenTreePtr  node;

#if     SMALL_TREE_NODES

    // Allocate a large node

    assert(GenTree::s_gtNodeSizes[oper   ] == TREE_NODE_SZ_SMALL);
    assert(GenTree::s_gtNodeSizes[GT_CALL] == TREE_NODE_SZ_LARGE);

    node = gtNewOperNode(GT_CALL, type, op1, op2);
    node->SetOper(oper);

#else

    node = gtNewOperNode(oper, type, op1, op2);

#endif

    return node;
}

/*****************************************************************************
 *
 *  allocates a integer constant entry that represents a handle (something
 *  that may need to be fixed up).
 */

inline
GenTreePtr          Compiler::gtNewIconHandleNode(long         value,
                                                  unsigned     flags,
                                                  unsigned     handle1,
                                                  void *       handle2)
{
    GenTreePtr      node;
    assert((flags & GTF_ICON_HDL_MASK) != 0);

#if defined(JIT_AS_COMPILER) || defined (LATE_DISASM)
    node = gtNewLargeOperNode(GT_CNS_INT, TYP_INT);
    node->gtIntCon.gtIconVal = value;

    node->gtIntCon.gtIconHdl.gtIconHdl1 = handle1;
    node->gtIntCon.gtIconHdl.gtIconHdl2 = handle2;
#else
    node = gtNewIconNode(value);
#endif
    node->gtFlags           |= flags;
    return node;
}


#if!INLINING
#define gtNewIconHandleNode(value,flags,CPnum, CLS) gtNewIconHandleNode(value,flags,CPnum,0)
#endif


/*****************************************************************************
 *
 *  It may not be allowed to embed HANDLEs directly into the JITed code (for eg,
 *  as arguments to JIT helpers). Get a corresponding value that can be embedded.
 *  These are versions for each specific type of HANDLE
 */

inline
GenTreePtr  Compiler::gtNewIconEmbScpHndNode (CORINFO_MODULE_HANDLE    scpHnd, unsigned hnd1, void * hnd2)
{
    void * embedScpHnd, * pEmbedScpHnd;

    embedScpHnd = (void*)info.compCompHnd->embedModuleHandle(scpHnd, &pEmbedScpHnd);

    assert((!embedScpHnd) != (!pEmbedScpHnd));

    return gtNewIconEmbHndNode(embedScpHnd, pEmbedScpHnd, GTF_ICON_SCOPE_HDL, hnd1, hnd2);
}

//-----------------------------------------------------------------------------

inline
GenTreePtr  Compiler::gtNewIconEmbClsHndNode (CORINFO_CLASS_HANDLE    clsHnd, unsigned hnd1, void * hnd2)
{
    void * embedClsHnd, * pEmbedClsHnd;

    embedClsHnd = (void*)info.compCompHnd->embedClassHandle(clsHnd, &pEmbedClsHnd);

    assert((!embedClsHnd) != (!pEmbedClsHnd));

    return gtNewIconEmbHndNode(embedClsHnd, pEmbedClsHnd, GTF_ICON_CLASS_HDL, hnd1, hnd2);
}

//-----------------------------------------------------------------------------

inline
GenTreePtr  Compiler::gtNewIconEmbMethHndNode(CORINFO_METHOD_HANDLE  methHnd, unsigned hnd1, void * hnd2)
{
    void * embedMethHnd, * pEmbedMethHnd;

    embedMethHnd = (void*)info.compCompHnd->embedMethodHandle(methHnd, &pEmbedMethHnd);

    assert((!embedMethHnd) != (!pEmbedMethHnd));

    return gtNewIconEmbHndNode(embedMethHnd, pEmbedMethHnd, GTF_ICON_METHOD_HDL, hnd1, hnd2);
}

//-----------------------------------------------------------------------------

inline
GenTreePtr  Compiler::gtNewIconEmbFldHndNode (CORINFO_FIELD_HANDLE    fldHnd, unsigned hnd1, void * hnd2)
{
    void * embedFldHnd, * pEmbedFldHnd;

    embedFldHnd = (void*)info.compCompHnd->embedFieldHandle(fldHnd, &pEmbedFldHnd);

    assert((!embedFldHnd) != (!pEmbedFldHnd));

    return gtNewIconEmbHndNode(embedFldHnd, pEmbedFldHnd, GTF_ICON_FIELD_HDL, hnd1, hnd2);
}


/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewHelperCallNode(unsigned       helper,
                                                  var_types      type,
                                                  unsigned       flags,
                                                  GenTreePtr     args)
{
    GenTreePtr result =gtNewCallNode( CT_HELPER,
                                      eeFindHelper(helper),
                                      type,
                                      args);
    result->gtFlags |= flags;
    return result;
}

/*****************************************************************************/

inline
GenTreePtr FASTCALL Compiler::gtNewClsvNode(CORINFO_FIELD_HANDLE hnd,
                                            var_types      type)
{
    GenTreePtr      node = gtNewNode(GT_CLS_VAR, type);

    node->gtClsVar.gtClsVarHnd = hnd;
    return node;
}


#if!INLINING
#define gtNewClsvNode(cpx,cls,typ) gtNewClsvNode(cpx,info.compScopeHnd,typ)
#endif



/*****************************************************************************/

inline
GenTreePtr FASTCALL Compiler::gtNewCodeRef(BasicBlock *block)
{
    GenTreePtr      node = gtNewNode(GT_LABEL, TYP_VOID);

    node->gtLabel.gtLabBB = block;
#if TGT_x86
    node->gtFPlvl         = 0;
#endif
    return node;
}

/*****************************************************************************
 *
 *  A little helper to create a data member reference node.
 */

inline
GenTreePtr          Compiler::gtNewFieldRef(var_types     typ,
                                            CORINFO_FIELD_HANDLE  fldHnd,
                                            GenTreePtr    obj)
{
    GenTreePtr      tree;

#if SMALL_TREE_NODES

    /* 'GT_FIELD' nodes may later get transformed into 'GT_IND' */

    assert(GenTree::s_gtNodeSizes[GT_IND] >= GenTree::s_gtNodeSizes[GT_FIELD]);

    tree = gtNewNode(GT_IND  , typ);
    tree->SetOper(GT_FIELD);
#else
    tree = gtNewNode(GT_FIELD, typ);
#endif
    tree->gtField.gtFldObj = obj;
    tree->gtField.gtFldHnd = fldHnd;
#if HOIST_THIS_FLDS
    tree->gtField.gtFldHTX = 0;
#endif
    tree->gtFlags         |= GTF_GLOB_REF;

    return  tree;
}

/*****************************************************************************
 *
 *  A little helper to create an array index node.
 */

inline
GenTreePtr          Compiler::gtNewIndexRef(var_types     typ,
                                            GenTreePtr    adr,
                                            GenTreePtr    ind)
{
    GenTreePtr      tree;

#if SMALL_TREE_NODES

    /* 'GT_INDEX' nodes may later get transformed into 'GT_IND' */

    assert(GenTree::s_gtNodeSizes[GT_IND] >= GenTree::s_gtNodeSizes[GT_INDEX]);

    tree = gtNewOperNode(GT_IND  , typ, adr, ind);
    tree->SetOper(GT_INDEX);
#else
    tree = gtNewOperNode(GT_INDEX, typ, adr, ind);
#endif

    tree->gtFlags |= GTF_EXCEPT|GTF_INX_RNGCHK;
    tree->gtIndex.gtIndElemSize = genTypeSize(typ);
    return  tree;
}


/*****************************************************************************
 *
 *  Create (and check for) a "nothing" node, i.e. a node that doesn't produce
 *  any code. We currently use a "nop" node of type void for this purpose.
 */

inline
GenTreePtr          Compiler::gtNewNothingNode()
{
    return  gtNewOperNode(GT_NOP, TYP_VOID);
}

inline
bool                Compiler::gtIsaNothingNode(GenTreePtr tree)
{
    return  tree->gtOper == GT_NOP && tree->gtType == TYP_VOID;
}

/*****************************************************************************/

inline
bool                GenTree::IsNothingNode()
{
    if  (gtOper == GT_NOP && gtType == TYP_VOID)
        return  true;
    else
        return  false;
}

/*****************************************************************************
 *
 *  Bash the given node to a NOP - May be later bashed to a GT_COMMA
 *
 *****************************************************************************/

inline
void                GenTree::gtBashToNOP()
{
    ChangeOper(GT_NOP);

    gtType     = TYP_VOID;
    gtOp.gtOp1 = gtOp.gtOp2 = 0;

    gtFlags &= ~(GTF_GLOB_EFFECT | GTF_REVERSE_OPS);
#ifdef DEBUG
    gtFlags |= GTFD_NOP_BASH;
#endif
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtUnusedValNode(GenTreePtr expr)
{
    return gtNewOperNode(GT_COMMA, TYP_VOID, expr, gtNewNothingNode());
}

/*****************************************************************************
 *
 * A wrapper for gtSetEvalOrder and fgComputeFPlvls
 * Necessary because the FP levels may need to be re-computed if we reverse
 * operands
 */

inline
void               Compiler::gtSetStmtInfo(GenTree * stmt)
{
    assert(stmt->gtOper == GT_STMT);
    GenTreePtr      expr = stmt->gtStmt.gtStmtExpr;

#if TGT_x86

    /* We will try to compute the FP stack level at each node */
    genFPstkLevel = 0;

    /* Sometimes we need to redo the FP level computation */
    fgFPstLvlRedo = false;
#endif

#ifdef DEBUG
    if (verbose && 0)
        gtDispTree(stmt);
#endif

    /* Recursively process the expression */

    gtSetEvalOrder(expr);

    stmt->gtCostEx = expr->gtCostEx;
    stmt->gtCostSz = expr->gtCostSz;

#if TGT_x86

    /* Unused float values leave one operand on the stack */
    assert(genFPstkLevel == 0 || genFPstkLevel == 1);

    /* Do we need to recompute FP stack levels? */

    if  (fgFPstLvlRedo)
    {
        genFPstkLevel = 0;
        fgComputeFPlvls(expr);
        assert(genFPstkLevel == 0 || genFPstkLevel == 1);
    }
#endif
}

/*****************************************************************************/
#if SMALL_TREE_NODES
/*****************************************************************************/

inline
void                GenTree::SetOper(genTreeOps oper)
{
    assert(((gtFlags & GTF_NODE_SMALL) != 0) !=
           ((gtFlags & GTF_NODE_LARGE) != 0));

    /* Make sure the node isn't too small for the new operator */

    assert(GenTree::s_gtNodeSizes[gtOper] == TREE_NODE_SZ_SMALL ||
           GenTree::s_gtNodeSizes[gtOper] == TREE_NODE_SZ_LARGE);
    assert(GenTree::s_gtNodeSizes[  oper] == TREE_NODE_SZ_SMALL ||
           GenTree::s_gtNodeSizes[  oper] == TREE_NODE_SZ_LARGE);

    assert(GenTree::s_gtNodeSizes[  oper] == TREE_NODE_SZ_SMALL || (gtFlags & GTF_NODE_LARGE));

    gtOper = oper;
}

inline
void                GenTree::CopyFrom(GenTreePtr src)
{
    /* The source may be big only if the target is also a big node */

    assert((gtFlags & GTF_NODE_LARGE) || GenTree::s_gtNodeSizes[src->gtOper] == TREE_NODE_SZ_SMALL);
    memcpy(this, src, GenTree::s_gtNodeSizes[src->gtOper]);
#ifdef DEBUG
    gtSeqNum = 0;
#endif
}

inline
GenTreePtr          Compiler::gtNewCastNode(var_types typ, GenTreePtr op1,
                                                           var_types  castType)
{
    op1 = gtNewOperNode(GT_CAST, typ, op1);
    op1->gtCast.gtCastType = castType;

    return  op1;
}

inline
GenTreePtr          Compiler::gtNewCastNodeL(var_types typ, GenTreePtr op1,
                                                            var_types  castType)
{
    /* Some casts get transformed into 'GT_CALL' or 'GT_IND' nodes */

    assert(GenTree::s_gtNodeSizes[GT_CALL] >  GenTree::s_gtNodeSizes[GT_CAST]);
    assert(GenTree::s_gtNodeSizes[GT_CALL] >= GenTree::s_gtNodeSizes[GT_IND ]);

    /* Make a big node first and then bash it to be GT_CAST */

    op1 = gtNewOperNode(GT_CALL, typ, op1);
    op1->gtCast.gtCastType = castType;
    op1->SetOper(GT_CAST);

    return  op1;
}

/*****************************************************************************/
#else // SMALL_TREE_NODES
/*****************************************************************************/


inline
void                GenTree::InitNodeSize(){}

inline
void                GenTree::SetOper(genTreeOps oper)
{
    gtOper = oper;
}

inline
void                GenTree::CopyFrom(GenTreePtr src)
{
    *this = *src;
#ifdef DEBUG
    gtSeqNum = 0;
#endif
}

inline
GenTreePtr          Compiler::gtNewCastNode(var_types typ, GenTreePtr op1,
                                                           var_types  castType)
{
    GenTreePtr tree = gtNewOperNode(GT_CAST, typ, op1);
    tree->gtCast.gtCastType = castType;
}

inline
GenTreePtr          Compiler::gtNewCastNodeL(var_types typ, GenTreePtr op1,
                                                            var_types  castType)
{
    return gtNewCastNode(typ, op1, castType);
}

/*****************************************************************************/
#endif // SMALL_TREE_NODES
/*****************************************************************************/

inline
void                GenTree::SetOperResetFlags(genTreeOps oper)
{
    SetOper(oper);
    gtFlags &= GTF_NODE_MASK;
}

inline
void                GenTree::ChangeOperConst(genTreeOps oper)
{
    assert(OperIsConst(oper)); // use ChangeOper() instead
    SetOperResetFlags(oper);
}

inline
void                GenTree::ChangeOper(genTreeOps oper)
{
    assert(!OperIsConst(oper)); // use ChangeOperLeaf() instead

    SetOper(oper);
    gtFlags &= GTF_COMMON_MASK;
}

inline
void                GenTree::ChangeOperUnchecked(genTreeOps oper)
{
    gtOper = oper; // Trust the caller and dont use SetOper()
    gtFlags &= GTF_COMMON_MASK;
}


/*****************************************************************************
 * Returns true if the node is &var (created by ldarga and ldloca)
 */

inline
bool                GenTree::IsVarAddr()
{
    if (gtOper == GT_ADDR && (gtFlags & GTF_ADDR_ONSTACK))
    {
        assert((gtType == TYP_BYREF) || (gtType == TYP_I_IMPL));
        return true;
    }
    else
        return false;
}

/*****************************************************************************
 *
 * Returns true if the node is of the "ovf" variety, ie. add.ovf.i1
 * + gtOverflow() can only be called for valid operators (ie. we know it is one
 *   of the operators which may have GTF_OVERFLOW set).
 * + gtOverflowEx() is more expensive, and should be called only gtOper may be
 *   an operator for which GTF_OVERFLOW is invalid
 */

inline
bool                GenTree::gtOverflow()
{
    assert(gtOper == GT_MUL      || gtOper == GT_CAST     ||
           gtOper == GT_ADD      || gtOper == GT_SUB      ||
           gtOper == GT_ASG_ADD  || gtOper == GT_ASG_SUB);

    if (gtFlags & GTF_OVERFLOW)
    {
        assert(varTypeIsIntegral(TypeGet()));

        return true;
    }
    else
    {
        return false;
    }
}

inline
bool                GenTree::gtOverflowEx()
{
    if   ( gtOper == GT_MUL      || gtOper == GT_CAST     ||
           gtOper == GT_ADD      || gtOper == GT_SUB      ||
           gtOper == GT_ASG_ADD  || gtOper == GT_ASG_SUB)
    {
        return gtOverflow();
    }
    else
    {
        return false;
    }
}

/*****************************************************************************/

#ifdef DEBUG

inline
bool                Compiler::gtDblWasInt(GenTree * tree)
{
    return ((tree->gtOper == GT_LCL_VAR &&
             lvaTable[tree->gtLclVar.gtLclNum].lvDblWasInt) ||
            (tree->gtOper == GT_REG_VAR &&
             lvaTable[tree->gtRegVar.gtRegVar].lvDblWasInt));
}

#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          LclVarsInfo                                      XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  Allocate a temporary variable or a set of temp variables.
 */

inline
unsigned            Compiler::lvaGrabTemp(bool shortLifetime /* = true */)
{
    /* Check if the lvaTable has to be grown */
    if (lvaCount + 1 > lvaTableCnt)
    {
        lvaTableCnt = lvaCount + (lvaCount / 2) + 1;

        LclVarDsc * newLvaTable  = (LclVarDsc*)compGetMemArray(lvaTableCnt, sizeof(*lvaTable));
        size_t      lvaTableSize = lvaTableCnt * sizeof(*lvaTable);

        memset(newLvaTable, 0, lvaTableSize);
        memcpy(newLvaTable, lvaTable, lvaCount * sizeof(*lvaTable));

        lvaTable = newLvaTable;
    }

    /* Reset type, could have been set by unsuccessful inlining */

    lvaTable[lvaCount].lvType   = TYP_UNDEF;
    lvaTable[lvaCount].lvIsTemp = shortLifetime;
    return lvaCount++;
}

inline
unsigned            Compiler::lvaGrabTemps(unsigned cnt)
{
    /* Check if the lvaTable has to be grown */
    if (lvaCount + cnt > lvaTableCnt)
    {
        lvaTableCnt = lvaCount + lvaCount / 2 + cnt;

        LclVarDsc * newLvaTable  = (LclVarDsc*)compGetMemArray(lvaTableCnt, sizeof(*lvaTable));
        size_t      lvaTableSize = lvaTableCnt * sizeof(*lvaTable);

        memset(newLvaTable, 0, lvaTableSize);
        memcpy(newLvaTable, lvaTable, lvaCount * sizeof(*lvaTable));

        lvaTable = newLvaTable;
    }

    unsigned  tempNum = lvaCount;

    /* Reset type, could have been set by unsuccessful inlining */

    while (cnt--)
        lvaTable[lvaCount++].lvType = TYP_UNDEF;

    return tempNum;
}

/*****************************************************************************
 *
 *  Decrement the ref counts for a local variable
 */

inline
void          Compiler::LclVarDsc::decRefCnts(unsigned weight, Compiler * comp)
{
    /* Decrement lvRefCnt and lvRefCntWtd */

    assert(lvRefCnt);   // Can't decrement below zero

    if  (lvRefCnt > 0)
    {
        lvRefCnt--;

        if (lvIsTemp)
            weight *= 2;

        if (lvRefCntWtd < weight)  // Can't go below zero
            lvRefCntWtd  = 0;
        else
            lvRefCntWtd -= weight;
    }

    if (lvTracked)
    {
        /* Flag this change, set lvaSortAgain to true */
        comp->lvaSortAgain = true;

        /* Set weighted ref count to zero if  ref count is zero */
        if (lvRefCnt == 0)
            lvRefCntWtd  = 0;
    }

#ifdef DEBUG
    if (verbose)
    {
        unsigned varNum = this-comp->lvaTable;
        printf("New refCnts for V%02u: refCnt = %2u, refCntWtd = %2u\n",
               varNum, lvRefCnt, lvRefCntWtd);
    }
#endif
}

/*****************************************************************************
 *
 *  Increment the ref counts for a local variable
 */

inline
void            Compiler::LclVarDsc::incRefCnts(unsigned weight, Compiler *comp)
{
    /* Increment lvRefCnt and lvRefCntWtd */

    lvRefCnt++;

    if (lvIsTemp)
        weight *= 2;
    
    lvRefCntWtd += weight;

    if (lvTracked)
    {
        /* Flag this change, set lvaSortAgain to true */
        comp->lvaSortAgain = true;
    }

#ifdef DEBUG
    if (verbose)
    {
        unsigned varNum = this-comp->lvaTable;
        printf("New refCnts for V%02u: refCnt = %2u, refCntWtd = %2u\n",
               varNum, lvRefCnt, lvRefCntWtd);
    }
#endif
}

/*****************************************************************************
 *
 *  Set the lvPrefReg field to reg
 */

inline
void            Compiler::LclVarDsc::setPrefReg(regNumber reg, Compiler * comp)
{
    regMaskTP regMask = genRegMask(reg);

    /* Only interested if we have a new register bit set */
    if (lvPrefReg & regMask)
        return;

#ifdef DEBUG
    if (verbose)
    {
        if (lvPrefReg)
        {
            printf("Change preferred register for V%02u from ",
                   this-comp->lvaTable);
            dspRegMask(lvPrefReg, 0);
        }
        else
        {
            printf("Set preferred register for V%02u",
                   this-comp->lvaTable);
        }
        printf(" to ");
        dspRegMask(regMask, 0);
        printf("\n");
    }
#endif

    /* Overwrite the lvPrefReg field */

    lvPrefReg = regMask;

    if (lvTracked)
    {
        /* Flag this change, set lvaSortAgain to true */
        comp->lvaSortAgain = true;
    }

}

/*****************************************************************************
 *
 *  Add regMask to the lvPrefReg field
 */

inline
void         Compiler::LclVarDsc::addPrefReg(regMaskTP regMask, Compiler * comp)
{
    /* Only interested if we have a new register bit set */
    if (lvPrefReg & regMask)
        return;

#ifdef DEBUG
    if (verbose)
    {
        if (lvPrefReg)
        {
            printf("Additional preferred register for V%02u from ",
                   this-comp->lvaTable);
            dspRegMask(lvPrefReg, 0);
        }
        else
        {
            printf("Set preferred register for V%02u",
                   this-comp->lvaTable);
        }
        printf(" to ");
        dspRegMask(lvPrefReg | regMask, 0);
        printf("\n");
    }
#endif

    /* Update the lvPrefReg field */

    lvPrefReg |= regMask;

    if (lvTracked)
    {
        /* Flag this change, set lvaSortAgain to true */
        comp->lvaSortAgain = true;
    }

}

/*****************************************************************************/

/*****************************************************************************
 *
 *  Given a value that has exactly one bit set, return the position of that
 *  bit, in other words return the logarithm in base 2 of the given value.
 */

inline
unsigned            genVarBitToIndex(VARSET_TP bit)
{
    return genLog2(bit);
}

/*****************************************************************************
 *
 *  Maps a variable index onto a value with the appropriate bit set.
 */

inline
VARSET_TP           genVarIndexToBit(unsigned num)
{
    static const
    VARSET_TP       bitMask[] =
    {
        0x0000000000000001,
        0x0000000000000002,
        0x0000000000000004,
        0x0000000000000008,
        0x0000000000000010,
        0x0000000000000020,
        0x0000000000000040,
        0x0000000000000080,
        0x0000000000000100,
        0x0000000000000200,
        0x0000000000000400,
        0x0000000000000800,
        0x0000000000001000,
        0x0000000000002000,
        0x0000000000004000,
        0x0000000000008000,
        0x0000000000010000,
        0x0000000000020000,
        0x0000000000040000,
        0x0000000000080000,
        0x0000000000100000,
        0x0000000000200000,
        0x0000000000400000,
        0x0000000000800000,
        0x0000000001000000,
        0x0000000002000000,
        0x0000000004000000,
        0x0000000008000000,
        0x0000000010000000,
        0x0000000020000000,
        0x0000000040000000,
        0x0000000080000000,
#if VARSET_SZ > 32
        0x0000000100000000,
        0x0000000200000000,
        0x0000000400000000,
        0x0000000800000000,
        0x0000001000000000,
        0x0000002000000000,
        0x0000004000000000,
        0x0000008000000000,
        0x0000010000000000,
        0x0000020000000000,
        0x0000040000000000,
        0x0000080000000000,
        0x0000100000000000,
        0x0000200000000000,
        0x0000400000000000,
        0x0000800000000000,
        0x0001000000000000,
        0x0002000000000000,
        0x0004000000000000,
        0x0008000000000000,
        0x0010000000000000,
        0x0020000000000000,
        0x0040000000000000,
        0x0080000000000000,
        0x0100000000000000,
        0x0200000000000000,
        0x0400000000000000,
        0x0800000000000000,
        0x1000000000000000,
        0x2000000000000000,
        0x4000000000000000,
        0x8000000000000000,
#endif
    };

    assert(num < sizeof(bitMask)/sizeof(bitMask[0]));

    return bitMask[num];
}

/*****************************************************************************
 *
 *  The following returns the mask of all tracked locals
 *  referenced in a statement.
 */

inline
VARSET_TP           Compiler::lvaStmtLclMask(GenTreePtr stmt)
{
    GenTreePtr      tree;
    unsigned        varNum;
    LclVarDsc   *   varDsc;
    VARSET_TP       lclMask = 0;

    assert(stmt->gtOper == GT_STMT);
    assert(fgStmtListThreaded);

    for (tree = stmt->gtStmt.gtStmtList; tree; tree = tree->gtNext)
    {
        if  (tree->gtOper != GT_LCL_VAR)
            continue;

        varNum = tree->gtLclVar.gtLclNum;
        assert(varNum < lvaCount);
        varDsc = lvaTable + varNum;

        if  (!varDsc->lvTracked)
            continue;

        lclMask |= genVarIndexToBit(varDsc->lvVarIndex);
    }

    return lclMask;
}

/*****************************************************************************
 * Returns true if the lvType is a TYP_REF or a TYP_BYREF
 * When the lvType is TYP_STRUCT is searches the GC layout
 *  of the struct and returns true iff it contains a GC ref
 */

inline 
bool               Compiler::lvaTypeIsGC(unsigned varNum)
{
    // @TODO [REVISIT] [04/16/01] []: set lvStructGcCount for objrefs, and then avoid the if here
    if (lvaTable[varNum].TypeGet() == TYP_STRUCT)
    {
        assert(lvaTable[varNum].lvGcLayout  != 0);  // bits are intialized
        return (lvaTable[varNum].lvStructGcCount != 0);
    }
    return(varTypeIsGC(lvaTable[varNum].TypeGet()));
}


/*****************************************************************************
 end-of-last-executed-filter
*/

inline
unsigned            Compiler::lvaLastFilterOffs()
{
    assert(info.compXcptnsCount);
    assert(((int)lvaShadowSPfirstOffs) > 0);
    unsigned result = lvaShadowSPfirstOffs;
    result -= sizeof(void *); // skip ShadowSPfirst itself
    assert(((int)result) > 0);
    return result;
}

/*****************************************************************************/

inline
unsigned            Compiler::lvaLocAllocSPoffs()
{
    assert(compLocallocUsed);
    assert(((int)lvaShadowSPfirstOffs) > 0);
    unsigned result = lvaShadowSPfirstOffs;
    result -= sizeof(void *); // skip ShadowSPfirst itself
    if (info.compXcptnsCount > 0)
        result -= sizeof(void *); // skip end-of-last-executed-filter
    assert(((int)result) > 0);
    return result;
}

/*****************************************************************************
 *
 *  Return the stack framed offset of the given variable; set *FPbased to
 *  true if the variable is addressed off of FP, false if it's addressed
 *  off of SP. Note that 'varNum' can be a negated temporary var index.
 */

inline
int                 Compiler::lvaFrameAddress(int varNum, bool *FPbased)
{
    assert(lvaDoneFrameLayout);

    if  (varNum >= 0)
    {
        LclVarDsc   *   varDsc;

        assert((unsigned)varNum < lvaCount);
        varDsc = lvaTable + varNum;

        *FPbased = varDsc->lvFPbased;

#if     TGT_x86
#if     DOUBLE_ALIGN
        assert(*FPbased == (genFPused || (genDoubleAlign &&
                                          varDsc->lvIsParam &&
                                          !varDsc->lvIsRegArg)));
#else
        assert(*FPbased ==  genFPused);
#endif
#endif

        return  varDsc->lvStkOffs;
    }
    else
    {
        TempDsc *       tmpDsc = tmpFindNum(varNum); assert(tmpDsc);

        // UNDONE: The following is not always a safe assumption for RISC

        *FPbased = genFPused;

        return  tmpDsc->tdTempOffs();
    }
}

inline
bool                Compiler::lvaIsEBPbased(int varNum)
{

#if DOUBLE_ALIGN

    if  (varNum >= 0)
    {
        LclVarDsc   *   varDsc;

        assert((unsigned)varNum < lvaCount);
        varDsc = lvaTable + varNum;

#ifdef  DEBUG
#if     TGT_x86
#if     DOUBLE_ALIGN
        assert(varDsc->lvFPbased == (genFPused || (genDoubleAlign && varDsc->lvIsParam)));
#else
        assert(varDsc->lvFPbased ==  genFPused);
#endif
#endif
#endif

        return  varDsc->lvFPbased;
    }

#endif

    return  genFPused;
}

inline
bool                Compiler::lvaIsParameter(unsigned varNum)
{
    LclVarDsc   *   varDsc;

    assert(varNum < lvaCount);
    varDsc = lvaTable + varNum;

    return  varDsc->lvIsParam;
}

inline
bool                Compiler::lvaIsRegArgument(unsigned varNum)
{
    LclVarDsc   *   varDsc;

    assert(varNum < lvaCount);
    varDsc = lvaTable + varNum;

    return  varDsc->lvIsRegArg;
}

inline
BOOL                Compiler::lvaIsThisArg(unsigned varNum)
{
    LclVarDsc   *   varDsc;

    assert(varNum < lvaCount);
    varDsc = lvaTable + varNum;

    return  varDsc->lvVerTypeInfo.IsThisPtr(); // lvIsThis;
}

/*****************************************************************************
 *
 *  The following is used to detect the cases where the same local variable#
 *  is used both as a long/double value and a 32-bit value and/or both as an
 *  integer/address and a float value.
 */

/* static */ inline
unsigned            Compiler::lvaTypeRefMask(var_types type)
{
    const static
    BYTE                lvaTypeRefMasks[] =
    {
        #define DEF_TP(tn,nm,jitType,verType,sz,sze,asze,st,al,tf,howUsed) howUsed,
        #include "typelist.h"
        #undef  DEF_TP
    };

    assert(type < sizeof(lvaTypeRefMasks));
    assert(lvaTypeRefMasks[type] != 0);

    return lvaTypeRefMasks[type];
}

/*****************************************************************************
 *
 *  The following is used to detect the cases where the same local variable#
 *  is used both as a long/double value and a 32-bit value and/or both as an
 *  integer/address and a float value.
 */

inline
var_types          Compiler::lvaGetActualType(unsigned lclNum)
{
    return genActualType(lvaGetRealType(lclNum));
}

inline
var_types          Compiler::lvaGetRealType(unsigned lclNum)
{
    return lvaTable[lclNum].TypeGet();
}

/*****************************************************************************/

inline void         Compiler::lvaAdjustRefCnts() {}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          Importer                                         XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

inline
unsigned Compiler::compMapILargNum(unsigned ILargNum)
{
    assert(ILargNum < info.compILargsCount || tiVerificationNeeded);

    // Note that this works because if compRetBuffArg is not present
    // it will be negative, which when treated as an unsigned will
    // make it a larger than any varable.
    if (ILargNum >= (unsigned) info.compRetBuffArg)
    {
        ILargNum++;
        assert(ILargNum < info.compLocalsCount || tiVerificationNeeded);   // compLocals count already adjusted.
    }

    assert(ILargNum < info.compArgsCount || tiVerificationNeeded);
    return(ILargNum);
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                     Register Allocator                                    XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/



/*****************************************************************************
 *
 *  Given a register variable node, return the variable's liveset bit.
 */

inline
VARSET_TP           Compiler::raBitOfRegVar(GenTreePtr tree)
{
    unsigned        lclNum;
    LclVarDsc   *   varDsc;

    assert(tree->gtOper == GT_REG_VAR);

    lclNum = tree->gtRegVar.gtRegVar;
    assert(lclNum < lvaCount);
    varDsc = lvaTable + lclNum;
    assert(varDsc->lvTracked);

    return  genVarIndexToBit(varDsc->lvVarIndex);
}

inline
bool                isRegPairType(int /* s/b "var_types" */ type)
{
#if CPU_HAS_FP_SUPPORT
    return  type == TYP_LONG;
#else
    return  type == TYP_LONG || type == TYP_DOUBLE;
#endif
}

inline
bool                isFloatRegType(int /* s/b "var_types" */ type)
{
#if CPU_HAS_FP_SUPPORT
    return  type == TYP_DOUBLE || type == TYP_FLOAT;
#else
    return  false;
#endif
}

/*****************************************************************************/

inline
bool        rpCanAsgOperWithoutReg(GenTreePtr op, bool lclvar)
{
    var_types type;

    switch (op->OperGet())
    {
    case GT_CNS_LNG:
    case GT_CNS_INT:
    case GT_RET_ADDR:
    case GT_POP:
        return true;
    case GT_LCL_VAR:
        type = genActualType(op->TypeGet());
        if (lclvar && ((type == TYP_INT) || (type == TYP_REF) || (type == TYP_BYREF)))
            return true;
    }

    return false;
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                       FlowGraph                                           XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  Call the given function pointer for all nodes in the tree. The 'visitor'
 *  fn should return one of the following values:
 *
 *  WALK_ABORT          stop walking and return immediately
 *  WALK_CONTINUE       continue walking
 *  WALK_SKIP_SUBTREES  don't walk any subtrees of the node just visited
 */

inline
Compiler::fgWalkResult  Compiler::fgWalkTreePre(GenTreePtr    tree,
                                                fgWalkPreFn * visitor,
                                                void *        callBackData,
                                                bool          lclVarsOnly,
                                                bool          skipCalls)

{
    // This isnt naturally reentrant. Use fgWalkTreePreReEnter()
    assert(fgWalkPre.wtprVisitorFn    == NULL);
    assert(fgWalkPre.wtprCallbackData == NULL);

    fgWalkPre.wtprVisitorFn     = visitor;
    fgWalkPre.wtprCallbackData  = callBackData;
    fgWalkPre.wtprLclsOnly      = lclVarsOnly;
    fgWalkPre.wtprSkipCalls     = skipCalls;

    fgWalkResult result         = fgWalkTreePreRec(tree);

#ifdef DEBUG
    // Reset anti-reentrancy checks
    fgWalkPre.wtprVisitorFn     = NULL;
    fgWalkPre.wtprCallbackData  = NULL;
#endif

    return result;
}

/*****************************************************************************
 *
 *  Same as above, except the tree walk is performed in a depth-first fashion,
 *  The 'visitor' fn should return one of the following values:
 *
 *  WALK_ABORT          stop walking and return immediately
 *  WALK_CONTINUE       continue walking
 */

inline
Compiler::fgWalkResult  Compiler::fgWalkTreePost(GenTreePtr     tree,
                                                 fgWalkPostFn * visitor,
                                                 void *         callBackData,
                                                 genTreeOps     prefixNode)
{
    // This isnt naturally reentrant. Use fgWalkTreePostReEnter()
    assert(fgWalkPost.wtpoVisitorFn    == NULL);
    assert(fgWalkPost.wtpoCallbackData == NULL);

    fgWalkPost.wtpoVisitorFn    = visitor;
    fgWalkPost.wtpoCallbackData = callBackData;
    fgWalkPost.wtpoPrefixNode   = prefixNode;

    fgWalkResult result         = fgWalkTreePostRec(tree);
    assert(result == WALK_CONTINUE || result == WALK_ABORT);

#ifdef DEBUG
    // Reset anti-reentrancy checks
    fgWalkPost.wtpoVisitorFn    = NULL;
    fgWalkPost.wtpoCallbackData = NULL;
#endif

    return result;
}

/*****************************************************************************
 *
 * Has this block been added to throw an inlined-exception
 * (by calling an EE helper).
 */

inline
bool                Compiler::fgIsThrowHlpBlk(BasicBlock * block)
{
    if (!fgIsCodeAdded())
        return false;

    if (!(block->bbFlags & BBF_INTERNAL) || block->bbJumpKind != BBJ_THROW)
        return false;

    GenTreePtr  call = block->bbTreeList->gtStmt.gtStmtExpr;
    
    if (!call || (call->gtOper != GT_CALL))
        return false;
          
    if (!((call->gtCall.gtCallMethHnd == eeFindHelper(CORINFO_HELP_RNGCHKFAIL)) ||
          (call->gtCall.gtCallMethHnd == eeFindHelper(CORINFO_HELP_OVERFLOW))))
        return false;

    return true;
}

/*****************************************************************************
 *
 *  Return the stackLevel of the inserted block that throws exception
 *  (by calling the EE helper).
 */

#if TGT_x86
inline
unsigned            Compiler::fgThrowHlpBlkStkLevel(BasicBlock *block)
{
    assert(fgIsThrowHlpBlk(block));

    for  (AddCodeDsc  *   add = fgAddCodeList; add; add = add->acdNext)
    {
        if  (block == add->acdDstBlk)
        {
            assert(add->acdKind == ACK_RNGCHK_FAIL || add->acdKind == ACK_OVERFLOW);
            // @CONSIDER: bbTgtStkDepth is DEBUG-only.
            // Should we use it regularly and avoid this search.
            assert(block->bbTgtStkDepth == add->acdStkLvl);
            return add->acdStkLvl;
        }
    }

    /* We couldn't find the basic block ?? */

    return 0;
}
#endif

/*
    Small inline function to change a given block to a throw block.

*/
inline void Compiler::fgConvertBBToThrowBB(BasicBlock * block)
{
    block->bbJumpKind = BBJ_THROW;
    block->bbSetRunRarely();     // any block with a throw is rare
}

/*****************************************************************************
 *
 *  Return true if we've added any new basic blocks.
 */

inline
bool                Compiler::fgIsCodeAdded()
{
    return  fgAddCodeModf;
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          TempsInfo                                        XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/

/* static */ inline
unsigned            Compiler::tmpFreeSlot(size_t size)
{
    assert((size % sizeof(int)) == 0 && size <= TEMP_MAX_SIZE);

    return size / sizeof(int) - 1;
}

/*****************************************************************************
 *
 *  Finish allocating temps - should be called each time after a pass is made
 *  over a function body.
 */

inline
void                Compiler::tmpEnd()
{
#ifdef DEBUG
    if (verbose && tmpCount) printf("%d tmps used\n", tmpCount);
#endif
}

/*****************************************************************************
 *
 *  Shuts down the temp-tracking code. Should be called once per function
 *  compiled.
 */

inline
void                Compiler::tmpDone()
{
#ifdef DEBUG
    size_t      size = 0;
    unsigned    count;
    TempDsc   * temp;

    for (temp = tmpListBeg(    ), count  = temp ? 1 : 0;
         temp;
         temp = tmpListNxt(temp), count += temp ? 1 : 0)
    {
        assert(temp->tdOffs != BAD_TEMP_OFFSET);

        size += temp->tdSize;
    }

    // Make sure that all the temps were released
    assert(count == tmpCount);
    assert(tmpGetCount == 0);

#endif
}

/*****************************************************************************
 *
 *  A helper function is used to iterate over all the temps;
 *  this function may only be called at the end of codegen and *after* calling
 *  tmpEnd().
 */

inline
Compiler::TempDsc *    Compiler::tmpListBeg()
{
    // All grabbed temps should have been released
    assert(tmpGetCount == 0);

    // Return the first temp in the slot for the smallest size
    TempDsc * temp = tmpFree[0];

    if (!temp)
    {
        // If we have more slots, need to use "while" instead of "if" above
        assert(tmpFreeSlot(TEMP_MAX_SIZE) == 1);

        temp = tmpFree[1];
    }

    return temp;
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          RegSet                                           XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************
 *  Should we stress register tracking logic ?
 *  1 = rsPickReg() picks 'bad' registers.
 *  2 = codegen spills at safe points. This is still flaky
 */

#ifdef DEBUG

inline
int                 Compiler::rsStressRegs()
{
    static ConfigDWORD fJitStressRegs(L"JitStressRegs", 0);
    return fJitStressRegs.val() || compStressCompile(STRESS_REGS, 15);
}


/*****************************************************************************
 *  Should we enable JitStress mode?
 *   0:   No stress
 *   !=2: Vary stress. Performance will be slightly/moderately degraded
 *   2:   Check-all stress. Performance will be REALLY horrible
 */

inline
DWORD               getJitStressLevel()
{
    static ConfigDWORD fJitStress(L"JitStress", 0);
    return fJitStress.val();
}

#endif

/*****************************************************************************
 *  Includes 'includeHint' if 'regs' is empty
 */

inline
regMaskTP           rsUseIfZero(regMaskTP regs, regMaskTP includeHint)
{
    return regs ? regs : includeHint;
}

/*****************************************************************************
 *  Excludes 'excludeHint' if it results in a non-empty mask
 */

inline
regMaskTP           rsExcludeHint(regMaskTP regs, regMaskTP excludeHint)
{
    regMaskTP   OKmask = regs & ~excludeHint;
    return OKmask ? OKmask : regs;
}

/*****************************************************************************
 *  Narrows choice by 'narrowHint' if it results in a non-empty mask
 */

inline
regMaskTP           rsNarrowHint(regMaskTP regs, regMaskTP narrowHint)
{
    regMaskTP   narrowed = regs & narrowHint;
    return narrowed ? narrowed : regs;
}

/*****************************************************************************
 *  Excludes 'exclude' from regs if non-zero, or from RBM_ALL
 */

inline
regMaskTP           rsMustExclude(regMaskTP regs, regMaskTP exclude)
{
    // Try to exclude from current set
    regMaskTP   OKmask = regs & ~exclude;

    // If current set wont work, exclude from RBM_ALL
    if (OKmask == RBM_NONE)
        OKmask = (RBM_ALL & ~exclude);

    assert(OKmask);

    return OKmask;
}

/*****************************************************************************
 *
 *  The following returns a mask that yields all free registers.
 */

inline
regMaskTP           Compiler::rsRegMaskFree()
{
    /* Any register that is locked must also be marked as 'used' */

    assert((rsMaskUsed & rsMaskLock) == rsMaskLock);

    /* Any register that isn't used and doesn't hold a variable is free */

    return  (RBM_ALL & ~(rsMaskUsed|rsMaskVars));
}

/*****************************************************************************
 *
 *  The following returns a mask of registers that may be grabbed.
 */

inline
regMaskTP           Compiler::rsRegMaskCanGrab()
{
    /* Any register that is locked must also be marked as 'used' */

    assert((rsMaskUsed & rsMaskLock) == rsMaskLock);

    /* Any register that isn't locked and doesn't hold a var can be grabbed */

    return  (RBM_ALL & ~(rsMaskLock|rsMaskVars));
}

/*****************************************************************************
 *
 *  Mark the given set of registers as used and locked.
 */

inline
void                Compiler::rsLockReg(regMaskTP regMask)
{
    /* Must not be already marked as either used or locked */

    assert((rsMaskUsed &  regMask) == 0);
            rsMaskUsed |= regMask;
    assert((rsMaskLock &  regMask) == 0);
            rsMaskLock |= regMask;
}

/*****************************************************************************
 *
 *  Mark an already used set of registers as locked.
 */

inline
void                Compiler::rsLockUsedReg(regMaskTP regMask)
{
    /* Must not be already marked as locked. Must be already marked as used. */

    assert((rsMaskLock &  regMask) == 0);
    assert((rsMaskUsed &  regMask) == regMask);

            rsMaskLock |= regMask;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as no longer used/locked.
 */

inline
void                Compiler::rsUnlockReg(regMaskTP regMask)
{
    /* Must be currently marked as both used and locked */

    assert((rsMaskUsed &  regMask) == regMask);
            rsMaskUsed -= regMask;
    assert((rsMaskLock &  regMask) == regMask);
            rsMaskLock -= regMask;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as no longer locked.
 */

inline
void                Compiler::rsUnlockUsedReg(regMaskTP regMask)
{
    /* Must be currently marked as both used and locked */

    assert((rsMaskUsed &  regMask) == regMask);
    assert((rsMaskLock &  regMask) == regMask);
            rsMaskLock -= regMask;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as used and locked. It may already have
 *  been marked as used.
 */

inline
void                Compiler::rsLockReg(regMaskTP regMask, regMaskTP * usedMask)
{
    /* Is it already marked as used? */

    regMaskTP   used = (rsMaskUsed & regMask);
    regMaskTP unused = (regMask & ~used);

    if (  used)
        rsLockUsedReg(used);

    if (unused)
        rsLockReg(unused);

    *usedMask = used;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as no longer
 */

inline
void                Compiler::rsUnlockReg(regMaskTP regMask, regMaskTP usedMask)
{
    regMaskTP unused = (regMask & ~usedMask);

    if (usedMask)
        rsUnlockUsedReg(usedMask);

    if (unused)
        rsUnlockReg(unused);
}

/*****************************************************************************
 * Complexity with non-interruptible GC, so only track callee-trash.
 * For fully interruptible, don't track at all
 *
 * This comment has been added AFTER the code was written.
 * For non-interruptible code, we probably dont track ptrs in callee-saved
 * registers because we will not report these tracked ptr registers to the
 * emitter at significant points (calls and labels). However, that can be
 * fixed by explicitly killing tracked ptr values in callee-saved registers
 * at call-sites.
 * We should be able to track ptrs for interruptible code as long as we do
 * rsTrackRegClr at all significant points (calls and labels).
 */

inline
bool                Compiler::rsCanTrackGCreg(regMaskTP regMask)
{
    return ((regMask & RBM_CALLEE_TRASH) && !genInterruptible);
}

/*****************************************************************************
 *
 *  Assume all registers contain garbage (called at start of codegen and when
 *  we encounter a code label).
 */

inline
void                Compiler::rsTrackRegClr()
{
    assert(RV_TRASH == 0); 
    memset(rsRegValues, 0, sizeof(rsRegValues));
}

/*****************************************************************************
 *
 *  Record the fact that the given register now contains the given value.
 */

inline
void                Compiler::rsTrackRegTrash(regNumber reg)
{
    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg);

    /* Record the new value for the register */

    rsRegValues[reg].rvdKind = RV_TRASH;
}

/*****************************************************************************/

inline
void                Compiler::rsTrackRegIntCns(regNumber reg, long val)
{
    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg);

    /* Record the new value for the register */

    rsRegValues[reg].rvdKind      = RV_INT_CNS;
    rsRegValues[reg].rvdIntCnsVal = val;
}


/*****************************************************************************/

#if USE_SET_FOR_LOGOPS

inline
void                Compiler::rsTrackRegOneBit(regNumber reg)
{
    /* Record the new value for the register */

#ifdef  DEBUG
    if  (verbose) printf("The register %s now holds a bit value\n", compRegVarName(reg));
#endif

    rsRegValues[reg].rvdKind = RV_BIT;
}

#endif

/*****************************************************************************/

inline
void                Compiler::rsTrackRegLclVarLng(regNumber reg, unsigned var, bool low)
{
    assert(reg != REG_STK);

    if (!MORE_REDUNDANT_LOAD && lvaTable[var].lvAddrTaken)
        return;

    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg);

    /* Record the new value for the register */

    rsRegValues[reg].rvdKind      = (low ? RV_LCL_VAR_LNG_LO : RV_LCL_VAR_LNG_HI);
    rsRegValues[reg].rvdLclVarNum = var;
}

/*****************************************************************************/

inline
bool                Compiler::rsTrackIsLclVarLng(regValKind rvKind)
{
    if  (opts.compMinOptim || opts.compDbgCode)
        return  false;

    if  (rvKind == RV_LCL_VAR_LNG_LO ||
         rvKind == RV_LCL_VAR_LNG_HI)
        return  true;
    else
        return  false;
}

/*****************************************************************************/

inline
void                Compiler::rsTrackRegClsVar(regNumber reg, GenTreePtr clsVar)
{
    if (MORE_REDUNDANT_LOAD)
    {
        regMaskTP   regMask = genRegMask(reg);

        if (varTypeIsGC(clsVar->TypeGet()) && !rsCanTrackGCreg(regMask))
            return;

        /* Keep track of which registers we ever touch */

        rsMaskModf |= regMask;

        /* Record the new value for the register */

        rsRegValues[reg].rvdKind      = RV_CLS_VAR;
        rsRegValues[reg].rvdClsVarHnd = clsVar->gtClsVar.gtClsVarHnd;
    }
    else
    {
        rsTrackRegTrash(reg);
    }
}

/*****************************************************************************/

#if 0
inline
void                Compiler::rsTrackRegCopy(regNumber reg1, regNumber reg2)
{
    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg1);

    rsRegValues[reg1] = rsRegValues[reg2];
}
#endif

/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************
 *
 *  Determine whether we should "riscify" by loading a local variable to
 *  a register instead of addressing it in memory.
 *
 *  Called from genMakeRvalueAddressable() and rsPickReg (to determine if
 *  round-robin register allocation should be used.
 */

#if TGT_RISC

inline
bool                Compiler::rsRiscify(var_types type, regMaskTP needReg)
{
    return  false;
}

#else

inline
bool                Compiler::rsRiscify(var_types type, regMaskTP needReg)
{
    if (!riscCode)
        return false;

//  if (!opts.compSchedCode)
//      return false;

    if (compCurBB->bbWeight <= BB_UNITY_WEIGHT)
        return false;

    if (needReg == 0)
        needReg = RBM_ALL;

    // require enough free registers for the value because no benefit to
    // riscification otherwise.
    if (rsFreeNeededRegCount(needReg) < genTypeStSz(type))
        return false;

#if 0
    // heuristic: if only one tree in block, don't riscify
    // since there's not much to schedule
    if (type != TYP_LONG && compCurBB->bbTreeList->gtNext == NULL)
        return false;
#endif

    return true;
}

#endif

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************
 *
 *  Make sure no spills are currently active - used for debugging of the code
 *  generator.
 */

#ifdef DEBUG

inline
void                Compiler::rsSpillChk()
{
    // All grabbed temps should have been released
    assert(tmpGetCount == 0);

    for (regNumber reg = REG_FIRST; reg < REG_COUNT; reg = REG_NEXT(reg))
    {
        assert(rsSpillDesc[reg] == 0);
        assert(rsUsedTree [reg] == 0);
        assert(rsMultiDesc[reg] == 0);
    }
}

#else

inline
void                Compiler::rsSpillChk(){}

#endif

/*****************************************************************************
 *
 *  Initializes the spill code. Should be called once per function compiled.
 */

inline
void                Compiler::rsSpillInit()
{
    /* Clear out the spill and multi-use tables */

    memset(rsSpillDesc, 0, sizeof(rsSpillDesc));
    memset(rsUsedTree,  0, sizeof(rsUsedTree) );
    memset(rsUsedAddr,  0, sizeof(rsUsedAddr) );
    memset(rsMultiDesc, 0, sizeof(rsMultiDesc));

    /* We don't have any descriptors allocated */

    rsSpillFree = 0;
}

/*****************************************************************************
 *
 *  Shuts down the spill code. Should be called once per function compiled.
 */

inline
void                Compiler::rsSpillDone()
{
    rsSpillChk();
}

/*****************************************************************************
 *
 *  Begin tracking spills - should be called each time before a pass is made
 *  over a function body.
 */

inline
void                Compiler::rsSpillBeg()
{
    rsSpillChk();
}

/*****************************************************************************
 *
 *  Finish tracking spills - should be called each time after a pass is made
 *  over a function body.
 */

inline
void                Compiler::rsSpillEnd()
{
    rsSpillChk();
}

/*****************************************************************************/
#if REDUNDANT_LOAD

inline
bool                Compiler::rsIconIsInReg(long val, regNumber reg)
{
    if  (opts.compMinOptim || opts.compDbgCode)
        return false;

    if (rsRegValues[reg].rvdKind == RV_INT_CNS &&
        rsRegValues[reg].rvdIntCnsVal == val)
    {
#if SCHEDULER
        rsUpdateRegOrderIndex(reg);
#endif
        return  true;
    }
    else
    {
        return false;
    }
}

#if USE_SET_FOR_LOGOPS

/*****************************************************************************
 *
 * Search for a register which has at least the upper 3 bytes cleared.
 * The caller can restrict the search to byte addressable registers and/or
 * free registers, only.
 * Return success/failure and set the register if success.
 */
inline
regNumber           Compiler::rsFindRegWithBit(bool free, bool byteReg)
{
    if  (opts.compMinOptim || opts.compDbgCode)
        return REG_NA;

    for (regNumber reg = REG_FIRST; reg < REG_COUNT; reg = REG_NEXT(reg))
    {

#if TGT_x86
        if (byteReg && !isByteReg(reg))
            continue;
#endif

        if ((rsRegValues[reg].rvdKind == RV_BIT) ||
            (rsRegValues[reg].rvdKind == RV_INT_CNS &&
             rsRegValues[reg].rvdIntCnsVal == 0))
        {
            if (!free || (genRegMask(reg) & rsRegMaskFree()))
                goto RET;
        }
    }

    return REG_NA;

RET:

#if SCHEDULER
    rsUpdateRegOrderIndex(reg);
#endif

    return reg;
}

#endif

/*****************************************************************************/
#endif // REDUNDANT_LOAD
/*****************************************************************************





/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                       Instruction                                         XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction is a floating-point ins.
 */

/* static */ inline
bool                Compiler::instIsFP(instruction ins)
{
    assert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_FP) != 0;
}

/*****************************************************************************/
#else //TGT_x86
/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction is a branch-delayed ins.
 */

/* static */ inline
bool                Compiler::instBranchDelay(instruction ins)
{
    assert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_BD) != 0;
}

/*****************************************************************************
 *
 *  Returns the number of branch-delay slots for the given instruction (or 0).
 */

/* static */ inline
unsigned            Compiler::instBranchDelayL(instruction ins)
{
    assert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

#if     MAX_BRANCH_DELAY_LEN > 1
#error  You\'ll need to add more bits to support more than 1 branch delay slot!
#endif

    return  (unsigned)((instInfo[ins] & INST_BD) != 0);
}

/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction is a branch/call/ret.
 */

/* static */ inline
bool                Compiler::instIsBranch(instruction ins)
{
    assert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_BR) != 0;
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction sets the flags.
 */

inline
bool                Compiler::instDefFlags(instruction ins)
{
    assert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_DEF_FL) != 0;
}

/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction uses the flags.
 */

inline
bool                Compiler::instUseFlags(instruction ins)
{
    assert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_USE_FL) != 0;
}

/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction uses the flags.
 */

inline
bool                Compiler::instSpecialSched(instruction ins)
{
    assert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_SPSCHD) != 0;
}

/*****************************************************************************/
#else //SCHEDULER
/*****************************************************************************/

#if     TGT_x86

inline
void                Compiler::inst_JMP(emitJumpKind   jmp,
                                       BasicBlock *   block,
                                       bool           except,
                                       bool           moveable,
                                       bool           newBlock)
{
    inst_JMP(jmp, block);
}

#endif

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Return the register which is defined by the IMUL_REG instruction
 */

inline
regNumber           Compiler::inst3opImulReg(instruction ins)
{
    regNumber       reg  = ((regNumber) (ins - INS_imul_AX));

    assert(reg >= REG_EAX);
    assert(reg <= REG_EDI);

    /* Make sure we return the appropriate register */

    assert(INS_imul_BX - INS_imul_AX == REG_EBX);
    assert(INS_imul_CX - INS_imul_AX == REG_ECX);
    assert(INS_imul_DX - INS_imul_AX == REG_EDX);

    assert(INS_imul_BP - INS_imul_AX == REG_EBP);
    assert(INS_imul_SI - INS_imul_AX == REG_ESI);
    assert(INS_imul_DI - INS_imul_AX == REG_EDI);

    return reg;
}

/*****************************************************************************
 *
 *  Return the register which is defined by the IMUL_REG instruction
 */

inline
instruction         Compiler::inst3opImulForReg(regNumber reg)
{
    assert(INS_imul_AX - INS_imul_AX == REG_EAX);
    assert(INS_imul_BX - INS_imul_AX == REG_EBX);
    assert(INS_imul_CX - INS_imul_AX == REG_ECX);
    assert(INS_imul_DX - INS_imul_AX == REG_EDX);
    assert(INS_imul_BP - INS_imul_AX == REG_EBP);
    assert(INS_imul_SI - INS_imul_AX == REG_ESI);
    assert(INS_imul_DI - INS_imul_AX == REG_EDI);

    instruction ins = instruction(reg + INS_imul_AX);
    assert(instrIs3opImul(ins));

    return ins;
}

/*****************************************************************************
 *
 *  Generate a floating-point instruction that has one operand given by
 *  a tree (which has been made addressable).
 */

inline
void                Compiler::inst_FS_TT(instruction ins, GenTreePtr tree)
{
    assert(instIsFP(ins));

    assert(varTypeIsFloating(tree->gtType));

    inst_TT(ins, tree, 0);
}

/*****************************************************************************
 *
 *  Generate a "shift reg, CL" instruction.
 */

inline
void                Compiler::inst_RV_CL(instruction ins, regNumber reg)
{
    inst_RV(ins, reg, TYP_INT);
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************
 *
 *  Macros to include/exclude arguments depending on whether inlining
 *  is enabled.
 */

#if!INLINING
#define inst_CALL(ctype,val,cls) inst_CALL(ctype,val,0)
#endif

#if!INLINING
#define inst_IV_handle(ins,val,flags,cpx,cls) inst_IV_handle(ins,val,flags,cpx,0)
#endif

#if!INLINING
#define instEmitDataFixup(cpx,cls) instEmitDataFixup(cpx,0)
#endif

#if!INLINING
#define inst_CV(ins,siz,cpx,cls,ofs) inst_CV(ins,siz,cpx,0,ofs)
#endif

#if INDIRECT_CALLS
#if!INLINING
#define inst_SM(ins,siz,cpx,cls,ofs) inst_SM(ins,siz,cpx,0,ofs)
#endif
#endif

#if!INLINING
#define inst_CV_RV(ins,siz,cpx,cls,reg,ofs) inst_CV_RV(ins,siz,cpx,0,reg,ofs)
#endif

#if!INLINING
#define inst_CV_IV(ins,siz,cpx,cls,val,ofs) inst_CV_IV(ins,siz,cpx,0,val,ofs)
#endif

#if!INLINING
#define inst_RV_CV(ins,siz,reg,cpx,cls,ofs) inst_RV_CV(ins,siz,reg,cpx,0,ofs)
#endif

#if!INLINING
#define instEmit_vfnCall(reg,disp,cpx,cls) instEmit_vfnCall(reg,disp,cpx,0)
#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          ScopeInfo                                        XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#ifdef DEBUGGING_SUPPORT

inline
void        Compiler::siBeginBlockSkipSome()
{
    assert(opts.compScopeInfo && info.compLocalVarsCount > 0);
    assert(siLastEndOffs < compCurBB->bbCodeOffs);

    compProcessScopesUntil(compCurBB->bbCodeOffs,
                           siNewScopeCallback, siEndScopeCallback,
                           (unsigned)this);
}

#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          GCInfo                                           XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#if TRACK_GC_REFS
/*****************************************************************************
 *  Reset tracking info at the start of a basic block.
 */

inline
void                Compiler::gcResetForBB()
{
    gcRegGCrefSetCur = 0;
    gcRegByrefSetCur = 0;
    gcVarPtrSetCur   = 0;
}

/*****************************************************************************
 *
 *  Mark the set of registers given by the specified mask as holding
 *  GCref pointer values.
 */

inline
void                Compiler::gcMarkRegSetGCref(regMaskTP regMask)
{
    gcRegGCrefSetCur |= regMask;

    assert((gcRegGCrefSetCur & gcRegByrefSetCur) == 0);
}

/*****************************************************************************
 *
 *  Mark the set of registers given by the specified mask as holding
 *  Byref pointer values.
 */

inline
void                Compiler::gcMarkRegSetByref(regMaskTP regMask)
{
    gcRegByrefSetCur |= regMask;

    assert((gcRegGCrefSetCur & gcRegByrefSetCur) == 0);
}

/*****************************************************************************
 *
 *  Mark the set of registers given by the specified mask as holding
 *  non-pointer values.
 */

inline
void                Compiler::gcMarkRegSetNpt(regMaskTP regMask)
{
    /* NOTE: don't unmark any live register variables */

    gcRegGCrefSetCur &= ~(regMask & ~rsMaskVars);
    gcRegByrefSetCur &= ~(regMask & ~rsMaskVars);
}

/*****************************************************************************
 *
 *  Mark the specified register as now holding a value of the given type.
 */

inline
void                Compiler::gcMarkRegPtrVal(regNumber reg, var_types type)
{
    regMaskTP       regMask = genRegMask(reg);

    switch(type)
    {
    case TYP_REF:   gcMarkRegSetGCref(regMask); break;
    case TYP_BYREF: gcMarkRegSetByref(regMask); break;
    default:        gcMarkRegSetNpt  (regMask); break;
    }
}

/*****************************************************************************/

/* static */ inline
bool                Compiler::gcIsWriteBarrierCandidate(GenTreePtr tgt)
{
    /* Are we storing a GC ptr? */

    if  (!varTypeIsGC(tgt->TypeGet()))
        return false;

    /* What are we storing into */

    switch(tgt->gtOper)
    {
    case GT_IND:
        if  (varTypeIsGC(tgt->gtOp.gtOp1->TypeGet()))
            return true;
        break;

    case GT_ARR_ELEM:
    case GT_CLS_VAR:
        return true;
    }

    return false;
}

/* static */ inline
bool                Compiler::gcIsWriteBarrierAsgNode(GenTreePtr op)
{
    if (op->gtOper == GT_ASG)
        return gcIsWriteBarrierCandidate(op->gtOp.gtOp1);
    else
        return false;
}

inline
size_t              encodeUnsigned(BYTE *dest, unsigned value)
{
    size_t size = 1;
    if (value >= (1 << 28)) {
        if (dest)
            *dest++ =  (value >> 28)         | 0x80;
        size++;
    }
    if (value >= (1 << 21)) {
        if (dest)
            *dest++ = ((value >> 21) & 0x7f) | 0x80;
        size++;
    }
    if (value >= (1 << 14)) {
        if (dest)
            *dest++ = ((value >> 14) & 0x7f) | 0x80;
        size++;
    }
    if (value >= (1 <<  7)) {
        if (dest)
            *dest++ = ((value >>  7) & 0x7f) | 0x80;
        size++;
    }
    if (dest)
        *dest++ = value & 0x7f;
    return size;
}

inline
size_t              encodeUDelta(BYTE *dest, unsigned value, unsigned lastValue)
{
    assert(value >= lastValue);
    return encodeUnsigned(dest, value - lastValue);
}

inline
size_t              encodeSigned(BYTE *dest, int val)
{
    size_t   size  = 1;
    bool     neg   = (val < 0);
    unsigned value = (neg) ? -val : val;
    unsigned max   = 0x3f;
    while ((value > max) && ((max>>25) == 0)) {
        size++;
        max <<= 7;
    }
    if (dest) {
        // write the bytes starting at the end of dest in LSB to MSB order
        BYTE* p    = dest + size;
        bool  cont = false;      // The last byte has no continuation flag
        while (--p != dest) {
            *p  = (cont << 7) | (value & 0x7f);
            value >>= 7;
            cont = true;        // Non last bytes have a continuation flag
        }
        assert(p == dest);      // Now write the first byte
        *dest++ = (cont << 7) | (neg << 6) | (value& 0x3f);
    }
    return size;
}

inline void Compiler::saveLiveness(genLivenessSet * ls)
{

    ls->liveSet   = genCodeCurLife;
    ls->varPtrSet = gcVarPtrSetCur;
    ls->maskVars  = rsMaskVars;
    ls->gcRefRegs = gcRegGCrefSetCur;
    ls->byRefRegs = gcRegByrefSetCur;
}

inline void Compiler::restoreLiveness(genLivenessSet * ls)
{
    genCodeCurLife   = ls->liveSet;
    gcVarPtrSetCur   = ls->varPtrSet;
    rsMaskVars       = ls->maskVars;
    gcRegGCrefSetCur = ls->gcRefRegs;
    gcRegByrefSetCur = ls->byRefRegs;
}

inline void Compiler::checkLiveness(genLivenessSet * ls)
{
    assert(genCodeCurLife   == ls->liveSet);
    assert(gcVarPtrSetCur   == ls->varPtrSet);
    assert(rsMaskVars       == ls->maskVars);
    assert(gcRegGCrefSetCur == ls->gcRefRegs);
    assert(gcRegByrefSetCur == ls->byRefRegs);
}

#else //TRACK_GC_REFS

inline
void                Compiler::gcVarPtrSetInit  (){}

inline
void                Compiler::gcMarkRegSetGCref(regMaskTP   regMask){}
inline
void                Compiler::gcMarkRegSetByref(regMaskTP   regMask){}
inline
void                Compiler::gcMarkRegSetNpt  (regMaskTP   regMask){}
inline
void                Compiler::gcMarkRegPtrVal  (regNumber   reg,
                                                var_types   type){}

inline
void                Compiler::gcMarkRegPtrVal  (GenTreePtr  tree){}

#ifdef  DEBUG
inline
void                Compiler::gcRegPtrSetDisp  (regMaskTP   regMask,
                                                bool        fixed){}
#endif

inline
void                Compiler::gcRegPtrSetInit  (){}

#endif//TRACK_GC_REFS

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          CodeGenerator                                    XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************
 *
 *  Update the current set of live variables based on the life set recorded
 *  in the given expression tree node.
 */

inline
void                Compiler::genUpdateLife(GenTreePtr tree)
{
    if  (genCodeCurLife != tree->gtLiveSet)
        genChangeLife(tree->gtLiveSet DEBUGARG(tree));
}

inline
void                Compiler::genUpdateLife(VARSET_TP newLife)
{
    if  (genCodeCurLife != newLife)
        genChangeLife(newLife DEBUGARG(NULL));
}

inline
GenTreePtr          Compiler::genMarkLclVar(GenTreePtr tree)
{
    unsigned        varNum;
    LclVarDsc   *   varDsc;

    assert(tree->gtOper == GT_LCL_VAR);

    /* Does the variable live in a register? */

    varNum = tree->gtLclVar.gtLclNum;
    assert(varNum < lvaCount);
    varDsc = lvaTable + varNum;

    if  (varDsc->lvRegister)
        genBashLclVar(tree, varNum, varDsc);
    else
        tree = 0;

    return tree;
}

inline
void                Compiler::genFlagsEqualToNone()
{
    genFlagsEqReg = REG_NA;
    genFlagsEqVar = -1;
}

inline
GenTreePtr          Compiler::genIsAddrMode(GenTreePtr tree, GenTreePtr *indxPtr)
{
    bool            rev;
    unsigned        mul;
    unsigned        cns;
    GenTreePtr      adr;

    if  (genCreateAddrMode(tree,        // address
                           0,           // mode
                           false,       // fold
                           RBM_NONE,    // reg mask
#if!LEA_AVAILABLE
                           TYP_UNDEF,   // operand type
#endif
                           &rev,        // reverse ops
                           &adr,        // base addr
                           indxPtr,     // index val
#if SCALED_ADDR_MODES
                           &mul,        // scaling
#endif
                           &cns,        // displacement
                           true))       // don't generate code
        return  adr;
    else
        return  NULL;
}

/*****************************************************************************/

inline
bool                Compiler::genCanSchedJMP2THROW()
{
#if     SCHEDULER

    /* 1. We cant schedule any instruction with side-effect in a try-block if
          it is detectable by the catch block.
       2. We only allow code with the same stack-depth to jump to a
          throw-block for easy stack-walking. So we cant move a
          stack-modifying instr past a jmp2throw.
     */
    return ((compCurBB->bbTryIndex == 0) && (genFPused == true));

#else

    return false;

#endif
}

/*****************************************************************************/

#if !TGT_x86

inline
void                Compiler::genChkFPregVarDeath(GenTreePtr stmt, bool saveTOS) {}

#else

inline
void                Compiler::genChkFPregVarDeath(GenTreePtr stmt, bool saveTOS)
{
    assert(stmt->gtOper == GT_STMT);

    /* Get hold of the statement tree */
    GenTreePtr tree = stmt->gtStmt.gtStmtExpr;

    if (tree->gtOper == GT_ASG)
    {
        GenTreePtr op1 = tree->gtOp.gtOp1;
        if ((op1->gtOper == GT_REG_VAR) && (op1->gtRegNum == 0))
            saveTOS = true;
    }

    if  (stmt->gtStmtFPrvcOut != genFPregCnt)
    {
        assert(genFPregCnt == stmt->gtStmtFPrvcOut + genFPdeadRegCnt);
        genFPregVarKill(stmt->gtStmtFPrvcOut, saveTOS);
    }

    assert(stmt->gtStmtFPrvcOut == genFPregCnt);
    assert(genFPdeadRegCnt == 0);
}

inline
void                Compiler::genFPregVarLoad(GenTreePtr tree)
{
    assert(tree->gtOper == GT_REG_VAR);

    /* Is the variable dying right here? */

    if  (tree->gtFlags & GTF_REG_DEATH)
    {
        /* The last living reference needs extra care */

        genFPregVarLoadLast(tree);
    }
    else
    {
        /* No regvar can come live if there's a defered death */
        assert(genFPdeadRegCnt==0);

        /* Simply push a copy of the variable on the FP stack */        
        inst_FN(INS_fld, tree->gtRegNum + genFPstkLevel);
        genFPstkLevel++;
    }
}

/* Small helper to shift an FP stack register from the bottom of the stack
 * (excluding the enregisterd FP variables which are always bottom-most) to the top.
 * genFPstkLevel specifies the number of values pushed on the stack */

inline
void                Compiler::genFPmovRegTop()
{
    assert(genFPstkLevel);

    /* If there are temps above our register (i.e bottom of stack) we have to bubble it up */

    if  (genFPstkLevel > 1)
    {
        /* Shift the result on top above 'genFPstkLevel-1' temps */

        for (unsigned tmpLevel = 1; tmpLevel < genFPstkLevel  ; tmpLevel++)
            inst_FN(INS_fxch, tmpLevel);
    }
}


/* Small helper to shift an FP stack register from the TOP of the stack to the BOTTOM
 * genFPstkLevel specifies the number of values pushed on the stack */
inline
void                Compiler::genFPmovRegBottom()
{
    int             fpTmpLevel;

    assert(genFPstkLevel);

    /* If the stack has more than one value bubble the top down */

    if  (genFPstkLevel > 1)
    {
        /* We will have to move the value from the top down 'genFPstkLevel-1'
         * positions which is equivalent to shift the 'genFPstkLevel-1' temps up */

        /* Shift the temps up and move the new value into the right place */

        for (fpTmpLevel = genFPstkLevel - 1; fpTmpLevel > 0; fpTmpLevel--)
            inst_FN(INS_fxch, fpTmpLevel);
    }
}

#endif

/*****************************************************************************
 *
 *  We stash cookies in basic blocks for the code emitter; this call retrieves
 *  the cookie associated with the given basic block.
 */

inline
void *  FASTCALL    emitCodeGetCookie(BasicBlock *block)
{
    assert(block);
    return block->bbEmitCookie;
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          Optimizer                                        XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#if ASSERTION_PROP

/*****************************************************************************
 *
 *  The following removes the i-th entry in the value assignment table
 */

inline
void                Compiler::optAssertionReset(unsigned limit)
{
    while (optAssertionCount > limit)
    {
        unsigned index  = --optAssertionCount;
        unsigned lclNum = optAssertionTab[index].op1.lclNum;
        lvaTable[lclNum].lvAssertionDep &= ~((EXPSET_TP)1 << index);  
        
        if ((optAssertionTab[index].assertion == OA_EQUAL) &&
            (optAssertionTab[index].op2.type  == GT_LCL_VAR))
        {
            lclNum = optAssertionTab[index].op2.lclNum;
            lvaTable[lclNum].lvAssertionDep &= ~((EXPSET_TP)1 << index);  
        }
    }
    while (optAssertionCount < limit)
    {
        unsigned index  = optAssertionCount++;
        unsigned lclNum = optAssertionTab[index].op1.lclNum;
        lvaTable[lclNum].lvAssertionDep |=  ((EXPSET_TP)1 << index);
        
        if ((optAssertionTab[index].assertion == OA_EQUAL) &&
            (optAssertionTab[index].op2.type  == GT_LCL_VAR))
        {
            lclNum = optAssertionTab[index].op2.lclNum;
            lvaTable[lclNum].lvAssertionDep |=  ((EXPSET_TP)1 << index);  
        }
    }
}

/*****************************************************************************
 *
 *  The following removes the i-th entry in the value assignment table
 */

inline
void                Compiler::optAssertionRemove(unsigned index)
{
    assert(optAssertionCount <= EXPSET_SZ);
    
    /*  Two cases to consider if index == optAssertionCount then the last entry
     *  in the table is to be removed and that happens automatically when
     *  optAssertionCount is decremented,
     *  The other case is when index < optAssertionCount and here we overwrite the
     *  index-th entry in the table with the data found at the end of the table
     */
    if (index < optAssertionCount)
    {
        unsigned newAssertionCount = optAssertionCount - 1;
        optAssertionReset(0);
        memcpy(&optAssertionTab[index], 
               &optAssertionTab[index+1], 
               sizeof(AssertionDsc));
        optAssertionReset(newAssertionCount);
    }
    else
    {
        unsigned lclNum = optAssertionTab[index].op1.lclNum;
        lvaTable[lclNum].lvAssertionDep &= ~((EXPSET_TP)1 << index);
    
        if ((optAssertionTab[index].assertion == OA_EQUAL) &&
            (optAssertionTab[index].op2.type  == GT_LCL_VAR))
        {
            lclNum = optAssertionTab[index].op2.lclNum;
            lvaTable[lclNum].lvAssertionDep &= ~((EXPSET_TP)1 << index);  
        }
        optAssertionCount--;
    }
}
#endif

/*****************************************************************************/
#if HOIST_THIS_FLDS
/*****************************************************************************/

inline
void                Compiler::optHoistTFRrecDef(CORINFO_FIELD_HANDLE hnd, GenTreePtr tree)
{
    assert(tree->gtOper == GT_FIELD);

    if  (optThisFldDont)
        return;

    /* Get the type of the value */

    var_types       typ = tree->TypeGet();

    /* Don't bother if this is not an integer or pointer */

    if  (typ != TYP_INT && typ != TYP_REF)
        return;

    /* Find/create an entry for this field */

    thisFldPtr fld = optHoistTFRlookup(hnd);
    fld->tfrTree = tree;
    fld->tfrDef  = true;
}

inline
void                Compiler::optHoistTFRrecRef(CORINFO_FIELD_HANDLE hnd, GenTreePtr tree)
{

    assert(tree->gtOper == GT_FIELD);

    if  (optThisFldDont)
        return;

    /* Get the type of the value */

    var_types typ = tree->TypeGet();

    /* Don't bother if this is not an integer or pointer */

    if  (typ != TYP_INT && typ != TYP_REF)
        return;

    /* Find/create an entry for this field */

    thisFldPtr fld = optHoistTFRlookup(hnd);
    fld->tfrTree = tree;
    fld->tfrUseCnt++;

    /* Mark the reference */

    tree->gtField.gtFldHTX = fld->tfrIndex;
}

inline
void                Compiler::optHoistTFRhasLoop()
{
    // UNDONE: Perform analysis after we've identified loops, so that
    // UNDONE: we can properly weight references inside loops.

    optThisFldLoop = true;
}

inline
GenTreePtr          Compiler::optHoistTFRreplace(GenTreePtr tree)
{
    thisFldPtr      fld;

    assert(tree->gtOper == GT_FIELD);
    assert(optThisFldDont == false);

    /* If the object is not "this", return */

    GenTreePtr      obj = tree->gtOp.gtOp1;
    if  (info.compIsStatic || obj->OperGet() != GT_LCL_VAR || obj->gtLclVar.gtLclNum != 0)
        return tree;

    /* Find an entry for this field */

    for (fld = optThisFldLst; fld; fld = fld->tfrNext)
    {
        if  (fld->tfrIndex == tree->gtField.gtFldHTX)
        {
            if  (fld->tfrDef)
                return tree;

            assert(fld->optTFRHoisted);
            assert(fld->tfrTempNum);

#ifdef DEBUG
            /* 'tree' should now be dead */
            if (tree != fld->tfrTree) fld->tfrTree->ChangeOperUnchecked(GT_NONE);
#endif
            /* Replace with a reference to the appropriate temp */

            return gtNewLclvNode(fld->tfrTempNum, tree->TypeGet());
        }
    }

    return  tree;
}

inline
GenTreePtr          Compiler::optHoistTFRupdate(GenTreePtr tree)
{
    assert(tree->gtOper == GT_FIELD);

    return  optThisFldDont ? tree : optHoistTFRreplace(tree);
}

/*****************************************************************************/
#endif//HOIST_THIS_FLDS

inline
void                Compiler::LoopDsc::VERIFY_lpIterTree()
{
#ifdef DEBUG
    assert(lpFlags & LPFLG_ITER);

    //iterTree should be "lcl <op>= const"

    assert(lpIterTree);

    BYTE   operKind = GenTree::gtOperKindTable[lpIterTree->OperGet()];
    assert(operKind & GTK_ASGOP); // +=, -=, etc

    assert(lpIterTree->gtOp.gtOp1->OperGet() == GT_LCL_VAR);
    assert(lpIterTree->gtOp.gtOp2->OperGet() == GT_CNS_INT);
#endif
}

//-----------------------------------------------------------------------------

inline
unsigned            Compiler::LoopDsc::lpIterVar()
{
    VERIFY_lpIterTree();
    return lpIterTree->gtOp.gtOp1->gtLclVar.gtLclNum;
}

//-----------------------------------------------------------------------------

inline
long                Compiler::LoopDsc::lpIterConst()
{
    VERIFY_lpIterTree();
    return lpIterTree->gtOp.gtOp2->gtIntCon.gtIconVal;
}

//-----------------------------------------------------------------------------

inline
genTreeOps          Compiler::LoopDsc::lpIterOper()
{
    VERIFY_lpIterTree();
    return lpIterTree->OperGet();
}


inline
var_types           Compiler::LoopDsc::lpIterOperType()
{
    VERIFY_lpIterTree();

    var_types type = lpIterTree->TypeGet();
    assert(genActualType(type) == TYP_INT);

    if ((lpIterTree->gtFlags & GTF_UNSIGNED) && type == TYP_INT)
        type = TYP_UINT;

    return type;
}


inline
void                Compiler::LoopDsc::VERIFY_lpTestTree()
{
#ifdef DEBUG
    assert(lpFlags & LPFLG_SIMPLE_TEST);
    assert(lpTestTree);

    genTreeOps  oper = lpTestTree->OperGet();
    assert(GenTree::OperIsCompare(oper));

    assert(lpTestTree->gtOp.gtOp1->OperGet() == GT_LCL_VAR);
    if      (lpFlags & LPFLG_CONST_LIMIT)
        assert(lpTestTree->gtOp.gtOp2->OperIsConst());
    else if (lpFlags & LPFLG_VAR_LIMIT)
        assert(lpTestTree->gtOp.gtOp2->OperGet() == GT_LCL_VAR);
#endif
}

inline
genTreeOps          Compiler::LoopDsc::lpTestOper()
{
    VERIFY_lpTestTree();
    return lpTestTree->OperGet();
}

//-----------------------------------------------------------------------------

inline
long                Compiler::LoopDsc::lpConstLimit()
{
    VERIFY_lpTestTree();
    assert(lpFlags & LPFLG_CONST_LIMIT);

    assert(lpTestTree->gtOp.gtOp2->OperIsConst());
    return lpTestTree->gtOp.gtOp2->gtIntCon.gtIconVal;
}

//-----------------------------------------------------------------------------

inline
unsigned            Compiler::LoopDsc::lpVarLimit()
{
    VERIFY_lpTestTree();
    assert(lpFlags & LPFLG_VAR_LIMIT);

    assert(lpTestTree->gtOp.gtOp2->OperGet() == GT_LCL_VAR);
    return lpTestTree->gtOp.gtOp2->gtLclVar.gtLclNum;
}

/*****************************************************************************
 *  Is "var" assigned in the loop "lnum" ?
 */

inline
bool                Compiler::optIsVarAssgLoop(unsigned lnum, long var)
{
    assert(lnum < optLoopCount);

    if  (var < VARSET_SZ)
        return  optIsSetAssgLoop(lnum, genVarIndexToBit(var)) != 0;
    else
        return  optIsVarAssigned(optLoopTable[lnum].lpHead->bbNext,
                                 optLoopTable[lnum].lpEnd,
                                 0,
                                 var);
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          EEInterface                                      XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

extern  var_types   JITtype2varType(CorInfoType type);

#include "ee_il_dll.hpp"

inline
CORINFO_METHOD_HANDLE       Compiler::eeFindHelper        (unsigned helper)
{
    assert(helper < CORINFO_HELP_COUNT);

    /* Helpers are marked by the fact that they are odd numbers
     * force this to be an odd number (will shift it back to extract */

    return((CORINFO_METHOD_HANDLE) ((helper << 2) + 1));
}

inline
CorInfoHelpFunc      Compiler::eeGetHelperNum      (CORINFO_METHOD_HANDLE  method)
{
            // Helpers are marked by the fact that they are odd numbers
    if (!(((int) method) & 1))
        return(CORINFO_HELP_UNDEF);
    return((CorInfoHelpFunc) (((int) method) >> 2));
}

//
// Note that we want to have two special FIELD_HANDLES that will both
// be consider non-Data Offset handles for both DLL_JIT and non DLL_JIT
//
// The special values that we use are -2 for FLD_GLOBAL_DS
//   and -4 for FLD_GLOBAL_FS
//
inline
CORINFO_FIELD_HANDLE       Compiler::eeFindJitDataOffs        (unsigned dataOffs)
{
        // Data offsets are marked by the fact that they are odd numbers
        // force this to be an odd number (will shift it back to extract)
    return((CORINFO_FIELD_HANDLE) ((dataOffs << 1) + 1));
}

inline
int         Compiler::eeGetJitDataOffs        (CORINFO_FIELD_HANDLE  field)
{
        // Data offsets are marked by the fact that they are odd numbers
        // and we must shift it back to extract
    if (!(((int) field) & 1))
        return(-1);
    return((((int) field) >> 1));
}

inline
bool        jitStaticFldIsGlobAddr(CORINFO_FIELD_HANDLE fldHnd)
{
    return (fldHnd == FLD_GLOBAL_DS || fldHnd == FLD_GLOBAL_FS);
}

inline
bool                Compiler::eeIsNativeMethod      (CORINFO_METHOD_HANDLE method)
{
    return ((((int)method) & 0x2) == 0x2);
}

inline
CORINFO_METHOD_HANDLE       Compiler::eeMarkNativeTarget    (CORINFO_METHOD_HANDLE method)
{
    assert ((((int)method)& 0x3) == 0);
    return (CORINFO_METHOD_HANDLE)(((int)method)| 0x2);
}

inline
CORINFO_METHOD_HANDLE       Compiler::eeGetMethodHandleForNative (CORINFO_METHOD_HANDLE method)
{
    assert ((((int)method)& 0x3) == 0x2);
    return (CORINFO_METHOD_HANDLE)(((int)method)& ~0x3);
}

#if !INLINING

// When inlining, the class-handle passed in may be different than the
// currnent procedure's. It is oftern GenTree::gtCall.gtCallCLS. However
// this field is defined in GenTree only when INLINING. So to get this to
// compile, we make the preprocessor strip off any gtCall.gtCallCLS.

#define eeIsOurMethod(ctype,val,cls)        eeIsOurMethod(ctype,val,0)
#define eeGetCPfncinfo(cpx,cls,cpk,typ,opc) eeGetCPfncinfo(cpx,0,cpk,typ,opc)
#define eeGetMethodVTableOffset(cpx,cls)             eeGetMethodVTableOffset(cpx,0)
#define eeFindField(cpx,cls)           eeFindField(cpx)
#define eeGetInterfaceID(cpx,cls)             eeGetInterfaceID(cpx,0)
#define eeGetMethodName(ctype,val,cls,nam)     eeGetMethodName(ctype,val,0,nam)
#endif




/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          Compiler                                         XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#ifndef DEBUG
inline
bool            Compiler::compStressCompile(compStressArea    stressArea,
                                            unsigned          weightPercentage)
{
    return false;
}
#endif

/*****************************************************************************
 *
 *  Allocate memory from the no-release allocator. All such memory will be
 *  freed up simulataneously at the end of the procedure
 */

#ifndef DEBUG

inline
void  *  FASTCALL       Compiler::compGetMem(size_t sz)
{
    assert(sz);

    return  compAllocator->nraAlloc(sz);
}

#endif

/*****************************************************************************
 *
 * A common memory allocation for arrays of structures involves the
 * multiplication of the number of elements with the size of each element.
 * If this computation overflows, then the memory allocation might succeed,
 * but not allocate sufficient memory for all the elements.  This can cause
 * us to overwrite the allocation, and AV or worse, corrupt memory.
 *
 * This method checks for overflow, and succeeds only when it detects
 * that there's no overflow.  It should be cheap, because when inlined with
 * a constant elemSize, the division should be done in compile time, and so
 * at run time we simply have a check of numElem against some number (this
 * is why we __forceinline).
 */

#define MAX_MEMORY_PER_ALLOCATION 512*1024*1024

__forceinline
void *   FASTCALL       Compiler::compGetMemArray(size_t numElem, size_t elemSize)
{
    if (numElem > (MAX_MEMORY_PER_ALLOCATION / elemSize))
    {
        NOMEM();
    }

    return compGetMem(numElem * elemSize);
}

__forceinline
void *   FASTCALL       Compiler::compGetMemArrayA(size_t numElem, size_t elemSize)
{
    if (numElem > (MAX_MEMORY_PER_ALLOCATION / elemSize))
    {
        NOMEM();
    }

    return compGetMemA(numElem * elemSize);
}

/******************************************************************************
 *
 *  Roundup the allocated size so that if this memory block is aligned,
 *  then the next block allocated too will be aligned.
 *  The JIT will always try to keep all the blocks aligned.
 */

inline
void  *  FASTCALL       Compiler::compGetMemA(size_t sz)
{
    assert(sz);

    void * ptr = compAllocator->nraAlloc(roundUp(sz, sizeof(int)));

    // Verify that the current block is aligned. Only then will the next
    // block allocated be on an aligned boundary.
    assert((int(ptr) & (sizeof(int) - 1)) == 0);

    return ptr;
}

inline
void                    Compiler::compFreeMem(void * ptr)
{}

#define compFreeMem(ptr)   compFreeMem((void *)ptr)

/*****************************************************************************/
#endif //_COMPILER_HPP_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\ee_il_dll.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            ee_jit.cpp                                     XX
XX                                                                           XX
XX   The functionality needed for the JIT DLL. Includes the DLL entry point  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#include "jitpch.h"
#pragma hdrstop
#include "emit.h"
#include "dbgalloc.h"

/*****************************************************************************/

#include "target.h"
#include "error.h"


#if !INLINING

// These are defined for other .CPP files. We dont need it

#undef eeIsOurMethod
#undef eeGetCPfncinfo
#undef eeGetMethodVTableOffset
#undef eeGetInterfaceID
#undef eeFindField
#undef eeGetMethodName

#endif


/*****************************************************************************/

#define DUMP_PTR_REFS       0       // for testing

static CILJit* ILJitter = 0;        // The one and only JITTER I return

/*****************************************************************************/

extern  bool        native          =  true;
extern  bool        genCode         =  true;
extern  bool        savCode         =  true;
extern  bool        goSpeed         =  true;
extern  bool        optJumps        =  true;
extern  bool        genOrder        =  true;
extern  bool        genFPopt        =  true;
extern  bool        callGcChk       = false;
extern  unsigned    genCPU          =     5;
extern  bool        riscCode        = false;
extern  bool        vmSdk3_0        = false;

#ifdef  DEBUG
extern  bool        quietMode       = false;
extern  bool        verbose         = false;
extern  bool        verboseTrees    = false;
extern  bool        dspCode         = false;
extern  bool        dspInstrs    = false;
extern  bool        dspEmit         = false;
extern  bool        dspLines        = false;
extern  bool        varNames        = false;
extern  bool        dspGCtbls       = false;
extern  bool        dmpHex          = false;
extern  bool        dspGCoffs       = false;
extern  bool        dspInfoHdr      = false;

#ifdef  LATE_DISASM
extern  bool        disAsm          = false;
extern  bool        disAsm2         = false;
#endif
#endif

#ifdef  DEBUGGING_SUPPORT
extern  bool        debugInfo       = false;
extern  bool        debuggableCode  = false;
extern  bool        debugEnC        = false;
#endif

extern  unsigned    testMask        = 0;

/*****************************************************************************/

void            jitOnDllProcessAttach();
void            jitOnDllProcessDetach();

BOOL WINAPI     DllMain(HANDLE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls((HINSTANCE)hInstance);
        jitOnDllProcessAttach();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        jitOnDllProcessDetach();
    }

    return TRUE;
}

/*****************************************************************************
 *
 *  Convert the type returned from the VM to a var_type.
 */

inline var_types           JITtype2varType(CorInfoType type)
{

    static const unsigned char varTypeMap[CORINFO_TYPE_COUNT] =
    { // see the definition of enum CorInfoType in file inc/corinfo.h
      TYP_UNDEF,        // CORINFO_TYPE_UNDEF           = 0x0,
      TYP_VOID,         // CORINFO_TYPE_VOID            = 0x1,
      TYP_BOOL,         // CORINFO_TYPE_BOOL            = 0x2,
      TYP_CHAR,         // CORINFO_TYPE_CHAR            = 0x3,
      TYP_BYTE,         // CORINFO_TYPE_BYTE            = 0x4,
      TYP_UBYTE,        // CORINFO_TYPE_UBYTE           = 0x5,
      TYP_SHORT,        // CORINFO_TYPE_SHORT           = 0x6,
      TYP_CHAR,         // CORINFO_TYPE_USHORT          = 0x7,
      TYP_INT,          // CORINFO_TYPE_INT             = 0x8,
      TYP_INT,          // CORINFO_TYPE_UINT            = 0x9,
      TYP_LONG,         // CORINFO_TYPE_LONG            = 0xa,
      TYP_LONG,         // CORINFO_TYPE_ULONG           = 0xb,
      TYP_FLOAT,        // CORINFO_TYPE_FLOAT           = 0xc,
      TYP_DOUBLE,       // CORINFO_TYPE_DOUBLE          = 0xd,
      TYP_REF,          // CORINFO_TYPE_STRING          = 0xe,         // Not used, should remove
      TYP_INT,          // CORINFO_TYPE_PTR             = 0xf,
      TYP_BYREF,        // CORINFO_TYPE_BYREF           = 0x10,
      TYP_STRUCT,       // CORINFO_TYPE_VALUECLASS      = 0x11,
      TYP_REF,          // CORINFO_TYPE_CLASS           = 0x12,
      TYP_STRUCT,       // CORINFO_TYPE_REFANY          = 0x13,
    };

    // spot check to make certain enumerations have not changed

    assert(varTypeMap[CORINFO_TYPE_CLASS]      == TYP_REF   );
    assert(varTypeMap[CORINFO_TYPE_BYREF]      == TYP_BYREF );
    assert(varTypeMap[CORINFO_TYPE_PTR]        == TYP_INT   );
    assert(varTypeMap[CORINFO_TYPE_INT]        == TYP_INT   );
    assert(varTypeMap[CORINFO_TYPE_UINT]       == TYP_INT   );
    assert(varTypeMap[CORINFO_TYPE_DOUBLE]     == TYP_DOUBLE);
    assert(varTypeMap[CORINFO_TYPE_VOID]       == TYP_VOID  );
    assert(varTypeMap[CORINFO_TYPE_VALUECLASS] == TYP_STRUCT);
    assert(varTypeMap[CORINFO_TYPE_REFANY]     == TYP_STRUCT);

    assert(type < CORINFO_TYPE_COUNT);
    assert(varTypeMap[type] != TYP_UNDEF);

    return((var_types) varTypeMap[type]);
};

/*****************************************************************************/

#if DUMP_PTR_REFS
static
void                dumpPtrs(void *methodAddr, void *methodInfo);
#else
inline
void                dumpPtrs(void *methodAddr, void *methodInfo){}
#endif

/*****************************************************************************/


static
bool                JITcsInited;

/*****************************************************************************
 *  jitOnDllProcessAttach() called by DllMain() when jit.dll is loaded
 */

void jitOnDllProcessAttach()
{
    Compiler::compStartup();
}

/*****************************************************************************
 *  jitOnDllProcessDetach() called by DllMain() when jit.dll is unloaded
 */

void jitOnDllProcessDetach()
{
    Compiler::compShutdown();
}

/*****************************************************************************
 *  Called just before the function is JIT'ed
 */

#ifdef DEBUG
const char * jitClassName  = NULL;
const char * jitMethodName = NULL;
extern bool  stopAtMethod  = false;
#endif

inline
bool                jitBeforeCompiling (COMP_HANDLE    compHandle,
                                        CORINFO_MODULE_HANDLE   scopeHandle,
                                        CORINFO_METHOD_HANDLE  methodHandle,
                                        void *         methodCodePtr)
{
#ifdef DEBUG

    jitMethodName = compHandle->getMethodName(methodHandle, &jitClassName);

    if (verbose) printf("Compiling %s.%s\n", jitClassName, jitMethodName);

#endif // DEBUG

    return true;
}


/*****************************************************************************
 *  Called after the function has been jit'ed
 */

inline
void                jitOnCompilingDone (COMP_HANDLE    compHandle,
                                        CORINFO_MODULE_HANDLE   scopeHandle,
                                        CORINFO_METHOD_HANDLE  methodHandle,
                                        void *         methodCodePtr,
                                        int            result)
{
#ifdef DEBUG
    if  (0)
    {
        jitMethodName = compHandle->getMethodName(methodHandle, &jitClassName);
        printf("Generated code at %08X for %s.%s\n", methodCodePtr, jitClassName, jitMethodName);
    }

//  if  (methodCodePtr == (void *)0x023c060d) { __asm int 3 }

#endif
}

/*****************************************************************************/
/* FIX, really the ICorJitCompiler should be done as a COM object, this is just
   something to get us going */

ICorJitCompiler* getJit()
{
    static char CILJitBuff[sizeof(CILJit)];
    if (ILJitter == 0)
        ILJitter = new(CILJitBuff) CILJit();
    return(ILJitter);
}

/*****************************************************************************
 *  The main JIT function
 */
CorJitResult __stdcall CILJit::compileMethod (
            ICorJitInfo*       compHnd,
            CORINFO_METHOD_INFO* methodInfo,
            unsigned        flags,
            BYTE **         entryAddress,
            ULONG  *        nativeSizeOfCode)
{
    int             result;
    void *          methodCodePtr = NULL;
    void *          methodDataPtr = NULL;
    void *          methodConsPtr = NULL;
    void *          methodInfoPtr = NULL;
    CORINFO_METHOD_HANDLE   methodHandle  = methodInfo->ftn;

#ifdef DEBUG
	LogEnv curEnv(compHnd);		// caputure state needed for error reporting
#endif

    if  (!JITcsInited)
    {
        if  (flags & CORJIT_FLG_TARGET_PENTIUM)
            genCPU = 5;
        else if (flags & CORJIT_FLG_TARGET_PPRO)
            genCPU = 6;
        else if (flags & CORJIT_FLG_TARGET_P4)
            genCPU = 7;
        else
            genCPU = 4;

        /* Offset of the acutal mem ptr in the proxy NStruct object */

        Compiler::Info::compNStructIndirOffset = compHnd->getIndirectionOffset();

        JITcsInited = true;
    }

    assert((flags & (CORJIT_FLG_TARGET_PENTIUM|CORJIT_FLG_TARGET_PPRO|CORJIT_FLG_TARGET_P4))
                 != (CORJIT_FLG_TARGET_PENTIUM|CORJIT_FLG_TARGET_PPRO|CORJIT_FLG_TARGET_P4));

    assert(((genCPU == 5) && (flags&CORJIT_FLG_TARGET_PENTIUM)) ||
           ((genCPU == 6) && (flags&CORJIT_FLG_TARGET_PPRO)) ||
           ((genCPU == 7) && (flags&CORJIT_FLG_TARGET_P4)) ||
            (genCPU == 4) || true);
    
    assert(methodInfo->ILCode);

    jitBeforeCompiling(compHnd, methodInfo->scope, methodHandle, methodInfo->ILCode);

    result = jitNativeCode(methodHandle,
                           methodInfo->scope,
                           compHnd,
                           methodInfo,
                           &methodCodePtr,
                           nativeSizeOfCode,
                           &methodConsPtr,
                           &methodDataPtr,
                           &methodInfoPtr,
                           flags);

    jitOnCompilingDone(compHnd, methodInfo->scope, methodHandle, methodCodePtr, result);

	if (result == CORJIT_OK)
        *entryAddress = (BYTE*)methodCodePtr;


	return CorJitResult(result);
}

/*****************************************************************************
 * Returns the number of bytes required for the given type argument
 */

unsigned           Compiler::eeGetArgSize(CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO* sig)
{
    CORINFO_CLASS_HANDLE        argClass;
    CorInfoType argTypeJit = strip(info.compCompHnd->getArgType(sig, list, &argClass));
    var_types argType = JITtype2varType(argTypeJit);

    if (argType == TYP_STRUCT)
    {
		unsigned structSize = info.compCompHnd->getClassSize(argClass);

			// make certain the EE passes us back the right thing for refanys
        assert(argTypeJit != CORINFO_TYPE_REFANY || structSize == 2*sizeof(void*));

		return roundUp(structSize, sizeof(int));
    }
    else
    {
        size_t  argSize = sizeof(int) * genTypeStSz(argType);
        if ((argSize == 0) || (argSize > sizeof(__int64)))
            BADCODE("Illegal size of argument or local");
        return  argSize;
    }
}

/*****************************************************************************/

GenTreePtr          Compiler::eeGetPInvokeCookie(CORINFO_SIG_INFO *szMetaSig)
{
    void * cookie, * pCookie;
    cookie = info.compCompHnd->GetCookieForPInvokeCalliSig(szMetaSig, &pCookie);
    assert((cookie == NULL) != (pCookie == NULL));

    return gtNewIconEmbHndNode(cookie, pCookie, GTF_ICON_PINVKI_HDL);
}

/*****************************************************************************/

void                Compiler::eeGetStmtOffsets()
{
    info.compLineNumCount = 0;

    ULONG32                      offsetsCount;
    DWORD                   *    offsets;
    ICorDebugInfo::BoundaryTypes offsetsImplicit;

    info.compCompHnd->getBoundaries(info.compMethodHnd,
                                    &offsetsCount,
                                    &offsets,
                                    &offsetsImplicit);

    /* Set the implicit boundaries */

    assert(Compiler::STACK_EMPTY_BOUNDARIES == ICorDebugInfo::STACK_EMPTY_BOUNDARIES);
    assert(Compiler::CALL_SITE_BOUNDARIES   == ICorDebugInfo::CALL_SITE_BOUNDARIES  );
    assert(Compiler::ALL_BOUNDARIES         == ICorDebugInfo::ALL_BOUNDARIES        );
    info.compStmtOffsetsImplicit = (ImplicitStmtOffsets)offsetsImplicit;

    /* Process the explicit boundaries */

    info.compStmtOffsetsCount = 0;

    if (offsetsCount == 0)
        return;

    info.compStmtOffsets = (IL_OFFSET *)compGetMemArray(offsetsCount, sizeof(info.compStmtOffsets[0]));

    for(unsigned i = 0; i < offsetsCount; i++)
    {
        if (offsets[i] > info.compCodeSize)
            continue;

        info.compStmtOffsets[info.compStmtOffsetsCount] = offsets[i];
        info.compStmtOffsetsCount++;
    }

    /* @TODO [REVISIT] [04/16/01] []: If we dont need to do the above filtering, just use the return values
    info.compCompHnd->getBoundaries((SIZE_T*)&info.compStmtOffsetsCount,
                                    (SIZE_T**)&info.compStmtOffsets,
                                    (int *)&info.compStmtOffsetsImplicit);
    */

    info.compCompHnd->freeArray(offsets);
}

/*****************************************************************************/

bool            Compiler::compGetVarsExtendOthers(unsigned      varNum,
                                                  bool *        varInfoProvided,
                                                  LocalVarDsc * localVarPtr)
{
    if (varInfoProvided[varNum])
        return false;

    // Create a varInfo with scope over the entire method

    localVarPtr->lvdLifeBeg = 0;
    localVarPtr->lvdLifeEnd = info.compCodeSize;
    localVarPtr->lvdVarNum  = varNum;
#ifdef DEBUG
    localVarPtr->lvdName    = NULL;
#endif
    localVarPtr->lvdLVnum   = info.compLocalVarsCount;

    info.compLocalVarsCount++;
    return true;
}

/*****************************************************************************/

#include "malloc.h"     // for alloca

void            Compiler::eeGetVars()
{
    ICorDebugInfo::ILVarInfo *  varInfoTable;
    ULONG32                     varInfoCount;
    bool                        extendOthers;

    info.compCompHnd->getVars(info.compMethodHnd,
                              &varInfoCount, &varInfoTable, &extendOthers);
    //printf("LVin count = %d\n", varInfoCount);

    // Over allocate in case extendOthers is set.

    SIZE_T  varInfoCountExtra = varInfoCount;
    if (extendOthers)
        varInfoCountExtra += info.compLocalsCount;

    if (varInfoCountExtra == 0)
        return;

    info.compLocalVars =
        (LocalVarDsc *)compGetMemArray(varInfoCountExtra, sizeof(info.compLocalVars[0]));

    /* @TODO [REVISIT] [04/16/01] []: Once LocalVarDsc exactly matches ICorDebugInfo::ILVarInfo,
       there is no need to do this copy operation. Get rid of it
     */

    LocalVarDsc * localVarPtr = info.compLocalVars;
    ICorDebugInfo::ILVarInfo *v = varInfoTable;

    for (unsigned i = 0; i < varInfoCount; i++, localVarPtr++, v++)
    {
#ifdef DEBUG
        if (verbose)
            printf("var:%d start:%d end:%d\n",
                   v->varNumber,
                   v->startOffset,
                   v->endOffset);
#endif

        // @TODO [CONSIDER] [04/16/01] []: assert here?
        if (v->startOffset >= v->endOffset)
            continue;

        assert(v->startOffset <= info.compCodeSize);
        assert(v->endOffset   <= info.compCodeSize);

        localVarPtr->lvdLifeBeg = v->startOffset;
        localVarPtr->lvdLifeEnd = v->endOffset;
#ifdef DEBUG
        localVarPtr->lvdName    = NULL;
#endif
        localVarPtr->lvdLVnum   = i;
        localVarPtr->lvdVarNum  = compMapILvarNum(v->varNumber);

        if (localVarPtr->lvdVarNum == -1)
            continue;

        info.compLocalVarsCount++;
    }

    /* If extendOthers is set, then assume the scope of unreported vars
       is the entire method. Note that this will cause fgExtendDbgLifetimes()
       to zero-initalize all of them. This will be expensive if its used
       for too many variables
     */
    if  (extendOthers)
    {
        // Allocate a bit-array for all the variables and initialize to false

        bool * varInfoProvided = (bool *)alloca(info.compLocalsCount *
                                                sizeof(varInfoProvided[0]));
        for (unsigned i = 0; i < info.compLocalsCount; i++)
            varInfoProvided[i] = false;

        // Find which vars have absolutely no varInfo provided

        for (i = 0; i < info.compLocalVarsCount; i++)
            varInfoProvided[info.compLocalVars[i].lvdVarNum] = true;

        // Create entries for the variables with no varInfo

        for (unsigned varNum = 0; varNum < info.compLocalsCount; varNum++)
            localVarPtr += compGetVarsExtendOthers(varNum, varInfoProvided, localVarPtr) ? 1 : 0;
    }

    assert(localVarPtr <= info.compLocalVars + varInfoCountExtra);

    if (varInfoCount != 0)
        info.compCompHnd->freeArray(varInfoTable);
}

/*****************************************************************************
 *
 *                      Utility functions
 */

#if defined(DEBUG) || INLINE_MATH

/*****************************************************************************/
const char*         Compiler::eeGetMethodName(CORINFO_METHOD_HANDLE       method,
                                              const char** classNamePtr)
{
    if  (eeGetHelperNum(method))
    {
        if (classNamePtr != 0)
            *classNamePtr = "HELPER";
        return eeHelperMethodName(eeGetHelperNum(method));
    }

    if (eeIsNativeMethod(method))
        method = eeGetMethodHandleForNative(method);

    return(info.compCompHnd->getMethodName(method, classNamePtr));
}

const char *        Compiler::eeGetFieldName  (CORINFO_FIELD_HANDLE field,
                                             const char * *     classNamePtr)
{
    return(info.compCompHnd->getFieldName(field, classNamePtr));
}

#endif


#ifdef DEBUG
void Compiler::eeUnresolvedMDToken (CORINFO_MODULE_HANDLE   cls,
                                    unsigned       token,
                                    const char *   errMsg)
{
    char buff[1024];
    const char *name = info.compCompHnd->findNameOfToken(cls, token);
    wsprintfA(buff, "%s: could not resolve meta data token (%s) (class not found?)", errMsg, name);
    NO_WAY(buff);
}


const wchar_t * FASTCALL   Compiler::eeGetCPString (unsigned strHandle)
{
    char buff[512 + sizeof(CORINFO_String)];

    // make this bulletproof, so it works even if we are wrong.  
    if (ReadProcessMemory(GetCurrentProcess(), (void*) strHandle, buff, 4, 0) == 0)
        return(0);

    CORINFO_String* asString = *((CORINFO_String**) strHandle);
    if (ReadProcessMemory(GetCurrentProcess(), asString, buff, sizeof(buff), 0) == 0)
        return(0);

    if (asString->buffLen   >= 256                || 
        asString->stringLen >= asString->buffLen  || 
        asString->chars[asString->stringLen] != 0   )
    {
        return 0;
    }

    return(asString->chars);
}


const char * FASTCALL   Compiler::eeGetCPAsciiz (unsigned       cpx)
{
    return "<UNKNOWN>";
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\disasm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          DisAsm                                           XX  
XX                                                                           XX
XX  The dis-assembler to display the native code generated                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#ifndef _DIS_H_
#define _DIS_H_
/*****************************************************************************/
#ifdef LATE_DISASM
/*****************************************************************************/

void                        disOpenForLateDisAsm(const char * curClassName, 
                                                  const char * curMethodName);



class Compiler;


class DisAssembler
{
public :

    // Constructor
    void            disInit(Compiler * pComp);

    /* Address of the code block to dissasemble */
    DWORD           codeBlock;

    /* Address where the code block is to be loaded */
    DWORD           startAddr;

    /* Size of the code to dissasemble */
    DWORD           codeSize;

    /* Current offset in the code block */
    DWORD           curOffset;

    /* Size (in bytes) of current dissasembled instruction */
    size_t          instSize;

    /* Target address of a jump */
    DWORD           target;

    /* labeling counter */
    unsigned char   label;

    /* temporary buffer for function names */
    char            funcTempBuf[1024];

    /* flag that signals when replacing a symbol name has been deferred for following callbacks */
    int             disHasName;

    /* class, member, method name to be printed */
    const char *    methodName;
    const char *    memberName;
    const char *    className;


    BYTE *          disJumpTarget;

    void            DisasmBuffer ( DWORD         addr,
                                    const BYTE *  rgb,
                                    DWORD         cbBuffer,
                                    FILE  *       pfile,
                                    int           printit );

    static FILE *   s_disAsmFile;

    void            disAsmCode(BYTE * codePtr, unsigned size);

    Compiler *      disComp;

};




/*****************************************************************************/
#endif  // LATE_DISASM
/*****************************************************************************/
#endif  // _DIS_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\eeinterface.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          EEInterface                                      XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

// ONLY FUNCTIONS common to all variants of the JIT (EXE, DLL) should go here)
// otherwise they belong in the corresponding directory.

#include "jitpch.h"
#pragma hdrstop

#if defined(DEBUG)

/*****************************************************************************/
const char* Compiler::eeGetMethodFullName (CORINFO_METHOD_HANDLE  hnd)
{
    char* ptr;
    const char* returnType = NULL;

    const char* className;
    const char* methodName = eeGetMethodName(hnd, &className);

    unsigned length = 0;
    unsigned i;

    /* Generating the full signature is a two-pass process. First we have to walk
       the components in order to asses the total size, then we allocate the buffer
       and copy the elements into it.
     */


    /* Right now there is a race-condition in the EE, className can be NULL */

    /* initialize length with length of className and '.' */

    if (className)
        length = strlen(className)+1;
    else
    {
        assert(strlen("<NULL>.") == 7);
        length = 7;
    }

    /* add length of methodName and opening bracket */
    length += strlen(methodName) + 1;

    CORINFO_SIG_INFO sig;
    eeGetMethodSig(hnd, &sig);
    CORINFO_ARG_LIST_HANDLE argLst = sig.args;

    for(i = 0; i < sig.numArgs; i++)
    {
        var_types type = eeGetArgType(argLst, &sig);

        length += strlen(varTypeName(type));
        argLst = eeGetArgNext(argLst);
    }

    /* add ',' if there is more than one argument */

    if (sig.numArgs > 1)
        length += (sig.numArgs - 1);

    if (JITtype2varType(sig.retType) != TYP_VOID)
    {
        returnType = varTypeName(JITtype2varType(sig.retType));
        length += strlen(returnType) + 1; // don't forget the delimiter ':'
    }

    /* add closing bracket and null terminator */

    length += 2;

    char *retName = (char*)compGetMemA(length);

    /* Now generate the full signature string in the allocated buffer */

    if (className)
    {
        strcpy(retName, className);
        strcat(retName, ".");
    }
    else
        strcpy(retName, "<NULL>.");
    strcat(retName, methodName);

    ptr = &retName[strlen(retName)];

        // append the signature
    *ptr++ = '(';

    argLst = sig.args;

    for(i = 0; i < sig.numArgs; i++)
    {
        var_types type = eeGetArgType(argLst, &sig);
        strcpy(ptr, varTypeName(type));
        ptr = &ptr[strlen(ptr)];

        argLst = eeGetArgNext(argLst);
                if (i + 1 < sig.numArgs)
                        *ptr++ = ',';
    }

    *ptr++ = ')';

    if (returnType)
    {
        *ptr++ = ':';
        strcpy(ptr, returnType);
        ptr = &ptr[strlen(ptr)];
    }

    *ptr = 0;

    assert(strlen(retName) == (length-1));

    return(retName);
}

#endif // DEBUG

#if defined(DEBUG) || INLINE_MATH
/*****************************************************************************/

const char *        Compiler::eeHelperMethodName(int helper)
{
    assert(helper < CORINFO_HELP_COUNT);

    const   char *  name;

    switch (helper)
    {
    case CORINFO_HELP_ISINSTANCEOF          : name = "@isType"              ; break;
    case CORINFO_HELP_ISINSTANCEOFCLASS     : name = "@isTypeClass"         ; break;
    case CORINFO_HELP_CHKCASTCLASS          : name = "@checkCastClass"      ; break;
    case CORINFO_HELP_CHKCAST               : name = "@checkCast"           ; break;
    case CORINFO_HELP_NEWFAST               : name = "@newClassFast"        ; break;
    case CORINFO_HELP_RNGCHKFAIL            : name = "@indexFailed"         ; break;
    case CORINFO_HELP_THROW                 : name = "@throw"               ; break;
    case CORINFO_HELP_RETHROW               : name = "@rethrow"             ; break;
    case CORINFO_HELP_STRCNS                : name = "@stringCns"           ; break;
    case CORINFO_HELP_MON_ENTER             : name = "@enterCrit"           ; break;
    case CORINFO_HELP_MON_EXIT              : name = "@exitCrit"            ; break;
    case CORINFO_HELP_EnC_RESOLVEVIRTUAL    : name = "@encResolveVirt"      ; break;

    case CORINFO_HELP_GETFIELD32            : name = "@getCOMfld32"         ; break;
    case CORINFO_HELP_GETFIELD64            : name = "@getCOMfld64"         ; break;
    case CORINFO_HELP_SETFIELD32            : name = "@putCOMfld32"         ; break;
    case CORINFO_HELP_SETFIELD64            : name = "@putCOMfld64"         ; break;
    case CORINFO_HELP_GETFIELD32OBJ         : name = "@getfldObj"           ; break;
    case CORINFO_HELP_SETFIELD32OBJ         : name = "@putfldObj"           ; break;
    case CORINFO_HELP_GETFIELDADDR          : name = "@getFldAddr"          ; break;
    case CORINFO_HELP_ARRADDR_ST            : name = "@addrArrStore"        ; break;
    case CORINFO_HELP_LDELEMA_REF           : name = "@ldelemaRef"          ; break;
    case CORINFO_HELP_MON_ENTER_STATIC      : name = "@monEnterStat"        ; break;
    case CORINFO_HELP_MON_EXIT_STATIC       : name = "@monExitStat"         ; break;

    case CORINFO_HELP_LLSH                  : name = "@longLSH"             ; break;
    case CORINFO_HELP_LRSH                  : name = "@longRSH"             ; break;
    case CORINFO_HELP_LRSZ                  : name = "@longRSZ"             ; break;
    case CORINFO_HELP_LMUL                  : name = "@longMul"             ; break;
    case CORINFO_HELP_LDIV                  : name = "@longDiv"             ; break;
    case CORINFO_HELP_LMOD                  : name = "@longMod"             ; break;
    case CORINFO_HELP_DBL2INT               : name = "@doubleToInt"         ; break;
    case CORINFO_HELP_DBL2UINT              : name = "@doubleToUInt"        ; break;
    case CORINFO_HELP_DBL2LNG               : name = "@doubleToLong"        ; break;
    case CORINFO_HELP_DBL2ULNG              : name = "@doubleToULong"       ; break;
    case CORINFO_HELP_ULNG2DBL              : name = "@ulongTodouble"       ; break;
    case CORINFO_HELP_DBLREM                : name = "@doubleRem"           ; break;
    case CORINFO_HELP_FLTREM                : name = "@floatRem"            ; break;

    case CORINFO_HELP_NEW_DIRECT            : name = "@newClassDirect"      ; break;
    case CORINFO_HELP_NEWARR_1_DIRECT       : name = "@newObjArrayDirect"   ; break;
    case CORINFO_HELP_NEWARR_1_OBJ          : name = "@newObjArray_1"       ; break;
    case CORINFO_HELP_NEWARR_1_VC           : name = "@newArray_VC"         ; break;
    case CORINFO_HELP_NEW_SPECIALDIRECT     : name = "@newClassDirectSpecial";break;
    case CORINFO_HELP_NEW_CROSSCONTEXT      : name = "@newCrossContext"     ; break;

    case CORINFO_HELP_STOP_FOR_GC           : name = "@call_GC"             ; break;
    case CORINFO_HELP_ASSIGN_REF_EAX        : name = "@GcRegAsgnEAX"        ; break;
    case CORINFO_HELP_ASSIGN_REF_EBX        : name = "@GcRegAsgnEBX"        ; break;
    case CORINFO_HELP_ASSIGN_REF_ECX        : name = "@GcRegAsgnECX"        ; break;
    case CORINFO_HELP_ASSIGN_REF_ESI        : name = "@GcRegAsgnESI"        ; break;
    case CORINFO_HELP_ASSIGN_REF_EDI        : name = "@GcRegAsgnEDI"        ; break;
    case CORINFO_HELP_ASSIGN_REF_EBP        : name = "@GcRegAsgnEBP"        ; break;

    case CORINFO_HELP_ULDIV                 : name = "@ulongDiv"            ; break;
    case CORINFO_HELP_ULMOD                 : name = "@ulongMod"            ; break;
    case CORINFO_HELP_LMUL_OVF              : name = "@longMul.ovf"         ; break;
    case CORINFO_HELP_ULMUL_OVF             : name = "@ulongMul.ovf"        ; break;
    case CORINFO_HELP_DBL2INT_OVF           : name = "@doubleToInt.ovf"     ; break;
    case CORINFO_HELP_DBL2UINT_OVF          : name = "@doubleToUInt.ovf"    ; break;
    case CORINFO_HELP_DBL2LNG_OVF           : name = "@doubleToLng.ovf"     ; break;
    case CORINFO_HELP_DBL2ULNG_OVF          : name = "@doubleToULng.ovf"    ; break;
    case CORINFO_HELP_INITCLASS             : name = "@initClass"           ; break;
    case CORINFO_HELP_USER_BREAKPOINT       : name = "@breakPoint"          ; break;
    case CORINFO_HELP_OVERFLOW              : name = "@arithExcpn"          ; break;
    case CORINFO_HELP_NEWOBJ                : name = "@newObj"              ; break;
    case CORINFO_HELP_ASSIGN_BYREF          : name = "@GcByRefAsgn"         ; break;

    case CORINFO_HELP_CHECKED_ASSIGN_REF_EAX    : name = "@GcRegChkAsgnEAX"     ; break;
    case CORINFO_HELP_CHECKED_ASSIGN_REF_EBX    : name = "@GcRegChkAsgnEBX"     ; break;
    case CORINFO_HELP_CHECKED_ASSIGN_REF_ECX    : name = "@GcRegChkAsgnECX"     ; break;
    case CORINFO_HELP_CHECKED_ASSIGN_REF_ESI    : name = "@GcRegChkAsgnESI"     ; break;
    case CORINFO_HELP_CHECKED_ASSIGN_REF_EDI    : name = "@GcRegChkAsgnEDI"     ; break;
    case CORINFO_HELP_CHECKED_ASSIGN_REF_EBP    : name = "@GcRegChkAsgnEBP"     ; break;

    case CORINFO_HELP_BOX                   : name = "@Box"                 ; break;
    case CORINFO_HELP_UNBOX                 : name = "@Unbox"               ; break;
    case CORINFO_HELP_GETREFANY             : name = "@GetRefAny"           ; break;
    case CORINFO_HELP_NEWSFAST              : name = "@newClassSmall"       ; break;
    case CORINFO_HELP_NEWSFAST_ALIGN8       : name = "@newClassSmallAlign8" ; break;
    case CORINFO_HELP_ENDCATCH              : name = "@endcatch"            ; break;
#ifdef PROFILER_SUPPORT
    case CORINFO_HELP_PROF_FCN_CALL         : name = "@ProfEvCall"          ; break;
    case CORINFO_HELP_PROF_FCN_RET          : name = "@ProfEvReturned"      ; break;
    case CORINFO_HELP_PROF_FCN_ENTER        : name = "@ProfEvEnter"         ; break;
    case CORINFO_HELP_PROF_FCN_LEAVE        : name = "@ProfEvLeave"         ; break;
    case CORINFO_HELP_PROF_FCN_TAILCALL     : name = "@ProfEvTailcall"      ; break;
#endif
    case CORINFO_HELP_GETSHAREDSTATICBASE   : name = "@StaticBase"          ; break;

    case CORINFO_HELP_PINVOKE_CALLI         : name = "@pinvokeCalli"        ; break;
    case CORINFO_HELP_TAILCALL              : name = "@tailCall"            ; break;

    case CORINFO_HELP_SEC_UNMGDCODE_EXCPT   : name = "@SecurityUnmanagedCodeException" ; break;

#if !   CPU_HAS_FP_SUPPORT

    case CPX_R4_NEG                 : name = "@fltNeg"              ; break;
    case CPX_R8_NEG                 : name = "@dblNeg"              ; break;

    case CPX_R4_ADD                 : name = "@fltAdd"              ; break;
    case CPX_R8_ADD                 : name = "@dblAdd"              ; break;
    case CPX_R4_SUB                 : name = "@fltSub"              ; break;
    case CPX_R8_SUB                 : name = "@dblSub"              ; break;
    case CPX_R4_MUL                 : name = "@fltMul"              ; break;
    case CPX_R8_MUL                 : name = "@dblMul"              ; break;
    case CPX_R4_DIV                 : name = "@fltDiv"              ; break;
    case CPX_R8_DIV                 : name = "@dblDiv"              ; break;

    case CPX_R4_EQ                  : name = "@fltEQ"               ; break;
    case CPX_R8_EQ                  : name = "@dblEQ"               ; break;
    case CPX_R4_NE                  : name = "@fltNE"               ; break;
    case CPX_R8_NE                  : name = "@dblNE"               ; break;
    case CPX_R4_LT                  : name = "@fltLT"               ; break;
    case CPX_R8_LT                  : name = "@dblLT"               ; break;
    case CPX_R4_LE                  : name = "@fltLE"               ; break;
    case CPX_R8_LE                  : name = "@dblLE"               ; break;
    case CPX_R4_GE                  : name = "@fltGE"               ; break;
    case CPX_R8_GE                  : name = "@dblGE"               ; break;
    case CPX_R4_GT                  : name = "@fltGT"               ; break;
    case CPX_R8_GT                  : name = "@dblGT"               ; break;

    case CPX_R8_TO_I4               : name = "@dbltoint"            ; break;
    case CPX_R8_TO_I8               : name = "@dbltolng"            ; break;
    case CPX_R8_TO_R4               : name = "@dbltoflt"            ; break;

    case CPX_R4_TO_I4               : name = "@flttoint"            ; break;
    case CPX_R4_TO_I8               : name = "@flttolng"            ; break;
    case CPX_R4_TO_R8               : name = "@flttodbl"            ; break;

    case CPX_I4_TO_R4               : name = "@inttoflt"            ; break;
    case CPX_I4_TO_R8               : name = "@inttodbl"            ; break;
    case CPX_I8_TO_R4               : name = "@lngtoflt"            ; break;
    case CPX_I8_TO_R8               : name = "@lngtodbl"            ; break;
    case CPX_U4_TO_R4               : name = "@unstoflt"            ; break;
    case CPX_U4_TO_R8               : name = "@unstodbl"            ; break;
    case CPX_U8_TO_R4               : name = "@ulntoflt"            ; break;
    case CPX_U8_TO_R8               : name = "@ulntodbl"            ; break;

#ifdef  USE_HELPERS_FOR_INT_DIV
    case CPX_I4_DIV                 : name = "@intdiv"              ; break;
    case CPX_I4_MOD                 : name = "@intmod"              ; break;
    case CPX_U4_DIV                 : name = "@unsdiv"              ; break;
    case CPX_U4_MOD                 : name = "@unsmod"              ; break;
#endif

#endif

    case CORINFO_HELP_GETFIELDSTRUCT        : name = "@getFieldStruct"      ; break;
    case CORINFO_HELP_SETFIELDSTRUCT        : name = "@setFieldStruct"      ; break;
    case CORINFO_HELP_GETSTATICFIELDADDR    : name = "@getFieldStaticAddr"  ; break;

    default:
        static char buff[64];
        sprintf(buff, "@helper_%d", helper);
        name = buff;
        break;
    }

    return  name;
}

/*****************************************************************************/
#endif // defined(DEBUG) || INLINE_MATH
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emit.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMIT_H_
#define _EMIT_H_
/*****************************************************************************/
#include "emitTgt.h"
/*****************************************************************************/
#ifndef _INSTR_H_
#include "instr.h"
#endif
/*****************************************************************************/
#ifndef _GCINFO_H_
#include "GCInfo.h"
#endif
/*****************************************************************************/
#ifdef  TRANSLATE_PDB
#ifndef _ADDRMAP_INCLUDED_
#include "AddrMap.h"
#endif
#ifndef _LOCALMAP_INCLUDED_
#include "LocalMap.h"
#endif
#ifndef _PDBREWRITE_H_
#include "PDBRewrite.h"
#endif
#endif // TRANSLATE_PDB


/*****************************************************************************/
// This definition was pulled out of the SDK
#ifndef IMAGE_REL_BASED_REL32
#define IMAGE_REL_BASED_REL32                 7
#endif

/*****************************************************************************/
#pragma warning(disable:4200)           // allow arrays of 0 size inside structs

#define TRACK_GC_TEMP_LIFETIMES 0

/*****************************************************************************/

#ifndef TRACK_GC_REFS
#if     TGT_x86
#define TRACK_GC_REFS       1
#else
#define TRACK_GC_REFS       0
#endif
#endif

/*****************************************************************************/

#ifdef  DEBUG
#define EMITTER_STATS       0           // to get full stats (but no sizes!)
#define EMITTER_STATS_RLS   0           // don't use this one
#else
#define EMITTER_STATS       0           // don't use this one
#define EMITTER_STATS_RLS   0           // to get retail-only version of stats
#endif

#undef  EMITTER_STATS
#define EMITTER_STATS       0

#if     EMITTER_STATS
void                emitterStats();
#endif

/*****************************************************************************/

#define USE_LCL_EMIT_BUFF   1

/*****************************************************************************/

enum    GCtype
{
    GCT_NONE,
    GCT_GCREF,
    GCT_BYREF
};

//-----------------------------------------------------------------------------

inline
bool    needsGC(GCtype gcType)
{
    if (gcType == GCT_NONE)
    {
        return false;
    }
    else
    {
        assert(gcType == GCT_GCREF || gcType == GCT_BYREF);
        return true;
    }
}

//-----------------------------------------------------------------------------

#ifdef DEBUG

inline
bool                IsValidGCtype(GCtype gcType)
{
    return (gcType == GCT_NONE  ||
            gcType == GCT_GCREF ||
            gcType == GCT_BYREF);
}

// Get a string name to represent the GC type

inline
const char *        GCtypeStr(GCtype gcType)
{
    switch(gcType)
    {
    case GCT_NONE:      return "npt";
    case GCT_GCREF:     return "gcr";
    case GCT_BYREF:     return "byr";
    default:            assert(!"Invalid GCtype"); return "err";
    }
}

#endif

inline bool         insIsCMOV(instruction ins)
{
    return ((ins >= INS_cmovo) && (ins <= INS_cmovg));
}

/*****************************************************************************/

#ifdef  DEBUG
#define INTERESTING_JUMP_NUM    (1*999999)  // set to 0 to see all jump info
#undef  INTERESTING_JUMP_NUM
#define INTERESTING_JUMP_NUM    -1
#endif

/*****************************************************************************/

#define DEFINE_ID_OPS
#include "emitfmts.h"
#undef  DEFINE_ID_OPS

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************/

#if     TGT_x86
#define SCHED_INS_CNT_MIN   5                   // min. # of instrs we schedule
#else
#define SCHED_INS_CNT_MIN   2                   // min. # of instrs we schedule
#endif

#define SCHED_INS_CNT_MAX   64                  // max. # of instrs we schedule
typedef unsigned __int64    schedDepMap_tp;     // must match SCHED_INS_CNT_MAX
typedef unsigned char       schedInsCnt_tp;     // big enough to hold ins count

#define SCHED_FRM_CNT_MAX   32                  // max. frame values we track

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/

/*****************************************************************************
 *
 *  The actual size is in the low 4 bits, the upper 4 bits are flags
 *  TYP_REF is 4+32 and TYP_BYREF is 4+64 so that it can track GC refs.
 */

#if NEW_EMIT_ATTR
#undef EA_UNKNOWN
enum emitAttr { EA_UNKNOWN       = 0x000,
                EA_1BYTE         = 0x001,
                EA_2BYTE         = 0x002,
                EA_4BYTE         = 0x004,
                EA_8BYTE         = 0x008,
                EA_OFFSET_FLG    = 0x010,
                EA_OFFSET        = 0x014,       /* size ==  0 */
                EA_GCREF_FLG     = 0x020,
                EA_GCREF         = 0x024,       /* size == -1 */
                EA_BYREF_FLG     = 0x040,
                EA_BYREF         = 0x044,       /* size == -2 */
                EA_DSP_RELOC_FLG = 0x100,
                EA_CNS_RELOC_FLG = 0x200,
};
# define EA_ATTR(x)          ((emitAttr) (x))
# define EA_SIZE(x)          ((emitAttr) ( ((unsigned) (x)) &  0x00f)      )
# define EA_SIZE_IN_BYTES(x) ((size_t)   ( ((unsigned) (x)) &  0x00f)      )
# define EA_SET_SIZE(x,sz)   ((emitAttr) ((((unsigned) (x)) & ~0x00f) | sz))
# define EA_SET_FLG(x,flg)   ((emitAttr) ( ((unsigned) (x)) |  flg  )      )
# define EA_4BYTE_DSP_RELOC  (EA_SET_FLG(EA_4BYTE,EA_DSP_RELOC_FLG)        )
# define EA_4BYTE_CNS_RELOC  (EA_SET_FLG(EA_4BYTE,EA_CNS_RELOC_FLG)        )
# define EA_IS_OFFSET(x)     ((((unsigned) (x)) & ((unsigned) EA_OFFSET_FLG)) != 0)
# define EA_IS_GCREF(x)      ((((unsigned) (x)) & ((unsigned) EA_GCREF_FLG )) != 0)
# define EA_IS_BYREF(x)      ((((unsigned) (x)) & ((unsigned) EA_BYREF_FLG )) != 0)
# define EA_IS_DSP_RELOC(x)  ((((unsigned) (x)) & ((unsigned) EA_DSP_RELOC_FLG )) != 0)
# define EA_IS_CNS_RELOC(x)  ((((unsigned) (x)) & ((unsigned) EA_CNS_RELOC_FLG )) != 0)
#else
# undef  emitAttr
# define emitAttr            int
# define EA_1BYTE            (sizeof(char))
# define EA_2BYTE            (sizeof(short))
# define EA_4BYTE            (sizeof(int))
# define EA_8BYTE            (sizeof(double))
# define EA_OFFSET           (0)
# define EA_GCREF            (-1)
# define EA_BYREF            (-2)
# define EA_DSP_RELOC_FLG    (0)             /* Can't be done */
# define EA_DSP_RELOC        (EA_4BYTE)      /* Can't be done */
# define EA_CNS_RELOC_FLG    (0)             /* Can't be done */
# define EA_CNS_RELOC        (EA_4BYTE)      /* Can't be done */
# define EA_ATTR(x)          ((emitAttr) (x))
# define EA_SIZE(x)          (((x) > 0) ? (x) : EA_4BYTE)
# define EA_SIZE_IN_BYTES(x) ((size_t) (((x) > 0) ? (x) : sizeof(int)))
# define EA_SET_SIZE(x,sz)   (sz)
# define EA_SET_FLG(x,flg)   ((x) | flg)
# define EA_IS_OFFSET(x)     ((x) ==  0)
# define EA_IS_GCREF(x)      ((x) == -1)
# define EA_IS_BYREF(x)      ((x) == -2)
# define EA_IS_DSP_RELOC(x)  (0)             /* Can't be done */
# define EA_IS_CNS_RELOC(x)  (0)             /* Can't be done */
#endif

class   emitter
{
    friend  class   Compiler;

public:

    /*************************************************************************
     *
     *  Define the public entry points.
     */

    #include "emitpub.h"

protected:

    /************************************************************************/
    /*                        Miscellaneous stuff                           */
    /************************************************************************/

    Compiler    *   emitComp;

    typedef Compiler::varPtrDsc varPtrDsc;
    typedef Compiler::regPtrDsc regPtrDsc;
    typedef Compiler::CallDsc   callDsc;

#if USE_LCL_EMIT_BUFF

    static
   CRITICAL_SECTION emitCritSect;
    static
    bool            emitCrScInit;
    static
    bool            emitCrScBusy;

    bool            emitCrScUsed;

    static
    BYTE            emitLclBuff[];

    BYTE    *       emitLclBuffNxt;
    BYTE    *       emitLclBuffEnd;
    bool            emitLclBuffDst;

    size_t          emitLclAvailMem()
    {
        return  emitLclBuffEnd - emitLclBuffNxt;
    }

    void    *       emitLclAllocMem(size_t sz)
    {
        BYTE    *   p = emitLclBuffNxt;

        assert(sz % sizeof(int) == 0);
        assert(p + sz <= emitLclBuffEnd);

        emitLclBuffNxt  += sz;

#if EMITTER_STATS
        emitTotMemAlloc += sz;
        emitLclMemAlloc += sz;
#endif

        return  p;
    }

    void    *       emitGetAnyMem(size_t sz)
    {
        return  (sz <= emitLclAvailMem()) ? emitLclAllocMem(sz)
                                          :      emitGetMem(sz);
    }

#else

    void    *       emitGetAnyMem(size_t sz)
    {
        return  emitGetMem(sz);
    }

#endif

    inline
    void    *       emitGetMem(size_t sz)
    {
        assert(sz % sizeof(int) == 0);

#if EMITTER_STATS
        emitTotMemAlloc += sz;
        emitExtMemAlloc += sz;
#endif

        return  emitComp->compGetMem(sz);
    }

    static
    BYTE            emitSizeEnc[];
    static
    BYTE            emitSizeDec[];

    static
    unsigned        emitEncodeSize(emitAttr size);
    static
    emitAttr        emitDecodeSize(unsigned ensz);

#if     TRACK_GC_REFS

    static
    regMaskSmall    emitRegMasks[REG_COUNT];

    inline
    regMaskTP       emitRegMask(emitRegs reg)
    {
        assert(reg < sizeof(emitRegMasks)/sizeof(emitRegMasks[0]));

        return emitRegMasks[reg];
    }

    emitRegs       emitRegNumFromMask(unsigned mask);

#endif

    /************************************************************************/
    /*          The following describes an instruction group                */
    /************************************************************************/

    struct          insGroup
    {
        insGroup    *   igPrev;         // all instruction groups are
        insGroup    *   igNext;         // kept in a doubly-linked list

#ifdef  DEBUG
        insGroup    *   igSelf;         // for consistency checking
#endif

        unsigned        igOffs;         // offset of this group within method

#if     EMIT_USE_LIT_POOLS
        unsigned short  igLPuse1stW;    // offset of 1st word use in literal pool
        unsigned short  igLPuse1stL;    // offset of 1st long use in literal pool
        unsigned short  igLPuse1stA;    // offset of 1st addr use in literal pool
        unsigned short  igLPuseCntW;    // number of words used   in literal pool
        unsigned short  igLPuseCntL;    // number of longs used   in literal pool
        unsigned short  igLPuseCntA;    // number of addrs used   in literal pool
#endif

        unsigned short  igNum;          // for ordering (and display) purposes
        unsigned short  igSize;         // # of bytes of code in this group

#if     EMIT_TRACK_STACK_DEPTH
        unsigned        igStkLvl;       // stack level on entry
#endif

#if     TRACK_GC_REFS
        regMaskSmall    igGCregs;       // set of registers with live GC refs
#endif

        unsigned char   igInsCnt;       // # of instructions  in this group
        unsigned char   igFlags;        // see IGF_xxx below

    #define IGF_GC_VARS     0x0001      // new set of live GC ref variables
    #define IGF_BYREF_REGS  0x0002      // new set of live by-ref registers

    #define IGF_IN_TRY      0x0004      // this group is in a try(-catch) block

    #define IGF_EPILOG      0x0008      // this group belongs to the epilog

    #define IGF_HAS_LABEL   0x0010      // this IG is a target of a jump

    #define IGF_UPD_ISZ     0x0020      // some instruction sizes updated

    #define IGF_END_NOREACH 0x0040      // end of group is not reachable [RISC only]

    #define IGF_EMIT_ADD    0x0080      // this is a block added by the emiter
                                        // because the codegen block was too big

        BYTE    *       igData;         // addr of instruction descriptors

        unsigned        igByrefRegs()
        {
            assert(igFlags & IGF_BYREF_REGS);

            BYTE * ptr = (BYTE *)igData;

            if (igFlags & IGF_GC_VARS)
                ptr -= sizeof(VARSET_TP);

            ptr -= sizeof(unsigned);

            return *(unsigned *)ptr;
        }

    };

    // Currently, we only allow one IG for the prolog
    bool            emitIGisInProlog(insGroup * ig) { return ig == emitPrologIG; }

#if SCHEDULER
    bool            emitCanSchedIG(insGroup * ig)
    {
        // @TODO [REVISIT] [04/16/01] []: We dont schedule code in "try" blocks. Do it by recording
        // dependancies between idMayFault instrs, global variable instrs,
        // indirections, writes to vars which are live on entry to the handler
        // (approximated currently by all stack variables), etc.
#if TGT_x86
        return ((!emitIGisInProlog(ig)) && ((ig->igFlags & (IGF_IN_TRY|IGF_EPILOG)) == 0));
#else
        return ((!emitIGisInProlog(ig)) && ((ig->igFlags & (IGF_IN_TRY           )) == 0));
#endif
    }
#endif

    void            emitRecomputeIGoffsets();

    /************************************************************************/
    /*          The following describes a single instruction                */
    /************************************************************************/

    enum            _insFormats_enum
    {
        #define IF_DEF(en, op1, op2) IF_##en,
        #include "emitfmts.h"
        #undef  IF_DEF

        IF_COUNT
    };

#ifdef DEBUG
    typedef _insFormats_enum insFormats;
#else
    typedef BYTE insFormats;
#endif

    struct          emitLclVarAddr
    {
        short           lvaVarNum;
        unsigned short  lvaOffset;  // offset into the variable to access
#ifdef  DEBUG
        unsigned        lvaRefOfs;
#endif

        void            setVarNum(int varNum)
        {
            lvaVarNum = (short) varNum;
            
            if ((int) lvaVarNum != varNum)
            {
                IMPL_LIMITATION("JIT doesn't support more than 32767 variables\n");
            }
        }
    };

    struct          instrDescCns;

    struct          instrDesc
    {
        /* Store as enums for easier debugging, bytes in retail to save size */


        instruction     idIns;
        insFormats      idInsFmt;


        instruction     idInsGet() { return (instruction)idIns; }

        /*
            The following controls which fields get automatically cleared
            when an instruction descriptor is allocated. If you add lots
            more fields that need to be cleared (such as various flags),
            you might need to update the ID_CLEARxxx macros. Right now
            there are two areas that get cleared; this is because some
            instruction descriptors get allocated very small and don't
            contain the second area.

            See the body of emitter::emitAllocInstr() for more details.
         */

#define ID_CLEAR1_OFFS  0               // idIns,idInsFmt, and the following flags
#define ID_CLEAR1_SIZE  sizeof(int)     // all of these add up to one 32-bit word

        /*
            The idReg and idReg2 fields hold the first and second register
            operand(s), whenever these are present. Note that the size of
            these fields ranges from 3 to 6 bits, and extreme care needs
            to be taken to make sure all of the fields stay reasonably
            aligned.
         */

        unsigned short  idReg       :REGNUM_BITS;
        unsigned short  idRg2       :REGNUM_BITS;

        unsigned short  idTinyDsc   :1; // is this a "tiny"        descriptor?
        unsigned short  idScnsDsc   :1; // is this a "small const" descriptor?

#if     TGT_x86
        unsigned short  idCodeSize  :4; // size of instruction in bytes
#define ID1_BITS1       (2*REGNUM_BITS+1+1+4)
#elif   TGT_ARM
        unsigned        cond        :CONDNUM_BITS;
#define ID1_BITS1       (2*REGNUM_BITS+1+1+CONDNUM_BITS)
#else
        unsigned short  idSwap      :1; // swap with next ins (branch-delay)
#define ID1_BITS1       (2*REGNUM_BITS+1+1+1)
#endif

        unsigned short  idOpSize    :2; // operand size: 0=1 , 1=2 , 2=4 , 3=8

#define OPSZ1   0
#define OPSZ2   1
#define OPSZ4   2
#define OPSZ8   3

#if     TRACK_GC_REFS
        unsigned short  idGCref     :2; // GCref operand? (value is a "GCtype")
#define ID1_BITS2       (ID1_BITS1+2+2)
#else
#define ID1_BITS2       (ID1_BITS1+2)
#endif

        /* Note: (16-ID1_BITS2) bits are available here "for free" */
        // PPC: for RISC implementations, this is actually 32-ID1_BITS2 for free

#ifdef  DEBUG

        unsigned        idNum;          // for tracking down problems
        size_t          idSize;         // size of descriptor
        unsigned        idSrcLineNo;    // for displaying  source code

        int             idMemCookie;    // for display of member names in addr modes
        void    *       idClsCookie;    // for display of member names in addr modes

        unsigned short  idStrLit    :1; // set for "push offset string"
#endif

        /* Trivial wrappers to return properly typed enums */

        emitRegs        idRegGet     ()  { return (emitRegs)idReg; }
        emitRegs        idRg2Get     ()  { return (emitRegs)idRg2; }
        bool            idIsTiny     ()  { return (bool) idTinyDsc; }
        bool            idIsSmallCns ()  { return (bool) idScnsDsc; }
#if     TRACK_GC_REFS
        GCtype          idGCrefGet   ()  { return (GCtype)idGCref; }
#endif

#ifdef  TRANSLATE_PDB

        /* instruction descriptor source information for PDB translation */

        unsigned long   idilStart;
#endif

        /* NOTE: The "tiny" descriptor ends here */

#define TINY_IDSC_SIZE  offsetof(emitter::instrDesc, idInfo)

        struct
        {
            unsigned        idLargeCns  :1; // does a large constant     follow?
            unsigned        idLargeDsp  :1; // does a large displacement follow?

            unsigned        idLargeCall :1; // large call descriptor used

            unsigned        idMayFault  :1; // instruction may cause a fault

            unsigned        idBound     :1; // jump target / frame offset bound

            #define ID2_BITS1       5       // number of bits taken up so far

#if   TGT_x86
            unsigned        idCallRegPtr:1; // IL indirect calls: addr in reg
            unsigned        idCallAddr  :1; // IL indirect calls: can make a direct call to iiaAddr
            unsigned        idCallEDXLive:1;// IL calls; the EDX register is live
#ifndef RELOC_SUPPORT
            #define ID2_BITS2       (ID2_BITS1+3)
#else
            unsigned        idCnsReloc  :1; // LargeCns is an RVA and needs reloc tag
            unsigned        idDspReloc  :1; // LargeDsp is an RVA and needs reloc tag
            #define ID2_BITS2       (ID2_BITS1+3+2)
#endif
#elif TGT_MIPS32
            unsigned        idRg3       :REGNUM_BITS;
#  if TGT_MIPSFP
#  define FPFORMAT_BITS 5
            unsigned        idFPfmt     :FPFORMAT_BITS;
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS + FPFORMAT_BITS)
#  else
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS)
#  endif
#elif TGT_PPC
            unsigned        idRg3       :REGNUM_BITS;
            unsigned        idBit1      :1;
            unsigned        idBit2      :1;
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS + 1 + 1)
#elif TGT_ARM
            unsigned        idRg3       :REGNUM_BITS;
            //unsigned        cond        :CONDNUM_BITS;  // moved to tiny descriptor area
            unsigned        shift       :SHIFTER_BITS;
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS + SHIFTER_BITS + CONDNUM_BITS)
#elif TGT_SH3
            unsigned        idRelocType :2;
            #define ID2_BITS2       (ID2_BITS1 + 2)
#else
            #define ID2_BITS2       (ID2_BITS1)
#endif

            /* Use whatever bits are left over for small constants */

            #define ID_BIT_SMALL_CNS            (32-ID2_BITS2)

            unsigned        idSmallCns  :ID_BIT_SMALL_CNS;

            #define ID_MIN_SMALL_CNS            0
            #define ID_MAX_SMALL_CNS            ((1<<ID_BIT_SMALL_CNS)-1U)
        }
                        idInfo;

#if TGT_MIPS32
        emitRegs        idRg3MayGet ()  { return (idIsTiny()) ? SR_ZERO : idRg3Get();}
#endif
#if TGT_MIPS32 || TGT_ARM
        emitRegs        idRg3Get    ()  { return (emitRegs) idInfo.idRg3; }
#elif TGT_PPC
        void   setField1(USHORT field1)  { idReg = field1; }
        USHORT getField1()               { return (USHORT)idReg; }
        void   setField2(USHORT field2)  { idRg2 = field2; }
        USHORT getField2()               { return (USHORT)idRg2; }
        void   setField3(USHORT field3)  { idInfo.idRg3 = field3; }
        USHORT getField3()               { return (USHORT)idInfo.idRg3; }
        void   setImmed(USHORT immed)    { idInfo.idSmallCns = immed; }
        USHORT getImmed()                { return (USHORT)idInfo.idSmallCns; }
        void   setOE(USHORT OE)          { idInfo.idBit1 = OE;}
        USHORT getOE()                   { return (USHORT)idInfo.idBit1; }
        void   setRc(USHORT Rc)          { idInfo.idBit2 = Rc;}
        USHORT getRc()                   { return (USHORT)idInfo.idBit2; }
        void   setAA(USHORT AA)          { idInfo.idBit1 = AA;}
        USHORT getAA()                   { return (USHORT)idInfo.idBit1; }
        void   setLK(USHORT LK)          { idInfo.idBit2 = LK;}
        USHORT getLK()                   { return (USHORT)idInfo.idBit2; }
        void   setRelocHi(USHORT reloc)  { idInfo.idBit1 = reloc;}
        USHORT getRelocHi()              { return (USHORT)idInfo.idBit1; }
        void   setRelocLo(USHORT reloc)  { idInfo.idBit2 = reloc;}
        USHORT getRelocLo()              { return (USHORT)idInfo.idBit2; }
#endif
         /*
            See the body of emitter::emitAllocInstr() or the comments
            near the definition ID_CLEAR1_xxx above for more details
            on these macros.
         */

#define ID_CLEAR2_OFFS  (offsetof(emitter::instrDesc, idInfo))
#define ID_CLEAR2_SIZE  (sizeof(((emitter::instrDesc*)0)->idInfo))

        /* NOTE: The "small constant" descriptor ends here */

#define SCNS_IDSC_SIZE  offsetof(emitter::instrDesc, idAddr)

        union
        {
            emitLclVarAddr  iiaLclVar;
            instrDescCns *  iiaNxtEpilog;
            BasicBlock   *  iiaBBlabel;
            insGroup     *  iiaIGlabel;
            CORINFO_FIELD_HANDLE    iiaFieldHnd;
            CORINFO_METHOD_HANDLE   iiaMethHnd;
            void         *  iiaMembHnd; // method or field handle
            BYTE *          iiaAddr;
            int             iiaCns;
            BasicBlock  **  iiaBBtable;

            ID_TGT_DEP_ADDR
        }
                        idAddr;
    };

    struct          instrBaseCns    : instrDesc     // large const
    {
        long            ibcCnsVal;
    };

    struct          instrDescJmp    : instrDesc
    {
        instrDescJmp *  idjNext;        // next jump in the group/method
        insGroup     *  idjIG;          // containing group

#if TGT_RISC
        unsigned        idjCodeSize :24;// indirect jump size
        unsigned        idjJumpKind : 3;// see scIndJmpKinds enum
#endif

        unsigned        idjOffs     :24;// offset within IG / target offset
#if SCHEDULER
        unsigned        idjSched    : 1;// is the jump schedulable / moveable ?
#endif
        unsigned        idjShort    : 1;// is the jump known to be a short  one?
#if TGT_RISC
        unsigned        idjMiddle   : 1;// is the jump known to be a middle one?
        unsigned        idjAddBD    : 1;// does it need a branch-delay slot?
#endif

        union
        {
            BYTE         *  idjAddr;    // address of jump ins (for patching)
#if SCHEDULER
            USHORT          idjOffs[2]; // range of possible scheduled offsets
#endif
#if TGT_RISC
            unsigned        idjCount;   // indirect jump: # of jump targets
#endif
        }
                        idjTemp;
    };

    struct          instrDescCns    : instrDesc     // large const
    {
        long            idcCnsVal;
    };

    struct          instrDescDsp    : instrDesc     // large displacement
    {
        long            iddDspVal;
    };

    struct          instrDescAmd    : instrDesc     // large addrmode disp
    {
        long            idaAmdVal;
    };

    struct          instrDescDspCns : instrDesc     // large disp + cons
    {
        long            iddcDspVal;
        long            iddcCnsVal;
    };

    struct          instrDescDCM    : instrDescDspCns   // disp+cons+class mem
    {
        int             idcmCval;
    };

    struct          instrDescCIGCA  : instrDesc     // indir. call with ...
    {
        VARSET_TP       idciGCvars;                 // ... updated GC vars or
        unsigned        idciByrefRegs;              // ... byref registers
#if TGT_x86
        int             idciDisp;                   // ... big addrmode disp
#endif
        unsigned        idciArgCnt;                 // ... lots of args    or
    };

  //#if TGT_RISC && defined(DEBUG) && !defined(DLL_JIT)
#if TGT_RISC && defined(DEBUG)

    struct          instrDescDisp   : instrDesc
    {
        void        *   iddInfo;
        unsigned        iddNum;
        instrDesc   *   iddId;
    };

    struct          dspJmpInfo
    {
        instruction     iijIns;
#if TGT_SH3
        emitIndJmpKinds iijKind;
#endif
        unsigned        iijLabel;
        unsigned        iijTarget;

        union
        {
            emitRegs        iijReg;
            int             iijDist;
        }
                        iijInfo;
    };

#define dispSpecialIns(id,dst) ((disAsm || dspEmit) ? (emitDispIns(id, false, dspGCtbls, true, emitCurCodeOffs(dst)), (id)->iddNum++) : (void)0)

#else

#define dispSpecialIns(id,dst)

#endif

    insUpdateModes  emitInsUpdateMode(instruction ins);
    insFormats      emitInsModeFormat(instruction ins, insFormats base);

    static
    BYTE            emitInsModeFmtTab[];
#ifdef  DEBUG
    static
    unsigned        emitInsModeFmtCnt;
#endif

    int             emitGetInsCns   (instrDesc *id);
    int             emitGetInsDsp   (instrDesc *id);
    int             emitGetInsAmd   (instrDesc *id);
    int             emitGetInsDspCns(instrDesc *id, int   *dspPtr);
    int             emitGetInsSC    (instrDesc *id);
    int             emitGetInsCIdisp(instrDesc *id);
    unsigned        emitGetInsCIargs(instrDesc *id);

    /* Define the inline method that returns the size of a given instruction */

    int EMIT_GET_INS_SIZE();

    /************************************************************************/
    /*           A few routines used for debug display purposes             */
    /************************************************************************/

#ifdef  DEBUG

    unsigned        emitInsCount;

    unsigned        emitVarRefOffs;

    const   char *  emitRegName     (emitRegs       reg,
                                     emitAttr       size    = EA_4BYTE,
                                     bool           varName = true);
#if TGT_MIPSFP
    const   char *  emitFPRegName   (emitRegs       reg,
                                     emitAttr       size    = EA_4BYTE,
                                     bool           varName = true) {
                return emitRegName((emitRegs)(reg + 32), size, varName);
    }
#endif

    const   char *  emitFldName     (int            mem,
                                     void   *       cls);
    const   char *  emitFncName     (CORINFO_METHOD_HANDLE  callVal);

    static
    const char  *   emitIfName      (unsigned f);

    void            emitDispIGlist  (bool verbose = false);
    void            emitDispClsVar  (CORINFO_FIELD_HANDLE fldHnd, int offs, bool reloc = false);
    void            emitDispFrameRef(int varx, int offs, int disp, bool asmfm);

    void            emitDispInsOffs (unsigned offs, bool doffs);

#endif

    /************************************************************************/
    /*                      Method prolog and epilog                        */
    /************************************************************************/

    size_t          emitPrologSize;

    BYTE            emitEpilogCode[MAX_EPILOG_SIZE];
    size_t          emitEpilogSize;
    insGroup     *  emitEpilog1st;
    unsigned        emitEpilogCnt;
    bool            emitHasHandler;
#ifdef  DEBUG
    bool            emitHaveEpilog;         // epilog sequence has been defined?
#endif

    instrDescCns *  emitEpilogList;         // per method epilog list - head
    instrDescCns *  emitEpilogLast;         // per method epilog list - tail

    size_t          emitExitSeqStart;       // where the current epilog starts
    size_t          emitExitSeqSize;		// minimum size of any epilog

    /************************************************************************/
    /*           Members and methods used in PDB translation                */
    /************************************************************************/

#ifdef TRANSLATE_PDB

    inline void     SetIDSource( instrDesc *pID );
    void            MapCode    ( long ilOffset, BYTE *imgDest );
    void            MapFunc    ( long imgOff,
                                 long procLen,
                                 long dbgStart,
                                 long dbgEnd,
                                 short frameReg,
                                 long stkAdjust,
                                 int lvaCount,
                                 OptJit::LclVarDsc *lvaTable,
                                 bool framePtr );

    long                        emitInstrDescILBase;    // code offset of IL that produced this instruction desctriptor
    static AddrMap  *           emitPDBOffsetTable;     // translation table for mapping IL addresses to native addresses
    static LocalMap *           emitPDBLocalTable;      // local symbol translation table
    static bool                 emitIsPDBEnabled;       // flag to disable PDB translation code when a PDB is not found
    static BYTE     *           emitILBaseOfCode;       // start of IL .text section
    static BYTE     *           emitILMethodBase;       // beginning of IL method (start of header)
    static BYTE     *           emitILMethodStart;      // beginning of IL method code (right after the header)
    static BYTE     *           emitImgBaseOfCode;      // start of the image .text section

#endif

    /************************************************************************/
    /*    Methods to record a code position and later convert to offset     *
    /************************************************************************/

    unsigned        emitFindOffset(insGroup *ig, unsigned insNum);

    /************************************************************************/
    /*        Members and methods used to issue (encode) instructions.      */
    /************************************************************************/

    BYTE    *       emitCodeBlock;
    BYTE    *       emitConsBlock;
    BYTE    *       emitDataBlock;

    BYTE    *       emitCurInsAdr;

    size_t          emitCurCodeOffs(BYTE *dst)
    {
        return  dst - emitCodeBlock;
    }

    size_t          emitCurCodeOffs()
    {
        return  emitCurInsAdr - emitCodeBlock;
    }

    size_t          emitOutputByte(BYTE *dst, int val);
    size_t          emitOutputWord(BYTE *dst, int val);
    size_t          emitOutputLong(BYTE *dst, int val);

    size_t          emitIssue1Instr(insGroup *ig, instrDesc *id, BYTE **dp);
    size_t          emitOutputInstr(insGroup *ig, instrDesc *id, BYTE **dp);

    bool            emitEBPframe;

    size_t          emitLclSize;
    size_t          emitMaxTmpSize;
    size_t          emitGrowableMaxByteOffs;
    void            emitTmpSizeChanged(size_t   tmpSize);
#ifdef DEBUG
    unsigned        emitMaxByteOffsIdNum;
#if TGT_x86
    bool            emitChkAlign;           // perform some alignment checks
#endif
#endif


    insGroup    *   emitCurIG;

#ifdef  DEBUG
    unsigned        emitLastSrcLine;
#endif

    bool            emitIsCondJump(instrDesc    *jmp);

    size_t          emitSizeOfJump(instrDescJmp *jmp);
    size_t          emitInstCodeSz(instrDesc    *id);

    /************************************************************************/
    /*      The logic that creates and keeps track of instruction groups    */
    /************************************************************************/
    #define         SC_IG_BUFFER_SIZE  (50*sizeof(instrDesc)+14*TINY_IDSC_SIZE)

    BYTE        *   emitIGbuffAddr;
    size_t          emitIGbuffSize;

    insGroup    *   emitIGlist;             // first  instruction group
    insGroup    *   emitIGlast;             // last   instruction group
    insGroup    *   emitIGthis;             // issued instruction group

    insGroup    *   emitPrologIG;           // prolog instruction group

    instrDescJmp*   emitJumpList;           // list of local jumps in method
    instrDescJmp*   emitJumpLast;           // last of local jumps in method
    void            emitJumpDistBind();     // Bind all the local jumps in method

#if TGT_x86 || SCHEDULER
    bool            emitFwdJumps;           // forward jumps present?
#endif

#if TGT_RISC
    bool            emitIndJumps;           // indirect/table jumps present?
#if SCHEDULER
    bool            emitIGmoved;            // did some IG offsets change?
#endif
  //#if defined(DEBUG) && !defined(DLL_JIT)
#if defined(DEBUG)
    unsigned        emitTmpJmpCnt;          // for display purposes
#endif
#endif

    BYTE        *   emitCurIGfreeNext;      // next available byte    in buffer
    BYTE        *   emitCurIGfreeEndp;      // last available byte    in buffer
    BYTE        *   emitCurIGfreeBase;      // first byte address

#if SCHEDULER
    unsigned        emitMaxIGscdCnt;        // max. schedulable instructions
    unsigned        emitCurIGscd1st;        // ordinal of 1st schedulable ins
    unsigned        emitCurIGscdOfs;        // offset of current group start
#endif

    unsigned        emitCurIGinsCnt;        // # of collected instr's in buffer
    unsigned        emitCurIGsize;          // est. size of current group
    size_t          emitCurCodeOffset;      // current code offset within group

    size_t          emitTotalCodeSize;      // bytes of code in entire method

#if TGT_x86
    int             emitOffsAdj;            // current code offset adjustment
#endif

    instrDescJmp *  emitCurIGjmpList;       // list of jumps   in current IG
    instrDescCns *  emitCurIGEpiList;       // list of epilogs in current IG

#if TRACK_GC_REFS

    VARSET_TP       emitPrevGCrefVars;
    unsigned        emitPrevGCrefRegs;
    unsigned        emitPrevByrefRegs;

    VARSET_TP       emitInitGCrefVars;
    unsigned        emitInitGCrefRegs;
    unsigned        emitInitByrefRegs;

    bool            emitThisGCrefVset;

    VARSET_TP       emitThisGCrefVars;
    unsigned        emitThisGCrefRegs;
    unsigned        emitThisByrefRegs;

    emitRegs        emitSyncThisObjReg; // where is "this" enregistered for synchronized methods?

    static
    unsigned        emitEncodeCallGCregs(unsigned regs);
    static
    void            emitEncodeCallGCregs(unsigned regs, instrDesc *id);

    static
    unsigned        emitDecodeCallGCregs(unsigned mask);
    static
    unsigned        emitDecodeCallGCregs(instrDesc *id);

#endif

    unsigned        emitNxtIGnum;

    insGroup    *   emitAllocIG();

    void            emitNewIG();
    void            emitGenIG(insGroup *ig, size_t sz = 0);
    insGroup    *   emitSavIG(bool emitAdd = false);
    void            emitNxtIG(bool emitAdd = false);

    bool            emitCurIGnonEmpty()
    {
        return  (emitCurIG && emitCurIGfreeNext > emitCurIGfreeBase);
    }

    instrDesc   *   emitLastIns;

#ifdef  DEBUG
    void            emitCheckIGoffsets();
#else
    void            emitCheckIGoffsets(){}
#endif

    /* This method sets/clears the emitHasHandler data member
     *  which records the current state that is used by NewIG
     *  Any new instruction groups that are created when we
     *  have a handler (inside a try region) must be handled
     *  more conservatively by the scheduler
     */
    void            emitSetHasHandler(bool hasHandler)
    {
        emitHasHandler = hasHandler;
    }

    void            emitAddLabel(void **    labPtr);

#if     TRACK_GC_REFS

    void            emitAddLabel(void **    labPtr,
                                 VARSET_TP  GCvars,
                                 unsigned   gcrefRegs,
                                 unsigned   byrefRegs);

#else

    void            emitAddLabel(void **    labPtr,
                                 VARSET_TP  GCvars,
                                 unsigned   gcrefRegs,
                                 unsigned   byrefRegs)
    {
        emitAddLabel(labPtr);
    }

#endif

    void            emitMarkStackLvl(size_t stackLevel);

    void        *   emitAllocInstr(size_t sz, emitAttr attr);

    instrDesc      *emitAllocInstr      (emitAttr attr)
    {
        return  (instrDesc      *)emitAllocInstr(sizeof(instrDesc      ), attr);
    }

    instrDescJmp   *emitAllocInstrJmp   ()
    {
        return  (instrDescJmp   *)emitAllocInstr(sizeof(instrDescJmp   ), EA_1BYTE);
    }

    instrDescCns   *emitAllocInstrCns   (emitAttr attr)
    {
        return  (instrDescCns   *)emitAllocInstr(sizeof(instrDescCns   ), attr);
    }

    instrDescDsp   *emitAllocInstrDsp   (emitAttr attr)
    {
        return  (instrDescDsp   *)emitAllocInstr(sizeof(instrDescDsp   ), attr);
    }

    instrDescDspCns*emitAllocInstrDspCns(emitAttr attr)
    {
        return  (instrDescDspCns*)emitAllocInstr(sizeof(instrDescDspCns), attr);
    }

    instrDescCIGCA *emitAllocInstrCIGCA (emitAttr attr)
    {
        return  (instrDescCIGCA *)emitAllocInstr(sizeof(instrDescCIGCA ), attr);
    }

    instrDescDCM   *emitAllocInstrDCM   (emitAttr attr)
    {
        return  (instrDescDCM   *)emitAllocInstr(sizeof(instrDescDCM   ), attr);
    }

    instrDesc      *emitNewInstr        (emitAttr attr = EA_4BYTE);
    instrDesc      *emitNewInstrTiny    (emitAttr attr);
    instrDesc      *emitNewInstrSC      (emitAttr attr, int val);
    instrDesc      *emitNewInstrDsp     (emitAttr attr, int dsp);
    instrDesc      *emitNewInstrCns     (emitAttr attr, int cns);
    instrDesc      *emitNewInstrDspCns  (emitAttr attr, int dsp, int cns);
    instrDescJmp   *emitNewInstrJmp     ();
    instrDescDCM   *emitNewInstrDCM     (emitAttr attr, int dsp, int cns, int val);

    static
    BYTE            emitFmtToOps[];

#ifdef  DEBUG

    static
    unsigned        emitFmtCount;

#endif

    bool            emitIsTinyInsDsc    (instrDesc       *id);
    bool            emitIsScnsInsDsc    (instrDesc       *id);

    size_t          emitSizeOfInsDsc    (instrDesc       *id);
    size_t          emitSizeOfInsDsc    (instrDescCns    *id);
    size_t          emitSizeOfInsDsc    (instrDescDsp    *id);
    size_t          emitSizeOfInsDsc    (instrDescDspCns *id);

#if EMIT_USE_LIT_POOLS

    void            emitRecIGlitPoolRefs(insGroup *ig);

    void            emitEstimateLitPools();
    void            emitFinalizeLitPools();

#if SMALL_DIRECT_CALLS
    void            emitShrinkShortCalls();
#else
    void            emitShrinkShortCalls() {}
#endif

#else

    void            emitRecIGlitPoolRefs(insGroup *ig) {}

    void            emitEstimateLitPools() {}
    void            emitFinalizeLitPools() {}

    void            emitShrinkShortCalls() {}

#endif

    #include "sched.h"      // scheduling members/methods

    /************************************************************************/
    /*         Logic to handle source line information / display            */
    /************************************************************************/

#ifdef  DEBUG

    unsigned        emitBaseLineNo;
    unsigned        emitThisLineNo;
    unsigned        emitLastLineNo;

#endif

    /************************************************************************/
    /*        The following keeps track of stack-based GC values            */
    /************************************************************************/

    unsigned        emitTrkVarCnt;
    int     *       emitGCrFrameOffsTab;  // Offsets of tracked stack ptr vars (varTrkIndex -> stkOffs)

    unsigned        emitGCrFrameOffsCnt;  // Number of       tracked stack ptr vars
    int             emitGCrFrameOffsMin;  // Min offset of a tracked stack ptr var
    int             emitGCrFrameOffsMax;  // Max offset of a tracked stack ptr var
    bool            emitContTrkPtrLcls;   // All lcl between emitGCrFrameOffsMin/Max are only tracked stack ptr vars
    varPtrDsc * *   emitGCrFrameLiveTab;  // Cache of currently live varPtrs (stkOffs -> varPtrDsc)

    int             emitArgFrameOffsMin;
    int             emitArgFrameOffsMax;

    int             emitLclFrameOffsMin;
    int             emitLclFrameOffsMax;

    int             emitThisArgOffs;

public:

    void            emitSetFrameRangeGCRs(int offsLo, int offsHi);
    void            emitSetFrameRangeLcls(int offsLo, int offsHi);
    void            emitSetFrameRangeArgs(int offsLo, int offsHi);

#ifdef  DEBUG
    void            emitInsTest(instrDesc *id);
#endif

    /************************************************************************/
    /*    The following is used to distinguish helper vs non-helper calls   */
    /************************************************************************/

    static bool            emitNoGChelper(unsigned IHX);

    /************************************************************************/
    /*         The following logic keeps track of live GC ref values        */
    /************************************************************************/

#if TRACK_GC_REFS

    bool            emitFullGCinfo;         // full GC pointer maps?
    bool            emitFullyInt;           // fully interruptible code?

    unsigned        emitCntStackDepth;      // 0 in prolog/epilog, 1 elsewhere
    unsigned        emitMaxStackDepth;      // actual computed max. stack depth

    /* Stack modelling wrt GC */

    bool            emitSimpleStkUsed;      // using the "simple" stack table?

    union
    {
        struct                              // if emitSimpleStkUsed==true
        {
            #define     BITS_IN_BYTE            (8)
            #define     MAX_SIMPLE_STK_DEPTH    (BITS_IN_BYTE*sizeof(unsigned))

            unsigned    emitSimpleStkMask;      // bit per pushed dword (if it fits. Lowest bit <==> last pushed arg)
            unsigned    emitSimpleByrefStkMask; // byref qualifier for emitSimpleStkMask
        };

        struct                              // if emitSimpleStkUsed==false
        {
            BYTE        emitArgTrackLcl[16];    // small local table to avoid malloc
            BYTE    *   emitArgTrackTab;        // base of the argument tracking stack
            BYTE    *   emitArgTrackTop;        // top  of the argument tracking stack
            unsigned    emitGcArgTrackCnt;      // count of pending arg records (stk-depth for frameless methods, gc ptrs on stk for framed methods)
        };
    };

    unsigned        emitCurStackLvl;           // amount of bytes pushed on stack

    /* Functions for stack tracking */

    void            emitStackPush       (BYTE *     addr,
                                         GCtype     gcType);
    void            emitStackPushN      (BYTE *     addr,
                                         unsigned   count);

    void            emitStackPop        (BYTE *     addr,
                                         bool       isCall,
                                         unsigned   count = 1);
    void            emitStackKillArgs   (BYTE *     addr,
                                         unsigned   count);

    void            emitRecordGCcall    (BYTE *     codePos);

    // Helpers for the above

    void            emitStackPushLargeStk(BYTE*     addr,
                                         GCtype     gcType,
                                         unsigned   count = 1);
    void            emitStackPopLargeStk(BYTE *     addr,
                                         bool       isCall,
                                         unsigned   count = 1);

    /* Liveness of stack variables, and registers */

    void            emitUpdateLiveGCvars(int        offs, BYTE *addr, bool birth);
    void            emitUpdateLiveGCvars(VARSET_TP  vars, BYTE *addr);
    void            emitUpdateLiveGCregs(GCtype     gcType,
                                         unsigned   regs, BYTE *addr);

#ifdef  DEBUG
    void            emitDispRegSet      (unsigned   regs, bool calleeOnly = false);
    void            emitDispVarSet      ();
#endif

    void            emitGCregLiveUpd(GCtype gcType, emitRegs reg, BYTE *addr);
    void            emitGCregLiveSet(GCtype gcType, unsigned mask, BYTE *addr, bool isThis);
    void            emitGCregDeadUpd(regMaskTP, BYTE *addr);
    void            emitGCregDeadUpd(emitRegs reg, BYTE *addr);
    void            emitGCregDeadSet(GCtype gcType, unsigned mask, BYTE *addr);

    void            emitGCvarLiveUpd(int offs, int varNum, GCtype gcType, BYTE *addr);
    void            emitGCvarLiveSet(int offs, GCtype gcType, BYTE *addr, int disp = -1);
    void            emitGCvarDeadUpd(int offs,                BYTE *addr);
    void            emitGCvarDeadSet(int offs,                BYTE *addr, int disp = -1);

    GCtype          emitRegGCtype   (emitRegs reg);

#endif

    /************************************************************************/
    /*      The following logic keeps track of initialized data sections    */
    /************************************************************************/

    /* One of these is allocated for every blob of initialized data */

    struct  dataSection
    {
        dataSection *       dsNext;
        size_t              dsSize;
        BYTE                dsCont[0];
    };

    /* These describe the entire initialized/uninitialized data sections */

    struct  dataSecDsc
    {
        unsigned            dsdOffs;
        dataSection *       dsdList;
        dataSection *       dsdLast;
    };

    dataSecDsc      emitConsDsc;
    dataSecDsc      emitDataDsc;

    dataSection *   emitDataSecCur;
    dataSecDsc  *   emitDataDscCur;

    void            emitOutputDataSec(dataSecDsc *sec,
                                      BYTE       *cbp,
                                      BYTE       *dst);

    /************************************************************************/
    /*              Handles to the current class and method.                */
    /************************************************************************/

    COMP_HANDLE     emitCmpHandle;


    /************************************************************************/
    /*               Logic to collect and display statistics                */
    /************************************************************************/

#if EMITTER_STATS_RLS

    static unsigned emitTotIDcount;
    static unsigned emitTotIDsize;

#endif

#if EMITTER_STATS

    friend  void    emitterStats();

    static unsigned emitTotalInsCnt;

    static unsigned emitTotalIGcnt;
    static unsigned emitTotalIGicnt;
    static unsigned emitTotalIGsize;
    static unsigned emitTotalIGmcnt;
    static unsigned emitTotalIGjmps;
    static unsigned emitTotalIGptrs;

    static unsigned emitTotMemAlloc;
    static unsigned emitLclMemAlloc;
    static unsigned emitExtMemAlloc;

    static unsigned emitSmallDspCnt;
    static unsigned emitLargeDspCnt;

    static unsigned emitSmallCnsCnt;
    #define                      SMALL_CNS_TSZ   256
    static unsigned emitSmallCns[SMALL_CNS_TSZ];
    static unsigned emitLargeCnsCnt;

    static unsigned emitIFcounts[IF_COUNT];
#if SCHEDULER
    static unsigned schedFcounts[IF_COUNT];
    static histo    scdCntTable;
    static histo    scdSucTable;
    static histo    scdFrmCntTable;
#endif

#endif

    /*************************************************************************
     *
     *  Define any target-dependent emitter members.
     */

    #include "emitDef.h"
};

/*****************************************************************************
 *
 *  Define any target-dependent inlines.
 */

#include "emitInl.h"

/*****************************************************************************
 *
 *  Returns true if the given instruction descriptor is a "tiny" or a "small
 *  constant" one (i.e. one of the descriptors that don't have all instrDesc
 *  fields allocated).
 */

inline
bool                emitter::emitIsTinyInsDsc(instrDesc *id)
{
    return  id->idIsTiny();
}

inline
bool                emitter::emitIsScnsInsDsc(instrDesc *id)
{
    return  id->idIsSmallCns();
}

/*****************************************************************************
 *
 *  Given an instruction, return its "update mode" (RD/WR/RW).
 */

#if !TGT_MIPS32

inline
insUpdateModes      emitter::emitInsUpdateMode(instruction ins)
{
#ifdef DEBUG
    assert((unsigned)ins < emitInsModeFmtCnt);
#endif
    return (insUpdateModes)emitInsModeFmtTab[ins];
}

#endif

/*****************************************************************************
 *
 *  Combine the given base format with the update mode of the instuction.
 */

#if !TGT_MIPS32

inline
emitter::insFormats   emitter::emitInsModeFormat(instruction ins, insFormats base)
{
    assert(IF_RRD + IUM_RD == IF_RRD);
    assert(IF_RRD + IUM_WR == IF_RWR);
    assert(IF_RRD + IUM_RW == IF_RRW);

    return  (insFormats)(base + emitInsUpdateMode(ins));
}

#endif

/*****************************************************************************
 *
 *  Return the number of epilog blocks generated so far.
 */

inline
unsigned            emitter::emitGetEpilogCnt()
{
    return emitEpilogCnt;
}

/*****************************************************************************
 *
 *  Return the current size of the specified data section.
 */

inline
size_t              emitter::emitDataSize(bool readOnly)
{
    return  (readOnly ? emitConsDsc
                      : emitDataDsc).dsdOffs;
}

/*****************************************************************************
 *
 *  Emit an 8-bit integer as code.
 */

inline
size_t              emitter::emitOutputByte(BYTE *dst, int val)
{
    *castto(dst, char  *) = val;

#ifdef  DEBUG
    if (dspEmit) printf("; emit_byte 0%02XH\n", val & 0xFF);
#endif

    return  sizeof(char);
}

/*****************************************************************************
 *
 *  Emit a 16-bit integer as code.
 */

inline
size_t              emitter::emitOutputWord(BYTE *dst, int val)
{
    MISALIGNED_WR_I2(dst, val);

#ifdef  DEBUG
#if     TGT_x86
    if (dspEmit) printf("; emit_word 0%02XH,0%02XH\n", (val & 0xFF), (val >> 8) & 0xFF);
#else
    if (dspEmit) printf("; emit_word 0%04XH\n"       , (val & 0xFFFF));
#endif
#endif

    return  sizeof(short);
}

/*****************************************************************************
 *
 *  Emit a 32-bit integer as code.
 */

inline
size_t              emitter::emitOutputLong(BYTE *dst, int val)
{
    MISALIGNED_WR_I4(dst, val);

#ifdef  DEBUG
    if (dspEmit) printf("; emit_long 0%08XH\n", val);
#endif

    return  sizeof(long );
}

/*****************************************************************************
 *
 *  Return a handle to the current position in the output stream. This can
 *  be later converted to an actual code offset in bytes.
 */

inline
void    *           emitter::emitCurBlock()
{
    return emitCurIG;
}

/*****************************************************************************
 *
 *  The emitCurOffset() method returns a cookie that identifies the current
 *  position in the instruction stream. Due to things like scheduling (and
 *  the fact that the final size of some instructions cannot be known until
 *  the end of code generation), we return a value with the instruction num.
 *  and its estimated offset to the caller.
 */

inline
unsigned            emitGetInsNumFromCodePos(unsigned codePos)
{
    return (codePos & 0xFFFF);
}

inline
unsigned            emitGetInsOfsFromCodePos(unsigned codePos)
{
    return (codePos >> 16);
}

inline
unsigned            emitter::emitCurOffset()
{
    unsigned        codePos = emitCurIGinsCnt + (emitCurIGsize << 16);

    assert(emitGetInsOfsFromCodePos(codePos) == emitCurIGsize);
    assert(emitGetInsNumFromCodePos(codePos) == emitCurIGinsCnt);

//  printf("[IG=%02u;ID=%03u;OF=%04X] => %08X\n", emitCurIG->igNum, emitCurIGinsCnt, emitCurIGsize, codePos);

    return codePos;
}

/*****************************************************************************
 *
 *  Given a block cookie and an code position, return the actual code offset;
 *  this can only be called at the end of code generation.
 */

inline
size_t              emitter::emitCodeOffset(void *blockPtr, unsigned codePos)
{
    insGroup    *   ig;

    unsigned        of;
    unsigned        no = emitGetInsNumFromCodePos(codePos);

    /* Make sure we weren't passed some kind of a garbage thing */

    ig = (insGroup*)blockPtr;
#ifdef DEBUG
    assert(ig && ig->igSelf == ig);
#endif

    /* The first and last offsets are always easy */

    if      (no == 0)
    {
        of = 0;
    }
    else if (no == ig->igInsCnt)
    {
        of = ig->igSize;
    }
    else if (ig->igFlags & IGF_UPD_ISZ)
    {
        /*
            Some instruction sizes have changed, so we'll have to figure
            out the instruction offset "the hard way".
         */

        of = emitFindOffset(ig, no);
    }
    else
    {
        /* All instructions correctly predicted, the offset stays the same */

        of = emitGetInsOfsFromCodePos(codePos);

//      printf("[IG=%02u;ID=%03u;OF=%04X] <= %08X\n", ig->igNum, emitGetInsNumFromCodePos(codePos), of, codePos);

        /* Make sure the offset estimate is accurate */

        assert(of == emitFindOffset(ig, emitGetInsNumFromCodePos(codePos)));
    }

    return  ig->igOffs + of;
}

extern
const signed char   emitTypeSizes[TYP_COUNT];

inline
emitAttr            emitTypeSize(var_types type)
{
    assert(type < TYP_COUNT);
#if !TRACK_GC_REFS
    assert(emitTypeSizes[type] > 0);
#else
# if NEW_EMIT_ATTR
    assert(emitTypeSizes[type] > 0);
# else
    assert(emitTypeSizes[type] >= -2);  // EA_BYREF is -2
# endif
#endif
    return (emitAttr) emitTypeSizes[type];
}

extern
const signed char   emitTypeActSz[TYP_COUNT];

inline
emitAttr            emitActualTypeSize(var_types type)
{
    assert(type < TYP_COUNT);
#if !TRACK_GC_REFS
    assert(emitTypeActSz[type] > 0);
#else
# if NEW_EMIT_ATTR
    assert(emitTypeActSz[type] > 0);
# else
    assert(emitTypeActSz[type] >= -2);  // EA_BYREF is -2
# endif
#endif
    return (emitAttr) emitTypeActSz[type];
}

/*****************************************************************************
 *
 *  Convert between an operand size in bytes and a smaller encoding used for
 *  storage in instruction descriptors.
 */

inline
unsigned           emitter::emitEncodeSize(emitAttr size)
{
    assert(size == EA_1BYTE ||
           size == EA_2BYTE ||
           size == EA_4BYTE ||
           size == EA_8BYTE);

    return  (unsigned) emitSizeEnc[((int) size)-1];
}

inline
emitAttr            emitter::emitDecodeSize(unsigned ensz)
{
    assert(ensz < 4);

    return  (emitAttr) emitSizeDec[ensz];
}

/*****************************************************************************
 *
 *  Little helpers to allocate various flavors of instructions.
 */

inline
emitter::instrDesc   *emitter::emitNewInstr      (emitAttr attr)
{
    return  emitAllocInstr(attr);
}

inline
emitter::instrDesc   *emitter::emitNewInstrTiny  (emitAttr attr)
{
    instrDesc        *id;

    id =  (instrDesc*)emitAllocInstr(TINY_IDSC_SIZE, attr);

    id->idTinyDsc = true;

    return  id;
}

inline
emitter::instrDescJmp*emitter::emitNewInstrJmp()
{
    return  emitAllocInstrJmp();
}

inline
emitter::instrDesc      * emitter::emitNewInstrDsp   (emitAttr attr, int dsp)
{
    if  (dsp == 0)
    {
        instrDesc      *id = emitAllocInstr      (attr);

#if EMITTER_STATS
        emitSmallDspCnt++;
#endif

        return  id;
    }
    else
    {
        instrDescDsp   *id = emitAllocInstrDsp   (attr);

        id->idInfo.idLargeDsp = true;
        id->iddDspVal  = dsp;

#if EMITTER_STATS
        emitLargeDspCnt++;
#endif

        return  id;
    }
}

inline
emitter::instrDesc      * emitter::emitNewInstrCns   (emitAttr attr, int cns)
{
    if  (cns >= ID_MIN_SMALL_CNS &&
         cns <= ID_MAX_SMALL_CNS)
    {
        instrDesc      *id = emitAllocInstr      (attr);

        id->idInfo.idSmallCns = cns;

#if EMITTER_STATS
        emitSmallCnsCnt++;
        if  (cns - ID_MIN_SMALL_CNS >= SMALL_CNS_TSZ)
            emitSmallCns[   SMALL_CNS_TSZ - 1  ]++;
        else
            emitSmallCns[cns - ID_MIN_SMALL_CNS]++;
#endif

        return  id;
    }
    else
    {
        instrDescCns   *id = emitAllocInstrCns   (attr);

        id->idInfo.idLargeCns = true;
        id->idcCnsVal  = cns;

#if EMITTER_STATS
        emitLargeCnsCnt++;
#endif

        return  id;
    }
}

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction with a small integer
 *  constant operand.
 */

inline
emitter::instrDesc   *emitter::emitNewInstrSC(emitAttr attr, int cns)
{
    instrDesc      *id;

    if  (cns >= ID_MIN_SMALL_CNS &&
         cns <= ID_MAX_SMALL_CNS)
    {
        id = (instrDesc*)emitAllocInstr(      SCNS_IDSC_SIZE, attr);

        id->idInfo.idSmallCns           = cns;
    }
    else
    {
        id = (instrDesc*)emitAllocInstr(sizeof(instrBaseCns), attr);

        id->idInfo.idLargeCns           = true;
        ((instrBaseCns*)id)->ibcCnsVal  = cns;
    }

    id->idScnsDsc = true;

    return  id;
}

/*****************************************************************************
 *
 *  Return the allocated size (in bytes) of the given instruction descriptor.
 */

inline
size_t              emitter::emitSizeOfInsDsc(instrDescCns    *id)
{
    return  id->idInfo.idLargeCns ? sizeof(instrDescCns)
                                  : sizeof(instrDesc   );
}

inline
size_t              emitter::emitSizeOfInsDsc(instrDescDsp    *id)
{
    return  id->idInfo.idLargeDsp ? sizeof(instrDescDsp)
                                  : sizeof(instrDesc   );
}

inline
size_t              emitter::emitSizeOfInsDsc(instrDescDspCns *id)
{
    if      (id->idInfo.idLargeCns)
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescDspCns)
                                      : sizeof(instrDescCns   );
    }
    else
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescDsp   )
                                      : sizeof(instrDesc      );
    }
}

/*****************************************************************************
 *
 *  The following helpers should be used to access the various values that
 *  get stored in different places within the instruction descriptor.
 */

inline
int                 emitter::emitGetInsCns   (instrDesc *id)
{
    return  id->idInfo.idLargeCns ? ((instrDescCns*)id)->idcCnsVal
                                  :                 id ->idInfo.idSmallCns;
}

inline
int                 emitter::emitGetInsDsp   (instrDesc *id)
{
    return  id->idInfo.idLargeDsp ? ((instrDescDsp*)id)->iddDspVal
                                  : 0;
}

inline
int                 emitter::emitGetInsDspCns(instrDesc *id, int *dspPtr)
{
    if  (id->idInfo.idLargeCns)
    {
        if  (id->idInfo.idLargeDsp)
        {
            *dspPtr = ((instrDescDspCns*)id)->iddcDspVal;
            return    ((instrDescDspCns*)id)->iddcCnsVal;
        }
        else
        {
            *dspPtr = 0;
            return    ((instrDescCns   *)id)->idcCnsVal;
        }
    }
    else
    {
        if  (id->idInfo.idLargeDsp)
        {
            *dspPtr = ((instrDescDsp   *)id)->iddDspVal;
            return                       id ->idInfo.idSmallCns;
        }
        else
        {
            *dspPtr = 0;
            return                       id ->idInfo.idSmallCns;
        }
    }
}

inline
int                 emitter::emitGetInsSC(instrDesc *id)
{
    assert(id->idIsSmallCns());

    if  (id->idInfo.idLargeCns)
        return  ((instrBaseCns*)id)->ibcCnsVal;
    else
        return  id->idInfo.idSmallCns;
}

/*****************************************************************************
 *
 *  Get hold of the argument count for an indirect call.
 */

inline
unsigned            emitter::emitGetInsCIargs(instrDesc *id)
{
    if  (id->idInfo.idLargeCall)
    {
        return  ((instrDescCIGCA*)id)->idciArgCnt;
    }
    else
    {
        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);

        return  emitGetInsCns(id);
    }
}

/*****************************************************************************
 *
 *  Display (optionally) an instruction offset.
 */

#ifdef  DEBUG

inline
void                emitter::emitDispInsOffs(unsigned offs, bool doffs)
{
    if  (doffs)
        printf("%06X", offs);
    else
        printf("      ");
}

#endif

/*****************************************************************************/
#if TRACK_GC_REFS
/*****************************************************************************
 *
 *  Map a register mask (must have only one bit set) to a register number.
 */

inline
emitRegs           emitter::emitRegNumFromMask(unsigned mask)
{
    emitRegs       reg;

    reg = (emitRegs) genLog2(mask);
    assert(mask == emitRegMask(reg));

    return  reg;
}

/*****************************************************************************
 *
 *  Returns true if the given register contains a live GC ref.
 */

inline
GCtype              emitter::emitRegGCtype  (emitRegs reg)
{
    if       ((emitThisGCrefRegs & emitRegMask(reg)) != 0)
        return GCT_GCREF;
    else if  ((emitThisByrefRegs & emitRegMask(reg)) != 0)
        return GCT_BYREF;
    else
        return GCT_NONE;
}

/*****************************************************************************
 *
 *  Record the fact that the given register now       contains a live GC ref.
 */

inline
void                emitter::emitGCregLiveUpd(GCtype gcType, emitRegs reg, BYTE *addr)
{
    assert(needsGC(gcType));

    regMaskTP regMask = emitRegMask(reg);

    unsigned & emitThisXXrefRegs = (gcType == GCT_GCREF) ? emitThisGCrefRegs
                                                         : emitThisByrefRegs;
    unsigned & emitThisYYrefRegs = (gcType == GCT_GCREF) ? emitThisByrefRegs
                                                         : emitThisGCrefRegs;

    if  ((emitThisXXrefRegs & regMask) == 0)
    {
        // If the register was holding the other GC type, that type should
        // go dead now

        if (emitThisYYrefRegs & regMask)
            emitGCregDeadUpd(        reg    , addr);

        // For synchronized methods, "this" is always alive and in the same register.
        // However, if we generate any code after the epilog block (where "this"
        // goes dead), "this" will come alive again. We need to notice that.
        // Not that we only expect isThis to be true at an insGroup boundary
        
        bool isThis = (reg == emitSyncThisObjReg) ? true : false;
        
        if  (emitFullGCinfo)
            emitGCregLiveSet(gcType, regMask, addr, isThis);

        emitThisXXrefRegs |=         regMask;

#ifdef  DEBUG
        if  (0 && verbose && emitFullyInt)
            printf("%sReg +[%s]\n", GCtypeStr(gcType), emitRegName(reg));
#endif
    }

    // The 2 GC reg masks cant be overlapping

    assert((emitThisGCrefRegs & emitThisByrefRegs) == 0);
}

/*****************************************************************************
 *
 *  Record the fact that the given register no longer contains a live GC ref.
 */

inline
void                emitter::emitGCregDeadUpd(regMaskTP regs, BYTE *addr)
{
    regMaskTP   gcrefRegs = emitThisGCrefRegs & regs;

    if  (gcrefRegs)
    {
        assert((emitThisByrefRegs & gcrefRegs) == 0);

        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_GCREF, gcrefRegs, addr);

        emitThisGCrefRegs &= ~gcrefRegs;
        regs              &= ~gcrefRegs;
    }

    regMaskTP   byrefRegs = emitThisByrefRegs & regs;

    if (byrefRegs)
    {
        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_BYREF, byrefRegs, addr);

        emitThisByrefRegs &= ~byrefRegs;
    }
}

inline
void                emitter::emitGCregDeadUpd(emitRegs reg, BYTE *addr)
{
    unsigned        regMask = emitRegMask(reg);

    if  ((emitThisGCrefRegs & regMask) != 0)
    {
        assert((emitThisByrefRegs & regMask) == 0);

        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_GCREF, regMask, addr);

        emitThisGCrefRegs &= ~regMask;

#ifdef  DEBUG
        if  (0 && verbose && emitFullyInt)
            printf("%s -[%s]\n", "gcrReg", emitRegName(reg));
#endif
    }
    else if ((emitThisByrefRegs & regMask) != 0)
    {
        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_BYREF, regMask, addr);

        emitThisByrefRegs &= ~regMask;

#ifdef  DEBUG
        if  (0 && verbose && emitFullyInt)
            printf("%s -[%s]\n", "byrReg", emitRegName(reg));
#endif
    }
}

/*****************************************************************************
 *
 *  Record the fact that the given variable now contains a live GC ref.
 *  varNum may be INT_MAX only if offs is guaranteed to be the offset of a
 *    tracked GC ref. Else we need a valid value to check if the variable
 *    is tracked or not.
 */

inline
void                emitter::emitGCvarLiveUpd(int offs, int varNum,
                                              GCtype gcType, BYTE *addr)
{
    assert(abs(offs) % sizeof(int) == 0);
    assert(needsGC(gcType));

    /* Is the frame offset within the "interesting" range? */

    if  (offs >= emitGCrFrameOffsMin &&
         offs <  emitGCrFrameOffsMax)
    {
        /* Normally all variables in this range must be tracked stack
           pointers. However, for EnC, we relax this condition. So we
           must check if this is not such a variable */

        if (varNum != INT_MAX && !emitComp->lvaTable[varNum].lvTracked)
        {
            assert(!emitContTrkPtrLcls);
            return;
        }

        size_t          disp;

        /* Compute the index into the GC frame table */

        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);
        assert(disp < emitGCrFrameOffsCnt);

        /* If the variable is currently dead, mark it as live */

        if  (emitGCrFrameLiveTab[disp] == NULL)
            emitGCvarLiveSet(offs, gcType, addr, disp);
    }
}

/*****************************************************************************
 *
 *  Record the fact that the given variable no longer contains a live GC ref.
 */

inline
void                emitter::emitGCvarDeadUpd(int offs, BYTE *addr)
{
    assert(abs(offs) % sizeof(int) == 0);

    /* Is the frame offset within the "interesting" range? */

    if  (offs >= emitGCrFrameOffsMin &&
         offs <  emitGCrFrameOffsMax)
    {
        size_t          disp;

        /* Compute the index into the GC frame table */

        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);
        assert(disp < emitGCrFrameOffsCnt);

        /* If the variable is currently live, mark it as dead */

        if  (emitGCrFrameLiveTab[disp] != NULL)
            emitGCvarDeadSet(offs, addr, disp);
    }
}

/*****************************************************************************/
#if     EMIT_TRACK_STACK_DEPTH
/*****************************************************************************
 *
 *  Record a push of a single dword on the stack.
 */

inline
void                emitter::emitStackPush(BYTE *addr, GCtype gcType)
{
#ifdef DEBUG
    assert(IsValidGCtype(gcType));
#endif

    if  (emitSimpleStkUsed)
    {
        assert(!emitFullGCinfo); // Simple stk not used for emitFullGCinfo
        assert(emitCurStackLvl/sizeof(int) < MAX_SIMPLE_STK_DEPTH);

        emitSimpleStkMask      <<= 1;
        emitSimpleStkMask      |= (unsigned)needsGC(gcType);

        emitSimpleByrefStkMask <<= 1;
        emitSimpleByrefStkMask |= (gcType == GCT_BYREF);

        assert((emitSimpleStkMask & emitSimpleByrefStkMask) == emitSimpleByrefStkMask);
    }
    else
    {
        emitStackPushLargeStk(addr, gcType);
    }

    emitCurStackLvl += sizeof(int);
}

/*****************************************************************************
 *
 *  Record a push of a bunch of non-GC dwords on the stack.
 */

inline
void                emitter::emitStackPushN(BYTE *addr, unsigned count)
{
    assert(count);

    if  (emitSimpleStkUsed)
    {
        assert(!emitFullGCinfo); // Simple stk not used for emitFullGCinfo

        emitSimpleStkMask       <<= count;
        emitSimpleByrefStkMask  <<= count;
    }
    else
    {
        emitStackPushLargeStk(addr, GCT_NONE, count);
    }

    emitCurStackLvl += count * sizeof(int);
}

/*****************************************************************************
 *
 *  Record a pop of the given number of dwords from the stack.
 */

inline
void                emitter::emitStackPop(BYTE *addr, bool isCall, unsigned count)
{
    assert(emitCurStackLvl/sizeof(int) >= count);

    if  (count)
    {
        if  (emitSimpleStkUsed)
        {
            assert(!emitFullGCinfo); // Simple stk not used for emitFullGCinfo

            unsigned    cnt = count;

            do
            {
                emitSimpleStkMask      >>= 1;
                emitSimpleByrefStkMask >>= 1;
            }
            while (--cnt);
        }
        else
        {
            emitStackPopLargeStk(addr, isCall, count);
        }

        emitCurStackLvl -= count * sizeof(int);
    }
    else
    {
        assert(isCall);

        if  (emitFullGCinfo)
            emitStackPopLargeStk(addr, true, 0);
    }
}

/*****************************************************************************/
#endif//EMIT_TRACK_STACK_DEPTH
/*****************************************************************************
/*****************************************************************************/
#endif//TRACK_GC_REFS
/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************
 *
 *  Define the "IS_xxxx" enum.
 */

#define DEFINE_IS_OPS
#include "emitfmts.h"
#undef  DEFINE_IS_OPS

/*****************************************************************************
 *
 *  Return an integer that represents the stack offset referenced by the
 *  given instruction and a size that will be set to 0 for 32-bit values
 *  and 1 for 64-bit values. The offset value is guaranteed to change by
 *  1 for a real frame offset change of 4 (in other words, the caller can
 *  add the returned size to the returned offset to get the equivalent
 *  frame offset of the byte that follows the given operand).
 */

#if SCHEDULER

inline
int                 emitter::scGetFrameOpInfo(instrDesc *id, size_t *szp,
                                                             bool   *ebpPtr)
{
    int             ofs;

    ofs  = emitComp->lvaFrameAddress(id->idAddr.iiaLclVar.lvaVarNum, ebpPtr);
    ofs += id->idAddr.iiaLclVar.lvaOffset;

    assert(emitDecodeSize(0) == EA_1BYTE);
    assert(emitDecodeSize(1) == EA_2BYTE);
    assert(emitDecodeSize(2) == EA_4BYTE);
    assert(emitDecodeSize(3) == EA_8BYTE);

    *szp = 1 + (id->idOpSize == 3);

    return  ofs / (int)sizeof(int);
}

#endif

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/

#ifdef  DEBUG

#if     EMIT_TRACK_STACK_DEPTH
#define CHECK_STACK_DEPTH() assert((int)emitCurStackLvl >= 0)
#else
#define CHECK_STACK_DEPTH()
#endif

#if     EMITTER_STATS
#define dispIns(i)  emitIFcounts[i->idInsFmt]++;                            \
                    emitInsTest(id);                                        \
                    if (dspCode) emitDispIns(i, true, false, false);        \
                    assert(id->idSize == emitSizeOfInsDsc((instrDesc*)id)); \
                    CHECK_STACK_DEPTH();
#else
#define dispIns(i)  emitInsTest(id);                                        \
                    if (dspCode) emitDispIns(i, true, false, false);        \
                    assert(id->idSize == emitSizeOfInsDsc((instrDesc*)id)); \
                    CHECK_STACK_DEPTH();
#endif

#else

#define dispIns(i)

#endif

/*****************************************************************************/
#endif//_SCHED_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emit.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                              emit.cpp                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "alloc.h"
#include "instr.h"
#include "target.h"

#include "emit.h"

/*****************************************************************************/

#if     0
#define VERBOSE 1
#else
#define VERBOSE verbose
#endif

#undef  VERBOSE
#define VERBOSE 0

/*****************************************************************************
 *
 *  Return the name of an instruction format.
 */

#ifdef  DEBUG

const char  *   emitter::emitIfName(unsigned f)
{
    static
    const char * const  ifNames[] =
    {
        #define IF_DEF(en, op1, op2) "IF_" #en,
        #include "emitfmts.h"
        #undef  IF_DEF
    };

    static
    char            errBuff[32];

    if  (f < sizeof(ifNames)/sizeof(*ifNames))
        return  ifNames[f];

    sprintf(errBuff, "??%u??", f);
    return  errBuff;
}

#endif

/*****************************************************************************
 *
 *  Local buffer - used first for memory allocation, when it's full we start
 *  allocating through the client-supplied allocator.
 *
 *  Note that we try to size the buffer so that it pads the data section of
 *  JIT DLL to be close to a multiple of OS pages.
 *
 *  MSCORJIT:
 *
 *      0002:00000000 00001560H .data                   DATA
 *      0002:00001560 0000150cH .bss                    DATA
 *
 */

#if     USE_LCL_EMIT_BUFF

BYTE                emitter::emitLclBuff[ 40*sizeof(instrDesc)+15*TINY_IDSC_SIZE];

CRITICAL_SECTION    emitter::emitCritSect;
bool                emitter::emitCrScInit;
bool                emitter::emitCrScBusy;

#endif

/*****************************************************************************/

#ifdef  TRANSLATE_PDB

/* these are protected */

AddrMap     *       emitter::emitPDBOffsetTable = 0;
LocalMap    *       emitter::emitPDBLocalTable  = 0;
bool                emitter::emitIsPDBEnabled   = true;
BYTE        *       emitter::emitILBaseOfCode   = 0;
BYTE        *       emitter::emitILMethodBase   = 0;
BYTE        *       emitter::emitILMethodStart  = 0;
BYTE        *       emitter::emitImgBaseOfCode  = 0;

inline void emitter::SetIDSource( instrDesc *id )
{
    id->idilStart = emitInstrDescILBase;
}

void emitter::MapCode( long ilOffset, BYTE *imgDest )
{
    if( emitIsPDBEnabled )
    {
        emitPDBOffsetTable->MapSrcToDest( ilOffset, (long)( imgDest - emitImgBaseOfCode ));
    }
}
 
void emitter::MapFunc( long imgOff,    long procLen,  long dbgStart, long dbgEnd, short frameReg,
                       long stkAdjust, int  lvaCount, OptJit::LclVarDsc *lvaTable, bool framePtr )
{
    if( emitIsPDBEnabled )
    {
        // this code stores information about local symbols for the PDB translation

        assert( lvaCount >=0 );         // don't allow a negative count

        LvaDesc *rgLvaDesc = 0;

        if( lvaCount > 0 )
        {
            rgLvaDesc = new LvaDesc[lvaCount];

            if (!rgLvaDesc)
            {
                NOMEM();
            }
            

            LvaDesc *pDst = rgLvaDesc;
            OptJit::LclVarDsc *pSrc = lvaTable;
            for( int i = 0; i < lvaCount; ++i, ++pDst, ++pSrc )
            {
                pDst->slotNum = pSrc->lvSlotNum;
                pDst->isReg   = pSrc->lvRegister;
                pDst->reg     = (pSrc->lvRegister ? pSrc->lvRegNum : frameReg );
                pDst->off     =  pSrc->lvStkOffs + stkAdjust;
            }
        }

        emitPDBLocalTable->AddFunc( (long)(emitILMethodBase - emitILBaseOfCode),
                                    imgOff - (long)emitImgBaseOfCode,
                                    procLen,
                                    dbgStart - imgOff,
                                    dbgEnd - imgOff,
                                    lvaCount,
                                    rgLvaDesc,
                                    framePtr );
        // do not delete rgLvaDesc here -- responsibility is now on emitPDBLocalTable destructor
    }
}


/* these are public */

void emitter::SetILBaseOfCode ( BYTE    *pTextBase )
{
    emitILBaseOfCode = pTextBase;
}

void emitter::SetILMethodBase ( BYTE *pMethodEntry )
{
    emitILMethodBase = pMethodEntry;
}

void emitter::SetILMethodStart( BYTE  *pMethodCode )
{
    emitILMethodStart = pMethodCode;
}

void emitter::SetImgBaseOfCode( BYTE    *pTextBase )
{
    emitImgBaseOfCode = pTextBase;
}

void emitter::SetIDBaseToProlog()
{
    emitInstrDescILBase = (long)( emitILMethodBase - emitILBaseOfCode );
}

void emitter::SetIDBaseToOffset( long methodOffset )
{
    emitInstrDescILBase = methodOffset + (long)( emitILMethodStart - emitILBaseOfCode );
}

void emitter::DisablePDBTranslation()
{
    // this function should disable PDB translation code
    emitIsPDBEnabled = false;
}

bool emitter::IsPDBEnabled()
{
    return emitIsPDBEnabled;
}

void emitter::InitTranslationMaps( long ilCodeSize )
{
    if( emitIsPDBEnabled )
    {
        emitPDBOffsetTable = AddrMap::Create( ilCodeSize );
        emitPDBLocalTable = LocalMap::Create();
    }
}

void emitter::DeleteTranslationMaps()
{
    if( emitPDBOffsetTable )
    {
        delete emitPDBOffsetTable;
        emitPDBOffsetTable = 0;
    }
    if( emitPDBLocalTable )
    {
        delete emitPDBLocalTable;
        emitPDBLocalTable = 0;
    }
}

void emitter::InitTranslator( PDBRewriter *           pPDB,
                              int *                   rgSecMap,
                              IMAGE_SECTION_HEADER ** rgpHeader,
                              int                     numSections )
{
    if( emitIsPDBEnabled )
    {
        pPDB->InitMaps( rgSecMap,               // new PE section header order
                        rgpHeader,              // array of section headers
                        numSections,            // number of sections
                        emitPDBOffsetTable,     // code offset translation table
                        emitPDBLocalTable );    // slot variable translation table
    }
}

#endif // TRANSLATE_PDB

/*****************************************************************************/

#if EMITTER_STATS_RLS

unsigned            emitter::emitTotIDcount;
unsigned            emitter::emitTotIDsize;

#endif

/*****************************************************************************/

#if EMITTER_STATS

static  unsigned    totAllocdSize;
static  unsigned    totActualSize;

        unsigned    emitter::emitIFcounts[emitter::IF_COUNT];
#if SCHEDULER
        unsigned    emitter::schedFcounts[emitter::IF_COUNT];
#endif

static  size_t       emitSizeMethod;
static  unsigned     emitSizeBuckets[] = { 100, 1024*1, 1024*2, 1024*3, 1024*4, 1024*5, 1024*10, 0 };
static  histo        emitSizeTable(emitSizeBuckets);

static  unsigned      GCrefsBuckets[] = { 0, 1, 2, 5, 10, 20, 50, 128, 256, 512, 1024, 0 };
static  histo         GCrefsTable(GCrefsBuckets);

#if TRACK_GC_REFS
static  unsigned    stkDepthBuckets[] = { 0, 1, 2, 5, 10, 16, 32, 128, 1024, 0 };
static  histo       stkDepthTable(stkDepthBuckets);
#endif

#if SCHEDULER

static  unsigned    scdCntBuckets[] = { 0, 1, 2, 3, 4, 5, 8, 12, 16, 20, 24, 32, 128, 256, 1024, 0 };
histo      emitter::scdCntTable(scdCntBuckets);

static  unsigned    scdSucBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 28, 32, 48, 64, 1024, 0 };
histo      emitter::scdSucTable(scdSucBuckets);

static  unsigned    scdFrmCntBuckets[] = { 0, 1, 2, 3, 4, 5, 8, 12, 16, 20, 24, 32, 128, 256, 1024, 0 };
histo      emitter::scdFrmCntTable(scdFrmCntBuckets);

#endif  // SCHEDULER

unsigned            emitter::emitTotMemAlloc;
unsigned            emitter::emitLclMemAlloc;
unsigned            emitter::emitExtMemAlloc;

unsigned            emitter::emitTotalInsCnt;

unsigned            emitter::emitTotalIGcnt;
unsigned            emitter::emitTotalIGjmps;
unsigned            emitter::emitTotalIGptrs;
unsigned            emitter::emitTotalIGicnt;
unsigned            emitter::emitTotalIGsize;
unsigned            emitter::emitTotalIGmcnt;

unsigned            emitter::emitSmallDspCnt;
unsigned            emitter::emitLargeDspCnt;

unsigned            emitter::emitSmallCnsCnt;
unsigned            emitter::emitLargeCnsCnt;
unsigned            emitter::emitSmallCns[SMALL_CNS_TSZ];

void                emitterStats()
{
    if  (totAllocdSize)
    {
        assert(totActualSize <= totAllocdSize);

        printf("\nTotal allocated code size = %u\n", totAllocdSize);

        if  (totActualSize < totAllocdSize)
        {
            printf("Total generated code size = %u  ", totActualSize);

            printf("(%4.3f%% waste)", 100*((totAllocdSize-totActualSize)/(double)totActualSize));
            printf("\n");
        }

        assert(emitter::emitTotalInsCnt);

        printf("Average of %4.2f bytes of code generated per instruction\n", (double)totActualSize/emitter::emitTotalInsCnt);
    }

#if 0
#if SCHEDULER

    printf("\nSchedulable instruction format frequency table:\n\n");

    unsigned    f, ic = 0;

    for (f = 0; f < emitter::IF_COUNT; f++)
        ic += schedFcounts[f];

    for (f = 0; f < emitter::IF_COUNT; f++)
    {
        unsigned    cnt = schedFcounts[f];

        if  (cnt)
            printf("%20s %8u (%5.2f%%)\n", emitIfName(f), cnt, 100.0*cnt/ic);
    }

    printf("\n\n");

#endif
#endif

#if 0

    printf("\nInstruction format frequency table:\n\n");

    unsigned    f, ic = 0, dc = 0;

    for (f = 0; f < emitter::IF_COUNT; f++)
        ic += emitter::emitIFcounts[f];

    for (f = 0; f < emitter::IF_COUNT; f++)
    {
        unsigned    c = emitter::emitIFcounts[f];

        if  (c && 1000*c >= ic)
        {
            dc += c;
            printf("%20s %8u (%5.2f%%)\n", emitter::emitIfName(f), c, 100.0*c/ic);
        }
    }

    printf("         -----------------------------\n");
    printf("%20s %8u (%5.2f%%)\n", "Total shown", dc, 100.0*dc/ic);
    printf("\n");

#endif

#ifdef  DEBUG
    if  (!verbose) return;
#endif

#if 0

    printf("\n");
    printf("Offset of idIns       = %2u\n", offsetof(emitter::instrDesc, idIns       ));
    printf("Offset of idInsFmt    = %2u\n", offsetof(emitter::instrDesc, idInsFmt    ));
//  printf("Offset of idSmallCns  = %2u\n", offsetof(emitter::instrDesc, idSmallCns  ));
//  printf("Offset of idOpSize    = %2u\n", offsetof(emitter::instrDesc, idOpSize    ));
//  printf("Offset of idInsSize   = %2u\n", offsetof(emitter::instrDesc, idInsSize   ));
//  printf("Offset of idReg       = %2u\n", offsetof(emitter::instrDesc, idReg       ));
    printf("Offset of idAddr      = %2u\n", offsetof(emitter::instrDesc, idAddr      ));
    printf("\n");
    printf("Size   of idAddr      = %2u\n", sizeof(((emitter::instrDesc*)0)->idAddr  ));
    printf("Size   of insDsc      = %2u\n", sizeof(  emitter::instrDesc              ));
    printf("\n");
    printf("Offset of sdnDepsAll  = %2u\n", offsetof(emitter::scDagNode, sdnDepsAll  ));
//  printf("Offset of sdnDepsAGI  = %2u\n", offsetof(emitter::scDagNode, sdnDepsAGI  ));
    printf("Offset of sdnDepsFlow = %2u\n", offsetof(emitter::scDagNode, sdnDepsFlow ));
    printf("Offset of sdnNext     = %2u\n", offsetof(emitter::scDagNode, sdnNext     ));
    printf("Offset of sdnIndex    = %2u\n", offsetof(emitter::scDagNode, sdnIndex    ));
    printf("Offset of sdnPreds    = %2u\n", offsetof(emitter::scDagNode, sdnPreds    ));
    printf("Offset of sdnHeight   = %2u\n", offsetof(emitter::scDagNode, sdnHeight   ));
    printf("\n");
    printf("Size   of scDagNode   = %2u\n",   sizeof(emitter::scDagNode              ));
    printf("\n");

#endif

#if 0

    printf("Size   of regPtrDsc = %2u\n",   sizeof(Compiler::regPtrDsc           ));
    printf("Offset of rpdNext   = %2u\n", offsetof(Compiler::regPtrDsc, rpdNext  ));
    printf("Offset of rpdBlock  = %2u\n", offsetof(Compiler::regPtrDsc, rpdBlock ));
    printf("Offset of rpdOffs   = %2u\n", offsetof(Compiler::regPtrDsc, rpdOffs  ));
    printf("Offset of <union>   = %2u\n", offsetof(Compiler::regPtrDsc, rpdPtrArg));
    printf("\n");

#endif

    if  (emitter::emitTotalIGmcnt)
    {
        printf("Average of %8.1lf ins groups   per method\n", (double)emitter::emitTotalIGcnt  / emitter::emitTotalIGmcnt);
        printf("Average of %8.1lf instructions per method\n", (double)emitter::emitTotalIGicnt / emitter::emitTotalIGmcnt);
#ifndef DEBUG
        printf("Average of %8.1lf desc.  bytes per method\n", (double)emitter::emitTotalIGsize / emitter::emitTotalIGmcnt);
#endif
        printf("Average of %8.1lf jumps        per method\n", (double)emitter::emitTotalIGjmps / emitter::emitTotalIGmcnt);
        printf("Average of %8.1lf GC livesets  per method\n", (double)emitter::emitTotalIGptrs / emitter::emitTotalIGmcnt);
        printf("\n");
        printf("Average of %8.1lf instructions per group \n", (double)emitter::emitTotalIGicnt / emitter::emitTotalIGcnt );
#ifndef DEBUG
        printf("Average of %8.1lf desc.  bytes per group \n", (double)emitter::emitTotalIGsize / emitter::emitTotalIGcnt );
#endif
        printf("Average of %8.1lf jumps        per group \n", (double)emitter::emitTotalIGjmps / emitter::emitTotalIGcnt );
        printf("\n");
        printf("Average of %8.1lf bytes        per insdsc\n", (double)emitter::emitTotalIGsize / emitter::emitTotalIGicnt);
#ifndef DEBUG
        printf("\n");
        printf("A total of %8u desc.  bytes\n"              ,         emitter::emitTotalIGsize);
#endif
        printf("\n");
    }

#if 0

    printf("Descriptor size distribution:\n");
    emitSizeTable.histoDsp();
    printf("\n");

    printf("GC ref frame variable counts:\n");
    GCrefsTable.histoDsp();
    printf("\n");

    printf("Max. stack depth distribution:\n");
    stkDepthTable.histoDsp();
    printf("\n");

#if SCHEDULER

    printf("Schedulable instruction counts:\n");
    schedCntTable.histoDsp();
    printf("\n");

    printf("Scheduling dag node successor counts:\n");
    schedSucTable.histoDsp();
    printf("\n");

    printf("Schedulable frame range size counts:\n");
    scdFrmCntTable.histoDsp();
    printf("\n");

#endif  // SCHEDULER

#endif  // 0

#if 0

    int             i;
    unsigned        c;
    unsigned        m;

    if  (emitter::emitSmallCnsCnt || emitter::emitLargeCnsCnt)
    {
        printf("SmallCnsCnt = %6u\n"                  , emitter::emitSmallCnsCnt);
        printf("LargeCnsCnt = %6u (%3u %% of total)\n", emitter::emitLargeCnsCnt, 100*emitter::emitLargeCnsCnt/(emitter::emitLargeCnsCnt+emitter::emitSmallCnsCnt));
    }

    if  (emitter::emitSmallCnsCnt)
    {
        printf("\n");

        m = emitter::emitSmallCnsCnt/1000 + 1;

        for (i = ID_MIN_SMALL_CNS; i < ID_MAX_SMALL_CNS; i++)
        {
            c = emitter::emitSmallCns[i-ID_MIN_SMALL_CNS];
            if  (c >= m)
                printf("cns[%4d] = %u\n", i, c);
        }
    }

#endif

    printf("Altogether %8u total   bytes allocated.\n", emitter::emitTotMemAlloc);
    printf("           %8u       locally allocated.\n", emitter::emitLclMemAlloc);
    printf("           %8u     externaly allocated.\n", emitter::emitExtMemAlloc);
}

#endif  // EMITTER_STATS

/*****************************************************************************/

const signed char       emitTypeSizes[] =
{
    #define DEF_TP(tn,nm,jitType,verType,sz,sze,asze,st,al,tf,howUsed) sze,
    #include "typelist.h"
    #undef DEF_TP
};

const signed char       emitTypeActSz[] =
{
    #define DEF_TP(tn,nm,jitType,verType,sz,sze,asze,st,al,tf,howUsed) asze,
    #include "typelist.h"
    #undef DEF_TP
};

/*****************************************************************************
 *
 *  The following called for each recorded instruction -- use for debugging.
 */

#ifdef  DEBUG

static
unsigned            insCount;

void                emitter::emitInsTest(instrDesc *id)
{

    		// make certain you only try to put relocs on things that can have them.  - vancem
    BYTE idOp = emitFmtToOps[id->idInsFmt];
    if (!id->idIsTiny()) { 
        if (id->idInfo.idDspReloc)
            assert(idOp == ID_OP_NONE || idOp == ID_OP_AMD || idOp == ID_OP_DC || idOp == ID_OP_AC 
                || idOp == ID_OP_SPEC || idOp == ID_OP_CALL || idOp == ID_OP_JMP);
        if (id->idInfo.idCnsReloc)
            assert(idOp == ID_OP_CNS || idOp == ID_OP_SCNS || idOp == ID_OP_AC || idOp == ID_OP_SPEC 
                || idOp == ID_OP_CALL || idOp == ID_OP_JMP);
    }

#if 0

    if  (insCount == 24858)
        BreakIfDebuggerPresent();

    const char *m = emitComp->info.compMethodName;
    const char *c = emitComp->info.compClassName;

    insCount++;

#endif

}

#endif

/*****************************************************************************/
/*****************************************************************************
 *
 *  Initialize the emitter - called once, at DLL load time.
 */

void                emitter::emitInit()
{

#if USE_LCL_EMIT_BUFF

//  printf("Local buff size in bytes  = 0x%04X\n", sizeof(emitLclBuff));
//  printf("Local buff size in tiny's = %u    \n", sizeof(emitLclBuff)/TINY_IDSC_SIZE);
//  printf("Local buff size in idsc's = %u    \n", sizeof(emitLclBuff)/sizeof(instrDesc));

    /* Initialize the critical section */

    InitializeCriticalSection(&emitCritSect);

    emitCrScInit = true;
    emitCrScBusy = false;

#endif


}

/*****************************************************************************
 *
 *  Shut down the emitter - called once, at DLL exit time.
 */

void                emitter::emitDone()
{

#if EMITTER_STATS_RLS

    printf("\n");
    printf("Offset of idIns       = %2u\n", offsetof(emitter::instrDesc, idIns       ));
    printf("Offset of idInsFmt    = %2u\n", offsetof(emitter::instrDesc, idInsFmt    ));
//  printf("Offset of idSmallCns  = %2u\n", offsetof(emitter::instrDesc, idSmallCns  ));
//  printf("Offset of idOpSize    = %2u\n", offsetof(emitter::instrDesc, idOpSize    ));
//  printf("Offset of idReg       = %2u\n", offsetof(emitter::instrDesc, idReg       ));
    printf("Offset of idInfo      = %2u\n", offsetof(emitter::instrDesc, idInfo      ));
    printf("Offset of idAddr      = %2u\n", offsetof(emitter::instrDesc, idAddr      ));
    printf("\n");
    printf("Size   of tinyID      = %2u\n", TINY_IDSC_SIZE);
    printf("Size   of scnsID      = %2u\n", SCNS_IDSC_SIZE);
    printf("Size   of instrDesc   = %2u\n", sizeof(emitter::instrDesc));
    printf("\n");
    printf("Size   of id.idAddr   = %2u\n", sizeof(((emitter::instrDesc*)0)->idAddr  ));
    printf("\n");
//  printf("ID_BIT_SMALL_CNS = %u\n", ID_BIT_SMALL_CNS);
//  printf("ID_MIN_SMALL_CNS = %u\n", ID_MIN_SMALL_CNS);
//  printf("ID_MAX_SMALL_CNS = %u\n", ID_MAX_SMALL_CNS);
//  printf("\n");

    printf("Total number of instrDesc's allocated = %u\n", emitTotIDcount);
    printf("Average size of instrDesc's allocated = %6.3f\n", (double)emitTotIDsize/emitTotIDcount);
    printf("\n");

#endif  // EMITTER_STATS_RLS


#if USE_LCL_EMIT_BUFF

    /* Delete the critical section if we've created one */

    if  (emitCrScInit)
    {
        DeleteCriticalSection(&emitCritSect);
        emitCrScInit = false;
    }

#endif

}

/*****************************************************************************
 *
 *  Record some info about the method about to be emitted.
 */

void                emitter::emitBegCG(Compiler     *comp,
                                       COMP_HANDLE   cmpHandle)
{
    emitComp      = comp;
    emitCmpHandle = cmpHandle;
}

void                emitter::emitEndCG()
{
}

/*****************************************************************************
 *
 *  Allocate an instruction group descriptor and assign it the next index.
 */

inline
emitter::insGroup *   emitter::emitAllocIG()
{
    insGroup    *   ig;

    /* Allocate a group descriptor */

    ig = emitCurIG    = (insGroup*)emitGetMem(sizeof(*ig));

#if EMITTER_STATS
    emitTotalIGcnt   += 1;
    emitTotalIGsize  += sizeof(*ig);
    emitSizeMethod  += sizeof(*ig);
#endif

    /* Assign the next available index to the instruction group */

    ig->igNum       = emitNxtIGnum;

	// @TODO [REVISIT] [04/16/01] []: we should understand and try to remove this limitation!
	if (ig->igNum != emitNxtIGnum)			// Overflowed igNum slot
        NO_WAY("Too many instruction groups");
    emitNxtIGnum++;

#ifdef  DEBUG
    ig->igSelf      = ig;
#endif

#if     EMIT_USE_LIT_POOLS
    ig->igLPuseCntW = 0;
    ig->igLPuseCntL = 0;
    ig->igLPuseCntA = 0;
#endif

    ig->igFlags     = 0;

    return  ig;
}

/*****************************************************************************
 *
 *  Prepare the given IG for emission of code.
 */

void                emitter::emitGenIG(insGroup *ig, size_t sz)
{
    /* Set the "current IG" value */

    emitCurIG         = ig;

#if EMIT_TRACK_STACK_DEPTH

    /* Record the stack level on entry to this group */

    ig->igStkLvl      = emitCurStackLvl;

    // If we dont have enough bits in igStkLvl, refuse to compile

    if (ig->igStkLvl != emitCurStackLvl)
        NO_WAY("Too many arguments pushed on stack");

//  printf("Start IG #%02u [stk=%02u]\n", ig->igNum, emitCurStackLvl);

#endif

    /* Record the (estimated) code offset of the group */

    ig->igOffs        = emitCurCodeOffset;

    /* Make sure the code offset looks reasonably aligned */

#if TGT_RISC
    assert((ig->igOffs & (INSTRUCTION_SIZE-1)) == 0);
#endif

    /* Prepare to issue instructions */

    emitCurIGinsCnt   = 0;
#if SCHEDULER
    emitCurIGscd1st   = 0;
    emitCurIGscdOfs   = 0;
#endif
    emitCurIGsize     = 0;
#if TGT_MIPS32
        emitLastHLinstr   = 0;
#endif

    assert(emitCurIGjmpList == NULL);
#if EMIT_USE_LIT_POOLS
    assert(emitLPRlistIG    == NULL);
#endif

    /* Figure out how much space we'd like to have */
    if  (sz == 0)
        sz = SC_IG_BUFFER_SIZE + sizeof(VARSET_TP);

#if USE_LCL_EMIT_BUFF

    /* Can we emit directly into the local buffer? */

    size_t          fs = emitLclAvailMem();

//  printf("Lcl buff available = %u, need = %u\n", fs, sz);

    if  (fs >= sz)
    {
        /* Make sure we don't grab too much space */

        fs = min(fs, 255*TINY_IDSC_SIZE);

        /* Prepare to record instructions in the buffer */

        emitCurIGfreeBase =
        emitCurIGfreeNext =   emitLclBuffNxt
                          + sizeof(unsigned)    // for IGF_BYREF_REGS
                          + sizeof(VARSET_TP);  // for IGF_GC_VARS
                          emitLclBuffNxt += fs;
        emitCurIGfreeEndp = emitLclBuffNxt;

        emitLclBuffDst    = true;
        return;
    }

    /* We'll have to use the other buffer and copy later */

    emitLclBuffDst    = false;

//  if  (!emitIGbuffAddr) printf("Switching to temp buffer: %4u/%4u\n", emitLclBuffEnd-emitLclBuffNxt, SC_IG_BUFFER_SIZE);

#endif

    /* Allocate the temp instruction buffer if we haven't done so */

    if  (emitIGbuffAddr == NULL)
    {
        emitIGbuffSize = SC_IG_BUFFER_SIZE;
        emitIGbuffAddr = (BYTE*)emitGetMem(emitIGbuffSize);
    }

    emitCurIGfreeBase =
    emitCurIGfreeNext = emitIGbuffAddr;
    emitCurIGfreeEndp = emitIGbuffAddr + emitIGbuffSize;
}

/*****************************************************************************
 *
 *  Append a new IG to the current list, and get it ready to receive code.
 */

inline
void                emitter::emitNewIG()
{
    insGroup    *   ig = emitAllocIG();

    /* Append the group to the list */

    assert(emitIGlist);
    assert(emitIGlast);

    ig->igNext   = NULL;
    ig->igPrev   = emitIGlast;
                   emitIGlast->igNext = ig;
                   emitIGlast         = ig;

    if (emitHasHandler)
        ig->igFlags |= IGF_IN_TRY;

    emitGenIG(ig);
}

/*****************************************************************************
 *
 *  Finish and save the current IG.
 */

emitter::insGroup *   emitter::emitSavIG(bool emitAdd)
{
    insGroup    *   ig;
    BYTE    *       id;

    size_t          sz;
    size_t          gs;

    assert(emitLastIns || emitCurIG == emitPrologIG);
    assert(emitCurIGfreeNext <= emitCurIGfreeEndp);

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched();
#endif

    /* Get hold of the IG descriptor */

    ig = emitCurIG; assert(ig);

    /* Compute how much code we've generated */

    sz = emitCurIGfreeNext - emitCurIGfreeBase;

    /* Compute the total size we need to allocate */

    gs = roundUp(sz);

#if TRACK_GC_REFS

    if  (!(ig->igFlags & IGF_EMIT_ADD))
    {
        /* Is the initial set of live GC vars different from the previous one? */

        if (emitPrevGCrefVars != emitInitGCrefVars)
        {
            /* Remember that we will have a new set of live GC variables */

            ig->igFlags |= IGF_GC_VARS;

#if EMITTER_STATS
            emitTotalIGptrs++;
#endif

            /* We'll allocate extra space to record the liveset */

            gs += sizeof(VARSET_TP);
        }

        /* Is the initial set of live Byref regs different from the previous one? */

        /* @TODO [REVISIT] [04/16/01] []: - Can we avoid always storing the byref regs. If so,
           how come the emitXXXXGCrefVars stuff works ?
           The problem was that during codegen, emitThisXXrefRegs is the
           last reported lifetime, not the acutal one as we dont track
           the GC behavior of each instr we add. However during the
           emitting phase, emitThisXXrefRegs is accurate after every
           instruction as we track the GC behavior of each instr
         */

//      if (emitPrevByrefRegs != emitInitByrefRegs)
        {
            /* Remember that we will have a new set of live GC variables */

            ig->igFlags |= IGF_BYREF_REGS;

            /* We'll allocate extra space (DWORD aligned) to record the GC regs */

            gs += sizeof(int);
        }
    }

#endif

    /* Did we store the instructions in the local buffer? */

#if USE_LCL_EMIT_BUFF
    if  (emitLclBuffDst)
    {
        /* We can leave the instructions where we've stored them */

        id = emitCurIGfreeBase;

        if  (ig->igFlags & IGF_GC_VARS)
            id -= sizeof(VARSET_TP);

        if (ig->igFlags & IGF_BYREF_REGS)
            id -= sizeof(unsigned);

#if EMITTER_STATS
        emitTotMemAlloc += gs;
        emitLclMemAlloc += gs;
#endif

        /* Can we give back any unused space at the end of the buffer? */

        if  (emitCurIGfreeEndp == emitLclBuffNxt &&
             emitCurIGfreeNext != emitLclBuffEnd)
        {
            emitLclBuffNxt = (BYTE*)roundUp((int)emitCurIGfreeNext);
        }

//      printf("Remaining bytes in local buffer: %u\n", emitLclBuffEnd - emitLclBuffNxt);
    }
    else
#endif
    {
        /* Allocate space for the instructions and optional liveset */

        id = (BYTE*)emitGetMem(gs);
    }

#if TRACK_GC_REFS

    /* Do we need to store the byref regs */

    if (ig->igFlags & IGF_BYREF_REGS)
    {
        /* Record the byref regs in front the of the instructions */

        *castto(id, unsigned *)++ = emitInitByrefRegs;
    }

    /* Do we need to store the liveset? */

    if  (ig->igFlags & IGF_GC_VARS)
    {
        /* Record the liveset in front the of the instructions */

        *castto(id, VARSET_TP *)++ = emitInitGCrefVars;
    }

#endif

    /* Record the collected instructions */

    ig->igData = id;

    if  (id != emitCurIGfreeBase)
        memcpy(id, emitCurIGfreeBase, sz);

    /* Record how many instructions and bytes of code this group contains */

    ig->igInsCnt       = emitCurIGinsCnt;
    ig->igSize         = emitCurIGsize;
    emitCurCodeOffset += emitCurIGsize;

#if EMITTER_STATS
    emitTotalIGicnt   += emitCurIGinsCnt;
    emitTotalIGsize   += sz;
    emitSizeMethod    += sz;
#endif

//  printf("Group [%08X]%3u has %2u instructions (%4u bytes at %08X)\n", ig, ig->igNum, emitCurIGinsCnt, sz, id);

#if TRACK_GC_REFS

    /* Record the live GC register set - if and only if it is not an emiter added block */

    if  (!(ig->igFlags & IGF_EMIT_ADD))
    {
//      ig->igFlags     |= IGF_GC_REGS;
        ig->igGCregs     = emitInitGCrefRegs;
    }

    if (!emitAdd)
    {
        /* Update the previous recorded live GC ref sets, but not if
           if we are starting an "overflow" buffer
         */

        emitPrevGCrefVars = emitThisGCrefVars;
        emitPrevGCrefRegs = emitThisGCrefRegs;
        emitPrevByrefRegs = emitThisByrefRegs;
    }

#endif

#ifdef  DEBUG
    if  (dspCode)
    {
        printf("\n      G_M%03u_IG%02u:", Compiler::s_compMethodsCount, ig->igNum);
        if (verbose) printf("        ; offs=%06XH", ig->igOffs);
        printf("\n");
    }
#endif

    /* Did we have any jumps in this group? */

    if  (emitCurIGjmpList)
    {
        instrDescJmp  * list = NULL;
        instrDescJmp  * last = NULL;

        /* Move jumps to the global list, update their 'next' links */

        do
        {
            size_t          of;
            instrDescJmp   *oj;
            instrDescJmp   *nj;

            /* Grab the jump and remove it from the list */

            oj = emitCurIGjmpList; emitCurIGjmpList = oj->idjNext;

            /* Figure out the address of where the jump got copied */

            of = (BYTE*)oj - emitCurIGfreeBase;
            nj = (instrDescJmp*)(ig->igData + of);

#if USE_LCL_EMIT_BUFF
            assert((oj == nj) == emitLclBuffDst);
#endif

//          printf("Jump moved from %08X to %08X\n", oj, nj);
//          printf("jmp [%08X] at %08X + %03u\n", nj, ig, nj->idjOffs);

            assert(nj->idjIG   == ig);
            assert(nj->idIns   == oj->idIns);
            assert(nj->idjNext == oj->idjNext);

            /* Make sure the jumps are correctly ordered */

            assert(last == NULL || last->idjOffs > nj->idjOffs);

            /* Append the new jump to the list */

            nj->idjNext = list;
                          list = nj;

            if  (!last)
                last = nj;
        }
        while (emitCurIGjmpList);

        /* Append the jump(s) from this IG to the global list */

        if  (emitJumpList)
            emitJumpLast->idjNext = list;
        else
            emitJumpList          = list;

        last->idjNext = NULL;
        emitJumpLast  = last;
    }

    /* Record any literal pool entries within the IG as needed */

    emitRecIGlitPoolRefs(ig);

#if TGT_SH3

    /* Remember whether the group's end is reachable */

    if  (emitLastIns)
    {
        switch (emitLastIns->idIns)
        {
        case INS_bra:
        case INS_rts:
        case INS_braf:
            ig->igFlags |= IGF_END_NOREACH;
            break;
        }
    }

#endif

#if TGT_x86

    /* Did we have any epilogs in this group? */

    if  (emitCurIGEpiList)
    {
        /* Move epilogs to the global list, update their 'next' links */

        do
        {
            size_t          offs;
            instrDescCns *  epin;

            /* Figure out the address of where the epilog got copied */

            offs = (BYTE*)emitCurIGEpiList - (BYTE*)emitCurIGfreeBase;
            epin = (instrDescCns*)(ig->igData + offs);

            assert(epin->idIns               == emitCurIGEpiList->idIns);
            assert(epin->idAddr.iiaNxtEpilog == emitCurIGEpiList->idAddr.iiaNxtEpilog);

            /* Append the new epilog to the per-method list */

            epin->idAddr.iiaNxtEpilog = 0;

            if  (emitEpilogList)
                emitEpilogLast->idAddr.iiaNxtEpilog = epin;
            else
                emitEpilogList                      = epin;

            emitEpilogLast = epin;

            /* Move on to the next epilog */

            emitCurIGEpiList = emitCurIGEpiList->idAddr.iiaNxtEpilog;
        }
        while (emitCurIGEpiList);
    }

#else

    /* For now we don't use epilog instructions for RISC */

    assert(emitCurIGEpiList == NULL);

#endif

    /* The last instruction field is no longer valid */

    emitLastIns = NULL;

    return  ig;
}

/*****************************************************************************
 *
 *  Save the current IG and start a new one.
 */

#ifndef BIRCH_SP2
 inline
#endif
void                emitter::emitNxtIG(bool emitAdd)
{
    /* Right now we don't allow multi-IG prologs */

    assert(emitCurIG != emitPrologIG);

    /* First save the current group */

    emitSavIG(emitAdd);

    /* Update the GC live sets for the group's start
     * Do it only if not an emiter added block */

#if TRACK_GC_REFS

    if  (!emitAdd)
    {
        emitInitGCrefVars = emitThisGCrefVars;
        emitInitGCrefRegs = emitThisGCrefRegs;
        emitInitByrefRegs = emitThisByrefRegs;
    }

#endif

    /* Start generating the new group */

    emitNewIG();

    /* If this is an emiter added block, flag it */

    if (emitAdd)
        emitCurIG->igFlags |= IGF_EMIT_ADD;

}

void                emitter::emitTmpSizeChanged(size_t tmpSize)
{
    assert(emitGrowableMaxByteOffs <= SCHAR_MAX);

#ifdef DEBUG
     // Ugly hack for FP code
     static ConfigDWORD fMaxTempAssert(L"JITMaxTempAssert", 1);
     bool bAssert = fMaxTempAssert.val()?true:false;
 
     if (tmpSize > emitMaxTmpSize && bAssert)
         assert(!"Incorrect max tmp size set. We have a known bug involving floating point code and this assert. The \
 				generated code will be ok, This is only a warning. To not receive this assert again you can set\
 			  	this registry key: JITMaxTempAssert = 0. Contact dnotario for more info");        

#endif

    if (tmpSize <= emitMaxTmpSize)
        return;

    size_t  change = tmpSize - emitMaxTmpSize;

    /* If we have used a small offset to access a variable, growing the
       temp size is a problem if we should have used a large offset instead.
       Detect if such a situation happens and bail */

    if ( emitGrowableMaxByteOffs           <= SCHAR_MAX &&
        (emitGrowableMaxByteOffs + change) >  SCHAR_MAX)
    {
#ifdef DEBUG
        if (verbose)
            printf("Under-estimated var offset encoding size for ins #%Xh\n", emitMaxByteOffsIdNum);
#endif
        NO_WAY("Should have used large offset to access var");
    }

    emitMaxTmpSize = tmpSize;
    emitGrowableMaxByteOffs += change;
}

/*****************************************************************************
 *
 *  Start generating code to be scheduled; called once per method.
 */

void                emitter::emitBegFN(bool     EBPframe,
#if defined(DEBUG) && TGT_x86
                                       bool     chkAlign,
#endif
                                       size_t   lclSize,
                                       size_t   maxTmpSize)
{
    insGroup    *   ig;

    /* Assume we won't need the temp instruction buffer */

    emitIGbuffAddr = NULL;
    emitIGbuffSize = 0;

#if USE_LCL_EMIT_BUFF

    assert(emitCrScInit);

    /* Enter the critical section guarding the "busy" flag */

    EnterCriticalSection(&emitCritSect);

    /* If the local buffer is available, grab it */

    if  (emitCrScBusy)
    {
        emitLclBuffNxt =
        emitLclBuffEnd = NULL;

        emitCrScUsed   = false;
    }
    else
    {
        emitLclBuffNxt = emitLclBuff;
        emitLclBuffEnd = emitLclBuff + sizeof(emitLclBuff);

        emitCrScUsed   =
        emitCrScBusy   = true;
    }

    /* Leave the critical section guarding the "busy" flag */

    LeaveCriticalSection(&emitCritSect);

#endif

    /* Record stack frame info (the temp size is just an estimate) */

    emitEBPframe        = EBPframe;
    emitLclSize         = lclSize;
    emitMaxTmpSize      = maxTmpSize;
    emitGrowableMaxByteOffs = 0;
#ifdef DEBUG
    emitMaxByteOffsIdNum= -1;
#if TGT_x86
    emitChkAlign        = chkAlign;
#endif
#endif
    /* We have no epilogs yet */

    emitEpilogSize      = 0;
    emitExitSeqSize     = INT_MAX;
    emitEpilogCnt       = 0;
    emitHasHandler      = false;
    emitEpilog1st       = NULL;
#ifdef  DEBUG
    emitHaveEpilog      = false;
#endif
    emitEpilogList      =
    emitEpilogLast      = NULL;
    emitCurIGEpiList    = NULL;

    /* We don't have any jumps */

    emitJumpList        =
    emitJumpLast        = NULL;
    emitCurIGjmpList    = NULL;

#if TGT_x86 || SCHEDULER
    emitFwdJumps        = false;
#endif

#if TGT_RISC
    emitIndJumps        = false;
#if SCHEDULER
    emitIGmoved         = false;
#endif
#endif

    /* We have not recorded any live sets */

#if TRACK_GC_REFS

    emitInitGCrefVars   =
    emitPrevGCrefVars   = 0;
    emitInitGCrefRegs   =
    emitPrevGCrefRegs   = 0;
    emitInitByrefRegs   =
    emitPrevByrefRegs   = 0;

#endif

    /* Assume there will be no GC ref variables */

    emitGCrFrameOffsMin =
    emitGCrFrameOffsMax =
    emitGCrFrameOffsCnt = 0;
#ifdef  DEBUG
    emitGCrFrameLiveTab = NULL;
#endif

    /* We have no groups / code at this point */

    emitIGlist          =
    emitIGlast          = NULL;

    emitCurCodeOffset   = 0;
#ifdef  DEBUG
    emitTotalCodeSize   = 0;
#endif
#if     SCHEDULER
    emitMaxIGscdCnt     = 0;
#endif

#if     EMITTER_STATS
    emitTotalIGmcnt++;
    emitSizeMethod     = 0;
#endif

#ifdef  DEBUG
    emitInsCount        = 0;
#endif

#if TRACK_GC_REFS

    /* The stack is empty now */

    emitCurStackLvl     = 0;

#if EMIT_TRACK_STACK_DEPTH
    emitMaxStackDepth   = 0;
    emitCntStackDepth   = sizeof(int);
#endif

#endif

    /* We don't have any line# info just yet */

#ifdef  DEBUG
    emitBaseLineNo      =
    emitThisLineNo      =
    emitLastLineNo      = 0;
#endif

    /* No data sections have been created */

    emitDataDscCur      = 0;
    emitDataSecCur      = 0;

    memset(&emitConsDsc, 0, sizeof(emitConsDsc));
    memset(&emitDataDsc, 0, sizeof(emitDataDsc));

#if EMIT_USE_LIT_POOLS

    /* We haven't used any literal pool entries */

    emitEstLPwords      = 0;
    emitEstLPlongs      = 0;
    emitEstLPaddrs      = 0;

#ifdef  DEBUG
    emitLitPoolList     =
    emitLitPoolLast     = NULL;       // to prevent trouble in emitDispIGlist()
#endif

    emitLPRlist         =
    emitLPRlast         =
    emitLPRlistIG       = NULL;

#if SMALL_DIRECT_CALLS
    emitTotDCcount      = 0;
#endif

#endif

#if     TGT_RISC

    /* Don't have any indirect/table jumps */

    emitIndJumps        = false;

    /* The following is used to display instructions with extra info */

#ifdef  DEBUG
    emitDispInsExtra    = false;
#endif

#endif

    /* Create the first IG, it will be used for the prolog */

    emitNxtIGnum        = 1;

    emitPrologIG        =
    emitIGlist          =
    emitIGlast          = ig = emitAllocIG();

    emitLastIns         = NULL;

    ig->igPrev          =
    ig->igNext          = NULL;

    /* Append another group, to start generating the method body */

    emitNewIG();
}

/*****************************************************************************
 *
 *  Done generating code to be scheduled; called once per method.
 */

void                emitter::emitEndFN()
{

#if USE_LCL_EMIT_BUFF

    /* Release the local buffer if we were using it */

    if  (emitCrScUsed)
    {
        emitCrScUsed =
        emitCrScBusy = false;
    }

#endif

}

/*****************************************************************************
 *
 *  The following series of methods allocates instruction descriptors.
 */

void        *       emitter::emitAllocInstr(size_t sz, emitAttr opsz)
{
    instrDesc * id;

#ifdef  DEBUG
#endif

    /* Make sure we have enough space for the new instruction */

#ifdef DEBUG
    if  (emitComp->compStressCompile(Compiler::STRESS_EMITTER, 1) &&
         emitCurIGinsCnt && !emitIGisInProlog(emitCurIG) && !(emitCurIG->igFlags & IGF_EPILOG))
        emitNxtIG(true);
#endif

    if  (emitCurIGfreeNext + sz >= emitCurIGfreeEndp)
        emitNxtIG(true);

    /* Grab the space for the instruction */

    emitLastIns = id = (instrDesc*)emitCurIGfreeNext;
                                   emitCurIGfreeNext += sz;

    /*
        The following is a bit subtle - we need to clear the various
        bitfields in the descriptor so that they are initialized to
        0, but there is no great way to do that as one is not allowed
        to get the offset of a bitfield. So, instead we simply clear
        the area defined by the ID_CLEARx_xxx macros (the second one
        conditionally, since not all descriptor contain it).

        In debug mode the layout of an instruction descriptor is very
        different, so to keep things simple we simply clear the whole
        thing via memset.
      */

#ifdef  DEBUG
    memset(id, 0, sz);
#endif

     /*
        Check to make sure the first area is present and its size is
        what we expect (an int), and then clear it.
      */

    assert(ID_CLEAR1_SIZE + ID_CLEAR1_OFFS <= sz);
    assert(ID_CLEAR1_SIZE == sizeof(int));

    *(int*)((BYTE*)id + ID_CLEAR1_OFFS) = 0;

    /* Is the second area to be cleared actually present? */

    if  (sz > ID_CLEAR2_OFFS)
    {
        /* Make sure our belief about the size of the area is correct */

        assert(ID_CLEAR2_SIZE == sizeof(int));

        /* Make sure the entire area is present */

        assert(ID_CLEAR2_SIZE + ID_CLEAR2_OFFS <= sz);

        /* Everything looks fine, let's clear it */

        *(int*)((BYTE*)id + ID_CLEAR2_OFFS) = 0;
    }

    /* In debug mode we clear/set some additional fields */

#ifdef  DEBUG

    id->idNum       = ++emitInsCount;
#if     TGT_x86
    id->idCodeSize  = 0;
#endif
    id->idSize      = sz;
    id->idMemCookie = 0;
    id->idClsCookie = 0;
    id->idSrcLineNo = emitThisLineNo;

#endif

#if     TRACK_GC_REFS

    /* Store the size and handle the two special values
       that indicate GCref and ByRef */

    if       (EA_IS_GCREF(opsz))
    {
        /* A special value indicates a GCref pointer value */

        id->idGCref  = GCT_GCREF;
        id->idOpSize = emitEncodeSize(EA_4BYTE);
    }
    else if  (EA_IS_BYREF(opsz))
    {
        /* A special value indicates a Byref pointer value */

        id->idGCref  = GCT_BYREF;
        id->idOpSize = emitEncodeSize(EA_4BYTE);
    }
    else
    {
        id->idGCref  = GCT_NONE;
        id->idOpSize = emitEncodeSize(EA_SIZE(opsz));
    }

#else

        id->idOpSize = emitEncodeSize(EA_SIZE(opsz));

#endif

#if TGT_x86 && RELOC_SUPPORT

    if       (EA_IS_DSP_RELOC(opsz) && emitComp->opts.compReloc)
    {
        /* Mark idInfo.idDspReloc to remember that the               */
        /* address mode has a displacement that is relocatable       */
        id->idInfo.idDspReloc  = 1;
    }

    if       (EA_IS_CNS_RELOC(opsz) && emitComp->opts.compReloc)
    {
        /* Mark idInfo.idCnsReloc to remember that the               */
        /* instruction has an immediate constant that is relocatable */
        id->idInfo.idCnsReloc  = 1;
    }

#endif


#if     EMITTER_STATS
    emitTotalInsCnt++;
#endif

#if EMITTER_STATS_RLS
    emitTotIDcount += 1;
    emitTotIDsize  += sz;
#endif

#ifdef  TRANSLATE_PDB
    // set id->idilStart to the IL offset of the instruction that generated the id
    SetIDSource( id );
#endif

    /* Update the instruction count */

    emitCurIGinsCnt++;

    return  id;
}

/*****************************************************************************
 *
 *  Make sure the code offsets of all instruction groups look reasonable.
 */

#ifdef  DEBUG

void                emitter::emitCheckIGoffsets()
{
    insGroup    *   tempIG;
    size_t          offsIG;

    for (tempIG = emitIGlist, offsIG = 0;
         tempIG;
         tempIG = tempIG->igNext)
    {
        if  (tempIG->igOffs != offsIG)
        {
            printf("Block #%u has offset %08X, expected %08X\n", tempIG->igNum,
                                                                 tempIG->igOffs,
                                                                 offsIG);
            assert(!"bad block offset");
        }

        /* Make sure the code offset looks reasonably aligned */

#if TGT_RISC
        if  (tempIG->igOffs & (INSTRUCTION_SIZE-1))
        {
            printf("Block #%u has mis-aligned offset %08X\n", tempIG->igNum,
                                                              tempIG->igOffs);
            assert(!"mis-aligned block offset");
        }
#endif

        offsIG += tempIG->igSize;
    }

    if  (emitTotalCodeSize && emitTotalCodeSize != offsIG)
    {
        printf("Total code size is %08X, expected %08X\n", emitTotalCodeSize,
                                                           offsIG);

        assert(!"bad total code size");
    }
}

#else

#define             emitCheckIGoffsets()

#endif

/*****************************************************************************
 *
 *  Begin generating a method prolog.
 */

void                emitter::emitBegProlog()
{

#if EMIT_TRACK_STACK_DEPTH

    /* Don't measure stack depth inside the prolog, it's misleading */

#if TGT_x86
    emitCntStackDepth = 0;
#endif

    assert(emitCurStackLvl == 0);

#endif

    /* Save the current IG if it's non-empty */

    if  (emitCurIGnonEmpty())
        emitSavIG();

    /* Switch to the pre-allocated prolog IG */

    emitGenIG(emitPrologIG, 32 * sizeof(instrDesc));

    /* Nothing is live on entry to the prolog */

#if TRACK_GC_REFS

    emitInitGCrefVars   =
    emitPrevGCrefVars   = 0;
    emitInitGCrefRegs   =
    emitPrevGCrefRegs   = 0;
    emitInitByrefRegs   =
    emitPrevByrefRegs   = 0;

#endif

}

/*****************************************************************************
 *
 *  Return the code offset of the current location in the prolog.
 */

size_t              emitter::emitSetProlog()
{
    /* For now only allow a single prolog ins group */

    assert(emitPrologIG);
    assert(emitPrologIG == emitCurIG);

    return  emitCurIGsize;
}

/*****************************************************************************
 *
 *  Finish generating a method prolog.
 */

void                emitter::emitEndProlog()
{
    size_t          prolSz;

    insGroup    *   tempIG;

    /* Save the prolog IG if non-empty or if only one block */

    if  (emitCurIGnonEmpty() || emitCurIG == emitPrologIG)
        emitSavIG();

    /* Reset the stack depth values */

#if EMIT_TRACK_STACK_DEPTH
    emitCurStackLvl   = 0;
    emitCntStackDepth = sizeof(int);
#endif

    /* Compute the size of the prolog */

    for (tempIG = emitPrologIG, prolSz  = 0;
         emitIGisInProlog(tempIG);
         tempIG = tempIG->igNext)
    {
        prolSz += tempIG->igSize;
    }

    emitPrologSize = prolSz;

    /* Update the offsets of all the blocks */

    emitRecomputeIGoffsets();

    /* We should not generate any more code after this */

    emitCurIG = NULL;
}

/*****************************************************************************
 *
 *  Begin generating an epilog.
 */

void                emitter::emitBegEpilog()
{
    /* Keep track of how many epilogs we have */

    emitEpilogCnt++;

#if TGT_x86

    size_t          sz;
    instrDescCns *  id;

#if EMIT_TRACK_STACK_DEPTH

    assert(emitCurStackLvl == 0);

    /* Don't measure stack depth inside the epilog, it's misleading */

    emitCntStackDepth = 0;

#endif

    /* Make sure the current IG has space for a few more instructions */

    if  (emitCurIGfreeNext + 5*sizeof(*id) > emitCurIGfreeEndp)
    {
        /* Get a fresh new group */

        emitNxtIG(true);
    }

    /* We can now allocate the epilog "instruction" */

    id = emitAllocInstrCns(EA_1BYTE);

    /* Append the epilog "instruction" to the epilog list */

    id->idAddr.iiaNxtEpilog = emitCurIGEpiList;
                              emitCurIGEpiList = id;

    /* Conservatively estimate the amount of code that will be added */

    sz             = MAX_EPILOG_SIZE;

    id->idInsFmt   = IF_EPILOG;
    id->idIns      = INS_nop;
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize   += sz;

#endif

    /* Remember size so that we can compute total epilog size */

    emitExitSeqStart = emitCurIGsize;

    /* Mark this group as being an epilog */

    emitCurIG->igFlags |= IGF_EPILOG;

    /* Remember the first epilog group */

    if  (!emitEpilog1st)
        emitEpilog1st = emitCurIG;
}

/*****************************************************************************
 *
 *  Finish generating an epilog.
 */

void                emitter::emitEndEpilog(bool last)
{
    /* Compute total epilog size */

    size_t newSize  = emitCurIGsize - emitExitSeqStart;
    if (newSize < emitExitSeqSize) 
    {
            // we expect either the epilog to be the same every time, or that
            // one will be a jmp and the other will be a ret or a ret <n>;
            // we make the epilogs the minimum of these.  Note that this ONLY works
            // because the only instruction is the last one and thus a slight 
			// underestimation of the epilog size is harmless (since the EIP 
			// can not be between instructions.
        assert(emitEpilogCnt == 1 || 
            (emitExitSeqSize - newSize) == 5 || (emitExitSeqSize - newSize) == 3 // jmp instr
            );
        emitExitSeqSize = newSize;
    }

#if EMIT_TRACK_STACK_DEPTH

    emitCurStackLvl   = 0;
    emitCntStackDepth = sizeof(int);

#endif

#if TGT_RISC
    assert(last);   // for now only allow one epilog for RISC
#endif

    /* Finish the current instruction group */

    assert(emitCurIGnonEmpty()); emitSavIG();

    /* The end of an epilog sequence is never reached */

#if TGT_RISC
    emitCurIG->igFlags |= IGF_END_NOREACH;
#endif

    /* Start a new IG if more code follows */

    if  (last)
    {
        emitCurIG = NULL;
    }
    else
        emitNewIG();
}

/*****************************************************************************
 *
 *  Return non-zero if the current method only has one epilog, which is
 *  at the very end of the method body.
 */

bool                emitter::emitHasEpilogEnd()
{
    if  (emitEpilogCnt == 1 && (emitIGlast->igFlags & IGF_EPILOG))
        return   true;
    else
        return  false;
}

/*****************************************************************************
 *
 *  The code generator tells us the range of GC ref locals through this
 *  method. Needless to say, locals and temps should be allocated so that
 *  the size of the range is as small as possible.
 */

void                emitter::emitSetFrameRangeGCRs(int offsLo, int offsHi)
{

#ifndef OPT_IL_JIT
#ifdef  DEBUG

    //  A total of    47254 methods compiled.
    //
    //  GC ref frame variable counts:
    //
    //      <=         0 ===>  43175 count ( 91% of total)
    //       1 ..      1 ===>   2367 count ( 96% of total)
    //       2 ..      2 ===>    887 count ( 98% of total)
    //       3 ..      5 ===>    579 count ( 99% of total)
    //       6 ..     10 ===>    141 count ( 99% of total)
    //      11 ..     20 ===>     40 count ( 99% of total)
    //      21 ..     50 ===>     42 count ( 99% of total)
    //      51 ..    128 ===>     15 count ( 99% of total)
    //     129 ..    256 ===>      4 count ( 99% of total)
    //     257 ..    512 ===>      4 count (100% of total)
    //     513 ..   1024 ===>      0 count (100% of total)

    if  (verbose)
    {
        printf("GC refs are at stack offsets ");

        if  (offsLo >= 0)
        {
            printf(" %04X ..  %04X",  offsLo,  offsHi);
            assert(offsHi >= 0);
        }
        else
        {
            printf("-%04X .. -%04X", -offsLo, -offsHi);
            assert(offsHi <  0);
        }

        printf(" [count=%2u]\n", (offsHi-offsLo)/sizeof(void*) + 1);
    }

#endif
#endif

    emitGCrFrameOffsMin = offsLo;
    emitGCrFrameOffsMax = offsHi + sizeof(void*);
    emitGCrFrameOffsCnt = (offsHi-offsLo)/sizeof(void*) + 1;
}

/*****************************************************************************
 *
 *  The code generator tells us the range of local variables through this
 *  method.
 */

void                emitter::emitSetFrameRangeLcls(int offsLo, int offsHi)
{
}

/*****************************************************************************
 *
 *  The code generator tells us the range of used arguments through this
 *  method.
 */

void                emitter::emitSetFrameRangeArgs(int offsLo, int offsHi)
{
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Record a source line# as corresponding to the current code position.
 *  A negated line# indicates the "base" line# of the entire method (if
 *  called before any code is emitted) or the last line of a method (if
 *  called after all the code for the method has been generated).
 */

void                emitter::emitRecordLineNo(int lineno)
{
    if  (lineno < 0)
    {
        lineno = -lineno;

        if  (emitBaseLineNo)
            emitLastLineNo = lineno - 1;
        else
            emitBaseLineNo = lineno;
    }

    emitThisLineNo = lineno;
}

/*****************************************************************************/
#endif
/*****************************************************************************
 *
 *  A conversion table used to map an operand size value (in bytes) into its
 *  small encoding (0 through 3), and vice versa.
 */

BYTE                emitter::emitSizeEnc[] =
{
    0,      // 1
    1,      // 2
   -1,
    2,      // 4
   -1,
   -1,
   -1,
    3       // 8
};

BYTE                emitter::emitSizeDec[] =
{
    1,
    2,
    4,
    8
};

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction that uses both
 *  a displacement and a constant.
 */

emitter::instrDesc *  emitter::emitNewInstrDspCns(emitAttr size, int dsp, int cns)
{
    if  (dsp == 0)
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDesc      *id = emitAllocInstr      (size);

            id->idInfo.idSmallCns = cns;

#if EMITTER_STATS
            emitSmallCnsCnt++;
            emitSmallCns[cns - ID_MIN_SMALL_CNS]++;
            emitSmallDspCnt++;
#endif

            return  id;
        }
        else
        {
            instrDescCns   *id = emitAllocInstrCns   (size);

            id->idInfo.idLargeCns = true;
            id->idcCnsVal  = cns;

#if EMITTER_STATS
            emitLargeCnsCnt++;
            emitSmallDspCnt++;
#endif

            return  id;
        }
    }
    else
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDescDsp   *id = emitAllocInstrDsp   (size);

            id->idInfo.idLargeDsp = true;
            id->iddDspVal  = dsp;

            id->idInfo.idSmallCns = cns;

#if EMITTER_STATS
            emitLargeDspCnt++;
            emitSmallCnsCnt++;
            emitSmallCns[cns - ID_MIN_SMALL_CNS]++;
#endif

            return  id;
        }
        else
        {
            instrDescDspCns*id = emitAllocInstrDspCns(size);

            id->idInfo.idLargeCns = true;
            id->iddcCnsVal = cns;

            id->idInfo.idLargeDsp = true;
            id->iddcDspVal = dsp;

#if EMITTER_STATS
            emitLargeDspCnt++;
            emitLargeCnsCnt++;
#endif

            return  id;
        }
    }
}

/*****************************************************************************
 *
 *  Returns true if garbage-collection wont happen within the helper call.
 *  Dont need to record live pointers for such call sites.
 */

bool                emitter::emitNoGChelper(unsigned IHX)
{
    // UNDONE: Make this faster (maybe via a simple table of bools?)

    switch (IHX)
    {
    case CORINFO_HELP_LLSH:
    case CORINFO_HELP_LRSH:
    case CORINFO_HELP_LRSZ:

//  case CORINFO_HELP_LMUL:
//  case CORINFO_HELP_LDIV:
//  case CORINFO_HELP_LMOD:
//  case CORINFO_HELP_ULDIV:
//  case CORINFO_HELP_ULMOD:

    case CORINFO_HELP_ASSIGN_REF_EAX:
    case CORINFO_HELP_ASSIGN_REF_ECX:
    case CORINFO_HELP_ASSIGN_REF_EBX:
    case CORINFO_HELP_ASSIGN_REF_EBP:
    case CORINFO_HELP_ASSIGN_REF_ESI:
    case CORINFO_HELP_ASSIGN_REF_EDI:

    case CORINFO_HELP_CHECKED_ASSIGN_REF_EAX:
    case CORINFO_HELP_CHECKED_ASSIGN_REF_ECX:
    case CORINFO_HELP_CHECKED_ASSIGN_REF_EBX:
    case CORINFO_HELP_CHECKED_ASSIGN_REF_EBP:
    case CORINFO_HELP_CHECKED_ASSIGN_REF_ESI:
    case CORINFO_HELP_CHECKED_ASSIGN_REF_EDI:

    case CORINFO_HELP_ASSIGN_BYREF:

//  case CORINFO_HELP_RESOLVEINTERFACE:
//  case CPX_RES_IFC_TRUSTED:
//  case CPX_RES_IFC_TRUSTED2:

    case CORINFO_HELP_GET_THREAD:

        return  true;
    }

    return  false;
}

/*****************************************************************************
 *
 *  Mark the current spot as having a label.
 */

void                emitter::emitAddLabel(void **labPtr)
{
    /* Create a new IG if the current one is non-empty */

    if  (emitCurIGnonEmpty())
        emitNxtIG();

    /* Mark the IG as having a label */

    emitCurIG->igFlags |= IGF_HAS_LABEL;

    /* Give the caller a ref to the corresponding IG */

    if (labPtr)
        *labPtr = emitCurIG;
}

#if TRACK_GC_REFS

void                emitter::emitAddLabel(void **   labPtr,
                                          VARSET_TP GCvars,
                                          unsigned  gcrefRegs,
                                          unsigned  byrefRegs)
{
    emitAddLabel(labPtr);

#if TGT_RISC

    #pragma message("NOTE: GC ref tracking disabled for RISC targets")

    GCvars      = 0;
    gcrefRegs   = 0;
    byrefRegs   = 0;

#endif

#ifndef OPT_IL_JIT
#ifdef  DEBUG
    if  (verbose) printf("Label: GCvars=%016I64X , gcrefRegs=%04X , byrefRegs=%04X\n",
                                 GCvars,           gcrefRegs,       byrefRegs);
#endif
#endif

    emitThisGCrefVars = emitInitGCrefVars = GCvars;
    emitThisGCrefRegs = emitInitGCrefRegs = gcrefRegs;
    emitThisByrefRegs = emitInitByrefRegs = byrefRegs;
}

#endif

/*****************************************************************************/
#ifdef  DEBUG
#if     TRACK_GC_REFS
/*****************************************************************************
 *
 *  Display a register set in a readable form.
 */

void                emitter::emitDispRegSet(unsigned regs, bool calleeOnly)
{
    unsigned        reg;
    bool            sp;

    for (reg = 0, sp = false; reg < SR_COUNT; reg++)
    {
        char            tmp[4];

        if  (calleeOnly && !(RBM_CALLEE_SAVED & emitRegMask((emitRegs)reg)))
            continue;

        if  (regs & emitRegMask((emitRegs)reg))
        {
            strcpy(tmp, emitRegName((emitRegs)reg));
        }
        else
        {
            if  (!calleeOnly)
                continue;

            strcpy(tmp, "   ");
        }

        if  (sp)
            printf(" ");
        else
            sp = true;

        printf(tmp);
    }
}

/*****************************************************************************
 *
 *  Display the current GC ref variable set in a readable form.
 */

void                emitter::emitDispVarSet()
{
    unsigned        vn;
    int             of;
    bool            sp = false;

    for (vn  = 0, of  = emitGCrFrameOffsMin;
         vn < emitGCrFrameOffsCnt;
         vn += 1, of += sizeof(void *))
    {
        if  (emitGCrFrameLiveTab[vn])
        {
            if  (sp)
                printf(" ");
            else
                sp = true;

#if TGT_x86
            printf("[%s", emitEBPframe ? "EBP" : "ESP");
#else
            assert(!"need non-x86 code");
#endif

            if      (of < 0)
                printf("-%02XH", -of);
            else if (of > 0)
                printf("+%02XH", +of);

            printf("]");
        }
    }
}

/*****************************************************************************/
#endif//TRACK_GC_REFS
#endif//DEBUG
/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an indirect call.
 *
 *  We use two different descriptors to save space - the common case records
 *  no GC variables and has both a very small argument count and an address
 *  mode displacement; the much rarer (we hope) case records the current GC
 *  var set, the call scope, and an arbitrarily large argument count and
 *  address mode displacement.
 */

emitter::instrDesc  * emitter::emitNewInstrCallInd(int        argCnt,
#if TGT_x86
                                                   int        disp,
#endif
#if TRACK_GC_REFS

                                                   VARSET_TP  GCvars,
                                                   unsigned   byrefRegs,
#endif
                                                   int        retSizeIn)
{
    emitAttr  retSize = retSizeIn ? EA_ATTR(retSizeIn) : EA_4BYTE;

    /*
        Allocate a larger descriptor if any GC values need to be saved
        or if we have an absurd number of arguments or a large address
        mode displacement, or we have some byref registers
     */

#if TRACK_GC_REFS
    if  (GCvars    != 0)                 goto BIG;
    if  (byrefRegs != 0)                 goto BIG;
#endif

#if TGT_x86
    if  (disp < AM_DISP_MIN)             goto BIG;
    if  (disp > AM_DISP_MAX)             goto BIG;
    if  (argCnt < 0)                     goto BIG;  // caller pops arguments
#endif

    if  (argCnt > ID_MAX_SMALL_CNS)
    {
        instrDescCIGCA* id;

    BIG:

        id = emitAllocInstrCIGCA(retSize);

        id->idInfo.idLargeCall = true;

#if TRACK_GC_REFS
        id->idciGCvars         = GCvars;
        id->idciByrefRegs      = emitEncodeCallGCregs(byrefRegs);
#endif
        id->idciArgCnt         = argCnt;
#if TGT_x86
        id->idciDisp           = disp;
#endif

        return  id;
    }
    else
    {
        instrDesc     * id;

        id = emitNewInstrCns(retSize, argCnt);

        /* Make sure we didn't waste space unexpectedly */

        assert(id->idInfo.idLargeCns == false);

#if TGT_x86

        /* Store the displacement and make sure the value fit */

        id->idAddr.iiaAddrMode.amDisp  = disp;
 assert(id->idAddr.iiaAddrMode.amDisp == disp);

#endif

        return  id;
    }
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Return a string with the name of the given class field (blank string (not
 *  NULL) is returned when the name isn't available).
 */

const   char *      emitter::emitFldName(int mem, void *cls)
{
    if  (varNames)
    {
        const  char *   memberName;
        const  char *   className;

        static char     buff[1024];

        if  (!cls)
            cls = emitComp->info.compScopeHnd;

       memberName = emitComp->eeGetFieldName(emitComp->eeFindField(mem, (CORINFO_MODULE_HANDLE) cls, 0), &className);

        sprintf(buff, "'<%s>.%s'", className, memberName);
        return  buff;
    }
    else
        return  "";
}

/*****************************************************************************
 *
 *  Return a string with the name of the given function (blank string (not
 *  NULL) is returned when the name isn't available).
 */

const   char *      emitter::emitFncName(CORINFO_METHOD_HANDLE methHnd)
{
    const  char *   memberName;
    const  char *   className;

    static char     buff[1024];

    memberName = emitComp->eeGetMethodName(methHnd, &className);

    sprintf(buff, "'<%s>.%s'", className, memberName);
    return  buff;
}

/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************
 *
 *  Be very careful, some instruction descriptors are allocated as "tiny" and
 *  don't have some of the tail fields of instrDesc (in particular, "idInfo").
 */

BYTE                emitter::emitFmtToOps[] =
{
    #define IF_DEF(en, op1, op2) ID_OP_##op2,
    #include "emitfmts.h"
    #undef  IF_DEF
};

#ifdef  DEBUG
unsigned            emitter::emitFmtCount = sizeof(emitFmtToOps)/sizeof(emitFmtToOps[0]);
#endif

/*****************************************************************************
 *
 *  Display the current instruction group list.
 */

#ifdef  DEBUG

void                emitter::emitDispIGlist(bool verbose)
{
    insGroup    *   ig;
    insGroup    *   il;

#if EMIT_USE_LIT_POOLS
    litPool *       lp = emitLitPoolList;
#endif

    for (il = NULL, ig = emitIGlist;
                    ig;
         il = ig  , ig = ig->igNext)
    {
        printf("G_M%03u_IG%02u:", Compiler::s_compMethodsCount, ig->igNum);
        printf("        ; offs=%06XH , size=%04XH\n", ig->igOffs, ig->igSize);

        assert(ig->igPrev == il);

        if  (verbose)
        {
            BYTE    *   ins = ig->igData;
            size_t      ofs = ig->igOffs;
            unsigned    cnt = ig->igInsCnt;

            if  (cnt)
            {
                printf("\n");

                do
                {
                    instrDesc * id = (instrDesc *)ins;

                    emitDispIns(id, false, true, false, ofs);

                    ins += emitSizeOfInsDsc(id);
                    ofs += emitInstCodeSz  (id);
                }
                while (--cnt);

                printf("\n");
            }
        }

#if EMIT_USE_LIT_POOLS
        if  (lp && lp->lpIG == ig)
        {
            printf("        LitPool [%2u/%2u words, %2u/%2u longs, %2u/%2u addrs] at 0x%X ptr:%X\n", lp->lpWordCnt,
                                                                       lp->lpWordMax,
                                                                       lp->lpLongCnt,
                                                                       lp->lpLongMax,
                                                                       lp->lpAddrCnt,
                                                                       lp->lpAddrMax,
                                                                       lp->lpOffs,
                                                                       lp);

            lp = lp->lpNext;
        }
#endif

    }

#if EMIT_USE_LIT_POOLS
    assert(lp == NULL);
#endif

}

#endif

/*****************************************************************************
 *
 *  Issue the given instruction. Basically, this is just a thin wrapper around
 *  emitOutputInstr() that does a few debug checks.
 */

size_t              emitter::emitIssue1Instr(insGroup  *ig,
                                             instrDesc *id, BYTE **dp)
{
    size_t          is;

#if MAX_BRANCH_DELAY_LEN || SMALL_DIRECT_CALLS
    if  (id->idIns == INS_ignore)
        return  emitSizeOfInsDsc(id);
#endif

#ifdef DEBUG
    if  (id->idSrcLineNo != emitLastSrcLine && !emitIGisInProlog(ig))
    {
        emitLastSrcLine = id->idSrcLineNo;
        if (disAsm && dspLines)
            emitComp->compDspSrcLinesByLineNum(emitLastSrcLine, false);
    }
#endif

    /* Record the beginning offset of the instruction */

    emitCurInsAdr = *dp;

    /* Issue the next instruction */

//  printf("[S=%02u] " , emitCurStackLvl);

    is = emitOutputInstr(ig, id, dp);

//  printf("[S=%02u]\n", emitCurStackLvl);

#if EMIT_TRACK_STACK_DEPTH && TRACK_GC_REFS

    /*
        If we're generating a full pointer map and the stack
        is empty, there better not be any "pending" argument
        push entries.
     */

    assert(emitFullGCinfo  == false ||
           emitCurStackLvl != 0     ||
           emitGcArgTrackCnt == 0);

#endif

#if TGT_x86
#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)

    /* Did the size of the instruction match our expectations? */

    size_t          csz = *dp - emitCurInsAdr;

    if  (csz != id->idCodeSize && id->idInsFmt != IF_EPILOG)
    {
#ifdef  DEBUG
#endif
        /* It is fatal to under-estimate the instruction size */
        if (emitInstCodeSz(id) < csz)
            NO_WAY("Under-estimated instruction size");

        /* The instruction size estimate wasn't accurate; remember this */

        ig->igFlags   |= IGF_UPD_ISZ;
        id->idCodeSize = csz;
    }

#endif
#endif

#ifdef  DEBUG

    /* Make sure the instruction descriptor size also matches our expectations */

    if  (is != emitSizeOfInsDsc(id))
    {
        printf("%s at %u: Expected size = %u , actual size = %u\n",
               emitIfName(id->idInsFmt), id->idNum, is, emitSizeOfInsDsc(id));
        assert(is == emitSizeOfInsDsc(id));
    }

#endif

    return  is;
}

/*****************************************************************************
 *
 *  Dont schedule across this boundary
 */

#if SCHEDULER

void            emitter::emitIns_SchedBoundary()
{
    // Why add a boundary if we arent scheduling in the first place ?

    assert(emitComp->opts.compSchedCode);

    /* Insert a pseudo-instruction to prevent scheduling across this */

    instrDesc * id  = emitNewInstrTiny(EA_1BYTE);
    id->idIns       = INS_noSched;
    id->idCodeSize  = 0;

    assert(scIsSchedulable(id->idIns) == false);
}

#endif

/*****************************************************************************/
/*****************************************************************************
 *
 *  Update the offsets of all the instruction groups (note: please don't be
 *  lazy and call this routine frequently, it walks the list of instruction
 *  groups and thus it isn't cheap).
 */

void                emitter::emitRecomputeIGoffsets()
{
    size_t          offs;
    insGroup    *   list;

    for (list = emitIGlist, offs = 0;
         list;
         list = list->igNext)
    {
        list->igOffs = offs;
                       offs += list->igSize;
    }

    /* Update the total code size (but only if it's been set already) */

    if  (emitTotalCodeSize)
        emitTotalCodeSize = offs;

    /* Paranoia? You bet! */

    emitCheckIGoffsets();
}

/*****************************************************************************
 *
 *  Bind targets of relative jumps to decide if the instruction will use
 *  the small or big encoding.
 */

void                emitter::emitJumpDistBind()
{
#ifdef  DEBUG

    if  (verbose & 0)
    {
        printf("\nInstruction list before jump distance binding:\n\n");
        emitDispIGlist(true);
    }

#endif

    instrDescJmp *  jmp;

    size_t          minx;
    size_t          adjIG;
#if TGT_x86
    size_t          adjLJ;
#endif
    insGroup    *   lstIG;

    int             jmp_iteration = 0;

AGAIN:

    emitCheckIGoffsets();

    /*
        In the following loop we convert all jump targets from "BasicBlock *"
        to "insGroup *" values. We also estimate which jumps will be short.
     */

#if     TGT_x86

#ifdef  DEBUG
    insGroup     *  lastIG = NULL;
    instrDescJmp *  lastLJ = NULL;
#endif

    lstIG = NULL;

    adjLJ = 0;

#else

    instrDescJmp *  lastLJ = NULL;

#endif

    adjIG = 0;

    for (jmp = emitJumpList, minx = 99999;
         jmp;
         jmp = jmp->idjNext)
    {
        insGroup    *   jmpIG;
        insGroup    *   tgt;

        size_t          jsz;

        size_t          ssz;            // small  jump size
        int             nsd;            // small  jump max. neg distance
        int             psd;            // small  jump max. pos distance

#if     TGT_SH3
        size_t          msz;            // middle jump size
        int             nmd;            // middle jump max. neg distance
        int             pmd;            // middle jump max. pos distance
#endif

        size_t          lsz;            // large  jump size

        int             extra;
        size_t          srcOffs;
        size_t          dstOffs;
        int             jmpDist;
        size_t          oldSize;
        size_t          sizeDif;

#if     TGT_RISC

        instrDescJmp *  pji = lastLJ; lastLJ = jmp;

        /* Ignore indirect jumps for now */

        if  (jmp->idInsFmt == IF_JMP_TAB)
            continue;

#if     SCHEDULER
        assert(emitComp->opts.compSchedCode ||
               jmp->idjAddBD == (unsigned)Compiler::instBranchDelay(jmp->idIns));
#else
#ifdef DEBUG
        assert(jmp_iteration ||
               jmp->idjAddBD == (unsigned)Compiler::instBranchDelay(jmp->idIns));
#endif
#endif

#endif

#if TGT_MIPSFP
        assert( (jmp->idInsFmt == IF_LABEL) ||
                (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR)  ||
                (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O) ||
                (jmp->idInsFmt == IF_O));

#elif TGT_MIPS32
        assert( (jmp->idInsFmt == IF_LABEL) ||
                (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR) ||
                (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O));
#else
        assert(jmp->idInsFmt == IF_LABEL);
#endif

        /* Figure out the smallest size we can end up with */

        if  (emitIsCondJump(jmp))
        {
            ssz = JCC_SIZE_SMALL;
            nsd = JCC_DIST_SMALL_MAX_NEG;
            psd = JCC_DIST_SMALL_MAX_POS;

#if     TGT_SH3
            msz = JCC_SIZE_MIDDL;
            nmd = JCC_DIST_MIDDL_MAX_NEG;
            pmd = JCC_DIST_MIDDL_MAX_POS;
#endif

            lsz = JCC_SIZE_LARGE;
        }
        else
        {
            ssz = JMP_SIZE_SMALL;
            nsd = JMP_DIST_SMALL_MAX_NEG;
            psd = JMP_DIST_SMALL_MAX_POS;

#if     TGT_SH3
            msz = JMP_SIZE_MIDDL;
            nmd = JMP_DIST_MIDDL_MAX_NEG;
            pmd = JMP_DIST_MIDDL_MAX_POS;
#endif

            lsz = JMP_SIZE_LARGE;
        }

        /* Make sure the jumps are properly ordered */

#ifdef  DEBUG
#if     TGT_x86
        assert(lastLJ == NULL || lastIG != jmp->idjIG ||
               lastLJ->idjOffs < jmp->idjOffs);
        lastLJ = (lastIG == jmp->idjIG) ? jmp : NULL;

        assert(lastIG == NULL ||
               lastIG->igNum   <= jmp->idjIG->igNum ||
               emitNxtIGnum > unsigned(0xFFFF)); // igNum might overflow
        lastIG = jmp->idjIG;
#endif
#endif

        /* Get hold of the current jump size */

        jsz = oldSize = emitSizeOfJump(jmp);

        /* Get the group the jump is in */

        jmpIG = jmp->idjIG;

#if     TGT_x86

        /* Are we in a group different from the previous jump? */

        if  (lstIG != jmpIG)
        {
            /* Were there any jumps before this one? */

            if  (lstIG)
            {
                /* Adjust the offsets of the intervening blocks */

                do
                {
                    lstIG = lstIG->igNext; assert(lstIG);
//                  printf("Adjusted offset of block %02u from %04X to %04X\n", lstIG->igNum, lstIG->igOffs, lstIG->igOffs - adjIG);
                    lstIG->igOffs -= adjIG;
                }
                while (lstIG != jmpIG);
            }

            /* We've got the first jump in a new group */

            adjLJ = 0;
            lstIG = jmpIG;
        }

        /* Apply any local size adjustment to the jump's relative offset */

        jmp->idjOffs -= adjLJ;

#if     SCHEDULER
        if  (jmp->idjSched)
        {
            assert(emitComp->opts.compSchedCode);

            if (jmp->idjTemp.idjOffs[0] < adjLJ)
                jmp->idjTemp.idjOffs[0] = 0;
            else
                jmp->idjTemp.idjOffs[0] -= adjLJ;

            assert(jmp->idjTemp.idjOffs[1] >= adjLJ);
            jmp->idjTemp.idjOffs[1] -= adjLJ;
        }
#endif
#endif
        // done if this is a jump via register, size does not change

#if     TGT_MIPS32
        if (IF_JR_R == jmp->idInsFmt || IF_JR == jmp->idInsFmt)
        {
            jsz = INSTRUCTION_SIZE;
            goto CONSIDER_DELAY_SLOT;
        }
#endif

        /* Have we bound this jump's target already? */

        if  (jmp->idInfo.idBound)
        {
            /* Does the jump already have the smallest size? */

            if  (jmp->idjShort)
            {
#if     TGT_RISC
                assert((emitSizeOfJump(jmp) == ssz) || jmp->idjAddBD);
#else
                assert(emitSizeOfJump(jmp) == ssz);
#endif
                continue;
            }

            tgt = jmp->idAddr.iiaIGlabel;
        }
        else
        {
            /* First time we've seen this label, convert its target */

            tgt = (insGroup*)emitCodeGetCookie(jmp->idAddr.iiaBBlabel); assert(tgt);

            /* Record the bound target */

            jmp->idAddr.iiaIGlabel = tgt;
            jmp->idInfo.idBound    = true;
        }

        /* Done if this is not a variable-sized jump */

#if     TGT_x86
        if  (jmp->idIns == INS_call || jmp->idIns == INS_push || jmp->idIns == INS_push_hide)
            continue;
#endif

        /*
            In the following distance calculations, if we're not actually
            scheduling the code (i.e. reordering instructions), we can
            use the actual offset of the jump (rather than the beg/end of
            the instruction group) since the jump will not be moved around
            and thus its offset is accurate.

            First we need to figure out whether this jump is a forward or
            backward one; to do this we simply look at the ordinals of the
            group that contains the jump and the target.
         */

        dstOffs = tgt->igOffs;

#if     SCHEDULER
    JMP_REP:
#endif

        if  (jmpIG->igNum < tgt->igNum)
        {
            /* Forward jump: figure out the appropriate source offset */

            srcOffs = jmpIG->igOffs;

#if     SCHEDULER
            if  (jmp->idjSched)
            {
                assert(emitComp->opts.compSchedCode);

                srcOffs += jmp->idjTemp.idjOffs[0];
            }
            else
#endif
            {
                srcOffs += jmp->idjOffs;
            }

            /* Adjust the target offset by the current delta */

#if     TGT_x86
            dstOffs -= adjIG;
#endif

            /* Compute the distance estimate */

#if   TGT_SH3
            jmpDist = dstOffs - (srcOffs + INSTRUCTION_SIZE);
#elif TGT_MIPS32 || TGT_PPC
            jmpDist = dstOffs - (srcOffs + INSTRUCTION_SIZE) - (lsz - ssz);
#else
            jmpDist = dstOffs - srcOffs - ssz;
#endif

            /* How much beyond the max. short distance does the jump go? */

            extra   = jmpDist - psd;

#if     SCHEDULER

            if  (extra > 0 && jmp->idjSched)
            {
                /*
                    Could it happen that the jump might become non-short
                    solely due to scheduling?
                 */

                if  (unsigned(extra) <= jmp->idjOffs - jmp->idjTemp.idjOffs[0])
                {
                    /* Keep the jump short by not scheduling it */

                    jmp->idjSched = false;

                    goto JMP_REP;
                }
            }

#endif

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[1] Jump %u:\n",               jmp->idNum);
                printf("[1] Jump  block is at %08X\n", jmpIG->igOffs);
                printf("[1] Jump source is at %08X\n", srcOffs+ssz);
                printf("[1] Label block is at %08X\n", dstOffs);
                printf("[1] Jump  dist. is    %04X\n", jmpDist);
                if  (extra > 0)
                printf("[1] Dist excess [S] = %d  \n", extra);
            }
#endif

#ifdef  DEBUG
            if  (verbose) printf("Estimate of fwd jump [%08X/%03u]: %04X -> %04X = %04X\n", jmp, jmp->idNum, srcOffs, dstOffs, jmpDist);
#endif

            if  (extra <= 0)
            {
                /* This jump will be a short one */

                goto SHORT_JMP;
            }

#if     TGT_SH3

            /* Can we use a "medium" jump? */

            if  (!msz)
                goto LARGE_JMP;

            /* Compute the distance estimate for a medium jump */

            jmpDist = dstOffs - srcOffs - msz;

            /* How much beyond the max. medium distance does the jump go? */

            extra   = jmpDist - pmd;

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (extra > 0)
                printf("[1] Dist excess [M] = %d  \n", extra);
            }
#endif

            if  (extra <= 0)
            {
                /* This jump will be a "medium" one */

                goto MIDDL_JMP;
            }

#endif

            /* This jumps needs to stay "long", at least for now */

            ;
        }
        else
        {
            /* This is a backward jump */

            size_t          srcOffs;

            /* Figure out the appropriate source offset to use */

            srcOffs = jmpIG->igOffs;
#if SCHEDULER
            if  (emitComp->opts.compSchedCode && jmp->idjSched)
            {
                srcOffs += jmp->idjTemp.idjOffs[1];
            }
            else
#endif
            {
                srcOffs += jmp->idjOffs;
            }

            /* Compute the distance estimate */

#if     (TGT_SH3 || TGT_MIPS32 || TGT_PPC)
            jmpDist = srcOffs + INSTRUCTION_SIZE - dstOffs;
#else
            jmpDist = srcOffs - dstOffs + ssz;
#endif

            /* How much beyond the max. short distance does the jump go? */

            extra = jmpDist + nsd;

#if     SCHEDULER

            if  (extra > 0 && jmp->idjSched)
            {
                /* Would the jump not short solely due to scheduling?
                 * We prefer short to schedulable.
                 */

                if  ((unsigned)extra <= jmp->idjTemp.idjOffs[1] - jmp->idjOffs)
                {
                    /* Prevent the jump from being scheduled */

                    jmp->idjSched = false;

                    goto JMP_REP;
                }
            }

#endif

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[2] Jump %u:\n",               jmp->idNum);
                printf("[2] Jump reloffset is %04X\n", jmp->idjOffs);
                printf("[2] Jump  block is at %08X\n", jmpIG->igOffs);
                printf("[2] Jump source is at %08X\n", srcOffs+ssz);
                printf("[2] Label block is at %08X\n", tgt->igOffs);
                printf("[2] Jump  dist. is    %04X\n", jmpDist);
                if  (extra > 0)
                printf("[2] Dist excess [S] = %d  \n", extra);
            }
#endif

#ifdef  DEBUG
            if  (verbose) printf("Estimate of bwd jump [%08X/%03u]: %04X -> %04X = %04X\n", jmp, jmp->idNum, srcOffs, tgt->igOffs, jmpDist);
#endif

            if  (extra <= 0)
            {
                /* This jump will be a short one */

                goto SHORT_JMP;
            }

#if     TGT_SH3

            /* Can we use a "medium" jump? */

            if  (!msz)
                goto LARGE_JMP;

            /* We assume only conditional have a medium flavor */

            assert(emitIsCondJump(jmp));

            /* Compute the distance estimate for a medium jump */

            jmpDist = srcOffs - dstOffs - msz;

            /* How much beyond the max. short distance does the jump go? */

            extra = jmpDist + nmd;

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (extra > 0)
                printf("[2] Dist excess [M] = %d  \n", extra);
            }
#endif

            if  (extra <= 0)
            {
                /* This jump will be a "medium" one */

                goto MIDDL_JMP;
            }

#endif

            /* This jumps needs to stay "long", at least for now */

            ;
        }

#if     TGT_RISC
    LARGE_JMP:
#endif

        /* We arrive here if the jump needs to stay long */

        /* We had better not have eagerly marked the jump as short
         * in emitIns_J(). If we did, then it has to be able to stay short
         * as emitIns_J() uses the worst case scenario, and blocks can
         * only move closer togerther after that.
         */
        assert(jmp->idjShort  == 0);
#if     TGT_RISC
        assert(jmp->idjMiddle == 0);
#endif

        /* Keep track of the closest distance we got */

        if  (minx > (unsigned)extra)
             minx = (unsigned)extra;

        continue;

    SHORT_JMP:

        /* This jump will definitely be a short one */

        jmp->idjShort  = 1;
        jsz            = ssz;

#if TGT_MIPS32 || TGT_PPC

        /* jump elimination should work for any CPU, only tested for MIPS */

        if (0 == jmpDist)               // are we just falling thru?
        {
            jsz = 0;
            goto SMALL_JMP;
        }

#endif

#if TGT_RISC
CONSIDER_DELAY_SLOT:
        /* Some jumps may need a branch delay slot */

        if  (jmp->idjAddBD)
        {
#if TGT_MIPS32 || TGT_SH3 // @TODO [REVISIT] [04/16/01] []: add each CPU back in to this logic as needed

            /* Can we simply swap the branch with the previous instruction? */

            instrDesc * pid;

            /*
                @TODO [CONSIDER] [04/16/01] []:
                
                The following is very inefficient.

                The following is horrible - since we have no easy way
                of finding the previous instruction, we start at the
                beginning of the jump's group and walk through the
                instructions until we find the one just before the
                jump.

                One minor improvement: if the previous jump belongs
                to this group, we start the search at that jump.
            */

            pid = (pji && pji->idjIG == jmpIG) ? pji
                                               : (instrDesc *)jmpIG->igData;
            if (pid < jmp)
            {
                for (;;)
                {
                    /* Get hold of the next instruction */

                    instrDesc * nid = (instrDesc *)((BYTE*)pid + emitSizeOfInsDsc(pid));

                    /* Stop if the next instruction is our jump */

                    if  (nid == jmp)
                        break;

                    /* Continue looking (but make sure we're not too far) */

                    assert(nid < jmp);

                    pid = nid;
                }

                /* Now we can we decide whether we can swap the instructions */

                jmp->idjAddBD = emitIns_BD (jmp, pid, jmpIG);
            }
#endif  // CPUs as needed

            // If the delay slot is needed add its size

            if  (jmp->idjAddBD)
                jsz += INSTRUCTION_SIZE;
        }
#endif

        goto SMALL_JMP;

#if     TGT_SH3

    MIDDL_JMP:

        /* This jump will be a "medium" one */

        jsz            = msz;
        jmp->idjMiddle = 1;

#endif

    SMALL_JMP:

        /* This jump is becoming either short or medium */

        sizeDif = oldSize - jsz; assert((int)sizeDif >= 0);

#if     TGT_x86
        jmp->idCodeSize = jsz;
#endif
#if     TGT_SH3
        if (!all_jumps_shortened && sizeDif && oldSize > msz)
        {
            assert(jmpIG->igLPuseCntL > 0);
            jmpIG->igLPuseCntL--;
            //emitEstLPlongs--;
        }
#endif

        /* Make sure the size of the jump is marked correctly */

        assert((0 == (jsz | jmpDist)) || (jsz == emitSizeOfJump(jmp)));

#ifdef  DEBUG
        if  (verbose) printf("Shrinking jump [%08X/%03u]\n", jmp, jmp->idNum);
#endif

        adjIG             += sizeDif;
#if     TGT_x86
        adjLJ             += sizeDif;
#endif
        jmpIG->igSize     -= sizeDif;
        emitTotalCodeSize -= sizeDif;

        /* The jump size estimate wasn't accurate; flag its group */

        jmpIG->igFlags    |= IGF_UPD_ISZ;
    }

    /* Did we shorten any jumps? */

    if  (adjIG)
    {

#if     TGT_x86

        /* Adjust offsets of any remaining blocks */

        assert(lstIG);

        for (;;)
        {
            lstIG = lstIG->igNext;
            if  (!lstIG)
                break;
//          printf("Adjusted offset of block %02u from %04X to %04X\n", lstIG->igNum, lstIG->igOffs, lstIG->igOffs - adjIG);
            lstIG->igOffs -= adjIG;
        }

#else

        /* Simply update the offsets of all the blocks */

        emitRecomputeIGoffsets();

#endif

        emitCheckIGoffsets();

        /* Is there a chance of other jumps becoming short? */

        assert((int)minx >= 0);

#ifdef  DEBUG
        if  (verbose) printf("Total shrinkage = %3u, min extra jump size = %3u\n", adjIG, minx);
#endif

        if  (minx <= adjIG)
        {
            jmp_iteration++;
            goto AGAIN;
        }
    }
}

/*****************************************************************************
 *
 *  Called at the end of code generation, this method creates the code, data
 *  and GC info blocks for the method.
 */

size_t              emitter::emitEndCodeGen(Compiler *comp,
                                            bool      contTrkPtrLcls,
                                            bool      fullyInt,
                                            bool      fullPtrMap,
                                            bool      returnsGCr,
                                            unsigned *prologSize,
                                            unsigned *epilogSize, void **codeAddr,
                                                                  void **consAddr,
                                                                  void **dataAddr)
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In emitEndCodeGen()\n");
#endif

    insGroup     *  ig;

    BYTE    *       consBlock;
    BYTE    *       dataBlock;
    BYTE    *       codeBlock;
    BYTE    *       cp;

#if EMIT_USE_LIT_POOLS
    litPool   *     curLP;
    insGroup  *     litIG;
#endif

//  if  (!emitIGbuffAddr) printf("Temp buffer never used\n");

#ifdef  DEBUG
    emitCodeBlock     = NULL;
    emitConsBlock     = NULL;
    emitDataBlock     = NULL;
    emitLastSrcLine   = 0;
#endif

    /* Tell everyone whether we have fully interruptible code or not */

#if TRACK_GC_REFS
    emitFullyInt   = fullyInt;
    emitFullGCinfo = fullPtrMap;
#endif

#if EMITTER_STATS
      GCrefsTable.histoRec(emitGCrFrameOffsCnt, 1);
    emitSizeTable.histoRec(emitSizeMethod     , 1);
#if TRACK_GC_REFS
    stkDepthTable.histoRec(emitMaxStackDepth  , 1);
#endif
#endif

#if TRACK_GC_REFS

    /* Convert max. stack depth from # of bytes to # of entries */

    emitMaxStackDepth /= sizeof(int);

    /* Should we use the simple stack */

    if  (emitMaxStackDepth <= MAX_SIMPLE_STK_DEPTH && !emitFullGCinfo)
    {
        emitSimpleStkUsed         = true;
        emitSimpleStkMask         = 0;
        emitSimpleByrefStkMask    = 0;
    }
    else
    {
        /* We won't use the "simple" argument table */

        emitSimpleStkUsed = false;

        /* Allocate the argument tracking table */

        if  (emitMaxStackDepth <= sizeof(emitArgTrackLcl))
            emitArgTrackTab = (BYTE*)emitArgTrackLcl;
        else
            emitArgTrackTab = (BYTE*)emitGetMem(roundUp(emitMaxStackDepth));

        emitArgTrackTop     = emitArgTrackTab;
        emitGcArgTrackCnt   = 0;
    }

#endif

    emitCheckIGoffsets();

    /* The following is a "nop" if literal pools aren't being used */

    emitEstimateLitPools();

    assert(emitHasHandler == 0);  // We should no longer be inside a try region

#if TGT_x86

    /* Do we have any epilogs at all? */

    if  (emitEpilogCnt)
    {
        /* Update all of the epilogs with the actual epilog size */

        if  (emitEpilogSize != MAX_EPILOG_SIZE)
        {
            assert(emitEpilogSize < MAX_EPILOG_SIZE);

            int             sizeAdj = MAX_EPILOG_SIZE - emitEpilogSize;
            insGroup    *   tempIG  = emitIGlist;
            size_t          offsIG  = 0;

            /* Start with the first epilog group */

            tempIG = emitEpilog1st; assert(tempIG->igFlags & IGF_EPILOG);
            offsIG = tempIG->igOffs;

            do
            {
                /* Assign a (possibly updated) offset to the block */

                tempIG->igOffs = offsIG;

                /* If this is an epilog block, adjust its size */

                if  (tempIG->igFlags & IGF_EPILOG)
                    tempIG->igSize -= sizeAdj;

                /* Update the offset and move on to the next block */

                offsIG += tempIG->igSize;
                tempIG  = tempIG->igNext;
            }
            while (tempIG);

            /* Update the total code size */

            emitCurCodeOffset = offsIG;

            emitCheckIGoffsets();
        }
    }
    else
    {
        /* No epilogs, make sure the epilog size is set to 0 */

        emitEpilogSize = emitExitSeqSize = 0;
    }

#endif

    /* The last code offset is the (estimated) total size of the method */

    emitTotalCodeSize = emitCurCodeOffset;

    /* Also return the size of the prolog/epilog to the caller */
    // *prologSize       = emitPrologSize; @TODO [CLEANUP]
    *epilogSize       = emitEpilogSize + emitExitSeqSize;

    /* Bind jump distances */

    emitJumpDistBind();

#ifdef BIRCH_SP2
    HRESULT hr;
#endif

#if     SMALL_DIRECT_CALLS

    /* Can we get the address of the method we're compiling? */

# ifdef BIRCH_SP2

    emitLPmethodAddr  = 0;
    hr = comp->getIJitInfo()->allocMem (  0,
                                          0,
                                          0,
                                          (void**) &emitLPmethodAddr,
                                          (void**) &consBlock,
                                          (void**) &dataBlock);
    if (FAILED (hr))
        NOMEM();

# else // not BIRCH_SP2


    assert(!"ToDo");
#  if 0
    emitLPmethodAddr = (BYTE*)emitComp->eeGetMethodEntryPoint(CT_USER_FUNC,
                                                              emitComp->compMethodHnd,
                                                              emitComp->info.compScopeHnd);
#  else
    emitLPmethodAddr = 0;
#  endif


#endif  // BIRCH_SP2

#endif  // SMALL_DIRECT_CALLS

    /* The following is a "nop" if indirect jumps aren't "special" */

    emitFinalizeIndJumps();

    /* The following is a "nop" if literal pools aren't being used */

    emitFinalizeLitPools();

#ifdef  DEBUG

    if  (0 && verbose)
    {
        printf("\nInstruction list before instruction issue:\n\n");
        emitDispIGlist(true);
    }

    emitCheckIGoffsets();

#endif


    /* Allocate the code block (and optionally the data blocks) */

#if EMIT_USE_LIT_POOLS
    assert(emitConsDsc.dsdOffs == 0);
    assert(emitDataDsc.dsdOffs == 0);
#endif

#ifdef BIRCH_SP2
    size_t askCodeSize = emitTotalCodeSize;
    askCodeSize = (askCodeSize + 7) & ~7;

    hr = comp->getIJitInfo()->allocMem (  askCodeSize,
                                          emitConsDsc.dsdOffs,
                                          emitDataDsc.dsdOffs,
                                          (void**) &codeBlock,
                                          (void**) &consBlock,
                                          (void**) &dataBlock);
    if (FAILED (hr))
        NO_MEM();

#if TGT_x86
    assert(askCodeSize >= 8);
    BYTE* nopPtr = ((BYTE*) codeBlock) + (askCodeSize - 8);

    for (int nopCnt=0; nopCnt < 8; nopCnt++)
        *nopPtr++ = 0xCC;       // INT 3 instruction
#endif

#else
    if  (!eeAllocMem(emitCmpHandle, emitTotalCodeSize,
                                    emitConsDsc.dsdOffs,
                                    emitDataDsc.dsdOffs,
                                    (const void**)&codeBlock,
                                    (const void**)&consBlock,
                                    (const void**)&dataBlock))
    {
        NOMEM();
    }
#endif  // BIRCH_SP2

//  if  (emitConsDsc.dsdOffs) printf("Cons=%08X\n", consBlock);
//  if  (emitDataDsc.dsdOffs) printf("Data=%08X\n", dataBlock);

    /* Give the block addresses to the caller and other functions here */

    *codeAddr = emitCodeBlock = codeBlock;
    *consAddr = emitConsBlock = consBlock;
    *dataAddr = emitDataBlock = dataBlock;

#if TGT_x86 && defined(RELOC_SUPPORT) && defined(BIRCH_SP2)
    emitConsBlock = getCurrentCodeAddr(NULL) + (consBlock - codeBlock);
#endif

#if SMALL_DIRECT_CALLS

    /* If we haven't done so already, ... */

    if  (!emitLPmethodAddr)
    {
        /* ... go try shrink calls that are direct and short */

        emitShrinkShortCalls();
    }
    else
    {
        /* Just make sure we had not been lied to earlier */

        assert(emitLPmethodAddr == codeBlock);
    }

#endif

    /* We have not encountered any source line numbers yet */

#ifdef  DEBUG
    emitLastSrcLine   = 0;
#endif

    /* Nothing has been pushed on the stack */

#if EMIT_TRACK_STACK_DEPTH
    emitCurStackLvl   = 0;
#endif

    /* Assume no live GC ref variables on entry */

#if TRACK_GC_REFS
    emitThisGCrefVars = 0;
    emitThisGCrefRegs =
    emitThisByrefRegs = 0;
    emitThisGCrefVset = true;

    /* Initialize the GC ref variable lifetime tracking logic */

    emitComp->gcVarPtrSetInit();
#endif

    emitThisArgOffs   = -1;     /* -1  means no offset set */
    emitSyncThisObjReg = SR_NA; /* SR_NA  means not set */

#if TRACK_GC_REFS

    if  (!emitComp->info.compIsStatic)
    {
        /* If "this" (which is passed in as a register argument in REG_ARG_0)
           is enregistered, we normally spot the "mov REG_ARG_0 -> thisReg"
           in the prolog and note the location of "this" at that point.
           However, if 'this' is enregistered into REG_ARG_0 itself, no code
           will be generated in the prolog, so we explicitly need to note
           the location of "this" here.
           NOTE that we can do this even if "this" is not enregistered in
           REG_ARG_0, and it will result in more accurate "this" info over the
           prolog. However, as methods are not interruptible over the prolog,
           we try to save space by avoiding that.
         */

        assert(emitComp->lvaIsThisArg(0));
        Compiler::LclVarDsc * thisDsc = &emitComp->lvaTable[0];

        if  (thisDsc->lvRegister && thisDsc->lvRegNum == REG_ARG_0 && (emitComp->rsCalleeRegArgMaskLiveIn & emitRegMask((emitRegs)REG_ARG_0)))
        {
            if  (emitFullGCinfo && thisDsc->TypeGet() != TYP_I_IMPL)
            {
                GCtype   gcType = (thisDsc->TypeGet() == TYP_REF) ? GCT_GCREF
                                                                  : GCT_BYREF;
                emitGCregLiveSet(gcType,
                                 emitRegMask((emitRegs)REG_ARG_0),
                                 emitCodeBlock, // from offset 0
                                 true);
            }
            else
            {
                /* If emitFullGCinfo==false, the we dont use any
                   regPtrDsc's and so explictly note the location
                   of "this" in GCEncode.cpp
                 */
            }
        }

        if (thisDsc->lvRegister && (emitComp->info.compFlags & CORINFO_FLG_SYNCH))
            emitSyncThisObjReg = emitRegs(thisDsc->lvRegNum);
    }

#endif

    emitContTrkPtrLcls = contTrkPtrLcls;

    /* Are there any GC ref variables on the stack? */

    if  (emitGCrFrameOffsCnt)
    {
        size_t              siz;
        unsigned            cnt;
        unsigned            num;
        Compiler::LclVarDsc*dsc;
        int         *       tab;

        /* Allocate and clear emitGCrFrameLiveTab[]. This is the table
           mapping "stkOffs -> varPtrDsc". It holds a pointer to
           the liveness descriptor that was created when the
           variable became alive. When the variable becomes dead, the
           descriptor will be appended to the liveness descriptor list, and
           the entry in emitGCrFrameLiveTab[] will be make NULL.

           Note that if all GC refs are assigned consecutively,
           emitGCrFrameLiveTab[] can be only as big as the number of GC refs
           present, instead of lvaTrackedCount;
         */

        siz = emitGCrFrameOffsCnt * sizeof(*emitGCrFrameLiveTab);
        emitGCrFrameLiveTab = (varPtrDsc**)emitGetMem(roundUp(siz));
        memset(emitGCrFrameLiveTab, 0, siz);

        /* Allocate and fill in emitGCrFrameOffsTab[]. This is the table
           mapping "varIndex -> stkOffs".
           Non-ptrs or reg vars have entries of -1.
           Entries of Tracked stack byrefs have the lower bit set to 1.
        */

        emitTrkVarCnt       = cnt = emitComp->lvaTrackedCount; assert(cnt);
        emitGCrFrameOffsTab = tab = (int*)emitGetMem(cnt * sizeof(int));

        memset(emitGCrFrameOffsTab, -1, cnt * sizeof(int));

        /* Now fill in all the actual used entries */

        for (num = 0, dsc = emitComp->lvaTable, cnt = emitComp->lvaCount;
             num < cnt;
             num++  , dsc++)
        {
            if  (!dsc->lvOnFrame || (dsc->lvIsParam && !dsc->lvIsRegArg))
                continue;

            int  offs = dsc->lvStkOffs;

            /* Is it within the interesting range of offsets */

            if  (offs >= emitGCrFrameOffsMin && offs < emitGCrFrameOffsMax)
            {
                /* Are tracked stack ptr locals laid out contiguously?
                   If not, skip non-ptrs. The emitter is optimized to work
                   with contiguous ptrs, but for EditNContinue, the variables
                   are laid out in the order they occur in the local-sig.
                 */

                if (!emitContTrkPtrLcls)
                {
                    if (! dsc->lvTracked ||
                        !(dsc->TypeGet() == TYP_REF ||
                          dsc->TypeGet() == TYP_BYREF))
                        continue;
                }

                unsigned        indx = dsc->lvVarIndex;

                assert(!dsc->lvRegister);
                assert( dsc->lvTracked);
                assert( dsc->lvRefCnt != 0);

                assert( dsc->TypeGet() == TYP_REF   ||
                        dsc->TypeGet() == TYP_BYREF);

                assert(indx < emitComp->lvaTrackedCount);

                // printf("Variable #%2u/%2u is at stack offset %d\n", num, indx, offs);
                /* Remember the frame offset of the "this" argument */
                if  (dsc->lvVerTypeInfo.IsThisPtr()) 
                {
                    emitThisArgOffs = offs;
                    offs |= this_OFFSET_FLAG;
                }
                if (dsc->TypeGet() == TYP_BYREF)
                {
                    offs |= byref_OFFSET_FLAG;
                }
                tab[indx] = offs;
            }
        }
    }
    else
    {
#ifdef  DEBUG
        emitTrkVarCnt       = 0;
        emitGCrFrameOffsTab = NULL;
#endif
    }

#ifdef  DEBUG
    if  (0 && verbose) 
    {
        printf("\n***************************************************************************\n");
        printf("Instructions as they come out of the scheduler\n\n");
    }
#endif

    /* Prepare for scheduling, if necessary */

    scPrepare();

#if EMIT_USE_LIT_POOLS
    curLP = emitLitPoolCur = emitLitPoolList;
    litIG = curLP ? curLP->lpIG : NULL;
#endif

    /* Issue all instruction groups in order */
    cp = codeBlock;

    for (ig = emitIGlist; ig; ig = ig->igNext)
    {        
        /* Are we overflowing */
        if (ig->igNext && ig->igNum + 1 != ig->igNext->igNum)
            NO_WAY("Too many instruction groups");
       
        instrDesc * id = (instrDesc *)ig->igData;

        BYTE      * bp = cp;

        /* Tell other methods which group we're issuing */

        emitCurIG = ig;

//      if  (Compiler::s_compMethodsCount == 12 && ig->igNum == 8) BreakIfDebuggerPresent();

#ifdef  DEBUG

        if  (dspEmit || verbose)
        {
            printf("\nG_M%03u_IG%02u:", Compiler::s_compMethodsCount, ig->igNum);
            printf("  ; offs=%06XH", ig->igOffs);
            if  (ig->igOffs != emitCurCodeOffs(cp))
                printf("/%06XH", cp - codeBlock);
            printf("\n");
        }

#endif

#if TGT_x86

        /* Record the actual offset of the block, noting the difference */

        emitOffsAdj  = ig->igOffs - emitCurCodeOffs(cp); assert(emitOffsAdj >= 0);
//      printf("Block predicted offs = %08X, actual = %08X -> size adj = %d\n", ig->igOffs, emitCurCodeOffs(cp), emitOffsAdj);
        ig->igOffs = emitCurCodeOffs(cp);

#else

        /* For RISC targets, the offset estimate must always be accurate */

#if SCHEDULER

        /* Unless we're scheduling, of course ... */

        if  (ig->igOffs != emitCurCodeOffs(cp))
        {
            assert(emitComp->opts.compSchedCode);

            /* Remember that some block offsets have changed */

            emitIGmoved = true;
        }

#else

        assert(ig->igOffs == emitCurCodeOffs(cp));

#endif

#endif

#if EMIT_TRACK_STACK_DEPTH

        /* Set the proper stack level if appropriate */

        if  (ig->igStkLvl != emitCurStackLvl)
        {
            /* We are pushing stuff implicitly at this label */

            assert((unsigned)ig->igStkLvl > (unsigned)emitCurStackLvl);
            emitStackPushN(cp, (ig->igStkLvl - (unsigned)emitCurStackLvl)/sizeof(int));
        }

#endif

#if TRACK_GC_REFS

        /* Is this IG "real" (not added implicitly by the emitter) ? */

        if (!(ig->igFlags & IGF_EMIT_ADD))
        {
            /* Is there a new set of live GC ref variables? */

            if  (ig->igFlags & IGF_GC_VARS)
                emitUpdateLiveGCvars(castto(id, VARSET_TP *)[-1], cp);
            else if (!emitThisGCrefVset)
                emitUpdateLiveGCvars(            emitThisGCrefVars, cp);

            /* Is there a new set of live GC ref registers? */

//          if  (ig->igFlags & IGF_GC_REGS)
            {
                unsigned        GCregs = ig->igGCregs;

                if  (GCregs != emitThisGCrefRegs)
                    emitUpdateLiveGCregs(GCT_GCREF, GCregs, cp);
            }

            /* Is there a new set of live byref registers? */

            if  (ig->igFlags & IGF_BYREF_REGS)
            {
                unsigned        byrefRegs = ig->igByrefRegs();

                if  (byrefRegs != emitThisByrefRegs)
                    emitUpdateLiveGCregs(GCT_BYREF, byrefRegs, cp);
            }
        }

#endif

#if SCHEDULER

        /* Should we try to schedule instructions in this group? */

        if  (emitComp->opts.compSchedCode && (ig->igInsCnt >= SCHED_INS_CNT_MIN)
             && emitCanSchedIG(ig))
        {
            /* We'll try to schedule instructions in this group */

            unsigned        cnt;

            int             fpLo, spLo;
            int             fpHi, spHi;

            instrDesc  *  * scInsPtr;

            /*
                If we are scheduling for a target with branch-delay slots
                present, we'll include the next jump and the all of the
                nop instructions that follow it in the scheduling group.

                When we save a branch-delay instruction, we set the bdCnt
                variable to the number of branch-delay slots; when this
                count reaches zero, we'll schedule the group. If we have
                not yet encountered a branch-delay instruction, we keep
                the bdCnt value negative so that it never goes to zero.
             */

#if MAX_BRANCH_DELAY_LEN
            unsigned        bdLen;
            int             bdCnt;
            #define         startBranchDelayCnt( ) bdCnt = -1, bdLen = 0
            #define         checkBranchDelayCnt(m) assert(bdCnt <= m)
#else
            #define         startBranchDelayCnt( )
            #define         checkBranchDelayCnt(m)
#endif

            /* Use the following macro to mark the scheduling table as empty */

            #define         clearSchedTable()                   \
                                                                \
                scInsPtr = scInsTab;                            \
                                                                \
                startBranchDelayCnt();                          \
                                                                \
                fpLo = spLo = INT_MAX;                          \
                fpHi = spHi = INT_MIN;

            /* Prepare to fill the instruction table */

            clearSchedTable();

            /* Walk through all of the instructions in the IG */

            for (cnt = ig->igInsCnt;
                 cnt;
                 cnt--, castto(id, BYTE *) += emitSizeOfInsDsc(id))
            {
                /* Is this a schedulable instruction? */

//              emitDispIns(id, false, false, false);

                if  (scIsSchedulable(id))
                {
                    /* The instruction looks schedulable */

#if MAX_BRANCH_DELAY_LEN

                    /* Have we just consumed an entire branch-delay section? */

                    if  (--bdCnt == 0)
                        goto NOT_SCHED;

                    /* Don't schedule nop's except as branch-delay slots */

                    if  (id->idIns == INS_nop && bdCnt < 0)
                        goto NOT_SCHED;

                    /* Don't schedule zapped instructions */

                    if  (id->idIns == INS_ignore)
                        continue;

                    /* Check for a jump/call instruction */

                    if  (scIsBranchIns(id->idIns))
                    {
                        /* This better not be a branch-delay slot */

                        assert(bdCnt <  0);
                        assert(bdLen == 0);

                        /* Get the number of branch-delay slots */

                        bdLen = Compiler::instBranchDelayL(id->idIns);

                        /* If there are no branch-delay slots, give up */

                        if  (!bdLen)
                            goto NOT_SCHED;

                        /*
                            Do we have enough instructions available to fill
                            the branch-delay slots, and do we have room for
                            them in the scheduling table?
                         */

                        if  (scInsPtr + bdLen >= scInsMax || bdLen >= cnt)
                        {
                            bdLen = 0;
                            goto NOT_SCHED;
                        }

                        /* Save and schedule the whole shebang */

                        bdCnt = bdLen + 1;
                    }
#ifdef DEBUG
                    else if (bdCnt > 0)
                    {
                        /* In a branch-delay section; this better be a nop */

                        assert(id->idIns == INS_nop);
                    }
#endif

#endif

                    /* Is there room in the schedule table? */

                    if  (scInsPtr == scInsMax)
                    {
                        /* Schedule and issue the instructions in the table */

                        checkBranchDelayCnt(0);

                        scGroup(ig, id, &cp, scInsTab,
                                             scInsPtr, fpLo, fpHi,
                                                       spLo, spHi, bdLen);

                        /* The table is now empty */

                        clearSchedTable();
                    }

#if     0
#ifdef  DEBUG
                    emitDispIns(id, false, false, false); printf("Append sched instr #%02u to table.\n", scInsPtr - scInsTab);
#endif
#endif

                    assert(scInsPtr < scInsTab + emitMaxIGscdCnt);

                    *scInsPtr++ = id;

                    /* Does this instruction reference the stack? */

                    if  (scInsSchedOpInfo(id) & IS_SF_RW)
                    {
                        int         ofs;
                        size_t      osz;
                        bool        fpb;

                        /* Keep track of min. and max. frame offsets */

                        ofs = scGetFrameOpInfo(id, &osz, &fpb);

                        if  (fpb)
                        {
                            if  (fpLo > (int)(ofs    )) fpLo = ofs;
                            if  (fpHi < (int)(ofs+osz)) fpHi = ofs+osz;
                        }
                        else
                        {
                            if  (spLo > (int)(ofs    )) spLo = ofs;
                            if  (spHi < (int)(ofs+osz)) spHi = ofs+osz;
                        }
                    }

                    continue;
                }

#if MAX_BRANCH_DELAY_LEN
            NOT_SCHED:
#endif

                /* Instruction is not schedulable; is the table non-empty? */

                if  (scInsPtr != scInsTab)
                {
                    /* Schedule and issue the instructions in the table */

                    checkBranchDelayCnt(0);

                    scGroup(ig, id, &cp, scInsTab,
                                         scInsPtr, fpLo, fpHi,
                                                   spLo, spHi, bdLen);

                    /* The table is now empty */

                    clearSchedTable();
                }

                /* Issue the non-schedulable instruction itself */

                emitIssue1Instr(ig, id, &cp);
            }

            /* Is the table non-empty? */

            if  (scInsPtr != scInsTab)
            {
                /* Issue whatever has been accumulated in the table */

                checkBranchDelayCnt(1);

                scGroup(ig, NULL, &cp, scInsTab,
                                       scInsPtr, fpLo, fpHi,
                                                 spLo, spHi, bdLen);
            }

            assert(ig->igSize >= cp - bp);
                   ig->igSize  = cp - bp;
        }
        else
#endif
        {
            /* Issue each instruction in order */

            for (unsigned cnt = ig->igInsCnt; cnt; cnt--)
            {

#if TGT_RISC && !TGT_ARM

                /* Are the next 2 instructions to be swapped? */

                if  (id->idSwap)
                {
                    instrDesc   *   i1;
                    instrDesc   *   i2;
                    size_t          s2;

                    assert(cnt >= 2);

                    /* Get hold of the 2 instructions */

                    i1 = id;
                    i2 = (instrDesc*)((BYTE*)id + emitSizeOfInsDsc(id));

                    /* Output the instruction in reverse order */

                    s2 = emitIssue1Instr(ig, i2, &cp);
                         emitIssue1Instr(ig, i1, &cp);

                    /* We've consumed 2 instructions, one more than for-loop expects */

                    cnt--;

                    /* Skip over the second instruction */

                    id = (instrDesc*)((BYTE*)i2 + s2);
                }
                else    // don't put out a solo if we just did a pair
#endif
                {
                    castto(id, BYTE *) += emitIssue1Instr(ig, id, &cp);
                }
            }

            assert(ig->igSize >= cp - bp);
                   ig->igSize  = cp - bp;
        }

#if EMIT_USE_LIT_POOLS

        /* Is the current literal pool supposed to go after this group? */

        if  (ig == litIG)
        {
            /* Output the contents of the literal pool */

            cp = emitOutputLitPool(curLP, cp);

            /* Move to the next literal pool, if any */

            curLP = emitLitPoolCur = curLP->lpNext;
            litIG = curLP ? curLP->lpIG : NULL;
        }

#endif

    }

#if EMIT_TRACK_STACK_DEPTH
    assert(emitCurStackLvl == 0);
#endif

    /* Output any initialized data we may have */

    if  (emitConsDsc.dsdOffs) emitOutputDataSec(&emitConsDsc, codeBlock, consBlock);
    if  (emitDataDsc.dsdOffs) emitOutputDataSec(&emitDataDsc, codeBlock, dataBlock);

#if TRACK_GC_REFS

    /* Make sure all GC ref variables are marked as dead */

    if  (emitGCrFrameOffsCnt)
    {
        unsigned        vn;
        int             of;
        varPtrDsc   * * dp;

        for (vn = 0, of  = emitGCrFrameOffsMin, dp = emitGCrFrameLiveTab;
             vn < emitGCrFrameOffsCnt;
             vn++  , of += sizeof(void*)    , dp++)
        {
            if  (*dp)
                emitGCvarDeadSet(of, cp, vn);
        }
    }

    /* No GC registers are live any more */

    if  (emitThisByrefRegs)
        emitUpdateLiveGCregs(GCT_BYREF, 0, cp);  // ISSUE: What if ptr returned in EAX?
    if  (emitThisGCrefRegs)
        emitUpdateLiveGCregs(GCT_GCREF, 0, cp);  // ISSUE: What if ptr returned in EAX?

#endif

#if TGT_RISC && SCHEDULER

    /* If all block offsets were correctly estimated, no jmp patching needed */

    if  (!emitIGmoved)
        emitFwdJumps = false;

#endif

#if TGT_x86 || SCHEDULER

    /* Patch any forward jumps */

    if  (emitFwdJumps)
    {
        instrDescJmp *  jmp;

        for (jmp = emitJumpList; jmp; jmp = jmp->idjNext)
        {
            insGroup    *   tgt;

#if TGT_MIPS32
            if ((IF_JR_R == jmp->idInsFmt) || (IF_JR == jmp->idInsFmt))
                continue;       // skip this calculation not relevant to indirect jumps

            assert( (jmp->idInsFmt == IF_LABEL) ||
                    (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O));
#else
            assert(jmp->idInsFmt == IF_LABEL);
#endif
            tgt = jmp->idAddr.iiaIGlabel;

            if  (!jmp->idjTemp.idjAddr)
                continue;

            if  (jmp->idjOffs != tgt->igOffs)
            {
                BYTE    *       adr = jmp->idjTemp.idjAddr;
                int             adj = jmp->idjOffs - tgt->igOffs;

#if     TGT_x86

#ifdef  DEBUG
                if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
                {
                    if  (INTERESTING_JUMP_NUM == 0)
                        printf("[5] Jump %u:\n", jmp->idNum);

                    if  (jmp->idjShort)
                    {
                        printf("[5] Jump        is at %08X\n"              , (adr + 1 - emitCodeBlock));
                        printf("[5] Jump distance is  %02X - %02X = %02X\n", *(BYTE *)adr, adj, *(BYTE *)adr - adj);
                    }
                    else
                    {
                        printf("[5] Jump        is at %08X\n"              , (adr + 4 - emitCodeBlock));
                        printf("[5] Jump distance is  %08X - %02X = %08X\n", *(int  *)adr, adj, *(int  *)adr - adj);
                    }
                }
#endif

                if  (jmp->idjShort)
                {
                    *(BYTE *)adr -= adj;
//                  printf("; Updated jump distance = %04XH\n", *(BYTE *)adr);
                }
                else
                {
                    *(int  *)adr -= adj;
//                  printf("; Updated jump distance = %08XH\n", *(int *)adr);
#ifdef  DEBUG
//                  if  (*(int*)adr <= JMP_DIST_SMALL_MAX_POS)
//                      printf("STUPID forward jump %08X / %03u: %u = %u - (%d)\n", jmp, jmp->idNum, *(int *)adr, *(int *)adr+adj, -adj);
#endif
                }

#else

                /* Check the size of the jump and adjust the distance value */

                if  (jmp->idjShort)
                {
                    *(USHORT*)adr -= adj;
                }
                else
                {
                    assert(!"need to patch RISC non-short fwd jump distance");
                }

#endif

            }
        }
    }

#endif

#ifdef  DEBUG
    if (disAsm) printf("\n");
#endif

//  printf("Allocated method code size = %4u , actual size = %4u\n", emitTotalCodeSize, cp - codeBlock);

#if EMITTER_STATS
    totAllocdSize += emitTotalCodeSize;
    totActualSize += cp - codeBlock;
#endif


    // Assign the real prolog size
    *prologSize       = emitPrologIG->igNext->igOffs;

    /* Return the amount of code we've generated */

    return  cp - codeBlock;
}

/*****************************************************************************
 *
 *  We've been asked for the code offset of an instruction but alas one or
 *  more instruction sizes in the block have been mis-predicted, so we have
 *  to find the true offset by looking for the instruction within the group.
 */

size_t              emitter::emitFindOffset(insGroup *ig, unsigned insNum)
{
    instrDesc *     id = (instrDesc *)ig->igData;
    unsigned        of = 0;

    /* Make sure we were passed reasonable arguments */

#ifdef DEBUG
    assert(ig && ig->igSelf == ig);
    assert(ig->igInsCnt >= insNum);
#endif

    /* Walk the instruction list until all are counted */

    while (insNum)
    {
        of += emitInstCodeSz(id);

        castto(id, BYTE *) += emitSizeOfInsDsc(id);

        insNum--;
    }

    return  of;
}

/*****************************************************************************
 *
 *  Start generating a constant or read/write data section for the current
 *  function. Returns the offset of the section in the appropriate data
 *  block.
 */

unsigned            emitter::emitDataGenBeg(size_t size,
                                            bool dblAlign,
                                            bool readOnly,
                                            bool codeLtab)
{
    unsigned        secOffs;
    dataSection *   secDesc;

    assert(emitDataDscCur == 0);
    assert(emitDataSecCur == 0);

    /* The size better not be some kind of an odd thing */

    assert(size && size % sizeof(int) == 0);

    /* Figure out which section to use */

    emitDataDscCur = readOnly ? &emitConsDsc : &emitDataDsc;

    /* Get hold of the current offset */

    secOffs = emitDataDscCur->dsdOffs;

    /* Are we require to align this request on an eight byte boundry? */
    if (dblAlign && (secOffs % sizeof(double) != 0))
    {
        emitDataDscCur = 0;

        /* Need to skip 4 bytes to honor dblAlign */
        /* Must allocate a dummy 4 byte integer */
        int zero = 0;
        emitDataGenBeg(4, false, readOnly, false);
        emitDataGenData(0, &zero, 4);
        emitDataGenEnd();

        emitDataDscCur = readOnly ? &emitConsDsc : &emitDataDsc;

        /* Get the new secOffs */
        secOffs = emitDataDscCur->dsdOffs;
        /* Now it should be a multiple of 8 */
        assert(secOffs % sizeof(double) == 0);
    }

    /* Advance the current offset */

    emitDataDscCur->dsdOffs += size;

    /* Allocate a data section descriptor and add it to the list */

    secDesc = emitDataSecCur = (dataSection *)emitGetMem(roundUp(sizeof(*secDesc) + size));

    secDesc->dsSize = size | (int)codeLtab;
    secDesc->dsNext = 0;

    if  (emitDataDscCur->dsdLast)
        emitDataDscCur->dsdLast->dsNext = secDesc;
    else
        emitDataDscCur->dsdList         = secDesc;
    emitDataDscCur->dsdLast = secDesc;

    /* Set the low bit if the value is a constant */

    assert((secOffs & 1) == 0);
    assert(readOnly == 0 || readOnly == 1);

    return  secOffs + readOnly;
}

/*****************************************************************************
 *
 *  Emit the given block of bits into the current data section.
 */

void                emitter::emitDataGenData(unsigned    offs,
                                             const void *data,
                                             size_t      size)
{
    assert(emitDataDscCur);
    assert(emitDataSecCur && (emitDataSecCur->dsSize >= offs + size)
                          && (emitDataSecCur->dsSize & 1) == 0);

    memcpy(emitDataSecCur->dsCont + offs, data, size);
}

/*****************************************************************************
 *
 *  Emit the address of the given basic block into the current data section.
 */

void                emitter::emitDataGenData(unsigned offs,
                                             BasicBlock *label)
{
    assert(emitDataDscCur == &emitConsDsc);
    assert(emitDataSecCur != 0);
    assert(emitDataSecCur && (emitDataSecCur->dsSize >= offs + sizeof(void*))
                          && (emitDataSecCur->dsSize & 1) != 0);

    *(BasicBlock **)(emitDataSecCur->dsCont + offs) = label;
}

/*****************************************************************************
 *
 *  We're done generating a data section.
 */

void                emitter::emitDataGenEnd()
{

#ifdef DEBUG
    assert(emitDataSecCur); emitDataSecCur = 0;
    assert(emitDataDscCur); emitDataDscCur = 0;
#endif

}

/*****************************************************************************
 *
 *  Output the given data section at the specified address.
 */

void                emitter::emitOutputDataSec(dataSecDsc *sec, BYTE *cbp, BYTE *dst)
{
    dataSection *   dsc;

#ifdef  DEBUG
    BYTE    *       dsb = dst;
#endif

#if TGT_x86 && defined(OPT_IL_JIT) && defined(BIRCH_SP2)
    cbp = getCurrentCodeAddr(NULL);
#endif

    assert(dst);
    assert(sec->dsdOffs);
    assert(sec->dsdList);

    /* Walk and emit the contents of all the data blocks */

    for (dsc = sec->dsdList; dsc; dsc = dsc->dsNext)
    {
        size_t          siz = dsc->dsSize;

        /* Is this a label table? */

        if  (siz & 1)
        {
            BasicBlock  * * bbp = (BasicBlock**)dsc->dsCont;

            siz -= 1;
            assert(siz && siz % sizeof(void *) == 0);
            siz /= sizeof(void*);

            /* Output the label table (it's stored as "BasicBlock*" values) */

            do
            {
                insGroup    *   lab;

                /* Convert the BasicBlock* value to an IG address */

                lab = (insGroup*)emitCodeGetCookie(*bbp++); assert(lab);

                /* Append the appropriate address to the destination */

                *castto(dst, BYTE**)++ = cbp + lab->igOffs;
#ifdef RELOC_SUPPORT
                emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
#endif
            }
            while (--siz);
        }
        else
        {
            /* Simple binary data: copy the bytes to the target */

            memcpy(dst, dsc->dsCont, siz);
                   dst       +=      siz;
        }
    }

#ifdef DEBUG
    assert(dst == dsb + sec->dsdOffs);
#endif
}

/*****************************************************************************/
#if     TRACK_GC_REFS
/*****************************************************************************
 *
 *  Record the fact that the given variable now contains a live GC ref.
 */

void                emitter::emitGCvarLiveSet(int       offs,
                                              GCtype    gcType,
                                              BYTE *    addr,
                                              int       disp)
{
    varPtrDsc   *   desc;

    assert((abs(offs) % sizeof(int)) == 0);
    assert(needsGC(gcType));

    /* Compute the index into the GC frame table if the caller didn't do it */

    if  (disp == -1)
        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);

    assert((unsigned)disp < emitGCrFrameOffsCnt);

    /* Allocate a lifetime record */

    desc = (varPtrDsc *)emitComp->compGetMem(sizeof(*desc));

    desc->vpdBegOfs = emitCurCodeOffs(addr);
#ifdef DEBUG
    desc->vpdEndOfs = 0xFACEDEAD;
#endif

    desc->vpdVarNum = offs;

    /* the lower 2 bits encode props about the stk ptr */

    if  (offs == emitThisArgOffs)
    {
        desc->vpdVarNum |= this_OFFSET_FLAG;
    }

    if  (gcType == GCT_BYREF)
    {
        desc->vpdVarNum |= byref_OFFSET_FLAG;
    }

    /* Append the new entry to the end of the list */

    desc->vpdPrev   = emitComp->gcVarPtrLast;
                      emitComp->gcVarPtrLast->vpdNext = desc;
                      emitComp->gcVarPtrLast          = desc;

    /* Record the variable descriptor in the table */

    assert(emitGCrFrameLiveTab[disp] == NULL);
           emitGCrFrameLiveTab[disp]  = desc;

#ifdef  DEBUG
    if  (VERBOSE)
    {
        printf("[%08X] %s var born at [%s", desc, GCtypeStr(gcType), emitEBPframe ? "EBP" : "ESP");

        if      (offs < 0)
            printf("-%02XH", -offs);
        else if (offs > 0)
            printf("+%02XH", +offs);

        printf("]\n");
    }
#endif

    /* The "global" live GC variable mask is no longer up-to-date */

    emitThisGCrefVset = false;
}

/*****************************************************************************
 *
 *  Record the fact that the given variable no longer contains a live GC ref.
 */

void                emitter::emitGCvarDeadSet(int offs, BYTE *addr, int disp)
{
    varPtrDsc   *   desc;

    assert(abs(offs) % sizeof(int) == 0);

    /* Compute the index into the GC frame table if the caller didn't do it */

    if  (disp == -1)
        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);

    assert((unsigned)disp < emitGCrFrameOffsCnt);

    /* Get hold of the lifetime descriptor and clear the entry */

    desc = emitGCrFrameLiveTab[disp];
           emitGCrFrameLiveTab[disp] = NULL;

    assert( desc);
    assert((desc->vpdVarNum & ~OFFSET_MASK) == (unsigned)offs);

    /* Record the death code offset */

    assert(desc->vpdEndOfs == 0xFACEDEAD);
           desc->vpdEndOfs  = emitCurCodeOffs(addr);

#ifdef  DEBUG
    if  (VERBOSE)
    {
        GCtype  gcType = (desc->vpdVarNum & byref_OFFSET_FLAG) ? GCT_BYREF : GCT_GCREF;
        bool    isThis = (desc->vpdVarNum & this_OFFSET_FLAG) != 0;

        printf("[%08X] %s%s var died at [%s",
               desc,
               GCtypeStr(gcType),
               isThis       ? "this-ptr" : "",
               emitEBPframe ? "EBP"      : "ESP");

        if      (offs < 0)
            printf("-%02XH", -offs);
        else if (offs > 0)
            printf("+%02XH", +offs);

        printf("]\n");
    }
#endif

    /* The "global" live GC variable mask is no longer up-to-date */

    emitThisGCrefVset = false;
}

/*****************************************************************************
 *
 *  Record a new set of live GC ref variables.
 */

void                emitter::emitUpdateLiveGCvars(VARSET_TP vars, BYTE *addr)
{
    /* Is the current set accurate and unchanged? */

    if  (emitThisGCrefVset && emitThisGCrefVars == vars)
        return;

#ifdef  DEBUG
    if  (VERBOSE) printf("New GC ref live vars=%016I64X\n", vars);
#endif

    emitThisGCrefVars = vars;

    /* Are there any GC ref variables on the stack? */

    if  (emitGCrFrameOffsCnt)
    {
        int     *       tab;
        unsigned        cnt = emitTrkVarCnt;
        unsigned        num;

        /* Test all the tracked variable bits in the mask */

        for (num = 0, tab = emitGCrFrameOffsTab;
             num < cnt;
             num++  , tab++)
        {
            int         val = *tab;

            if  (val != -1)
            {
                // byref_OFFSET_FLAG and this_OFFSET_FLAG are set
                //  in the table-offsets for byrefs and this-ptr

                int     offs = val & ~OFFSET_MASK;

//              printf("var #%2u at %3d is now %s\n", num, offs, (vars & 1) ? "live" : "dead");

                if  (vars & 1)
                {
                    GCtype  gcType = (val & byref_OFFSET_FLAG) ? GCT_BYREF
                                                               : GCT_GCREF;
                    emitGCvarLiveUpd(offs, INT_MAX, gcType, addr);
                }
                else
                {
                    emitGCvarDeadUpd(offs,         addr);
                }
            }

            vars >>= 1;
        }
    }

    emitThisGCrefVset = true;
}

/*****************************************************************************/

inline
unsigned            getU4(const BYTE * ptr)
{
#ifdef _X86_
    return * (unsigned *) ptr;
#else
    return ptr[0] + ptr[1]<<8 + ptr[2]<<16 + ptr[3]<<24;
#endif
}

/*****************************************************************************
 *
 *  Record a call location for GC purposes (we know that this is a method that
 *  will not be fully interruptible).
 */

void                emitter::emitRecordGCcall(BYTE * codePos)
{
    assert(!emitFullGCinfo);

    unsigned        offs = emitCurCodeOffs(codePos);
    unsigned        regs = (emitThisGCrefRegs|emitThisByrefRegs) & ~SRM_INTRET;
    callDsc     *   call;

    /* Bail if this is a totally boring call */

    if  (regs == 0)
    {
#if EMIT_TRACK_STACK_DEPTH
        if  (emitCurStackLvl == 0)
            return;
#endif
        /* Nope, only interesting calls get recorded */

        if  (emitSimpleStkUsed)
        {
            if  (!emitSimpleStkMask)
                return;
        }
        else
        {
            if (emitGcArgTrackCnt == 0)
                return;
        }
    }

#ifdef  DEBUG

    if  (VERBOSE||(disAsm&&0))
    {
        printf("; Call at %04X[stk=%u] gcrefRegs [", offs, emitCurStackLvl);
        emitDispRegSet(emitThisGCrefRegs & ~SRM_INTRET, true);
        printf(" byrefRegs [");
        emitDispRegSet(emitThisByrefRegs & ~SRM_INTRET, true);
        printf("] GCvars: ");
        emitDispVarSet();
        printf("\n");
    }

#endif

    /* Allocate a 'call site' descriptor and start filling it in */

    call = (callDsc *)emitComp->compGetMem(sizeof(*call));

    call->cdBlock         = NULL;
    call->cdOffs          = offs;

    call->cdGCrefRegs     = emitThisGCrefRegs;
    call->cdByrefRegs     = emitThisByrefRegs;
#if EMIT_TRACK_STACK_DEPTH
    call->cdArgBaseOffset = emitCurStackLvl / sizeof(int);
#endif

    /* Append the call descriptor to the list */

    emitComp->gcCallDescLast->cdNext = call;
    emitComp->gcCallDescLast         = call;

    /* Record the current "pending" argument list */

    if  (emitSimpleStkUsed)
    {
        /* The biggest call is less than MAX_SIMPLE_STK_DEPTH. So use
           small format */

        call->cdArgMask         = emitSimpleStkMask;
        call->cdByrefArgMask    = emitSimpleByrefStkMask;
        call->cdArgCnt          = 0;
    }
    else
    {
        // @TODO [CONSIDER] [04/16/01] []:
        //           If the number of pending arguments at this call-site
        //           is less than MAX_SIMPLE_STK_DEPTH, we could still
        //           use the mask.

        /* The current call has too many arguments, so we need to report the
           offsets of each individual GC arg. */

        call->cdArgCnt      = emitGcArgTrackCnt;
        if (call->cdArgCnt == 0)
        {
            call->cdArgMask         =
            call->cdByrefArgMask    = 0;
            return;
        }

        call->cdArgTable    = (unsigned *)emitComp->compGetMemArray(emitGcArgTrackCnt, sizeof(unsigned));

        unsigned gcArgs = 0;
        unsigned stkLvl = emitCurStackLvl/sizeof(int);

        for (unsigned i = 0; i < stkLvl; i++)
        {
            GCtype  gcType = (GCtype)emitArgTrackTab[stkLvl-i-1];

            if (needsGC(gcType))
            {
                call->cdArgTable[gcArgs] = i * sizeof(void*);

                if (gcType == GCT_BYREF)
                {
                    call->cdArgTable[gcArgs] |= byref_OFFSET_FLAG;
                }

                gcArgs++;
            }
        }

        assert(gcArgs == emitGcArgTrackCnt);
    }

    return;
}

/*****************************************************************************
 *
 *  Record a new set of live GC ref registers.
 */

void                emitter::emitUpdateLiveGCregs(GCtype    gcType,
                                                  unsigned  regs,
                                                  BYTE *    addr)
{
    unsigned        life;
    unsigned        dead;
    unsigned        chg;

//  printf("New GC ref live regs=%04X [", regs); emitDispRegSet(regs); printf("]\n");

    assert(needsGC(gcType));

    unsigned & emitThisXXrefRegs = (gcType == GCT_GCREF) ? emitThisGCrefRegs
                                                         : emitThisByrefRegs;
    unsigned & emitThisYYrefRegs = (gcType == GCT_GCREF) ? emitThisByrefRegs
                                                         : emitThisGCrefRegs;
    assert(emitThisXXrefRegs != regs);

    if  (emitFullGCinfo)
    {
        /* Figure out which GC registers are becoming live/dead at this point */

        dead = ( emitThisXXrefRegs & ~regs);
        life = (~emitThisXXrefRegs &  regs);

        /* Can't simultaneously become live and dead at the same time */

        assert((dead | life) != 0);
        assert((dead & life) == 0);

        /* Compute the 'changing state' mask */

        chg = (dead | life);

        do
        {
            unsigned            bit = genFindLowestBit(chg);
            emitRegs           reg = emitRegNumFromMask(bit);

            if  (life & bit)
                emitGCregLiveUpd(gcType, reg, addr);
            else
                emitGCregDeadUpd(reg, addr);

            chg -= bit;
        }
        while (chg);

        assert(emitThisXXrefRegs == regs);
    }
    else
    {
        emitThisYYrefRegs &= ~regs; // Kill the regs from the other GC type (if live)

        emitThisXXrefRegs =   regs; // Mark them as live in the requested GC type
    }

    // The 2 GC reg masks cant be overlapping

    assert((emitThisGCrefRegs & emitThisByrefRegs) == 0);
}

/*****************************************************************************
 *
 *  Record the fact that the given register now contains a live GC ref.
 */

void                emitter::emitGCregLiveSet(GCtype    gcType,
                                              unsigned  regMask,
                                              BYTE *    addr,
                                              bool      isThis)
{
    assert(needsGC(gcType));

    regPtrDsc  *    regPtrNext;

//  assert(emitFullyInt || isThis);
    assert(emitFullGCinfo);

    assert(((emitThisGCrefRegs|emitThisByrefRegs) & regMask) == 0);

    /* Allocate a new regptr entry and fill it in */

    regPtrNext                     = emitComp->gcRegPtrAllocDsc();
    regPtrNext->rpdGCtype          = gcType;

    regPtrNext->rpdOffs            = emitCurCodeOffs(addr);
    regPtrNext->rpdArg             = FALSE;
    regPtrNext->rpdCall            = FALSE;
    regPtrNext->rpdIsThis          = isThis;
    regPtrNext->rpdCompiler.rpdAdd = regMask;
    regPtrNext->rpdCompiler.rpdDel = 0;
}

/*****************************************************************************
 *
 *  Record the fact that the given register no longer contains a live GC ref.
 */

void                emitter::emitGCregDeadSet(GCtype    gcType,
                                              unsigned  regMask,
                                              BYTE *    addr)
{
    assert(needsGC(gcType));

    regPtrDsc  *    regPtrNext;

//  assert(emitFullyInt);
    assert(emitFullGCinfo);

    assert(((emitThisGCrefRegs|emitThisByrefRegs) & regMask) != 0);

    /* Allocate a new regptr entry and fill it in */

    regPtrNext                     = emitComp->gcRegPtrAllocDsc();
    regPtrNext->rpdGCtype          = gcType;

    regPtrNext->rpdOffs            = emitCurCodeOffs(addr);
    regPtrNext->rpdCall            = FALSE;
    regPtrNext->rpdIsThis          = FALSE;
    regPtrNext->rpdArg             = FALSE;
    regPtrNext->rpdCompiler.rpdAdd = 0;
    regPtrNext->rpdCompiler.rpdDel = regMask;
}

/*****************************************************************************/
#if EMIT_TRACK_STACK_DEPTH
/*****************************************************************************
 *
 *  Record a push of a single word on the stack for a full pointer map.
 */

void                emitter::emitStackPushLargeStk (BYTE *    addr,
                                                    GCtype    gcType,
                                                    unsigned  count)
{
    unsigned        level = emitCurStackLvl / sizeof(int);

    assert(IsValidGCtype(gcType));
    assert(count);
    assert(!emitSimpleStkUsed);

    do
    {
        /* Push an entry for this argument on the tracking stack */

//      printf("Pushed [%d] at lvl %2u [max=%u]\n", isGCref, emitArgTrackTop - emitArgTrackTab, emitMaxStackDepth);

        assert(emitArgTrackTop == emitArgTrackTab + level);
              *emitArgTrackTop++ = (BYTE)gcType;
        assert(emitArgTrackTop <= emitArgTrackTab + emitMaxStackDepth);

        if (!emitEBPframe || needsGC(gcType))
        {
            if  (emitFullGCinfo)
            {
                /* Append an "arg push" entry if this is a GC ref or
                   FPO method. Allocate a new ptr arg entry and fill it in */

                regPtrDsc  * regPtrNext = emitComp->gcRegPtrAllocDsc();
                regPtrNext->rpdGCtype   = gcType;

                regPtrNext->rpdOffs     = emitCurCodeOffs(addr);
                regPtrNext->rpdArg      = TRUE;
                regPtrNext->rpdCall     = FALSE;
                regPtrNext->rpdPtrArg   = level;
                regPtrNext->rpdArgType  = (unsigned short)Compiler::rpdARG_PUSH;
                regPtrNext->rpdIsThis   = FALSE;

#ifdef  DEBUG
                if  (0 && verbose) printf(" %08X  %s arg push %u\n",
                                        regPtrNext, GCtypeStr(gcType), level);
#endif
            }

            /* This is an "interesting" argument push */

            emitGcArgTrackCnt++;
        }
    }
    while (++level, --count);
}

/*****************************************************************************
 *
 *  Record a pop of the given number of words from the stack for a full ptr
 *  map.
 */

void                emitter::emitStackPopLargeStk(BYTE *    addr,
                                                  bool      isCall,
                                                  unsigned  count)
{
    unsigned        argStkCnt;
    unsigned        argRecCnt;  // arg count for ESP, ptr-arg count for EBP
    unsigned        gcrefRegs, byrefRegs;

    assert(!emitSimpleStkUsed);

    /* Count how many pointer records correspond to this "pop" */

    for (argStkCnt = count, argRecCnt = 0;
         argStkCnt;
         argStkCnt--)
    {
        assert(emitArgTrackTop > emitArgTrackTab);

        GCtype      gcType = (GCtype)(*--emitArgTrackTop);

        assert(IsValidGCtype(gcType));

//      printf("Popped [%d] at lvl %u\n", GCtypeStr(gcType), emitArgTrackTop - emitArgTrackTab);

        // This is an "interesting" argument

        if  (!emitEBPframe || needsGC(gcType))
            argRecCnt++;
    }

    assert(emitArgTrackTop >= emitArgTrackTab);
    assert(emitArgTrackTop == emitArgTrackTab + emitCurStackLvl / sizeof(int) - count);

    /* We're about to pop the corresponding arg records */

    emitGcArgTrackCnt -= argRecCnt;

    if (!emitFullGCinfo)
        return;

    /* Do we have any interesting registers live here? */

    gcrefRegs =
    byrefRegs = 0;

#if TGT_x86
    if  (emitThisGCrefRegs & RBM_EDI) gcrefRegs |= 0x01;
    if  (emitThisGCrefRegs & RBM_ESI) gcrefRegs |= 0x02;
    if  (emitThisGCrefRegs & RBM_EBX) gcrefRegs |= 0x04;
    if  (emitThisGCrefRegs & RBM_EBP) gcrefRegs |= 0x08;

    if  (emitThisByrefRegs & RBM_EDI) byrefRegs |= 0x01;
    if  (emitThisByrefRegs & RBM_ESI) byrefRegs |= 0x02;
    if  (emitThisByrefRegs & RBM_EBX) byrefRegs |= 0x04;
    if  (emitThisByrefRegs & RBM_EBP) byrefRegs |= 0x08;
#else
    assert(!"need non-x86 code");
#endif

    /* Are there any args to pop at this call site? */

    if  (argRecCnt == 0)
    {
        /*
            Or do we have a partially interruptible EBP-less frame, and any
            of EDI,ESI,EBX,EBP are live, or is there an outer/pending call?
         */

#if !FPO_INTERRUPTIBLE
        if  (emitFullyInt ||
             (gcrefRegs == 0 && byrefRegs == 0 && emitGcArgTrackCnt == 0))
#endif
            return;
    }

    /* Only calls may pop more than one value */

    if  (argRecCnt > 1)
        isCall = true;

    /* Allocate a new ptr arg entry and fill it in */

    regPtrDsc * regPtrNext      = emitComp->gcRegPtrAllocDsc();
    regPtrNext->rpdGCtype       = GCT_GCREF; // Pops need a non-0 value (??)

    regPtrNext->rpdOffs         = emitCurCodeOffs(addr);
    regPtrNext->rpdCall         = isCall;
    regPtrNext->rpdCallGCrefRegs= gcrefRegs;
    regPtrNext->rpdCallByrefRegs= byrefRegs;
    regPtrNext->rpdArg          = TRUE;
    regPtrNext->rpdArgType      = (unsigned short)Compiler::rpdARG_POP;
    regPtrNext->rpdPtrArg       = argRecCnt;

#ifdef  DEBUG
    if  (0 && verbose) printf(" %08X  ptr arg pop  %u\n", regPtrNext, count);
#endif

}


/*****************************************************************************
 *  For caller-pop arguments, we report the arguments as pending arguments.
 *  However, any GC arguments are now dead, so we need to report them
 *  as non-GC.
 */

void            emitter::emitStackKillArgs(BYTE *addr, unsigned   count)
{
    assert(count > 0);

    if (emitSimpleStkUsed)
    {
        assert(!emitFullGCinfo); // Simple stk not used for emitFullGCInfo

        /* We dont need to report this to the GC info, but we do need
           to kill mark the ptrs on the stack as non-GC */

        assert(emitCurStackLvl/sizeof(int) >= count);

        for(unsigned lvl = 0; lvl < count; lvl++)
        {
            emitSimpleStkMask      &= ~(1 << lvl);
            emitSimpleByrefStkMask &= ~(1 << lvl);
        }
    }
    else
    {
        BYTE *          argTrackTop = emitArgTrackTop;
        unsigned        gcCnt = 0;

        for (unsigned i = 0; i < count; i++)
        {
            assert(argTrackTop > emitArgTrackTab);

            --argTrackTop;

            GCtype      gcType = (GCtype)(*argTrackTop);
            assert(IsValidGCtype(gcType));

            if (needsGC(gcType))
            {
//              printf("Killed %s at lvl %u\n", GCtypeStr(gcType), argTrackTop - emitArgTrackTab);

                *argTrackTop = GCT_NONE;
                gcCnt++;
            }
        }

        /* We're about to kill the corresponding (pointer) arg records */

        if (emitEBPframe)
            emitGcArgTrackCnt -= gcCnt;

        if (!emitFullGCinfo)
            return;

        /* Right after the call, the arguements are still sitting on the
           stack, but they are effectively dead. For fully-interruptible
           methods, we need to report that */

        if (emitFullGCinfo && gcCnt)
        {
            /* Allocate a new ptr arg entry and fill it in */

            regPtrDsc * regPtrNext      = emitComp->gcRegPtrAllocDsc();
            regPtrNext->rpdGCtype       = GCT_GCREF; // Kills need a non-0 value (??)

            regPtrNext->rpdOffs         = emitCurCodeOffs(addr);

            regPtrNext->rpdArg          = TRUE;
            regPtrNext->rpdArgType      = (unsigned short)Compiler::rpdARG_KILL;
            regPtrNext->rpdPtrArg       = gcCnt;

#ifdef  DEBUG
            if  (0 && verbose) printf(" %08X  ptr arg kill %u\n", regPtrNext, count);
#endif
        }

        /* Now that ptr args have been marked as non-ptrs, we need to record
           the call itself as one that has no arguments. */

        emitStackPopLargeStk(addr, true, 0);
    }
}

/*****************************************************************************/
#endif//EMIT_TRACK_STACK_DEPTH
/*****************************************************************************/
#endif//TRACK_GC_REFS
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\ee_il_dll.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
class CILJit: public ICorJitCompiler

{
    CorJitResult __stdcall compileMethod (
            ICorJitInfo*       comp,                   /* IN */
            CORINFO_METHOD_INFO*methodInfo,             /* IN */
            unsigned        flags,                  /* IN */
            BYTE **         nativeEntry,            /* OUT */
            ULONG *         nativeSizeOfCode        /* OUT */
            );
};

inline void eeSetEHcount (
                    COMP_HANDLE   compHandle,
                    unsigned      cEH)
{
    HRESULT res = ((ICorJitInfo*) compHandle)->setEHcount(cEH);
    if (!SUCCEEDED(res))
        NOMEM();
}


inline void eeSetEHinfo (
                    COMP_HANDLE   compHandle,
                    unsigned EHnumber,
                    const CORINFO_EH_CLAUSE*  ehInfo)
{
    ((ICorJitInfo*) compHandle)->setEHinfo(EHnumber, ehInfo);
}

inline BOOL   eeAllocMem (
                    COMP_HANDLE   compHandle,
                    size_t        codeSize,
                    size_t        roDataSize,
                    size_t        rwDataSize,
                    const void ** codeBlock,
                    const void ** roDataBlock,
                    const void ** rwDataBlock)
{
    HRESULT res = ((ICorJitInfo*) compHandle)->allocMem(codeSize, roDataSize, rwDataSize,
                                             (void**) codeBlock, (void**) roDataBlock, (void**) rwDataBlock);

    return(SUCCEEDED(res));
}

inline void * eeAllocGCInfo (
                    COMP_HANDLE   compHandle,
                    size_t        blockSize)
{
    void* ret;
    HRESULT res = ((ICorJitInfo*) compHandle)->allocGCInfo(blockSize, &ret);
    if (!SUCCEEDED(res)) ret = 0;
    return(ret);
}

inline PVOID eeGetHelperFtn(
                    COMP_HANDLE                 compHandle,
                    CorInfoHelpFunc              hlpFunc,
                    PVOID *                    *ppIndir)
{
    return ((ICorJitInfo*) compHandle)->getHelperFtn(hlpFunc, (void**)ppIndir);
}


inline void Compiler::eeInit()
{
}

/*****************************************************************************
 *
 *              Functions to get various handles
 */

inline
CORINFO_CLASS_HANDLE        Compiler::eeFindClass    (unsigned       clsTok,
                                              CORINFO_MODULE_HANDLE   scope,
                                              CORINFO_METHOD_HANDLE  context,
                                              bool           giveUp)
{
    CORINFO_CLASS_HANDLE cls = info.compCompHnd->findClass(scope, clsTok, context);

    if (cls == 0 && giveUp)
    {
#ifdef DEBUG
        eeUnresolvedMDToken (scope, clsTok, "eeFindClass");
#else
        NO_WAY("could not obtain class handle (class not found?)");
#endif
    }

    return(cls);
}

inline
CORINFO_METHOD_HANDLE       Compiler::eeFindMethod   (unsigned       methodTok,
                                              CORINFO_MODULE_HANDLE   scope,
                                              CORINFO_METHOD_HANDLE  context,
                                              bool           giveUp)
{
    CORINFO_METHOD_HANDLE method = info.compCompHnd->findMethod(scope, methodTok, context);

    if (method == 0 && giveUp)
    {
#ifdef DEBUG
        eeUnresolvedMDToken (scope, methodTok, "eeFindMethod");
#else
        NO_WAY("could not obtain method handle (class not found?)");
#endif
    }

    /* insure there is no collision between helper functions and EE method tokens */
    assert(!method || eeGetHelperNum(method) == CORINFO_HELP_UNDEF);

    return(method);
}

inline
CORINFO_CLASS_HANDLE Compiler::eeGetMethodClass (
                    CORINFO_METHOD_HANDLE  methodHandle)
{
    CORINFO_CLASS_HANDLE cls = info.compCompHnd->getMethodClass(methodHandle);
    assert(cls != 0);
    return(cls);
}

inline
CORINFO_FIELD_HANDLE         Compiler::eeFindField(unsigned         fieldTok,
                                           CORINFO_MODULE_HANDLE    scope,
                                           CORINFO_METHOD_HANDLE    context,
                                           bool                     giveUp)
{
    CORINFO_FIELD_HANDLE field = info.compCompHnd->findField(scope, fieldTok, context);

    if (field == 0 && giveUp)
    {
#ifdef DEBUG
        eeUnresolvedMDToken (scope, fieldTok, "eeFindField");
#else
        NO_WAY("could not obtain field handle (class not found?)");
#endif
    }

    /* insure there is no collision between local jit data offsets and EE method tokens */
    assert(!field || eeGetJitDataOffs(field) < 0);

    return(field);
}

inline
CORINFO_CLASS_HANDLE        Compiler::eeGetFieldClass  (CORINFO_FIELD_HANDLE       hnd)
{
    CORINFO_CLASS_HANDLE cls = info.compCompHnd->getFieldClass(hnd);
    assert(cls != 0);
    return(cls);
}

inline
unsigned            Compiler::eeGetStringHandle(unsigned        strTok,
                                                CORINFO_MODULE_HANDLE    scope,
                                                unsigned *     *ppIndir)
{
    unsigned val = (unsigned) info.compCompHnd->constructStringLiteral(
                                                scope,
                                                strTok,
                                                (void**)ppIndir);

    if (!val && !*ppIndir)
        NO_WAY("Could not get string handle");

    return val;
}

inline
void *              Compiler::embedGenericHandle(unsigned       metaTok,
                                                 CORINFO_MODULE_HANDLE   scope,
                                                 CORINFO_METHOD_HANDLE  context,
                                                 void         **ppIndir,
                                                 CORINFO_CLASS_HANDLE& tokenType,
                                                 bool           giveUp)
{
    void * hnd = (void*)info.compCompHnd->embedGenericHandle(scope, metaTok,
                                                            context, ppIndir,tokenType);
    if (!hnd && !*ppIndir && giveUp)
        NO_WAY("Could not get generic handle");

    return hnd;
}

/*****************************************************************************
 *
 *                  Functions to get flags
 */
inline
unsigned            Compiler::eeGetClassAttribs   (CORINFO_CLASS_HANDLE   hnd)
{
    // all classes can use direct!
    return(info.compCompHnd->getClassAttribs(hnd, info.compMethodHnd));
}

inline
unsigned            Compiler::eeGetFieldAttribs  (CORINFO_FIELD_HANDLE   hnd,
                                                  CORINFO_ACCESS_FLAGS   flags)
{
    unsigned attribs = info.compCompHnd->getFieldAttribs(hnd, info.compMethodHnd, flags);

    return attribs;
}

inline
unsigned Compiler::eeGetMethodAttribs (CORINFO_METHOD_HANDLE    methodHandle)
{
    return(info.compCompHnd->getMethodAttribs(methodHandle, info.compMethodHnd));
}

inline
void     Compiler::eeSetMethodAttribs (CORINFO_METHOD_HANDLE    methodHandle,
                                       unsigned         attr)
{
    info.compCompHnd->setMethodAttribs(methodHandle, attr);
}

inline
void* Compiler::eeGetMethodSync (CORINFO_METHOD_HANDLE  methodHandle,
                                 void **       *ppIndir)
{
    return(info.compCompHnd->getMethodSync(methodHandle, (void**)ppIndir));
}

/*****************************************************************************
 *
 *          VOS info, method sigs, etc
 */

inline
bool                Compiler::eeCanPutField      (CORINFO_FIELD_HANDLE  fieldHnd,
                                                  unsigned      flags,
                                                  CORINFO_CLASS_HANDLE  cls,            // TODO remove this parameter
                                                  CORINFO_METHOD_HANDLE method)
{
    return(info.compCompHnd->canPutField(method, fieldHnd) != 0);
}


inline
void    *           Compiler::eeFindPointer      (CORINFO_MODULE_HANDLE   scope,
                                                  unsigned       ptrTok,
                                                  bool           giveUp)
{
    void* ret = info.compCompHnd->findPtr(scope, ptrTok);

    if (ret == 0 && giveUp)
        NO_WAY("could not obtain string token");

    return(ret);
}

inline
void               Compiler::eeGetSig           (unsigned       sigTok,
                                                 CORINFO_MODULE_HANDLE   scope,
                                                 CORINFO_SIG_INFO*  retSig,
                                                 bool               giveUp)
{
    info.compCompHnd->findSig(scope, sigTok, retSig);

    if (giveUp &&
        varTypeIsComposite(JITtype2varType(retSig->retType)) &&
        retSig->retTypeClass == NULL)
    {
        NO_WAY("Could not get Sig");
    }
}

inline
void               Compiler::eeGetMethodSig      (CORINFO_METHOD_HANDLE  methHnd,
                                                  CORINFO_SIG_INFO*      sigRet,
                                                  bool                   giveUp)
{
    info.compCompHnd->getMethodSig(methHnd, sigRet);

    if (giveUp &&
        varTypeIsComposite(JITtype2varType(sigRet->retType)) &&
        sigRet->retTypeClass == NULL)
    {
        NO_WAY("Could not get MethodSig");
    }
}

/*****************************************************************************/
inline
CORINFO_MODULE_HANDLE Compiler::eeGetMethodScope (CORINFO_METHOD_HANDLE  hnd)
{
    return(info.compCompHnd->getClassModule(info.compCompHnd->getMethodClass(hnd)));
}

/**********************************************************************
 * For varargs we need the number of arguments at the call site
 */

inline
void                Compiler::eeGetCallSiteSig     (unsigned       sigTok,
                                                    CORINFO_MODULE_HANDLE   scope,
                                                    CORINFO_SIG_INFO*  sigRet,
                                                    bool                giveUp)
{
    info.compCompHnd->findCallSiteSig(scope, sigTok, sigRet);

    if (giveUp &&
        varTypeIsComposite(JITtype2varType(sigRet->retType)) &&
        sigRet->retTypeClass == NULL)
    {
        NO_WAY("Could not find CallSiteSig");
    }
}

inline
unsigned            Compiler::eeGetMethodVTableOffset(CORINFO_METHOD_HANDLE methHnd)
{
    return(info.compCompHnd->getMethodVTableOffset(methHnd));
}


inline
unsigned            Compiler::eeGetInterfaceID   (CORINFO_CLASS_HANDLE clsHnd, unsigned * *ppIndir)
{
    return((unsigned) info.compCompHnd->getInterfaceTableOffset(clsHnd, (void**)ppIndir));
}

inline
void    *            Compiler::eeGetHintPtr     (CORINFO_METHOD_HANDLE  methHnd,
                                                 void **       *ppIndir)
{
    return(info.compCompHnd->AllocHintPointer(methHnd, (void**)ppIndir));
}

inline
BOOL                Compiler::eeIsOurMethod     (CORINFO_METHOD_HANDLE methHnd)
{
    return(0);  // to be safe, always answer NO
}

inline
int                 Compiler::eeGetNewHelper(CORINFO_CLASS_HANDLE   newCls, CORINFO_METHOD_HANDLE context)
{
    return (info.compCompHnd->getNewHelper(newCls, context));
}

inline
int                  Compiler::eeGetIsTypeHelper   (CORINFO_CLASS_HANDLE   newCls)
{
    return (info.compCompHnd->getIsInstanceOfHelper(newCls));
}

inline
int                  Compiler::eeGetChkCastHelper  (CORINFO_CLASS_HANDLE   newCls)
{
    return (info.compCompHnd->getChkCastHelper(newCls));
}

inline
CORINFO_CLASS_HANDLE Compiler::eeGetBuiltinClass   (CorInfoClassId         classId) const
{
    return (info.compCompHnd->getBuiltinClass(classId));
}

inline
var_types            Compiler::eeGetFieldType (CORINFO_FIELD_HANDLE   handle, CORINFO_CLASS_HANDLE* structType)

{
        // FIX: can we get rid of the explicit conversion?
#ifdef DEBUG
    if (structType != 0)
        *structType = BAD_CLASS_HANDLE;
#endif
    return(JITtype2varType(info.compCompHnd->getFieldType(handle, structType)));
}

inline
unsigned             Compiler::eeGetFieldOffset   (CORINFO_FIELD_HANDLE   handle)
{
    return(info.compCompHnd->getFieldOffset(handle));
}

inline
unsigned            Compiler::eeGetClassSize   (CORINFO_CLASS_HANDLE   hnd)
{
    assert(hnd != BAD_CLASS_HANDLE);
    unsigned result = info.compCompHnd->getClassSize(hnd);
    return result;
}

inline
unsigned             Compiler::eeGetClassGClayout (CORINFO_CLASS_HANDLE   hnd, BYTE* gcPtrs)
{
    assert(hnd != BAD_CLASS_HANDLE);

    return info.compCompHnd->getClassGClayout(hnd, gcPtrs);
}

inline      
unsigned            Compiler::eeGetClassNumInstanceFields (CORINFO_CLASS_HANDLE   hnd)
{
    assert(hnd != BAD_CLASS_HANDLE);

    return info.compCompHnd->getClassNumInstanceFields(hnd);
}

inline      
unsigned            Compiler::eeGetFieldNumber (CORINFO_FIELD_HANDLE   hnd)
{
    return info.compCompHnd->getFieldNumber(hnd);
}

/*****************************************************************************/
inline
CORINFO_ARG_LIST_HANDLE     Compiler::eeGetArgNext        (CORINFO_ARG_LIST_HANDLE list)
{
    return(info.compCompHnd->getArgNext(list));
}

/*****************************************************************************/
inline
var_types           Compiler::eeGetArgType        (CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO* sig)
{
    CORINFO_CLASS_HANDLE        argClass;
    return(JITtype2varType(strip(info.compCompHnd->getArgType(sig, list, &argClass))));

}

/*****************************************************************************/
inline
var_types           Compiler::eeGetArgType        (CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO* sig, bool* isPinned)
{
    CORINFO_CLASS_HANDLE        argClass;
    CorInfoTypeWithMod type = info.compCompHnd->getArgType(sig, list, &argClass);
    *isPinned = ((type & ~CORINFO_TYPE_MASK) != 0);
    return JITtype2varType(strip(type));
}

inline
CORINFO_CLASS_HANDLE        Compiler::eeGetArgClass       (CORINFO_ARG_LIST_HANDLE list, CORINFO_SIG_INFO * sig)
{
    CORINFO_CLASS_HANDLE cls;
    cls = info.compCompHnd->getArgClass(sig, list);

    if (!cls)
        NO_WAY("Could not figure out Class specified in argument or local signature");

    return cls;
}

/*****************************************************************************
 *
 *                  Method entry-points, body information
 */

inline
void    *       Compiler::eeGetMethodPointer(CORINFO_METHOD_HANDLE   methHnd,
                                             InfoAccessType *        pAccessType,
                                             CORINFO_ACCESS_FLAGS    flags)
{
    if (!eeIsNativeMethod(methHnd))
    {
        return(info.compCompHnd->getFunctionFixedEntryPoint(methHnd, pAccessType, flags));
    }
    else
    {
        void * addr, **pAddr;
        addr = info.compCompHnd->getPInvokeUnmanagedTarget(
                                    eeGetMethodHandleForNative(methHnd), (void**)&pAddr);
        assert((!addr) != (!pAddr));
        if (addr)
        {
            *pAccessType = IAT_VALUE;
            return addr;
        }
        else
        {
            *pAccessType = IAT_PVALUE;
            return (void*)pAddr;
        }
    }
}

inline
void    *           Compiler::eeGetMethodEntryPoint(CORINFO_METHOD_HANDLE   methHnd,
                                                    InfoAccessType *        pAccessType,
                                                    CORINFO_ACCESS_FLAGS    flags)
{
    if (!eeIsNativeMethod(methHnd))
    {
        return(info.compCompHnd->getFunctionEntryPoint(methHnd, pAccessType, flags));
    }
    else
    {
        void * addr, **pAddr;
        addr = info.compCompHnd->getAddressOfPInvokeFixup(
                                    eeGetMethodHandleForNative(methHnd), (void**)&pAddr);
        assert((!addr) != (!pAddr));
        if (addr)
        {
            *pAccessType = IAT_PVALUE;
            return addr;
        }
        else
        {
            *pAccessType = IAT_PPVALUE;
            return (void*)pAddr;
        }
    }
}

inline
bool                 Compiler::eeGetMethodInfo  (CORINFO_METHOD_HANDLE  method,
                                                 CORINFO_METHOD_INFO* methInfo)
{
    return(info.compCompHnd->getMethodInfo(method, methInfo));
}

inline
CorInfoInline        Compiler::eeCanInline (CORINFO_METHOD_HANDLE  callerHnd,
                                            CORINFO_METHOD_HANDLE  calleeHnd,
                                            CORINFO_ACCESS_FLAGS   flags)
{
    return(info.compCompHnd->canInline(callerHnd, calleeHnd, flags));
}

inline
bool                 Compiler::eeCanTailCall (CORINFO_METHOD_HANDLE  callerHnd,
                                              CORINFO_METHOD_HANDLE  calleeHnd,
                                              CORINFO_ACCESS_FLAGS   flags)
{
    return(info.compCompHnd->canTailCall(callerHnd, calleeHnd, flags));
}

inline
void    *            Compiler::eeGetFieldAddress (CORINFO_FIELD_HANDLE   handle,
                                                  void **       *ppIndir)
{
    return(info.compCompHnd->getFieldAddress(handle, (void**)ppIndir));
}

inline
unsigned             Compiler::eeGetFieldThreadLocalStoreID (
                                                  CORINFO_FIELD_HANDLE   handle,
                                                  void **       *ppIndir)
{
    return((unsigned)info.compCompHnd->getFieldThreadLocalStoreID(handle, (void**)ppIndir));
}

inline
void                 Compiler::eeGetEHinfo      (unsigned       EHnum,
                                                 CORINFO_EH_CLAUSE* clause)

{
    info.compCompHnd->getEHinfo(info.compMethodHnd, EHnum, clause);
    return;
}

#ifdef PROFILER_SUPPORT
inline
CORINFO_PROFILING_HANDLE    Compiler::eeGetProfilingHandle(CORINFO_METHOD_HANDLE        method,
                                                           BOOL *                       pbHookFunction,
                                                           CORINFO_PROFILING_HANDLE **  ppIndir)
{
    return (info.compCompHnd->GetProfilingHandle(method, pbHookFunction, (void**)ppIndir));
}

#endif

/*****************************************************************************
 *
 *                  Native Direct Optimizations
 */

        // return the unmanaged calling convention for a PInvoke
inline
CorInfoUnmanagedCallConv  Compiler::eeGetUnmanagedCallConv(CORINFO_METHOD_HANDLE method)
{
    return info.compCompHnd->getUnmanagedCallConv(method);
}

        // return if any marshaling is required for PInvoke methods
inline
BOOL                 Compiler::eeNDMarshalingRequired(CORINFO_METHOD_HANDLE method,
                                                      CORINFO_SIG_INFO* sig)
{
    return info.compCompHnd->pInvokeMarshalingRequired(method, sig);
}


inline
CORINFO_EE_INFO *Compiler::eeGetEEInfo()
{
    static CORINFO_EE_INFO eeInfo;
    static bool initialized = false;

    if (!initialized)
    {
        info.compCompHnd->getEEInfo(&eeInfo);
        initialized = true;
    }

    return &eeInfo;
}

inline
DWORD                 Compiler::eeGetThreadTLSIndex(DWORD * *ppIndir)
{
    return info.compCompHnd->getThreadTLSIndex((void**)ppIndir);
}

inline
const void *        Compiler::eeGetInlinedCallFrameVptr(const void ** *ppIndir)
{
    return info.compCompHnd->getInlinedCallFrameVptr((void**)ppIndir);
}

inline
LONG *              Compiler::eeGetAddrOfCaptureThreadGlobal(LONG ** *ppIndir)
{
    return info.compCompHnd->getAddrOfCaptureThreadGlobal((void**)ppIndir);
}

/*****************************************************************************
 *
 *                  Debugging support - Local var info
 */

inline
void FASTCALL       Compiler::eeSetLVcount  (unsigned      count)
{
    eeVarsCount = count;
    if (eeVarsCount)
        eeVars = (VarResultInfo *)info.compCompHnd->allocateArray(eeVarsCount * sizeof(eeVars[0]));
    else
        eeVars = NULL;
}

inline
void                Compiler::eeSetLVinfo
                                (unsigned               which,
                                 unsigned                   startOffs,
                                 unsigned                   length,
                                 unsigned                   varNum,
                                 unsigned                   LVnum,
                                 lvdNAME                    name,
                                 bool                       avail,
                                 const Compiler::siVarLoc & varLoc)
{
    // ICorDebugInfo::VarLoc and Compiler::siVarLoc have to overlap
    // This is checked in siInit()

    assert(eeVarsCount);
    assert(which < eeVarsCount);
    eeVars[which].startOffset   = startOffs;
    eeVars[which].endOffset     = startOffs + length;
    eeVars[which].varNumber     = varNum;
    eeVars[which].loc           = varLoc;

#ifdef DEBUG
    if (verbose)
    {
        if (varNum == ICorDebugInfo::VARARGS_HANDLE)
            name = "varargsHandle";

        printf("%3d(%10s) : From %08Xh to %08Xh, %s in ",varNum,
                                                    lvdNAMEstr(name),
                                                    startOffs,
                                                    startOffs+length,
                                                    avail ? "  is" : "isnt");
        switch(varLoc.vlType)
        {
        case VLT_REG:       printf("%s",        getRegName(varLoc.vlReg.vlrReg));
                            break;
        case VLT_STK:       printf("%s[%d]",    getRegName(varLoc.vlStk.vlsBaseReg),
                                                varLoc.vlStk.vlsOffset);
                            break;
        case VLT_REG_REG:   printf("%s-%s",     getRegName(varLoc.vlRegReg.vlrrReg1),
                                                getRegName(varLoc.vlRegReg.vlrrReg2));
                            break;
        case VLT_REG_STK:   printf("%s-%s[%d]", getRegName(varLoc.vlRegStk.vlrsReg),
                                                getRegName(varLoc.vlRegStk.vlrsStk.vlrssBaseReg),
                                                varLoc.vlRegStk.vlrsStk.vlrssOffset);
                            break;
        case VLT_STK2:      printf("%s[%d-%d]", getRegName(varLoc.vlStk2.vls2BaseReg),
                                                varLoc.vlStk2.vls2Offset,
                                                varLoc.vlStk2.vls2Offset + sizeof(int));
                            break;
        case VLT_FPSTK:     printf("ST(L-%d)",  varLoc.vlFPstk.vlfReg);
                            break;
        case VLT_FIXED_VA:  printf("fxd_va[%d]", varLoc.vlFixedVarArg.vlfvOffset);
                            break;
        }

        printf("\n");
    }
#endif
}

inline
void                Compiler::eeSetLVdone()
{
    // necessary but not sufficient condition that the 2 struct definitions overlap
    assert(sizeof(eeVars[0]) == sizeof(ICorDebugInfo::NativeVarInfo));

    info.compCompHnd->setVars(info.compMethodHnd,
                              eeVarsCount,
                              (ICorDebugInfo::NativeVarInfo *) eeVars);

    eeVars = NULL; // We give up ownership after setVars()
}

/*****************************************************************************
 *
 *                  Debugging support - Line number info
 */

inline
void FASTCALL       Compiler::eeSetLIcount   (unsigned       count)
{
    eeBoundariesCount = count;
    if (eeBoundariesCount)
        eeBoundaries = (boundariesDsc *) info.compCompHnd->allocateArray(eeBoundariesCount * sizeof(eeBoundaries[0]));
    else
        eeBoundaries = NULL;
}

inline
void FASTCALL       Compiler::eeSetLIinfo  (unsigned       which,
                                            NATIVE_IP      nativeOffset,
                                            IL_OFFSET      ilOffset,
                                            bool           stkEmpty)
{
    assert(eeBoundariesCount && which<eeBoundariesCount);
    eeBoundaries[which].nativeIP = nativeOffset;
    eeBoundaries[which].ilOffset = ilOffset;
    eeBoundaries[which].sourceReason = stkEmpty ? ICorDebugInfo::STACK_EMPTY : 0;
}

inline
void                Compiler::eeSetLIdone()
{
#ifdef DEBUG
    if (verbose)
    {
        printf("IP mapping count : %d\n", eeBoundariesCount);
        for(unsigned i = 0; i < eeBoundariesCount; i++)
        {
            printf("IL offs ");

            const char * specialOffs[] = { "EPLG", "PRLG", "UNMP" };

            IL_OFFSET ilOffset = eeBoundaries[i].ilOffset;

            switch(ilOffset)
            {
            case ICorDebugInfo::MappingTypes::EPILOG:
            case ICorDebugInfo::MappingTypes::PROLOG:
            case ICorDebugInfo::MappingTypes::NO_MAPPING:
                assert(DWORD(ICorDebugInfo::MappingTypes::EPILOG) + 1 == ICorDebugInfo::MappingTypes::PROLOG);
                assert(DWORD(ICorDebugInfo::MappingTypes::EPILOG) + 2 == ICorDebugInfo::MappingTypes::NO_MAPPING);
                int specialOffsNum;
                specialOffsNum = ilOffset - DWORD(ICorDebugInfo::MappingTypes::EPILOG);
                printf("%s", specialOffs[specialOffsNum]);
                break;
            default:
                printf("%03Xh", ilOffset);
            }

            bool stackEmpty = !(eeBoundaries[i].sourceReason & ICorDebugInfo::STACK_EMPTY);
            printf(" : %08Xh (stack %s)\n", eeBoundaries[i].nativeIP,
                                            stackEmpty ? "empty" : "non-empty");
        }
        printf("\n");
    }
#endif

    // necessary but not sufficient condition that the 2 struct definitions overlap
    assert(sizeof(eeBoundaries[0]) == sizeof(ICorDebugInfo::OffsetMapping));

    info.compCompHnd->setBoundaries(info.compMethodHnd,
                                    eeBoundariesCount,
                                    (ICorDebugInfo::OffsetMapping *) eeBoundaries);

    eeBoundaries = NULL; // we give up ownership after setBoundaries();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitdef.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITDEF_H_
#define _EMITDEF_H_
/*****************************************************************************/

#if     TGT_x86

#include "emitX86.h"

#else

#include "emitRISC.h"

#if     TGT_SH3
#include "emitSH3.h"
#elif     TGT_MIPS32
#include "emitMIPS.h"
#elif     TGT_ARM
#include "emitARM.h"
#elif     TGT_PPC
#include "emitPPC.h"
#else
#error Unexpected target
#endif

#endif

/*****************************************************************************/
#endif//_EMITDEF_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitsh3.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /************************************************************************/
    /*               Private helpers for instruction output                 */
    /************************************************************************/

    /************************************************************************/
    /*           The public entry points to output instructions             */
    /************************************************************************/

public:

    void            emitIns_A_R    (emitRegs     reg,
                                    unsigned    offs);

protected:

    void            emitIns_IMOV   (insFormats  fmt,
                                    emitRegs    dreg,
                                    emitRegs    areg,
                                    bool        autox,
                                    int         size, 
                                    bool        isfloat = false);

public:

/*

  void            emitIns_I      (instruction ins,
                                    int         val
#ifdef  DEBUG
                                  , bool        strlit = false
#endif
                                   );
*/
    void            emitIns_R      (instruction ins,
                                    int         size,
                                    emitRegs    reg);

    void            emitIns_C      (instruction ins,
                                    int         size,
                                    int         CPX,
                                    void *      CLS,
                                    int         offs);

    void            emitIns_R_R    (instruction ins,
                                    int         size,
                                    emitRegs    reg1,
                                    emitRegs    reg2);

    void            emitIns_S      (instruction ins,
                                    int         size,
                                    int         varx,
                                    int         offs);

    void            emitIns_S_R    (instruction ins,
                                    int         size,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_R_S    (instruction ins,
                                    int         size,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_R_I    (instruction ins,
                                    int         size,
                                    emitRegs    reg,
                                    int         val);

#if EMIT_USE_LIT_POOLS

    void            emitIns_R_LP_I (emitRegs    reg,
                                    int         size,
                                    int         val,
                                    int         relo_type = 0);

#if!INLINING
#define scAddIns_R_LP_V(r,m,s)  scAddIns_R_LP_V(r,m)
#endif

    void            emitIns_R_LP_V (emitRegs    reg,
                                    void    *   mem);

    void            emitIns_R_LP_M (emitRegs    reg,
                                    gtCallTypes callType,
                                    void   *    callHand);
    
#ifdef BIRCH_SP2
    void            emitIns_R_LP_P (emitRegs    reg,
                                    void   *    data,
                                    int         relo_type = 0);
#endif // BIRCH_SP2

#endif // EMIT_USE_LIT_POOLS

    void            emitIns_IR     (emitRegs     reg,
                                    instruction ins,
                                    bool        autox,
                                    int         size);

    void            emitIns_Ig    ( instruction ins,
                                    int         val,
                                    int         size);

    void            emitIns_IR_R   (emitRegs    dreg,
                                    emitRegs    areg,
                                    bool        autox,
                                    int         size,
                                    bool        isfloat);

    void            emitIns_R_IR   (emitRegs    dreg,
                                    emitRegs    areg,
                                    bool        autox,
                                    int         size,
                                    bool        isfloat);

protected:

    void            emitIns_X0MV   (insFormats  fmt,
                                    emitRegs    dreg,
                                    emitRegs    areg,
                                    int         size);

public:

    void            emitIns_R_XR0  (emitRegs    dreg,
                                    emitRegs    areg,
                                    int         size);

    void            emitIns_XR0_R  (emitRegs    areg,
                                    emitRegs    dreg,
                                    int         size);

    void            emitIns_I_GBR_R(int         size);
    void            emitIns_R_I_GBR(int         size);

protected:

    void            emitIns_RDMV   (insFormats  fmt,
                                    emitRegs    dreg,
                                    emitRegs    areg,
                                    int         offs,
                                    int         size);

public:

    void            emitIns_R_RD   (emitRegs    dreg,
                                    emitRegs    areg,
                                    int         offs,
                                    int         size);

    void            emitIns_RD_R   (emitRegs     areg,
                                    emitRegs     dreg,
                                    int         offs,
                                    int         size);

    int all_jumps_shortened;

    void            delete_id      (instrDesc *id);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitfmts.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
#ifdef  DEFINE_ID_OPS
//////////////////////////////////////////////////////////////////////////////

#undef  DEFINE_ID_OPS

enum    ID_OPS
{
    ID_OP_NONE,                             // no additional arguments
    ID_OP_CNS,                              // constant     operand
    ID_OP_DSP,                              // displacement operand
    ID_OP_AMD,                              // addrmode dsp operand
    ID_OP_DC,                               // displacement + constant
    ID_OP_AC,                               // addrmode dsp + constant
    ID_OP_JMP,                              // local jump
    ID_OP_REG,                              // register     operand
    ID_OP_SCNS,                             // small const  operand
    ID_OP_CALL,                             // direct method call
    ID_OP_SPEC,                             // special handling required
};

//////////////////////////////////////////////////////////////////////////////
#else
//////////////////////////////////////////////////////////////////////////////
#ifdef  DEFINE_IS_OPS
#undef  DEFINE_IS_OPS

#define IS_NONE     0

#define IS_R1_SHF   0
#define IS_R1_RD    (1<<(IS_R1_SHF  ))      // register1 read
#define IS_R1_WR    (1<<(IS_R1_SHF+1))      // register1 write
#define IS_R1_RW    (IS_R1_RD|IS_R1_WR)

#define IS_R2_SHF   2
#define IS_R2_RD    (1<<(IS_R2_SHF  ))      // register2 read
#define IS_R2_WR    (1<<(IS_R2_SHF+1))      // register2 write
#define IS_R2_RW    (IS_R2_RD|IS_R2_WR)

#define IS_SF_SHF   4
#define IS_SF_RD    (1<<(IS_SF_SHF  ))      // stk frame read
#define IS_SF_WR    (1<<(IS_SF_SHF+1))      // stk frame write
#define IS_SF_RW    (IS_SF_RD|IS_SF_WR)

#define IS_GM_SHF   6
#define IS_GM_RD    (1<<(IS_GM_SHF  ))      // glob mem  read
#define IS_GM_WR    (1<<(IS_GM_SHF+1))      // glob mem  write
#define IS_GM_RW    (IS_GM_RD|IS_GM_WR)

#if TGT_x86

#define IS_AM_SHF   8
#define IS_AM_RD    (1<<(IS_AM_SHF  ))      // addr mode read
#define IS_AM_WR    (1<<(IS_AM_SHF+1))      // addr mode write
#define IS_AM_RW    (IS_AM_RD|IS_AM_WR)

#define IS_INDIR_RW IS_AM_RW
#define IS_INDIR_RD IS_AM_RD
#define IS_INDIR_WR IS_AM_WR

#define IS_FP_STK   0x1000                  // defs/uses the FP stack

#endif

#if TGT_SH3

#define IS_IR_SHF   8
#define IS_IR_RD    (1<<(IS_IR_SHF  ))      // ind. addr read
#define IS_IR_WR    (1<<(IS_IR_SHF+1))      // ind. addr write
#define IS_IR_RW    (IS_IR_RD|IS_IR_WR)

#define IS_INDIR_RW IS_IR_RW
#define IS_INDIR_RD IS_IR_RD
#define IS_INDIR_WR IS_IR_WR

#define IS_0R_SHF   10
#define IS_0R_RD    (1<<(IS_0R_SHF  ))      // read r0

#endif

#if TGT_MIPS32

#define IS_IR_SHF   8
#define IS_IR_RD    (1<<(IS_IR_SHF  ))      // ind. addr read
#define IS_IR_WR    (1<<(IS_IR_SHF+1))      // ind. addr write
#define IS_IR_RW    (IS_IR_RD|IS_IR_WR)

#define IS_R3_SHF   10
#define IS_R3_RD    (1<<(IS_R3_SHF  ))      // register2 read
#define IS_R3_WR    (1<<(IS_R3_SHF+1))      // register2 write
#define IS_R3_RW    (IS_R3_RD|IS_R3_WR)

#endif

#if TGT_PPC
// @ToDo
#endif

#define IS_SPECIAL  0x8000                  // needs special handling

//////////////////////////////////////////////////////////////////////////////
#else
//////////////////////////////////////////////////////////////////////////////
//     name
//                  opers
//                                           ID ops
//////////////////////////////////////////////////////////////////////////////

IF_DEF(NONE,        IS_NONE,                    NONE)     // no operands

IF_DEF(LABEL,       IS_NONE,                    JMP )     // label

#if TGT_x86 || TGT_MIPS32 || TGT_PPC
IF_DEF(METHOD,      IS_NONE,                    CALL)     // method
IF_DEF(METHPTR,     IS_NONE,                    CALL)     // method ptr (glbl)
IF_DEF(RWR_METHOD,  IS_R1_WR,                   SCNS)     // write  reg , method address
#else
IF_DEF(METHOD,      IS_NONE,                    CALL)     // method ptr call
#endif

IF_DEF(CNS,         IS_NONE,                    SCNS)     // const

#if TGT_x86
IF_DEF(EPILOG,      IS_NONE,                    SPEC)     // epilog
#endif

//----------------------------------------------------------------------------
// NOTE: The order of the "RD/WR/RW" varieties must match that of
//       the "insUpdateModes" enum in "instr.h".
//----------------------------------------------------------------------------

IF_DEF(RRD,         IS_R1_RD,                   REG )     // read   reg
IF_DEF(RWR,         IS_R1_WR,                   REG )     // write  reg
IF_DEF(RRW,         IS_R1_RW,                   REG )     // r/w    reg

IF_DEF(RRD_CNS,     IS_R1_RD,                   SCNS)     // read   reg , const
IF_DEF(RWR_CNS,     IS_R1_WR,                   SCNS)     // write  reg , const
IF_DEF(RRW_CNS,     IS_R1_RW,                   SCNS)     // r/w    reg , const

IF_DEF(RRW_SHF,     IS_R1_RW,                   SCNS)     // shift  reg , const

IF_DEF(RRD_RRD,     IS_R1_RD|IS_R2_RD,          SCNS)     // read   reg , read reg2
IF_DEF(RWR_RRD,     IS_R1_WR|IS_R2_RD,          SCNS)     // write  reg , read reg2
IF_DEF(RRW_RRD,     IS_R1_RW|IS_R2_RD,          SCNS)     // r/w    reg , read reg2
IF_DEF(RRW_RRW,     IS_R1_RW|IS_R2_RW,          SCNS)     // r/w    reg , r/w reg2 - for XCHG reg, reg2

#if TGT_x86
IF_DEF(RRW_RRW_CNS, IS_R1_RW|IS_R2_RW,          SCNS)     // r/w    reg , r/w  reg2 , const
#endif

#if TGT_RISC
IF_DEF(RWR_LIT,     IS_R1_WR,                   SPEC)     // write  reg , read [LP]
IF_DEF(JMP_TAB,     IS_NONE,                    JMP )     // table jump
#endif

//----------------------------------------------------------------------------
// The following formats are used for direct addresses (e.g. static data members)
//----------------------------------------------------------------------------

IF_DEF(MRD,         IS_GM_RD,                   SPEC)     // read  [mem] (indirect call req. SPEC)
IF_DEF(MWR,         IS_GM_WR,                   DC  )     // write [mem]
IF_DEF(MRW,         IS_GM_RW,                   DC  )     // r/w   [mem]
IF_DEF(MRD_OFF,     IS_GM_RD,                   DC  )     // offset mem

IF_DEF(RRD_MRD,     IS_GM_RD|IS_R1_RD,          DC  )     // read   reg , read [mem]
IF_DEF(RWR_MRD,     IS_GM_RD|IS_R1_WR,          DC  )     // write  reg , read [mem]
IF_DEF(RRW_MRD,     IS_GM_RD|IS_R1_RW,          DC  )     // r/w    reg , read [mem]

IF_DEF(RWR_MRD_OFF, IS_GM_RD|IS_R1_WR,          DC  )     // write  reg , offset mem

IF_DEF(MRD_RRD,     IS_GM_RD|IS_R1_RD,          DC  )     // read  [mem], read  reg
IF_DEF(MWR_RRD,     IS_GM_WR|IS_R1_RD,          DC  )     // write [mem], read  reg
IF_DEF(MRW_RRD,     IS_GM_RW|IS_R1_RD,          DC  )     // r/w   [mem], read  reg

IF_DEF(MRD_CNS,     IS_GM_RD,                   SPEC)     // read  [mem], const
IF_DEF(MWR_CNS,     IS_GM_WR,                   SPEC)     // write [mem], const
IF_DEF(MRW_CNS,     IS_GM_RW,                   SPEC)     // r/w   [mem], const

IF_DEF(MRW_SHF,     IS_GM_RW,                   SPEC)     // shift [mem], const

//----------------------------------------------------------------------------
// The following formats are used for stack frame refs
//----------------------------------------------------------------------------

IF_DEF(SRD,         IS_SF_RD,                   SPEC)     // read  [stk] (indirect call req. SPEC)
IF_DEF(SWR,         IS_SF_WR,                   NONE)     // write [stk]
IF_DEF(SRW,         IS_SF_RW,                   NONE)     // r/w   [stk]

IF_DEF(RRD_SRD,     IS_SF_RD|IS_R1_RD,          NONE)     // read   reg , read [stk]
IF_DEF(RWR_SRD,     IS_SF_RD|IS_R1_WR,          NONE)     // write  reg , read [stk]
IF_DEF(RRW_SRD,     IS_SF_RD|IS_R1_RW,          NONE)     // r/w    reg , read [stk]

IF_DEF(SRD_RRD,     IS_SF_RD|IS_R1_RD,          NONE)     // read  [stk], read  reg
IF_DEF(SWR_RRD,     IS_SF_WR|IS_R1_RD,          NONE)     // write [stk], read  reg
IF_DEF(SRW_RRD,     IS_SF_RW|IS_R1_RD,          NONE)     // r/w   [stk], read  reg

IF_DEF(SRD_CNS,     IS_SF_RD,                   CNS )     // read  [stk], const
IF_DEF(SWR_CNS,     IS_SF_WR,                   CNS )     // write [stk], const
IF_DEF(SRW_CNS,     IS_SF_RW,                   CNS )     // r/w   [stk], const

IF_DEF(SRW_SHF,     IS_SF_RW,                   CNS )     // shift [stk], const

//----------------------------------------------------------------------------
// The following formats are used for indirect address modes
//----------------------------------------------------------------------------

#if TGT_x86

IF_DEF(ARD,         IS_AM_RD,                   SPEC)     // read  [adr] (indirect call req. SPEC)
IF_DEF(AWR,         IS_AM_WR,                   AMD )     // write [adr]
IF_DEF(ARW,         IS_AM_RW,                   AMD )     // r/w   [adr]

IF_DEF(RRD_ARD,     IS_AM_RD|IS_R1_RD,          AMD )     // read   reg , read [adr]
IF_DEF(RWR_ARD,     IS_AM_RD|IS_R1_WR,          AMD )     // write  reg , read [adr]
IF_DEF(RRW_ARD,     IS_AM_RD|IS_R1_RW,          AMD )     // r/w    reg , read [adr]

IF_DEF(ARD_RRD,     IS_AM_RD|IS_R1_RD,          AMD )     // read  [adr], read  reg
IF_DEF(AWR_RRD,     IS_AM_WR|IS_R1_RD,          AMD )     // write [adr], read  reg
IF_DEF(ARW_RRD,     IS_AM_RW|IS_R1_RD,          AMD )     // r/w   [adr], read  reg

IF_DEF(ARD_CNS,     IS_AM_RD,                   AC  )     // read  [adr], const
IF_DEF(AWR_CNS,     IS_AM_WR,                   AC  )     // write [adr], const
IF_DEF(ARW_CNS,     IS_AM_RW,                   AC  )     // r/w   [adr], const

IF_DEF(ARW_SHF,     IS_AM_RW,                   AC  )     // shift [adr], const

#endif

#if TGT_SH3

IF_DEF(IRD,         IS_IR_RD,                   NONE)     // read  [ind]
IF_DEF(IWR,         IS_IR_WR,                   NONE)     // write [ind]

IF_DEF(IRD_RWR,     IS_IR_RD|IS_R1_WR,          NONE)     // read   reg , write [ind]
IF_DEF(RRD_IWR,     IS_IR_WR|IS_R1_RD,          NONE)     // read  [ind], write  reg

IF_DEF(DRD_RWR,     IS_IR_RD|IS_R1_WR,          DSP )     // read   reg , write [r+d]
IF_DEF(RRD_DWR,     IS_IR_WR|IS_R1_RD,          DSP )     // read  [r+d], write  reg

IF_DEF(0RD_XRD_RWR, IS_IR_RD|IS_R1_RD|IS_R2_WR, NONE)     // read (r0,r), write  reg
IF_DEF(0RD_RRD_XWR, IS_IR_WR|IS_R1_WR|IS_R2_RD, NONE)     // read   reg , write (r0,r)

IF_DEF(AWR_RRD,     IS_R1_RD, /*need arg wrt*/  NONE)     // write [arg], read   reg

IF_DEF(IRD_GBR,     IS_IR_RD,                   NONE)
IF_DEF(IWR_GBR,     IS_IR_WR,                   NONE)

IF_DEF(IRD_RWR_GBR, IS_IR_RD|IS_R1_WR,          NONE)
IF_DEF(RRD_IWR_GBR, IS_IR_WR|IS_R1_RD,          NONE)

#endif

#if TGT_MIPS32

IF_DEF(JR,      IS_R1_RD,                       JMP)
IF_DEF(JR_R,    IS_R1_RD | IS_R2_WR,            JMP)
IF_DEF(RR_R,    IS_R1_RD | IS_R2_RD | IS_R3_WR, SCNS)   // rg3 equiv to small const form of descriptor
IF_DEF(RI_R,    IS_R1_RD | IS_R2_WR,            SCNS)
IF_DEF(RI_R_PL, IS_R1_RD | IS_R2_WR,            SCNS)
IF_DEF(RR_O,    IS_R1_RD | IS_R2_RD,            JMP)
IF_DEF(R_O,     IS_R1_RD,                       JMP)
IF_DEF(RR_M,    IS_R1_RD | IS_R2_RD,            REG)
IF_DEF(M_R,     IS_R1_WR,                       REG)
IF_DEF(R_M,     IS_R1_RD,                       REG)
IF_DEF(AI_R,    IS_R1_RD | IS_R2_WR,            DSP)
IF_DEF(AI_R_PL, IS_R1_RD | IS_R2_WR,            DSP)
IF_DEF(I_R,     IS_R1_WR,                       SCNS)
IF_DEF(I_R_PH,  IS_R1_WR,                       SCNS)
IF_DEF(R_AI,    IS_R1_WR | IS_R2_RD,            DSP)
IF_DEF(R_AI_PL, IS_R1_WR | IS_R2_RD,            DSP)
IF_DEF(RS_R,    IS_R1_RD | IS_R2_WR,            CNS)

#if TGT_MIPSFP
// Floating point instruction formats
IF_DEF(fF_F,	IS_R1_RD | IS_R2_WR,			REG)
IF_DEF(fFF_F,	IS_R1_RD | IS_R2_RD | IS_R3_WR,	REG)
IF_DEF(O,		0,								JMP) // branch on FP status
IF_DEF(fF_Fc,	IS_R1_RD | IS_R2_RD,			REG) // comparisons
IF_DEF(F_R,		IS_R1_RD | IS_R2_WR,			REG)
IF_DEF(AI_F,	IS_R1_RD | IS_R2_WR,			DSP)
IF_DEF(AI_F_P,	IS_R1_RD | IS_R2_WR,			DSP)
#endif // TGT_MIPSFP

#endif // TGT_MIPS32

#if TGT_PPC
#include "instrPPC.h"
#endif

#if TGT_ARM
#include "emitfmtarm.h"
#endif // TGT_ARM


//----------------------------------------------------------------------------
// The following formats are used for FP coprocessor instructions
//----------------------------------------------------------------------------

#if TGT_x86

IF_DEF(FRD,         IS_FP_STK,                  NONE)     // read  ST(n)
IF_DEF(FWR,         IS_FP_STK,                  NONE)     // write ST(n)
IF_DEF(FRW,         IS_FP_STK,                  NONE)     // r/w   ST(n)

IF_DEF(TRD,         IS_FP_STK,                  NONE)     // read  ST(0)
IF_DEF(TWR,         IS_FP_STK,                  NONE)     // write ST(0)
IF_DEF(TRW,         IS_FP_STK,                  NONE)     // r/w   ST(0)

IF_DEF(FRD_TRD,     IS_FP_STK,                  NONE)     // read  ST(n), read ST(0)
IF_DEF(FWR_TRD,     IS_FP_STK,                  NONE)     // write ST(n), read ST(0)
IF_DEF(FRW_TRD,     IS_FP_STK,                  NONE)     // r/w   ST(n), read ST(0)

IF_DEF(TRD_FRD,     IS_FP_STK,                  NONE)     // read  ST(0), read ST(n)
IF_DEF(TWR_FRD,     IS_FP_STK,                  NONE)     // write ST(0), read ST(n)
IF_DEF(TRW_FRD,     IS_FP_STK,                  NONE)     // r/w   ST(0), read ST(n)

IF_DEF(TRD_SRD,     IS_FP_STK|IS_SF_RD,         NONE)     // read  ST(0), read [stk]
IF_DEF(TWR_SRD,     IS_FP_STK|IS_SF_RD,         NONE)     // write ST(0), read [stk]
IF_DEF(TRW_SRD,     IS_FP_STK|IS_SF_RD,         NONE)     // r/w   ST(0), read [stk]

//////(SRD_TRD,     IS_FP_STK|IS_SF_RD,         NONE)     // read  [stk], read ST(n)
IF_DEF(SWR_TRD,     IS_FP_STK|IS_SF_WR,         NONE)     // write [stk], read ST(n)
//////(SRW_TRD,     IS_FP_STK|IS_SF_RW,         NONE)     // r/w   [stk], read ST(n)

IF_DEF(TRD_MRD,     IS_FP_STK|IS_GM_RD,         NONE)     // read  ST(0), read [mem]
IF_DEF(TWR_MRD,     IS_FP_STK|IS_GM_RD,         NONE)     // write ST(0), read [mem]
IF_DEF(TRW_MRD,     IS_FP_STK|IS_GM_RD,         NONE)     // r/w   ST(0), read [mem]

//////(MRD_TRD,     IS_FP_STK|IS_GM_RD,         NONE)     // read  [mem], read ST(n)
IF_DEF(MWR_TRD,     IS_FP_STK|IS_GM_WR,         NONE)     // write [mem], read ST(n)
//////(MRW_TRD,     IS_FP_STK|IS_GM_RW,         NONE)     // r/w   [mem], read ST(n)

IF_DEF(TRD_ARD,     IS_FP_STK|IS_AM_RD,         AMD )     // read  ST(0), read [adr]
IF_DEF(TWR_ARD,     IS_FP_STK|IS_AM_RD,         AMD )     // write ST(0), read [adr]
IF_DEF(TRW_ARD,     IS_FP_STK|IS_AM_RD,         AMD )     // r/w   ST(0), read [adr]

//////(ARD_TRD,     IS_FP_STK|IS_AM_RD,         NONE)     // read  [adr], read ST(n)
IF_DEF(AWR_TRD,     IS_FP_STK|IS_AM_WR,         AMD )     // write [adr], read ST(n)
//////(ARW_TRD,     IS_FP_STK|IS_AM_RW,         NONE)     // r/w   [adr], read ST(n)

#endif

//////////////////////////////////////////////////////////////////////////////

#if TGT_RISC
IF_DEF(DISPINS,     IS_NONE,                    NONE)     // fake instruction
#endif

//////////////////////////////////////////////////////////////////////////////
#endif
#endif
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitinl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITINL_H_
#define _EMITINL_H_
/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Return the number of bytes of machine code the given instruction will
 *  produce.
 */

inline
size_t              emitter::emitInstCodeSz(instrDesc    *id)
{
    if  (id->idInsFmt == IF_EPILOG)
        return MAX_EPILOG_SIZE;
    return   id->idCodeSize;
}

inline
size_t              emitter::emitSizeOfJump(instrDescJmp *jmp)
{
    return  jmp->idCodeSize;
}

/*****************************************************************************
 *
 *  Given a jump, return true if it's a conditional jump.
 */

inline
bool                emitter::emitIsCondJump(instrDesc *jmp)
{
    instruction     ins = (instruction)jmp->idIns;

    assert(jmp->idInsFmt == IF_LABEL);

    return  (ins != INS_call && ins != INS_jmp);
}

/*****************************************************************************
 *
 *  The following helpers should be used to access the various values that
 *  get stored in different places within the instruction descriptor.
 */

inline
int                 emitter::emitGetInsAmd   (instrDesc *id)
{
    return  id->idInfo.idLargeDsp ? ((instrDescAmd*)id)->idaAmdVal
                                  : id->idAddr.iiaAddrMode.amDisp;
}

inline
void                emitter::emitGetInsCns   (instrDesc *id, CnsVal *cv)
{
#ifdef RELOC_SUPPORT
    cv->cnsReloc =                    id ->idInfo.idCnsReloc;
#endif
    if  (id->idInfo.idLargeCns)
    {
        cv->cnsVal =  ((instrDescCns*)id)->idcCnsVal;
    }
    else
    {
        cv->cnsVal =                  id ->idInfo.idSmallCns;
    }
}

inline
int                 emitter::emitGetInsAmdCns(instrDesc *id, CnsVal *cv)
{
#ifdef RELOC_SUPPORT
    cv->cnsReloc =                           id ->idInfo.idCnsReloc;
#endif
    if  (id->idInfo.idLargeDsp)
    {
        if  (id->idInfo.idLargeCns)
        {
            cv->cnsVal = ((instrDescAmdCns*) id)->idacCnsVal;
            return       ((instrDescAmdCns*) id)->idacAmdVal;
        }
        else
        {
            cv->cnsVal =                     id ->idInfo.idSmallCns;
            return          ((instrDescAmd*) id)->idaAmdVal;
        }
    }
    else
    {
        if  (id->idInfo.idLargeCns)
            cv->cnsVal =   ((instrDescCns *) id)->idcCnsVal;
        else
            cv->cnsVal =                     id ->idInfo.idSmallCns;

        return  id->idAddr.iiaAddrMode.amDisp;
    }
}

inline
void                emitter::emitGetInsDcmCns(instrDesc *id, CnsVal *cv)
{
    assert(id->idInfo.idLargeCns);
    assert(id->idInfo.idLargeDsp);
#ifdef RELOC_SUPPORT
    cv->cnsReloc =                    id ->idInfo.idCnsReloc;
#endif
    cv->cnsVal   =    ((instrDescDCM*)id)->idcmCval;
}

inline
int                 emitter::emitGetInsAmdAny(instrDesc *id)
{
    /* The following is a bit sleazy but awfully convenient */

    assert(offsetof(instrDescAmd   ,  idaAmdVal) ==
           offsetof(instrDescAmdCns, idacAmdVal));

    return  emitGetInsAmd(id);
}

/*****************************************************************************
 *
 *  Convert between a register mask and a smaller version for storage.
 */

#if TRACK_GC_REFS

inline
unsigned            emitter::emitEncodeCallGCregs(unsigned regs)
{
    unsigned        mask = 0;

    if  (regs & RBM_EAX)     mask |= 0x01;
    if  (regs & RBM_ECX)     mask |= 0x02;
    if  (regs & RBM_EDX)     mask |= 0x04;
    if  (regs & RBM_EBX)     mask |= 0x08;
    if  (regs & RBM_ESI)     mask |= 0x10;
    if  (regs & RBM_EDI)     mask |= 0x20;
    if  (regs & RBM_EBP)     mask |= 0x40;

    return  mask;
}

inline
void                emitter::emitEncodeCallGCregs(unsigned regs, instrDesc *id)
{
    unsigned        mask1 = 0;
    unsigned        mask2 = 0;
    unsigned        mask3 = 0;

    if  (regs & RBM_EAX)     mask1 |= 0x01;
    if  (regs & RBM_ECX)     mask1 |= 0x02;
    if  (regs & RBM_EBX)     mask1 |= 0x04;

    if  (regs & RBM_ESI)     mask2 |= 0x01;
    if  (regs & RBM_EDI)     mask2 |= 0x02;
    if  (regs & RBM_EBP)     mask2 |= 0x04;

    if  (regs & RBM_EDX)     mask3 |= 0x01;

    id->idReg                = mask1;
    id->idRg2                = mask2;
    id->idInfo.idCallEDXLive = mask3;
}

inline
unsigned            emitter::emitDecodeCallGCregs(unsigned mask)
{
    unsigned        regs = 0;

    if  (mask & 0x01)        regs |= RBM_EAX;
    if  (mask & 0x02)        regs |= RBM_ECX;
    if  (mask & 0x04)        regs |= RBM_EDX;
    if  (mask & 0x08)        regs |= RBM_EBX;
    if  (mask & 0x10)        regs |= RBM_ESI;
    if  (mask & 0x20)        regs |= RBM_EDI;
    if  (mask & 0x40)        regs |= RBM_EBP;

    return  regs;
}

inline
unsigned            emitter::emitDecodeCallGCregs(instrDesc *id)
{
    unsigned        regs  = 0;
    unsigned        mask1 = id->idRegGet();
    unsigned        mask2 = id->idRg2Get();

    if  (mask1 & 0x01)              regs |= RBM_EAX;
    if  (mask1 & 0x02)              regs |= RBM_ECX;
    if  (mask1 & 0x04)              regs |= RBM_EBX;

    if  (mask2 & 0x01)              regs |= RBM_ESI;
    if  (mask2 & 0x02)              regs |= RBM_EDI;
    if  (mask2 & 0x04)              regs |= RBM_EBP;

    if  (id->idInfo.idCallEDXLive)  regs |= RBM_EDX;

    return  regs;
}

#endif

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Returns true if the given instruction can be moved around during
 *  instruction scheduling.
 */

inline
bool                emitter::scIsSchedulable(instruction ins)
{
    if  (ins == INS_noSched)    // explicit scheduling boundary
        return  false;

    if  (ins == INS_align)      // loop alignment pseudo instruction
        return  false;

    if  (ins == INS_i_jmp)
        return  false;

    if  (ins == INS_call)
        return  false;

    if  (ins == INS_ret)
        return  false;

    if  (insIsCMOV(ins))
        return  false;

    return true;
}

inline
bool                emitter::scIsSchedulable(instrDesc *id)
{
    instruction ins = id->idInsGet();

    if (!scIsSchedulable(ins))
        return false;

    /* UNDONE: Mark FP instrs as non-schedulable */

    if  (Compiler::instIsFP(ins))
        return  false;

    /* These instructions implicitly modify aliased memory. As the
       scheduler has no knowledge about aliasing, we have to assume that
       they can touch any memory. So dont schedule across them.
       @TODO [CONSIDER] [04/16/01] []: We could provide the scheduler with sufficient info such
       that it can do the aliasing analysis.
     */

    if  (id->idInsFmt == IF_NONE)
    {
        switch(ins)
        {
        case INS_r_movsb:
        case INS_r_movsd:
        case INS_movsd:
        case INS_r_stosb:
        case INS_r_stosd:
            return false;
        }
    }

    assert(id->idInsFmt != IF_EPILOG);

    if  (id->idInsFmt == IF_LABEL)
    {
        if  (!((instrDescJmp*)id)->idjSched)
            return  false;
    }

    return  true;
}

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/

#if TGT_RISC

/*****************************************************************************
 *
 *  Return the number of bytes of machine code the given instruction will
 *  produce.
 */

inline
size_t              emitter::emitInstCodeSz(instrDesc *id)
{
    assert(id->idIns <  INS_count);
    //assert(id->idIns != INS_ignore);
    if (id->idIns == INS_ignore)
        return 0;

    if  (id->idInsFmt == IF_JMP_TAB)
        return  ((instrDescJmp*)id)->idjCodeSize;

#if TGT_MIPS32
    if  ( (id->idInsFmt == IF_LABEL) ||
          (id->idInsFmt == IF_JR_R)  || (id->idInsFmt == IF_JR) ||
          (id->idInsFmt == IF_RR_O)  || (id->idInsFmt == IF_R_O)
#if TGT_MIPSFP
                                     || (id->idInsFmt == IF_O)
#endif
        )
        return  emitSizeOfJump((instrDescJmp*)id);
#else
    if  (id->idInsFmt == IF_LABEL)
        return  emitSizeOfJump((instrDescJmp*)id);
#endif

    return  INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Given a jump, return true if it's a conditional jump.
 */

inline
bool                emitter::emitIsCondJump(instrDesc *jmp)
{
    instruction     ins = (instruction)jmp->idIns;

#if TGT_MIPSFP
    assert( (jmp->idInsFmt == IF_LABEL) ||
            (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR) ||
            (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O) ||
            (jmp->idInsFmt == IF_O));
#elif TGT_MIPS32
    assert( (jmp->idInsFmt == IF_LABEL) ||
            (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR) ||
            (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O));
#else
    assert(jmp->idInsFmt == IF_LABEL);
#endif

#if   TGT_SH3
    return  (ins != INS_braf  && ins != INS_bra && ins != INS_bsr);
#elif TGT_MIPS32
    return  (ins != INS_jr  && ins != INS_j  && ins != INS_jal  && ins != INS_jalr);
#elif TGT_ARM
    return( ins != INS_b && ins != INS_bl );
#elif TGT_PPC
    return (ins == INS_bc);
#elif
    assert (!"nyi");
#endif
}

#endif TGT_RISC

#if     TGT_SH3
/*****************************************************************************
 *
 *  Inline short-cuts to generate variations of the same opcode.
 */

inline
void                emitter::emitIns_IR_R (emitRegs areg,
                                           emitRegs dreg,
                                           bool      autox,
                                           int       size,
                                           bool      isfloat)
{
    emitIns_IMOV(IF_IRD_RWR, dreg, areg, autox, size, isfloat);
}

inline
void                emitter::emitIns_R_IR (emitRegs dreg,
                                           emitRegs areg,
                                           bool      autox,
                                           int       size,
                                           bool      isfloat)
{
    emitIns_IMOV(IF_RRD_IWR, dreg, areg, autox, size, isfloat);
}

inline
void                emitter::emitIns_R_XR0(emitRegs dreg,
                                           emitRegs areg,
                                           int       size)
{
    emitIns_X0MV(IF_0RD_XRD_RWR, dreg, areg, size);
}

inline
void                emitter::emitIns_XR0_R(emitRegs areg,
                                           emitRegs dreg,
                                           int       size)
{
    emitIns_X0MV(IF_0RD_RRD_XWR, dreg, areg, size);
}

// ============================
inline
void                emitter::emitIns_I_GBR_R(int       size)
{
    emitIns_Ig(INS_lod_gbr, false, size);
}

inline
void                emitter::emitIns_R_I_GBR(int       size)
{
    emitIns_Ig(INS_sto_gbr, false, size);
}

// ============================
inline
void                emitter::emitIns_R_RD (emitRegs dreg,
                                           emitRegs areg,
                                           int       offs,
                                           int       size)
{
    emitIns_RDMV(IF_DRD_RWR, dreg, areg, offs, size);
}

inline
void                emitter::emitIns_RD_R (emitRegs areg,
                                           emitRegs dreg,
                                           int       offs,
                                           int       size)
{
    emitIns_RDMV(IF_RRD_DWR, dreg, areg, offs, size);
}

/*****************************************************************************
 *
 *  Convert between a register mask and a smaller version for storage.
 */

#if TRACK_GC_REFS

inline
unsigned            emitter::emitEncodeCallGCregs(unsigned regs)
{
    #error  GC ref tracking for RISC NYI
}

inline
unsigned            emitter::emitDecodeCallGCregs(unsigned mask)
{
    #error  GC ref tracking for RISC NYI
}

#endif

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Returns true if the given instruction can be moved around during
 *  instruction scheduling.
 */

inline
bool                emitter::scIsSchedulable(instruction ins)
{
    if  (ins == INS_noSched)    // explicit scheduling boundary
        return  false;

    return  true;
}

inline
bool                emitter::scIsSchedulable(instrDesc *id)
{
    /* We should never encounter a "swapped" instructin here, right? */

    assert(id->idSwap == false);

    if  (!scIsSchedulable(id->idIns))
        return false;

    return  true;
}

/*****************************************************************************
 *
 *  Returns true if the given instruction is a jump or a call.
 */

inline
bool                emitter::scIsBranchIns(instruction ins)
{
    return  Compiler::instIsBranch(ins);
}

/*****************************************************************************/
#if     MAX_BRANCH_DELAY_LEN
/*****************************************************************************
 *
 *  Returns true if the given instruction is a jump or a call with delay slot(s).
 */

inline
bool                emitter::scIsBranchIns(scDagNode *node)
{
    return  node->sdnBranch;
}

/*****************************************************************************
 *
 *  Return true if the given dag node corresponds to a branch instruction
 *  that cannot be issued yet.
 */

inline
bool                emitter::scIsBranchTooEarly(scDagNode *node)
{
    /* Is this a branch instruction? */

    if  (scIsBranchIns(node))
    {
        /* Is it too early to issue the branch? */

        if  (scIssued < scBDTmin)
            return  true;
    }

    return  false;
}

/*****************************************************************************/
#endif//MAX_BRANCH_DELAY_LEN
/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************
 *
 *  Return the size of the jump we'll have to insert to jump over a literal
 *  pool that got placed in an unfortunate place.
 */

inline
size_t              emitter::emitLPjumpOverSize(litPool *lp)
{
    assert(lp->lpJumpIt);

    // note : nop is necessary because prev instr could be a jsr
    // we could pick a smarter place to break but this is easy 
    if  (lp->lpJumpSmall)
        return  3 * INSTRUCTION_SIZE;           // nop + bra + nop
    else                                        
        return  4 * INSTRUCTION_SIZE;           // nop + mov + br  + nop
   
}

/*****************************************************************************/
#endif//TGT_SH3
#if TGT_ARM
inline
size_t              emitter::emitLPjumpOverSize(litPool *lp)
{
    assert(lp->lpJumpIt);

    return INSTRUCTION_SIZE;           //  br 
   
}

#endif //TGT_ARM
/*****************************************************************************/
#if     EMIT_USE_LIT_POOLS
/*****************************************************************************
 *
 *  Given a literal pool referencing instruction, return the "call type"
 *  of the reference (which is not necessarily a method).
 */

inline
gtCallTypes         emitter::emitGetInsLPRtyp(instrDesc *id)
{
    return  (gtCallTypes)id->idInfo.idSmallCns;
}

/*****************************************************************************
 *
 *  Given an instruction that references a method address (via a literal
 *  pool entry), return the address of the method if it's available (NULL
 *  otherwise).
 */

#if SMALL_DIRECT_CALLS

inline
BYTE    *           emitter::emitMethodAddr(instrDesc *lprID)
{
    gtCallTypes     callTyp = emitGetInsLPRtyp(lprID);
    CORINFO_METHOD_HANDLE   callHnd = lprID->idAddr.iiaMethHnd;
    BYTE *          addr;
    InfoAccessType  accessType = IAT_VALUE;

    if  (callTyp == CT_DESCR)
    {
        addr = (BYTE*)emitComp->eeGetMethodEntryPoint(callHnd, &accessType);
        assert(accessType == IAT_PVALUE);
        return addr;
    }

    assert(callTyp == CT_USER_FUNC);

    if  (emitComp->eeIsOurMethod(callHnd))
    {
        /* Directly recursive call */

        return  emitCodeBlock;
    }
    else
    {
        addr = (BYTE*)emitComp->eeGetMethodEntryPoint(callHnd, &accessType);
        assert(accessType == IAT_PVALUE);
        return addr;
    }
}

#endif

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given entry.
 */

inline
void                emitter::scDepDef(scDagNode *node,
                                      const char*name, schedDef_tp def,
                                                       schedUse_tp use)
{
    scDagList *  useLst;

    /*
        Check for an output dependency; note that we check only the first
        def that follows after our instruction. We can do this because we
        know that any further defs must already have a dependency entry,
        so it's not necessary to add them (i.e. the transitive closure is
        done implicitly).
     */

    if  (def)
    {
        /* There is an output dependency */

        scAddDep(node, def, "Out-", name, false);
    }

    /*
        Check for any flow dependencies; since no dependencies are noted
        between multiple uses, we keep all the "active" uses on a list
        and mark dependencies for all of them here.
     */

    for (useLst = use; useLst; useLst = useLst->sdlNext)
    {
        /* There is a flow dependency */

        scAddDep(node, useLst->sdlNode, "Flow", name, true);
    }
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given register.
 */

inline
void                emitter::scDepDefReg(scDagNode *node, emitRegs reg)
{
#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "reg %s", emitRegName(reg));
#endif
    scDepDef(node, temp, scRegDef[reg], scRegUse[reg]);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given register.
 */

inline
void                emitter::scDepUseReg(scDagNode *node, emitRegs reg)
{
#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "reg %s", emitRegName(reg));
#endif
    scDepUse(node, temp, scRegDef[reg], scRegUse[reg]);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  register.
 */

inline
void                emitter::scUpdDefReg(scDagNode *node, emitRegs reg)
{
    scUpdDef(node, &scRegDef[reg], &scRegUse[reg]);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  register.
 */

inline
void                emitter::scUpdUseReg(scDagNode *node, emitRegs reg)
{
    scUpdUse(node, &scRegDef[reg], &scRegUse[reg]);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given frame slot.
 */

inline
void                emitter::scDepDefFrm(scDagNode   *node,
                     unsigned     frm)
{
    assert(frm < scFrmUseSiz);

#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "frm[%u]", frm);
#endif

    scDepDef(node, temp, scFrmDef[frm], scFrmUse[frm]);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given frame slot.
 */

inline
void                emitter::scDepUseFrm(scDagNode   *node,
                     unsigned     frm)
{
    assert(frm < scFrmUseSiz);

#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "frm[%u]", frm);
#endif

    scDepUse(node, temp, scFrmDef[frm], scFrmUse[frm]);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  stack slot.
 */

inline
void                emitter::scUpdDefFrm(scDagNode   *node,
                     unsigned     frm)
{
    assert(frm < scFrmUseSiz);
    scUpdDef(node, scFrmDef+frm, scFrmUse+frm);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  stack slot.
 */

inline
void                emitter::scUpdUseFrm(scDagNode   *node,
                     unsigned     frm)
{
    assert(frm < scFrmUseSiz);
    scUpdUse(node, scFrmDef+frm, scFrmUse+frm);
}

/*****************************************************************************/
#if     SCHED_USE_FL
/*****************************************************************************
 *
 *  Record a dependency for an instruction that sets flags.
 */

inline
void                emitter::scDepDefFlg(scDagNode *node)
{
    if  (scFlgDef)
        scAddDep(node, scFlgDef, "Out-", "FLAGS", false);
    if  (scFlgUse)
        scAddDep(node, scFlgUse, "Flow", "FLAGS",  true);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses flags.
 */

inline
void                emitter::scDepUseFlg(scDagNode *node, scDagNode *begp,
                                                          scDagNode *endp)
{
    while (begp != endp)
    {
        instrDesc   *   id  = scGetIns(begp);
        instruction     ins = id->idInsGet();

        if  (emitComp->instInfo[ins] & INST_DEF_FL)
            scAddDep(node, begp, "Anti", "FLAGS", false);

        begp++;
    }
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that sets flags.
 */

inline
void                emitter::scUpdDefFlg(scDagNode *node)
{
    if  (scFlgUse || scFlgEnd)
    {
        scFlgDef = node;
        scFlgUse = NULL;
        scFlgEnd = false;
    }
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses flags.
 */

inline
void                emitter::scUpdUseFlg(scDagNode *node)
{
    /* As we dont keep a list of users for flags, if there are multiple
       users of flags, just pretend there is a dependancy between the various
       users. This will enforce a more stricter ordering than necessary, but
       it happens very rarely (eg. X=((Y+ovfZ)==0) produces add;jo;sete; )
       @TODO [CONSIDER] [04/16/01]: Keep a list of users for flags.
     */

    if (scFlgUse)
    {
        scDepUse(node, "FLAGS", scFlgUse, NULL);
    }

    scFlgUse = node;
    scFlgDef = NULL;
}

/*****************************************************************************/
#endif//SCHED_USE_FL
/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given global.
 */

inline
void                emitter::scDepDefGlb(scDagNode *node, CORINFO_FIELD_HANDLE MBH)
{
#ifdef  DEBUG
//  char            temp[32]; sprintf(temp, "glob[%s]", scFldName(MBX, SCP));
    char            temp[32]; sprintf(temp, "global");
#endif
    scDepDef(node, temp, scGlbDef, scGlbUse);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given global.
 */

inline
void                emitter::scDepUseGlb(scDagNode *node, CORINFO_FIELD_HANDLE MBH)
{
#ifdef  DEBUG
//  char            temp[32]; sprintf(temp, "glob[%s]", scFldName(MBH));
    char            temp[32]; sprintf(temp, "global");
#endif
    scDepUse(node, temp, scGlbDef, scGlbUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  global.
 */

inline
void                emitter::scUpdDefGlb(scDagNode *node, CORINFO_FIELD_HANDLE MBH)
{
    scUpdDef(node, &scGlbDef, &scGlbUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  global.
 */

inline
void                emitter::scUpdUseGlb(scDagNode *node, CORINFO_FIELD_HANDLE MBH)
{
    scUpdUse(node, &scGlbDef, &scGlbUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  indirection.
 */

inline
void                emitter::scUpdDefInd(scDagNode   *node,
                                         unsigned     am)
{
    assert(am < sizeof(scIndUse));
    scUpdDef(node, scIndDef+am, scIndUse+am);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  indirection.
 */

inline
void                emitter::scUpdUseInd(scDagNode   *node,
                                         unsigned     am)
{
    assert(am < sizeof(scIndUse));
    scUpdUse(node, scIndDef+am, scIndUse+am);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given entry.
 */

inline
void                emitter::scDepUse(scDagNode *node,
                                      const char*name, schedDef_tp def,
                                                       schedUse_tp use)

{
    /* Check for anti-dependence */

    if  (def)
    {
        /* There is an anti-dependence */

        scAddDep(node, def, "Anti", name, false);
    }
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  entry.
 */

inline
void                emitter::scUpdDef(scDagNode *node, schedDef_tp*defPtr,
                                                       schedUse_tp*usePtr)
{
    /* Set the current definition to the defining instruction */

    *defPtr = node;

    /*
        Clear the use list, since all existing uses have just been marked
        as dependencies so no need to keep them around.
     */

    scClrUse(usePtr);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  register.
 */

inline
void                emitter::scUpdUse(scDagNode *node, schedDef_tp*defPtr,
                                                       schedUse_tp*usePtr)
{
    /* Add the entry to the use list */

    scAddUse(usePtr, node);
}

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#endif//_EMITINL_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitpub.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /************************************************************************/
    /*       Overall emitter control (including startup and shutdown)       */
    /************************************************************************/

    static
    void            emitInit();
    static
    void            emitDone();

    void            emitBegCG(Compiler   *  comp,
                              COMP_HANDLE   cmpHandle);
    void            emitEndCG();

    void            emitBegFN(bool     EBPframe, 
#if defined(DEBUG) && TGT_x86
                              bool     checkAlign,
#endif
                              size_t   lclSize, 
                              size_t   maxTmpSize);

    void            emitEndFN();

    size_t          emitEndCodeGen(Compiler *comp,
                                   bool      contTrkPtrLcls,
                                   bool      fullyInt,
                                   bool      fullPtrMap,
                                   bool      returnsGCr,
                                   unsigned *prologSize,
                                   unsigned *epilogSize, void **codeAddr,
                                                         void **consAddr,
                                                         void **dataAddr);

    /************************************************************************/
    /*                      Method prolog and epilog                        */
    /************************************************************************/

    void            emitBegEpilog();
    void            emitEndEpilog(bool last);
#if!TGT_RISC
    void            emitDefEpilog(BYTE *codeAddr, size_t codeSize);
#endif

    bool            emitHasEpilogEnd();
    unsigned        emitGetEpilogCnt();
    size_t          emitGenEpilogLst(size_t (*fp)(void *, unsigned),
                                     void    *cp);

    void            emitBegProlog();
    size_t          emitSetProlog();
    void            emitEndProlog();

    /************************************************************************/
    /*           Record a code position and later convert it to offset      */
    /************************************************************************/

    void    *       emitCurBlock ();
    unsigned        emitCurOffset();

    size_t          emitCodeOffset(void *blockPtr, unsigned codeOffs);

    /************************************************************************/
    /*                      Display source line information                 */
    /************************************************************************/

#ifdef  DEBUG
    void            emitRecordLineNo(int lineno);
#endif

    /************************************************************************/
    /*                   Output target-independent instructions             */
    /************************************************************************/

    void            emitIns_J(instruction ins,
                              bool        except,
                              bool        moveable,
                              BasicBlock *dst);

#if SCHEDULER
    void            emitIns_SchedBoundary();
#endif

    /************************************************************************/
    /*                   Emit initialized data sections                     */
    /************************************************************************/

    unsigned        emitDataGenBeg (size_t        size,
                                    bool          dblAlign,
                                    bool          readOnly,
                                    bool          codeLtab);

    void            emitDataGenData(unsigned      offs,
                                    const void *  data,
                                    size_t        size);

    void            emitDataGenData(unsigned      offs,
                                    BasicBlock *  label);

    void            emitDataGenEnd();

    size_t          emitDataSize(bool readOnly);

    /************************************************************************/
    /*                   Emit PDB offset translation information            */
    /************************************************************************/

#ifdef  TRANSLATE_PDB
  {
    static void     SetILBaseOfCode ( BYTE    *pTextBase );
    static void     SetILMethodBase ( BYTE *pMethodEntry );
    static void     SetILMethodStart( BYTE  *pMethodCode );
    static void     SetImgBaseOfCode( BYTE    *pTextBase );
    
    void            SetIDBaseToProlog();
    void            SetIDBaseToOffset( long methodOffset );
    
    static void     DisablePDBTranslation();
    static bool     IsPDBEnabled();
    
    static void     InitTranslationMaps( long ilCodeSize );
    static void     DeleteTranslationMaps();
    static void     InitTranslator( PDBRewriter * pPDB,
                                    int *         rgSecMap,
                                    IMAGE_SECTION_HEADER **rgpHeader,
                                    int           numSections );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emittyp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITTYP_H_
#define _EMITTYP_H_
/*****************************************************************************/

struct  emitbase;

#if     TGT_x86

struct  emitX86;
typedef emitX86 emitter;

#elif   TGT_SH3

struct  emitSH3;
typedef emitSH3 emitter;

#elif   TGT_MIPS32

struct  emitMIPS;
typedef emitMIPS emitter;

#elif   TGT_ARM

struct  emitARM;
typedef emitARM emitter;

#elif   TGT_PPC

struct  emitPPC;
typedef emitPPC emitter;

#else

#error  Unexpected target

#endif

/*****************************************************************************/
#endif//_EMITTYP_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitrisc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
   /************************************************************************/
    /*                  Routines that encode instructions                   */
    /************************************************************************/

    BYTE    *       emitOutputRIRD(BYTE *dst, instruction ins,
                                              emitRegs     reg,
                                              emitRegs     irg,
                                              unsigned    dsp,
                                              bool        rdst);

    BYTE    *       emitOutputSV  (BYTE *dst, instrDesc *id, bool     rdst);

#if TGT_MIPS32
    BYTE    *       emitOutputLJ  (BYTE *dst, instrDesc *id, emitRegs regS, emitRegs regT);
    BYTE    *       emitOutputCall (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputProcAddr (BYTE *dst, instrDesc *id);
#else
    BYTE    *       emitOutputLJ  (BYTE *dst, instrDesc *id);
#endif
    BYTE    *       emitOutputIJ  (BYTE *dst, instrDesc *id);

#if SMALL_DIRECT_CALLS
    BYTE    *       emitOutputDC  (BYTE *dst, instrDesc *id, instrDesc *im);
#endif

    BYTE    *       emitMethodAddr(instrDesc *id);

    /************************************************************************/
    /*             Debug-only routines to display instructions              */
    /************************************************************************/

#ifdef  DEBUG
    void            emitDispIndAddr (emitRegs base, bool dest, bool autox, int disp = 0);

    bool            emitDispInsExtra;

    unsigned        emitDispLPaddr;
    int             emitDispJmpDist;

#if     EMIT_USE_LIT_POOLS
    insGroup    *   emitDispIG;
#endif

    void            emitDispIns     (instrDesc *id, bool isNew,
                                                    bool doffs,
                                                    bool asmfm, unsigned offs = 0);

#endif

    /*----------------------------------------------------------------------*/

    bool            emitInsDepends  (instrDesc   *i1,
                                     instrDesc   *i2);

    /************************************************************************/
    /*                         Literal pool logic                           */
    /************************************************************************/

#if     EMIT_USE_LIT_POOLS

    struct  LPaddrDesc
    {
        gtCallTypes     lpaTyp;         // CT_xxxx (including the fake ones below)
        void    *       lpaHnd;         // member/method handle
    };

    /* These "fake" values are used to distinguish members from methods */

    #define CT_INTCNS       ((gtCallTypes)(CT_COUNT+1))
    #define CT_CLSVAR       ((gtCallTypes)(CT_COUNT+2))
#ifdef BIRCH_SP2
    #define CT_RELOCP       ((gtCallTypes)(CT_COUNT+3))
#endif

#if     SCHEDULER

    struct  LPcrefDesc
    {
        LPcrefDesc  *       lpcNext;    // next ref to this literal pool
        BYTE        *       lpcAddr;    // address of reference
    };

#endif

    struct  litPool
    {
        litPool     *   lpNext;

        insGroup    *   lpIG;           // the litpool follows this group

#ifdef  DEBUG
        unsigned        lpNum;
#endif

#if     SCHEDULER
        LPcrefDesc  *   lpRefs;         // list of refs (if scheduling)
        unsigned        lpDiff;         // base offset change value
#endif

        unsigned short  lpSize;         // total size in bytes
        unsigned short  lpSizeEst;      // total size in bytes estimate

        unsigned        lpOffs      :24;// offset within function

        unsigned        lpPadding   :1; // pad via first word entry?
        unsigned        lpPadFake   :1; // pad via adding a fake word?

        unsigned        lpJumpIt    :1; // do we need to jump over the LP?
        unsigned        lpJumpSmall :1; // jump is small  (if present)?
#if     JMP_SIZE_MIDDL
        unsigned        lpJumpMedium:1; // jump is medium (if present)?
#endif

        short       *   lpWordTab;      // address of word table
        short       *   lpWordNxt;      // next available entry
        unsigned short  lpWordCnt;      // number of entries added so far
        unsigned short  lpWordOfs;      // base offset of the first entry
#ifdef  DEBUG
        unsigned        lpWordMax;      // max. capacity
#endif

        long        *   lpLongTab;      // address of long table
        long        *   lpLongNxt;      // next available entry
        unsigned short  lpLongCnt;      // number of entries added so far
        unsigned short  lpLongOfs;      // base offset of the first entry
#ifdef  DEBUG
        unsigned        lpLongMax;      // max. capacity
#endif

        LPaddrDesc  *   lpAddrTab;      // address of addr table
        LPaddrDesc  *   lpAddrNxt;      // next available entry
        unsigned short  lpAddrCnt;      // number of entries added so far
        unsigned short  lpAddrOfs;      // base offset of the first entry
#ifdef  DEBUG
        unsigned        lpAddrMax;      // max. capacity
#endif
    };

    litPool *       emitLitPoolList;
    litPool *       emitLitPoolLast;
    litPool *       emitLitPoolCur;

    unsigned        emitTotLPcount;
#if SMALL_DIRECT_CALLS
    unsigned        emitTotDCcount;
#endif
    unsigned        emitEstLPwords;
    unsigned        emitEstLPlongs;
    unsigned        emitEstLPaddrs;

    size_t          emitAddLitPool     (insGroup   * ig,
                                        bool         skip,
                                        unsigned     wordCnt,
                                        short *    * nxtLPptrW,
                                        unsigned     longCnt,
                                        long  *    * nxtLPptrL,
                                        unsigned     addrCnt,
                                        LPaddrDesc** nxtAPptrL);

    int             emitGetLitPoolEntry(void       * table,
                                        unsigned     count,
                                        void       * value,
                                        size_t       size);

    size_t          emitAddLitPoolEntry(litPool    * lp,
                                        instrDesc  * id,
                                        bool         issue);

    BYTE    *       emitOutputLitPool  (litPool    * lp, BYTE *cp);

    size_t          emitLPjumpOverSize (litPool    * lp);

#if!JMP_SIZE_MIDDL
    #define         emitOutputFwdJmp(c,d,s,m) emitOutputFwdJmp(c,d,s)
#endif

    BYTE    *       emitOutputFwdJmp   (BYTE       * cp,
                                        unsigned     dist,
                                        bool         isSmall,
                                        bool         isMedium);

#if SMALL_DIRECT_CALLS
    BYTE    *       emitLPmethodAddr;
#endif

#if SCHEDULER

    void            emitRecordLPref    (litPool    * lp,
                                        BYTE       * dst);

    void            emitPatchLPref     (BYTE       * addr,
                                        unsigned     oldOffs,
                                        unsigned     newOffs);

#endif

#endif

    /************************************************************************/
    /*  Private members that deal with target-dependent instr. descriptors  */
    /************************************************************************/

private:

#if EMIT_USE_LIT_POOLS

    struct          instrDescLPR    : instrDesc     // literal pool/fixup ref
    {
        instrDescLPR  * idlNext;        // next litpool ref
        instrDesc     * idlCall;        // points to call instr if call
        size_t          idlOffs;        // offset within IG
        insGroup      * idlIG;          // IG this instruction belongs to
    };

    instrDescLPR   *emitAllocInstrLPR(size_t size)
    {
        return  (instrDescLPR*)emitAllocInstr(sizeof(instrDescLPR), size);
    }

    instrDescLPR *  emitLPRlist;        // list of litpool refs in method
    instrDescLPR *  emitLPRlast;        // last of litpool refs in method

    instrDescLPR *  emitLPRlistIG;      // list of litpool refs in current IG

#endif

    instrDesc      *emitNewInstrLPR    (size_t       size,
                                        gtCallTypes  type,
                                        void   *     hand = NULL);

    instrDesc      *emitNewInstrCallInd(int        argCnt,  // <0 ==> caller pops args
#if TRACK_GC_REFS
                                        VARSET_TP  GCvars,
                                        unsigned   byrefRegs,
#endif
                                        int        retSize);

#if EMIT_USE_LIT_POOLS
    gtCallTypes     emitGetInsLPRtyp(instrDesc *id);
#endif

    /************************************************************************/
    /*               Private helpers for instruction output                 */
    /************************************************************************/

private:

    void            emitFinalizeIndJumps();

    /************************************************************************/
    /*           The public entry points to output instructions             */
    /************************************************************************/

public:

    void            emitIns        (instruction ins);
#ifndef TGT_MIPS32
    bool            emitIns_BD     (instruction ins);
#endif
    bool            emitIns_BD     (instrDesc * id,
                                    instrDesc * pi,
                                    insGroup  * pg);

    void            emitIns_I      (instruction ins,
                                    int         val
#ifdef  DEBUG
                                  , bool        strlit = false
#endif
                                   );

#if!SCHEDULER
#define scAddIns_J(jmp, xcpt, move, dst) scAddIns_J(jmp, dst)
#endif

    void            emitIns_JmpTab (emitRegs     reg,
                                    unsigned    cnt,
                                    BasicBlock**tab);

    void            emitIns_Call   (size_t      argSize,
                                    int         retSize,
#if TRACK_GC_REFS
                                    VARSET_TP   ptrVars,
                                    unsigned    gcrefRegs,
                                    unsigned    byrefRegs,
#endif
                                    bool        chkNull,
#if TGT_MIPS32 || TGT_PPC
                                    unsigned    ftnIndex
#else
                                    emitRegs    areg
#endif
                                    );

#if defined(BIRCH_SP2) && TGT_SH3
    void            emitIns_CallDir(size_t      argSize,
                                    int         retSize,
#if TRACK_GC_REFS
                                    VARSET_TP   ptrVars,
                                    unsigned    gcrefRegs,
                                    unsigned    byrefRegs,
#endif
                                    unsigned    ftnIndex,
                                    emitRegs    areg
                                    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitsh3.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                             emitSH3.cpp                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/
#if     TGT_SH3     // this entire file is used only for targetting the SH-3
/*****************************************************************************/

#include "alloc.h"
#include "instr.h"
#include "target.h"
#include "emit.h"

/*****************************************************************************/

#if     TRACK_GC_REFS

regMaskSmall        emitter::emitRegMasks[] =
{
    #define REGDEF(name, strn, rnum, mask) mask,
    #include "regSH3.h"
    #undef  REGDEF
};

#endif

/*****************************************************************************
 *
 *  Initialize the table used by emitInsModeFormat().
 */

BYTE                emitter::emitInsModeFmtTab[] =
{
    #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) um,
    #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) um,
    #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) um,
    #include "instrSH3.h"
    #undef  INST1
    #undef  INST2
    #undef  INST3
};

BYTE                emitInsWriteFlags[] =
{
    #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) wf,
    #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) wf,
    #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) wf,
    #include "instrSH3.h"
    #undef  INST1
    #undef  INST2
    #undef  INST3
};

#ifdef  DEBUG
unsigned            emitter::emitInsModeFmtCnt = sizeof(emitInsModeFmtTab)/
                                                 sizeof(emitInsModeFmtTab[0]);
#endif

/*****************************************************************************
 *
 *  Returns true if instruction i2 depends on instruction i1.
 */

bool                emitter::emitInsDepends(instrDesc *i1, instrDesc *i2)
{
    /* What is the second instruction? */

    switch(i2->idIns)
    {
    case INS_rts:

        /* "rts" depends on the PR register only */

        return  (i1->idIns == INS_ldspr);

    case INS_bra:
    case INS_bsr:
    case INS_jsr:
    case INS_bf:
    case INS_bt:
    case INS_mov_PC:

        /* Branches can't be used as branch-delay slots */

        if (i1->idIns == INS_mov_PC 
            || i1->idIns == INS_mova || i1->idIns == INS_bsr || i1->idIns == INS_bra
            || i1->idIns == INS_jsr || i1->idIns == INS_nop)
            return true;

        return  (i1->idInsFmt == IF_LABEL);

    case INS_bfs:
    case INS_bts:


        return ((emitComp->instInfo[i1->idIns] & INST_DEF_FL) != 0);
    
    default:
        emitRegs    rx = i2->idRegGet();
        if (((rx == i1->idRegGet ()) || (rx == i1->idRg2Get())))
            return true;
        rx = i2->idRg2Get();
        if (Compiler::instBranchDelay ((instruction) i1->idIns))
        {
            return (rx == i1->idRegGet ());
        }
        else
        {
            return (((rx == i1->idRegGet ()) || (rx == i1->idRg2Get())));
        }
    }

    /* Play it safe if we're not sure */

    return  true;
}

/*****************************************************************************
 *
 *  Add an instruction with no operands.
 */

void                emitter::emitIns(instruction ins)
{
    instrDesc      *id = emitNewInstr();

    id->idInsFmt = IF_NONE;
    id->idIns    = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  remove an id
 */

void                emitter::delete_id(instrDesc *id_del)
{

#ifdef DEBUG
    emitDispIns(id_del, false, true, false, 0);
#endif

    if ((void*)id_del >= (void*)emitCurIGfreeBase && (void*)emitCurIGfreeNext >= (void*)id_del)
    {
        emitCurIGsize -= emitInstCodeSz(id_del);
        id_del->idIns = INS_ignore;
        id_del->idInsFmt = IF_NONE;
    }

    else
    {

        insGroup    *ig = emitCurIG->igPrev;
        instrDesc   *id = (instrDesc *)ig->igData;
        instrDesc  *tmp = NULL;
        char *ins = (char *) id;
        

        // in retail there is no idNum.  So we have to assume that 
        // the last matching instruction is the correct one.
        for (int i=0; i<ig->igInsCnt; i++)
        {
            id = (instrDesc *)ins;
#ifdef DEBUG
//          emitDispIns(id, false, true, false, 0);
//          fflush(stdout);
#endif
            if (!memcmp(id, id_del, emitSizeOfInsDsc(id))) {
                tmp = id;
            }
            ins = (char *)id + emitSizeOfInsDsc(id);
        }
        assert(tmp);

#ifdef DEBUG
        assert(tmp->idNum == id_del->idNum);
#endif
        ig->igSize -= emitInstCodeSz(tmp);
        emitCurCodeOffset -= emitInstCodeSz(tmp);

        tmp->idIns = INS_ignore;
        tmp->idInsFmt = IF_NONE;
    }
   
    return;
}

/*****************************************************************************
 *
 *  We've just added an instruction with a branch-delay slot. See if it can
 *  be swapped with the previous instruction or whether we may need to add
 *  a nop.
 */

bool                emitter::emitIns_BD(instrDesc * id,
                                        instrDesc * pi,
                                        insGroup  * pg)
{
    /* This should only ever be called for branch-delayed instructions */

#ifdef DEBUG
    assert(Compiler::instBranchDelay(id->idIns));
#endif

#if SCHEDULER

    /* If we're scheduling "for real", we'll take care of this later */

    if  (emitComp->opts.compSchedCode)
        return  true;

#endif

    /* Is there a previous instruction? */

    if  (pi == NULL)
        return  true;

    /* Does the current instruction depend on the previous one? */

    if  (emitInsDepends(pi, id))
        return  true;

    /* Mark the previous instruction to be swapped with the new one */

    pi->idSwap = true;

    return  false;
}

/*****************************************************************************
 *
 *  Add a potentially branch-delaying instruction with no operands.
 */

bool                emitter::emitIns_BD(instruction ins)
{
    instrDesc      *pi = emitLastIns;
    insGroup       *pg = emitCurIG;

    instrDesc      *id = emitNewInstr();

    id->idInsFmt = IF_NONE;
    id->idIns    = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;

    /* Is this actually a branch-delayed instruction? */

    if  (Compiler::instBranchDelay(ins))
        return  emitIns_BD(id, pi, pg);
    else
        return  false;
}

/*****************************************************************************
 *
 *  Add an instruction with a register operand.
 */

void                emitter::emitIns_R(instruction ins,
                                       int         size,
                                       emitRegs   reg)
{
    instrDesc      *id = emitNewInstrTiny(size);

    id->idReg                        = reg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD);
    id->idIns                        = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an instruction referencing a register and a small integer constant.
 */

void                emitter::emitIns_R_I(instruction ins, int size, emitRegs reg,
                                                                    int      val)
{
    instrDesc      *id  = emitNewInstrSC(size, val);
    insFormats      fmt = emitInsModeFormat(ins, IF_RRD_CNS);

#if TGT_SH3
    assert(ins == INS_mov_imm || ins == INS_add_imm || ins == INS_mova || ins == INS_xor);
#else
#error Unexpected target
#endif

    id->idReg             = reg;
    id->idInsFmt          = fmt;
    id->idIns             = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an instruction referencing a register and a small integer constant.
 */

void                emitter::emitIns_I(instruction ins,
                                       int val
#ifdef  DEBUG
                                      ,bool        strlit
#endif
                                       )
{
    instrDesc      *id  = emitNewInstrSC(4, val);
    insFormats      fmt = emitInsModeFormat(ins, IF_RRD_CNS);

    assert(ins == INS_cmpeq || ins == INS_xor_imm);

    id->idInsFmt          = fmt;
    id->idIns             = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}


/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a word/long constant.
 */

void                emitter::emitIns_R_LP_I(emitRegs    reg,
                                           int          size,
                                           int          val,
                                           int          relo_type)
{
    instrDesc      *id;

    /* Figure out whether the operand fits in a 16-bit word */

    if  ((signed short)val == val)
        size = 2;

    /* Create the instruction */

    id                = emitNewInstrLPR(size, CT_INTCNS);

    id->idReg         = reg;
    id->idInsFmt      = IF_RWR_LIT;

#if TGT_SH3
    id->idIns         = INS_mov_PC;
#else
#error Unexpected target
#endif

    id->idAddr.iiaCns = val;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    id->idInfo.idRelocType = relo_type;

    if  (size == 2)
    {
        if  (emitCurIG->igLPuseCntW == 0)
            emitCurIG->igLPuse1stW = emitCurIGsize;

        emitCurIG->igLPuseCntW++;
    }
    else
    {
        if  (emitCurIG->igLPuseCntL == 0)
            emitCurIG->igLPuse1stL = emitCurIGsize;

        emitCurIG->igLPuseCntL++;
    }

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a global variable addr.
 */

void                emitter::emitIns_R_LP_V(emitRegs reg, void *mem)
{
    instrDesc      *id;

    id                = emitNewInstrLPR(sizeof(void*), CT_CLSVAR, mem);
    id->idReg         = reg;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    if  (emitCurIG->igLPuseCntA == 0)
        emitCurIG->igLPuse1stA = emitCurIGsize;

    emitCurIG->igLPuseCntA++;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a method address.
 */

void                emitter::emitIns_R_LP_M(emitRegs    reg,
                                            gtCallTypes callType,
                                            void   *    callHand)
{
    instrDesc      *id;

    id                = emitNewInstrLPR(sizeof(void*), callType, callHand);

    id->idReg         = reg;
    id->idInsFmt      = IF_RWR_LIT;
    id->idIns         = INS_mov_PC;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    if  (emitCurIG->igLPuseCntA == 0)
        emitCurIG->igLPuse1stA = emitCurIGsize;

    emitCurIG->igLPuseCntA++;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

#ifdef BIRCH_SP2
/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a pointer that will
 *  need to be store in the .reloc section.
 */

void                emitter::emitIns_R_LP_P(emitRegs    reg,
                                            void   *    data,
                                             int        relo_type)
{
    instrDesc      *id;

    id                = emitNewInstrLPR(sizeof(void*), CT_RELOCP, data);

    id->idReg         = reg;
    id->idInsFmt      = IF_RWR_LIT;
    id->idIns         = INS_mov_PC;
    
    id->idInfo.idRelocType = relo_type;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    if  (emitCurIG->igLPuseCntA == 0)
        emitCurIG->igLPuse1stA = emitCurIGsize;

    emitCurIG->igLPuseCntA++;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}
#endif  // BIRCH_SP2 only


/*****************************************************************************
 *
 *  Add an instruction with two register operands.
 */

void                emitter::emitIns_R_R(instruction ins,
                                         int         size,
                                         emitRegs    reg1,
                                         emitRegs    reg2)
{
    instrDesc      *id = emitNewInstrTiny(size);

    id->idReg                        = reg1;
    id->idRg2                        = reg2;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_RRD);
    id->idIns                        = ins;


    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an indirect jump through a table (this generates many instructions).
 */

void                emitter::emitIns_JmpTab(emitRegs   reg,
                                            unsigned    cnt,
                                            BasicBlock**tab)
{
    instrDescJmp   *id = emitNewInstrJmp();
    size_t          sz;

    assert(reg != SR_r00);

    id->idIns             = INS_braf;
    id->idInsFmt          = IF_JMP_TAB;
    id->idReg             = reg;
    id->idAddr.iiaBBtable = tab;
    id->idjTemp.idjCount  = cnt;

    /* Record the jump's IG and offset within it */

    id->idjIG             = emitCurIG;
    id->idjOffs           = emitCurIGsize;

    /* Append this jump to this IG's jump list */

    id->idjNext           = emitCurIGjmpList;
                            emitCurIGjmpList = id;

    /* This will take at most 6 instructions + alignment + the table itself */

    id->idjCodeSize = sz  = 6*INSTRUCTION_SIZE + sizeof(short) * 2
                                               + sizeof(void*) * cnt;

    dispIns(id);
    emitCurIGsize += sz;

    /* Force an end to the current IG */

    emitNxtIG();

    /* Remember that we have indirect jumps */

    emitIndJumps = true;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction with a register and an indirection.
 */

void                emitter::emitIns_IMOV(insFormats fmt,
                                          emitRegs  dreg,
                                          emitRegs  areg,
                                          bool       autox,
                                          int        size,
                                          bool       isfloat
                                          )
{
    instrDesc      *id = emitNewInstr(size);

    id->idReg                        = dreg;
    id->idInsFmt                     = fmt;
#if SHX_SH4
    if (!isfloat)
        id->idIns                        = INS_mov_ind;
    else
        id->idIns                        = INS_fmov_ind;
#else
    id->idIns                        = INS_mov_ind;
#endif

    id->idAddr.iiaRegAndFlg.rnfReg   = areg;
    id->idAddr.iiaRegAndFlg.rnfFlg   = autox ? RNF_AUTOX : 0;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction with a register and a "@(r0,reg)" indirection.
 */

void                emitter::emitIns_X0MV(insFormats fmt,
                                         emitRegs  dreg,
                                         emitRegs  areg,
                                         int        size)
{
    instrDesc      *id = emitNewInstr(size);

    id->idReg                        = dreg;
    id->idInsFmt                     = fmt;
    id->idIns                        = fmt == IF_0RD_RRD_XWR ? INS_mov_ix0 : INS_movl_ix0;

    id->idAddr.iiaRegAndFlg.rnfReg   = areg;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction with a register and a "@(reg+disp)" indirection.
 */

void                emitter::emitIns_RDMV(insFormats fmt,
                                          emitRegs   dreg,
                                          emitRegs   areg,
                                          int        offs,
                                          int        size)
{
    instrDesc      *id = emitNewInstrDsp(size, offs);

#ifdef DEBUG

    /* Make sure the displacement is aligned and within range */

    int temp                         = EA_SIZE(size);

    assert(temp == 1 || temp == 2 || temp == 4);
    assert(offs >= 0 && offs <= MAX_INDREG_DISP*temp);
    assert((offs & (temp-1)) == 0);

#endif

    id->idReg                        = dreg;
    id->idInsFmt                     = fmt;
    id->idIns                        = INS_mov_dsp;

    id->idAddr.iiaRegAndFlg.rnfReg   = areg;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a instruction with an indirection and an implied operand (such as PR).
 */

void                emitter::emitIns_IR(emitRegs    reg,
                                        instruction ins,
                                        bool        autox,
                                        int         size)
{
    instrDesc      *id = emitNewInstr(size);

    id->idAddr.iiaRegAndFlg.rnfReg   = reg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_IRD);
    id->idIns                        = ins;

//  id->idAddr.iiaRegAndFlg.rnfReg   = SR_NA;
    id->idAddr.iiaRegAndFlg.rnfFlg   = autox ? RNF_AUTOX : 0;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a instruction with an indirection and an implied operand (such as PR).
 */

void                emitter::emitIns_Ig(instruction ins,
                                        int         val,
                                        int         size)
{
    instrDesc      *id  = emitNewInstrSC(size, val);

    id->idIns                        = ins;

    if (ins == INS_lod_gbr)
        id->idInsFmt                     = emitInsModeFormat(ins, IF_IRD_GBR);
    else
        id->idInsFmt                     = emitInsModeFormat(ins, IF_IWR_GBR);
    
    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  The following add instructions referencing stack-based local variables.
 */

#if 0

void                emitter::emitIns_S(instruction ins,
                                       int         size,
                                       int         varx,
                                       int         offs)
{
    instrDesc      *id = emitNewInstr(size);

    id->idIns                        = ins;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_SRD);

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

#endif

void                emitter::emitIns_S_R(instruction ins,
                                         int         size,
                                         emitRegs    ireg,
                                         int         varx,
                                         int         offs)
{
    instrDesc      *id = emitNewInstr(size);

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_SRD_RRD);

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

void                emitter::emitIns_R_S   (instruction ins,
                                           int         size,
                                           emitRegs   ireg,
                                           int         varx,
                                           int         offs)
{
    instrDesc      *id = emitNewInstr(size);

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_SRD);

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an instruction with an operand off of SP and a register operand.
 */

void                emitter::emitIns_A_R(emitRegs reg, unsigned offs)
{
    instrDesc      *id = emitNewInstr(sizeof(int));

    id->idReg                        = reg;
    id->idInsFmt                     = IF_AWR_RRD;
    id->idIns                        = INS_mov_dsp;
    id->idAddr.iiaCns                = offs;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a jmp instruction.
 */

void                emitter::emitIns_J(instruction ins,
                                       bool        except,
                                       bool        moveable,
                                       BasicBlock *dst)
{
    size_t          sz;
    instrDescJmp  * id = emitNewInstrJmp();

#if SCHEDULER
    assert(except == moveable);
#endif

    assert(dst->bbFlags & BBF_JMP_TARGET);

    id->idInsFmt          = IF_LABEL;
    id->idIns             = ins;
    id->idAddr.iiaBBlabel = dst;

#if SCHEDULER
    if  (except)
        id->idInfo.idMayFault = true;
#endif

    /* Assume the jump will be long */

    id->idjShort          = 0;

    /* The jump may require a branch-delay slot */

    id->idjAddBD          = Compiler::instBranchDelay(ins);

    /* Record the jump's IG and offset within it */

    id->idjIG             = emitCurIG;
    id->idjOffs           = emitCurIGsize;

    /* Append this jump to this IG's jump list */

    id->idjNext           = emitCurIGjmpList;
                            emitCurIGjmpList = id;

#if EMITTER_STATS
    emitTotalIGjmps++;
#endif

    /* Record the offset if this is the first LP use in the group */

    if  (emitCurIG->igLPuseCntL == 0)
        emitCurIG->igLPuse1stL = emitCurIGsize;

    /* We might need a "long" literal pool entry for this call/jump */

    emitCurIG->igLPuseCntL++;

    /* Figure out the max. size of the jump/call instruction */

    if  (ins == INS_bsr)
    {
        /* This is a local call instruction */

        sz = JMP_SIZE_LARGE;
    }
    else
    {
        insGroup    *   tgt;

        assert(ins != INS_jsr);

        /* This is a jump - assume the worst */

        sz = (ins == JMP_INSTRUCTION) ? JMP_SIZE_LARGE
                                      : JCC_SIZE_LARGE;

        // ISSUE: On RISC - one or more literal pools might get in the way,
        // ISSUE: so for now we assume even backward jumps cannot be bound
        // ISSUE: to be short at this stage - we'll have to do it later.
    }

    dispIns(id);

#if SCHEDULER

    if (emitComp->opts.compSchedCode)
    {
        id->idjSched = moveable;

#if!MAX_BRANCH_DELAY_LEN
        if  (!moveable)
        {
            scInsNonSched(id);
        }
        else
#endif
        {
            /*
                This jump is moveable (can be scheduled), and so we'll need
                to figure out the range of offsets it may be moved to after
                it's scheduled (otherwise we wouldn't be able to correctly
                estimate the jump distance).
             */

            id->idjTemp.idjOffs[0] = emitCurIGscdOfs;
            id->idjTemp.idjOffs[1] = emitCurIGscdOfs - 1;
        }
    }
    else
    {
        id->idjSched = false;
    }

#endif

    emitCurIGsize += sz;

    /* Append a "nop" if the branch has delay slot(s) */

#if SCHEDULER && MAX_BRANCH_DELAY_LEN

    if  (id->idjAddBD && emitComp->opts.compSchedCode)
    {
        /* We'll let the "real" scheduler worry about filling the BD slot(s) */

        emitIns(INS_nop); id->idjAddBD = false;
    }

#endif

}

#ifdef BIRCH_SP2
void             emitter::emitIns_CallDir(size_t        argSize,
                                          int           retSize,
#if TRACK_GC_REFS
                                          VARSET_TP     ptrVars,
                                          unsigned      gcrefRegs,
                                          unsigned      byrefRegs,
#endif
                                          unsigned      ftnIndex,
                                          emitRegs      areg)
{
    unsigned        argCnt;

    instrDesc      *id;
    instrDesc      *pd = emitLastIns;

#if     TRACK_GC_REFS

#error  GC ref tracking for RISC is not yet implemented

#ifdef  DEBUG
    if  (verbose) printf("Call : GCvars=%016I64X , gcrefRegs=%04X , byrefRegs=%04X\n",
                                 ptrVars,          gcrefRegs,       byrefRegs);
#endif

#endif

    /* Figure out how many arguments we have */

    argCnt = argSize / sizeof(void*); assert(argSize == argCnt * sizeof(int));

    /* Allocate the instruction descriptor */

#if TRACK_GC_REFS
    id  = emitNewInstrCallInd(argCnt, ptrVars, byrefRegs, retSize);
#else
    id  = emitNewInstrCallInd(argCnt,                     retSize);
#endif

#if SMALL_DIRECT_CALLS

    /* Do we know the previous instruction? */

    OptPEReader *oper =     &((OptJitInfo*)emitComp->info.compCompHnd)->m_PER;
    BYTE        *dstAddr =  (BYTE *)oper->m_rgFtnInfo[ftnIndex].m_pNative;

    if  (pd && dstAddr)
    {
        /* Do we have a direct call sequence? */

        // ISSUE: Should we check whether we can get the address?

        if  (pd->idInsFmt == IF_RWR_LIT        &&
             pd->idIns    == LIT_POOL_LOAD_INS &&
             pd->idRegGet()== areg )
        {
            /* Mark the earlier address load */

            ((instrDescLPR *)pd)->idlCall = id;

            /* Remember that we a direct call candidate */

            emitTotDCcount++;

            // ISSUE: Should we make sure that 'areg' is not callee-saved?
        }
    }

#endif

    /* Set the instruction/format, record the address register */

    id->idIns             = INS_jsr;
    id->idInsFmt          = IF_METHOD;
    id->idReg             = areg;
    id->idAddr.iiaMethHnd = ~0;

#if TRACK_GC_REFS

    /* Update the "current" live GC ref sets */

    emitThisGCrefVars =   ptrVars;
    emitThisGCrefRegs = gcrefRegs;
    emitThisByrefRegs = byrefRegs;

    /* Save the live GC registers in the unused 'rnfReg' field */

    id->idAddr.iiaRegAndFlg.rnfReg = emitEncodeCallGCregs(gcrefRegs);

#endif

    dispIns(id);
    emitCurIGsize   += INSTRUCTION_SIZE;

    /* Append a "nop" if the call is branch-delayed */

    id->idAddr.iiaMethHnd = (CORINFO_METHOD_HANDLE) ftnIndex;
    
    if  (Compiler::instBranchDelay(id->idInsGet()))
        emitIns(INS_nop);
}
#endif  // BIRCH_SP2


/*****************************************************************************
 *
 *  Add a call-via-register instruction.
 */

void                emitter::emitIns_Call(size_t        argSize,
                                          int           retSize,
#if TRACK_GC_REFS
                                          VARSET_TP     ptrVars,
                                          unsigned      gcrefRegs,
                                          unsigned      byrefRegs,
#endif
                                          bool          chkNull,
                                          emitRegs      areg)
{
    unsigned        argCnt;

    instrDesc      *id;
    instrDesc      *pd = emitLastIns;

#if     TRACK_GC_REFS

#error  GC ref tracking for RISC is not yet implemented

#ifdef  DEBUG
    if  (verbose) printf("Call : GCvars=%016I64X , gcrefRegs=%04X , byrefRegs=%04X\n",
                                 ptrVars,          gcrefRegs,       byrefRegs);
#endif

#endif

    /* Figure out how many arguments we have */

    argCnt = argSize / sizeof(void*); assert(argSize == argCnt * sizeof(int));

    /* Allocate the instruction descriptor */

#if TRACK_GC_REFS
    id  = emitNewInstrCallInd(argCnt, ptrVars, byrefRegs, retSize);
#else
    id  = emitNewInstrCallInd(argCnt,                     retSize);
#endif

#if SMALL_DIRECT_CALLS

    /* Do we know the previous instruction? */

    if  (pd)
    {
        /* Do we have a direct call sequence? */

        // ISSUE: Should we check whether we can get the address?

        if  (pd->idInsFmt == IF_RWR_LIT        &&
             pd->idIns    == LIT_POOL_LOAD_INS &&
             pd->idRegGet()== areg )
        {
            /* Mark the earlier address load */

            ((instrDescLPR *)pd)->idlCall = id;

            /* Remember that we a direct call candidate */

            emitTotDCcount++;

            // ISSUE: Should we make sure that 'areg' is not callee-saved?
        }
    }

#endif

    /* Set the instruction/format, record the address register */

    id->idIns             = INS_jsr;
    id->idInsFmt          = IF_METHOD;
    id->idReg             = areg;
    id->idAddr.iiaMethHnd = ~0;

#if TRACK_GC_REFS

    /* Update the "current" live GC ref sets */

    emitThisGCrefVars =   ptrVars;
    emitThisGCrefRegs = gcrefRegs;
    emitThisByrefRegs = byrefRegs;

    /* Save the live GC registers in the unused 'rnfReg' field */

    id->idAddr.iiaRegAndFlg.rnfReg = emitEncodeCallGCregs(gcrefRegs);

#endif

    /* Is this a call via a function pointer which could be NULL? */

    if  (chkNull)
        id->idInfo.idMayFault;

#ifdef  DEBUG
    if  (verbose&&0)
    {
        if  (id->idInfo.idLargeCall)
            printf("[%02u] Rec call GC vars = %016I64X\n", id->idNum, ((instrDescCIGCA*)id)->idciGCvars);
    }
#endif

    dispIns(id);
    emitCurIGsize   += INSTRUCTION_SIZE;

    /* Append a "nop" if the call is branch-delayed */

    //id->idjAddBD          = Compiler::instBranchDelay(ins);
    if  (Compiler::instBranchDelay(id->idInsGet()))
        emitIns(INS_nop);
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Display the given instruction.
 */

void                emitter::emitDispIns(instrDesc *id, bool isNew,
                                                        bool doffs,
                                                        bool asmfm, unsigned offs)
{
    unsigned        sp;
    int             size;
    char            name[16];

#ifdef BIRCH_SP2
    if (!verbose)
        return;
#endif

    instruction     ins = id->idInsGet(); assert(ins != INS_none);

//  printf("[F=%s] "   , emitIfName(id->idInsFmt));
//  printf("INS#%03u: ", id->idNum);
//  printf("[S=%02u] " , emitCurStackLvl/sizeof(int));
//  printf("[A=%08X] " , emitSimpleStkMask);
//  printf("[A=%08X] " , emitSimpleByrefStkMask);

    if  (!dspEmit && !isNew && !asmfm)
        doffs = true;

    /* Display the instruction offset */

    emitDispInsOffs(offs, doffs);

    /* Get hold of the instruction name */

    strcpy(name, emitComp->genInsName(ins));

    /* Figure out the operand size */


    size = emitDecodeSize(id->idOpSize);

#if TRACK_GC_REFS
    switch(id->idGCrefGet())
    {
    case GCT_GCREF:     size = EA_GCREF; break;
    case GCT_BYREF:     size = EA_BYREF; break;
    case GCT_NONE:                       break;
#ifdef DEBUG
    default:            assert(!"bad GCtype");
#endif
    }
#endif

    switch (id->idInsFmt)
    {
        char    *   suffix;

    case IF_NONE:
    case IF_LABEL:
        break;

    case IF_DISPINS:
        goto NO_NAME;

    default:

        switch (ins)
        {
        case INS_jsr:
#if SMALL_DIRECT_CALLS
        case INS_bsr:
#endif
        case INS_cmpPL:
        case INS_cmpPZ:
            suffix = "";
            break;

        case INS_mov_imm:
            suffix = ".b";
            break;

        case INS_add_imm:
            suffix = ".l";
            break;

        case INS_extsb:
        case INS_extub:
            suffix = ".b";
            break;

        case INS_extsw:
        case INS_extuw:
            suffix = ".w";
            break;

        default:

            switch (size)
            {
            case 1:
                suffix = ".b";
                break;
            case 2:
                suffix = ".w";
                break;
            default:
                suffix = ".l";
                break;
            }
        }

        strcat(name, suffix);
        break;
    }

    /* Display the full instruction name */

    printf(EMIT_DSP_INS_NAME, name);

    /* If this instruction has just been added, check its size */

    assert(isNew == false || (int)emitSizeOfInsDsc(id) == emitCurIGfreeNext - (BYTE*)id);

NO_NAME:

    /* We keep track of the number of characters displayed (for alignment) */

    sp = 20;

#define TMPLABFMT "J_%u"

    /* Now see what instruction format we've got */

    switch (id->idInsFmt)
    {
        emitRegs       rg1;
        emitRegs       rg2;
        unsigned        flg;

        const char  *   rnm;
        const char  *   xr1;
        const char  *   xr2;

        void        *   mem;

        int             val;
        int             offs;

        instrDesc   *   idr;
        unsigned        idn;

        const char  *   methodName;
        const char  *    className;

    case IF_DISPINS:

        idr = ((instrDescDisp*)id)->iddId;
        idn = ((instrDescDisp*)id)->iddNum;

        switch (idr->idInsFmt)
        {
            dspJmpInfo *    info;

        case IF_JMP_TAB:
            {
            info = (dspJmpInfo*)((instrDescDisp*)id)->iddInfo;

            static
            BYTE            sizeChar[] =
            {
                'b',    // IJ_UNS_I1
                'b',    // IJ_UNS_U1
                'b',    // IJ_SHF_I1
                'b',    // IJ_SHF_U1

                'w',    // IJ_UNS_I2
                'w',    // IJ_UNS_U2

                'l',    // IJ_UNS_I4
            };

            switch (idn)
            {
            case 0:
            case 9:
                printf(EMIT_DSP_INS_NAME, ".align");
                printf("4");
                break;

            case 1:
                printf(EMIT_DSP_INS_NAME, emitComp->genInsName(info->iijIns));
                printf("%s", emitRegName(info->iijInfo.iijReg));
                break;

            case 2:
                printf(EMIT_DSP_INS_NAME, "mova.l");
                printf(TMPLABFMT, info->iijLabel+1);
                break;

            case 3:
                sprintf(name, "mov.%c", sizeChar[info->iijKind]);
                printf(EMIT_DSP_INS_NAME, name);
                printf("@(%s,r0),r0", emitRegName(id->idRegGet()));
                break;

            case 4:
                strcpy(name, emitComp->genInsName(info->iijIns));
                strcat(name, info->iijIns == INS_extub ? ".b" : ".w");
                printf(EMIT_DSP_INS_NAME, name);
                printf("%s", emitRegName(info->iijInfo.iijReg));
                break;

            case 5:
                printf(EMIT_DSP_INS_NAME, "shll.l");
                printf("%s", emitRegName(info->iijInfo.iijReg));
                break;

            case 6:
                printf(EMIT_DSP_INS_NAME, "braf");
                printf(emitRegName(SR_r00));
                break;

            case 7:
                printf(EMIT_DSP_INS_NAME, "nop");
                break;

            case 8:
                printf("  "TMPLABFMT":", info->iijLabel);
                break;

            case 10:
                printf("  "TMPLABFMT":", info->iijLabel+1);
                break;

            case 99:
                sprintf(name, ".data.%c", sizeChar[info->iijKind]);
                printf(EMIT_DSP_INS_NAME, name);
                printf("G_%02u_%02u - ", Compiler::s_compMethodsCount,
                                         info->iijTarget);
                printf(TMPLABFMT, info->iijLabel);
                break;

            default:
#ifdef  DEBUG
                printf("Index = %u\n", idn);
#endif
                assert(!"unexpected indirect jump display index");
            }
            }
            break;

        case IF_LABEL:

            if  (((instrDescJmp*)idr)->idjShort)
            {
                printf(EMIT_DSP_INS_NAME, "nop");
                printf("%*c; branch-delay slot", 20, ' ');
                break;
            }

            if  (ins != INS_xtrct)
                printf(EMIT_DSP_INS_NAME, name);

            info = (dspJmpInfo*)((instrDescDisp*)id)->iddInfo;

            if  (((instrDescJmp*)idr)->idjMiddle)
            {
                switch (idn)
                {
                case 0:
                    sp -= printf(TMPLABFMT, info->iijLabel);
                    printf("%*c; pc+2", sp, ' ');
                    break;
                case 1:
                    printf("G_%02u_%02u", Compiler::s_compMethodsCount, idr->idAddr.iiaIGlabel->igNum);
                    break;
                case 2:
                    break;
                case 3:
                    printf(TMPLABFMT ":", info->iijLabel);
                    break;
                default:
                    assert(!"unexpected 'special' medium jump display format");
                }
            }
            else
            {
                switch (idn)
                {
                case 0:
                default:
                    assert(!"unexpected 'special' long jump display format");
                }
            }

            break;

        default:
            assert(!"unexpected 'special' instruction display format");
        }

        break;

    case IF_RRD:
    case IF_RWR:
    case IF_RRW:

        xr1 = xr2 = NULL;

        switch (ins)
        {
        case INS_ldsmach: xr2 = "mach"; break;
        case INS_ldsmacl: xr2 = "macl"; break;
        case INS_ldspr  : xr2 = "PR"  ; break;
        case INS_stsmach: xr1 = "mach"; break;
        case INS_stsmacl: xr1 = "macl"; break;
        case INS_stspr  : xr1 = "PR"  ; break;
        }

        if  (xr1) printf("%s,", xr1);
        printf("%s", emitRegName(id->idRegGet()));
        if  (xr2) printf(",%s", xr2);
        break;

    case IF_RRD_CNS:
    case IF_RWR_CNS:
    case IF_RRW_CNS:
#if DSP_SRC_OPER_LEFT
        printf("#%d,%s", emitGetInsSC(id), emitRegName(id->idRegGet()));
#else
        printf("%s,#%d", emitRegName(id->idRegGet()), emitGetInsSC(id));
#endif
        break;

    case IF_RWR_LIT:

        if  (emitDispInsExtra)
        {
            unsigned    sp = 20;

#if SMALL_DIRECT_CALLS
            if  (ins == INS_bsr)
                sp -= printf("%+d", emitDispLPaddr);
            else
#endif
                sp -= printf("@(%u,pc),%s", emitDispLPaddr, emitRegName(id->idRegGet()));

            printf("%*c; ", sp, ' ');
        }

        mem = id->idAddr.iiaMembHnd;

        switch (emitGetInsLPRtyp(id))
        {
        case CT_INTCNS:
            if  (emitDispInsExtra)
            {
                if  ((int)mem > 0)
                    printf("0x%08X=", mem);

                printf("%d", mem);
            }
            else
                printf("#%d", mem);
            break;

#ifdef BIRCH_SP2

        case CT_RELOCP:
            if  (emitDispInsExtra)
            {
                if  ((int)mem > 0)
                    printf(".reloc 0x%08X=", mem);

                printf("%d", mem);
            }
            else
                printf(".reloc #%d", mem);
            break;

#endif

        case CT_CLSVAR:

#if SMALL_DIRECT_CALLS
            if  (ins != INS_bsr)
#endif
                printf("&");

            emitDispClsVar((CORINFO_FIELD_HANDLE) mem, 0);
            break;

        default:

#if SMALL_DIRECT_CALLS
            if  (ins != INS_bsr)
#endif
                printf("&");

            methodName = emitComp->eeGetMethodName((CORINFO_METHOD_HANDLE) mem, &className);

            if  (className == NULL)
                printf("'%s'", methodName);
            else
                printf("'%s.%s'", className, methodName);

            break;
        }

        if  (!emitDispInsExtra)
            printf(",%s", emitRegName(id->idRegGet()));

        break;

    case IF_RRD_RRD:
    case IF_RWR_RRD:
    case IF_RRW_RRD:
#if DSP_SRC_OPER_LEFT
        printf("%s,", emitRegName(id->idRg2Get()));
        printf("%s" , emitRegName(id->idRegGet()));
#else
        printf("%s,", emitRegName(id->idRegGet()));
        printf("%s" , emitRegName(id->idRg2Get()));
#endif
        break;

    case IF_IRD:
    case IF_IWR:

        switch (ins)
        {
        case INS_ldspr  :
        case INS_stspr  : rnm =   "pr"; break;

        case INS_ldcgbr :
        case INS_stcgbr : rnm =  "GBR"; break;

        case INS_ldsmach:
        case INS_stsmach: rnm = "mach"; break;

        case INS_ldsmacl:
        case INS_stsmacl: rnm = "macl"; break;

        default:
            assert(!"unexpected instruction");
        }

        rg1 = (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg;
        flg =           id->idAddr.iiaRegAndFlg.rnfFlg;

        if  (id->idInsFmt == IF_IRD)
        {
            printf("%s,", rnm);
            emitDispIndAddr(rg1,  true, (flg & RNF_AUTOX) != 0);
        }
        else
        {
            emitDispIndAddr(rg1, false, (flg & RNF_AUTOX) != 0);
            printf(",%s", rnm);
        }
        break;

#if DSP_DST_OPER_LEFT
    case IF_IRD_RWR:
#else
    case IF_RRD_IWR:
#endif

        rg1 = id->idRegGet();
        rg2 = (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg;
        flg = id->idAddr.iiaRegAndFlg.rnfFlg;

        emitDispIndAddr(rg2, false, (flg & RNF_AUTOX) != 0);
        printf(",%s", emitRegName(rg1));
        break;

#if DSP_DST_OPER_LEFT
    case IF_RRD_IWR:
#else
    case IF_IRD_RWR:
#endif

        rg1 = id->idRegGet();
        rg2 = (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg;
        flg = id->idAddr.iiaRegAndFlg.rnfFlg;

        printf("%s,", emitRegName(rg1));
        emitDispIndAddr(rg2, true, (flg & RNF_AUTOX) != 0);
        break;

    case IF_RRD_SRD:    // reg <- stk
    case IF_RWR_SRD:    // reg <- stk
    case IF_RRW_SRD:    // reg <- stk

#if DSP_DST_OPER_LEFT
        printf("%s,", emitRegName(id->idRegGet(), size));
#endif

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);


#if DSP_SRC_OPER_LEFT
        printf(",%s", emitRegName(id->idRegGet(), size));
#endif

        break;

    case IF_SRD_RRD:    // stk <- reg
    case IF_SWR_RRD:    // stk <- reg
    case IF_SRW_RRD:    // stk <- reg

#if DSP_SRC_OPER_LEFT
        printf("%s,", emitRegName(id->idRegGet(), size));
#endif

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);


#if DSP_DST_OPER_LEFT
        printf(",%s", emitRegName(id->idRegGet(), size));
#endif

        break;

    case IF_AWR_RRD:

#if DSP_SRC_OPER_LEFT
        printf("%s,", emitRegName(id->idRegGet(), size));
#endif
        printf("@(sp,%u)", id->idAddr.iiaCns);
#if DSP_DST_OPER_LEFT
        printf(",%s", emitRegName(id->idRegGet(), size));
#endif

        break;

#if DSP_SRC_OPER_LEFT
    case IF_0RD_RRD_XWR:
#else
    case IF_0RD_XRD_RWR:
#endif
        printf("%s,@(r0,%s)", emitRegName(id->idRegGet(), size),
                              emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, sizeof(void*)));
        break;

#if DSP_SRC_OPER_LEFT
    case IF_0RD_XRD_RWR:
#else
    case IF_0RD_RRD_XWR:
#endif
        printf("@(r0,%s),%s", emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, size),
                              emitRegName(id->idRegGet(),             sizeof(void*)));
        break;

#if DSP_SRC_OPER_LEFT
    case IF_DRD_RWR:
#else
    case IF_RRD_DWR:
#endif
        printf("@(%s,%d),%s", emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, size),
                              emitGetInsDsp(id),
                              emitRegName(id->idRegGet(),             sizeof(void*)));
        break;

#if DSP_SRC_OPER_LEFT
    case IF_RRD_DWR:
#else
    case IF_DRD_RWR:
#endif
        printf("%s,@(%s,%d)", emitRegName(id->idRegGet(),             sizeof(void*)),
                              emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, size),
                              emitGetInsDsp(id));
        break;

    case IF_NONE:
        break;

    case IF_LABEL:

//      if  (((instrDescJmp*)id)->idjShort ) printf("SHORT ");
//      if  (((instrDescJmp*)id)->idjMiddle) printf("MIDDLE");

        if  (id->idInfo.idBound)
        {
            printf("G_%02u_%02u", Compiler::s_compMethodsCount, id->idAddr.iiaIGlabel->igNum);
        }
        else
        {
            printf("L_%02u_%02u", Compiler::s_compMethodsCount, id->idAddr.iiaBBlabel->bbNum);
        }

        if  (emitDispInsExtra)
            printf("             ; pc%+d", emitDispJmpDist);

        break;

    case IF_METHOD:

        sp -= printf("@%s", emitRegName(id->idRegGet()));

        if  (id->idInfo.idLargeCall)
        {
            // CONSIDER: Display GC info
        }
        break;

    case IF_JMP_TAB:
        printf("<indirect jump>");
        break;

    case IF_IRD_RWR_GBR:
        printf("@(#%d,GBR),%s", emitGetInsSC(id), emitRegName(id->idRegGet(),             sizeof(void*)));
        break;

    case IF_RRD_IWR_GBR:
        printf("%s, @(#%d,GBR)", emitRegName(id->idRegGet(), sizeof(void*)), emitGetInsSC(id));
        break;


    default:

        printf("unexpected SH-3 instruction format %s\n", emitIfName(id->idInsFmt));

        BreakIfDebuggerPresent();
        assert(!"oops");
        break;
    }

    emitDispInsExtra = false;

    printf("\n");
}

/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************
 *
 *  Finalize the modes and sizes of all indirect jumps.
 *
 */

void                emitter::emitFinalizeIndJumps()
{
    /* Do we have any table jumps? */

    if  (emitIndJumps)
    {
        unsigned        ofs;
        instrDescJmp *  jmp;

        insGroup    *   ig1 = NULL;

        /* Fix the size of all table jumps; start by finding the first one */

        for (jmp = emitJumpList; jmp; jmp = jmp->idjNext)
        {
            insGroup  *     jmpIG;

            unsigned        jmpCnt;
            BasicBlock  * * jmpTab;

            unsigned        srcNeg;
            unsigned        srcPos;
            unsigned        srcOfs;

            int             minOfs;
            int             maxOfs;

            emitIndJmpKinds   kind;

            size_t          size;
            size_t          adrs;
            size_t          diff;

            if  (jmp->idInsFmt != IF_JMP_TAB)
                continue;

            jmpIG = jmp->idjIG;

            /* Remember the group of the first indirect jump */

            if  (!ig1) ig1 = jmpIG;

            /* Compute the max. distance of any entry in the table */

            jmpCnt = jmp->idjTemp.idjCount;
            jmpTab = jmp->idAddr.iiaBBtable;

            /* Estimate the source offsets for the jump */

            srcOfs = jmpIG->igOffs + jmpIG->igSize - jmp->idjCodeSize;
            srcNeg = jmpIG->igOffs + jmpIG->igSize - jmpCnt * sizeof(void*);
            srcPos = jmpIG->igOffs + jmpIG->igSize - roundUp(jmpCnt, INSTRUCTION_SIZE);

//          printf("Estimated offs/size/end of ind jump: %04X/%02X/%04X\n", srcOfs, jmp->idjCodeSize, jmpIG->igOffs + jmpIG->igSize);

            /* Compute the max. distance of any entry in the table */

            minOfs = INT_MAX & ~1;
            maxOfs = INT_MIN & ~1;

            do
            {
                insGroup    *   tgt;
                unsigned        ofs;
                int             dif;
#ifdef  DEBUG
                unsigned        src = 0xDDDD;
#endif

                /* Get the target IG of the entry */

                tgt = (insGroup*)emitCodeGetCookie(*jmpTab); assert(tgt);
                ofs = tgt->igOffs;

                /* Is the target before or after our jump? */

                if  (ofs > srcPos)
                {
                    /* Compute the positive distance estimate */

                    dif = ofs - srcPos; assert(dif > 0);
#ifdef  DEBUG
                    src = srcPos;
#endif

                    if  (maxOfs < dif) maxOfs = dif;
                }
                else
                {
                    /* Compute the negative distance estimate */

                    dif = tgt->igOffs - srcNeg; assert(dif < 0);
#ifdef  DEBUG
                    src = srcNeg;
#endif

                    if  (minOfs > dif) minOfs = dif;
                }

#ifdef  DEBUG
                if  (verbose)
                {
                    printf("Indirect jump entry: %04X -> %04X (dist=%d)\n", src,
                                                                            tgt->igOffs,
                                                                            dif);
                }
#endif

            }
            while (++jmpTab, --jmpCnt);

            /* The distance should be multiple of instruction size */

            assert((minOfs & 1) == 0);
            assert((maxOfs & 1) == 0);

#ifdef  DEBUG
            if  (verbose)
            {
                if (minOfs < 0) printf("Max. negative distance = %d\n", minOfs);
                if (maxOfs > 0) printf("Max. positive distance = %d\n", maxOfs);

                printf("Base offset: %04X\n", srcOfs);
            }
#endif

            /*
                Compute the total size:

                    2   alignment                    [optional]
                    2   mova  instruction
                    2   load of distance value
                    2   extu  instruction            [optional]
                    2   shift instruction            [optional]
                    2   braf  instruction
                    2   delay slot
                    2   alignment                    [optional]
                    x   jump table
             */

            size = 2 + 2 + 2 + 2;   // mova + mov + braf + delay slot

            /* Add alignment, if necessary */

//            if  (srcOfs & 2)
                size   += 2;

            minOfs -= 8;
            maxOfs += 8;
            /* How big will the table entries need to be? */

            if      (minOfs >=   SCHAR_MIN && maxOfs <=   SCHAR_MAX)
            {
                /* We'll use           signed  byte distances */

                kind = IJ_UNS_I1;
                adrs = 1;
            }
            else if (minOfs >=           0 && maxOfs <=   UCHAR_MAX)
            {
                /* We'll use         unsigned  byte distances */

                kind = IJ_UNS_U1;
                size = size + 2;
                adrs = 1;
            }
            else if (minOfs >= 2*SCHAR_MIN && maxOfs <= 2*SCHAR_MAX)
            {
                /* We'll use shifted   signed byte distances */

                kind = IJ_SHF_I1;
                size = size + 2;
                adrs = 1;
            }
            else if (minOfs >=           0 && maxOfs <= 2*UCHAR_MAX)
            {
                /* We'll use shifted unsigned  byte distances */

                kind = IJ_SHF_U1;
                size = size + 4;
                adrs = 1;
            }
            else if (minOfs >=    SHRT_MIN && maxOfs <=    SHRT_MAX)
            {
                /* We'll use           signed word distances */

                kind = IJ_UNS_I2;
                size = size + 2;
                adrs = 2;
            }
            else if (minOfs >=           0 && maxOfs <=   USHRT_MAX)
            {
                /* We'll use         unsigned word distances */

                kind = IJ_UNS_U2;
                size = size + 4;
                adrs = 2;
            }
            else
            {
                /* We'll use           signed long distances */

                kind = IJ_UNS_I4;
                size = size + 2;
                adrs = 4;
            }

            /* Align the table if necessary */

            srcOfs += size;

//            if  (srcOfs & 2)
//                size += 2;

            /* Remember what kind of of a jump we're planning to use */

            jmp->idjJumpKind = kind;

            /* Total size = size of code + size of table */

            size += roundUp(adrs * jmp->idjTemp.idjCount, INSTRUCTION_SIZE);
            size += 4;

            /* Figure out the size adjustment */

            diff  = jmp->idjCodeSize - size; assert((int)diff >= 0);

            /* Update the code size and adjust the instruction group size */

            jmp  ->idjCodeSize = size;
            jmpIG->igSize     -= diff;


            /* Update offsets of IG's that follow the 1st adjusted one */

            for (ofs = ig1->igOffs;;)
            {
                ofs += ig1->igSize;
                ig1  = ig1->igNext;
                if  (!ig1)
                    break;
                ig1->igOffs = ofs;
            }
#ifdef  DEBUG
            if  (verbose)
            {
                printf("\nInstruction list after an adjustment:\n\n");
                emitDispIGlist(true);
            }
#endif
    }

        /* Update the total code size of the method */

        emitTotalCodeSize = ofs;

        emitCheckIGoffsets();
    }
}

/*****************************************************************************
 *
 *  Returns the base encoding of the given CPU instruction.
 */

inline
unsigned            insCode(instruction ins)
{
    static
    unsigned        insCodes[] =
    {
        #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) i1,
        #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) i1,
        #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) i1,
        #include "instrSH3.h"
        #undef  INST1
        #undef  INST2
        #undef  INST3
    };

    assert(ins < sizeof(insCodes)/sizeof(insCodes[0]));
    assert((insCodes[ins] != BAD_CODE));

    return  insCodes[ins];
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes a single register.
 */

inline
unsigned            insCode_RV(instruction ins, emitRegs reg)
{
    return  insCode(ins) | (reg << 8);
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes a single immed and implied R0
 */

inline
unsigned            insCode_IV(instruction ins, int icon)
{
    static
    unsigned        insCodes[] =
    {
        #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) 0,
        #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) 0, 
        #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) i2,
        #include "instrSH3.h"
        #undef  INST1
        #undef  INST2
        #undef  INST3
    };

    assert(ins < sizeof(insCodes)/sizeof(insCodes[0]));
    assert((insCodes[ins] != BAD_CODE));

    return  insCodes[ins] | (icon & 0xFF);
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes a register and integer constant operands.
 */

inline
unsigned            insCode_RV_IV(instruction ins, emitRegs reg, int icon)
{
    assert(icon == (signed char)icon);

    assert(ins == INS_mov_imm || ins == INS_add_imm || ins == INS_mova || ins == INS_xor_imm);

    return  insCode(ins) | (reg << 8) | (icon & 0xFF);
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes two register operands.
 */

inline
unsigned            insCode_R1_R2(instruction ins, emitRegs rg1, emitRegs rg2)
{
    return  insCode(ins) | (rg1 << 4) | (rg2 << 8);
}

/*****************************************************************************
 *
 *  Output an instruction that references a register and an indirection
 *  given by "irg+dsp" (if 'rdst' is non-zero, the register is the target).
 */

BYTE    *           emitter::emitOutputRIRD(BYTE *dst, instruction ins,
                                                       emitRegs    reg,
                                                       emitRegs    irg,
                                                       unsigned    dsp,
                                                       bool        rdst)
{
    unsigned        code = insCode(ins);

    assert(dsp < 64);
    assert(dsp % 4 == 0);

    if  (rdst)
    {
        code |= (irg << 4) | (reg << 8) | 0x4000;
    }
    else
    {
        code |= (reg << 4) | (irg << 8);
    }

    return  dst + emitOutputWord(dst, code | dsp >> 2);
}

/*****************************************************************************
 *
 *  Output an instruction that (directly) references a stack frame location
 *  and a register (if 'rdst' is non-zero, the register is the target).
 */

BYTE    *           emitter::emitOutputSV(BYTE *dst, instrDesc *id, bool rdst)
{
    bool            FPbased;

    emitRegs        base;
    unsigned        addr;

    assert(id->idIns == INS_mov_dsp);

    addr = emitComp->lvaFrameAddress(id->idAddr.iiaLclVar.lvaVarNum, &FPbased);

    base = FPbased ? (emitRegs)REG_FPBASE
                   : (emitRegs)REG_SPBASE;

    return  emitOutputRIRD(dst, id->idInsGet(),
                                id->idRegGet(),
                                base,
                                addr + id->idAddr.iiaLclVar.lvaOffset,
                                rdst);
}

/*****************************************************************************
 *
 *  Return the number of bytes of machine code the given instruction will
 *  produce.
 */

size_t              emitter::emitSizeOfJump(instrDescJmp *jmp)
{
    size_t          sz;

    assert(jmp->idInsFmt == IF_LABEL);

    if      (jmp->idjShort)
    {
        sz = INSTRUCTION_SIZE;

        if  (jmp->idjAddBD)
            sz += INSTRUCTION_SIZE;
    }
    else if (jmp->idjMiddle)
    {
        sz = JCC_SIZE_MIDDL;
    }
    else
    {
        sz = emitIsCondJump(jmp) ? JCC_SIZE_LARGE
                                 : JMP_SIZE_LARGE;
    }

    return  sz;
}

/*****************************************************************************
 *
 *  Output a local jump instruction.
 */

BYTE    *           emitter::emitOutputLJ(BYTE *dst, instrDesc *i)
{
    unsigned        srcOffs;
    unsigned        dstOffs;
    int             jmpDist;

    assert(i->idInsFmt == IF_LABEL);

    instrDescJmp *  id  = (instrDescJmp*)i;
    instruction     ins = id->idInsGet();

#ifdef DEBUG

    /* Crate a fake instruction for display purposes */

    instrDescDisp   disp;
    dspJmpInfo      info;

    disp.idInsFmt = IF_DISPINS;
    disp.iddInfo  = &info;
    disp.iddNum   = 0;
    disp.iddId    = id;

#endif

    /* Figure out the distance to the target */

    srcOffs = emitCurCodeOffs(dst);
    dstOffs = id->idAddr.iiaIGlabel->igOffs;
    jmpDist = dstOffs - srcOffs;

    /* Is the jump a forward one and are we scheduling? */

#if SCHEDULER

    if  (emitComp->opts.compSchedCode && jmpDist > 0)
    {
        /* The jump distance might change later */

        emitFwdJumps = true;

        /* Record the target offset and the addr of the distance value */

        id->idjOffs         = dstOffs;
        id->idjTemp.idjAddr = dst;
    }
    else
        id->idjTemp.idjAddr = NULL;

#endif

    /* Is the jump short, medium, or long? */

    if  (id->idjShort)
    {
        /* The distance is computed from after the jump */

        jmpDist -= INSTRUCTION_SIZE * 2;

#ifdef  DEBUG

        if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
        {
            size_t      blkOffs = id->idjIG->igOffs;

            if  (INTERESTING_JUMP_NUM == 0)
            printf("[3] Jump %u:\n", id->idNum);
//          printf("[3] Jump  block is at %08X\n", blkOffs);
            printf("[3] Jump        is at %08X\n", srcOffs);
            printf("[3] Label block is at %08X\n", dstOffs);
            printf("[3] Jump is from      %08X\n", dstOffs - jmpDist);
            printf("[3] Jump distance  is %04X\n", jmpDist);
        }

        /* The distance better fit in the jump's range */

        size_t      exsz = id->idjAddBD ? INSTRUCTION_SIZE : 0;

        if  (emitIsCondJump(id))
        {
            assert(emitSizeOfJump(id) == JCC_SIZE_SMALL + exsz);
            assert(jmpDist >= JCC_DIST_SMALL_MAX_NEG &&
                   jmpDist <= JCC_DIST_SMALL_MAX_POS);
        }
        else
        {
            assert(emitSizeOfJump(id) == JMP_SIZE_SMALL + exsz);
            assert(jmpDist >= JMP_DIST_SMALL_MAX_NEG &&
                   jmpDist <= JMP_DIST_SMALL_MAX_POS);
        }

#endif

        /* Now issue the instruction */

#ifdef  DEBUG
        if  (emitDispInsExtra)
        {
            emitDispJmpDist  = jmpDist;
            emitDispIns(id, false, dspGCtbls, true, emitCurCodeOffs(dst));
            emitDispInsExtra = false;
        }
#endif

        /* The distance is scaled automatically */

        assert((jmpDist & 1) == 0); jmpDist >>= 1;

        /* What kind of a jump do we have? */

        switch (ins)
        {
        case INS_bra:

            if (jmpDist)/* The distance is a 12-bit number */
                dst += emitOutputWord(dst, insCode(ins) | (jmpDist & 0x0FFF));
            else
                dst += emitOutputWord(dst, insCode(INS_nop));
            break;

        case INS_bsr:

            /* The distance is a 12-bit number */
            dst += emitOutputWord(dst, insCode(ins) | (jmpDist & 0x0FFF));
            break;

        case INS_bt:
        case INS_bts:
        case INS_bf:
        case INS_bfs:

            /* The distance is an 8-bit number */

            dst += emitOutputWord(dst, insCode(ins) | (jmpDist & 0x00FF));
            break;

        default:
            assert(!"unexpected SH-3 jump");
        }

        /* Some jumps need a branch delay slot */

        if  (id->idjAddBD)
        {

#ifdef DEBUG
            disp.idIns = INS_nop;
            dispSpecialIns(&disp, dst);
#endif

            dst += emitOutputWord(dst, insCode(INS_nop));
        }

        return  dst;
    }

    if  (id->idjMiddle)
    {
        instruction     ins;

        /* This is a medium-size jump (it must be a conditional one) */

        assert(emitIsCondJump(id));

        /*
            Generate the following sequence for bt/bf label:

                    bf/bt skip
                    bra   label
                    nop
               skip:

            First reverse the sense of the condition.
         */

        assert(id->idIns == INS_bt  ||
               id->idIns == INS_bts ||
               id->idIns == INS_bf  ||
               id->idIns == INS_bfs);

        switch (id->idIns)
        {
        case INS_bf : ins = INS_bt ; break;
        case INS_bfs: ins = INS_bts; break;
        case INS_bt : ins = INS_bf ; break;
        case INS_bts: ins = INS_bfs; break;

        default:
            assert(!"unexpected medium jump");
        }

        /* Generate (and optionally display) the flipped conditional jump */

#ifdef DEBUG
        disp.iddNum   = 0;
        disp.idIns    = ins;
        info.iijLabel = emitTmpJmpCnt; emitTmpJmpCnt++;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(ins) | 1);

        /* Update the distance of the unconditional jump */

        jmpDist -= INSTRUCTION_SIZE * 3;

        assert(jmpDist >= JMP_DIST_SMALL_MAX_NEG &&
               jmpDist <= JMP_DIST_SMALL_MAX_POS);

#ifdef DEBUG
        disp.idIns = INS_bra;
        dispSpecialIns(&disp, dst);
#endif

        /* The distance is a 12-bit number */

        dst += emitOutputWord(dst, insCode(INS_bra) | (jmpDist >> 1 & 0x0FFF));

        /* Fill in the branch-delay slot with a nop */

#ifdef DEBUG
        disp.idIns = INS_nop;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(INS_nop));

        /* Display the "skip" temp label */

#ifdef DEBUG
        disp.idIns = INS_xtrct;  // just a hack to suppress instruction display
        dispSpecialIns(&disp, dst);
#endif

    }
    else
    {
        // long branch
        instruction     ins;

        switch (id->idIns)
        {
        case INS_bf : ins = INS_bt ; break;
        case INS_bfs: ins = INS_bts; break;
        case INS_bt : ins = INS_bf ; break;
        case INS_bra: ins = INS_bf ; break;
        case INS_bts: ins = INS_bfs; break;
        default:
            assert(!"unexpected medium jump");
        }
        

        if (emitIsCondJump(id))
        {
            // take 7 instructions 
            int align = 1;
            
            dst += emitOutputWord(dst, insCode(ins) | 5);
            unsigned code = insCode(INS_mov_PC);
            code |= 0x4000; // load 4 byte constant
            dst += emitOutputWord(dst, code | 1);
            dst += emitOutputWord(dst, insCode(INS_braf));
            dst += emitOutputWord(dst, insCode(INS_nop));

            if  (emitCurCodeOffs(dst) & 2) {
                dst += emitOutputWord(dst, insCode(INS_nop));
                align = 0;
            }

            srcOffs = emitCurCodeOffs(dst);
            jmpDist = dstOffs - srcOffs;
            dst += emitOutputWord(dst, jmpDist & 0xffff);
            dst += emitOutputWord(dst, (jmpDist >> 16) & 0xffff);

            if (align)
                dst += emitOutputWord(dst, insCode(INS_nop));
        }
        else
        {
            // take 6 instructions 
            int align = 1;
            
            unsigned code = insCode(INS_mov_PC);
            code |= 0x4000; // load 4 byte constant
            dst += emitOutputWord(dst, code | 1);
            dst += emitOutputWord(dst, insCode(INS_braf));
            dst += emitOutputWord(dst, insCode(INS_nop));

            if  (emitCurCodeOffs(dst) & 2) {
                dst += emitOutputWord(dst, insCode(INS_nop));
                align = 0;
            }

            srcOffs = emitCurCodeOffs(dst);
            jmpDist = dstOffs - srcOffs;
            dst += emitOutputWord(dst, jmpDist & 0xffff);
            dst += emitOutputWord(dst, (jmpDist >> 16) & 0xffff);

            if (align)
                dst += emitOutputWord(dst, insCode(INS_nop));
        }
    }
    return  dst;
}

/*****************************************************************************
 *
 *  Output an unconditional forward jump to PC+dist.
 */

#undef                       emitOutputFwdJmp

BYTE    *           emitter::emitOutputFwdJmp(BYTE *dst, unsigned    dist,
                                                         bool        isSmall)
{
    assert(isSmall);

#ifdef  DEBUG

    /* Create a fake jump instruction descriptor so that we can display it */

    instrDescJmp    jmp;

    jmp.idIns             = INS_bra;
    jmp.idInsFmt          = IF_LABEL;
    jmp.idAddr.iiaIGlabel = emitDispIG;
    jmp.idjShort          = true;

    if  (disAsm || dspEmit)
    {
        emitDispInsExtra = true;
        emitDispJmpDist  = dist;
        emitDispIns(&jmp, false, dspGCtbls, true, emitCurCodeOffs(dst));
        emitDispInsExtra = false;
    }

#endif

    /* The scaled distance must fit in 12 bits */

    assert(dist < 0x2000);

    /* Output the branch opcode */

    dst += emitOutputWord(dst, insCode(INS_bra) | dist >> 1);

    /* Fill the branch-delay slot with a nop */

#ifdef DEBUG
    if  (disAsm || dspEmit)
    {
        jmp.idIns    = INS_nop;
        jmp.idInsFmt = IF_NONE;
        emitDispIns(&jmp, false, dspGCtbls, true, emitCurCodeOffs(dst));
    }
#endif

    dst += emitOutputWord(dst, insCode(INS_nop));

    return  dst;
}

/*****************************************************************************
 *
 *  Output an indirect jump.
 */

BYTE    *           emitter::emitOutputIJ(BYTE *dst, instrDesc *i)
{
    unsigned        jmpCnt;
    BasicBlock  * * jmpTab;

    unsigned        srcOfs;

    emitIndJmpKinds kind;
    unsigned        dist;
    size_t          asiz;
    int             nops_added = 0;

#ifdef  DEBUG
    size_t          base = emitCurCodeOffs(dst);
#endif

    instrDescJmp  * jmp = (instrDescJmp*)i;
    emitRegs        reg = jmp->idRegGet();

    assert(jmp->idInsFmt == IF_JMP_TAB);

    static
    BYTE            movalDisp[] =
    {
        1,  // IJ_UNS_I1
        2,  // IJ_UNS_U1
        2,  // IJ_SHF_I1
        2,  // IJ_SHF_U1

        1,  // IJ_UNS_I2
        2,  // IJ_UNS_U2

        2,  // IJ_UNS_I4
    };

    #define IJaddrGetSz(kind)    (addrInfo[kind] & 3)
    #define IJaddrIsExt(kind)   ((addrInfo[kind] & 4) != 0)
    #define IJaddrIsShf(kind)   ((addrInfo[kind] & 8) != 0)

    #define IJaddrEntry(size, isext, isshf) (size | (isext*4) | (isshf*8))

    static
    BYTE            addrInfo[] =
    {
        //          size ext shf     kind

        IJaddrEntry(0,   0,  0),    // IJ_UNS_I1
        IJaddrEntry(0,   1,  0),    // IJ_UNS_U1
        IJaddrEntry(0,   0,  1),    // IJ_SHF_I1
        IJaddrEntry(0,   1,  1),    // IJ_SHF_U1

        IJaddrEntry(1,   0,  0),    // IJ_UNS_I2
        IJaddrEntry(1,   1,  0),    // IJ_UNS_U2

        IJaddrEntry(2,   0,  0),    // IJ_UNS_I4
    };

#ifdef  DEBUG

    static
    const   char *  ijkNames[] =
    {
        "UNS_I1",                   // IJ_UNS_I1
        "UNS_U1",                   // IJ_UNS_U1
        "SHF_I1",                   // IJ_SHF_I1
        "SHF_U1",                   // IJ_SHF_U1
        "UNS_I2",                   // IJ_UNS_I2
        "UNS_U2",                   // IJ_UNS_U2
        "UNS_I4",                   // IJ_UNS_I4
    };

#endif

    /* Get hold of the jump kind */

    kind = (emitIndJmpKinds)jmp->idjJumpKind;

#ifdef DEBUG

    /* Crate a fake instruction for display purposes */

    instrDescDisp   disp;
    dspJmpInfo      info;

    disp.idIns    = INS_nop;
    disp.idInsFmt = IF_DISPINS;
    disp.iddInfo  = &info;
    disp.iddNum   = 0;
    disp.iddId    = i;

    info.iijLabel = emitTmpJmpCnt; emitTmpJmpCnt += 2;
    info.iijKind  = kind;

#endif

    /* Figure out the size of each address entry */

    asiz = IJaddrGetSz(kind);

    /* Shift the switch value if necessary */

    if  (asiz)
    {
        instruction     ishf = (asiz == 1) ? INS_shll
                                           : INS_shll2;

#ifdef DEBUG
        info.iijIns         = ishf;
        info.iijInfo.iijReg = reg;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(ishf) | (reg << 8));
    }
#ifdef DEBUG
    else
    {
        disp.iddNum++;  // no display of shift instruction
    }
#endif

    /* Make sure we're aligned properly */

    dispSpecialIns(&disp, dst);

    if  (emitCurCodeOffs(dst) & 2)
    {
        dst += emitOutputWord(dst, insCode(INS_nop));
        nops_added++;
    }

    /* Generate the "mova.l addr-of-jump-table r0" instruction */

    dist = movalDisp[kind];

    dispSpecialIns(&disp, dst);

    dst += emitOutputWord(dst, insCode(INS_mova) | dist);

    /* Generate "mov.sz @(r0,reg),r0" */

    dispSpecialIns(&disp, dst);

    dst += emitOutputWord(dst, insCode(INS_mov_ix0) | 8 | asiz | (reg << 4));

    /* Generate "extu" if necessary */

    if  (IJaddrIsExt(kind))
    {
        instruction     iext = (asiz == 0) ? INS_extub
                                           : INS_extuw;

#ifdef DEBUG
        info.iijIns         = iext;
        info.iijInfo.iijReg = reg;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(iext));
    }
#ifdef DEBUG
    else
    {
        disp.iddNum++;  // no display of zero-extend instruction
    }
#endif

    /* Shift the distance if necessary */

    if  (IJaddrIsShf(kind))
    {
        dispSpecialIns(&disp, dst);

        dst += emitOutputWord(dst, insCode(INS_shll));
    }
#ifdef DEBUG
    else
    {
        disp.iddNum++;  // no display of shift instruction
    }
#endif

    // ISSUE: Should we use "jmp @r0" for 32-bit addresses? Makes the code
    // ISSUE: location-dependent, but there is presumably some reason the
    // ISSUE: SHCL compiler does this, no?

    dispSpecialIns(&disp, dst);
    dst += emitOutputWord(dst, insCode(INS_braf));

    /* Fill the delay slot with a "nop" */

    dispSpecialIns(&disp, dst);
    dst += emitOutputWord(dst, insCode(INS_nop));

    /* The jumps are relative to the current point */

    srcOfs = emitCurCodeOffs(dst);
    dispSpecialIns(&disp, dst);

    /* Align the address table */

    dispSpecialIns(&disp, dst);

    if  (emitCurCodeOffs(dst) & 2)
    {
        dst += emitOutputWord(dst, insCode(INS_nop));
        nops_added++;
    }

    /* Output the address table contents */

    jmpCnt = jmp->idjTemp.idjCount;
    jmpTab = jmp->idAddr.iiaBBtable;

    dispSpecialIns(&disp, dst);

    do
    {
        insGroup    *   tgt;
        int             dif;

        /* Get the target IG of the entry and compute distance */

        tgt = (insGroup*)emitCodeGetCookie(*jmpTab); assert(tgt);
        dif = tgt->igOffs - srcOfs;

        /* Shift the distance if necessary */

        if  (IJaddrIsShf(kind))
            dif >>= 1;

#ifdef DEBUG
        disp.iddNum          = 99;
        info.iijTarget       = tgt->igNum;
        info.iijInfo.iijDist = dif;
        dispSpecialIns(&disp, dst);
#endif

        switch (asiz)
        {
        case 0: dst += emitOutputByte(dst, dif); break;
        case 1: dst += emitOutputWord(dst, dif); break;
        case 2: dst += emitOutputLong(dst, dif); break;
        }
    }
    while (++jmpTab, --jmpCnt);

    /* If we have an odd number of byte entries, pad it */

    if  (emitCurCodeOffs(dst) & 1)
    {

#ifdef DEBUG
        disp.iddNum = 19;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputByte(dst, 0);
    }
    while (nops_added < 3)
    {
        dst += emitOutputWord(dst, insCode(INS_nop));
        nops_added++;
    }

    /* Make sure we've generated the expected amount of code */

#ifdef  DEBUG
    if    (emitCurCodeOffs(dst) - base != jmp->idjCodeSize)
        printf("ERROR: Generated %u bytes for '%s' table jump, predicted %u\n", emitCurCodeOffs(dst) - base, ijkNames[kind], jmp->idjCodeSize);
    assert(emitCurCodeOffs(dst) - base == jmp->idjCodeSize);
#endif

    return  dst;
}

/*****************************************************************************
 *
 *  Output a direct (pc-relative) call.
 */

#if SMALL_DIRECT_CALLS

inline
BYTE    *           emitter::emitOutputDC(BYTE *dst, instrDesc *id,
                                                     instrDesc *im)
{
    BYTE    *       srcAddr = emitDirectCallBase(dst);
    BYTE    *       dstAddr;
#ifndef BIRCH_SP2
    dstAddr = emitMethodAddr(im);
#else
    OptPEReader *oper = &((OptJitInfo*)emitComp->info.compCompHnd)->m_PER;
    dstAddr = (BYTE *)oper->m_rgFtnInfo[(unsigned)(id->idAddr.iiaMethHnd)].m_pNative;
#endif
    int             difAddr = dstAddr - srcAddr;

    /* Display the instruction if appropriate */

#ifdef  DEBUG
    if  (emitDispInsExtra)
    {
        emitDispLPaddr   = difAddr;
        emitDispIns(im, false, dspGCtbls, true, dst - emitCodeBlock);
        emitDispInsExtra = false;
    }
#endif

    dst += emitOutputWord(dst, insCode(INS_bsr) | ((difAddr >> 1) & 0x0FFF));
    return dst;
}

#endif

/*****************************************************************************
 *
 *  Append the machine code corresponding to the given instruction descriptor
 *  to the code block at '*dp'; the base of the code block is 'bp', and 'ig'
 *  is the instruction group that contains the instruction. Updates '*dp' to
 *  point past the generated code, and returns the size of the instruction
 *  descriptor in bytes.
 */

size_t              emitter::emitOutputInstr(insGroup  *ig,
                                             instrDesc *id, BYTE **dp)
{
    BYTE    *       dst  = *dp;
    size_t          sz   = sizeof(instrDesc);
    instruction     ins  = id->idInsGet();
    size_t          size = emitDecodeSize(id->idOpSize);

#ifdef  DEBUG

#if     MAX_BRANCH_DELAY_LEN || SMALL_DIRECT_CALLS

    /* Zapped instructions should never reach here */

    assert(ins != INS_ignore);

#endif

    emitDispInsExtra = false;

    if  (disAsm || dspEmit)
    {
        /* Wait to display instructions that display extra info */

        switch (id->idInsFmt)
        {
        case IF_LABEL:
        case IF_RWR_LIT:
        case IF_JMP_TAB:

            /* We'll display the instruction a bit later */

            emitDispInsExtra = true;
            break;

        default:

            /* Display the instruction now */

            emitDispIns(id, false, dspGCtbls, true, emitCurCodeOffs(dst));
            break;
        }
    }

    if  (id->idNum == CGknob)
        BreakIfDebuggerPresent();

#endif

    /* What instruction format have we got? */

    switch (id->idInsFmt)
    {
        unsigned        code;
        size_t          disp;

#if TRACK_GC_REFS

        bool            nrc;

        bool            GCnewv;
        VARSET_TP       GCvars;

        unsigned        gcrefRegs;
        unsigned        byrefRegs;

#endif

#if SMALL_DIRECT_CALLS
        instrDesc   *   im;
#endif

        /********************************************************************/
        /*                        No operands                               */
        /********************************************************************/

    case IF_NONE:

#if TRACK_GC_REFS
        assert(id->idGCrefGet() == GCT_NONE);
#endif

        if (id->idIns != INS_ignore)
            dst += emitOutputWord(dst, insCode(ins));
        break;

        /********************************************************************/
        /*                      Single register                             */
        /********************************************************************/

    case IF_RRD:
    case IF_RWR:
    case IF_RRW:

        dst += emitOutputWord(dst, insCode_RV(ins, id->idRegGet()));
        sz   = TINY_IDSC_SIZE;
        break;

        /********************************************************************/
        /*                    Register and constant                         */
        /********************************************************************/

    case IF_RRD_CNS:
    case IF_RWR_CNS:
    case IF_RRW_CNS:

        assert(emitGetInsSC(id) >= IMMED_INT_MIN);
        assert(emitGetInsSC(id) <= IMMED_INT_MAX);

        if ( id->idIns == INS_cmpeq) {
            dst += emitOutputWord(dst, insCode_IV(ins, emitGetInsSC(id)));
            sz   = emitSizeOfInsDsc(id);
        }
        else {
            dst += emitOutputWord(dst, insCode_RV_IV(ins, id->idRegGet(), emitGetInsSC(id)));
            sz   = emitSizeOfInsDsc(id);
        }
        break;

        /********************************************************************/
        /*                Register and literal pool entry                   */
        /********************************************************************/

    case IF_RWR_LIT:
        {
        unsigned        offs;
        unsigned        base;
        unsigned        dist;

        /* The operand size must be word/long */

        assert(size == 2 || size == 4);

        /* Set the size of the instruction */

        sz = sizeof(instrDescLPR);

#if SMALL_DIRECT_CALLS

        /* Is this a direct (pc-relative) call? */

        if  (ins == INS_bsr)
        {
            /* Remember the first instruction for later */

            im = id;

            /* Switch to what used to be the call instruction */

            id = ((instrDescLPR*)id)->idlCall;

            /* Go process this as a call */

            goto EMIT_CALL;
        }

#endif

        /* The instruction must be "mov @(disp,pc), reg" */

        assert(ins == INS_mov_PC);

        /* Find the appropriate entry for the value in the current LP */

        offs = emitAddLitPoolEntry(emitLitPoolCur, id, true);
        base = emitCurCodeOffs(dst);

        if  (size == 4)
            base &= -4;

#ifdef  DEBUG
        if  (emitDispInsExtra)
        {
            emitDispLPaddr   = offs - base;
            emitDispIns(id, false, dspGCtbls, true, dst - emitCodeBlock);
            emitDispInsExtra = false;
        }
#endif

        /* Compute the distance from the current instruction */

        if (size == 4)
            dist = (offs-base)/size - 1;
        else
            dist = (offs-base)/size - 2;

//      printf("Cur offset = %04X, LP offs = %04X, dist = %04X [%04X]\n", base, offs, offs - base, dist);

        /* Start forming the opcode */

        switch (id->idInfo.idRelocType)
        {
        case 0:
        case 2:
            break;
#ifdef BIRCH_SP2
        case 1: // is a call
//        case 2: // is a ldftn
            {
                //if (!dstAddr)
                {
                    instrDescLPR *lprid = (instrDescLPR *) id;
            OptJit::SH3DeferredLocation *s = OptJit::SH3DeferredLocation::Create(
                        id->idAddr.iiaMethHnd, ((OptJit *)emitComp)->getCurMethodH(), emitComp);
                
                    s->offset = offs;
                    //if (verbose) printf("this lit pool refs a call/ftninfo at %X in method %x to %x\n", offs, lprid->idAddr.iiaCns, s->methodH);
                    emitCmpHandle->deferLocation(s->methodH, s);
                }

            }
            break;
#endif
        default:
            assert(!"unreached");
        }

        code = insCode(ins);
        if  (size == 4)
            code |= 0x4000;

#if     SCHEDULER

        /* If we're scheduling, the distance might change later */

        if  (emitComp->opts.compSchedCode)
            emitRecordLPref(emitLitPoolCur, dst);

#endif

        assert((dist & 0xff) == dist);
        dst += emitOutputWord(dst, code | (id->idRegGet() << 8) | dist);
        }

        break;

        /********************************************************************/
        /*                        Two registers                             */
        /********************************************************************/

    case IF_RRD_RRD:
    case IF_RWR_RRD:
    case IF_RRW_RRD:
        dst += emitOutputWord(dst, insCode_R1_R2(ins, id->idRg2Get(),
                                                      id->idRegGet()));
        sz   = emitSizeOfInsDsc(id);
        break;

        /********************************************************************/
        /*                         Indirection                              */
        /********************************************************************/

    case IF_IRD:
    case IF_IWR:

        code = insCode(ins) | (id->idAddr.iiaRegAndFlg.rnfReg << 8);

        if  (!(id->idAddr.iiaRegAndFlg.rnfFlg & RNF_AUTOX))
            code |= 0x0004;

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize);
        break;

        /********************************************************************/
        /*                           Call                                   */
        /********************************************************************/

    case IF_METHOD:

#if SMALL_DIRECT_CALLS
    EMIT_CALL:
#endif

#if TRACK_GC_REFS

        /* Assume we'll be recording this call */

        nrc  = false;

        /* Is this a "fat" call descriptor? */

        if  (id->idInfo.idLargeCall)
        {
            GCnewv    = true;
            GCvars    = ((instrDescCIGCA*)id)->idciGCvars;

            byrefRegs = ((instrDescCIGCA*)id)->idciByrefRegs;
            byrefRegs = emitDecodeCallGCregs(byrefRegs);

            sz        = sizeof(instrDescCIGCA);
        }
        else
        {
            assert(id->idInfo.idLargeCns == false);
            assert(id->idInfo.idLargeDsp == false);

            byrefRegs = emitThisByrefRegs;

            GCnewv    = false;
            sz        = sizeof(instrDesc);
        }

        /* Output the opcode */

#if SMALL_DIRECT_CALLS
        if  (ins == INS_bsr)
        {
            dst  = emitOutputDC(dst, id, im);
        }
        else
#endif
        {
            assert(ins == INS_jsr);

            dst += emitOutputWord(dst, insCode(ins) | (id->idRegGet() << 8));
        }

    DONE_CALL:

        /* Get the new set of live GC ref registers */

        gcrefRegs = emitDecodeCallGCregs(id->idAddr.iiaRegAndFlg.rnfReg);

        /* If the method returns a GC ref, mark the return reg appropriately */

        if       (id->idGCrefGet() == GCT_GCREF)
            gcrefRegs |= RBM_INTRET;
        else if  (id->idGCrefGet() == GCT_BYREF)
            byrefRegs |= RBM_INTRET;

        /* If the GC register set has changed, report the new set */

        if  (gcrefRegs != emitThisGCrefRegs)
            emitUpdateLiveGCregs(GCT_GCREF, gcrefRegs, dst);

        if  (byrefRegs != emitThisByrefRegs)
            emitUpdateLiveGCregs(GCT_BYREF, byrefRegs, dst);

        /* Is there a new set of live GC ref variables? */

#ifdef  DEBUG
        if  (verbose&&0)
        {
            if  (GCnewv)
                printf("[%02u] Gen call GC vars = %016I64X\n", id->idNum, GCvars);
        }
#endif

        if      (GCnewv)
            emitUpdateLiveGCvars(           GCvars, dst);
        else if (!emitThisGCrefVset)
            emitUpdateLiveGCvars(emitThisGCrefVars, dst);

        /* Do we need to record a call location for GC purposes? */

        if  (!emitFullGCinfo && !nrc)
            emitRecordGCcall(dst);

#else

        /* Output the opcode */

#if SMALL_DIRECT_CALLS
        if  (ins == INS_bsr)
        {
            dst  = emitOutputDC(dst, id, im);
        }
        else
#endif
        {
            assert(ins == INS_jsr);

            dst += emitOutputWord(dst, insCode(ins) | (id->idRegGet() << 8));
        }

#endif

        break;

        /********************************************************************/
        /*               Register and various indirections                  */
        /********************************************************************/

    case IF_IRD_RWR_GBR:
    case IF_RRD_IWR_GBR:
        code = emitGetInsSC(id) | insCode(ins) | (id->idOpSize<<8);
        assert((emitGetInsSC(id) & 0xFF) == emitGetInsSC(id));
        dst += emitOutputWord(dst, code);
        sz   = emitSizeOfInsDsc(id);
        break;

    case IF_IRD_RWR:

        assert(ins == INS_mov_ind || ins == INS_fmov_ind);

        code = insCode_R1_R2(ins, id->idRegGet(),
                                  (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);

        if  (id->idAddr.iiaRegAndFlg.rnfFlg & RNF_AUTOX)
        {
            if (ins == INS_mov_ind)
                code |= 0x0004;
            else
                code |= 0x0001;
        }

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize);
        break;

    case IF_RRD_IWR:

        assert(ins == INS_mov_ind || ins == INS_fmov_ind);

        code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg,
                                  id->idRegGet());

        if  (id->idAddr.iiaRegAndFlg.rnfFlg & RNF_AUTOX)
        {
            if (ins == INS_mov_ind)
                code |= 0x0004;
            else
                code |= 0x0001;
        }


        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        if (ins == INS_mov_ind)
            dst += emitOutputWord(dst, code|id->idOpSize|0x4000);
        else
            dst += emitOutputWord(dst, code);

        break;

    case IF_0RD_RRD_XWR:

        assert(ins == INS_mov_ix0);

        code = insCode_R1_R2(ins, id->idRegGet(),
                                  (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize);
        break;

    case IF_0RD_XRD_RWR:

        assert(ins == INS_movl_ix0);

        code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg,
                                  id->idRegGet());

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize|8);
        break;

    case IF_DRD_RWR:

        // read
        assert(ins == INS_mov_dsp);

        disp = emitGetInsDsp(id);
        code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg,
                                  id->idRegGet());

        switch (size)
        {
        case 1: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8400;             
            dst += emitOutputWord(dst, code|disp);
            break;
        case 2: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8500; 
            disp >>= 1; 
            dst += emitOutputWord(dst, code|disp);
            break;
        default:                
            disp >>= 2; 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
//            code = insCode_R1_R2(ins, id->idRegGet(), (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);
            dst += emitOutputWord(dst, code|disp|0x4000);
            break;
        }

        sz   = emitSizeOfInsDsc(id);
        break;

    case IF_RRD_DWR:

        // write
        assert(ins == INS_mov_dsp);

        disp = emitGetInsDsp(id);

        switch (size)
        {
        case 1: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8000;             
            break;
        case 2: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8100; 
            disp >>= 1; 
            break;
        default:                
            disp >>= 2; 
//            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code = insCode_R1_R2(ins, id->idRegGet(), (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);
            break;
        }

        dst += emitOutputWord(dst, code|disp);
        sz   = emitSizeOfInsDsc(id);
        break;

        /********************************************************************/
        /*                      Stack-based operand                         */
        /********************************************************************/

    case IF_SRD_RRD:    // stk <- reg
    case IF_SWR_RRD:    // stk <- reg
    case IF_SRW_RRD:    // stk <- reg

        dst = emitOutputSV(dst, id, false);
        break;

    case IF_RRD_SRD:    // reg <- stk
    case IF_RWR_SRD:    // reg <- stk
    case IF_RRW_SRD:    // reg <- stk

        dst = emitOutputSV(dst, id,  true);
        break;

    case IF_AWR_RRD:
        code = insCode_R1_R2(ins, id->idRegGet(), (emitRegs)REG_SPBASE);
        dst += emitOutputWord(dst, code | id->idAddr.iiaCns / sizeof(int));
        break;

        /********************************************************************/
        /*                           Local label                            */
        /********************************************************************/

    case IF_LABEL:

#if TRACK_GC_REFS
        assert(id->idGCrefGet() == GCT_NONE);
#endif
        assert(id->idInfo.idBound);

        dst = emitOutputLJ(dst, id);
        sz  = sizeof(instrDescJmp);
//      printf("jump #%u\n", id->idNum);
        break;

        /********************************************************************/
        /*                          Indirect jump                           */
        /********************************************************************/

    case IF_JMP_TAB:

#if TRACK_GC_REFS
        assert(id->idGCrefGet() == GCT_NONE);
#endif

        dst = emitOutputIJ(dst, id);
        sz  = sizeof(instrDescJmp);
        break;

        /********************************************************************/
        /*                            oops                                  */
        /********************************************************************/

    default:

#ifdef  DEBUG
        printf("unexpected non-x86 instr format %s\n", emitIfName(id->idInsFmt));
        BreakIfDebuggerPresent();
        assert(!"don't know how to encode this instruction");
#endif

        break;
    }

#ifdef  TRANSLATE_PDB
    /* Map the IL instruction group to the native instruction group for PDB translation */

    MapCode( id->idilStart, *dp );
#endif

    /* Make sure some code got generated */

    assert(*dp != dst); *dp = dst;

    return  sz;
}

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Due to scheduling the offset of a literal pool may change; when that
 *  happens, all references to that literal pool need to be updated to
 *  reflect the new offset by patching the pc-relative value in the
 *  instruction (the distance always gets smaller, one hopes).
 */

void                emitter::emitPatchLPref(BYTE *addr, unsigned oldOffs,
                                                        unsigned newOffs)

{
    unsigned        opcode = *(USHORT *)addr;

    assert((opcode & 0xB000) == insCode(INS_mov_PC));

    /* Is this a 32-bit reference? */

    if  (opcode & 4)
    {
        unsigned        srcOffs;

        /* Recompute the distance (note that the source offset is rounded down) */

        srcOffs = emitCurCodeOffs(addr) & -4;

        /* Replace the distance value in the opcode */

        *(USHORT *)addr  = (opcode & 0xFF00) | ((newOffs - srcOffs) / 4 - 1);
    }
    else
    {
        /* Simply apply the (shifted) distance delta to the offset value */

        *(USHORT *)addr -= (oldOffs - newOffs) / 2;
    }

#ifdef  DEBUG
    if  (verbose)
    {
        unsigned    refSize = (opcode & 4) ? sizeof(int) : sizeof(short);

        printf("Patch %u-bit LP ref at %04X: %04X->%04X [offs=%04X->%04X,dist=%04X->%04X]\n",
            refSize * 8,
            addr - emitCodeBlock,
            opcode,
            *(USHORT *)addr,
            oldOffs,
            newOffs,
            (opcode & 0xFF) * refSize,
            (opcode & 0xFF) * refSize + (newOffs - oldOffs));
    }
#endif

}

/*****************************************************************************/
#endif//SCHEDULER

/*****************************************************************************/
#endif//TGT_SH3
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitjmps.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//       jump     name    reverse  encoding
JMP_SMALL(jmp   , "jmp"   , jmp   , 0x00EB)
JMP_SMALL(jo    , "jo"    , jno   , 0x0070)
JMP_SMALL(jno   , "jno"   , jo    , 0x0071)
JMP_SMALL(jb    , "jb"    , jae   , 0x0072)
JMP_SMALL(jae   , "jae"   , jb    , 0x0073)
JMP_SMALL(je    , "je"    , jne   , 0x0074)
JMP_SMALL(jne   , "jne"   , je    , 0x0075)
JMP_SMALL(jbe   , "jbe"   , ja    , 0x0076)
JMP_SMALL(ja    , "ja"    , jbe   , 0x0077)
JMP_SMALL(js    , "js"    , jns   , 0x0078)
JMP_SMALL(jns   , "jns"   , js    , 0x0079)
JMP_SMALL(jpe   , "jpe"   , jpo   , 0x007A)
JMP_SMALL(jpo   , "jpo"   , jpe   , 0x007B)
JMP_SMALL(jl    , "jl"    , jge   , 0x007C)
JMP_SMALL(jge   , "jge"   , jl    , 0x007D)
JMP_SMALL(jle   , "jle"   , jg    , 0x007E)
JMP_SMALL(jg    , "jg"    , jle   , 0x007F)

JMP_LARGE(l_jmp , "jmp"   , l_jmp , 0x00E9)
JMP_LARGE(l_jo  , "jo"    , l_jno , 0x800F)
JMP_LARGE(l_jno , "jno"   , l_jo  , 0x810F)
JMP_LARGE(l_jb  , "jb"    , l_jae , 0x820F)
JMP_LARGE(l_jae , "jae"   , l_jb  , 0x830F)
JMP_LARGE(l_je  , "je"    , l_jne , 0x840F)
JMP_LARGE(l_jne , "jne"   , l_je  , 0x850F)
JMP_LARGE(l_jbe , "jbe"   , l_ja  , 0x860F)
JMP_LARGE(l_ja  , "ja"    , l_jbe , 0x870F)
JMP_LARGE(l_js  , "js"    , l_jns , 0x880F)
JMP_LARGE(l_jns , "jns"   , l_js  , 0x890F)
JMP_LARGE(l_jpe , "jpe"   , l_jpo , 0x8A0F)
JMP_LARGE(l_jpo , "jpo"   , l_jpe , 0x8B0F)
JMP_LARGE(l_jl  , "jl"    , l_jge , 0x8C0F)
JMP_LARGE(l_jge , "jge"   , l_jl  , 0x8D0F)
JMP_LARGE(l_jle , "jle"   , l_jg  , 0x8E0F)
JMP_LARGE(l_jg  , "jg"    , l_jle , 0x8F0F)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitrisc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            emitRISC.cpp                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "alloc.h"
#include "instr.h"
#include "target.h"
#include "emit.h"

/*****************************************************************************/
#if     TGT_RISC
/*****************************************************************************
 *
 *  Call the specified function pointer for each epilog block in the current
 *  method with the epilog's relative code offset. Returns the sum of the
 *  values returned by the callback.
 */

#if     TRACK_GC_REFS

size_t              emitter::emitGenEpilogLst(size_t (*fp)(void *, unsigned),
                                              void    *cp)
{
    #error  GC ref tracking NYI for RISC targets
}

#endif

/*****************************************************************************/
#if     EMIT_USE_LIT_POOLS
/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction that references
 *  a literal pool entry.
 */

emitter::instrDesc* emitter::emitNewInstrLPR(size_t       size,
                                             gtCallTypes  typ,
                                             void   *     hnd)
{
    instrDescLPR *  ld = emitAllocInstrLPR(size);

    /* Fill in the instruction descriptor */

    ld->idInsFmt          = IF_RWR_LIT;
    ld->idIns             = LIT_POOL_LOAD_INS;
    ld->idAddr.iiaMembHnd = hnd;
    ld->idInfo.idSmallCns = typ;

    /* Make sure the type was stored properly */

    assert(emitGetInsLPRtyp(ld) == typ);

    /* Record the instruction's IG and offset within it */

    ld->idlIG             = emitCurIG;
    ld->idlOffs           = emitCurIGsize;

    /* Assume this is not a direct call sequence for now */

#if SMALL_DIRECT_CALLS
    ld->idlCall           = NULL;
#endif

    /* Add the instruction to this IG's litpool ref list */

    ld->idlNext           = emitLPRlistIG;
                            emitLPRlistIG = ld;

    return  ld;
}

/*****************************************************************************
 *
 *  When we're finished creating an instruction group, this routine is called
 *  to perform any literal pool-related work for the current IG.
 */

void                emitter::emitRecIGlitPoolRefs(insGroup *ig)
{
    /* Update the total estimate of literal pool entries */

    emitEstLPwords += emitCurIG->igLPuseCntW;
    emitEstLPlongs += emitCurIG->igLPuseCntL;
    emitEstLPaddrs += emitCurIG->igLPuseCntA;

    /* Does this IG have any instructions referencing the literal pool? */

    if  (emitLPRlistIG)
    {
        /* Move all LP referencing instructions to a global list */

        instrDescLPR  * list = NULL;
        instrDescLPR  * last = NULL;

        do
        {
            size_t          offs;

            instrDescLPR  * oldI;
            instrDescLPR  * newI;

            /* Grab the next instruction and remove it from the list */

            oldI = emitLPRlistIG; emitLPRlistIG = oldI->idlNext;

            /* Figure out the address of where the instruction got copied */

            offs = (BYTE*)oldI - emitCurIGfreeBase;
            newI = (instrDescLPR*)(ig->igData + offs);

#if USE_LCL_EMIT_BUFF
            assert((oldI == newI) == emitLclBuffDst);
#endif

            assert(newI->idlIG   == ig);
            assert(newI->idIns   == oldI->idIns);
            assert(newI->idlNext == oldI->idlNext);

            /* Update the "call" field if non-NULL */

            if  (newI->idlCall)
            {
                unsigned    diff = (BYTE*)newI->idlCall - emitCurIGfreeBase;

                newI->idlCall = (instrDescLPR*)(ig->igData + diff);
            }

            /* Append the new instruction to the list */

            newI->idlNext = list;
                            list = newI;

            if  (!last)
                last = newI;
        }
        while (emitLPRlistIG);

        /* Add the instruction(s) from this IG to the global list */

        if  (emitCurIG == emitPrologIG)
        {
            /* We're in the prolog, insert in front of the list */

            last->idlNext = emitLPRlist;
                            emitLPRlist = list;

            if  (!emitLPRlast)
                  emitLPRlast = last;
        }
        else
        {
            /* Append at the end of the current list */

            if  (emitLPRlist)
                emitLPRlast->idlNext = list;
            else
                emitLPRlist          = list;

            last->idlNext = NULL;
            emitLPRlast   = last;
        }
    }

    assert(emitLPRlistIG == NULL);
}

/*****************************************************************************
 *
 *  Append a literal pool after the specified instruction group. Return its
 *  estimated size.
 */

size_t              emitter::emitAddLitPool(insGroup  * ig,
                                            bool        skip,
                                            unsigned    wordCnt,
                                            short  *  * nxtLPptrW,
                                            unsigned    longCnt,
                                            long   *  * nxtLPptrL,
                                            unsigned    addrCnt,
                                            LPaddrDesc**nxtAPptrL)
{
    litPool *       lp;
    size_t          sz;

    /* Allocate a pool descriptor and append it to the list */

    lp = (litPool*)emitGetMem(sizeof(*lp));

    if  (emitLitPoolLast)
         emitLitPoolLast->lpNext = lp;
    else
         emitLitPoolList         = lp;

    emitLitPoolLast = lp;
                      lp->lpNext = 0;

    emitTotLPcount++;

#ifdef  DEBUG
    lp->lpNum = emitTotLPcount;
#endif

    /* If there are longs/addrs, we need at least one word for alignment */
    /* but only for sh3? */

#if !TGT_ARM
    if  ((longCnt || addrCnt) && !wordCnt)
        wordCnt++;
#endif // TGT_ARM

    /* Remember which group the pool belongs to */

    lp->lpIG      = ig;

    /* There are no references yet */

#if     SCHEDULER
    lp->lpRefs    = NULL;
#endif

    /* Conservative size estimate: assume the pool will be completely filled */

    sz = wordCnt * 2 +
         longCnt * 4 +
         addrCnt * 4;

    /* Do we need to jump over the literal pool? */

    lp->lpJumpIt  = skip;

    if  (skip)
    {
        size_t          jmpSize;

        /* Estimate what size jump we'll have to use */

#if     JMP_SIZE_MIDDL
        lp->lpJumpMedium = false;
#endif

        if      (sz < JMP_DIST_SMALL_MAX_POS)
        {
            lp->lpJumpSmall  =  true; jmpSize = JMP_SIZE_SMALL;
        }
#if     JMP_SIZE_MIDDL
        else if (sz < JMP_DIST_MIDDL_MAX_POS)
        {
            lp->lpJumpMedium =  true; jmpSize = JMP_SIZE_MIDDL;
        }
#endif
        else
        {
            lp->lpJumpSmall  = false; jmpSize = JMP_SIZE_LARGE;

            /* This one really hurts - the jump will need to use the LP */

            longCnt++; sz += 4;
        }

        /* Add the jump size to the total size estimate */

        sz += jmpSize;
    }

    /* Grab the appropriate space in the tables */

    lp->lpWordTab =
    lp->lpWordNxt = *nxtLPptrW; *nxtLPptrW += wordCnt;
#ifdef  DEBUG
    lp->lpWordMax = wordCnt;
#endif
    lp->lpWordCnt = 0;

    lp->lpLongTab =
    lp->lpLongNxt = *nxtLPptrL; *nxtLPptrL += longCnt;
#ifdef  DEBUG
    lp->lpLongMax = longCnt;
#endif
    lp->lpLongCnt = 0;

    lp->lpAddrTab =
    lp->lpAddrNxt = *nxtAPptrL; *nxtAPptrL += addrCnt;
#ifdef  DEBUG
    lp->lpAddrMax = addrCnt;
#endif
    lp->lpAddrCnt = 0;

    /* Record the size estimate and add it to the group's size */

    lp->lpSize    = 0;
    lp->lpSizeEst = sz;

    ig->igSize   += sz;

    return  sz;
}

/*****************************************************************************
 *
 *  Find an existing literal pool entry that matches the given one. Returns
 *  the offset of the entry (or -1 in case one wasn't found).
 */

int                 emitter::emitGetLitPoolEntry(void     *    table,
                                                 unsigned      count,
                                                 void     *    value,
                                                 size_t        size)
{
    BYTE    *       entry = (BYTE*)table;

    /* ISSUE: Using linear search here - brilliant!!! */

    while (count--)
    {
        if  (!memcmp(entry, value, size))
        {
            /* Match found, return offset from base of table */

            return  (BYTE *)entry - (BYTE*)table;
        }

        entry += size;
    }

    return  -1;
}

/*****************************************************************************
 *
 *  Add an entry for the instruction's operand to the specified literal pool;
 *  if 'issue' is non-zero, the actual final offset of the entry (relative
 *  to the method beginning) is returned.
 */

size_t              emitter::emitAddLitPoolEntry(litPool   *lp,
                                                 instrDesc *id, bool issue)
{
    int             offs;
    unsigned        base;

    int             val;

    size_t          size = emitDecodeSize(id->idOpSize); assert(size == 2 || size == 4);

    assert(lp);
    assert(id->idInsFmt == IF_RWR_LIT);

    /* Get the base offset of the pool (valid only when 'issue' is true) */

    base = lp->lpOffs;

    /* Try to reuse an existing entry */

    if  (emitGetInsLPRtyp(id) == CT_INTCNS)
    {
        int             val = id->idAddr.iiaCns;
        //printf ("adding lit pool %d with issue %d\n", val, issue);

        if  (size == 2)
        {
            /* Search the word table for a match */

            offs = emitGetLitPoolEntry(lp->lpWordTab,
                                       lp->lpWordCnt, &val, size);
            if  (offs != -1)
            {
                if  (issue)
                {
                    /* Do we have any padding? */

                    if  (lp->lpPadding)
                    {
                        /* We must be using the first word for padding */

                        assert(lp->lpPadFake == false);

                        /* Have we matched the padding word itself? */

                        if  (!offs)
                            return  base;
                    }

                    /* Add the long and address sections sizes to the offset */

                    return  base + offs + lp->lpLongCnt * sizeof(int) + lp->lpAddrCnt * sizeof(void*);
                }

                return  0;
            }

            /* Search the long table for a match as well */

            offs = emitGetLitPoolEntry(lp->lpLongTab,
                                       lp->lpLongCnt*2, &val, size);
            if  (offs != -1)
                goto FOUND_LONG;

            /* No match among the existing entries, append a new entry */

#ifdef DEBUG
            assert(lp->lpWordCnt < lp->lpWordMax);
#endif

            *lp->lpWordNxt++ = (short)val;
             lp->lpWordCnt++;
        }
        else
        {
            /* Search the long table for a match */

            offs = emitGetLitPoolEntry(lp->lpLongTab,
                                       lp->lpLongCnt, &val, size);

            if  (offs != -1)
            {
                if  (issue)
                {

                FOUND_LONG:

                    /* Add padding, if necessary */

                    if  (lp->lpPadding)
                        base += 2;

                    /* long/addr entries must always be aligned */

                    assert(((base + offs) & 3) == 0 || issue == false || size < sizeof(int));

                    /* Return the offset of the entry */

                    return  base + offs;
                }

                return  0;
            }

            /* No match among the existing entries, append a new entry */

#ifdef DEBUG
            assert(lp->lpLongCnt < lp->lpLongMax);
#endif

            *lp->lpLongNxt++ = val;
             lp->lpLongCnt++;
        }
    }
    else
    {
        LPaddrDesc  val;

        /* Create an entry for the lookup */

        memset(&val, 0, sizeof(val));

        val.lpaTyp = emitGetInsLPRtyp(id);
        val.lpaHnd = id->idAddr.iiaMethHnd;

//      printf("Adding [%d] addr entry [%02X,%08X]\n", issue+1, val.lpaTyp, val.lpaHnd);

        /* Search both the addr table for a match */

        offs = emitGetLitPoolEntry(lp->lpAddrTab,
                                   lp->lpAddrCnt  , &val, sizeof(val));
        
        if  (offs != -1)
        {
            if  (issue)
            {
                /* Add padding, if necessary */

                if  (base & 3)
                {
                    assert(lp->lpPadding);

                    base += 2;
                }
                else
                {
                    assert(lp->lpPadding == false &&
                           lp->lpPadFake == false);
                }

                // the offs returned is the offset into the address table, which
                // is not the same as the offset into the litpool, since the
                // address table contains structures, not simple 32-bit addresses
                offs = offs * sizeof(void*) / sizeof(val);

                /* Return the offset of the entry */

                //return  base + offs + lp->lpLongCnt * sizeof(int) + lp->lpAddrCnt * sizeof(void*);
                return  base + lp->lpLongCnt * sizeof(long) + offs;
            }

            return  0;
        }

        /* No match among the existing entries, append a new entry */

#ifdef DEBUG
        assert(lp->lpAddrCnt < lp->lpAddrMax);
#endif
        *lp->lpAddrNxt++ = val;
         lp->lpAddrCnt++;
    }

    /*
        If we get here it means that we've just added a new entry
        to the pool. We better not be issuing an instruction since
        all entries are supposed to have been added by that time.
     */

    assert(issue == false);

    return  0;
}

/*****************************************************************************
 *
 *  Compute a conservative estimate of the size of each literal pool.
 */

void                emitter::emitEstimateLitPools()
{
    emitTotLPcount = 0;

#ifdef DEBUG
    unsigned        words = 0;
    unsigned        longs = 0;
    unsigned        addrs = 0;
#endif

    /* Does it look like we might need to create a constant pool? */

    if  (emitEstLPwords || emitEstLPlongs || emitEstLPaddrs)
    {
        size_t          curOffs;

        insGroup    *   tempIG;
        insGroup    *   nextIG;

        insGroup    *   lastIG = NULL;
        insGroup    *   bestIG = NULL;
        unsigned        bestWc = 0;
        unsigned        bestLc = 0;
        unsigned        bestAc = 0;
        unsigned        bestSz;
        unsigned        prevWc = 0;
        unsigned        prevLc = 0;
        unsigned        prevAc = 0;
        unsigned        prevSz;
        unsigned        bestMx = UINT_MAX;
        unsigned        need_bestmx = false;
        unsigned        need_bestmxw = false;

        unsigned        begOfsW = 0;
        unsigned        begOfsL = 0;

        unsigned        wordCnt = 0;
        unsigned        longCnt = 0;
        unsigned        addrCnt = 0;
        unsigned        litSize = 0;

        unsigned        endOffs;
        unsigned        maxOffs = UINT_MAX;

        bool            doneIG  = false;
        bool            skipIG  = false;

        short       *   LPtabW  = NULL;
        short       *   LPnxtW  = NULL;

        long        *   LPtabL  = NULL;
        long        *   LPnxtL  = NULL;

        LPaddrDesc  *   LPtabA  = NULL;
        LPaddrDesc  *   LPnxtA  = NULL;

            /*        
            If the total estimated size of the entire method is less
            than the max. distance for "medium" jumps, decrement the
            "long" literal pool use counts for each jump marked as
            long.
            */

#if !TGT_ARM
        if  (emitCurCodeOffset < -min(JMP_DIST_SMALL_MAX_NEG,
                                      JCC_DIST_MIDDL_MAX_NEG) &&
             emitCurCodeOffset <  min(JMP_DIST_SMALL_MAX_POS,
                                      JCC_DIST_MIDDL_MAX_POS))
        {
            instrDescJmp *  jmp;

            for (jmp = emitJumpList; jmp; jmp = jmp->idjNext)
            {
                insGroup    *   jmpIG;

                if  (jmp->idInsFmt == IF_JMP_TAB)
                    continue;

#if TGT_MIPSFP
                assert( (jmp->idInsFmt == IF_LABEL) || (jmp->idInsFmt == IF_JR) || (jmp->idInsFmt == IF_JR_R) ||
                        (jmp->idInsFmt == IF_RR_O) || (jmp->idInsFmt == IF_R_O) || (jmp->idInsFmt == IF_O));
#elif TGT_MIPS32
                assert( (jmp->idInsFmt == IF_LABEL) || (jmp->idInsFmt == IF_JR) || (jmp->idInsFmt == IF_JR_R) ||
                        (jmp->idInsFmt == IF_RR_O) || (jmp->idInsFmt == IF_R_O));
#else
                assert(jmp->idInsFmt == IF_LABEL);
#endif

                /* Get the group the jump is in */

                jmpIG = jmp->idjIG;

                /* Decrease the "long" litpool count of the group */

                assert(jmpIG->igLPuseCntL > 0);

                jmpIG->igLPuseCntL--;
                    emitEstLPlongs--;
            }

#if TGT_SH3
            all_jumps_shortened = 1;
#endif
            /* Are there any litpool users left? */

            if  (!emitEstLPwords && !emitEstLPlongs && !emitEstLPaddrs)
                goto DONE_LP;
        }
        else
        {
#if TGT_SH3
            all_jumps_shortened = 0;
#endif
        }
#endif //TGT_ARM
#ifdef  DEBUG

        if  (verbose)
        {
            printf("\nInstruction list before literal pools are added:\n\n");
            emitDispIGlist(false);
        }

        /* Make sure our estimates were accurate */

        unsigned    wordChk;
        unsigned    longChk;
        unsigned    addrChk;

        for (wordChk =
             longChk =
             addrChk = 0, tempIG = emitIGlist; tempIG; tempIG = tempIG->igNext)
        {
            wordChk += tempIG->igLPuseCntW;
            longChk += tempIG->igLPuseCntL;
            addrChk += tempIG->igLPuseCntA;
            emitEstLPwords+=2;
            emitEstLPlongs+=2;
            // @TODO [REVISIT] [04/16/01] []:
            // any lit pool can add a word for alignment.  
            // also can add a long for a jump over the litpool.
            // here we pray there is not an avg of more than two lit pool per instr group.
        }

        assert(wordChk <= emitEstLPwords);
        assert(longChk <= emitEstLPlongs);
        assert(addrChk <= emitEstLPaddrs);

#else
        for (tempIG = emitIGlist; tempIG; tempIG = tempIG->igNext)
        {
            emitEstLPwords+=2;
            emitEstLPlongs+=2;
        }
#endif


        /* Allocate the arrays of the literal pool word/long entries */

        LPtabW = LPnxtW = (short     *)emitGetMem(roundUp(emitEstLPwords * sizeof(*LPtabW)));
        LPtabL = LPnxtL = (long      *)emitGetMem(        emitEstLPlongs * sizeof(*LPtabL) );
        LPtabA = LPnxtA = (LPaddrDesc*)emitGetMem(        emitEstLPaddrs * sizeof(*LPtabA) );

        /* We have not created any actual lit pools yet */

        emitLitPoolList =
        emitLitPoolLast = NULL;

        /* Walk the group list, looking for lit pool use */

        for (tempIG = emitIGlist, curOffs = litSize = bestSz = 0;;)
        {
            assert(lastIG == NULL || lastIG->igNext == tempIG);

            /* Record the (possibly) updated group offset */

            tempIG->igOffs = curOffs;

            /* Get hold of the next group */

            nextIG  = tempIG->igNext;

            /* Compute the offset of the group's end */

            endOffs = tempIG->igOffs + tempIG->igSize;

            //printf("\nConsider IG #%02u at %04X\n", tempIG->igNum, tempIG->igOffs);
            //printf("bestsz is %x\n", bestSz);

            /* Is the end of this group too far? */

            int nextLitSize =
                tempIG->igLPuseCntW * 2 + tempIG->igLPuseCntL * sizeof(int  ) + tempIG->igLPuseCntA * sizeof(void*);
            
            if  (endOffs + litSize + nextLitSize > maxOffs)
            //if  (endOffs + litSize > maxOffs)
            {
                size_t          offsAdj;

                /* We must place a literal pool before this group */

                if  (!bestIG)
                {
                  
//                        Ouch - we'll have to jump over the literal pool
//                        since we have to place it here and there were
//                        no good places to put earlier. For now, we'll
//                        just set a flag on the liter pool (and bump its
//                        size), and we'll issue the jump just before we
//                        write out the literal pool contents.
                     

                    skipIG = true;
                    bestIG = lastIG;

                ALL_LP:

                    bestWc = wordCnt;
                    bestLc = longCnt;
                    bestAc = addrCnt;
                    bestSz = litSize;
                    bestMx = UINT_MAX;
                    //printf ("had to split %d %d %d %x!\n", bestWc, bestLc, bestAc, litSize);
                }

                
                assert(bestIG && ((bestIG->igFlags & IGF_END_NOREACH) || skipIG));

                /* Append an LP right after "bestIG" */

                //printf("lit placed after IG #%02u at %04X uses : WLA %d %d %d : maxOffs was %X\n", bestIG->igNum, bestIG->igOffs, bestWc, bestLc, bestAc, maxOffs);
                //printf("lit size (bestsz) was %x, litsize+endoffs = %x  endoffs = %x\n", bestSz, bestSz+bestIG->igOffs+bestIG->igSize, bestIG->igOffs+bestIG->igSize);
                //printf("lit uses lpnxtW : %x\t lpnxtL : %x\t lpnxtA : %x\n", LPnxtW, LPnxtL, LPnxtA);

                offsAdj = emitAddLitPool(bestIG,
                                         skipIG, bestWc, &LPnxtW,
                                                 bestLc, &LPnxtL,
                                                 bestAc, &LPnxtA);

                
                // Do we need to skip over the literal pool? 

                if  (skipIG)
                {
                    /* Reset the flag */

                    skipIG = false;

                    /* Update this group's and the current offset  */

                    tempIG->igOffs += offsAdj;
                }
                else
                {
                    /* Update the intervening group offsets */

                    while (bestIG != tempIG)
                    {
                        bestIG = bestIG->igNext;

                        bestIG->igOffs += offsAdj;
                    }
                }

                /* Update the total code size */

                emitCurCodeOffset += offsAdj;

                /* Update the current offset */

                curOffs           += offsAdj;

                /* Update the outstanding/"best" LP ref values */

                wordCnt -= bestWc; bestWc = 0;
                longCnt -= bestLc; bestLc = 0;
                addrCnt -= bestAc; bestAc = 0;
                litSize -= bestSz; bestSz = 0;

                /* if we've unloaded some litpool entries on bestIG but still */
                /* need to put more before the current IG, then need a skip and loop back */
                if (endOffs + litSize + nextLitSize > bestMx)
                {
                    skipIG = true;
                    bestIG = lastIG;
                    goto ALL_LP;
                }

                maxOffs  = bestMx; bestMx = UINT_MAX;

                /* We've used up our "best" IG */

                bestIG = NULL;

                if (doneIG) goto DONE_LP;
            }


#ifdef DEBUG
            //printf("IG #%02u at %04X uses : WLA %d %d %d words %d longs %d\n", tempIG->igNum, tempIG->igOffs, tempIG->igLPuseCntW, tempIG->igLPuseCntL, tempIG->igLPuseCntA, wordCnt, longCnt);
            //printf("IG #%02u at %04X uses : WLA %d %d %d maxoffs %x bestMx %x\n", tempIG->igNum, tempIG->igOffs, tempIG->igLPuseCntW, tempIG->igLPuseCntL, tempIG->igLPuseCntA, maxOffs, bestMx);
            //printf("litsize : %x\n", litSize);

            words += tempIG->igLPuseCntW;
            longs += tempIG->igLPuseCntL;
            addrs += tempIG->igLPuseCntA;
#endif

            /* Does this group need any LP entries? */

            prevWc = wordCnt;
            prevLc = longCnt;
            prevAc = addrCnt;
            prevSz = litSize;
            
            if  (tempIG->igLPuseCntW)
            {
                if  (!wordCnt || !bestWc || need_bestmx || need_bestmxw)
                {
                    unsigned        tmpOffs;

                    /* This is the first "word" LP use */

                    tmpOffs = tempIG->igOffs;
#if SCHEDULER
                    if  (!emitComp->opts.compSchedCode)
#endif
                        tmpOffs += tempIG->igLPuse1stW;

                    /* Figure out the farthest acceptable offset */

                    tmpOffs += LIT_POOL_MAX_OFFS_WORD - 2*INSTRUCTION_SIZE;

                    /* Update the max. offset */

                    if  (!wordCnt)
                    {
                        if  (maxOffs > tmpOffs)
                             maxOffs = tmpOffs;
                    }
                    if (need_bestmx || need_bestmxw)
                    //else
                    {
                        if  (bestMx  > tmpOffs)
                             bestMx  = tmpOffs;
                        need_bestmx = false;
                        need_bestmxw = false;
                    }
                }

                wordCnt += tempIG->igLPuseCntW;
                litSize += tempIG->igLPuseCntW * 2;
                //bestSz  += tempIG->igLPuseCntW * 2;
            }

            if  (tempIG->igLPuseCntL || tempIG->igLPuseCntA)
            {
                if  ((!longCnt && !addrCnt) || (!bestLc && !bestAc) || need_bestmx)
                {
                    unsigned        tmpOffs;

                    /* This is the first long/addr LP use */

                    tmpOffs = tempIG->igOffs;
                    
                    int firstuse = INT_MAX;
                    
                    if (tempIG->igLPuseCntL)
                        firstuse = tempIG->igLPuse1stL;
                    if (tempIG->igLPuseCntA)
                        firstuse = min (firstuse, tempIG->igLPuse1stA);

#if SCHEDULER
                    if  (!emitComp->opts.compSchedCode)
#endif
                        tmpOffs += firstuse;

                    /* Figure out the farthest acceptable offset */

                    tmpOffs += LIT_POOL_MAX_OFFS_LONG - 2*INSTRUCTION_SIZE;

                    /* Update the max. offset */

                    if  (!longCnt && !addrCnt)
                    {
                        if  (maxOffs > tmpOffs)
                             maxOffs = tmpOffs;
                    }
                    if (need_bestmx)
                    {
                        if  (bestMx  > tmpOffs)
                             bestMx  = tmpOffs;
                        need_bestmx = false;
                    }
                }

                longCnt += tempIG->igLPuseCntL;
                litSize += tempIG->igLPuseCntL * sizeof(int  );
                //bestSz  += tempIG->igLPuseCntL * sizeof(int  );

                addrCnt += tempIG->igLPuseCntA;
                litSize += tempIG->igLPuseCntA * sizeof(void*);
                //bestSz  += tempIG->igLPuseCntA * sizeof(void*);
            }

            /* Is the end of this group unreachable? */

            if  (tempIG->igFlags & IGF_END_NOREACH)
            {
                /* Looks like the best candidate so far */

                bestIG = tempIG;

                /* Remember how much we can cram into the best candidate */

                bestWc = wordCnt;
                bestLc = longCnt;
                bestAc = addrCnt;

                //bestSz = 0;
                bestSz = litSize;
                bestMx = UINT_MAX;
                need_bestmx = true;
                need_bestmxw = true;
            }

            /* Is this the last group? */

            //printf("IG #%02u at %04X uses : WLA %d %d %d maxoffs %x bestMx %x\n", tempIG->igNum, tempIG->igOffs, tempIG->igLPuseCntW, tempIG->igLPuseCntL, tempIG->igLPuseCntA, maxOffs, bestMx);

            if  (!nextIG)
            {
                assert(bestIG == tempIG);

                /* Is there any need for a literal pool? */

                if  (wordCnt || longCnt || addrCnt)
                {
                    /* Prevent endless looping */

                    if  (doneIG)
                        break;

                    doneIG = true;
                    bestWc = wordCnt;
                    bestLc = longCnt;
                    bestAc = addrCnt;
                    bestSz = litSize;
                    goto ALL_LP;
                }

                /* We're all done */

                break;
            }

            /* Update the current offset and continue with the next group */

            curOffs += tempIG->igSize;

            lastIG   = tempIG;
            tempIG   = nextIG;
        }

DONE_LP:;

#ifdef DEBUG
      if (verbose)
      {
          printf("Est word need = %3u, alloc = %3u, used = %3u\n", emitEstLPwords, words, LPnxtW - LPtabW);
          printf("Est long need = %3u, alloc = %3u, used = %3u\n", emitEstLPlongs, longs, LPnxtL - LPtabL);
          printf("Est addr need = %3u, alloc = %3u, used = %3u\n", emitEstLPaddrs, addrs, LPnxtA - LPtabA);
      }
#endif

#ifdef  DEBUG

        if  (verbose)
        {
            printf("\nInstruction list after literal pools have been added:\n\n");
            emitDispIGlist(false);
        }

        assert(words <= emitEstLPwords && emitEstLPwords + LPtabW >= LPnxtW);
        assert(longs <= emitEstLPlongs && emitEstLPlongs + LPtabL >= LPnxtL);
        assert(addrs <= emitEstLPaddrs && emitEstLPaddrs + LPtabA >= LPnxtA);
#endif
    }

    /* Make sure all the IG offsets are up-to-date */

    emitCheckIGoffsets();
}


/*****************************************************************************
 *
 *  Finalize the size and contents of each literal pool.
 */

void                emitter::emitFinalizeLitPools()
{
    litPool     *   curLP;
    insGroup    *   litIG;
    instrDescLPR*   lprID;

    insGroup    *   thisIG;
    size_t          offsIG;

    /* Do we have any literal pools? */

    if  (!emitTotLPcount)
        return;

#ifdef  DEBUG

    if  (verbose)
    {
        printf("\nInstruction list before final literal pool allocation:\n\n");
        emitDispIGlist(false);
    }

    emitCheckIGoffsets();

#endif

#if     SMALL_DIRECT_CALLS

    /* Do we already know where the code for this method will end up? */

    if  (emitLPmethodAddr)
        emitShrinkShortCalls();

#endif

    /* Get hold of the first literal pool and its group */

    curLP = emitLitPoolList; assert(curLP);
    litIG = curLP->lpIG;
    lprID = emitLPRlist;

    /* Walk the instruction groups to create the literal pool contents */

    for (thisIG = emitIGlist, offsIG = 0;
         thisIG;
         thisIG = thisIG->igNext)
    {
        thisIG->igOffs = offsIG;

        /* Does this group have any lit pool entries? */

        if  (thisIG->igLPuseCntW ||
             thisIG->igLPuseCntL ||
             thisIG->igLPuseCntA)
        {
            /* Walk the list of instructions that reference the literal pool */

#ifdef  DEBUG
            unsigned    wc = 0;
            unsigned    lc = 0;
            unsigned    ac = 0;
#endif

            do
            {
#if TGT_SH3
#ifdef DEBUG
                emitDispIns(lprID, false, true, false, 0);
#endif
                // maybe this was because of a jmp instruction
                if (lprID->idlIG != thisIG)
                {
                    unsigned    cnt = thisIG->igInsCnt;
                    BYTE    *   ins = thisIG->igData;
                    instrDesc*  id;
#ifdef DEBUG
                    _flushall();
#endif
                    do
                    {
                        instrDesc * id = (instrDesc *)ins;

                        //emitDispIns(id, false, true, false, 0);

                        if (id->idInsFmt == IF_LABEL)
                        {
                            /* Is the jump "very long" ? */

                            if  (((instrDescJmp*)lprID)->idjShort  == false &&
                                 ((instrDescJmp*)lprID)->idjMiddle == false)
                            {
                                /* Add a label entry to the current LP */
#ifdef  DEBUG
                                lc++;
#endif
                            }
                        }
                        
                        ins += emitSizeOfInsDsc(id);
                    }
                    while (--cnt);

                    break;
                    thisIG = thisIG->igNext;
                    while (!(thisIG->igLPuseCntW || thisIG->igLPuseCntL || thisIG->igLPuseCntA))
                        thisIG = thisIG->igNext;
                    continue;

                }
#endif
                assert(lprID && lprID->idlIG == thisIG);

                switch (lprID->idInsFmt)
                {
                case IF_RWR_LIT:

#ifdef  DEBUG

                    /* Just to make sure the counts agree */

                    if  (emitGetInsLPRtyp(lprID) == CT_INTCNS)
                    {
                        if  (emitDecodeSize(lprID->idOpSize) == 2)
                            wc++;
                        else
                            lc++;
                    }
                    else
                    {
                        ac++;
                    }

#endif

#if     SMALL_DIRECT_CALLS

                    /* Ignore calls that have been made direct */

                    if  (lprID->idIns == DIRECT_CALL_INS)
                        break;

#endif

                    /* Add an entry for the operand to the current LP */

                    emitAddLitPoolEntry(curLP, lprID, false);
                    break;

                case IF_LABEL:

                    /* Is the jump "very long" ? */

                    if  (((instrDescJmp*)lprID)->idjShort  == false &&
                         ((instrDescJmp*)lprID)->idjMiddle == false)
                    {
                        /* Add a label entry to the current LP */

#ifdef  DEBUG
                        lc++;
#endif

                        assert(!"add long jump label address to litpool");
                    }
                    break;

#ifdef  DEBUG
                default:
                    assert(!"unexpected instruction in LP list");
#endif
                }

                lprID = lprID->idlNext;
            }
            while (lprID && lprID->idlIG == thisIG);

#ifdef DEBUG
            assert(thisIG->igLPuseCntW == wc);
            //assert(thisIG->igLPuseCntL == lc);
            assert(thisIG->igLPuseCntA == ac);
#endif
        }

        /* Is the current literal pool supposed to go after this group? */

        if  (litIG == thisIG)
        {
            unsigned        begOffs;
            unsigned        jmpSize;

            unsigned        wordCnt;
            unsigned        longCnt;
            unsigned        addrCnt;

            assert(curLP && curLP->lpIG == thisIG);

            /* Subtract the estimated pool size from the group's size */

            thisIG->igSize -= curLP->lpSizeEst; assert((int)thisIG->igSize >= 0);

            /* Compute the starting offset of the pool */

            begOffs = offsIG + thisIG->igSize;

            /* Adjust by the size of the "skip over LP" jump, if present */

            jmpSize = 0;

            if  (curLP->lpJumpIt)
            {
                jmpSize  = emitLPjumpOverSize(curLP);
                begOffs += jmpSize;
            }

            /* Get hold of the counts */

            wordCnt = curLP->lpWordCnt;
            longCnt = curLP->lpLongCnt;
            addrCnt = curLP->lpAddrCnt;


            /* Do we need to align the first long/addr? */

            curLP->lpPadding =
            curLP->lpPadFake = false;

            if  ((begOffs & 3) && (longCnt || addrCnt))
            {
                /* We'll definitely need one word of padding */

                curLP->lpPadding = true;

                /* Do we have any word-sized entries? */

                if  (!wordCnt)
                {
                    /* No, we'll have to pad by adding a "fake" word */

                    curLP->lpPadFake = true;

                    wordCnt++;
                }
            }

            /* Compute the final (accurate) size */

            curLP->lpSize  = wordCnt * 2 +
                             longCnt * 4 +
                             addrCnt * 4;

            /* Make sure the original estimate wasn't too low */

            assert(curLP->lpSize <= curLP->lpSizeEst);

            /* Record the pool's offset within the method */

            curLP->lpOffs  = begOffs;

            /* Add the actual size to the group's size */

            thisIG->igSize += curLP->lpSize + jmpSize;

            /* Move to the next literal pool, if any */

            curLP = curLP->lpNext;
            litIG = curLP ? curLP->lpIG : NULL;
        }

        offsIG += thisIG->igSize;
    }

    /* We should have processed all the literal pools */

    assert(curLP == NULL);
    assert(litIG == NULL);
    assert(lprID == NULL);

    /* Update the total code size of the method */

    emitTotalCodeSize = offsIG;

    /* Make sure all the IG offsets are up-to-date */

    emitCheckIGoffsets();
}

/*****************************************************************************/
#if     SMALL_DIRECT_CALLS
/*****************************************************************************
 *
 *  Convert as many calls as possible into the direct pc-relative variety.
 */

void                emitter::emitShrinkShortCalls()
{
    litPool     *   curLP;
    insGroup    *   litIG;
    unsigned        litIN;
    instrDescLPR*   lprID;

    size_t          ofAdj;

    bool            shrnk;
    bool            swapf;

    /* Do we have any candidate calls at all? */

#ifndef TGT_SH3
    if  (!emitTotDCcount)
        return;
#endif

    /* This is to make recursive calls find their target address */

    emitCodeBlock = emitLPmethodAddr;

    /* Get hold of the first literal pool and the group it belongs to */

    curLP = emitLitPoolList; assert(curLP);
    litIG = curLP->lpIG;
    litIN = litIG->igNum;

    /* Remember whether we shrank any calls at all */

    shrnk = false;

    /* Remember whether to swap any calls to fill branch-delay slots */

    swapf = false;
#if TGT_SH3
    shrnk = true; // always need to do delay slots on sh3
    swapf = true;
#endif

    /* Walk the list of instructions that reference the literal pool */

    for (lprID = emitLPRlist; lprID; lprID = lprID->idlNext)
    {
        instrDesc   *   nxtID;

        BYTE        *   srcAddr;
        BYTE        *   dstAddr;
        int             difAddr;

        /* Does this instruction reference a new literal pool? */

        while (lprID->idlIG->igNum > litIN)
        {
            /* Move to the next literal pool */

            curLP = curLP->lpNext; assert(curLP);
            litIG = curLP->lpIG;
            litIN = litIG->igNum;
        }

        /* We're only interested in direct-via-register call sequences */

        if  (lprID->idInsFmt != IF_RWR_LIT)
            continue;
        if  (lprID->idIns    != LIT_POOL_LOAD_INS)
            continue;
        if  (lprID->idlCall  == NULL)
            continue;

        switch (emitGetInsLPRtyp(lprID))
        {
        case CT_DESCR:

#if defined(BIRCH_SP2) && TGT_SH3
        case CT_RELOCP:
#endif
        case CT_USER_FUNC:
            break;

        default:
            continue;
        }

        /* Here we have a direct call via a register */

        nxtID = lprID->idlCall;

        assert(nxtID->idIns == INDIRECT_CALL_INS);
        assert(nxtID->idRegGet() == lprID->idRegGet());

        /* Assume the call will not be short */

        lprID->idlCall = NULL;

        /* Compute the address from where the call will originate */

        srcAddr = emitDirectCallBase(emitCodeBlock + litIG-> igOffs
                                                   + lprID->idlOffs);

        /* Ask for the address of the target and see how far it is */

#if defined(BIRCH_SP2) && TGT_SH3
    if (~0 != (unsigned) nxtID->idAddr.iiaMethHnd)
    {
        OptPEReader *oper =     &((OptJitInfo*)emitComp->info.compCompHnd)->m_PER;
        dstAddr =  (BYTE *)oper->m_rgFtnInfo[(unsigned)nxtID->idAddr.iiaMethHnd].m_pNative;
    }
    else
        dstAddr = 0;
#else
# ifdef BIRCH_SP2
    assert (0); // you need to guarantee iiaMethHnd if you want this to work <tanj>
# endif
        dstAddr = emitMethodAddr(lprID);
#endif

        /* If the target address isn't known, there isn't much we can do */

        if  (!dstAddr)
            continue;

//      printf("Direct call: %08X -> %08X , dist = %d\n", srcAddr, dstAddr, dstAddr - srcAddr);

        /* Compute the distance and see if it's in range */

        difAddr = dstAddr - srcAddr;

        if  (difAddr < CALL_DIST_MAX_NEG)
            continue;
        if  (difAddr > CALL_DIST_MAX_POS)
            continue;

        /* The call can be made short */

        lprID->idlCall = nxtID;

        /* Change the load-address instruction to a direct call */

        lprID->idIns   = DIRECT_CALL_INS;

        /* The indirect call instruction won't generate any code */

        nxtID->idIns   = INS_ignore;

        /* Update the group's size [ISSUE: may have to use nxtID's group] */

        lprID->idlIG->igSize -= INSTRUCTION_SIZE;

        /* Remember that we've shrunk at least one call */

        shrnk = true;

        /* Is there a "nop" filling the branch-delay slot? */

        if  (Compiler::instBranchDelay(DIRECT_CALL_INS))
        {
            instrDesc   *   nopID;

            /* Get hold of the instruction that follows the call */

            nopID = (instrDesc*)((BYTE*)nxtID + emitSizeOfInsDsc(nxtID));

            /* Do we have a (branch-delay) nop? */

            if  (nopID->idIns == INS_nop)
            {
                /* We'll get rid of the nop later (see next loop below) */

                lprID->idSwap = true;

                swapf = true;
            }
        }
    }

    /* We should have processed all the literal pools */

    // maybe there are lit pools after this that are now empty
    // (could have been used by jumps that are now long)
    //assert(curLP->lpNext == NULL);
    //assert(lprID         == NULL);

    /* Did we manage to shrink any calls? */

    if  (shrnk)
    {
        insGroup    *   thisIG;
        size_t          offsIG;

        for (thisIG = emitIGlist, offsIG = 0;
             thisIG;
             thisIG = thisIG->igNext)
        {
            instrDesc *     id;

            int             cnt;

            /* Update the group's offset */

            thisIG->igOffs = offsIG;

            /* Does this group have any address entries? */

            if  (!thisIG->igLPuseCntA)
                goto NXT_IG;

            /* Did we find any branch-delay slots that can be eliminated? */

            if  (!swapf)
                goto NXT_IG;

            /*
                Walk the instructions of the group, looking for
                the following sequence:

                    <any_ins>
                    direct_call
                    nop

                If we find it, we swap the first instruction
                with the call and zap the nop.
             */

            id  = (instrDesc *)thisIG->igData;
            cnt = thisIG->igInsCnt - 2;

            while (cnt > 0)
            {
                instrDesc *     nd;

                /* Get hold of the instruction that follows */

                nd = (instrDesc*)((BYTE*)id + emitSizeOfInsDsc(id));

                /* Is the following instruction a direct call? */

                if  (nd->idIns == DIRECT_CALL_INS && nd->idSwap)
                {
                    instrDesc *     n1;
                    instrDesc *     n2;

                    /* Skip over the indirect call */

                    n1 = (instrDesc*)((BYTE*)nd + emitSizeOfInsDsc(nd));
                    assert(n1->idIns == INS_ignore);

                    /* Get hold of the "nop" that is known to follow */

                    n2 = (instrDesc*)((BYTE*)n1 + emitSizeOfInsDsc(n1));
                    assert(n2->idIns == INS_nop);

                    /* The call was marked as "swapped" only temporarily */

                    nd->idSwap = false;

                    /* Are we scheduling "for real" ? */

#if SCHEDULER
                    if  (emitComp->opts.compSchedCode)
                    {
                        /* Move the "nop" into the branch-delay slot */

                        n1->idIns       = INS_nop;
                        n2->idIns       = INS_ignore;
                    }
                    else
#endif
                    {
                        if (!emitInsDepends(nd, id))
                        {
                            /* Swap the call with the previous instruction */
                          
                            id->idSwap      = true;

                            /* Zap the branch-delay slot (the "nop") */

                            n2->idIns       = INS_ignore;
                            
                            /* Update the group's size */
                            
                            thisIG->igSize -= INSTRUCTION_SIZE;
                        }
                    }
                }
#if TGT_SH3
                else if (nd->idIns == INS_jsr)
                {
                    instrDesc *     nop;

                    nop = (instrDesc*)((BYTE*)nd + emitSizeOfInsDsc(nd));
                    assert(nop->idIns == INS_nop);

                    if (!emitInsDepends(nd, id))
                    {
                        /* Swap the call with the previous instruction */
                        id->idSwap      = true;
                        /* Zap the branch-delay slot (the "nop") */
                        nop->idIns       = INS_ignore;

                        /* Update the group's size */
                        thisIG->igSize -= INSTRUCTION_SIZE;
                    }
                }
#endif

                /* Continue with the next instruction */

                id = nd;

                cnt--;
            }

        NXT_IG:

            /* Update the running offset */

            offsIG += thisIG->igSize;
        }

        assert(emitTotalCodeSize); emitTotalCodeSize = offsIG;
    }

    /* Make sure all the IG offsets are up-to-date */

    emitCheckIGoffsets();
}

/*****************************************************************************/
#endif//SMALL_DIRECT_CALLS
/*****************************************************************************
 *
 *  Output the contents of the next literal pool.
 */

BYTE    *           emitter::emitOutputLitPool(litPool *lp, BYTE *cp)
{
    unsigned        wordCnt = lp->lpWordCnt;
    short       *   wordPtr = lp->lpWordTab;
    unsigned        longCnt = lp->lpLongCnt;
    long        *   longPtr = lp->lpLongTab;
    unsigned        addrCnt = lp->lpAddrCnt;
    LPaddrDesc  *   addrPtr = lp->lpAddrTab;

    size_t          curOffs;

    /* Bail of no entry ended up being used in this pool */

    if  ((wordCnt|longCnt|addrCnt) == 0)
        return  cp;

    /* Compute the current code offset */

    curOffs = emitCurCodeOffs(cp);

    /* Do we need to jump over the literal pool? */

    if  (lp->lpJumpIt)
    {
        /* Reserve space for the jump over the pool */

        curOffs += emitLPjumpOverSize(lp);
    }

#if     SCHEDULER

    bool            addPad = false;

    /* Has the offset of this LP changed? */

    if  (lp->lpOffs != curOffs)
    {
        LPcrefDesc  *   ref;

        size_t          oldOffs = lp->lpOffs;
        size_t          tmpOffs = curOffs;

        assert(emitComp->opts.compSchedCode);

        /* Has the literal pool moved by an unaligned amount? */

        if  ((curOffs - oldOffs) & 2)
        {
            /* Did we originally think we would need padding? */

            if  (lp->lpPadding)
            {
                /*
                    OK, we thought we'd need padding but with the new LP
                    position that's not the case any more. If the padding
                    value is an unused one, simply get rid of it; if it
                    contains a real word entry, we'll have to add padding
                    in front of the LP to keep things aligned, as moving
                    the initial word entry is too difficult at this point.
                 */

                if  (lp->lpPadFake)
                {
                    /* Padding no longer needed, just get rid of it */

                    lp->lpPadding =
                    lp->lpPadFake = false;
                }
                else
                {
                    /*
                        This is the unfortunate scenario described above;
                        we thought we'd need padding and we achieved this
                        by sticking the first word entry in front of all
                        the dword entries. It's simply too hard to move
                        that initial word someplace else at this point,
                        so instead we just add another pad word. Sigh.
                     */

                ADD_PAD:

                    /* Come here to add a pad word in front of the LP */

                    addPad = true; lp->lpSize += 2;

                    /* Update the offset and see if it's still different */

                    curOffs += 2;

                    if  (curOffs == oldOffs)
                        goto DONE_MOVE;
                }
            }
            else
            {
                /*
                    There is currently no padding. If there are any
                    entries that need to be aligned, we'll have to
                    add padding now, lest they end up mis-aligned.
                 */

                assert((oldOffs & 2) == 0);
                assert((curOffs & 2) != 0);

                if  (longCnt || addrCnt)
                {
                    lp->lpPadding =
                    lp->lpPadFake = true;

                    /* Does the padding take up all the savings? */

                    if  (oldOffs == curOffs + sizeof(short))
                    {
                        /* Nothing really changed, no need to patch */

                        goto NO_PATCH;
                    }

                    tmpOffs += sizeof(short);
                }
            }
        }

        /* Patch all issued instructions that reference this LP */

        for (ref = lp->lpRefs; ref; ref = ref->lpcNext)
            emitPatchLPref(ref->lpcAddr, oldOffs, tmpOffs);

    NO_PATCH:

        /* Update the offset of the LP */

        lp->lpOffs = curOffs; assert(oldOffs != curOffs);
    }

DONE_MOVE:

#else

    assert(lp->lpOffs == curOffs);

#endif

    /* Do we need to jump over the literal pool? */

    if  (lp->lpJumpIt)
    {

#ifdef DEBUG
        /* Remember the code offset so that we can verify the jump size */
        unsigned    jo = emitCurCodeOffs(cp);
#endif

        /* Skip over the literal pool */

#ifdef  DEBUG
        emitDispIG = lp->lpIG->igNext;  // for instruction display purposes
#endif

#if TGT_SH3
        if (lp->lpJumpSmall)
        {
            cp += emitOutputWord(cp, 0x0009);
        }
#endif
        cp = emitOutputFwdJmp(cp, lp->lpSize, lp->lpJumpSmall,
                                              lp->lpJumpMedium);

        /* Make sure the issued jump had the expected size */

#ifdef DEBUG
        assert(jo + emitLPjumpOverSize(lp) == emitCurCodeOffs(cp));
#endif
    }

#ifdef  DEBUG
    if (disAsm) printf("\n; Literal pool %02u:\n", lp->lpNum);
#endif

#ifdef DEBUG
    unsigned    lpBaseOffs = emitCurCodeOffs(cp);
#endif

#if     SCHEDULER

    /* Do we need to insert additional padding? */

    if  (addPad)
    {
        /* This can only happen when the scheduler is enabled */

        assert(emitComp->opts.compSchedCode);

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME "0                   ; pool alignment (due to scheduling)\n", ".data.w");
        }
#endif

        cp += emitOutputWord(cp, 0);
    }

#endif

    /* Output the contents of the literal pool */

    if  (lp->lpPadding)
    {

#ifdef  DEBUG
        if (disAsm) emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
#endif

        /* Are we padding with the first word entry? */

        if  (lp->lpPadFake)
        {

#if !   SCHEDULER
            assert(wordCnt == 0);
#endif

#ifdef  DEBUG
            if (disAsm) printf(EMIT_DSP_INS_NAME "0                   ; pool alignment\n", ".data.w");
#endif
            cp += emitOutputWord(cp, 0);
        }
        else
        {
            assert(wordCnt != 0);

#ifdef  DEBUG
            if (disAsm) printf(EMIT_DSP_INS_NAME "%d\n", ".data.w", *wordPtr);
#endif
            cp += emitOutputWord(cp, *wordPtr);

            wordPtr++;
            wordCnt--;
        }
    }

    /* Output any long entries */

    while (longCnt)
    {
        int         val = *longPtr;

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME "%d\n", ".data.l", val);
        }
#endif

        assert(longPtr < lp->lpLongNxt);

        cp += emitOutputLong(cp, val);

        longPtr++;
        longCnt--;
    }

    /* Output any addr entries */

    while (addrCnt)
    {
        gtCallTypes     addrTyp = addrPtr->lpaTyp;
        void        *   addrHnd = addrPtr->lpaHnd;

        void        *   addr;

        /* What kind of an address do we have here? */

        switch (addrTyp)
        {
            InfoAccessType accessType = IAT_VALUE;

#ifdef BIRCH_SP2

        case CT_RELOCP:
            addr = (BYTE*)addrHnd;
            // record that this addr must be in the .reloc section
            emitCmpHandle->recordRelocation((void**)cp, IMAGE_REL_BASED_HIGHLOW);
            break;

#endif

        case CT_CLSVAR:


            addr = (BYTE *)emitComp->eeGetFieldAddress(addrHnd);
            if (!addr)
                NO_WAY("could not obtain address of static field");

            break;

        case CT_HELPER:

            assert(!"ToDo");

            break;

        case CT_DESCR:

            addr = (BYTE*)emitComp->eeGetMethodEntryPoint((CORINFO_METHOD_HANDLE)addrHnd, &accessType);
            assert(accessType == IAT_PVALUE);
            break;

        case CT_INDIRECT:
            assert(!"this should never happen");

        case CT_USER_FUNC:

            if  (emitComp->eeIsOurMethod((CORINFO_METHOD_HANDLE)addrHnd))
            {
                /* Directly recursive call */

                addr = emitCodeBlock;
            }
            else
            {
                addr = (BYTE*)emitComp->eeGetMethodPointer((CORINFO_METHOD_HANDLE)addrHnd, &accessType);
                assert(accessType == IAT_VALUE);
            }

            break;

        default:
            assert(!"unexpected call type");
        }

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME, ".data.l");
            printf("0x%08X          ; ", addr);

            if  (addrTyp == CT_CLSVAR)
            {
                printf("&");
                emitDispClsVar((CORINFO_FIELD_HANDLE) addrHnd, 0);
            }
            else
            {
                const char  *   methodName;
                const char  *    className;

                printf("&");

                methodName = emitComp->eeGetMethodName((CORINFO_METHOD_HANDLE) addrHnd, &className);

                if  (className == NULL)
                    printf("'%s'", methodName);
                else
                    printf("'%s.%s'", className, methodName);
            }

            printf("\n");
        }
#endif

        assert(addrPtr < lp->lpAddrNxt);

        cp += emitOutputLong(cp, (int)addr);

        addrPtr++;
        addrCnt--;
    }

    /* Output any word entries that may remain */

    while (wordCnt)
    {
        int         val = *wordPtr;

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME "%d\n", ".data.w", val);
        }
#endif

        assert(wordPtr < lp->lpWordNxt);

        cp += emitOutputWord(cp, val);

        wordPtr++;
        wordCnt--;
    }

    /* Make sure we've generated the exact right number of entries */

    assert(wordPtr == lp->lpWordNxt);
    assert(longPtr == lp->lpLongNxt);
    assert(addrPtr == lp->lpAddrNxt);

    /* Make sure the size matches our expectations */

    assert(lpBaseOffs + lp->lpSize == emitCurCodeOffs(cp));

    return  cp;
}

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Record a reference to a literal pool entry so that the distance can be
 *  updated if the literal pool moves due to scheduling.
 */

    struct  LPcrefDesc
    {
        LPcrefDesc  *       lpcNext;    // next ref to this literal pool
        void        *       lpcAddr;    // address of reference
    };


void                emitter::emitRecordLPref(litPool *lp, BYTE *dst)
{
    LPcrefDesc  *   ref;

    assert(emitComp->opts.compSchedCode);

    /* Allocate a reference descriptor and add it to the list */

    ref = (LPcrefDesc *)emitGetMem(sizeof(*ref));

    ref->lpcAddr = dst;
    ref->lpcNext = lp->lpRefs;
                   lp->lpRefs = ref;
}

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#endif//EMIT_USE_LIT_POOLS
/*****************************************************************************/

/*****************************************************************************
 *
 *  Return the allocated size (in bytes) of the given instruction descriptor.
 */

size_t              emitter::emitSizeOfInsDsc(instrDesc *id)
{
    if  (emitIsTinyInsDsc(id))
        return  TINY_IDSC_SIZE;

    if  (emitIsScnsInsDsc(id))
    {
        return  id->idInfo.idLargeCns ? sizeof(instrBaseCns)
                                      : SCNS_IDSC_SIZE;
    }

    assert((unsigned)id->idInsFmt < emitFmtCount);

    switch (emitFmtToOps[id->idInsFmt])
    {
    case ID_OP_NONE:
        break;

    case ID_OP_JMP:
        return  sizeof(instrDescJmp);

    case ID_OP_CNS:
        return  emitSizeOfInsDsc((instrDescCns   *)id);

    case ID_OP_DSP:
        return  emitSizeOfInsDsc((instrDescDsp   *)id);

    case ID_OP_DC:
        return  emitSizeOfInsDsc((instrDescDspCns*)id);

    case ID_OP_SCNS:
        break;

    case ID_OP_CALL:

        if  (id->idInfo.idLargeCall)
        {
            /* Must be a "fat" indirect call descriptor */

            return  sizeof(instrDescCIGCA);
        }

        assert(id->idInfo.idLargeCns == false);
        assert(id->idInfo.idLargeDsp == false);
        break;

    case ID_OP_SPEC:

#if EMIT_USE_LIT_POOLS
        switch (id->idInsFmt)
        {
        case IF_RWR_LIT:
            return  sizeof(instrDescLPR);
        }
#endif  // EMIT_USE_LIT_POOLS

        assert(!"unexpected 'special' format");

    default:
        assert(!"unexpected instruction descriptor format");
    }

    return  sizeof(instrDesc);
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Return a string that represents the given register.
 */

const   char *      emitter::emitRegName(emitRegs reg, int size, bool varName)
{
    static
    char            rb[128];

    assert(reg < SR_COUNT);

    // CONSIDER: Make the following work just using a code offset

    const   char *  rn = emitComp->compRegVarName((regNumber)reg, varName);

//  assert(size == EA_GCREF || size == EA_BYREF || size == EA_4BYTE);

    return  rn;
}

/*****************************************************************************
 *
 *  Display a static data member reference.
 */

void                emitter::emitDispClsVar(CORINFO_FIELD_HANDLE hand, int offs, bool reloc)
{
    if  (varNames)
    {
        const   char *  clsn;
        const   char *  memn;

        memn = emitComp->eeGetFieldName(hand, &clsn);

        printf("'%s.%s", clsn, memn);
        if (offs) printf("%+d", offs);
        printf("'");
    }
    else
    {
        printf("classVar[%08X]", hand);
    }
}

/*****************************************************************************
 *
 *  Display a stack frame reference.
 */

void                emitter::emitDispFrameRef(int varx, int offs, int disp, bool asmfm)
{
    int         addr;
    bool        bEBP;

    assert(emitComp->lvaDoneFrameLayout);

    addr = emitComp->lvaFrameAddress(varx, &bEBP) + disp; assert((int)addr >= 0);

    printf("@(%u,%s)", addr, bEBP ? "fp" : "sp");

    if  (varx >= 0 && varNames)
    {
        Compiler::LclVarDsc*varDsc;
        const   char *      varName;

        assert((unsigned)varx < emitComp->lvaCount);
        varDsc  = emitComp->lvaTable + varx;
        varName = emitComp->compLocalVarName(varx, offs);

        if  (varName)
        {
            printf("'%s", varName);

            if      (disp < 0)
                    printf("-%d", -disp);
            else if (disp > 0)
                    printf("+%d", +disp);

            printf("'");
        }
    }
}

/*****************************************************************************
 *
 *  Display an indirection (possibly auto-inc/dec).
 */

void                emitter::emitDispIndAddr(emitRegs  base,
                                              bool       dest,
                                              bool       autox,
                                              int        disp)
{
    if  (dest)
    {
        printf("@%s%s", autox ? "-" : "", emitRegName(base));
    }
    else
    {
        printf("@%s%s", emitRegName(base), autox ? "+" : "");
    }
}

#endif  // DEBUG

#endif//TGT_RISC
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emittgt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITTGT_H_
#define _EMITTGT_H_
/*****************************************************************************/

enum    emitRegs
{
    #if     TGT_x86
    #define REGDEF(name, rnum, mask, byte)  SR_##name = rnum,
    #include "register.h"
    #undef  REGDEF
    #endif

    #if     TGT_SH3
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regSH3.h"
    #undef  REGDEF
    #endif

    #if     TGT_MIPS32
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regMIPS.h"
    #undef  REGDEF
    #endif

    #if     TGT_ARM
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regARM.h"
    #undef  REGDEF
    #endif

    #if     TGT_PPC
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regPPC.h"
    #undef  REGDEF
    #endif

    SR_COUNT,
    SR_NA = SR_COUNT
};

enum    emitRegMasks
{
    #if     TGT_x86
    #define REGDEF(name, rnum, mask, byte)  SRM_##name = mask,
    #include "register.h"
    #undef  REGDEF
    SRM_BYTE_REGS = (SRM_EAX|SRM_EBX|SRM_ECX|SRM_EDX)
    #define SRM_INTRET  SRM_EAX
    #endif

    #if     TGT_SH3
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regSH3.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif

    #if     TGT_MIPS32
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regMIPS.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif

    #if     TGT_ARM
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regARM.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif

    #if     TGT_PPC
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regPPC.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif
};

/*****************************************************************************
 *
 *  Define any target-specific flags that get passed to the various emit
 *  functions.
 */

#if     TGT_SH3

#define AIF_MOV_IND_AUTOX   0x01        // @reg+ or @-reg

#endif

/*****************************************************************************
 *
 *  Define the various indirect jump types supported for the given target.
 */

#if     TGT_SH3

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_UNS_U1,           // unsigned, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance
    IJ_SHF_U1,           // unsigned,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_UNS_U2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};

#elif TGT_MIPS32

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_SHF_I2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};

#elif TGT_PPC // @TODO: Don't be a copycat

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_SHF_I2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};

#elif TGT_ARM

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_UNS_U1,           // unsigned, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance
    IJ_SHF_U1,           // unsigned,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_UNS_U2,           // unsigned, unshifted 16-bit distance
    IJ_SHF_I2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};
#endif

/*****************************************************************************
 *
 *  Different targets needs to store additonal varieties of values in
 *  the instruction descriptor's "idAddr" union. These should all be
 *  defined here and bound to the "ID_TGT_DEP_ADDR" macro, which is
 *  invoked within the union.
 */

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************/

struct          emitAddrMode
{
    BYTE            amBaseReg;
    BYTE            amIndxReg;
    short           amDisp :14;
#define AM_DISP_BIG_VAL   (-(1<<13  ))
#define AM_DISP_MIN       (-((1<<13)-1))
#define AM_DISP_MAX       (+((1<<13)-1))
    unsigned short  amScale :2;         // 0=*1 , 1=*2 , 2=*4 , 3=*8
};

#define ID_TGT_DEP_ADDR                 \
                                        \
    emitAddrMode    iiaAddrMode;

/*****************************************************************************/
#elif   TGT_SH3
/*****************************************************************************/

struct          emitRegNflags
{
    unsigned short  rnfFlg;             // see RNF_xxxx below
    #define RNF_AUTOX       0x0001      // auto-index addressing mode

    unsigned short  rnfReg;
};

#define ID_TGT_DEP_ADDR                 \
                                        \
    emitRegNflags   iiaRegAndFlg;

/*****************************************************************************/
#elif   TGT_MIPS32
    #define ID_TGT_DEP_ADDR
#elif   TGT_ARM
    #define ID_TGT_DEP_ADDR
#elif   TGT_PPC
    #define ID_TGT_DEP_ADDR
#else
/*****************************************************************************/
#error  Unexpected target
/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#endif//_EMITTGT_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\gcdecode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "jitpch.h"
#pragma hdrstop

/* Precompiled header nonsense requires that we do it this way  */

/* GCDecoder.cpp is a common source file bewtween VM and JIT/IL */
/* GCDecoder.cpp is located in $COM99/inc                       */

#if TRACK_GC_REFS
#include "GCDecoder.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitx86.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /************************************************************************/
    /*         Routines that compute the size of / encode instructions      */
    /************************************************************************/

    struct CnsVal
    {
        long cnsVal;
#ifdef RELOC_SUPPORT
        bool cnsReloc;
#endif
    };

    size_t          emitInsSize   (unsigned   code);
    size_t          emitInsSizeRM (instruction ins);
    size_t          emitInsSizeSV (unsigned   code, int var, int dsp);
    size_t          emitInsSizeSV (instrDesc * id,  int var, int dsp, int val);
    size_t          emitInsSizeRR (instruction ins);
    size_t          emitInsSizeAM (instrDesc * id,  unsigned code);
    size_t          emitInsSizeAM (instrDesc * id,  unsigned code, int val);
    size_t          emitInsSizeCV (instrDesc * id,  unsigned code);
    size_t          emitInsSizeCV (instrDesc * id,  unsigned code, int val);

    BYTE    *       emitOutputAM  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal * addc = NULL);
    BYTE    *       emitOutputSV  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal * addc = NULL);
    BYTE    *       emitOutputCV  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal * addc = NULL);

    BYTE    *       emitOutputR   (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputRI  (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputRR  (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputIV  (BYTE *dst, instrDesc *id);

    BYTE    *       emitOutputLJ  (BYTE *dst, instrDesc *id);

    /************************************************************************/
    /*             Debug-only routines to display instructions              */
    /************************************************************************/

#ifdef  DEBUG

    const   char *  emitFPregName   (unsigned       reg,
                                     bool           varName = true);

    void            emitDispEpilog  (instrDesc *id, unsigned offs);

    void            emitDispAddrMode(instrDesc *id, bool noDetail = false);
    void            emitDispShift   (instruction ins, int cnt = 0);

    void            emitDispIns     (instrDesc *id, bool isNew,
                                                    bool doffs,
                                                    bool asmfm, unsigned offs = 0);

#endif

    /************************************************************************/
    /*  Private members that deal with target-dependent instr. descriptors  */
    /************************************************************************/

private:

    struct          instrDescAmdCns : instrDesc     // large addrmode disp + cons
    {
        long            idacAmdVal;
        long            idacCnsVal;
    };

    struct          instrDescCDGCA  : instrDesc     // direct call with ...
    {
        VARSET_TP       idcdGCvars;                 // ... updated GC vars or
        unsigned        idcdByrefRegs;              // ... byref registers
        int             idcdArgCnt;                 // ... lots of args    or (<0 ==> caller pops args)
    };

    instrDescAmd   *emitAllocInstrAmd    (emitAttr attr)
    {
        return  (instrDescAmd   *)emitAllocInstr(sizeof(instrDescAmd   ), attr);
    }

    instrDescAmdCns*emitAllocInstrAmdCns (emitAttr attr)
    {
        return  (instrDescAmdCns*)emitAllocInstr(sizeof(instrDescAmdCns), attr);
    }

    instrDescCDGCA *emitAllocInstrCDGCA  (emitAttr attr)
    {
        return  (instrDescCDGCA *)emitAllocInstr(sizeof(instrDescCDGCA ), attr);
    }

    instrDesc      *emitNewInstrAmd     (emitAttr attr, int dsp);
    instrDesc      *emitNewInstrAmdCns  (emitAttr attr, int dsp, int cns);

    instrDesc      *emitNewInstrCallDir (int        argCnt,
#if TRACK_GC_REFS
                                         VARSET_TP  GCvars,
                                         unsigned   byrefRegs,
#endif
                                         int        retSize);

    instrDesc      *emitNewInstrCallInd( int        argCnt,
                                         int        disp,
#if TRACK_GC_REFS

                                         VARSET_TP  GCvars,
                                         unsigned   byrefRegs,
#endif
                                         int        retSize);

    void            emitGetInsCns   (instrDesc *id, CnsVal *cv);
    int             emitGetInsAmdCns(instrDesc *id, CnsVal *cv);
    void            emitGetInsDcmCns(instrDesc *id, CnsVal *cv);
    int             emitGetInsAmdAny(instrDesc *id);
    int             emitGetInsCDinfo(instrDesc *id);

    size_t          emitSizeOfInsDsc(instrDescAmd    *id);
    size_t          emitSizeOfInsDsc(instrDescAmdCns *id);

    /************************************************************************/
    /*               Private helpers for instruction output                 */
    /************************************************************************/

private:

    insFormats      emitInsModeFormat(instruction ins, insFormats base,
                                                       insFormats FPld,
                                                       insFormats FPst);

    void            emitFinalizeIndJumps(){}

    /*****************************************************************************
    *
    *  Convert between an index scale in bytes to a smaller encoding used for
    *  storage in instruction descriptors.
    */

    inline
    unsigned           emitEncodeScale(size_t scale)
    {
        assert(scale == 1 || scale == 2 || scale == 4 || scale == 8);

        return  (unsigned) emitSizeEnc[scale-1];
    }

    inline
    size_t            emitDecodeScale(unsigned ensz)
    {
        assert(ensz < 4);

        return  (size_t) emitter::emitSizeDec[ensz];
    }


    /************************************************************************/
    /*           The public entry points to output instructions             */
    /************************************************************************/

public:

    void            emitLoopAlign  (bool        flowInto);

    void            emitIns        (instruction ins);

    void            emitIns_I      (instruction ins,
                                    emitAttr    attr,
                                    int         val
#ifdef  DEBUG
                                  , bool        strlit = false
#endif
                                   );

    void            emitIns_R      (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    reg);

    void            emitIns_C      (instruction  ins,
                                    emitAttr     attr,
                                    CORINFO_FIELD_HANDLE fdlHnd,
                                    int          offs);

    void            emitIns_R_I    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    reg,
                                    int         val);

    void            emitIns_R_MP   (instruction   ins,
                                    emitAttr      attr,
                                    emitRegs      reg,
                                    CORINFO_METHOD_HANDLE methHnd);

    void            emitIns_R_R    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    reg1,
                                    emitRegs    reg2);

    void            emitIns_R_R_I  (instruction ins,
                                    emitRegs    reg1,
                                    emitRegs    reg2,
                                    int         ival);

    void            emitIns_S      (instruction ins,
                                    emitAttr    attr,
                                    int         varx,
                                    int         offs);

    void            emitIns_S_R    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_R_S    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_S_I    (instruction ins,
                                    emitAttr    attr,
                                    int         varx,
                                    int         offs,
                                    long        val);

    void            emitIns_R_C    (instruction  ins,
                                    emitAttr     attr,
                                    emitRegs     reg,
                                    CORINFO_FIELD_HANDLE fdlHnd,
                                    int          offs);

    void            emitIns_C_R    (instruction  ins,
                                    emitAttr     attr,
                                    CORINFO_FIELD_HANDLE fdlHnd,
                                    emitRegs     reg,
                                    int          offs);

    void            emitIns_C_I    (instruction  ins,
                                    emitAttr     attr,
                                    CORINFO_FIELD_HANDLE fdlHnd,
                                    int          offs,
                                    int          val);

    void            emitIns_IJ     (emitAttr    attr,
                                    emitRegs    reg,
                                    unsigned    base,
                                    unsigned    offs);

    void            emitIns_J_AR   (instruction ins,
                                    emitAttr    attr,
                                    BasicBlock *val,
                                    emitRegs    reg,
                                    int         offs,
                                    int         memCookie = 0,
                                    void *      clsCookie = NULL);

    void            emitIns_I_AR   (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    int         offs,
                                    int         memCookie = 0,
                                    void *      clsCookie = NULL);

    void            emitIns_R_AR   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    int         offs,
                                    int         memCookie = 0,
                                    void *      clsCookie = NULL);

    void            emitIns_AR_R   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    int         offs,
                                    int         memCookie = 0,
                                    void *      clsCookie = NULL);

    void            emitIns_I_ARR  (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    int         disp);

    void            emitIns_R_ARR  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    int         disp);

    void            emitIns_ARR_R  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    int         disp);

    void            emitIns_I_ARX  (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_R_ARX  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_ARX_R  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_I_AX   (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_R_AX   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_AX_R   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_F_F0   (instruction ins,
                                    unsigned    fpreg);

    void            emitIns_F0_F   (instruction ins,
                                    unsigned    fpreg);

#if!SCHEDULER
#define scAddIns_J(jmp, xcpt, move, dst) scAddIns_J(jmp, dst)
#endif

    enum EmitCallType
    {
        EC_FUNC_TOKEN,          //   Direct call to a helper/static/nonvirtual/global method
        EC_FUNC_TOKEN_INDIR,    // Indirect call to a helper/static/nonvirtual/global method
        EC_FUNC_ADDR,           // Direct call to an absolute address

        EC_FUNC_VIRTUAL,        // Call to a virtual method (using the vtable)
        EC_INDIR_R,             // Indirect call via register
        EC_INDIR_SR,            // Indirect call via stack-reference (local var)
        EC_INDIR_C,             // Indirect call via static class var
        EC_INDIR_ARD,           // Indirect call via an addressing mode

        EC_COUNT
    };

    void            emitIns_Call   (EmitCallType    callType,
                                    void*           callVal,
                                    int             argSize,
                                    int             retSize,
                                    VARSET_TP       ptrVars,
                                    unsigned        gcrefRegs,
                                    unsigned        byrefRegs,
                                    emitRegs        ireg = SR_NA,
                                    emitRegs        xreg = SR_NA,
                                    unsigned        xmul = 0,
                                    int             disp = 0,
                                    bool            isJump = false);

#ifdef  RELOC_SUPPORT

    BYTE* getCurrentCodeAddr(BYTE* codeBuffPtr);

    class X86deferredCall : public IDeferredLocation
    {
      private:
          CORINFO_METHOD_HANDLE   m_mh;
          unsigned *      m_dest;
          BYTE *          m_srcAddr;
                  COMP_HANDLE     m_cmp;

      public:

          X86deferredCall (COMP_HANDLE cmp, CORINFO_METHOD_HANDLE mh, BYTE* dest, BYTE* srcAddr)
             : m_cmp(cmp), m_mh(mh), m_dest((unsigned*)dest), m_srcAddr(srcAddr) {}

          virtual void  applyLocation();

          static X86deferredCall* create(Compiler* comp, COMP_HANDLE cmp, CORINFO_METHOD_HANDLE methHnd,
                                         BYTE* dest, BYTE* srcAddr);

    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\error.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _ERROR_H_
#define _ERROR_H_
/*****************************************************************************/

#include <corjit.h>     // for CORJIT_INTERNALERROR

extern  int             __filter  (int   exceptCode, void *exceptInfo, int *errCode);
        // Only catch JIT internal errors (will not catch EE generated Errors)
extern  int             __JITfilter  (int   exceptCode, void *exceptInfo, int *errCode);

extern  void            __JITraiseErr(int errCode);

#define                 setErrorTrap()                                      \
    int  __errc = CORJIT_INTERNALERROR;                                     \
    __try                                                                   \
    {                                                                       \
                __errc;                 /* reference so that /W4 is happy */

        // Catch only JitGeneratedErrors
#define                 impJitErrorTrap()                                   \
    }                                                                       \
    __except(__JITfilter(_exception_code(), _exception_info(), &__errc))    \
    {


        // Catch all errors (including recoverable ones from the EE)
#define                 impErrorTrap(compHnd)                               \
    }                                                                       \
    __except(compHnd->FilterException(GetExceptionInformation()))           \
    {

#define                 endErrorTrap()                                      \
    }                                                                       \

#define                 jmpErrorTrap(errCode)                               \
    __JITraiseErr(errCode);

#define                 rstErrorTrap()                                      \
    __JITraiseErr(__errc);

#define                 finallyErrorTrap()                                  \
    }                                                                       \
    __finally                                                               \
    {


/*****************************************************************************/

extern void debugError(const char* msg, const char* file, unsigned line);
extern bool badCode();
extern bool badCode3(const char* msg, const char* msg2, int arg, char* file, unsigned line);
extern bool noWay();
extern void NOMEM();

extern bool BADCODE3(const char* msg, const char* msg2, int arg);


#ifdef DEBUG
#define NO_WAY(msg) (debugError(msg, __FILE__, __LINE__), noWay())
// Used for fallback stress mode
#define NO_WAY_NOASSERT(msg) noWay()
#define BADCODE(msg) (debugError(msg, __FILE__, __LINE__), badCode())
#define BADCODE3(msg, msg2, arg) badCode3(msg, msg2, arg, __FILE__, __LINE__)

#else 

#define NO_WAY(msg) noWay()
#define BADCODE(msg) badCode()
#define BADCODE3(msg, msg2, arg) badCode()

#endif

	// IMPL_LIMITATION is called when we encounter valid IL that is not
	// supported by our current implementation because of various
	// limitations (that could be removed in the future)
#define IMPL_LIMITATION(msg) NO_WAY(msg)

// By using these instead of a simple NO_WAY, we are hoping that they
// get folded together in tail merging by BBT (basically there will be
// only one instance of them.  
// If it does not pan out we should get rid of them or another possibility
// is to mark the NO_WAY fuction __declspec(noreturn)
// and then MAYBE BBT will do the right thing

#define NO_WAY_RET(str, type)   { return (type) NO_WAY(str);    }
#define NO_WAY_RETVOID(str)     { NO_WAY(str); return;          }


#ifdef _X86_

// While debugging in an Debugger, the "int 3" will cause the program to break
// Outside, the exception handler will just filter out the "int 3".

#define BreakIfDebuggerPresent()                                            \
    do { __try { __asm {int 3} } __except(EXCEPTION_EXECUTE_HANDLER) {} }   \
    while(0)

#else
#define BreakIfDebuggerPresent()        0
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\error.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           error.cpp                                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "error.h"
#include <winbase.h>

/*****************************************************************************/
static void fatal(int errCode)
{
    DWORD       exceptArg = errCode;
    RaiseException(0x02345678, 0, 1, &exceptArg);
}

/*****************************************************************************/
bool badCode() 
{
    fatal(CORJIT_BADCODE);
    return 0;
}

/*****************************************************************************/
bool noWay() 
{
    fatal(CORJIT_INTERNALERROR);
    return 0;
}

/*****************************************************************************/
void NOMEM()
{
    fatal(CORJIT_OUTOFMEM);
}


/*****************************************************************************/

int                 __JITfilter(int exceptCode, void *exceptInfo, int *errCode)
{
        // Only catch EH from __JITraiseErr
    return(exceptCode ==  0x02345678);
}

/*****************************************************************************/
#ifdef DEBUG
#include <stdarg.h>

ConfigDWORD fBreakOnBadCode(L"JitBreakOnBadCode", false);
ConfigDWORD fJitRequired(L"JITRequired", true);

/*****************************************************************************/
void debugError(const char* msg, const char* file, unsigned line) 
{
	const char* tail = strrchr(file, '\\');
	if (tail) file = tail+1;

    LogEnv* env = LogEnv::cur();
    JITLOG((LL_ERROR, "COMPILATION FAILED: file: %s:%d compiling method %s reason %s\n", file, line, env->compiler->info.compFullName, msg));
    if (fJitRequired.val())
    {
            // Don't assert if verification is done.
        if (!env->compiler->tiVerificationNeeded || fBreakOnBadCode.val())
            assertAbort(msg, "NO-FILE", 0);
    }

    BreakIfDebuggerPresent();
}


/*****************************************************************************/
/* static */ int LogEnv::tlsID = -1;

inline LogEnv* LogEnv::cur() {
    return((LogEnv*) TlsGetValue(tlsID));
}

LogEnv::LogEnv(ICorJitInfo* aCompHnd) : compHnd(aCompHnd), compiler(0) 
{
    if (tlsID == -1)
        tlsID = TlsAlloc();
    next = (LogEnv*) TlsGetValue(tlsID);
    TlsSetValue(tlsID, this);
}

LogEnv::~LogEnv()
{
    TlsSetValue(tlsID, next);   // pop me off the environment stack
}

void LogEnv::cleanup()
{
    if (tlsID != -1)
        TlsFree(tlsID);
}

/*****************************************************************************/
extern  "C"
void  __cdecl   assertAbort(const char *why, const char *file, unsigned line)
{
    LogEnv* env = LogEnv::cur();
    char buff[1024];
    if (env->compiler) {
        sprintf(buff, "Assertion failed '%s' in '%s'\n", why, env->compiler->info.compFullName);
        why = buff;
    }
    printf("");         // null string means flush

    if (env->compHnd->doAssert(file, line, why))
        DebugBreak(); 
}

/*********************************************************************/
BOOL logf(unsigned level, const char* fmt, va_list args) 
{
    return(LogEnv::cur()->compHnd->logMsg(level, fmt, args));
}   

/*********************************************************************/
void logf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    if (!logf(LL_INFO10, fmt, args))
    {
        vprintf(fmt, args);
        if (fmt[0] == 0)                // null string means flush
            fflush(stdout);
    }
}


/*********************************************************************/
void logf(unsigned level, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    logf(level, fmt, args);
}

bool badCode3(const char* msg, const char* msg2, int arg, char* file, unsigned line)  
{
    char buf1[256];
    char buf2[256];
    assert((strlen(msg)+strlen(msg2)) < 250);
    sprintf(buf1, "%s%s", msg, msg2);
    sprintf(buf2, buf1, arg);

    debugError(buf2, file, line);
    return badCode();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\gcencode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          GCEncode                                         XX
XX                                                                           XX
XX   Logic to encode the JIT method header and GC pointer tables             XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "GCInfo.h"
#include "emit.h"

/*****************************************************************************/
#if TRACK_GC_REFS
/*****************************************************************************/

/*****************************************************************************/
// (see jit.h) #define REGEN_SHORTCUTS 0
// To Regenerate the compressed info header shortcuts, define REGEN_SHORTCUTS
// and use the following command line pipe/filter to give you the 128
// most useful encodings.
//
// find . -name regen.txt | xargs cat | grep InfoHdr | sort | uniq -c | sort -r | head -128

// (see jit.h) #define REGEN_CALLPAT 0
// To Regenerate the compressed info header shortcuts, define REGEN_CALLPAT
// and use the following command line pipe/filter to give you the 80
// most useful encodings.
//
// find . -name regen.txt | xargs cat | grep CallSite | sort | uniq -c | sort -r | head -80


#if REGEN_SHORTCUTS || REGEN_CALLPAT
static FILE* logFile = NULL;
CRITICAL_SECTION logFileLock;
#endif

#if REGEN_CALLPAT
static void regenLog(unsigned codeDelta,    unsigned argMask, 
                     unsigned regMask,      unsigned argCnt,
                     unsigned byrefArgMask, unsigned byrefRegMask, 
                     BYTE*    base,         unsigned enSize)
{
    CallPattern pat;

    pat.fld.argCnt    = (argCnt  < 0xff)   ? argCnt    : 0xff;
    pat.fld.regMask   = (regMask < 0xff)   ? regMask   : 0xff;
    pat.fld.argMask   = (argMask < 0xff)   ? argMask   : 0xff;
    pat.fld.codeDelta = (codeDelta < 0xff) ? codeDelta : 0xff;
    
    if (logFile == NULL)
    {
        logFile = fopen("regen.txt", "a");
        InitializeCriticalSection(&logFileLock);
    }

    assert(((enSize>0) && (enSize<256)) && ((pat.val & 0xffffff) != 0xffffff));

    EnterCriticalSection(&logFileLock);

    fprintf(logFile, "CallSite( 0x%08x, 0x%02x%02x, 0x", 
            pat.val, byrefArgMask, byrefRegMask);

    while (enSize > 0)
    {
        fprintf(logFile, "%02x", *base++);
        enSize--;
    }
    fprintf(logFile, "),\n");
    fflush(logFile);

    LeaveCriticalSection(&logFileLock);
}
#endif

#if REGEN_SHORTCUTS
static void regenLog(unsigned encoding, InfoHdr* header, InfoHdr* state)
{
    if (logFile == NULL)
    {
        logFile = fopen("regen.txt", "a");
        InitializeCriticalSection(&logFileLock);
    }

    EnterCriticalSection(&logFileLock);

    fprintf(logFile, "InfoHdr( %2d, %2d, %1d, %1d, %1d,"
                             " %1d, %1d, %1d, %1d, %1d,"
                             " %1d, %1d, %1d, %1d, %1d,"
                             " %1d, %2d, %2d, %2d, %2d ), \n",
                     state->prologSize,
                     state->epilogSize,
                     state->epilogCount,
                     state->epilogAtEnd,
                     state->ediSaved,
                     state->esiSaved,
                     state->ebxSaved,
                     state->ebpSaved,
                     state->ebpFrame,
                     state->interruptible,
                     state->doubleAlign,
                     state->security,
                     state->handlers,
                     state->localloc,
                     state->editNcontinue,
                     state->varargs,
                     state->argCount,
                     state->frameSize,
                     (state->untrackedCnt<4) ? state->untrackedCnt : -1,
                     (state->varPtrTableSize==0) ? 0 : -1
            );

    fflush(logFile);

    LeaveCriticalSection(&logFileLock);
}
#endif

/*****************************************************************************
 *
 *  Given the four parameters return the index into the callPatternTable[]
 *  that is used to encoding these four items.  If an exact match cannot
 *  found then ignore the codeDelta and search the table again for a near
 *  match.
 *  Returns 0..79 for an exact match or
 *         (delta<<8) | (0..79) for a near match.
 *  A near match will be encoded using two bytes, the first byte will
 *  skip the adjustment delta that prevented an exact match and the
 *  rest of the delta plus the other three items are encoded in the
 *  second byte.
 */
int FASTCALL lookupCallPattern(unsigned argCnt,   unsigned regMask,
                               unsigned argMask,  unsigned codeDelta)
{
    if ((argCnt <= CP_MAX_ARG_CNT) && (argMask <= CP_MAX_ARG_MASK))
    {
        CallPattern pat;

        pat.fld.argCnt    = argCnt;
        pat.fld.regMask   = regMask;      // EBP,EBX,ESI,EDI
        pat.fld.argMask   = argMask;
        pat.fld.codeDelta = codeDelta;

        bool     codeDeltaOK = (pat.fld.codeDelta == codeDelta);
        unsigned bestDelta2  = 0xff;
        unsigned bestPattern = 0xff;
        unsigned patval      = pat.val;
        assert(sizeof(CallPattern) == sizeof(unsigned));

        unsigned *    curp = &callPatternTable[0];
        for (unsigned inx  = 0; 
                      inx  < 80;
                      inx++,curp++)
        {
            unsigned curval = *curp;
            if ((patval == curval) && codeDeltaOK)
                return inx;

            if (((patval ^ curval) & 0xffffff) == 0)
            {
                unsigned delta2 = codeDelta - (curval >> 24);
                if (delta2 < bestDelta2)
                {
                   bestDelta2  = delta2;
                   bestPattern = inx;
                }
            }
        }

        if (bestPattern != 0xff)
        {
            return (bestDelta2 << 8) | bestPattern;
        }
    }
    return -1;
}



static bool initNeeded3(unsigned cur, unsigned tgt,
                        unsigned max, unsigned* hint)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x07;
        tmp >>= 3;
        if (tmp == cur)
        {
            *hint = nib;
            return false;
        }
        cnt++;
    }

    *hint = tmp;
    return true;
}

static bool initNeeded4(unsigned cur, unsigned tgt,
                        unsigned max, unsigned* hint)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x0f;
        tmp >>= 4;
        if (tmp == cur)
        {
            *hint = nib;
            return false;
        }
        cnt++;
    }

    *hint = tmp;
    return true;
}

static int bigEncoding3(unsigned cur, unsigned tgt, unsigned max)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x07;
        tmp >>= 3;
        if (tmp == cur)
            break;
        cnt++;
    }
    return cnt;
}

static int bigEncoding4(unsigned cur, unsigned tgt, unsigned max)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x0f;
        tmp >>= 4;
        if (tmp == cur)
            break;
        cnt++;
    }
    return cnt;
}

BYTE FASTCALL encodeHeaderNext(const InfoHdr& header, InfoHdr* state)
{
    BYTE encoding = 0xff;

    if (state->argCount != header.argCount)
    {
        // We have one-byte encodings for 0..8
        if (header.argCount <= SET_ARGCOUNT_MAX)
        {
            state->argCount = header.argCount;
            encoding = SET_ARGCOUNT + header.argCount;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            if (initNeeded4(state->argCount, header.argCount,
                            SET_ARGCOUNT_MAX, &hint))
            {
                assert(hint <= SET_ARGCOUNT_MAX);
                state->argCount = hint;
                encoding = SET_ARGCOUNT + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0xf);
                state->argCount <<= 4;
                state->argCount  += hint;
                encoding = NEXT_FOUR_ARGCOUNT + hint;
                goto DO_RETURN;
            }
        }
    }

    if (state->frameSize != header.frameSize)
    {
        // We have one-byte encodings for 0..7
        if (header.frameSize <= SET_FRAMESIZE_MAX)
        {
            state->frameSize = header.frameSize;
            encoding = SET_FRAMESIZE + header.frameSize;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            if (initNeeded4(state->frameSize, header.frameSize,
                            SET_FRAMESIZE_MAX, &hint))
            {
                assert(hint <= SET_FRAMESIZE_MAX);
                state->frameSize = hint;
                encoding = SET_FRAMESIZE + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0xf);
                state->frameSize <<= 4;
                state->frameSize  += hint;
                encoding = NEXT_FOUR_FRAMESIZE + hint;
                goto DO_RETURN;
            }
        }
    }

    if ((state->epilogCount != header.epilogCount) ||
        (state->epilogAtEnd != header.epilogAtEnd))
    {
        /* @TODO [FIXHACK] [06/13/01] [] : @BUGBUG 85880 : The GC-encoding only
           supports a few epilogs. We can now generate many epilogs because of CEE_JMP. */
        if (header.epilogCount > SET_EPILOGCNT_MAX)
            IMPL_LIMITATION("More than SET_EPILOGCNT_MAX epilogs");

        state->epilogCount = header.epilogCount;
        state->epilogAtEnd = header.epilogAtEnd;
        encoding = SET_EPILOGCNT + header.epilogCount*2;
        if (header.epilogAtEnd)
            encoding++;
        goto DO_RETURN;
    }

    if (state->varPtrTableSize != header.varPtrTableSize)
    {
        if (state->varPtrTableSize == 0)
        {
            state->varPtrTableSize = 0xffff;
            encoding = FLIP_VARPTRTABLESZ;
            goto DO_RETURN;
        }
        else if (header.varPtrTableSize == 0)
        {
            state->varPtrTableSize = 0;
            encoding = FLIP_VARPTRTABLESZ;
            goto DO_RETURN;
        }
    }

    if (state->untrackedCnt != header.untrackedCnt)
    {
        // We have one-byte encodings for 0..3
        if (header.untrackedCnt <= SET_UNTRACKED_MAX)
        {
            state->untrackedCnt = header.untrackedCnt;
            encoding = SET_UNTRACKED + header.untrackedCnt;
            goto DO_RETURN;
        }
        else if (state->untrackedCnt != 0xffff)
        {
            state->untrackedCnt = 0xffff;
            encoding = FFFF_UNTRACKEDCNT;
            goto DO_RETURN;
        }
    }

    if (state->epilogSize != header.epilogSize)
    {
        // We have one-byte encodings for 0..10
        if (header.epilogSize <= SET_EPILOGSIZE_MAX)
        {
            state->epilogSize = header.epilogSize;
            encoding = SET_EPILOGSIZE + header.epilogSize;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            if (initNeeded3(state->epilogSize, header.epilogSize,
                            SET_EPILOGSIZE_MAX, &hint))
            {
                assert(hint <= SET_EPILOGSIZE_MAX);
                state->epilogSize = hint;
                encoding = SET_EPILOGSIZE + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0x7);
                state->epilogSize <<= 3;
                state->epilogSize  += hint;
                encoding = NEXT_THREE_EPILOGSIZE + hint;
                goto DO_RETURN;
            }
        }
    }

    if (state->prologSize != header.prologSize)
    {
        // We have one-byte encodings for 0..16
        if (header.prologSize <= SET_PROLOGSIZE_MAX)
        {
            state->prologSize = header.prologSize;
            encoding = SET_PROLOGSIZE + header.prologSize;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            assert(SET_PROLOGSIZE_MAX > 15);
            if (initNeeded3(state->prologSize, header.prologSize, 15, &hint))
            {
                assert(hint <= 15);
                state->prologSize = hint;
                encoding = SET_PROLOGSIZE + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0x7);
                state->prologSize <<= 3;
                state->prologSize  += hint;
                encoding = NEXT_THREE_PROLOGSIZE + hint;
                goto DO_RETURN;
            }
        }
    }

    if (state->ediSaved != header.ediSaved)
    {
        state->ediSaved = header.ediSaved;
        encoding = FLIP_EDI_SAVED;
        goto DO_RETURN;
    }

    if (state->esiSaved != header.esiSaved)
    {
        state->esiSaved = header.esiSaved;
        encoding = FLIP_ESI_SAVED;
        goto DO_RETURN;
    }

    if (state->ebxSaved != header.ebxSaved)
    {
        state->ebxSaved = header.ebxSaved;
        encoding = FLIP_EBX_SAVED;
        goto DO_RETURN;
    }

    if (state->ebpSaved != header.ebpSaved)
    {
        state->ebpSaved = header.ebpSaved;
        encoding = FLIP_EBP_SAVED;
        goto DO_RETURN;
    }

    if (state->ebpFrame != header.ebpFrame)
    {
        state->ebpFrame = header.ebpFrame;
        encoding = FLIP_EBP_FRAME;
        goto DO_RETURN;
    }

    if (state->interruptible != header.interruptible)
    {
        state->interruptible = header.interruptible;
        encoding = FLIP_INTERRUPTIBLE;
        goto DO_RETURN;
    }

#if DOUBLE_ALIGN
    if (state->doubleAlign != header.doubleAlign)
    {
        state->doubleAlign = header.doubleAlign;
        encoding = FLIP_DOUBLE_ALIGN;
        goto DO_RETURN;
    }
#endif

    if (state->security != header.security)
    {
        state->security = header.security;
        encoding = FLIP_SECURITY;
        goto DO_RETURN;
    }

    if (state->handlers != header.handlers)
    {
        state->handlers = header.handlers;
        encoding = FLIP_HANDLERS;
        goto DO_RETURN;
    }

    if (state->localloc != header.localloc)
    {
        state->localloc = header.localloc;
        encoding = FLIP_LOCALLOC;
        goto DO_RETURN;
    }

    if (state->editNcontinue != header.editNcontinue)
    {
        state->editNcontinue = header.editNcontinue;
        encoding = FLIP_EDITnCONTINUE;
        goto DO_RETURN;
    }

    if (state->varargs != header.varargs)
    {
        state->varargs = header.varargs;
        encoding = FLIP_VARARGS;
        goto DO_RETURN;
    }

DO_RETURN:
    assert((encoding >= 0) && (encoding < 0x80));
    if (!state->isMatch(header))
        encoding |= 0x80;
    return encoding;
}

static int measureDistance(const InfoHdr& header, InfoHdr* p, int closeness)
{
    int distance = 0;

    if (p->untrackedCnt != header.untrackedCnt)
    {
        if (header.untrackedCnt > 3)
        {
            if (p->untrackedCnt != 0xffff)
                distance += 1;
        }
        else
        {
            distance += 1;
        }
        if (distance >= closeness) return distance;
    }

    if (p->varPtrTableSize != header.varPtrTableSize)
    {
        if (header.varPtrTableSize != 0)
        {
            if (p->varPtrTableSize != 0xffff)
                distance += 1;
        }
        else
        {
            assert(p->varPtrTableSize == 0xffff);
            distance += 1;
        }
        if (distance >= closeness) return distance;
    }

    if (p->frameSize != header.frameSize)
    {
        distance += 1;
        if (distance >= closeness) return distance;

        // We have one-byte encodings for 0..7
        if (header.frameSize > SET_FRAMESIZE_MAX)
        {
            distance += bigEncoding4(p->frameSize, header.frameSize,
                                     SET_FRAMESIZE_MAX);
            if (distance >= closeness) return distance;
        }
    }

    if (p->argCount != header.argCount)
    {
        distance += 1;
        if (distance >= closeness) return distance;

        // We have one-byte encodings for 0..8
        if (header.argCount > SET_ARGCOUNT_MAX)
        {
            distance += bigEncoding4(p->argCount, header.argCount,
                                     SET_ARGCOUNT_MAX);
            if (distance >= closeness) return distance;
        }
    }

    if (p->prologSize != header.prologSize)
    {
        distance += 1;
        if (distance >= closeness) return distance;

        // We have one-byte encodings for 0..16
        if (header.prologSize > SET_PROLOGSIZE_MAX)
        {
            assert(SET_PROLOGSIZE_MAX > 15);
            distance += bigEncoding3(p->prologSize, header.prologSize, 15);
            if (distance >= closeness) return distance;
        }
    }

    if (p->epilogSize != header.epilogSize)
    {
        distance += 1;
        if (distance >= closeness) return distance;
        // We have one-byte encodings for 0..10
        if (header.epilogSize > SET_EPILOGSIZE_MAX)
        {
            distance += bigEncoding3(p->epilogSize, header.epilogSize,
                                     SET_EPILOGSIZE_MAX);
            if (distance >= closeness) return distance;
        }
    }

    if ((p->epilogCount != header.epilogCount) ||
        (p->epilogAtEnd != header.epilogAtEnd))
    {
        distance += 1;
        if (distance >= closeness) return distance;

		/* @TODO [FIXHACK] [06/13/01] [] : @BUGBUG 85880 : The GC-encoding only
		   supports a few epilogs. We can now generate many epilogs because of CEE_JMP. */
        if (header.epilogCount > SET_EPILOGCNT_MAX)
			IMPL_LIMITATION("More than SET_EPILOGCNT_MAX epilogs");        
    }

    if (p->ediSaved != header.ediSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->esiSaved != header.esiSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->ebxSaved != header.ebxSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->ebpSaved != header.ebpSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->ebpFrame != header.ebpFrame)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->interruptible != header.interruptible)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

#if DOUBLE_ALIGN
    if (p->doubleAlign != header.doubleAlign)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }
#endif

    if (p->security != header.security)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->handlers != header.handlers)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->localloc != header.localloc)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->editNcontinue != header.editNcontinue)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->varargs != header.varargs)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    return distance;
}

static void initLookupTable()
{
    InfoHdr* p  = &infoHdrShortcut[0];
    int      lo = -1;
    int      hi = 0;
    int      n;

    for (n=0; n<128; n++, p++)
    {
        if (p->prologSize != lo)
        {
            if (p->prologSize < lo)
            {
                assert(p->prologSize == 0);
                hi = IH_MAX_PROLOG_SIZE;
            }
            else
                hi = p->prologSize;
            
            assert(hi <= IH_MAX_PROLOG_SIZE);
            
            while (lo < hi)
                infoHdrLookup[++lo] = n;

            if (lo == IH_MAX_PROLOG_SIZE)
                break;
        }
    }

    assert(lo == IH_MAX_PROLOG_SIZE);
    assert(infoHdrLookup[IH_MAX_PROLOG_SIZE] < 128);

    while (p->prologSize == lo)
    {
        n++;
        if (n >= 128)
            break;
        p++;
    }

    infoHdrLookup[++lo] = n;

#ifdef DEBUG
    //
    // We do some other DEBUG only validity checks here
    //
    assert(callCommonDelta[0] < callCommonDelta[1]);
    assert(callCommonDelta[1] < callCommonDelta[2]);
    assert(callCommonDelta[2] < callCommonDelta[3]);
    assert(sizeof(CallPattern) == sizeof(unsigned));
    unsigned maxMarks = 0;
    for (unsigned inx=0; inx < 80; inx++)
    {
        CallPattern pat;
        pat.val = callPatternTable[inx];
        
        assert(pat.fld.codeDelta <= CP_MAX_CODE_DELTA);
        if    (pat.fld.codeDelta == CP_MAX_CODE_DELTA)  maxMarks |= 0x01;
        
        assert(pat.fld.argCnt    <= CP_MAX_ARG_CNT);
        if    (pat.fld.argCnt    == CP_MAX_ARG_CNT)     maxMarks |= 0x02;
        
        assert(pat.fld.argMask   <= CP_MAX_ARG_MASK);
        if    (pat.fld.argMask   == CP_MAX_ARG_MASK)    maxMarks |= 0x04;
    }
    assert(maxMarks == 0x07);
#endif
}

BYTE FASTCALL encodeHeaderFirst(const InfoHdr& header, InfoHdr* state, int* more, int* s_cached)
{
    //
    // if infoHdrLookup[0] is equal to 0xff then
    // this is the first call and we must initialize
    // infoHdrLookup[] table
    //
    if (infoHdrLookup[0] == 0xff)
        initLookupTable();

    // First try the cached value for an exact match, if there is one
    //
    int      n = *s_cached;
    InfoHdr* p;

    if (n != -1)
    {
        p = &infoHdrShortcut[n];
        if (p->isMatch(header))
        {
            // exact match found
            *state = *p;
            *more  = 0;
            return n;
        }
    }

    // Next search the table for an exact match
    // Only search entries that have a matching prolog size
    // Note: lo and hi are saved here as they specify the
    // range of entries that have the correct prolog size
    //
    unsigned psz = header.prologSize;
    int      lo = 0;
    int      hi = 0;

    if (psz <= IH_MAX_PROLOG_SIZE)
    {
        lo = infoHdrLookup[psz];
        hi = infoHdrLookup[psz+1];
        p  = &infoHdrShortcut[lo];
        for (n=lo; n<hi; n++,p++)
        {
            assert(psz == p->prologSize);
            if (p->isMatch(header))
            {
                // exact match found
                *state    = *p;
                *s_cached = n;    // cache the value
                *more     = 0;
                return n;
            }
        }
    }

    //
    // no exact match in infoHdrShortcut[]
    //
    // find the nearest entry in the table
    //
    int nearest   = -1;
    int closeness = 255;   // (i.e. not very close)

    //
    // Calculate the minimum acceptable distance
    // if we find an entry that is at least this close
    // we will stop the search and use that value
    //
    int min_acceptable_distance = 1;

    if (header.frameSize > SET_FRAMESIZE_MAX)
    {
        ++min_acceptable_distance;
        if (header.frameSize > 32)
            ++min_acceptable_distance;
    }
    if (header.argCount > SET_ARGCOUNT_MAX)
    {
        ++min_acceptable_distance;
        if (header.argCount > 32)
            ++min_acceptable_distance;
    }

    // First try the cached value
    // and see if it meets the minimum acceptable distance
    //
    if (*s_cached != -1)
    {
        p = &infoHdrShortcut[*s_cached];
        int distance = measureDistance(header, p, closeness);
        assert(distance > 0);
        if (distance <= min_acceptable_distance)
        {
            *state = *p;
            *more  = distance;
            return 0x80 | *s_cached;
        }
        else
        {
            closeness = distance;
            nearest   = *s_cached;
        }
    }

    // Then try the ones pointed to by [lo..hi),
    // (i.e. the ones that have the correct prolog size)
    //
    p = &infoHdrShortcut[lo];
    for (n=lo; n<hi; n++,p++)
    {
        if (n == *s_cached)
            continue;   // already tried this one
        int distance = measureDistance(header, p, closeness);
        assert(distance > 0);
        if (distance <= min_acceptable_distance)
        {
            *state    = *p;
            *s_cached = n;     // Cache this value
            *more     = distance;
            return 0x80 | n;
        }
        else if (distance < closeness)
        {
            closeness = distance;
            nearest   = n;
        }
    }

    int last = infoHdrLookup[IH_MAX_PROLOG_SIZE+1];
    assert(last <= 128);

    // Then try all the rest [0..last-1]
    p = &infoHdrShortcut[0];
    for (n=0; n<last; n++,p++)
    {
        if (n == *s_cached)
            continue;   // already tried this one
        if ((n>=lo) && (n<hi))
            continue;   // already tried these
        int distance = measureDistance(header, p, closeness);
        assert(distance > 0);
        if (distance <= min_acceptable_distance)
        {
            *state    = *p;
            *s_cached = n;        // Cache this value
            *more     = distance;
            return 0x80 | n;
        }
        else if (distance < closeness)
        {
            closeness = distance;
            nearest = n;
        }
    }

    //
    // If we reach here then there was no adjacent neighbor
    //  in infoHdrShortcut[], closeness indicate how many extra
    //  bytes we will need to encode this item.
    //
    assert((nearest >= 0) && (nearest <= 127));
    *state    = infoHdrShortcut[nearest];
    *s_cached = nearest;          // Cache this value
    *more     = closeness;
    return 0x80 | nearest;
}

/*****************************************************************************
 *
 *  Write the initial part of the method info block. This is called twice;
 *  first to compute the size needed for the info (mask=0), the second time
 *  to actually generate the contents of the table (mask=-1,dest!=NULL).
 */

size_t              Compiler::gcInfoBlockHdrSave(BYTE     * dest,
                                                 int        mask,
                                                 unsigned   methodSize,
                                                 unsigned   prologSize,
                                                 unsigned   epilogSize,
                                                 InfoHdr  * header,
                                                 int*       s_cached)
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In gcInfoBlockHdrSave()\n");
#endif
    size_t          size = 0;

#if TGT_x86

    size_t          sz;

    /* Can't create tables if we've not saved code */

    if  (!savCode) return 0;

#if VERIFY_GC_TABLES
    *castto(dest, unsigned short *)++ = 0xFEEF; size += sizeof(short);
#endif

    /* Write the method size first (using between 1 and 5 bytes) */

#ifdef  DEBUG
    if (verbose)
    {
        if (mask) printf("GCINFO: methodSize = %04X\n", methodSize);
        if (mask) printf("GCINFO: prologSize = %04X\n", prologSize);
        if (mask) printf("GCINFO: epilogSize = %04X\n", epilogSize);
    }
#endif

    sz    = encodeUnsigned(dest, methodSize);
    size += sz;
    dest += sz & mask;

    //
    // New style InfoBlk Header [briansul]
    //
    // Typically only uses one-byte to store everything.
    //

    if (mask==0)
    {
        memset(header, 0, sizeof(InfoHdr));
        *s_cached = -1;
    }

    header->prologSize  = prologSize;
    header->epilogSize  = epilogSize;
    header->epilogCount = getEmitter()->emitGetEpilogCnt();
    if (header->epilogCount != getEmitter()->emitGetEpilogCnt())
        IMPL_LIMITATION("emitGetEpilogCnt() does not fit in InfoHdr::epilogCount");
    header->epilogAtEnd = getEmitter()->emitHasEpilogEnd();

#if TGT_x86

    if (rsMaskModf & RBM_EDI)
        header->ediSaved = 1;
    if (rsMaskModf & RBM_ESI)
        header->esiSaved =  1;
    if (rsMaskModf & RBM_EBX)
        header->ebxSaved = 1;

#else

    assert(!"need non-x86 code");

#endif

    header->interruptible = genInterruptible;

#if TGT_x86

    if  (!genFPused)
    {
#if DOUBLE_ALIGN
        if  (genDoubleAlign)
        {
            header->ebpSaved = true;
            assert((rsMaskModf & RBM_EBP) == 0);
        }
#endif
        if (rsMaskModf & RBM_EBP)
        {
            header->ebpSaved = true;
        }
    }
    else
    {
        header->ebpSaved = true;
        header->ebpFrame = true;
    }

#endif

#if DOUBLE_ALIGN
    header->doubleAlign = genDoubleAlign;
#endif

#if OPT_IL_JIT
    header->security = false;
#else
    header->security = opts.compNeedSecurityCheck;
#endif

    if (info.compXcptnsCount)
        header->handlers = true;
    else
        header->handlers = false;

    header->localloc = compLocallocUsed;

#ifdef OPT_IL_JIT
    header->varargs       = m_methodInfo->args.isVarArg();
    header->editNcontinue = false;
#else
    header->varargs       = info.compIsVarArgs;
    header->editNcontinue = opts.compDbgEnC;
#endif

    assert((compArgSize & 0x3) == 0);

    header->argCount  = (compArgSize - (rsCalleeRegArgNum * sizeof(void *))) / sizeof(void*);

    header->frameSize = compLclFrameSize / sizeof(int);

    if (mask==0)
        gcCountForHeader(&header->untrackedCnt, &header->varPtrTableSize);

    //
    // If the high-order bit of headerEncoding is set
    // then additional bytes will update the InfoHdr state
    // until the fully state is encoded
    //
    InfoHdr state;
    int more = 0;
    BYTE headerEncoding = encodeHeaderFirst(*header, &state, &more, s_cached);
    ++size;
    if (mask)
    {
#if REGEN_SHORTCUTS
        regenLog(headerEncoding, header, &state);
#endif
        *dest++ = headerEncoding;

        BYTE encoding = headerEncoding;
        while (encoding & 0x80)
        {
            encoding = encodeHeaderNext(*header, &state);
#if REGEN_SHORTCUTS
	    regenLog(headerEncoding, header, &state);
#endif
            *dest++ = encoding;
            ++size;
        }
    }
    else
    {
        size += more;
    }

    if (header->untrackedCnt > 3)
    {
        unsigned count = header->untrackedCnt;
        unsigned sz = encodeUnsigned(mask ? dest : NULL, count);
        size += sz;
        dest += (sz & mask);
    }

    if (header->varPtrTableSize != 0)
    {
        unsigned count = header->varPtrTableSize;
        unsigned sz = encodeUnsigned(mask ? dest : NULL, count);
        size += sz;
        dest += (sz & mask);
    }

    if (header->epilogCount)
    {
        /* Generate table unless one epilog at the end of the method */

        if  (header->epilogAtEnd == 0 ||
             header->epilogCount != 1)
        {
            unsigned    sz;

#if VERIFY_GC_TABLES
            *castto(dest, unsigned short *)++ = 0xFACE; size += sizeof(short);
#endif

            /* Simply write a sorted array of offsets using encodeUDelta */

            gcEpilogTable      = mask ? dest : NULL;
            gcEpilogPrevOffset = 0;

            sz = getEmitter()->emitGenEpilogLst(gcRecordEpilog, this);

            /* Add the size of the epilog table to the total size */

            size += sz;
            dest += (sz & mask);
        }
    }

#if DISPLAY_SIZES

    if (mask)
    {
        if (genInterruptible)
            genMethodICnt++;
        else
            genMethodNCnt++;
    }

#endif

#else

#pragma message("NOTE: GC table generation disabled for non-x86 targets")

#endif

    return  size;
}

/*****************************************************************************
 *
 *  Return the size of the pointer tracking tables.
 */

size_t              Compiler::gcPtrTableSize(const InfoHdr& header, unsigned codeSize)
{
    BYTE            temp[16+1];
#ifdef DEBUG
    temp[16] = 0xAB; // Set some marker
#endif

    /* Compute the total size of the tables */

    size_t size = gcMakeRegPtrTable(temp, 0, header, codeSize);

    assert(temp[16] == 0xAB); // Check that marker didnt get overwritten

    return size;
}

/*****************************************************************************
 * Encode the callee-saved registers into 3 bits.
 */

unsigned            gceEncodeCalleeSavedRegs(unsigned regs)
{
    unsigned    encodedRegs = 0;

#if TGT_x86
    if  (regs & RBM_EBX) encodedRegs |= 0x04;
    if  (regs & RBM_ESI) encodedRegs |= 0x02;
    if  (regs & RBM_EDI) encodedRegs |= 0x01;
#endif

    return encodedRegs;
}

/*****************************************************************************
 * Is the next entry for a byref pointer. If so, emit the prefix for the
 * interruptible encoding. Check only for pushes and registers
 */

inline
BYTE *              gceByrefPrefixI(Compiler::regPtrDsc * rpd, BYTE * dest)
{
    // For registers, we dont need a prefix if it is going dead.
    assert(rpd->rpdArg || rpd->rpdCompiler.rpdDel==0);

    if (!rpd->rpdArg || rpd->rpdArgType == Compiler::rpdARG_PUSH)
        if (rpd->rpdGCtypeGet() == GCT_BYREF)
            *dest++ = 0xBF;

    return dest;
}

/*****************************************************************************/

/* These functions are needed to work around a VC5.0 compiler bug */
/* DO NOT REMOVE, unless you are sure that the free build works   */
static  int         zeroFN() { return 0; }
static  int       (*zeroFunc)() = zeroFN;

/*****************************************************************************
 *  Modelling of the GC ptrs pushed on the stack
 */

typedef unsigned            pasMaskType;
#define BITS_IN_pasMask     (BITS_IN_BYTE * sizeof(pasMaskType))
#define HIGHEST_pasMask_BIT (((pasMaskType)0x1) << (BITS_IN_pasMask-1))

//-----------------------------------------------------------------------------

class   PendingArgsStack
{
public:

    PendingArgsStack            (unsigned   maxDepth, Compiler * pComp);

    void        pasPush         (GCtype     gcType);
    void        pasPop          (unsigned   count);
    void        pasKill         (unsigned   gcCount);

    unsigned    pasCurDepth     ()  { return pasDepth; }
    pasMaskType pasArgMask      ()  { assert(pasDepth <= BITS_IN_pasMask); return pasBottomMask; }
    pasMaskType pasByrefArgMask ()  { assert(pasDepth <= BITS_IN_pasMask); return pasByrefBottomMask; }
    bool        pasHasGCptrs    ();

    // Use these in the case where there actually are more ptrs than pasArgMask
    unsigned    pasEnumGCoffsCount();
    #define     pasENUM_START   (-1)
    #define     pasENUM_LAST    (-2)
    #define     pasENUM_END     (-3)
    unsigned    pasEnumGCoffs   (unsigned iter, unsigned * offs);

protected:

    unsigned    pasMaxDepth;

    unsigned    pasDepth;

    pasMaskType pasBottomMask;      // The first 32 args
    pasMaskType pasByrefBottomMask; // byref qualifier for pasBottomMask

    BYTE *      pasTopArray;        // More than 32 args are represented here
    unsigned    pasPtrsInTopArray;  // How many GCptrs here
};


//-----------------------------------------------------------------------------

PendingArgsStack::PendingArgsStack(unsigned maxDepth, Compiler * pComp) :
    pasMaxDepth(maxDepth), pasDepth(0),
    pasBottomMask(0), pasByrefBottomMask(0),
    pasTopArray(NULL), pasPtrsInTopArray(0)
{
    /* Do we need an array as well as the mask ? */

    if (pasMaxDepth > BITS_IN_pasMask)
        pasTopArray = (BYTE *)pComp->compGetMemA(pasMaxDepth - BITS_IN_pasMask);
}

//-----------------------------------------------------------------------------

void        PendingArgsStack::pasPush(GCtype gcType)
{
    assert(pasDepth < pasMaxDepth);

    if  (pasDepth < BITS_IN_pasMask)
    {
        /* Shift the mask */

        pasBottomMask       <<= 1;
        pasByrefBottomMask  <<= 1;

        if (needsGC(gcType))
        {
            pasBottomMask |= 1;

            if (gcType == GCT_BYREF)
                pasByrefBottomMask |= 1;
        }
    }
    else
    {
        /* Push on array */

        pasTopArray[pasDepth - BITS_IN_pasMask] = (BYTE)gcType;

        if (gcType)
            pasPtrsInTopArray++;
    }

    pasDepth++;
}

//-----------------------------------------------------------------------------

void        PendingArgsStack::pasPop(unsigned count)
{
    assert(pasDepth >= count);

    /* First pop from array (if applicable) */

    for (/**/; (pasDepth > BITS_IN_pasMask) && count; pasDepth--,count--)
    {
        unsigned    topIndex = pasDepth - BITS_IN_pasMask - 1;

        GCtype      topArg = (GCtype)pasTopArray[topIndex];

        if (needsGC(topArg))
            pasPtrsInTopArray--;
    }
    if (count == 0) return;

    /* Now un-shift the mask */

    assert(pasPtrsInTopArray == 0);
    assert(count <= BITS_IN_pasMask);

    if (count == BITS_IN_pasMask) // (x>>32) is a nop on x86. So special-case it
    {
        pasBottomMask       =
        pasByrefBottomMask  = 0;
        pasDepth            = 0;
    }
    else
    {
        pasBottomMask      >>= count;
        pasByrefBottomMask >>= count;
        pasDepth -= count;
    }
}

//-----------------------------------------------------------------------------
// Kill (but dont pop) the top 'gcCount' args

void        PendingArgsStack::pasKill(unsigned gcCount)
{
    assert(gcCount != 0);

    /* First kill args in array (if any) */

    for (unsigned curPos = pasDepth; (curPos > BITS_IN_pasMask) && gcCount; curPos--)
    {
        unsigned    curIndex = curPos - BITS_IN_pasMask - 1;

        GCtype      curArg = (GCtype)pasTopArray[curIndex];

        if (needsGC(curArg))
        {
            pasTopArray[curIndex] = GCT_NONE;
            pasPtrsInTopArray--;
            gcCount--;
        }
    }

    /* Now kill bits from the mask */

    assert(pasPtrsInTopArray == 0);
    assert(gcCount <= BITS_IN_pasMask);

    for (unsigned bitPos = 1; gcCount; bitPos<<=1)
    {
        assert(pasBottomMask != 0);

        if (pasBottomMask & bitPos)
        {
            pasBottomMask &= ~bitPos;
            pasByrefBottomMask &= ~bitPos;
            --gcCount;
        }
        else
        {
            assert(bitPos != HIGHEST_pasMask_BIT);
        }
    }
}

//-----------------------------------------------------------------------------
// Used for the case where there are more than BITS_IN_pasMask args on stack,
// but none are any pointers. May avoid reporting anything to GCinfo

bool        PendingArgsStack::pasHasGCptrs()
{
    if (pasDepth <= BITS_IN_pasMask)
        return pasBottomMask != 0;
    else
        return pasBottomMask != 0 || pasPtrsInTopArray != 0;
}

//-----------------------------------------------------------------------------
//  Iterates over mask and array to return total count.
//  Use only when you are going to emit a table of the offsets

unsigned    PendingArgsStack::pasEnumGCoffsCount()
{
    /* Should only be used in the worst case, when just the mask cant be used */

    assert(pasDepth > BITS_IN_pasMask && pasHasGCptrs());

    /* Count number of set bits in mask */

    unsigned count = 0;

    for(pasMaskType mask = 0x1, i = 0; i < BITS_IN_pasMask; mask<<=1, i++)
    {
        if (mask & pasBottomMask)
            count++;
    }

    return count + pasPtrsInTopArray;
}

//-----------------------------------------------------------------------------
//  Initalize enumeration by passing in iter=pasENUM_START.
//  Continue by passing in the return value as the new value of iter
//  End of enumeration when pasENUM_END is returned
//  If return value != pasENUM_END, *offs is set to the offset for GCinfo

unsigned    PendingArgsStack::pasEnumGCoffs(unsigned iter, unsigned * offs)
{
    if (iter == pasENUM_LAST) return pasENUM_END;

    unsigned i = (iter == pasENUM_START) ? pasDepth : iter;

    for(/**/; i > BITS_IN_pasMask; i--)
    {
        GCtype curArg = (GCtype)pasTopArray[i-BITS_IN_pasMask-1];
        if (needsGC(curArg))
        {
            unsigned    offset;

            offset  = (pasDepth - i) * sizeof(void*);
            if (curArg==GCT_BYREF)
                offset |= byref_OFFSET_FLAG;

            *offs = offset;
            return i - 1;
        }
    }

    if (!pasBottomMask) return pasENUM_END;

    // Have we already processed some of the bits in pasBottomMask ?

    i = (iter == pasENUM_START || iter >= BITS_IN_pasMask) ? 0      // no
                                                           : iter;  // yes

    for(pasMaskType mask = 0x1 << i; mask; i++, mask<<=1)
    {
        if (mask & pasBottomMask)
        {
            unsigned lvl = (pasDepth>BITS_IN_pasMask) ? (pasDepth-BITS_IN_pasMask) : 0; // How many in pasTopArray[]
            lvl += i;

            unsigned    offset;
            offset  =  lvl * sizeof(void*);
            if (mask & pasByrefBottomMask)
                offset |= byref_OFFSET_FLAG;

            *offs = offset;

            unsigned remMask = -(mask<<1);
            return ((pasBottomMask & remMask) ? (i + 1) : pasENUM_LAST);
        }
    }

    assert(!"Shouldnt reach here");
    return pasENUM_END;
}

/*****************************************************************************
 *
 *  Generate the register pointer map, and return its total size in bytes. If
 *  'mask' is 0, we don't actually store any data in 'dest' (except for one
 *  entry, which is never more than 10 bytes), so this can be used to merely
 *  compute the size of the table.
 */

#include "Endian.h"

size_t              Compiler::gcMakeRegPtrTable(BYTE *          dest,
                                                int             mask,
                                                const InfoHdr & header,
                                                unsigned        codeSize)
{
    unsigned        count;

    unsigned        varNum;
    LclVarDsc   *   varDsc;

    varPtrDsc   *   varTmp;

    unsigned        pass;

    size_t          totalSize  = 0;
    unsigned        lastOffset;

    bool            thisIsInUntracked = false;

#if TGT_x86

    /* Can't create tables if we've not saved code */

    if  (!savCode)
        return 0;

    /* The mask should be all 0's or all 1's */

    assert(mask == 0 || mask == -1);

    /* Start computing the total size of the table */

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xBEEF;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif

    /**************************************************************************
     *
     *                      Untracked ptr variables
     *
     **************************************************************************
     */

    count = 0;
    for (pass = 0; pass < 2; pass++)
    {
        /* If pass==0, generate the count
         * If pass==1, write the table of untracked pointer variables.
         */

        if (pass==1)
        {
            assert(count == header.untrackedCnt);
            if (header.untrackedCnt==0)
                break;  // No entries, break exits the loop since pass==1
        }

        /* Count&Write untracked locals and non-enregistered args */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount;
             varNum++  , varDsc++)
        {
            if  (varTypeIsGC(varDsc->TypeGet()))
            {
                /* Do we have an argument or local variable? */
                if  (!varDsc->lvIsParam)
                {
                    // If is is pinned, it must be an untracked local
                    assert(!varDsc->lvPinned || !varDsc->lvTracked);

                    if  (varDsc->lvTracked || !varDsc->lvOnFrame)
                        continue;
                }
                else
                {
                    /* Stack-passed arguments which are not enregistered
                     * are always reported in this "untracked stack
                     * pointers" section of the GC info even if lvTracked==true
                     */

                    /* Has this argument been enregistered? */
					if  (varDsc->lvRegister) 
					{
						/* if a CEE_JMP has been used, then we need to report all the arguments
						   even if they are enregistered, since we will be using this value
						   in JMP call.  Note that this is subtle as we require that
						   argument offsets are always fixed up properly even if lvRegister
						   is set */
						if (!compJmpOpUsed)
							continue;
						}
                    else
                    {
                        if  (!varDsc->lvOnFrame)
                        {
                            /* If this non-enregistered pointer arg is never
                             * used, we dont need to report it
                             */
                            assert(varDsc->lvRefCnt == 0);
                            continue;
                        }
                        else  if (varDsc->lvIsRegArg && varDsc->lvTracked)
                        {
                            /* If this register-passed arg is tracked, then
                             * it has been allocated space near the other
                             * pointer variables and we have accurate life-
                             * time info. It will be reported with
                             * gcVarPtrList in the "tracked-pointer" section
                             */

                            continue;
                        }
                    }
                }

                if (varDsc->lvVerTypeInfo.IsThisPtr())
                {
                    // Encoding of untracked variables does not support reporting
                    // "this". So report it as a tracked variable with a liveness 
                    // extending over the entire method.

                    thisIsInUntracked = true;
                    continue;
                }

                if (pass==0)
                    count++;
                else
                {
                    int offset;
                    assert(pass==1);

                    offset = varDsc->lvStkOffs;

                    // For genDoubleAlign, locals are addressed relative to ESP and
                    // arguments are addressed relative to EBP. We need to indiciate
                    // what the offset is for.

#ifndef OPT_IL_JIT
                    if (genDoubleAlign && varDsc->lvIsParam && !varDsc->lvIsRegArg)
                        offset += compLclFrameSize + compCalleeRegsPushed*sizeof(void*);
#endif
                    // The lower bits of the offset encode properties of the stk ptr

                    assert(~OFFSET_MASK % sizeof(offset) == 0);

                    if (varDsc->TypeGet() == TYP_BYREF)
                    {
                        // Or in byref_OFFSET_FLAG for 'byref' pointer tracking
                        offset |= byref_OFFSET_FLAG;
                    }

                    if (varDsc->lvPinned)
                    {
                        // Or in pinned_OFFSET_FLAG for 'pinned' pointer tracking
                        offset |= pinned_OFFSET_FLAG;
                    }

                    if (mask == 0)
                        totalSize  += encodeSigned(NULL, offset);
                    else
                    {
                        unsigned sz = encodeSigned(dest, offset);
                        dest      += sz;
                        totalSize += sz;
                    }
                }
            }

            if  (varDsc->lvType == TYP_STRUCT && varDsc->lvOnFrame)
            {
                assert(!varDsc->lvTracked);

                unsigned slots  = lvaLclSize(varNum) / sizeof(void*);
                BYTE *   gcPtrs = lvaGetGcLayout(varNum);

                // walk each member of the array
                for (unsigned i = 0; i < slots; i++)
                {
                    if (gcPtrs[i] == TYPE_GC_NONE)     // skip non-gc slots
                        continue;

                    if (pass==0)
                        count++;
                    else
                    {
                        assert(pass==1);

                        unsigned offset = varDsc->lvStkOffs + i * sizeof(void*);

                        // For genDoubleAlign, locals are addressed relative to ESP and
                        // arguments are addressed relative to EBP. We need to indiciate
                        // what the offset is for.
                            
#ifndef OPT_IL_JIT
                        if (genDoubleAlign && varDsc->lvIsParam && !varDsc->lvIsRegArg)
                            offset += compLclFrameSize + compCalleeRegsPushed*sizeof(void*);
#endif
                        if (gcPtrs[i] == TYPE_GC_BYREF)
                            offset |= byref_OFFSET_FLAG;     // indicate it is a byref GC pointer
                        
                        if (mask == 0)
                            totalSize  += encodeSigned(NULL, offset);
                        else
                        {
                            unsigned sz = encodeSigned(dest, offset);
                            dest      += sz;
                            totalSize += sz;
                        }
                    }
                }
            }
        }

        /* Count&Write spill temps that hold pointers */

        for (TempDsc * tempItem = tmpListBeg();
             tempItem;
             tempItem = tmpListNxt(tempItem))
        {
            if  (varTypeIsGC(tempItem->tdTempType()))
            {
                if (pass==0)
                    count++;
                else
                {
                    int offset;
                    assert(pass==1);

                    offset = tempItem->tdTempOffs();

                    // @TODO [REVISIT] [04/16/01] []:
                    // Or in 0x01 if this spill temp is the
                    // this pointer for the method

                    if (tempItem->tdTempType() == TYP_BYREF)
                    {
                        offset |= byref_OFFSET_FLAG;
                    }

                    if (mask == 0)
                    {
                        totalSize  += encodeSigned(NULL, offset);
                    }
                    else
                    {
                        unsigned sz = encodeSigned(dest, offset);
                        dest      += sz;
                        totalSize += sz;
                    }
                }
            }
        }
    }

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xCAFE;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif

    /**************************************************************************
     *
     *  Generate the table of stack pointer variable lifetimes.
     *
     *  In the first pass we'll count the lifetime entries and note
     *  whether there are any that don't fit in a small encoding. In
     *  the second pass we actually generate the table contents.
     *
     **************************************************************************
     */

    // First we check for the most common case - no lifetimes at all.

    if  (header.varPtrTableSize == 0)
        goto DONE_VLT;

    count = 0;

    if (thisIsInUntracked)
    {
        count = 1;

        // Encoding of untracked variables does not support reporting
        // "this". So report it as a tracked variable with a liveness 
        // extending over the entire method.

        assert(lvaTable[0].lvVerTypeInfo.IsThisPtr());
        unsigned    varOffs = lvaTable[0].lvStkOffs;

        /* For negative stack offsets we must reset the low bits,
         * take abs and then set them back */

        varOffs  = abs(varOffs);
        varOffs |= this_OFFSET_FLAG;
        if (lvaTable[0].TypeGet() == TYP_BYREF)
            varOffs |= byref_OFFSET_FLAG;

        size_t sz = 0;
        sz  = encodeUnsigned(mask?(dest+sz):NULL, varOffs);
        sz += encodeUDelta  (mask?(dest+sz):NULL, 0, 0);
        sz += encodeUDelta  (mask?(dest+sz):NULL, codeSize, 0);

        dest      += (sz & mask);
        totalSize += sz;
    }

    for (pass = 0; pass < 2; pass++)
    {
        /* If second pass, generate the count */

        if  (pass)
        {
            assert(header.varPtrTableSize > 0);
            assert(header.varPtrTableSize == count);
        }

        /* We'll use a delta encoding for the lifetime offsets */

        lastOffset = 0;

        for (varTmp = gcVarPtrList; varTmp; varTmp = varTmp->vpdNext)
        {
            unsigned        varOffs;
            unsigned        lowBits;

            unsigned        begOffs;
            unsigned        endOffs;

            assert(~OFFSET_MASK % sizeof(void*) == 0);

            /* Get hold of the variable's stack offset */

            lowBits  = varTmp->vpdVarNum & OFFSET_MASK;

            /* For negative stack offsets we must reset the low bits,
             * take abs and then set them back */

            varOffs  = abs(varTmp->vpdVarNum & ~OFFSET_MASK);
            varOffs |= lowBits;

            /* Compute the actual lifetime offsets */

            begOffs = varTmp->vpdBegOfs;
            endOffs = varTmp->vpdEndOfs;

            /* Special case: skip any 0-length lifetimes */

            if  (endOffs == begOffs)
                continue;

            /* Are we counting or generating? */

            if  (!pass)
            {
                count++;
            }
            else
            {
                size_t sz = 0;
                sz  = encodeUnsigned(mask?(dest+sz):NULL, varOffs);
                sz += encodeUDelta  (mask?(dest+sz):NULL, begOffs, lastOffset);
                sz += encodeUDelta  (mask?(dest+sz):NULL, endOffs, begOffs);

                dest      += (sz & mask);
                totalSize += sz;
            }

            /* The next entry will be relative to the one we just processed */

            lastOffset = begOffs;
        }
    }

DONE_VLT:

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xBABE;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif


    /**************************************************************************
     *
     * Prepare to generate the pointer register/argument map
     *
     **************************************************************************
     */

    lastOffset = 0;

    if  (genInterruptible)
    {
        assert(genFullPtrRegMap);

        unsigned        ptrRegs = 0;

        regPtrDsc  *    genRegPtrTemp;

        /* Walk the list of pointer register/argument entries */

        for (genRegPtrTemp = gcRegPtrList;
             genRegPtrTemp;
             genRegPtrTemp = genRegPtrTemp->rpdNext)
        {
            BYTE     *      base = dest;

            unsigned        nextOffset;
            DWORD           codeDelta;

            nextOffset = genRegPtrTemp->rpdOffs;

  /*
      Encoding table for methods that are fully interruptible

      The encoding used is as follows:

      ptr reg dead    00RRRDDD    [RRR != 100]
      ptr reg live    01RRRDDD    [RRR != 100]

  non-ptr arg push    10110DDD                    [SSS == 110]
      ptr arg push    10SSSDDD                    [SSS != 110] && [SSS != 111]
      ptr arg pop     11CCCDDD    [CCC != 000] && [CCC != 110] && [CCC != 111]
      little skip     11000DDD    [CCC == 000]
      bigger skip     11110BBB                    [CCC == 110]

      The values used in the above encodings are as follows:

        DDD                 code offset delta from previous entry (0-7)
        BBB                 bigger delta 000=8,001=16,010=24,...,111=64
        RRR                 register number (EAX=000,ECX=001,EDX=010,EBX=011,
                              EBP=101,ESI=110,EDI=111), ESP=100 is reserved
        SSS                 argument offset from base of stack. This is
                              redundant for frameless methods as we can
                              infer it from the previous pushes+pops. However,
                              for EBP-methods, we only report GC pushes, and
                              so we need SSS
        CCC                 argument count being popped (includes only ptrs for EBP methods)

      The following are the 'large' versions:

        large delta skip        10111000 [0xB8] , encodeUnsigned(delta)

        large     ptr arg push  11111000 [0xF8] , encodeUnsigned(pushCount)
        large non-ptr arg push  11111001 [0xF9] , encodeUnsigned(pushCount)
        large     ptr arg pop   11111100 [0xFC] , encodeUnsigned(popCount)
        large         arg dead  11111101 [0xFD] , encodeUnsigned(popCount) for caller-pop args.
                                                    Any GC args go dead after the call,
                                                    but are still sitting on the stack

        this pointer prefix     10111100 [0xBC]   the next encoding is a ptr live
                                                    or a ptr arg push
                                                    and contains the this pointer

        interior or by-ref      10111111 [0xBF]   the next encoding is a ptr live
             pointer prefix                         or a ptr arg push
                                                    and contains an interior
                                                    or by-ref pointer


        The value 11111111 [0xFF] indicates the end of the table.
  */

            codeDelta = nextOffset - lastOffset; assert((int)codeDelta >= 0);

            // If the code delta is between 8 and (64+7),
            // generate a 'bigger delta' encoding

            if ((codeDelta >= 8) && (codeDelta <= (64+7)))
            {
                unsigned biggerDelta = ((codeDelta-8) & 0x38) + 8;
                *dest++ = 0xF0 | ((biggerDelta-8) >> 3);
                lastOffset += biggerDelta;
                codeDelta &= 0x07;
            }

            // If the code delta is still bigger than 7,
            // generate a 'large code delta' encoding

            if  (codeDelta > 7)
            {
                *dest++   = 0xB8;
                dest     += encodeUnsigned(dest, codeDelta);
                codeDelta = 0;

                /* Remember the new 'last' offset */

                lastOffset = nextOffset;
            }

           /* Is this a pointer argument or register entry? */

            if  (genRegPtrTemp->rpdArg)
            {
                if (genRegPtrTemp->rpdArgTypeGet() == rpdARG_KILL)
                {
                    if  (codeDelta)
                    {
                        /*
                            Use the small encoding:
                            little delta skip       11000DDD    [0xC0]
                         */

                        assert((codeDelta & 0x7) == codeDelta);
                        *dest++ = 0xC0 | (BYTE)codeDelta;

                        /* Remember the new 'last' offset */

                        lastOffset = nextOffset;
                    }

                    /* Caller-pop arguments are dead after call but are still
                       sitting on the stack */

                    *dest++  = 0xFD;
                    assert(genRegPtrTemp->rpdPtrArg != 0);
                    dest    += encodeUnsigned(dest, genRegPtrTemp->rpdPtrArg);
                }
                else if  (genRegPtrTemp->rpdPtrArg < 6 && genRegPtrTemp->rpdGCtypeGet())
                {
                    /* Is the argument offset/count smaller than 6 ? */

                    dest = gceByrefPrefixI(genRegPtrTemp, dest);

                    if ( genRegPtrTemp->rpdArgTypeGet() == rpdARG_PUSH ||
                        (genRegPtrTemp->rpdPtrArg!=0))
                    {
                        /*
                          Use the small encoding:

                            ptr arg push 10SSSDDD [SSS != 110] && [SSS != 111]
                            ptr arg pop  11CCCDDD [CCC != 110] && [CCC != 111]
                         */

                        bool isPop = genRegPtrTemp->rpdArgTypeGet() == rpdARG_POP;

                        *dest++ = 0x80 | (BYTE)codeDelta
                                       | genRegPtrTemp->rpdPtrArg << 3
                                       | isPop << 6;

                        /* Remember the new 'last' offset */

                        lastOffset = nextOffset;
                    }
                    else
                    {
                        assert(!"Check this");
                    }

                }
                else if (genRegPtrTemp->rpdGCtypeGet() == GCT_NONE)
                {
                    /*
                        Use the small encoding:
`                        non-ptr arg push 10110DDD [0xB0] (push of sizeof(int))
                     */

                    assert((codeDelta & 0x7) == codeDelta);
                    *dest++ = 0xB0 | (BYTE)codeDelta;
                    assert(!genFPused);

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;
                }
                else
                {
                    /* Will have to use large encoding;
                     *   first do the code delta
                     */

                    if  (codeDelta)
                    {
                        /*
                            Use the small encoding:
                            little delta skip       11000DDD    [0xC0]
                         */

                        assert((codeDelta & 0x7) == codeDelta);
                        *dest++ = 0xC0 | (BYTE)codeDelta;
                    }

                    /*
                        Now append a large argument record:

                            large ptr arg push  11111000 [0xF8]
                            large ptr arg pop   11111100 [0xFC]
                     */

                    bool isPop = genRegPtrTemp->rpdArgTypeGet() == rpdARG_POP;

                    dest = gceByrefPrefixI(genRegPtrTemp, dest);

                    *dest++  = 0xF8 | (isPop << 2);
                    dest    += encodeUnsigned(dest, genRegPtrTemp->rpdPtrArg);

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;
                }
            }
            else
            {
                unsigned    regMask;

                /* Record any registers that are becoming dead */

                regMask = genRegPtrTemp->rpdCompiler.rpdDel & ptrRegs;

                while (regMask)         // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI
                {
                    unsigned    tmpMask;
                    regNumber   regNum;

                    /* Get hold of the next register bit */

                    tmpMask = genFindLowestReg(regMask); assert(tmpMask);

                    /* Remember the new state of this register */

                    ptrRegs&= ~tmpMask;

                    /* Figure out which register the next bit corresponds to */

                    regNum  = genRegNumFromMask(tmpMask); assert(regNum <= 7);

                    /* Reserve ESP, regNum==4 for future use */

                    assert(regNum != 4);

                    /*
                        Generate a small encoding:

                            ptr reg dead        00RRRDDD
                     */

                    assert((codeDelta & 0x7) == codeDelta);
                    *dest++ = 0x00 | regNum << 3
                                   | (BYTE)codeDelta;

                    /* Turn the bit we've just generated off and continue */

                    regMask -= tmpMask; // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    /* Any entries that follow will be at the same offset */

                    codeDelta =  zeroFunc(); /* DO NOT REMOVE */
                }

                /* Record any registers that are becoming live */

                regMask = genRegPtrTemp->rpdCompiler.rpdAdd & ~ptrRegs;

                while (regMask)         // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI
                {
                    unsigned    tmpMask;
                    regNumber   regNum;

                    /* Get hold of the next register bit */

                    tmpMask = genFindLowestReg(regMask); assert(tmpMask);

                    /* Remember the new state of this register */

                    ptrRegs |= tmpMask;

                    /* Figure out which register the next bit corresponds to */

                    regNum  = genRegNumFromMask(tmpMask); assert(regNum <= 7);

                    /*
                        Generate a small encoding:

                            ptr reg live        01RRRDDD
                     */

                    dest = gceByrefPrefixI(genRegPtrTemp, dest);

                    if (!thisIsInUntracked & genRegPtrTemp->rpdIsThis)
                    {
                        // Mark with 'this' pointer prefix
                        *dest++ = 0xBC;
                        // Can only have one bit set in regMask
                        assert(regMask == tmpMask);
                    }

                    assert((codeDelta & 0x7) == codeDelta);
                    *dest++ = 0x40 | regNum << 3
                                   | (BYTE)codeDelta;

                    /* Turn the bit we've just generated off and continue */

                    regMask -= tmpMask;    // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    /* Any entries that follow will be at the same offset */

                    codeDelta =  zeroFunc(); /* DO NOT REMOVE */
                }
            }

            /* Keep track of the total amount of generated stuff */

            totalSize += dest - base;

            /* Go back to the buffer start if we're not generating a table */

            if  (!mask)
                dest = base;
        }

        /* Terminate the table with 0xFF */

        *dest = 0xFF; dest -= mask; totalSize++;
    }
    else if (genFPused)        // genInterruptible is false
    {
  /*
      Encoding table for methods with an EBP frame and
                         that are not fully interruptible

      The encoding used is as follows:

      this pointer encodings:

         01000000          this pointer in EBX
         00100000          this pointer in ESI
         00010000          this pointer in EDI

      tiny encoding:

         0bsdDDDD
                           requires code delta > 0 & delta < 16 (4-bits)
                           requires pushed argmask == 0

           where    DDDD   is code delta
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer


      small encoding:

         1DDDDDDD bsdAAAAA

                           requires code delta     < 120 (7-bits)
                           requires pushed argmask <  64 (5-bits)

           where DDDDDDD   is code delta
                   AAAAA   is the pushed args mask
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer

      medium encoding

         0xFD aaaaaaaa AAAAdddd bseDDDDD

                           requires code delta     <  512  (9-bits)
                           requires pushed argmask < 2048 (12-bits)

           where    DDDDD  is the upper 5-bits of the code delta
                     dddd  is the low   4-bits of the code delta
                     AAAA  is the upper 4-bits of the pushed arg mask
                 aaaaaaaa  is the low   8-bits of the pushed arg mask
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        e  indicates that register EDI is a live pointer

      medium encoding with interior pointers

         0xF9 DDDDDDDD bsdAAAAAA iiiIIIII

                           requires code delta     < 256 (8-bits)
                           requires pushed argmask <  64 (5-bits)

           where  DDDDDDD  is the code delta
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                    AAAAA  is the pushed arg mask
                      iii  indicates that EBX,EDI,ESI are interior pointers
                    IIIII  indicates that bits in the arg mask are interior
                           pointers

      large encoding

         0xFE [0BSD0bsd][32-bit code delta][32-bit argMask]

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                        B  indicates that register EBX is an interior pointer
                        S  indicates that register ESI is an interior pointer
                        D  indicates that register EDI is an interior pointer
                           requires pushed  argmask < 32-bits

      large encoding  with interior pointers

         0xFA [0BSD0bsd][32-bit code delta][32-bit argMask][32-bit interior pointer mask]  
                               

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                        B  indicates that register EBX is an interior pointer
                        S  indicates that register ESI is an interior pointer
                        D  indicates that register EDI is an interior pointer
                           requires pushed  argmask < 32-bits
                           requires pushed iArgmask < 32-bits


      huge encoding        This is the only encoding that supports
                           a pushed argmask which is greater than
                           32-bits.

         0xFB [0BSD0bsd][32-bit code delta]
              [32-bit table count][32-bit table size]
              [pushed ptr offsets table...]

                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer
                       B   indicates that register EBX is an interior pointer
                       S   indicates that register ESI is an interior pointer
                       D   indicates that register EDI is an interior pointer
                       the list count is the number of entries in the list
                       the list size gives the byte-length of the list
                       the offsets in the list are variable-length
  */

        /* If "this" is enregistered, note it. We do this explicitly here as
           genFullPtrRegMap==false, and so we dont have any regPtrDsc's. */

        if (!info.compIsStatic && lvaTable[0].lvRegister)
        {
            assert(lvaIsThisArg(0));

            unsigned thisRegMask   = genRegMask(lvaTable[0].lvRegNum);
            unsigned thisPtrRegEnc = gceEncodeCalleeSavedRegs(thisRegMask) << 4;

            /* @TODO [REVISIT] [04/16/01] []: If "this" is in a calle-trashed register, 
               dont encode it as there is no encoding for it. If the encoding
               gets changed to allow it, will we also have to note when
               "this" goes dead - note that the CallDsc's dont indicate
               when a register goes dead.
               This shouldnt be too bad as if "this" is enregistered in
               a callee-trashed register, it cant be a synchronized method.
             */
            if (thisPtrRegEnc)
            {
                totalSize += 1;
                if (mask)
                    *dest++ = thisPtrRegEnc;
            }
        }

        CallDsc    *    call;

        assert(genFullPtrRegMap == false);

        /* Walk the list of pointer register/argument entries */

        for (call = gcCallDescList; call; call = call->cdNext)
        {
            BYTE    *   base = dest;
            unsigned    nextOffset;

            /* Figure out the code offset of this entry */

            nextOffset = call->cdOffs;

            /* Compute the distance from the previous call */

            DWORD       codeDelta    = nextOffset - lastOffset;

            assert((int)codeDelta >= 0);

            /* Remember the new 'last' offset */

            lastOffset = nextOffset;

            /* Compute the register mask */

            unsigned gcrefRegMask = 0;
            unsigned byrefRegMask = 0;

            gcrefRegMask |= gceEncodeCalleeSavedRegs(call->cdGCrefRegs);
            byrefRegMask |= gceEncodeCalleeSavedRegs(call->cdByrefRegs);

            assert((gcrefRegMask & byrefRegMask) == 0);

            unsigned regMask = gcrefRegMask | byrefRegMask;

            bool byref = (byrefRegMask | call->cdByrefArgMask) != 0;

            /* Check for the really large argument offset case */
            /* The very rare Huge encodings */

            if   (call->cdArgCnt)
            {
                unsigned    argNum;
                DWORD       argCnt = call->cdArgCnt;
                DWORD       argBytes = 0;
                BYTE *      pArgBytes;

                if (mask != 0)
                {
                    *dest++ = 0xFB;
                    *dest++ = (byrefRegMask << 4) | regMask;
                    storeDWordSmallEndian(dest, &codeDelta);dest += sizeof(DWORD);
                    storeDWordSmallEndian(dest, &argCnt);   dest += sizeof(DWORD);
                    // skip the byte-size for now. Just note where it will go
                    pArgBytes = dest;                       dest += sizeof(DWORD);
                }

                for (argNum = 0; argNum < argCnt; argNum++)
                {
                    unsigned    eltSize;
                    eltSize = encodeUnsigned(dest, call->cdArgTable[argNum]);
                    argBytes += eltSize;
                    if (mask) dest += eltSize;
                }

                if (mask == 0)
                {
                    dest = base + 1 + 1 + 3*sizeof(DWORD) + argBytes;
                }
                else
                {
                    assert(dest == pArgBytes + sizeof(argBytes) + argBytes);
                    storeDWordSmallEndian(pArgBytes, &argBytes);
                }
            }

            /* Check if we can use a tiny encoding */
            else if ((codeDelta < 16) && (codeDelta != 0) && (call->cdArgMask == 0) && !byref)
            {
                *dest++ = (regMask << 4) | (BYTE)codeDelta;
            }

            /* Check if we can use the small encoding */
            else if ((codeDelta < 0x79) && (call->cdArgMask <= 0x1F) && !byref)
            {
                *dest++ = 0x80 | (BYTE)codeDelta;
                *dest++ = call->cdArgMask | (regMask << 5);
            }

            /* Check if we can use the medium encoding */
            else if  (codeDelta <= 0x01FF && call->cdArgMask <= 0x0FFF && !byref)
            {
                *dest++ = 0xFD;
                *dest++ = call->cdArgMask;
                *dest++ = ((call->cdArgMask >> 4) & 0xF0) | ((BYTE)codeDelta & 0x0F);
                *dest++ = (regMask << 5) | (BYTE)((codeDelta >> 4) & 0x1F);
            }

            /* Check if we can use the medium encoding with byrefs */
            else if  (codeDelta <= 0x0FF && call->cdArgMask <= 0x01F)
            {
                *dest++ = 0xF9;
                *dest++ = (BYTE)codeDelta;
                *dest++ = (     regMask << 5) | call->cdArgMask;
                *dest++ = (byrefRegMask << 5) | call->cdByrefArgMask;
            }

            /* We'll use the large encoding */
            else if (!byref)
            {
                *dest++ = 0xFE;
                *dest++ = (byrefRegMask << 4) | regMask;
                storeDWordSmallEndian(dest, &codeDelta);                  dest += sizeof(DWORD);
                storeDWordSmallEndian(dest, (DWORD *) &call->cdArgMask);  dest += sizeof(DWORD);
            }

            /* We'll use the large encoding with byrefs */
            else
            {
                *dest++ = 0xFA;
                *dest++ = (byrefRegMask << 4) | regMask;
                storeDWordSmallEndian(dest, &codeDelta);                       dest += sizeof(DWORD);
                storeDWordSmallEndian(dest, (DWORD *) &call->cdArgMask);       dest += sizeof(DWORD);
                storeDWordSmallEndian(dest, (DWORD *) &call->cdByrefArgMask);  dest += sizeof(DWORD);
            }

            /* Keep track of the total amount of generated stuff */

            totalSize += dest - base;

            /* Go back to the buffer start if we're not generating a table */

            if  (!mask)
                dest = base;
        }

        /* Terminate the table with 0xFF */

        *dest = 0xFF; dest -= mask; totalSize++;
    }
    else // genInterruptible is false and we have an EBP-less frame
    {
        assert(genFullPtrRegMap);

        regPtrDsc  *    genRegPtrTemp;
        regNumber       thisRegNum = regNumber(0);
        PendingArgsStack pasStk(getEmitter()->emitMaxStackDepth, this);

        /* Walk the list of pointer register/argument entries */

        for (genRegPtrTemp = gcRegPtrList;
             genRegPtrTemp;
             genRegPtrTemp = genRegPtrTemp->rpdNext)
        {

/*
 *    Encoding table for methods without an EBP frame and
 *     that are not fully interruptible
 *
 *               The encoding used is as follows:
 *
 *  push     000DDDDD                     ESP push one item with 5-bit delta
 *  push     00100000 [pushCount]         ESP push multiple items
 *  reserved 0010xxxx                     xxxx != 0000
 *  reserved 0011xxxx
 *  skip     01000000 [Delta]             Skip Delta, arbitrary sized delta
 *  skip     0100DDDD                     Skip small Delta, for call (DDDD != 0)
 *  pop      01CCDDDD                     ESP pop  CC items with 4-bit delta (CC != 00)
 *  call     1PPPPPPP                     Call Pattern, P=[0..79]
 *  call     1101pbsd DDCCCMMM            Call RegMask=pbsd,ArgCnt=CCC,
 *                                        ArgMask=MMM Delta=commonDelta[DD]
 *  call     1110pbsd [ArgCnt] [ArgMask]  Call ArgCnt,RegMask=pbsd,ArgMask
 *  call     11111000 [PBSDpbsd][32-bit delta][32-bit ArgCnt]
 *                    [32-bit PndCnt][32-bit PndSize][PndOffs...]
 *  iptr     11110000 [IPtrMask]          Arbitrary Interior Pointer Mask
 *  thisptr  111101RR                     This pointer is in Register RR
 *                                        00=EDI,01=ESI,10=EBX,11=EBP
 *  reserved 111100xx                     xx  != 00
 *  reserved 111110xx                     xx  != 00
 *  reserved 11111xxx                     xxx != 000 && xxx != 111(EOT)
 *
 *   The value 11111111 [0xFF] indicates the end of the table. (EOT)
 *
 *  An offset (at which stack-walking is performed) without an explicit encoding
 *  is assumed to be a trivial call-site (no GC registers, stack empty before and
 *  after) to avoid having to encode all trivial calls.
 *
 * Note on the encoding used for interior pointers
 *
 *   The iptr encoding must immediately preceed a call encoding.  It is used
 *   to transform a normal GC pointer addresses into an interior pointers for
 *   GC purposes.  The mask supplied to the iptr encoding is read from the
 *   least signicant bit to the most signicant bit. (i.e the lowest bit is
 *   read first)
 *
 *   p   indicates that register EBP is a live pointer
 *   b   indicates that register EBX is a live pointer
 *   s   indicates that register ESI is a live pointer
 *   d   indicates that register EDI is a live pointer
 *   P   indicates that register EBP is an interior pointer
 *   B   indicates that register EBX is an interior pointer
 *   S   indicates that register ESI is an interior pointer
 *   D   indicates that register EDI is an interior pointer
 *
 *   As an example the following sequence indicates that EDI.ESI and the
 *   second pushed pointer in ArgMask are really interior pointers.  The
 *   pointer in ESI in a normal pointer:
 *
 *   iptr 11110000 00010011           => read Interior Ptr, Interior Ptr,
 *                                       Normal Ptr, Normal Ptr, Interior Ptr
 *
 *   call 11010011 DDCCC011 RRRR=1011 => read EDI is a GC-pointer,
 *                                            ESI is a GC-pointer.
 *                                            EBP is a GC-pointer
 *                           MMM=0011 => read two GC-pointers arguments
 *                                         on the stack (nested call)
 *
 *   Since the call instruction mentions 5 GC-pointers we list them in
 *   the required order:  EDI, ESI, EBP, 1st-pushed pointer, 2nd-pushed pointer
 *
 *   And we apply the Interior Pointer mask mmmm=10011 to the five GC-pointers
 *   we learn that EDI and ESI are interior GC-pointers and that
 *   the second push arg is an interior GC-pointer.
 */

            BYTE    *       base = dest;

            bool            usePopEncoding;
            unsigned        regMask;
            unsigned        argMask;
            unsigned        byrefRegMask;
            unsigned        byrefArgMask;
            DWORD           callArgCnt;

            unsigned        nextOffset;
            DWORD           codeDelta;

            nextOffset = genRegPtrTemp->rpdOffs;

            /* Compute the distance from the previous call */

            codeDelta = nextOffset - lastOffset; assert((int)codeDelta >= 0);

#if REGEN_CALLPAT
            // Must initialize this flag to true when REGEN_CALLPAT is on
            usePopEncoding = true;
            unsigned origCodeDelta = codeDelta;
#endif

            if (!thisIsInUntracked & genRegPtrTemp->rpdIsThis)
            {
                unsigned  tmpMask = genRegPtrTemp->rpdCompiler.rpdAdd;

                /* tmpMask must have exactly one bit set */

                assert(tmpMask && ((tmpMask & (tmpMask-1)) == 0));

                thisRegNum  = genRegNumFromMask(tmpMask);
                switch (thisRegNum)
                {
                  case 0: // EAX
                  case 1: // ECX
                  case 2: // EDX
                  case 4: // ESP
                    break;
                  case 7: // EDI
                    *dest++ = 0xF4;  /* 11110100  This pointer is in EDI */
                    break;
                  case 6: // ESI
                    *dest++ = 0xF5;  /* 11110100  This pointer is in ESI */
                    break;
                  case 3: // EBX
                    *dest++ = 0xF6;  /* 11110100  This pointer is in EBX */
                    break;
                  case 5: // EBP
                    *dest++ = 0xF7;  /* 11110100  This pointer is in EBP */
                    break;
                }
            }

            /* Is this a stack pointer change or call? */

            if (genRegPtrTemp->rpdArg)
            {
                if (genRegPtrTemp->rpdArgTypeGet() == rpdARG_KILL)
                {
                    // kill 'rpdPtrArg' number of pointer variables in pasStk
                    pasStk.pasKill(genRegPtrTemp->rpdPtrArg);
                }
                    /* Is this a call site? */
                else if (genRegPtrTemp->rpdCall)
                {
                    /* This is a true call site */

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    callArgCnt = genRegPtrTemp->rpdPtrArg;

                    unsigned gcrefRegMask = genRegPtrTemp->rpdCallGCrefRegs;
                    
                    byrefRegMask = genRegPtrTemp->rpdCallByrefRegs;

                    assert((gcrefRegMask & byrefRegMask) == 0);

                    regMask = gcrefRegMask | byrefRegMask;

                    /* adjust argMask for this call-site */
                    pasStk.pasPop(callArgCnt);

                    /* Do we have to use the fat encoding */

                    if (pasStk.pasCurDepth() > BITS_IN_pasMask &&
                        pasStk.pasHasGCptrs())
                    {
                        /* use fat encoding:
                         *   11111000 [PBSDpbsd][32-bit delta][32-bit ArgCnt]
                         *            [32-bit PndCnt][32-bit PndSize][PndOffs...]
                         */

                        DWORD   pndCount = pasStk.pasEnumGCoffsCount();
                        DWORD   pndSize = 0;
                        BYTE *  pPndSize;

                        if (mask)
                        {
                           *dest++ = 0xF8;
                           *dest++ = (byrefRegMask << 4) | regMask;
                            storeDWordSmallEndian(dest, &codeDelta);    dest += sizeof(DWORD);
                            storeDWordSmallEndian(dest, &callArgCnt);   dest += sizeof(DWORD);
                            storeDWordSmallEndian(dest, &pndCount);     dest += sizeof(DWORD);
                            pPndSize = dest;                            dest += sizeof(DWORD); // Leave space for pndSize
                        }

                        unsigned offs, iter;

                        for(iter = pasStk.pasEnumGCoffs(pasENUM_START, &offs);
                            pndCount;
                            iter = pasStk.pasEnumGCoffs(iter, &offs), pndCount--)
                        {
                            unsigned eltSize = encodeUnsigned(dest, offs);

                            pndSize += eltSize;
                            if (mask) dest += eltSize;
                        }
                        assert(iter == pasENUM_END);

                        if (mask == 0)
                        {
                            dest = base + 2 + 4*sizeof(DWORD) + pndSize;
                        }
                        else
                        {
                            assert(pPndSize + sizeof(pndSize) + pndSize == dest);
                            storeDWordSmallEndian(pPndSize, &pndSize);
                        }

                        goto NEXT_RPD;
                    }

                    argMask = byrefArgMask = 0;

                    if (pasStk.pasHasGCptrs())
                    {
                        assert(pasStk.pasCurDepth() <= BITS_IN_pasMask);

                             argMask = pasStk.pasArgMask();
                        byrefArgMask = pasStk.pasByrefArgMask();
                    }

                    /* Shouldn't be reporting trivial call-sites */

                    assert(regMask || argMask || callArgCnt || pasStk.pasCurDepth());

                    // Emit IPtrMask if needed

#define CHK_NON_INTRPT_ESP_IPtrMask                                         \
                                                                            \
                    if (byrefRegMask || byrefArgMask)                       \
                    {                                                       \
                        *dest++ = 0xF0;                                     \
                        unsigned imask = (byrefArgMask << 4) | byrefRegMask;\
                        dest += encodeUnsigned(dest, imask);                \
                    }

                    /* When usePopEncoding is true: 
                     *  this is not an interesting call site
                     *   because nothing is live here. 
                     */
                    usePopEncoding = ((callArgCnt < 4) && (regMask == 0) && (argMask == 0));

                    if (!usePopEncoding)
                    {
                        int pattern = lookupCallPattern(callArgCnt, regMask,
                                                        argMask, codeDelta);
                        if (pattern != -1)
                        {
                            if (pattern > 0xff)
                            {
                                codeDelta = pattern >> 8;
                                pattern &= 0xff;
                                if (codeDelta >= 16)
                                {
                                    /* use encoding: */
                                    /*   skip 01000000 [Delta] */
                                    *dest++ = 0x40;
                                    dest += encodeUnsigned(dest, codeDelta);
                                    codeDelta = 0;
                                }
                                else
                                {
                                    /* use encoding: */
                                    /*   skip 0100DDDD  small delta=DDDD */
                                    *dest++ = 0x40 | (BYTE)codeDelta;
                                }
                            }

                            // Emit IPtrMask if needed
                            CHK_NON_INTRPT_ESP_IPtrMask;

                            assert((pattern >= 0) && (pattern < 80));
                            *dest++ = 0x80 | pattern;
                            goto NEXT_RPD;
                        }

                        /* See if we can use 2nd call encoding
                         *     1101RRRR DDCCCMMM encoding */

                        if ((callArgCnt <= 7) && (argMask <= 7))
                        {
                            unsigned inx;          // callCommonDelta[] index
                            unsigned maxCommonDelta = callCommonDelta[3];

                            if (codeDelta > maxCommonDelta)
                            {
                                if (codeDelta > maxCommonDelta+15)
                                {
                                    /* use encoding: */
                                    /*   skip    01000000 [Delta] */
                                    *dest++ = 0x40;
                                    dest += encodeUnsigned(dest, codeDelta-maxCommonDelta);
                                }
                                else
                                {
                                    /* use encoding: */
                                    /*   skip 0100DDDD  small delta=DDDD */
                                    *dest++ = 0x40 | (BYTE)(codeDelta-maxCommonDelta);
                                }

                                codeDelta = maxCommonDelta;
                                inx = 3;
                                goto EMIT_2ND_CALL_ENCODING;
                            }

                            for (inx=0; inx<4; inx++)
                            {
                                if (codeDelta == callCommonDelta[inx])
                                {
EMIT_2ND_CALL_ENCODING:
                                    // Emit IPtrMask if needed
                                    CHK_NON_INTRPT_ESP_IPtrMask;

                                    *dest++ = 0xD0 | regMask;
                                    *dest++ =   (inx << 6)
                                              | (callArgCnt << 3)
                                              | argMask;
                                    goto NEXT_RPD;
                                }
                            }

                            unsigned minCommonDelta = callCommonDelta[0];

                            if ((codeDelta > minCommonDelta) && (codeDelta < maxCommonDelta))
                            {
                                assert((minCommonDelta+16) > maxCommonDelta);
                                /* use encoding: */
                                /*   skip 0100DDDD  small delta=DDDD */
                                *dest++ = 0x40 | (BYTE)(codeDelta-minCommonDelta);
                                
                                codeDelta = minCommonDelta;
                                inx = 0;
                                goto EMIT_2ND_CALL_ENCODING;
                            }

                        }
                    }

                    if (codeDelta >= 16)
                    {
                        unsigned i = (usePopEncoding ? 15 : 0);
                        /* use encoding: */
                        /*   skip    01000000 [Delta]  arbitrary sized delta */
                        *dest++ = 0x40;
                        dest += encodeUnsigned(dest, codeDelta-i);
                        codeDelta = i;
                    }

                    if ((codeDelta > 0) || usePopEncoding)
                    {
                        if (usePopEncoding)
                        {
                            /* use encoding: */
                            /*   pop 01CCDDDD  ESP pop CC items, 4-bit delta */
                            if (callArgCnt || codeDelta)
                                *dest++ = (BYTE)(0x40 | (callArgCnt << 4) | codeDelta);
                            goto NEXT_RPD;
                        }
                        else
                        {
                            /* use encoding: */
                            /*   skip 0100DDDD  small delta=DDDD */
                            *dest++ = 0x40 | (BYTE)codeDelta;
                        }
                    }

                    //Emit IPtrMask if needed
                    CHK_NON_INTRPT_ESP_IPtrMask;

                    /* use encoding:                                   */
                    /*   call 1110RRRR [ArgCnt] [ArgMask]              */

                    *dest++ = 0xE0 | regMask;
                    dest   += encodeUnsigned(dest, callArgCnt);

                    dest   += encodeUnsigned(dest, argMask);
                }
                else
                {
                    /* This is a push or a pop site */

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    if  (genRegPtrTemp->rpdArgTypeGet() == rpdARG_POP)
                    {
                        /* This must be a gcArgPopSingle */

                        assert(genRegPtrTemp->rpdPtrArg == 1);

                        if (codeDelta >= 16)
                        {
                            /* use encoding: */
                            /*   skip    01000000 [Delta] */
                            *dest++ = 0x40;
                            dest += encodeUnsigned(dest, codeDelta-15);
                            codeDelta = 15;
                        }

                        /* use encoding: */
                        /*   pop1    0101DDDD  ESP pop one item, 4-bit delta */

                        *dest++ = 0x50 | (BYTE)codeDelta;

                        /* adjust argMask for this pop */
                        pasStk.pasPop(1);
                    }
                    else
                    {
                        /* This is a push */

                        if (codeDelta >= 32)
                        {
                            /* use encoding: */
                            /*   skip    01000000 [Delta] */
                            *dest++ = 0x40;
                            dest += encodeUnsigned(dest, codeDelta-31);
                            codeDelta = 31;
                        }

                        assert(codeDelta < 32);

                        /* use encoding: */
                        /*   push    000DDDDD ESP push one item, 5-bit delta */

                        *dest++ = (BYTE)codeDelta;

                        /* adjust argMask for this push */
                        pasStk.pasPush(genRegPtrTemp->rpdGCtypeGet());
                    }
                }
            }

            /*  We ignore the register live/dead information, since the
             *  rpdCallRegMask contains all the liveness information
             *  that we need
             */
NEXT_RPD:

            totalSize += dest - base;

            /* Go back to the buffer start if we're not generating a table */

            if  (!mask)
                dest = base;

#if REGEN_CALLPAT
            if ((mask==-1) && (usePopEncoding==false) && ((dest-base) > 0))
                regenLog(origCodeDelta, argMask, regMask, callArgCnt, 
                         byrefArgMask, byrefRegMask, base, (dest-base));
#endif

        }

        /* Verify that we pop every arg that was pushed and that argMask is 0 */

        assert(pasStk.pasCurDepth() == 0);

        /* Terminate the table with 0xFF */

        *dest = 0xFF; dest -= mask; totalSize++;
    }

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xBEEB;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif

#if MEASURE_PTRTAB_SIZE

    if (mask)
        s_gcTotalPtrTabSize += totalSize;

#endif

#else

#pragma message("NOTE: GC table generation disabled for non-x86 targets")

#endif

    return  totalSize;
}

/*****************************************************************************/
#if DUMP_GC_TABLES
/*****************************************************************************
 *
 *  Dump the contents of a GC pointer table.
 */

#include "GCDump.h"

GCDump              gcDump;

#if VERIFY_GC_TABLES
const bool          verifyGCTables  = true;
#else
const bool          verifyGCTables  = false;
#endif


/*****************************************************************************
 *
 *  Dump the info block header.
 */

unsigned            Compiler::gcInfoBlockHdrDump(const BYTE *   table,
                                                 InfoHdr    *   header,
                                                 unsigned   *   methodSize)
{
    gcDump.gcPrintf = logf;             // use my printf (which logs to VM)
    printf("Method info block:\n");

    return gcDump.DumpInfoHdr(table, header, methodSize, verifyGCTables);
}

/*****************************************************************************/

unsigned            Compiler::gcDumpPtrTable(const BYTE *   table,
                                             const InfoHdr& header,
                                             unsigned       methodSize)
{
    printf("Pointer table:\n");

    return gcDump.DumpGCTable(table, header, methodSize, verifyGCTables);
}


/*****************************************************************************
 *
 *  Find all the live pointers in a stack frame.
 */

void                Compiler::gcFindPtrsInFrame(const void *infoBlock,
                                                const void *codeBlock,
                                                unsigned    offs)
{
    gcDump.DumpPtrsInFrame(infoBlock, codeBlock, offs, verifyGCTables);
}

#endif // DUMP_GC_TABLES

/*****************************************************************************/
#endif//TRACK_GC_REFS
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\gcinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          GCInfo                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "GCInfo.h"
#include "emit.h"

/*****************************************************************************/
#if TRACK_GC_REFS
/*****************************************************************************/

/*****************************************************************************/

extern int         JITGcBarrierCall;    

/*****************************************************************************/

#if MEASURE_PTRTAB_SIZE
/* static */ unsigned       Compiler::s_gcRegPtrDscSize = 0;
/* static */ unsigned       Compiler::s_gcTotalPtrTabSize = 0;
#endif

void                Compiler::gcInit()
{
}

/*****************************************************************************/
#ifndef OPT_IL_JIT
/*****************************************************************************
 *
 *  If the given tree value is sitting in a register, free it now.
 */

void                Compiler::gcMarkRegPtrVal(GenTreePtr tree)
{
    if  (varTypeIsGC(tree->TypeGet()))
    {
        if  (tree->gtOper == GT_LCL_VAR)
            genMarkLclVar(tree);

        if  (tree->gtFlags & GTF_REG_VAL)
            gcMarkRegSetNpt(genRegMask(tree->gtRegNum));
    }
}

/*****************************************************************************/

#ifdef  DEBUG

void                Compiler::gcRegPtrSetDisp(regMaskTP regMask, bool fixed)
{
    assert(REG_STK+1 == REG_COUNT);

    for (regNumber regNum = REG_FIRST; regNum < REG_COUNT; regNum = REG_NEXT(regNum))
    {
        if  (regMask & genRegMask(regNum))
        {
            char    reg[10];

            strcpy(reg, compRegVarName(regNum));

#ifndef _WIN32_WCE
            _strlwr(reg+1);
#endif

            printf("%3s", reg);
        }
        else
        {
            if  (fixed)
                printf("   ");
        }
    }
}

#endif

/*****************************************************************************/
#endif // OPT_IL_JIT
/*****************************************************************************
 *
 *  Initialize the non-register pointer variable tracking logic.
 */

void                Compiler::gcVarPtrSetInit()
{
    gcVarPtrSetCur = 0;

    /* Initialize the list of lifetime entries */

    gcVarPtrList =
    gcVarPtrLast = (varPtrDsc *)compGetMem(sizeof(*gcVarPtrList));

    gcVarPtrList->vpdNext =
    gcVarPtrList->vpdPrev = 0;
}

/*****************************************************************************
 *
 *  Allocate a new pointer register set / pointer argument entry and append
 *  it to the list.
 */

Compiler::regPtrDsc  *        Compiler::gcRegPtrAllocDsc()
{
    regPtrDsc  *    regPtrNext;

    assert(genFullPtrRegMap);

    /* Allocate a new entry and initialize it */

    regPtrNext = (regPtrDsc *)compGetMem(sizeof(*regPtrNext));

    regPtrNext->rpdEpilog        = FALSE;
    regPtrNext->rpdIsThis        = FALSE;

    regPtrNext->rpdOffs          = 0;
//  regPtrNext->rpdNext          = 0;

    /* Append the entry to the end of the list */

    assert(gcRegPtrList);
    assert(gcRegPtrLast);

    /* Note that we don't set the 'next' link for the new entry */

    gcRegPtrLast->rpdNext  = regPtrNext;
    gcRegPtrLast           = regPtrNext;

#if MEASURE_PTRTAB_SIZE
    s_gcRegPtrDscSize += sizeof(*regPtrNext);
#endif

    return  regPtrNext;
}

/*****************************************************************************
 *
 *  Compute the various counts that get stored in the info block header.
 */

void                Compiler::gcCountForHeader(unsigned short* untrackedCount,
                                               unsigned short* varPtrTableSize)
{
    unsigned        varNum;
    LclVarDsc *     varDsc;
    varPtrDsc *     varTmp;

    assert(gcVarPtrList);
    assert(gcVarPtrLast);

    /* Terminate the linked list of variable lifetimes */

    gcVarPtrLast->vpdNext = 0;

    /* Skip over the initial fake lifetime entry */

    gcVarPtrList = gcVarPtrList->vpdNext;

    if  (genFullPtrRegMap)
    {
        assert(gcRegPtrList);
        assert(gcRegPtrLast);

        /* Terminate the linked list */

        gcRegPtrLast->rpdNext = 0;

        /* The first entry in the list is fake */

        gcRegPtrList = gcRegPtrList->rpdNext;
    }
    else
    {
        assert(gcCallDescList);
        assert(gcCallDescLast);

        /* Terminate the linked list of call descriptors */

        gcCallDescLast->cdNext = 0;

        /* Skip over the initial fake call entry */

        gcCallDescList = gcCallDescList->cdNext;
    }

    bool        thisIsInUntracked = false; // did we track "this" ?
    unsigned    count = 0;

    /* Count the untracked locals and non-enregistered args */

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        if  (varTypeIsGC(varDsc->TypeGet()))
        {
            /* Do we have an argument or local variable? */
            if  (!varDsc->lvIsParam)
            {
                if  (varDsc->lvTracked || !varDsc->lvOnFrame)
                    continue;
            }
            else
            {
                /* Stack-passed arguments which are not enregistered
                 * are always reported in this "untracked stack
                 * pointers" section of the GC info even if lvTracked==true
                 */

                /* Has this argument been enregistered? */
				if  (varDsc->lvRegister) 
				{
						/* if a CEE_JMP has been used, then we need to report all the arguments
						   even if they are enregistered, since we will be using this value
						   in JMP call.  Note that this is subtle as we require that
						   argument offsets are always fixed up properly even if lvRegister
						   is set */
					if (!compJmpOpUsed)
						continue;
				}
                else
                {
                    if  (!varDsc->lvOnFrame)
                    {
                        /* If this non-enregistered pointer arg is never
                         * used, we dont need to report it
                         */
                        assert(varDsc->lvRefCnt == 0);
                        continue;
                    }
                    else  if (varDsc->lvIsRegArg && varDsc->lvTracked)
                    {
                        /* If this register-passed arg is tracked, then
                         * it has been allocated space near the other
                         * pointer variables and we have accurate life-
                         * time info. It will be reported with
                         * gcVarPtrList in the "tracked-pointer" section
                         */

                        continue;
                    }
                }
            }

            if (varDsc->lvVerTypeInfo.IsThisPtr())
            {
                // Encoding of untracked variables does not support reporting
                // "this". So report it as a tracked variable with a liveness 
                // extending over the entire method.

                thisIsInUntracked = true;
                continue;
            }

#ifdef  DEBUG
            if  (verbose)
            {
                int         offs = varDsc->lvStkOffs;

                printf("GCINFO: untrckd %s lcl at [%s",
                        varTypeGCstring(varDsc->TypeGet()),
                        genFPused ? "EBP" : "ESP");

                if      (offs < 0)
                    printf("-%02XH", -offs);
                else if (offs > 0)
                    printf("+%02XH", +offs);

                printf("]\n");
            }
#endif

            count++;
        }
        else if  (varDsc->lvType == TYP_STRUCT && varDsc->lvOnFrame)
        {
            assert(!varDsc->lvTracked);

	    unsigned slots  = lvaLclSize(varNum) / sizeof(void*);
	    BYTE *   gcPtrs = lvaGetGcLayout(varNum);

            // walk each member of the array
            for (unsigned i = 0; i < slots; i++)
                if (gcPtrs[i] != TYPE_GC_NONE)     // count only gc slots
                    count++;
        }
    }

    /* Also count spill temps that hold pointers */

    for (TempDsc * tempThis = tmpListBeg();
         tempThis;
         tempThis = tmpListNxt(tempThis))
    {
        if  (varTypeIsGC(tempThis->tdTempType()) == false)
            continue;

#ifdef  DEBUG
        if  (verbose)
        {
            int         offs = tempThis->tdTempOffs();

            printf("GCINFO: untrck %s Temp at [%s",
                    varTypeGCstring(varDsc->TypeGet()),
                    genFPused ? "EBP" : "ESP");

            if      (offs < 0)
                printf("-%02XH", -offs);
            else if (offs > 0)
                printf("+%02XH", +offs);

            printf("]\n");
        }
#endif

        count++;
    }

#ifdef  DEBUG
    if (verbose) printf("GCINFO: untrckVars = %u\n", count);
#endif

    *untrackedCount = count;

    /* Count the number of entries in the table of non-register pointer
       variable lifetimes. */

    count = 0;

    if (thisIsInUntracked)
        count++;

    if  (gcVarPtrList)
    {
        /* We'll use a delta encoding for the lifetime offsets */

        for (varTmp = gcVarPtrList; varTmp; varTmp = varTmp->vpdNext)
        {
            /* Special case: skip any 0-length lifetimes */

            if  (varTmp->vpdBegOfs == varTmp->vpdEndOfs)
                continue;

            count++;
        }
    }

#ifdef  DEBUG
    if (verbose) printf("GCINFO: trackdLcls = %u\n", count);
#endif

    *varPtrTableSize = count;
}

/*****************************************************************************
 *
 *  Shutdown the 'pointer value' register tracking logic and save the necessary
 *  info (which will be used at runtime to locate all pointers) at the specified
 *  address. The number of bytes written to 'destPtr' must be identical to that
 *  returned from gcPtrTableSize().
 */

BYTE    *           Compiler::gcPtrTableSave(BYTE *          destPtr,
                                             const InfoHdr & header,
                                             unsigned        codeSize)
{
    /* Write the tables to the info block */

    return  destPtr + gcMakeRegPtrTable(destPtr, -1, header, codeSize);
}

/*****************************************************************************
 *
 *  Initialize the 'pointer value' register/argument tracking logic.
 */

void                Compiler::gcRegPtrSetInit()
{
    gcRegGCrefSetCur =
    gcRegByrefSetCur = 0;

    if  (genFullPtrRegMap)
    {
        gcRegPtrList =
        gcRegPtrLast = (regPtrDsc *)compGetMem(roundUp(sizeof(*gcRegPtrList)));

//      gcRegPtrList->rpdNext            = 0;
        gcRegPtrList->rpdOffs            = 0;
        gcRegPtrList->rpdCompiler.rpdAdd =
        gcRegPtrList->rpdCompiler.rpdDel = 0;
    }
    else
    {
        /* Initialize the 'call descriptor' list */

        gcCallDescList =
        gcCallDescLast = (CallDsc *)compGetMem(sizeof(*gcCallDescList));
    }
}

/*****************************************************************************
 *
 *  Helper passed to genEmitter.emitCodeEpilogLst() to generate
 *  the table of epilogs.
 */

/* static */ size_t Compiler::gcRecordEpilog(void *   pCallBackData,
                                             unsigned offset)
{
    Compiler  *     pCompiler = (Compiler *)pCallBackData;

    assert(pCompiler);

    size_t result = encodeUDelta(pCompiler->gcEpilogTable,
                                 offset,
                                 pCompiler->gcEpilogPrevOffset);

    if (pCompiler->gcEpilogTable)
        pCompiler->gcEpilogTable += result;

    pCompiler->gcEpilogPrevOffset = offset;

    return result;
}

/*****************************************************************************/
#endif // TRACK_GC_REFS
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\exec.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EXEC_H_
#define _EXEC_H_
/*****************************************************************************/

struct BasicBlock;

/*****************************************************************************/

#pragma pack(push, 4)

/*****************************************************************************/

enum    execFixKinds
{
    FIX_MODE_ERROR,
    FIX_MODE_SELF32,
    FIX_MODE_SEGM32,
#if SCHEDULER
    FIX_MODE_SCHED,                     // fake fixup only used for scheduling
#endif
};

enum    execFixTgts
{
    FIX_TGT_ERROR = 0,

    // The first group of fixups are the same as the CCF format

    FIX_TGT_HELPER          =  1,       // target is a VM helper function
    FIX_TGT_FIELD_OFFSET    =  2,       // target is a field offset
    FIX_TGT_VTABLE_OFFSET   =  3,       // target is a vtable offset
    FIX_TGT_STATIC_METHOD   =  4,       // target is a static member address
    FIX_TGT_STATIC_FIELD    =  5,       // target is a static member address
    FIX_TGT_CLASS_HDL       =  6,       // target is a class handle
    FIX_TGT_METHOD_HDL      =  7,       // target is a method handle
    FIX_TGT_FIELD_HDL       =  8,       // target is a field handle
    FIX_TGT_STATIC_HDL      =  9,       // target is a static data block handle
    FIX_TGT_IID             = 10,       // target is an interface ID
    FIX_TGT_STRCNS_HDL      = 11,       // target is a string literal handle
    FIX_TGT_VM_DATA         = 12,       // target is address of static VM data
    FIX_TGT_DESCR_METHOD    = 13,       // target is a descriptor of a method

    // These are additional fixups internal to the VM

    FIX_TGT_CONST           = 17,       // target is a constant   data item
    FIX_TGT_DATA,                       // target is a read/write data item
    FIX_TGT_LCLADR,                     // target is a     local function
    FIX_TGT_EXTADR,                     // target is an external function
    FIX_TGT_RECURSE,                    // target is our own method
    FIX_TGT_STATDM,                     // target is a static data member   (OLD)

#if SCHEDULER
    FIX_TGT_SCHED,                      // fake fixup only used for scheduling
#endif
};

struct  execFixDsc
{
    unsigned        efdOffs;            // offset of fixed-up location
    union
    {
    void       *    efdTgtAddr;         // handle to code   target
    BasicBlock *    efdTgtCode;         // handle to code   target
    unsigned        efdTgtData;         // offset of data   target
    int             efdTgtHlpx;         // index  of helper target
#if defined(JIT_AS_COMPILER) || defined(LATE_DISASM)
    CORINFO_METHOD_HANDLE   efdTgtMeth;         // method handle of target
    struct
    {
        CORINFO_MODULE_HANDLE    cls;           // TODO fix name
        unsigned        CPidx;
    }
                    efdTgtCP;           // Class and Constant pool index of target
#endif
    CORINFO_FIELD_HANDLE    efdTgtSDMH;         // handle of static data member
#if     SCHEDULER
    unsigned        efdTgtInfo;         // info about schedulable instruction
#endif
    };

#ifndef  DEBUG
#if     SCHEDULER
    unsigned        efdMode     :2;     // fixup kind/mode
    unsigned        efdTarget   :6;     // fixup target kind
#else
    BYTE            efdMode;            // fixup kind/mode
    BYTE            efdTarget;          // fixup target kind
#endif
#else
    execFixKinds    efdMode;            // fixup kind/mode
    execFixTgts     efdTarget;          // fixup target kind
#endif

#if     SCHEDULER

    unsigned        efdInsSize  :4;     // instruction size (bytes of code)

    unsigned        efdInsSetFL :1;     // this          instruction sets the flags?
    unsigned        efdInsUseFL :1;     // this          instruction uses the flags?

    unsigned        efdInsNxtFL :1;     // the following instruction uses the flags?

    unsigned        efdInsUseX87:1;     // uses the numeric processor

#endif

};

struct  execMemDsc
{
    execMemDsc  *   emdNext;            // next member in the list

    char    *       emdName;            // null-terminated member name

    unsigned        emdCodeSize;        // the size    of code
    BYTE    *       emdCodeAddr;        // the address of code

    unsigned        emdConsSize;        // the size    of read-only  data
    BYTE    *       emdConsAddr;        // the address of read-only  data

    unsigned        emdDataSize;        // the size    of read-write data
    BYTE    *       emdDataAddr;        // the address of read-write data
};

struct  execClsDsc
{
    const   char *  ecdClassPath;       // name of the class file (?)

    unsigned        ecdMethodCnt;       // number of method bodies
    execMemDsc  *   ecdMethodLst;       // list   of method bodies
};

/*****************************************************************************/
#pragma pack(pop)
/*****************************************************************************/

#ifndef EXECCC
#define EXECCC      __fastcall
#endif

/*****************************************************************************
 *
 *  The following is used by EMIT.CPP to build an executable descriptor
 *  for a class.
 */

execClsDsc* EXECCC  createExecClassInit(const char  * classPath);

execMemDsc* EXECCC  createExecAddMethod(execClsDsc  * dsc,
                                        const char  * name,
                                        unsigned      codeSize,
                                        unsigned      consSize,
                                        unsigned      dataSize);

execMemDsc* EXECCC  createExecAddStatDm(execClsDsc  * dsc,
                                        const char  * name,
                                        unsigned      size);

void      * EXECCC  createExecImageAddr(execMemDsc  * mem);

void        EXECCC  createExecClassDone(execClsDsc  * dsc);

/*****************************************************************************/

inline
void      * EXECCC  createExecCodeAddr(execMemDsc   * mem)
{
    return  mem->emdCodeAddr;
}

inline
void      * EXECCC  createExecConsAddr(execMemDsc   * mem)
{
    return  mem->emdConsAddr;
}

inline
void      * EXECCC  createExecDataAddr(execMemDsc   * mem)
{
    return  mem->emdDataAddr;
}

/*****************************************************************************/
#endif  // _EXEC_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\emitx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                             emitX86.cpp                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/
#if     TGT_x86     // this entire file is used only for targetting the x86
/*****************************************************************************/

#include "alloc.h"
#include "instr.h"
#include "target.h"
#include "emit.h"

/*****************************************************************************/

regMaskSmall        emitter::emitRegMasks[] =
{
    #define REGDEF(name, rnum, mask, byte) mask,
    #include "register.h"
    #undef  REGDEF
};


/*****************************************************************************
 *
 *  Record a non-empty stack
 */

void                emitter::emitMarkStackLvl(size_t stackLevel)
{
    assert(int(stackLevel)     >= 0);
    assert(emitCurStackLvl     == 0);
    assert(emitCurIG->igStkLvl == 0);
    assert(emitCurIGfreeNext == emitCurIGfreeBase);

    assert(stackLevel && stackLevel % sizeof(int) == 0);

    emitCurStackLvl = emitCurIG->igStkLvl = stackLevel;

    if (emitMaxStackDepth < emitCurStackLvl)
        emitMaxStackDepth = emitCurStackLvl;
}

/*****************************************************************************
 *
 *  Get hold of the address mode displacement value for an indirect call.
 */

inline
int                 emitter::emitGetInsCIdisp(instrDesc *id)
{
    if  (id->idInfo.idLargeCall)
    {
        return  ((instrDescCIGCA*)id)->idciDisp;
    }
    else
    {
        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);

        return  id->idAddr.iiaAddrMode.amDisp;
    }
}

/*****************************************************************************
 *
 *  Use the specified code bytes as the epilog sequence.
 */

void                emitter::emitDefEpilog(BYTE *codeAddr, size_t codeSize)
{
    memcpy(emitEpilogCode, codeAddr, codeSize);
           emitEpilogSize      =     codeSize;

#ifdef  DEBUG
    emitHaveEpilog = true;
#endif

}

/*****************************************************************************
 *
 *  Call the specified function pointer for each epilog block in the current
 *  method with the epilog's relative code offset. Returns the sum of the
 *  values returned by the callback.
 */

size_t              emitter::emitGenEpilogLst(size_t (*fp)(void *, unsigned),
                                              void    *cp)
{
    instrDescCns *  id;
    size_t          sz;

    for (id = emitEpilogList, sz = 0; id; id = id->idAddr.iiaNxtEpilog)
    {
        assert(id->idInsFmt == IF_EPILOG);

        sz += fp(cp, id->idcCnsVal);
    }

    return  sz;
}

/*****************************************************************************
 *
 *  Initialize the table used by emitInsModeFormat().
 */

BYTE                emitter::emitInsModeFmtTab[] =
{
    #define INST0(id, nm, fp, um, rf, wf, ss, mr                ) um,
    #define INST1(id, nm, fp, um, rf, wf, ss, mr                ) um,
    #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) um,
    #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) um,
    #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) um,
    #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) um,
    #include "instrs.h"
    #undef  INST0
    #undef  INST1
    #undef  INST2
    #undef  INST3
    #undef  INST4
    #undef  INST5
};

#ifdef  DEBUG
unsigned            emitter::emitInsModeFmtCnt = sizeof(emitInsModeFmtTab)/
                                                 sizeof(emitInsModeFmtTab[0]);
#endif

/*****************************************************************************
 *
 *  A version of scInsModeFormat() that handles floating-point instructions.
 */

emitter::insFormats   emitter::emitInsModeFormat(instruction ins, insFormats base,
                                                                  insFormats FPld,
                                                                  insFormats FPst)
{
    if  (Compiler::instIsFP(ins))
    {
        assert(IF_TRD_SRD + 1 == IF_TWR_SRD);
        assert(IF_TRD_SRD + 2 == IF_TRW_SRD);

        assert(IF_TRD_MRD + 1 == IF_TWR_MRD);
        assert(IF_TRD_MRD + 2 == IF_TRW_MRD);

        assert(IF_TRD_ARD + 1 == IF_TWR_ARD);
        assert(IF_TRD_ARD + 2 == IF_TRW_ARD);

        switch (ins)
        {
        case INS_fst:
        case INS_fstp:
        case INS_fistp:
        case INS_fistpl:
            return  (insFormats)(FPst  );

        case INS_fld:
        case INS_fild:
            return  (insFormats)(FPld+1);

        case INS_fcomp:
        case INS_fcompp:
        case INS_fcomip:
            return  (insFormats)(FPld  );

        default:
            return  (insFormats)(FPld+2);
        }
    }
    else
    {
        return  emitInsModeFormat(ins, base);
    }
}

/*****************************************************************************
 *
 *  Returns the base encoding of the given CPU instruction.
 */

inline
unsigned            insCode(instruction ins)
{
    const static
    unsigned        insCodes[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                ) mr,
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                ) mr,
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) mr,
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) mr,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) mr,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) mr,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodes)/sizeof(insCodes[0]));
    assert((insCodes[ins] != BAD_CODE));

    return  insCodes[ins];
}

/*****************************************************************************
 *
 *  Returns the "[r/m], 32-bit icon" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeMI(instruction ins)
{
    const static
    unsigned        insCodesMI[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) mi,
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) mi,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) mi,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) mi,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesMI)/sizeof(insCodesMI[0]));
    assert((insCodesMI[ins] != BAD_CODE));

    return  insCodesMI[ins];
}

/*****************************************************************************
 *
 *  Returns the "reg, [r/m]" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeRM(instruction ins)
{
    const static
    unsigned        insCodesRM[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            )
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) rm,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) rm,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) rm,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesRM)/sizeof(insCodesRM[0]));
    assert((insCodesRM[ins] != BAD_CODE));

    return  insCodesRM[ins];
}

/*****************************************************************************
 *
 *  Returns the "AL/AX/EAX, imm" accumulator encoding of the given instruction.
 */

inline
unsigned            insCodeACC(instruction ins)
{
    const static
    unsigned        insCodesACC[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            )
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        )
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) a4,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) a4,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesACC)/sizeof(insCodesACC[0]));
    assert((insCodesACC[ins] != BAD_CODE));

    return  insCodesACC[ins];
}

/*****************************************************************************
 *
 *  Returns the "register" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeRR(instruction ins)
{
    const static
    unsigned        insCodesRR[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            )
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        )
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    )
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) rr,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesRR)/sizeof(insCodesRR[0]));
    assert((insCodesRR[ins] != BAD_CODE));

    return  insCodesRR[ins];
}

/*****************************************************************************
 *
 *  Returns the "[r/m], reg" or "[r/m]" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeMR(instruction ins)
{
    const static
    unsigned        insCodesMR[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                ) mr,
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) mr,
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) mr,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) mr,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) mr,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesMR)/sizeof(insCodesMR[0]));
    assert((insCodesMR[ins] != BAD_CODE));

    return  insCodesMR[ins];
}

/*****************************************************************************
 *
 *  Returns an encoding for the specified register to be used in the bit0-2
 *  part of an opcode.
 */

inline
unsigned            insEncodeReg012(emitRegs reg)
{
    assert(reg < 8);
    return reg;
}

/*****************************************************************************
 *
 *  Returns an encoding for the specified register to be used in the bit3-5
 *  part of an opcode.
 */

inline
unsigned            insEncodeReg345(emitRegs reg)
{
    assert(reg < 8);
    return(reg<< 3);
}

/*****************************************************************************
 *
 *  Returns the given opcode with the [r/m] field set to a register.
 */

inline
unsigned            insEncodeMRreg(unsigned code)
{
    assert((code & 0xC000) == 0);
    return  code | 0xC000;
}

/*****************************************************************************
 *
 *  Returns the "[r/m]" opcode with the mod/RM field set to register.
 */

inline
unsigned            insEncodeMRreg(instruction ins)
{
    return  insEncodeMRreg(insCodeMR(ins));
}

/*****************************************************************************
 *
 *  Returns the "[r/m], icon" opcode with the mod/RM field set to register.
 */

inline
unsigned            insEncodeMIreg(instruction ins)
{
    return  insEncodeMRreg(insCodeMI(ins));
}

/*****************************************************************************
 *
 *  Returns the "[r/m]" opcode with the mod/RM field set to register.
 */

inline
unsigned            insEncodeRMreg(instruction ins)
{
    return  insEncodeMRreg(insCodeRM(ins));
}

/*****************************************************************************
 *
 *  Returns the "byte ptr [r/m]" opcode with the mod/RM field set to
 *  the given register.
 */

inline
unsigned            insEncodeMRreg(instruction ins, emitRegs reg)
{
    return  insEncodeMRreg(insCodeMR(ins)) |  (insEncodeReg012(reg) << 8);
}

/*****************************************************************************
 *
 *  Returns the "byte ptr [r/m], icon" opcode with the mod/RM field set to
 *  the given register.
 */

inline
unsigned            insEncodeMIreg(instruction ins, emitRegs reg)
{
    return  insEncodeMRreg(insCodeMI(ins)) |  (insEncodeReg012(reg) << 8);
}

/*****************************************************************************
 *
 *  Return the 'SS' field value for the given index scale factor.
 */

inline
unsigned            insSSval(unsigned scale)
{
    assert(scale == 1 ||
           scale == 2 ||
           scale == 4 ||
           scale == 8);

    const static
    BYTE    scales[] =
    {
        0x00,   // 1
        0x40,   // 2
        0xFF,   // 3
        0x80,   // 4
        0xFF,   // 5
        0xFF,   // 6
        0xFF,   // 7
        0xC0,   // 8
    };

    return  scales[scale-1];
}

/*****************************************************************************
 * Reverse the conditional jump
 */

const emitJumpKind      emitReverseJumpKinds[] =
{
    EJ_NONE,

    #define JMP_SMALL(en, nm, rev, op) EJ_##rev,
    #define JMP_LARGE(en, nm, rev, op)
    #include "emitjmps.h"
    #undef  JMP_SMALL
    #undef  JMP_LARGE

    EJ_call,
};

/*****************************************************************************
 * The size for these instructions is less than EA_4BYTE,
 * but the target register need not be byte-addressable
 */

inline
bool                emitInstHasNoCode(instruction ins)
{
#if SCHEDULER
    if (ins == INS_noSched)
        return true;
#endif

    return false;
}

/*****************************************************************************
 * The size for these instructions is less than EA_4BYTE,
 * but the target register need not be byte-addressable
 */

#ifdef DEBUG
bool                insLooksSmall(instruction ins)
{
    if (ins == INS_movsx || ins == INS_movzx)
        return true;
    else
        return false;
}
#endif

/*****************************************************************************
 *
 *  Estimate the size (in bytes of generated code) of the given instruction.
 */

inline
size_t              emitter::emitInsSize(unsigned code)
{
    return  (code & 0x00FF0000) ? 3 : 2;
}

inline
size_t              emitter::emitInsSizeRM(instruction ins)
{
    return  emitInsSize(insCodeRM(ins));
}

inline
size_t              emitter::emitInsSizeRR(instruction ins)
{
    return  emitInsSize(insEncodeRMreg(ins));
}

/*****************************************************************************/

inline
size_t              emitter::emitInsSizeSV(unsigned code, int var, int dsp)
{
    size_t          size = emitInsSize(code);
    size_t          offs;
    bool            offsIsUpperBound = true; // Do we guarantee that we wont have to use larger 'offs' ?

    /*  Is this a temporary? */

    if  (var < 0)
    {
        /* An address off of ESP takes an extra byte */

        if  (!emitEBPframe)
            size++;

        /* We'll have to estimate the max. possible offset of this temp */

        // UNDONE: Get an estimate of the temp offset instead of assuming
        // UNDONE: that any temp may be at the max. temp offset!!!!!!!!!!

        offs = emitLclSize + emitMaxTmpSize;
        offsIsUpperBound = false;
    }
    else
    {
        bool            EBPbased;

        /* Get the frame offset of the (non-temp) variable */

        offs = dsp + emitComp->lvaFrameAddress(var, &EBPbased);

        /* An address off of ESP takes an extra byte */

        assert(!EBPbased == 0 || !EBPbased == 1); size += !EBPbased;

        /* Is this a stack parameter reference? */

        if  ( emitComp->lvaIsParameter  (var) &&
             !emitComp->lvaIsRegArgument(var)    )
        {

            /* If no EBP frame, arguments are off of ESP, above temps */

            if  (!EBPbased)
            {
                assert((int)offs >= 0);

                offsIsUpperBound = false; // since #temps can increase
                offs += emitMaxTmpSize;
            }
        }
        else
        {
            /* Locals off of EBP are at negative offsets */

            if  (EBPbased)
            {
                assert((int)offs < 0);

                return  size + ((int(offs) >= SCHAR_MIN) ? sizeof(char)
                                                         : sizeof( int));
            }
        }
    }

    assert((int)offs >= 0);

    /* Are we addressing off of ESP? */

    if  (!emitEBPframe)
    {
        /* Adjust the effective offset if necessary */

        if  (emitCntStackDepth)
            offs += emitCurStackLvl;

#if SCHEDULER
        /* If we move any pushes before this instruction, it will increase
           the offset of the local. As we dont know if this will happen,
           we keep a limit on the number of pushes that can be scheduled.
           Assume that we will hit the limit for estimating the instruction
           encoding size */

        if (emitComp->opts.compSchedCode)
            offs += SCHED_MAX_STACK_CHANGE;
#endif

        /* Special case: check for "[ESP]" */

        if  (offs == 0)
            return  size;
    }

//  printf("lcl = %04X, tmp = %04X, stk = %04X, offs = %04X\n",
//         emitLclSize, emitMaxTmpSize, emitCurStackLvl, offs);

    bool useSmallEncoding = (offs <= size_t(SCHAR_MAX));

    /* If we are using a small encoding, there is a danger that we might
       end up having to use a larger encoding. Record 'offs' so that
       we can detect if such a situation occurs */

    if (useSmallEncoding && !offsIsUpperBound)
    {
        if (emitGrowableMaxByteOffs < offs)
        {
            emitGrowableMaxByteOffs = offs;
#ifdef DEBUG
            // Remember which instruction this is
            emitMaxByteOffsIdNum    = emitInsCount;
#endif
        }
    }

    return  size + (useSmallEncoding ? sizeof(char)
                                     : sizeof( int));
}

inline
size_t              emitter::emitInsSizeSV(instrDesc * id, int var, int dsp, int val)
{
    instruction  ins       = id->idInsGet();
    size_t       valSize   = EA_SIZE_IN_BYTES(emitDecodeSize(id->idOpSize));
    size_t       prefix    = 0;
    bool         valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    if  (valSize > sizeof(int))
        valSize = sizeof(int);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;      // relocs can't be placed in a byte
        assert(valSize == sizeof(int));
    }
#endif

    if  (valInByte)
    {
        valSize = sizeof(char);
    }

    /* 16-bit operand instructions need a prefix */
    if (emitDecodeSize(id->idOpSize) == EA_2BYTE)
    {
        prefix = 1;
    }

    return prefix + valSize + emitInsSizeSV(insCodeMI(ins), var, dsp);
}

/*****************************************************************************/

size_t              emitter::emitInsSizeAM(instrDesc * id, unsigned code)
{
    emitAttr    attrSize  = emitDecodeSize(id->idOpSize);
    emitRegs    reg       = (emitRegs)id->idAddr.iiaAddrMode.amBaseReg;
    emitRegs    rgx       = (emitRegs)id->idAddr.iiaAddrMode.amIndxReg;
    instruction ins       = id->idInsGet();
    /* The displacement field is in an unusual place for calls */
    int         dsp       = (ins == INS_call) ? emitGetInsCIdisp(id)
                                              : emitGetInsAmdAny(id);
    bool        dspInByte = ((signed char)dsp == (int)dsp);
    bool        dspIsZero = (dsp == 0);
    size_t      size;


#ifdef RELOC_SUPPORT
    if (id->idInfo.idDspReloc)
    {
        dspInByte = false;      // relocs can't be placed in a byte
        dspIsZero = false;      // relocs won't always be zero
    }
#endif

    if  (code & 0x00FF0000)
    {
        assert(    (attrSize == EA_4BYTE)
                || (ins == INS_movzx)
                || (ins == INS_movsx));

        size = 3;
    }
    else
    {
        size = 2;

        /* most 16-bit operands will require a size prefix */

        if  (    (attrSize == EA_2BYTE)
              && (ins != INS_fldcw)
              && (ins != INS_fnstcw))
        {
            size++;
        }
    }

    if  (rgx == SR_NA)
    {
        /* The address is of the form "[reg+disp]" */

        switch (reg)
        {

        case SR_NA:

            /* The address is of the form "[disp]" */

            size += sizeof(int);
            return size;

        case SR_EBP:
            break;

        case SR_ESP:
            size++;

            // Fall through ...

        default:
            if  (dspIsZero)
                return size;
        }

        /* Does the offset fit in a byte? */

        if  (dspInByte)
            size += sizeof(char);
        else
            size += sizeof(int);
    }
    else
    {
        /* An index register is present */

        size++;

        /* Is the index value scaled? */

        if  (emitDecodeScale(id->idAddr.iiaAddrMode.amScale) > 1)
        {
            /* Is there a base register? */

            if  (reg != SR_NA)
            {
                /* The address is "[reg + {2/4/8} * rgx + icon]" */

                if  (dspIsZero && reg != SR_EBP)
                {
                    /* The address is "[reg + {2/4/8} * rgx]" */

                }
                else
                {
                    /* The address is "[reg + {2/4/8} * rgx + disp]" */

                    if  (dspInByte)
                        size += sizeof(char);
                    else
                        size += sizeof(int );
                }
            }
            else
            {
                /* The address is "[{2/4/8} * rgx + icon]" */

                size += sizeof(int);
            }
        }
        else
        {
            if  (dspIsZero && (reg == SR_EBP)
                           && (rgx != SR_EBP))
            {
                /* Swap reg and rgx, such that reg is not EBP */
                id->idAddr.iiaAddrMode.amBaseReg = reg = rgx;
                id->idAddr.iiaAddrMode.amIndxReg = rgx = SR_EBP;
            }

            /* The address is "[reg+rgx+dsp]" */

            if  (dspIsZero && reg != SR_EBP)
            {
                /* This is [reg+rgx]" */

            }
            else
            {
                /* This is [reg+rgx+dsp]" */

                if  (dspInByte)
                    size += sizeof(char);
                else
                    size += sizeof(int );
            }
        }
    }

    return  size;
}

inline
size_t              emitter::emitInsSizeAM(instrDesc * id, unsigned code, int val)
{
    instruction  ins       = id->idInsGet();
    size_t       valSize   = EA_SIZE_IN_BYTES(emitDecodeSize(id->idOpSize));
    bool         valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    if  (valSize > sizeof(int))
        valSize = sizeof(int);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;      // relocs can't be placed in a byte
        assert(valSize == sizeof(int));
    }
#endif

    if  (valInByte)
    {
        valSize = sizeof(char);
    }

    return  valSize + emitInsSizeAM(id, code);
}

inline
size_t              emitter::emitInsSizeCV(instrDesc * id, unsigned code)
{
    instruction  ins       = id->idInsGet();
    size_t       size      = sizeof(void*);

    /* Most 16-bit operand instructions will need a prefix */

    if  (emitDecodeSize(id->idOpSize) == EA_2BYTE && ins != INS_movzx
                                                  && ins != INS_movsx)
        size++;

    return  size + emitInsSize(code);
}

inline
size_t              emitter::emitInsSizeCV(instrDesc * id, unsigned code, int val)
{
    instruction  ins       = id->idInsGet();
    size_t       valSize   = EA_SIZE_IN_BYTES(emitDecodeSize(id->idOpSize));
    bool         valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    if  (valSize > sizeof(int))
        valSize = sizeof(int);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;      // relocs can't be placed in a byte
        assert(valSize == sizeof(int));
    }
#endif

    if  (valInByte)
    {
        valSize = sizeof(char);
    }

    return valSize + emitInsSizeCV(id, code);
}

/*****************************************************************************
 *
 *  Allocate instruction descriptors for instructions with address modes.
 */

inline
emitter::instrDesc      * emitter::emitNewInstrAmd   (emitAttr size, int dsp)
{
    if  (dsp < AM_DISP_MIN || dsp > AM_DISP_MAX)
    {
        instrDescAmd   *id = emitAllocInstrAmd   (size);

        id->idInfo.idLargeDsp          = true;
#ifdef  DEBUG
        id->idAddr.iiaAddrMode.amDisp  = AM_DISP_BIG_VAL;
#endif
        id->idaAmdVal                  = dsp;

        return  id;
    }
    else
    {
        instrDesc      *id = emitAllocInstr      (size);

        id->idAddr.iiaAddrMode.amDisp  = dsp;
 assert(id->idAddr.iiaAddrMode.amDisp == dsp);  // make sure the value fit

        return  id;
    }
}

inline
emitter::instrDescDCM   * emitter::emitNewInstrDCM (emitAttr size, int dsp, int cns, int val)
{
    // @TODO [REVISIT] [04/16/01] [briansul]: cns is always zero 

    instrDescDCM   *id = emitAllocInstrDCM (size);

    id->idInfo.idLargeCns = true;
    id->idInfo.idLargeDsp = true;

    id->iddcDspVal = dsp;
    id->iddcCnsVal = cns;

#if EMITTER_STATS
    emitLargeDspCnt++;
    emitLargeCnsCnt++;
#endif

    id->idcmCval   = val;

    return  id;
}

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for a direct call.
 *
 *  We use two different descriptors to save space - the common case records
 *  with no GC variables or byrefs and has a very small argument count, and no
 *  explicit scope;
 *  the much rarer (we hope) case records the current GC var set, the call scope,
 *  and an arbitrarily large argument count.
 */

emitter::instrDesc *emitter::emitNewInstrCallDir(int        argCnt,
#if TRACK_GC_REFS
                                                 VARSET_TP  GCvars,
                                                 unsigned   byrefRegs,
#endif
                                                 int        retSizeIn)
{
    emitAttr       retSize = retSizeIn ? EA_ATTR(retSizeIn) : EA_4BYTE;

    /*
        Allocate a larger descriptor if new GC values need to be saved
        or if we have an absurd number of arguments or if we need to
        save the scope.
     */

    if  (GCvars    != 0            ||   // any frame GCvars live
         byrefRegs != 0            ||   // any register byrefs live
         argCnt > ID_MAX_SMALL_CNS ||   // too many args
         argCnt < 0                   ) // caller pops arguments
    {
        instrDescCDGCA* id = emitAllocInstrCDGCA(retSize);

//      printf("Direct call with GC vars / big arg cnt / explicit scope\n");

        id->idInfo.idLargeCall = true;

        id->idcdGCvars         = GCvars;
        id->idcdByrefRegs      = emitEncodeCallGCregs(byrefRegs);

        id->idcdArgCnt         = argCnt;

        return  id;
    }
    else
    {
        instrDesc     * id = emitNewInstrCns(retSize, argCnt);

//      printf("Direct call w/o  GC vars / big arg cnt / explicit scope\n");

        /* Make sure we didn't waste space unexpectedly */

        assert(id->idInfo.idLargeCns == false);

        return  id;
    }
}

/*****************************************************************************
 *
 *  Get hold of the argument count for a direct call.
 */

inline
int             emitter::emitGetInsCDinfo(instrDesc *id)
{
    if  (id->idInfo.idLargeCall)
    {
        return  ((instrDescCDGCA*)id)->idcdArgCnt;
    }
    else
    {
        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);

        return  emitGetInsCns(id);
    }
}

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction that uses both
 *  an address mode displacement and a constant.
 */

emitter::instrDesc *  emitter::emitNewInstrAmdCns(emitAttr size, int dsp, int cns)
{
    if  (dsp >= AM_DISP_MIN && dsp <= AM_DISP_MAX)
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDesc      *id = emitAllocInstr      (size);

            id->idInfo.idSmallCns          = cns;

            id->idAddr.iiaAddrMode.amDisp  = dsp;
     assert(id->idAddr.iiaAddrMode.amDisp == dsp);  // make sure the value fit

            return  id;
        }
        else
        {
            instrDescCns   *id = emitAllocInstrCns   (size);

            id->idInfo.idLargeCns          = true;
            id->idcCnsVal                  = cns;

            id->idAddr.iiaAddrMode.amDisp  = dsp;
     assert(id->idAddr.iiaAddrMode.amDisp == dsp);  // make sure the value fit

            return  id;
        }
    }
    else
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDescAmd   *id = emitAllocInstrAmd   (size);

            id->idInfo.idLargeDsp          = true;
#ifdef  DEBUG
            id->idAddr.iiaAddrMode.amDisp  = AM_DISP_BIG_VAL;
#endif
            id->idaAmdVal                  = dsp;

            id->idInfo.idSmallCns          = cns;

            return  id;
        }
        else
        {
            instrDescAmdCns*id = emitAllocInstrAmdCns(size);

            id->idInfo.idLargeCns          = true;
            id->idacCnsVal                 = cns;

            id->idInfo.idLargeDsp          = true;
#ifdef  DEBUG
            id->idAddr.iiaAddrMode.amDisp  = AM_DISP_BIG_VAL;
#endif
            id->idacAmdVal                 = dsp;

            return  id;
        }
    }
}

/*****************************************************************************
 *
 *  The next instruction will be a loop head entry point
 *  So insert a dummy instruction here to insure that
 *  the x86 I-cache alignment rule is followed.
 *
 *  The parameter flowInfo indicate whether the previous
 *  block can flow into this one.
 *
 */

void                emitter::emitLoopAlign(bool flowInto)
{
    /* Insert a pseudo-instruction to ensure that we align
       the next instruction properly */

    /* We encode the flowInto argument in the opSize field */
    emitAttr opSize = flowInto ? EA_1BYTE : EA_2BYTE;

    instrDesc * id  = emitNewInstrTiny(opSize);
    id->idIns       = INS_align;
    id->idCodeSize  = 7;        // We may need to skip up to 7 byte of code

    assert(scIsSchedulable(id->idIns) == false);
}


/*****************************************************************************
 *
 *  Add an instruction with no operands.
 */

void                emitter::emitIns(instruction ins)
{
    size_t      sz;
    instrDesc  *id = emitNewInstr();

    sz = (insCodeMR(ins) & 0xFF00) ? sizeof(short)
                                   : sizeof(char);

    id->idInsFmt   = Compiler::instIsFP(ins) ? emitInsModeFormat(ins, IF_TRD)
                                             : IF_NONE;

#if SCHEDULER
    if (emitComp->opts.compSchedCode)
    {
        if (Compiler::instIsFP(ins))
            scInsNonSched(id);
    }
#endif

    id->idIns      = ins;
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction of the form "op ST(0),ST(n)".
 */

void                emitter::emitIns_F0_F(instruction ins, unsigned fpreg)
{
    size_t      sz = 2;
    instrDesc  *id = emitNewInstr();

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched(id);
#endif

    id->idIns      = ins;
    id->idInsFmt   = emitInsModeFormat(ins, IF_TRD_FRD);
    id->idReg      = (emitRegs)fpreg;
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction of the form "op ST(n),ST(0)".
 */

void                emitter::emitIns_F_F0(instruction ins, unsigned fpreg)
{
    size_t      sz = 2;
    instrDesc  *id = emitNewInstr();

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched(id);
#endif

    id->idIns      = ins;
    id->idInsFmt   = emitInsModeFormat(ins, IF_FRD_TRD);
    id->idReg      = (emitRegs)fpreg;

    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction referencing a single register.
 */

void                emitter::emitIns_R(instruction ins,
                                       emitAttr    attr,
                                       emitRegs    reg)
{
    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS));

    size_t          sz;
    instrDesc      *id   = emitNewInstrTiny(attr);


    switch (ins)
    {
    case INS_inc:
    case INS_dec:
        if (size == EA_1BYTE)
            sz = 2; // Use the long form as the small one has no 'w' bit
        else
            sz = 1; // Use short form
        break;

    case INS_pop:
    case INS_pop_hide:
    case INS_push:
    case INS_push_hide:

        /* We dont currently push/pop small values */

        assert(size == EA_4BYTE);

        sz = 1;
        break;

    default:

        /* All the sixteen INS_setCCs are contiguous. */

        if (INS_seto <= ins && ins <= INS_setg)
        {
            // Rough check that we used the endpoints for the range check

            assert(INS_seto + 0xF == INS_setg);

            /* We expect this to always be a 'big' opcode */

            assert(insEncodeMRreg(ins, reg) & 0x00FF0000);

            sz = 3;
            break;
        }
        else
        {
            sz = 2;
            break;
        }
    }
    id->idIns      = ins;
    id->idReg      = reg;
    id->idInsFmt   = emitInsModeFormat(ins, IF_RRD);

    /* 16-bit operand instructions will need a prefix */

    if (size == EA_2BYTE)
        sz += 1;

    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  Add an instruction referencing a register and a constant.
 */

void                emitter::emitIns_R_I(instruction ins,
                                         emitAttr    attr,
                                         emitRegs    reg,
                                         int         val)
{
    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS));

    size_t      sz;
    instrDesc  *id;
    insFormats  fmt       = emitInsModeFormat(ins, IF_RRD_CNS);
    bool        valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    /* Figure out the size of the instruction */

    switch (ins)
    {
    case INS_mov:
        sz = 5;
        break;

    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_RRW_SHF;
        sz   = 3;
        val &= 0x7F;
        valInByte = true;       // shift amount always placed in a byte
        break;

    default:

        if (EA_IS_CNS_RELOC(attr))
            valInByte = false;  // relocs can't be placed in a byte

        if  (valInByte)
        {
            sz = 3;
        }
        else
        {
            if  (reg == SR_EAX && !instrIs3opImul(ins))
            {
                sz = 1;
            }
            else
            {
                sz = 2;
            }
            sz += EA_SIZE_IN_BYTES(attr);
        }
        break;
    }

    id             = emitNewInstrSC(attr, val);
    id->idIns      = ins;
    id->idReg      = reg;
    id->idInsFmt   = fmt;

    /* 16-bit operand instructions will need a prefix */

    if (size == EA_2BYTE)
        sz += 1;

    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if  (reg == SR_ESP)
    {
        if  (emitCntStackDepth)
        {
            if      (ins == INS_sub)
            {
                emitCurStackLvl += val;

                if  (emitMaxStackDepth < emitCurStackLvl)
                     emitMaxStackDepth = emitCurStackLvl;
            }
            else if (ins == INS_add)
            {
                emitCurStackLvl -= val; assert((int)emitCurStackLvl >= 0);
            }
        }
    }
}

/*****************************************************************************
 *
 *  Load a register with the address of a method
 *
 *  instruction must be INS_mov
 */

void emitter::emitIns_R_MP(instruction ins, emitAttr attr, emitRegs reg, CORINFO_METHOD_HANDLE methHnd)
{
    assert(ins == INS_mov && EA_SIZE(attr) == EA_4BYTE);

    instrBaseCns *     id = (instrBaseCns*)emitAllocInstr(sizeof(instrBaseCns), attr);
    size_t             sz = 1 + sizeof(void*);

    id->idIns             = INS_mov;
    id->idCodeSize        = sz;
    id->idInsFmt          = IF_RWR_METHOD;
    id->idReg             = reg;
    id->idScnsDsc         = true;
    id->idInfo.idLargeCns = true;
    id->idAddr.iiaMethHnd = methHnd;

    dispIns(id);
    emitCurIGsize += sz;

}

/*****************************************************************************
 *
 *  Add an instruction referencing an integer constant.
 */

void                emitter::emitIns_I(instruction ins,
                                       emitAttr    attr,
                                       int         val
#ifdef  DEBUG
                                      ,bool        strlit
#endif
                                      )
{
    size_t     sz;
    instrDesc *id;
    bool       valInByte = ((signed char)val == val);

    if (EA_IS_CNS_RELOC(attr))
        valInByte = false;  // relocs can't be placed in a byte

    switch (ins)
    {
    case INS_loop:
    case INS_jge:
        sz = 2;
        break;

    case INS_ret:
        sz = 3;
        break;

    case INS_push_hide:
    case INS_push:
        sz = valInByte ? 2 : 5;
        break;

    default:
        NO_WAY_RETVOID("unexpected instruction");
    }

    id                = emitNewInstrSC(attr, val);
    id->idIns         = ins;
    id->idInsFmt      = IF_CNS;

#ifdef  DEBUG
    id->idStrLit      = strlit;
#endif

    id->idCodeSize    = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if  (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
}

/*****************************************************************************
 *
 *  Add a "jump through a table" instruction.
 */

void                emitter::emitIns_IJ(emitAttr attr,
                                        emitRegs reg,
                                        unsigned base,
                                        unsigned offs)

{
    assert(EA_SIZE(attr) == EA_4BYTE);

    size_t                       sz  = 3 + sizeof(void*);
    unsigned                     adr = base + offs - 1;
    instrDesc                   *id  = emitNewInstrAmd(attr, adr);

    assert(base & 1);

    id->idIns                        = INS_i_jmp;
    id->idInsFmt                     = IF_ARD;
    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(sizeof(void*));

#ifdef  DEBUG
    id->idMemCookie                  = base - 1;
#endif

    id->idCodeSize                   = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a static data member operand. If 'size' is 0, the
 *  instruction operates on the address of the static member instead of its
 *  value (e.g. "push offset clsvar", rather than "push dword ptr [clsvar]").
 */

void                emitter::emitIns_C(instruction  ins,
                                       emitAttr     attr,
                                       CORINFO_FIELD_HANDLE fldHnd,
                                       int          offs)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    size_t          sz;
    instrDesc      *id;

    /* Are we pushing the offset of the class variable? */

    if  (EA_IS_OFFSET(attr))
    {
        assert(ins == INS_push);
        sz = 1 + sizeof(void*);

        id                 = emitNewInstrDsp(EA_1BYTE, offs);
        id->idIns          = ins;
        id->idInsFmt       = IF_MRD_OFF;
    }
    else
    {
        id                 = emitNewInstrDsp(attr, offs);
        id->idIns          = ins;
        id->idInsFmt       = emitInsModeFormat(ins, IF_MRD,
                                                    IF_TRD_MRD,
                                                    IF_MWR_TRD);
        sz                 = emitInsSizeCV(id, insCodeMR(ins));
    }

    id->idAddr.iiaFieldHnd = fldHnd;

    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  Add an instruction with two register operands.
 */

void                emitter::emitIns_R_R   (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    reg1,
                                            emitRegs    reg2)
{
    /* We don't want to generate any useless mov instructions! */
    assert(ins != INS_mov || reg1 != reg2);

    emitAttr   size = EA_SIZE(attr);

    assert(   size <= EA_4BYTE);
    assert(   size != EA_1BYTE
           || (   (emitRegMask(reg1) & SRM_BYTE_REGS)
               && (emitRegMask(reg2) & SRM_BYTE_REGS))
           || insLooksSmall(ins));

    size_t          sz = emitInsSizeRR(ins);

    /* Most 16-bit operand instructions will need a prefix */

    if (size == EA_2BYTE && ins != INS_movsx
                         && ins != INS_movzx)
        sz += 1;

    instrDesc      *id = emitNewInstrTiny(attr);
    id->idIns          = ins;
    id->idReg          = reg1;
    id->idRg2          = reg2;
    id->idCodeSize     = sz;

    /* Special case: "XCHG" uses a different format */

    id->idInsFmt       = (ins == INS_xchg) ? IF_RRW_RRW
                                           : emitInsModeFormat(ins, IF_RRD_RRD);

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with two register operands and an integer constant.
 */

void                emitter::emitIns_R_R_I (instruction ins,
                                            emitRegs    reg1,
                                            emitRegs    reg2,
                                            int         ival)
{
    size_t          sz = 4;
    instrDesc      *id = emitNewInstrSC(EA_4BYTE, ival);

    id->idIns          = ins;
    id->idReg          = reg1;
    id->idRg2          = reg2;
    id->idInsFmt       = IF_RRW_RRW_CNS;
    id->idCodeSize     = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a register + static member operands.
 */
void                emitter::emitIns_R_C(instruction  ins,
                                         emitAttr     attr,
                                         emitRegs     reg,
                                         CORINFO_FIELD_HANDLE fldHnd,
                                         int          offs)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id;

    /* Are we MOV'ing the offset of the class variable into EAX? */

    /* @TODO [REVISIT] [04/16/01] []:
       is the next line correct? why can we assume that reg == SR_EAX?  (fpg)
     */

    if  (EA_IS_OFFSET(attr))
    {
        id                 = emitNewInstrDsp(EA_1BYTE, offs);
        id->idIns          = ins;
        id->idInsFmt       = IF_RWR_MRD_OFF;

        assert(ins == INS_mov && reg == SR_EAX);

        /* Special case: "mov eax, [addr]" is smaller */

        sz = 1 + sizeof(void *);
    }
    else
    {
        id                 = emitNewInstrDsp(attr, offs);
        id->idIns          = ins;
        id->idInsFmt       = emitInsModeFormat(ins, IF_RRD_MRD);

        /* Special case: "mov eax, [addr]" is smaller */

        if  (ins == INS_mov && reg == SR_EAX && size == EA_4BYTE)
            sz = 1 + sizeof(void *);
        else
            sz = emitInsSizeCV(id, insCodeRM(ins));

        /* Special case: mov reg, fs:[ddd] */

        if (fldHnd == FLD_GLOBAL_FS)
            sz += 1;
    }

    id->idReg              = reg;
    id->idAddr.iiaFieldHnd = fldHnd;

    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a static member + register operands.
 */

void                emitter::emitIns_C_R  (instruction  ins,
                                           emitAttr     attr,
                                           CORINFO_FIELD_HANDLE fldHnd,
                                           emitRegs     reg,
                                           int          offs)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    instrDesc      *id     = emitNewInstrDsp(attr, offs);
    id->idIns              = ins;
    size_t          sz;

    /* Special case: "mov [addr], EAX" is smaller */

    if  (ins == INS_mov && reg == SR_EAX && size == EA_4BYTE)
        sz = 1 + sizeof(void *);
    else
        sz = emitInsSizeCV(id, insCodeMR(ins));

    /* Special case: mov reg, fs:[ddd] */

    if (fldHnd == FLD_GLOBAL_FS)
        sz += 1;

    id->idInsFmt           = emitInsModeFormat(ins, IF_MRD_RRD);
    id->idReg              = reg;
    id->idAddr.iiaFieldHnd = fldHnd;
    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a static member + constant.
 */

void                emitter::emitIns_C_I   (instruction  ins,
                                            emitAttr     attr,
                                            CORINFO_FIELD_HANDLE fldHnd,
                                            int          offs,
                                            int          val)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_MRW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt = emitInsModeFormat(ins, IF_MRD_CNS);
        break;
    }

    instrDescDCM   *id     = emitNewInstrDCM(attr, offs, 0, val);
    id->idIns              = ins;
    size_t          sz     = emitInsSizeCV(id, insCodeMI(ins), val);

    id->idInsFmt           = fmt;
    id->idAddr.iiaFieldHnd = fldHnd;
    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_J_AR   (instruction ins,
                                             emitAttr    attr,
                                             BasicBlock *val,
                                             emitRegs    reg,
                                             int         offs,
                                             int         memCookie,
                                             void *      clsCookie)
{
    // emitAttr    size = EA_SIZE(attr);
    assert(ins == INS_mov);
    assert(!"NYI");
}

/*****************************************************************************
 *
 *  The following adds instructions referencing address modes.
 */

void                emitter::emitIns_I_AR  (instruction ins,
                                            emitAttr    attr,
                                            int         val,
                                            emitRegs    reg,
                                            int         disp,
                                            int         memCookie,
                                            void *      clsCookie)
{
    emitAttr   size = EA_SIZE(attr);

    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    size_t          sz;
    instrDesc *     id               = emitNewInstrAmdCns(attr, disp, val);
    id->idIns                        = ins;
    id->idInsFmt                     = fmt;
    id->idInfo.idMayFault            = true;

    assert((memCookie == NULL) == (clsCookie == NULL));

#ifdef  DEBUG
    id->idMemCookie                  = memCookie;
    id->idClsCookie                  = clsCookie;
#endif

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = SR_NA;

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_AR (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           emitRegs    reg,
                                           int         disp,
                                           int         memCookie,
                                           void *      clsCookie)
{
    emitAttr   size = EA_SIZE(attr);

    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idIns                        = ins;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idReg                        = ireg;

    if  (ins != INS_lea)
        id->idInfo.idMayFault = true;

    assert((memCookie == NULL) == (clsCookie == NULL));

#ifdef  DEBUG
    id->idMemCookie                  = memCookie;
    id->idClsCookie                  = clsCookie;
#endif

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = SR_NA;

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_AR_R (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           emitRegs    reg,
                                           int         disp,
                                           int         memCookie,
                                           void *      clsCookie)
{
    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    if  (ireg == SR_NA)
    {
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD,
                                                              IF_TRD_ARD,
                                                              IF_AWR_TRD);
#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr  size = EA_SIZE(attr);
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));

        id->idReg    = ireg;
        id->idInsFmt = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    assert((memCookie == NULL) == (clsCookie == NULL));

#ifdef  DEBUG
    id->idMemCookie                  = memCookie;
    id->idClsCookie                  = clsCookie;
#endif

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = SR_NA;

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize               = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_I_ARR (instruction ins,
                                            emitAttr    attr,
                                            int         val,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    size_t          sz;
    instrDesc  *    id               = emitNewInstrAmdCns(attr, disp, val);
    id->idIns                        = ins;
    id->idInsFmt                     = fmt;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(1);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_ARR(instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           emitRegs    reg,
                                           emitRegs    rg2,
                                           int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idIns                        = ins;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idReg                        = ireg;

    if  (ins != INS_lea)
        id->idInfo.idMayFault        = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(1);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_ARR_R (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            int         disp)
{
    size_t          sz;
    instrDesc      *id   = emitNewInstrAmd(attr, disp);

    if  (ireg == SR_NA)
    {
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD,
                                                              IF_TRD_ARD,
                                                              IF_AWR_TRD);

#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr size = EA_SIZE(attr);
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));

        id->idReg                    = ireg;
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(1);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_I_ARX (instruction ins,
                                            emitAttr    attr,
                                            int         val,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            unsigned    mul,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    size_t          sz;
    instrDesc  *    id               = emitNewInstrAmdCns(attr, disp, val);
    id->idInsFmt                     = fmt;
    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_ARX (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            unsigned    mul,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idReg                        = ireg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idIns                        = ins;

    if  (ins != INS_lea)
        id->idInfo.idMayFault = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_ARX_R (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            unsigned    mul,
                                            int         disp)
{
    size_t          sz;
    instrDesc      *id   = emitNewInstrAmd(attr, disp);


    if  (ireg == SR_NA)
    {
        id->idInsFmt = emitInsModeFormat(ins, IF_ARD,
                                              IF_TRD_ARD,
                                              IF_AWR_TRD);
#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr size = EA_SIZE(attr);
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

        id->idReg    = ireg;
        id->idInsFmt = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_I_AX (instruction ins,
                                           emitAttr    attr,
                                           int         val,
                                           emitRegs    reg,
                                           unsigned    mul,
                                           int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    size_t          sz;
    instrDesc  *    id               = emitNewInstrAmdCns(attr, disp, val);
    id->idIns                        = ins;
    id->idInsFmt                     = fmt;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_AX  (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            unsigned    mul,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idReg                        = ireg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idIns                        = ins;

    if  (ins != INS_lea)
        id->idInfo.idMayFault = true;

    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_AX_R  (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            unsigned    mul,
                                            int         disp)
{
    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    if  (ireg == SR_NA)
    {
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD,
                                                              IF_TRD_ARD,
                                                              IF_AWR_TRD);

#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr size = EA_SIZE(attr);
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

        id->idReg                    = ireg;
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  The following add instructions referencing stack-based local variables.
 */

void                emitter::emitIns_S     (instruction ins,
                                            emitAttr    attr,
                                            int         varx,
                                            int         offs)
{
    instrDesc      *id               = emitNewInstr(attr);
    size_t          sz               = emitInsSizeSV(insCodeMR(ins), varx, offs);

    /* 16-bit operand instructions will need a prefix */

    if (EA_SIZE(attr) == EA_2BYTE)
        sz += 1;

    id->idIns                        = ins;
    id->idAddr.iiaLclVar.setVarNum(varx);
    id->idAddr.iiaLclVar.lvaOffset   = offs;
    assert(id->idAddr.iiaLclVar.lvaOffset == offs);
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

#if SCHEDULER
    if (emitComp->opts.compSchedCode)
    {
        if (Compiler::instIsFP(ins))
            scInsNonSched(id);
    }
#endif

    id->idInsFmt   = emitInsModeFormat(ins, IF_SRD,
                                            IF_TRD_SRD,
                                            IF_SWR_TRD);
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_S_R  (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           int         varx,
                                           int         offs)
{
    instrDesc      *id               = emitNewInstr(attr);
    size_t          sz               = emitInsSizeSV(insCodeMR(ins), varx, offs);

    /* 16-bit operand instructions will need a prefix */

    if (EA_SIZE(attr) == EA_2BYTE)
        sz++;

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.setVarNum(varx);
    id->idAddr.iiaLclVar.lvaOffset   = offs;
    assert(id->idAddr.iiaLclVar.lvaOffset == offs);
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_SRD_RRD);

    id->idCodeSize                   = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_S  (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           int         varx,
                                           int         offs)
{
    emitAttr   size = EA_SIZE(attr);
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    instrDesc      *id               = emitNewInstr(attr);
    size_t          sz               = emitInsSizeSV(insCodeRM(ins), varx, offs);

    /* Most 16-bit operand instructions need a prefix */

    if (size == EA_2BYTE && ins != INS_movsx
                         && ins != INS_movzx)
        sz++;

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.setVarNum(varx);
    id->idAddr.iiaLclVar.lvaOffset   = offs;
    assert(id->idAddr.iiaLclVar.lvaOffset == offs);
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_SRD);

    id->idCodeSize                   = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_S_I  (instruction ins,
                                           emitAttr    attr,
                                           int         varx,
                                           int         offs,
                                           long        val)
{
    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt                        = IF_SRW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt                        = emitInsModeFormat(ins, IF_SRD_CNS);
        break;
    }

    instrDesc  *    id             = emitNewInstrCns(attr, val);
    id->idIns                      = ins;
    size_t          sz             = emitInsSizeSV(id, varx, offs, val);
    id->idAddr.iiaLclVar.setVarNum(varx);
    id->idAddr.iiaLclVar.lvaOffset = offs;
    assert(id->idAddr.iiaLclVar.lvaOffset == offs);   // watch for overflow
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs = emitVarRefOffs;
#endif
    id->idInsFmt                   = fmt;
    id->idCodeSize                 = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add a jmp instruction.
 */

void                emitter::emitIns_J(instruction ins,
                                       bool        except,
                                       bool        moveable,
                                       BasicBlock *dst)
{
    size_t          sz;
    instrDescJmp  * id        = emitNewInstrJmp();

    assert(dst->bbFlags & BBF_JMP_TARGET);

    id->idIns                 = ins;
    id->idInsFmt              = IF_LABEL;
    id->idAddr.iiaBBlabel     = dst;

#if SCHEDULER
    if  (except)
        id->idInfo.idMayFault = true;
#endif

    /* Assume the jump will be long */

    id->idjShort              = 0;

    /* Record the jump's IG and offset within it */

    id->idjIG                 = emitCurIG;
    id->idjOffs               = emitCurIGsize;

    /* Append this jump to this IG's jump list */

    id->idjNext               = emitCurIGjmpList;
                                emitCurIGjmpList = id;

#if EMITTER_STATS
    emitTotalIGjmps++;
#endif

    /* Figure out the max. size of the jump/call instruction */

    if  (ins == INS_call)
    {
        sz = CALL_INST_SIZE;
    }
    else if (ins == INS_push || ins == INS_push_hide)
    {
#if RELOC_SUPPORT
        // Pushing the address of a basicBlock will need a reloc
        // as the instruction uses the absolute address,
        // not a relative address
        if (emitComp->opts.compReloc)
            id->idInfo.idDspReloc        = 1;
#endif
        sz = PUSH_INST_SIZE;

    }
    else
    {
        insGroup    *   tgt;

        /* This is a jump - assume the worst */

        sz = (ins == JMP_INSTRUCTION) ? JMP_SIZE_LARGE
                                      : JCC_SIZE_LARGE;

        /* Can we guess at the jump distance? */

        tgt = (insGroup*)emitCodeGetCookie(dst);

        if  (tgt)
        {
            int             extra;
            size_t          srcOffs;
            int             jmpDist;

            assert(JMP_SIZE_SMALL == JCC_SIZE_SMALL);

            /* This is a backward jump - figure out the distance */

            srcOffs = emitCurCodeOffset + emitCurIGsize + JMP_SIZE_SMALL;

            /* Compute the distance estimate */

            jmpDist = srcOffs - tgt->igOffs; assert((int)jmpDist > 0);

            /* How much beyond the max. short distance does the jump go? */

            extra = jmpDist + JMP_DIST_SMALL_MAX_NEG;

#ifdef  DEBUG
            if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[0] Jump %u:\n",               id->idNum);
#if SCHEDULER
                printf("[0] Jump is %s schedulable\n", moveable ? "   " : "not");
#endif
                printf("[0] Jump source is at %08X\n", srcOffs);
                printf("[0] Label block is at %08X\n", tgt->igOffs);
                printf("[0] Jump  distance  - %04X\n", jmpDist);
                if  (extra > 0)
                printf("[0] Distance excess = %d  \n", extra);
            }
#endif

            if  (extra <= 0)
            {
                /* Wonderful - this jump surely will be short */

                id->idjShort = 1;
                sz           = JMP_SIZE_SMALL;
            }
        }
#ifdef  DEBUG
        else
        {
            if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[0] Jump %u:\n",               id->idNum);
#if SCHEDULER
                printf("[0] Jump is %s schedulable\n", moveable ? "   " : "not");
#endif
                printf("[0] Jump source is at %04X/%08X\n", emitCurIGsize, emitCurCodeOffset + emitCurIGsize + JMP_SIZE_SMALL);
                printf("[0] Label block is uknown \n");
            }
        }
#endif
    }

    id->idCodeSize = sz;

    dispIns(id);

#if SCHEDULER

    if (emitComp->opts.compSchedCode)
    {
        id->idjSched = moveable;

        if  (moveable)
        {
            /*
                This jump is moveable (can be scheduled), and so we'll need
                to figure out the range of offsets it may be moved to after
                it's scheduled (otherwise we wouldn't be able to correctly
                estimate the jump distance).
             */

            id->idjTemp.idjOffs[0] = emitCurIGscdOfs;
            id->idjTemp.idjOffs[1] = emitCurIGscdOfs - 1;
        }
        else
        {
            scInsNonSched(id);
        }
    }
    else
    {
        id->idjSched = false;
    }

#endif

    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
}


/*****************************************************************************
 *
 *  Add a call instruction (direct or indirect).
 *      argSize<0 means that the caller will pop the arguments
 *
 * The other arguments are interpreted depending on callType as shown:
 * Unless otherwise specified, ireg,xreg,xmul,disp should have default values.
 *
 * EC_FUNC_TOKEN       : callVal is the method token.
 * EC_FUNC_TOKEN_INDIR : callVal is the method token (may end up being treated
 *                       as EC_FUNC_TOKEN if the method gets JITcompiled by
 *                       another thread)
 * EC_FUNC_ADDR        : callVal is the absolute address of the function
 *
 * EC_FUNC_VIRTUAL     : callVal is the method token. "call [ireg+disp]"
 *
 * If callType is one of these 4 emitCallTypes, callVal has to be NULL.
 * EC_INDIR_R          : "call ireg".
 * EC_INDIR_SR         : "call lcl<disp>" (eg. call [ebp-8]).
 * EC_INDIR_C          : "call clsVar<disp>" (eg. call [clsVarAddr])
 * EC_INDIR_ARD        : "call [ireg+xreg*xmul+disp]"
 *
 */

void                emitter::emitIns_Call(EmitCallType  callType,
                                          void       *  callVal,
                                          int           argSize,
                                          int           retSize,
                                          VARSET_TP     ptrVars,
                                          unsigned      gcrefRegs,
                                          unsigned      byrefRegs,
                                          emitRegs      ireg    /* = SR_NA */,
                                          emitRegs      xreg    /* = SR_NA */,
                                          unsigned      xmul    /* = 0     */,
                                          int           disp    /* = 0     */,
                                          bool          isJump  /* = false */)
{
    /* Sanity check the arguments depending on callType */

    assert(callType < EC_COUNT);
    assert(callType != EC_FUNC_TOKEN || callType != EC_FUNC_TOKEN_INDIR ||
           callType != EC_FUNC_ADDR ||
           (ireg == SR_NA && xreg == SR_NA && xmul == 0 && disp == 0));
    assert(callType != EC_FUNC_VIRTUAL ||
           (ireg < SR_COUNT && xreg == SR_NA && xmul == 0));
    assert(callType < EC_INDIR_R || callVal == NULL);
    assert(callType != EC_INDIR_R ||
           (ireg < SR_COUNT && xreg == SR_NA && xmul == 0 && disp == 0));
    assert(callType != EC_INDIR_SR ||
           (ireg == SR_NA && xreg == SR_NA && xmul == 0 &&
            disp < (int)emitComp->lvaCount));
    assert(callType != EC_INDIR_C); // @TODO [REVISIT] [04/16/01] []: NYI : Calls via static class vars

    int             argCnt;

    size_t          sz;
    instrDesc      *id;

    /* This is the saved set of registers after a normal call */
    unsigned savedSet = RBM_CALLEE_SAVED;

    /* some special helper calls have a different saved set registers */

    if (callType == EC_FUNC_TOKEN || callType == EC_FUNC_TOKEN_INDIR)
    {
        CorInfoHelpFunc helperNum = Compiler::eeGetHelperNum((CORINFO_METHOD_HANDLE) callVal);

        if ((helperNum != CORINFO_HELP_UNDEF) && emitNoGChelper(helperNum))
        {
            /* This call will preserve the liveness of the full register set */

            savedSet = RBM_ALL;
        }
    }

    /* Trim out any calle trashed registers from the live set */

    gcrefRegs &= savedSet;
    byrefRegs &= savedSet;

#ifndef OPT_IL_JIT
#ifdef  DEBUG
    if  (verbose) printf("Call : GCvars=%016I64X , gcrefRegs=%04X , byrefRegs=%04X\n",
                                 ptrVars,          gcrefRegs,       byrefRegs);
#endif
#endif

    assert(  argSize % (int)sizeof(void*) == 0);
    argCnt = argSize / (int)sizeof(void*);

    /*
        We need to allocate the appropriate instruction descriptor based
        on whether this is a direct/indirect call, and whether we need to
        record an updated set of live GC variables.

        The stats for a ton of classes is as follows:

            Direct call w/o  GC vars        220,216
            Indir. call w/o  GC vars        144,781

            Direct call with GC vars          9,440
            Indir. call with GC vars          5,768
     */

    if  (callType >= EC_FUNC_VIRTUAL)
    {
        /* Indirect call, virtual calls */

        assert(callType == EC_FUNC_VIRTUAL || callType == EC_INDIR_R ||
               callType == EC_INDIR_SR     || callType == EC_INDIR_C ||
               callType == EC_INDIR_ARD);

        id  = emitNewInstrCallInd(argCnt, disp, ptrVars, byrefRegs, retSize);
    }
    else
    {
        /* Helper/static/nonvirtual/function calls (direct or through handle),
           and calls to an absolute addr. */

        assert(callType == EC_FUNC_TOKEN || callType == EC_FUNC_TOKEN_INDIR ||
               callType == EC_FUNC_ADDR);

        id  = emitNewInstrCallDir(argCnt,       ptrVars, byrefRegs, retSize);
    }

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched(id);
#endif

    /* Update the emitter's live GC ref sets */

    emitThisGCrefVars = ptrVars;
    emitThisGCrefRegs = gcrefRegs;
    emitThisByrefRegs = byrefRegs;

    /* Set the instruction - special case jumping a function */

    if (isJump)
    {
        assert(callType == EC_FUNC_TOKEN || callType == EC_FUNC_TOKEN_INDIR);
        id->idIns = (callType == EC_FUNC_TOKEN) ? INS_l_jmp : INS_i_jmp;
    }
    else
    {
        id->idIns = INS_call;
    }

    /* Save the live GC registers in the unused 'idReg/idRg2' fields */

    emitEncodeCallGCregs(emitThisGCrefRegs, id);

    /* Record the address: method, indirection, or funcptr */

    if  (callType >= EC_FUNC_VIRTUAL)
    {
        /* This is an indirect call (either a virtual call or func ptr call) */

        id->idInfo.idMayFault = true;

#ifdef  DEBUG
        id->idMemCookie = 0;
#endif

        switch(callType)
        {
        case EC_INDIR_R:            // the address is in a register

            id->idInfo.idCallRegPtr         = true;

            // Fall-through

        case EC_INDIR_ARD:          // the address is an indirection

            goto CALL_ADDR_MODE;

        case EC_INDIR_SR:           // the address is in a lcl var

            id->idInsFmt                    = IF_SRD;

            id->idAddr.iiaLclVar.lvaVarNum  = disp;
            id->idAddr.iiaLclVar.lvaOffset  = 0;
#ifdef DEBUG
            id->idAddr.iiaLclVar.lvaRefOfs  = 0;
#endif
            sz = emitInsSizeSV(insCodeMR(INS_call), disp, 0);

            break;

        case EC_FUNC_VIRTUAL:

#ifdef  DEBUG
            id->idMemCookie = (int) callVal;    // method token
            id->idClsCookie = 0;
#endif
            // fall-through

        CALL_ADDR_MODE:

            /* The function is "ireg" if id->idInfo.idCallRegPtr,
               else [ireg+xmul*xreg+disp] */

            id->idInsFmt                     = IF_ARD;

            id->idAddr.iiaAddrMode.amBaseReg = ireg;

            id->idAddr.iiaAddrMode.amIndxReg = xreg;
            id->idAddr.iiaAddrMode.amScale   = xmul ? emitEncodeScale(xmul) : 0;

            sz = emitInsSizeAM(id, insCodeMR(INS_call));
            break;

        default:
            NO_WAY_RETVOID("unexpected instruction");
            break;
        }

    }
    else if (callType == EC_FUNC_TOKEN_INDIR)
    {
        /* "call [method_addr]" */

        id->idInsFmt                     = IF_METHPTR;
        id->idAddr.iiaMethHnd            = (CORINFO_METHOD_HANDLE) callVal;
        sz                               = 6;

#if RELOC_SUPPORT
        if (emitComp->opts.compReloc)
        {
            // Since this is an indirect call through a pointer and we don't
            // currently pass in emitAttr into this function we have decided
            // to always mark the displacement as being relocatable.

            id->idInfo.idDspReloc        = 1;
        }
#endif

    }
    else
    {
        /* This is a simple direct call: "call helper/method/addr" */

        assert(callType == EC_FUNC_TOKEN || callType == EC_FUNC_ADDR);

        id->idInsFmt                     = IF_METHOD;
        sz                               = 5;

        if (callType == EC_FUNC_ADDR)
        {
            id->idInfo.idCallAddr        = true;
            id->idAddr.iiaAddr           = (BYTE*)callVal;

#if RELOC_SUPPORT
            if (emitComp->opts.compReloc)
            {
                // Since this is an indirect call through a pointer and we don't
                // currently pass in emitAttr into this function we have decided
                // to always mark the displacement as being relocatable.

                id->idInfo.idDspReloc    = 1;
            }
#endif
        }
        else    /* This is a direct call or a helper call */
        {
            assert(callType == EC_FUNC_TOKEN);
            id->idAddr.iiaMethHnd        = (CORINFO_METHOD_HANDLE) callVal;
        }
    }

#ifdef  DEBUG
    if  (verbose&&0)
    {
        if  (id->idInfo.idLargeCall)
        {
            if  (callType >= EC_FUNC_VIRTUAL)
                printf("[%02u] Rec call GC vars = %016I64X\n", id->idNum, ((instrDescCIGCA*)id)->idciGCvars);
            else
                printf("[%02u] Rec call GC vars = %016I64X\n", id->idNum, ((instrDescCDGCA*)id)->idcdGCvars);
        }
    }
#endif

    id->idCodeSize = sz;

    dispIns(id);

    emitCurIGsize   += sz;

    /* The call will pop the arguments */

    if  (emitCntStackDepth && argSize > 0)
    {
        emitCurStackLvl -= argSize; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  Return the allocated size (in bytes) of the given instruction descriptor.
 */

inline
size_t              emitter::emitSizeOfInsDsc(instrDescAmd    *id)
{
    assert(emitIsTinyInsDsc(id) == false);

    return  id->idInfo.idLargeDsp ? sizeof(instrDescAmd)
                                  : sizeof(instrDesc   );
}

inline
size_t              emitter::emitSizeOfInsDsc(instrDescAmdCns *id)
{
    assert(emitIsTinyInsDsc(id) == false);

    if      (id->idInfo.idLargeCns)
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescAmdCns)
                                      : sizeof(instrDescCns   );
    }
    else
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescAmd   )
                                      : sizeof(instrDesc      );
    }
}

size_t              emitter::emitSizeOfInsDsc(instrDesc *id)
{
    if  (emitIsTinyInsDsc(id))
        return  TINY_IDSC_SIZE;

    if  (emitIsScnsInsDsc(id))
    {
        return  id->idInfo.idLargeCns ? sizeof(instrBaseCns)
                                      : SCNS_IDSC_SIZE;
    }

    assert((unsigned)id->idInsFmt < emitFmtCount);

    BYTE idOp = emitFmtToOps[id->idInsFmt];

    // An INS_call instruction may use a "fat" direct/indirect call descriptor
    // except for a local call to a label (i.e. call to a finally)
    // Only ID_OP_CALL and ID_OP_SPEC check for this, so we enforce that the
    //  INS_call instruction always uses one of these idOps

    assert(id->idIns != INS_call ||
           idOp == ID_OP_CALL    ||     // direct calls
           idOp == ID_OP_SPEC    ||     // indirect calls
           idOp == ID_OP_JMP       );   // local calls to finally clause

    switch (idOp)
    {
    case ID_OP_NONE:
        break;

    case ID_OP_JMP:
        return  sizeof(instrDescJmp);

    case ID_OP_CNS:
        return  emitSizeOfInsDsc((instrDescCns   *)id);

    case ID_OP_DSP:
        return  emitSizeOfInsDsc((instrDescDsp   *)id);

    case ID_OP_DC:
        return  emitSizeOfInsDsc((instrDescDspCns*)id);

    case ID_OP_AMD:
        return  emitSizeOfInsDsc((instrDescAmd   *)id);

    case ID_OP_AC:
        return  emitSizeOfInsDsc((instrDescAmdCns*)id);

    case ID_OP_CALL:

        if  (id->idInfo.idLargeCall)
        {
            /* Must be a "fat" direct call descriptor */

            return  sizeof(instrDescCDGCA);
        }

        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);
        break;

    case ID_OP_SPEC:

        switch (id->idIns)
        {
        case INS_i_jmp:
            return  emitSizeOfInsDsc((instrDescAmd*)id);

        case INS_call:

            if  (id->idInfo.idLargeCall)
            {
                /* Must be a "fat" indirect call descriptor */

                return  sizeof(instrDescCIGCA);
            }

            assert(id->idInfo.idLargeDsp == false);
            assert(id->idInfo.idLargeCns == false);
            return  sizeof(instrDesc);
        }

        switch (id->idInsFmt)
        {
        case IF_ARD:
        case IF_SRD:
        case IF_MRD:
            return  emitSizeOfInsDsc((instrDescDspCns*)id);

        case IF_MRD_CNS:
        case IF_MWR_CNS:
        case IF_MRW_CNS:
        case IF_MRW_SHF:
            return  sizeof(instrDescDCM);

        case IF_EPILOG:
            return  sizeof(instrDescCns);
        }

        assert(!"unexpected 'special' format");

    default:
        assert(!"unexpected instruction descriptor format");
    }

    return  sizeof(instrDesc);
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Return a string that represents the given register.
 */

const   char *      emitter::emitRegName(emitRegs reg, emitAttr attr, bool varName)
{
    static char     rb[2][128];
    static char     rbc = 0;

    assert(reg < SR_COUNT);

    // @TODO [CONSIDER] [04/16/01] []: Make the following work just using a code offset

    const   char *  rn = emitComp->compRegVarName((regNumber)reg, varName);

    assert(strlen(rn) >= 3);

    switch (EA_SIZE(attr))
    {
    case EA_4BYTE:
        break;

    case EA_2BYTE:
        rn++;
        break;

    case EA_1BYTE:
        rbc = (rbc+1)%2;
        rb[rbc][0] = rn[1];
        rb[rbc][1] = 'L';
        strcpy(&rb[rbc][2], rn+3);

        rn = rb[rbc];
        break;
    }

    return  rn;
}

/*****************************************************************************
 *
 *  Return a string that represents the given FP register.
 */

const   char *      emitter::emitFPregName(unsigned reg, bool varName)
{
    assert(reg < SR_COUNT);

    // @TODO [CONSIDER] [04/16/01] []: Make the following work just using a code offset

    return emitComp->compFPregVarName((regNumber)(reg), varName);
}

/*****************************************************************************
 *
 *  Display a static data member reference.
 */

void                emitter::emitDispClsVar(CORINFO_FIELD_HANDLE fldHnd, int offs, bool reloc /* = false */)
{
    int doffs;

    /* Filter out the special case of fs:[offs] */

    if (fldHnd == FLD_GLOBAL_FS)
    {
        printf("FS:[0x%04X]", offs);
        return;
    }

    if (fldHnd == FLD_GLOBAL_DS)
    {
        printf("[0x%04X]", offs);
        return;
    }

    printf("[");

    doffs = Compiler::eeGetJitDataOffs(fldHnd);

#ifdef RELOC_SUPPORT
    if (reloc)
        printf("reloc ");
#endif

    if (doffs >= 0)
    {
        if  (doffs & 1)
            printf("@CNS%02u", doffs-1);
        else
            printf("@RWD%02u", doffs);

        if  (offs)
            printf("%+d", offs);
    }
    else
    {
        printf("classVar[%#x]", fldHnd);

        if  (offs)
            printf("%+d", offs);
    }

    printf("]");

    if  (varNames && offs < 0)
    {
        printf("'%s", emitComp->eeGetFieldName(fldHnd));
        if (offs) printf("%+d", offs);
        printf("'");
    }
}

/*****************************************************************************
 *
 *  Display a stack frame reference.
 */

void                emitter::emitDispFrameRef(int varx, int offs, int disp, bool asmfm)
{
    int         addr;
    bool        bEBP;

    printf("[");

    if  (!asmfm || !emitComp->lvaDoneFrameLayout)
    {
        if  (varx < 0)
            printf("T_%03u", -varx);
        else
            printf("L_%03u", +varx);

        if      (disp < 0)
                printf("-0x%X", -disp);
        else if (disp > 0)
                printf("+0x%X", +disp);
    }

    if  (emitComp->lvaDoneFrameLayout > 1)
    {
        if  (!asmfm)
            printf(" ");

        addr = emitComp->lvaFrameAddress(varx, &bEBP) + disp;

        if  (bEBP)
        {
            printf("EBP");

            if      (addr < 0)
                printf("-%02XH", -addr);
            else if (addr > 0)
                printf("+%02XH",  addr);
        }
        else
        {
            /* Adjust the offset by amount currently pushed on the stack */

            printf("ESP");

            if      (addr < 0)
                printf("-%02XH", -addr);
            else if (addr > 0)
                printf("+%02XH",  addr);

            if  (emitCurStackLvl)
                printf("+%02XH", emitCurStackLvl);
        }
    }

    printf("]");

    if  (varx >= 0 && varNames)
    {
        Compiler::LclVarDsc*varDsc;
        const   char *      varName;

        assert((unsigned)varx < emitComp->lvaCount);
        varDsc  = emitComp->lvaTable + varx;
        varName = emitComp->compLocalVarName(varx, offs);

        if  (varName)
        {
            printf("'%s", varName);

            if      (disp < 0)
                    printf("-%d", -disp);
            else if (disp > 0)
                    printf("+%d", +disp);

            printf("'");
        }
    }
}

/*****************************************************************************
 *
 *  Display an address mode.
 */

void                emitter::emitDispAddrMode(instrDesc *id, bool noDetail)
{
    bool            nsep = false;
    int             disp;

    unsigned        jtno = 0;
    dataSection *   jdsc = 0;

    /* The displacement field is in an unusual place for calls */

    disp = (id->idIns == INS_call) ? emitGetInsCIdisp(id)
                                   : emitGetInsAmdAny(id);

    /* Display a jump table label if this is a switch table jump */

    if  (id->idIns == INS_i_jmp)
    {
        int             offs = 0;

        /* Find the appropriate entry in the data section list */

        for (jdsc = emitConsDsc.dsdList, jtno = 0;
             jdsc;
             jdsc = jdsc->dsNext)
        {
            size_t          size = jdsc->dsSize;

            /* Is this a label table? */

            if  (size & 1)
            {
                size--;
                jtno++;

                if  (offs == id->idMemCookie)
                    break;
            }

            offs += size;
        }

        /* If we've found a matching entry then is a table jump */

        if  (jdsc)
        {
#ifdef RELOC_SUPPORT
            if (id->idInfo.idDspReloc)
            {
                printf("reloc ");
            }
#endif
            printf("J_M%03u_DS%02u", Compiler::s_compMethodsCount, jtno);
        }

        disp -= id->idMemCookie;
    }

    bool frameRef = false;

    printf("[");

    if  (id->idAddr.iiaAddrMode.amBaseReg != SR_NA)
    {
        printf("%s", emitRegName((emitRegs)id->idAddr.iiaAddrMode.amBaseReg));
        nsep = true;
        if (id->idAddr.iiaAddrMode.amBaseReg == SR_ESP)
            frameRef = true;
        else if (emitComp->genFPused && id->idAddr.iiaAddrMode.amBaseReg == SR_EBP)
            frameRef = true;
    }

    if  (id->idAddr.iiaAddrMode.amIndxReg != SR_NA)
    {
        size_t          scale = emitDecodeScale(id->idAddr.iiaAddrMode.amScale);

        if  (nsep)
            printf("+");
        if  (scale > 1)
            printf("%u*", scale);
        printf("%s", emitRegName((emitRegs)id->idAddr.iiaAddrMode.amIndxReg));
        nsep = true;
    }

#ifdef RELOC_SUPPORT
    if ((id->idInfo.idDspReloc) && (id->idIns != INS_i_jmp))
    {
        if  (nsep)
            printf("+");
        printf("(reloc 0x%x)", disp);
    }
    else
#endif
    {
        if (disp < 0)
        {
            if (frameRef)
                printf("-%02XH", -disp);
            else if (disp > -1000)
                printf("-%d", -disp);
            else if (disp >= -0xFFFF)
                printf("-%04XH", -disp);
            else
                printf("-%08XH", -disp);
        }
        else if (disp > 0)
        {
            if  (nsep)
                printf("+");
            if (frameRef)
                printf("%02XH", disp);
            else if (disp < 1000)
                printf("%d", disp);
            else if (disp <= 0xFFFF)
                printf("%04XH", disp);
            else
                printf("%08XH", disp);
        }
        else if (!nsep)
        {
            printf("%04XH", disp);
        }
    }

    printf("]");

    if  (id->idClsCookie)
    {
        if  (id->idIns == INS_call)
            printf("%s", emitFncName((CORINFO_METHOD_HANDLE) id->idMemCookie));
        else
            printf("%s", emitFldName(id->idMemCookie, id->idClsCookie));
    }
           // pretty print string if it looks like one
    else if (id->idGCrefGet() == GCT_GCREF && id->idIns == INS_mov && 
             id->idAddr.iiaAddrMode.amBaseReg == SR_NA) {
        const wchar_t* str = emitComp->eeGetCPString(disp);
        if (str != 0)
            printf("      '%S'", str);
    }

    if  (jdsc && !noDetail)
    {
        unsigned        cnt = (jdsc->dsSize - 1) / sizeof(void*);
        BasicBlock  * * bbp = (BasicBlock**)jdsc->dsCont;

        printf("\n\n    J_M%03u_DS%02u LABEL   DWORD", Compiler::s_compMethodsCount, jtno);

        /* Display the label table (it's stored as "BasicBlock*" values) */

        do
        {
            insGroup    *   lab;

            /* Convert the BasicBlock* value to an IG address */

            lab = (insGroup*)emitCodeGetCookie(*bbp++); assert(lab);

            printf("\n            DD      G_M%03u_IG%02u", Compiler::s_compMethodsCount, lab->igNum);
        }
        while (--cnt);
    }
}

/*****************************************************************************
 *
 *  If the given instruction is a shift, display the 2nd operand.
 */

void                emitter::emitDispShift(instruction ins, int cnt)
{
    switch (ins)
    {
    case INS_rcl_1:
    case INS_rcr_1:
    case INS_shl_1:
    case INS_shr_1:
    case INS_sar_1:
        printf(", 1");
        break;

    case INS_rcl:
    case INS_rcr:
    case INS_shl:
    case INS_shr:
    case INS_sar:
        printf(", CL");
        break;

    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        printf(", %d", cnt);
        break;
    }
}

/*****************************************************************************
 *
 *  Display the epilog instructions.
 */

void                emitter::emitDispEpilog(instrDesc *id, unsigned offs = 0)
{
    BYTE    *       sp = emitEpilogCode;
    BYTE    *       ep = sp + emitEpilogSize;

    assert(id->idInsFmt == IF_EPILOG);
    assert(emitHaveEpilog);

    printf("__epilog:\n");
    while (sp < ep)
    {
        unsigned        op1 = *(unsigned char*)sp;
        unsigned        op2 =  (unsigned short)MISALIGNED_RD_I2(sp);

        if (dspEmit || verbose)
            printf("        ");

        if  (offs)
            printf("%06X", offs + (sp - emitEpilogCode));
        else
            printf("      ");

        sp++;

        if      (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_EBX)))
        {
            printf("      pop     EBX\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_ECX)))
        {
            printf("      pop     ECX\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_ESI)))
        {
            printf("      pop     ESI\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_EDI)))
        {
            printf("      pop     EDI\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_EBP)))
        {
            printf("      pop     EBP\n");
        }
        else if (op1 == (insCodeMI     (INS_ret)))
        {
            printf("      ret     %u\n", *castto(sp, unsigned short*)++);
        }
        else if (op1 == (insCode       (INS_leave)))
        {
            printf("      leave\n");
        }
        else if (op1 == 0x64)           // FS segment override prefix
        {
            printf("      mov     FS:[0], ECX\n");
            op2 = *sp++; assert(op2 == 0x89);
            op2 = *sp++; assert(op2 == 0x0d);
            op2 = *sp++; assert(op2 == 0x00);
            op2 = *sp++; assert(op2 == 0x00);
            op2 = *sp++; assert(op2 == 0x00);
            op2 = *sp++; assert(op2 == 0x00);
        }
        else if (op2 == (insEncodeMIreg(INS_add, SR_ESP) | 1 | 2))
        {
            sp++;
            printf("      add     ESP, %d\n", *castto(sp, signed char*)++);
        }
        else if (op2 == (insEncodeMIreg(INS_add, SR_ESP) | 1))
        {
            sp++;
            printf("      add     ESP, %d\n", *castto(sp, int*)++);
        }
        else if (op2 == (insEncodeRMreg(INS_mov) | 1 /* w=1 */
                                     /* R/M */   | insEncodeReg345(SR_ESP) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 0 << 14))
        {
            sp++;
            printf("      mov     ESP, EBP\n");
        }
        else if (op2 == (insCodeRM     (INS_lea) | 0 /* w=0 */
                                     /* R/M */   | insEncodeReg345(SR_ESP) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 1 << 14))
        {
            sp++;
            int offset = *castto(sp, signed char*)++;
            printf("      lea     ESP, [EBP%s%d]\n",
                   (offset >= 0) ? "+" : "", offset);
        }
        else if (op2 == (insCodeRM     (INS_lea) | 0 /* w=0 */
                                     /* R/M */   | insEncodeReg345(SR_ESP) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 2 << 14))
        {
            sp++;
            int offset = *castto(sp, int*)++;
            printf("      lea     ESP, [EBP%s%d]\n",
                   (offset >= 0) ? "+" : "", offset);
        }
        else if (op2 == (insCodeRM     (INS_mov) | 1 /* w=1 */
                                     /* R/M */   | insEncodeReg345(SR_ECX) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 1 << 14))
        {
            sp++;
            int offset = *castto(sp, signed char*)++;
            printf("      mov     ECX, [EBP%S%d]\n",
                   (offset >= 0) ? "+" : "", offset);
        }
        else
        {
            printf("OOPS: Unrecognized epilog opcode: %02X/%04X\n", op1, op2);
            return;
        }
    }

    assert(sp == ep);
}

/*****************************************************************************
 *
 *  Display the given instruction.
 */

void                emitter::emitDispIns(instrDesc *id, bool isNew,
                                                        bool doffs,
                                                        bool asmfm, unsigned offs)
{
    emitAttr        attr;
    const   char *  sstr;

    instruction     ins = id->idInsGet();

    if (verbose)
        printf("IN%04d: ", id->idNum);

#ifdef RELOC_SUPPORT
# define ID_INFO_DSP_RELOC ((bool) (id->idInfo.idDspReloc))
#else
# define ID_INFO_DSP_RELOC false
#endif
    /* Display a constant value if the instruction references one */

    if  (!isNew)
    {
        switch (id->idInsFmt)
        {
#ifndef OPT_IL_JIT
            int             offs;
#endif

        case IF_MRD_RRD:
        case IF_MWR_RRD:
        case IF_MRW_RRD:

        case IF_RRD_MRD:
        case IF_RWR_MRD:
        case IF_RRW_MRD:

        case IF_MRD_CNS:
        case IF_MWR_CNS:
        case IF_MRW_CNS:
        case IF_MRW_SHF:

        case IF_MRD:
        case IF_MWR:
        case IF_MRW:

        case IF_TRD_MRD:
        case IF_TWR_MRD:
        case IF_TRW_MRD:

//      case IF_MRD_TRD:
        case IF_MWR_TRD:
//      case IF_MRW_TRD:

        case IF_MRD_OFF:

#ifndef OPT_IL_JIT

            /* Is this actually a reference to a data section? */

            offs = Compiler::eeGetJitDataOffs(id->idAddr.iiaFieldHnd);

            if  (offs >= 0)
            {
                void    *   addr;

                /* Display a data section reference */

                if  (offs & 1)
                {
                    offs--;
                    assert((unsigned)offs < emitConsDsc.dsdOffs);
                    addr = emitConsBlock ? emitConsBlock + offs : NULL;
                }
                else
                {
                    assert((unsigned)offs < emitDataDsc.dsdOffs);
                    addr = emitDataBlock ? emitDataBlock + offs : NULL;
                }

#if 0
                /* Is the operand an integer or floating-point value? */

                bool isFP = false;

                if  (Compiler::instIsFP(id->idInsGet()))
                {
                    switch (id->idIns)
                    {
                    case INS_fild:
                    case INS_fildl:
                        break;

                    default:
                        isFP = true;
                        break;
                    }
                }

                if (offs & 1)
                    printf("@CNS%02u", offs);
                else
                    printf("@RWD%02u", offs);

                printf("      ");

                if  (addr)
                {
                    addr = 0;
                    // UNDONE:  This was busted by switching the order
                    //          in which we output the code block vs.
                    //          the data blocks -- when we get here,
                    //          the data block has not been filled in
                    //          yet, so we'll display garbage.

                    if  (isFP)
                    {
                        if  (emitDecodeSize(id->idOpSize) == EA_4BYTE)
                            printf("DF      %f \n", addr ? *(float   *)addr : 0);
                        else
                            printf("DQ      %lf\n", addr ? *(double  *)addr : 0);
                    }
                    else
                    {
                        if  (emitDecodeSize(id->idOpSize) <= EA_4BYTE)
                            printf("DD      %d \n", addr ? *(int     *)addr : 0);
                        else
                            printf("DQ      %D \n", addr ? *(__int64 *)addr : 0);
                    }
                }
#endif
            }
#endif
            break;
        }
    }

//  printf("[F=%s] "   , emitIfName(id->idInsFmt));
//  printf("INS#%03u: ", id->idNum);
//  printf("[S=%02u] " , emitCurStackLvl); if (isNew) printf("[M=%02u] ", emitMaxStackDepth);
//  printf("[S=%02u] " , emitCurStackLvl/sizeof(int));
//  printf("[A=%08X] " , emitSimpleStkMask);
//  printf("[A=%08X] " , emitSimpleByrefStkMask);
//  printf("[L=%02u] " , id->idCodeSize);

    if  (!dspEmit && !isNew && !asmfm)
        doffs = true;

    /* Special case: epilog "instruction" */

    if  (id->idInsFmt == IF_EPILOG && emitHaveEpilog)
    {
        emitDispEpilog(id, doffs ? offs : 0);
        return;
    }

    /* Display the instruction offset */

    emitDispInsOffs(offs, doffs);

    /* Display the instruction name */

    sstr = (id->idInsFmt == IF_EPILOG) ? "__epilog"
                                       : emitComp->genInsName(ins);

    printf("      %-8s", sstr);

    /* By now the size better be set to something */

    assert(emitInstCodeSz(id) || emitInstHasNoCode(ins));

    /* If this instruction has just been added, check its size */

    assert(isNew == false || (int)emitSizeOfInsDsc(id) == emitCurIGfreeNext - (BYTE*)id);

    /* Figure out the operand size */

    if       (id->idGCrefGet() == GCT_GCREF)
    {
        attr = EA_GCREF;
        sstr = "gword ptr ";
    }
    else if  (id->idGCrefGet() == GCT_BYREF)
    {
        attr = EA_BYREF;
        sstr = "bword ptr ";
    }
    else
    {
        attr = emitDecodeSize(id->idOpSize);
        sstr = emitComp->genSizeStr(attr);

        if (ins == INS_lea) {
            assert(attr == EA_4BYTE);
            sstr = "";
        }
    }

    /* Now see what instruction format we've got */

    switch (id->idInsFmt)
    {
        int             val;
        int             offs;
        CnsVal          cnsVal;

        const char  *   methodName;
        const char  *    className;

    case IF_CNS:
        val = emitGetInsSC(id);
#ifdef RELOC_SUPPORT
        if (id->idInfo.idCnsReloc)
            printf("reloc 0x%x", val);
        else
#endif
//      if  (id->idStrLit)
//          printf("offset _S_%08X", val);
//      else
        {
            if ((val > -1000) && (val < 1000))
                printf("%d", val);
            else if (val > 0)
                printf("0x%x", val);
            else // (val < 0)
                printf("-0x%x", -val);
        }
        break;

    case IF_ARD:
    case IF_AWR:
    case IF_ARW:

    case IF_TRD_ARD:
    case IF_TWR_ARD:
    case IF_TRW_ARD:

//  case IF_ARD_TRD:
    case IF_AWR_TRD:
//  case IF_ARW_TRD:

        if  (ins == INS_call && id->idInfo.idCallRegPtr)
        {
            printf("%s", emitRegName((emitRegs)id->idAddr.iiaAddrMode.amBaseReg));
            break;
        }

        printf("%s", sstr);
        emitDispAddrMode(id, isNew);

        if  (ins == INS_call)
        {
            assert(id->idInsFmt == IF_ARD);

            /* Ignore indirect calls */

            if  (id->idMemCookie == 0)
                break;

            assert(id->idMemCookie);

            /* This is a virtual call */

            methodName = emitComp->eeGetMethodName((CORINFO_METHOD_HANDLE)id->idMemCookie, &className);

            printf("%s.%s", className, methodName);
        }
        break;

    case IF_RRD_ARD:
    case IF_RWR_ARD:
    case IF_RRW_ARD:
        if  (ins == INS_movsx || ins == INS_movzx)
        {
            printf("%s, %s", emitRegName((emitRegs)id->idReg, EA_4BYTE), sstr);
        }
        else
        {
            printf("%s, %s", emitRegName((emitRegs)id->idReg, attr), sstr);
        }
        emitDispAddrMode(id);
        break;

    case IF_ARD_RRD:
    case IF_AWR_RRD:
    case IF_ARW_RRD:

        printf("%s", sstr);
        emitDispAddrMode(id);
        printf(", %s", emitRegName(id->idRegGet(), attr));
        break;

    case IF_ARD_CNS:
    case IF_AWR_CNS:
    case IF_ARW_CNS:
    case IF_ARW_SHF:

        printf("%s", sstr);
        emitDispAddrMode(id);
        emitGetInsAmdCns(id, &cnsVal);
        val = cnsVal.cnsVal;
        if  (id->idInsFmt == IF_ARW_SHF)
            emitDispShift(ins, val);
        else
        {
#ifdef RELOC_SUPPORT
            if (cnsVal.cnsReloc)
                printf(", reloc 0x%x", val);
            else
#endif
            if ((val > -1000) && (val < 1000))
                printf(", %d", val);
            else if (val > 0)
                printf(", 0x%x", val);
            else // val <= -1000
                printf(", -0x%x", -val);
        }
        break;

    case IF_SRD:
    case IF_SWR:
    case IF_SRW:

    case IF_TRD_SRD:
    case IF_TWR_SRD:
    case IF_TRW_SRD:

//  case IF_SRD_TRD:
    case IF_SWR_TRD:
//  case IF_SRW_TRD:

        printf("%s", sstr);

        if  (ins == INS_pop) emitCurStackLvl -= sizeof(int);

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);

        if  (ins == INS_pop) emitCurStackLvl += sizeof(int);

        emitDispShift(ins);
        break;

    case IF_SRD_RRD:
    case IF_SWR_RRD:
    case IF_SRW_RRD:

        printf("%s", sstr);

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);

        printf(", %s", emitRegName(id->idRegGet(), attr));
        break;

    case IF_SRD_CNS:
    case IF_SWR_CNS:
    case IF_SRW_CNS:
    case IF_SRW_SHF:

        printf("%s", sstr);

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                         id->idAddr.iiaLclVar.lvaRefOfs,
                         id->idAddr.iiaLclVar.lvaOffset, asmfm);

        emitGetInsCns(id, &cnsVal);
        val = cnsVal.cnsVal;
#ifdef RELOC_SUPPORT
        if (cnsVal.cnsReloc)
            printf(", reloc 0x%x", val);
        else
#endif
        if  (id->idInsFmt == IF_SRW_SHF)
            emitDispShift(ins, val);
        else if ((val > -1000) && (val < 1000))
            printf(", %d", val);
        else if (val > 0)
            printf(", 0x%x", val);
        else // val <= -1000
            printf(", -0x%x", -val);
        break;

    case IF_RRD_SRD:
    case IF_RWR_SRD:
    case IF_RRW_SRD:

        if  (ins == INS_movsx || ins == INS_movzx)
        {
            printf("%s, %s", emitRegName(id->idRegGet(), EA_4BYTE), sstr);
        }
        else
        {
            printf("%s, %s", emitRegName(id->idRegGet(), attr), sstr);
        }

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);

        break;

    case IF_RRD_RRD:
    case IF_RWR_RRD:
    case IF_RRW_RRD:

        if  (ins == INS_movsx || ins == INS_movzx)
        {
            printf("%s, %s", emitRegName(id->idRegGet(),  EA_4BYTE),
                             emitRegName(id->idRg2Get(),  attr));
        }
        else
        {
            printf("%s, %s", emitRegName(id->idRegGet(),  attr),
                             emitRegName(id->idRg2Get(),  attr));
        }
        break;

    case IF_RRW_RRW:
        assert(ins == INS_xchg);
        printf("%s,", emitRegName(id->idRegGet(), attr));
        printf(" %s", emitRegName(id->idRg2Get(), attr));
        break;

    case IF_RRW_RRW_CNS:
        printf("%s,", emitRegName(id->idRegGet(), attr));
        printf(" %s", emitRegName(id->idRg2Get(), attr));
        val = emitGetInsSC(id);
#ifdef RELOC_SUPPORT
        if (id->idInfo.idCnsReloc)
            printf(", reloc 0x%x", val);
        else
#endif
        if ((val > -1000) && (val < 1000))
            printf(", %d", val);
        else if (val > 0)
            printf(", 0x%x", val);
        else // val <= -1000
            printf(", -0x%x", -val);
        break;

    case IF_RRD:
    case IF_RWR:
    case IF_RRW:
        printf("%s", emitRegName(id->idRegGet(), attr));
        emitDispShift(ins);
        break;

    case IF_RRW_SHF:
        printf("%s", emitRegName(id->idRegGet()));
        emitDispShift(ins, emitGetInsSC(id));
        break;

    case IF_RRD_MRD:
    case IF_RWR_MRD:
    case IF_RRW_MRD:

        if (ins == INS_movsx || ins == INS_movzx)
            attr = EA_4BYTE;
        printf("%s, %s", emitRegName(id->idRegGet(), attr), sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        break;

    case IF_RWR_MRD_OFF:

        printf("%s, %s", emitRegName(id->idRegGet(), attr), "offset");
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        break;

    case IF_MRD_RRD:
    case IF_MWR_RRD:
    case IF_MRW_RRD:

        printf("%s", sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        printf(", %s", emitRegName(id->idRegGet(), attr));
        break;

    case IF_MRD_CNS:
    case IF_MWR_CNS:
    case IF_MRW_CNS:
    case IF_MRW_SHF:

        printf("%s", sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        emitGetInsDcmCns(id, &cnsVal);
        val = cnsVal.cnsVal;
#ifdef RELOC_SUPPORT
        if (cnsVal.cnsReloc)
            printf(", reloc 0x%x", val);
        else
#endif
        if  (id->idInsFmt == IF_MRW_SHF)
            emitDispShift(ins, val);
        else if ((val > -1000) && (val < 1000))
            printf(", %d", val);
        else if (val > 0)
            printf(", 0x%x", val);
        else // val <= -1000
            printf(", -0x%x", -val);
        break;

    case IF_MRD:
    case IF_MWR:
    case IF_MRW:

    case IF_TRD_MRD:
    case IF_TWR_MRD:
    case IF_TRW_MRD:

//  case IF_MRD_TRD:
    case IF_MWR_TRD:
//  case IF_MRW_TRD:

        printf("%s", sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        emitDispShift(ins);
        break;

    case IF_MRD_OFF:

        printf("offset ");
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        break;

    case IF_RRD_CNS:
    case IF_RWR_CNS:
    case IF_RRW_CNS:
        printf("%s, ", emitRegName((emitRegs)id->idReg, attr));
        val = emitGetInsSC(id);
#ifdef RELOC_SUPPORT
        if (id->idInfo.idCnsReloc)
            printf("reloc 0x%x", val);
        else
#endif
        if ((val > -1000) && (val < 1000))
            printf("%d", val);
        else if (val > 0)
            printf("0x%x", val);
        else // val <= -1000
            printf("-0x%x", -val);
        break;

    case IF_TRD_FRD:
    case IF_TWR_FRD:
    case IF_TRW_FRD:
        switch (ins)
        {
        case INS_fld:
        case INS_fxch:
            break;

        default:
            printf("%s, ", emitFPregName(0));
            break;
        }
        printf("%s", emitFPregName(id->idReg));
        break;

    case IF_FRD_TRD:
    case IF_FWR_TRD:
    case IF_FRW_TRD:
        printf("%s", emitFPregName(id->idReg));
        if  (ins != INS_fst && ins != INS_fstp)
            printf(", %s", emitFPregName(0));
        break;

    case IF_LABEL:

        if  (((instrDescJmp*)id)->idjShort)
            printf("SHORT ");

        if  (id->idInfo.idBound)
        {
            printf("G_M%03u_IG%02u", Compiler::s_compMethodsCount, id->idAddr.iiaIGlabel->igNum);
        }
        else
        {
            printf("L_M%03u_BB%02u", Compiler::s_compMethodsCount, id->idAddr.iiaBBlabel->bbNum);
        }
        break;

    case IF_RWR_METHOD:
        if (id->idIns == INS_mov)
            printf("%s, ", emitRegName((emitRegs)id->idReg, attr));

        // Fall through ...

    case IF_METHOD:
    case IF_METHPTR:
        if (id->idInfo.idCallAddr)
        {
            offs = (int)id->idAddr.iiaAddr;
            methodName = "";
            className = 0;
        }
        else
        {
            offs = 0;
            methodName = emitComp->eeGetMethodName(id->idAddr.iiaMethHnd, &className);
        }

        if  (id->idInsFmt == IF_METHPTR) printf("[");

        if (offs)
        {
            if (id->idInfo.idDspReloc)
                printf("reloc ");
            printf("%08X", offs);
        }
        else
        {
            if  (className == NULL)
                printf("%s", methodName);
            else
                printf("%s.%s", className, methodName);
        }

        if  (id->idInsFmt == IF_METHPTR) printf("]");
        break;

    case IF_TRD:
    case IF_TWR:
    case IF_TRW:
    case IF_NONE:
    case IF_EPILOG:
        break;

    default:
        printf("unexpected format %s", emitIfName(id->idInsFmt));
        assert(!"unexpectedFormat");
        break;
    }
    printf("\n");
}

/*****************************************************************************/
#endif
/*****************************************************************************
 *
 *  Output an instruction involving an address mode.
 */

BYTE    *  emitter::emitOutputAM  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal*  addc)
{
    emitRegs        reg;
    emitRegs        rgx;
    int             dsp;
    bool            dspInByte;
    bool            dspIsZero;

    instruction     ins  = id->idInsGet();
    emitAttr        size = emitDecodeSize(id->idOpSize);
    size_t          opsz = EA_SIZE_IN_BYTES(size);

    /* Get the base/index registers */

    reg = (emitRegs)id->idAddr.iiaAddrMode.amBaseReg;
    rgx = (emitRegs)id->idAddr.iiaAddrMode.amIndxReg;

    /* For INS_call the instruction size is actually the return value size */

    if  (ins == INS_call)
    {
        /* Special case: call via a register */

        if  (id->idInfo.idCallRegPtr)
        {
            dst += emitOutputWord(dst, insEncodeMRreg(INS_call, reg));
            goto DONE;
        }

        /* The displacement field is in an unusual place for calls */

        dsp = emitGetInsCIdisp(id);
        goto GOT_DSP;
    }

    /* Is there a large constant operand? */

    if  (addc && (size > EA_1BYTE))
    {
        long cval = addc->cnsVal;

        /* Does the constant fit in a byte? */
        if  ((signed char)cval == cval &&
#ifdef RELOC_SUPPORT
             addc->cnsReloc == false   &&
#endif
             ins != INS_mov      &&
             ins != INS_test)
        {
            if  (id->idInsFmt != IF_ARW_SHF)
                code |= 2;

            opsz = 1;
        }
    }

    /* Is this a 'big' opcode? */

    if  (code & 0x00FF0000)
    {
        /* Output the highest byte of the opcode */

        dst += emitOutputByte(dst, code >> 16); code &= 0x0000FFFF;

        /* Use the large version if this is not a byte */

        if ((size != EA_1BYTE) && (ins != INS_imul))
            code++;
    }
    else if (Compiler::instIsFP(ins))
    {
        assert(size == EA_4BYTE   ||
               size == EA_8BYTE   ||
               ins  == INS_fldcw  ||
               ins  == INS_fnstcw);

        if  (size == EA_8BYTE)
            code += 4;
    }
    else
    {
        /* Is the operand size larger than a byte? */

        switch (size)
        {
        case EA_1BYTE:
            break;

        case EA_2BYTE:

            /* Output a size prefix for a 16-bit operand */

            dst += emitOutputByte(dst, 0x66);

            // Fall through ...

        case EA_4BYTE:

            /* Set the 'w' bit to get the large version */

            code |= 0x1;
            break;

        case EA_8BYTE:

            /* Double operand - set the appropriate bit */

            code |= 0x04;
            break;

        default:
            assert(!"unexpected size");
        }
    }

    /* Get the displacement value */

    dsp = emitGetInsAmdAny(id);

GOT_DSP:

    dspInByte = ((signed char)dsp == (int)dsp);
    dspIsZero = (dsp == 0);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idDspReloc)
    {
        dspInByte = false;      // relocs can't be placed in a byte
    }
#endif

    /* Is there a [scaled] index component? */

    if  (rgx == SR_NA)
    {
        /* The address is of the form "[reg+disp]" */

        switch (reg)
        {
        case SR_NA:

            /* The address is of the form "[disp]" */

            dst += emitOutputWord(dst, code | 0x0500);
            dst += emitOutputLong(dst, dsp);

#ifdef RELOC_SUPPORT
            if (id->idInfo.idDspReloc)
            {
                emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            }
#endif
            break;

        case SR_EBP:

            /* Does the offset fit in a byte? */

            if  (dspInByte)
            {
                dst += emitOutputWord(dst, code | 0x4500);
                dst += emitOutputByte(dst, dsp);
            }
            else
            {
                dst += emitOutputWord(dst, code | 0x8500);
                dst += emitOutputLong(dst, dsp);

#ifdef RELOC_SUPPORT
                if (id->idInfo.idDspReloc)
                {
                    emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                }
#endif
            }

            break;

        case SR_ESP:
#ifndef OPT_IL_JIT
            //
            // This assert isn't too helpful from the OptJit point of view
            //
            // a better question is why is it here at all
            //
            assert((ins == INS_lea)  ||
                   (ins == INS_mov)  ||
                   (ins == INS_test) ||
                   (ins == INS_fld   && dspIsZero) ||
                   (ins == INS_fstp  && dspIsZero) ||
                   (ins == INS_fistp && dspIsZero));
#endif

            /* Is the offset 0 or does it at least fit in a byte? */

            if  (dspIsZero)
            {
                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, 0x24);
            }
            else if     (dspInByte)
            {
                dst += emitOutputWord(dst, code | 0x4400);
                dst += emitOutputByte(dst, 0x24);
                dst += emitOutputByte(dst, dsp);
            }
            else
            {
                dst += emitOutputWord(dst, code | 0x8400);
                dst += emitOutputByte(dst, 0x24);
                dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                if (id->idInfo.idDspReloc)
                {
                    emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                }
#endif
            }

            break;

        default:

            /* Put the register in the opcode */

            code |= insEncodeReg012(reg) << 8;

            /* Is there a displacement? */

            if  (dspIsZero)
            {
                /* This is simply "[reg]" */

                dst += emitOutputWord(dst, code);
            }
            else
            {
                /* This is [reg + dsp]" -- does the offset fit in a byte? */

                if  (dspInByte)
                {
                    dst += emitOutputWord(dst, code | 0x4000);
                    dst += emitOutputByte(dst, dsp);
                }
                else
                {
                    dst += emitOutputWord(dst, code | 0x8000);
                    dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                    if (id->idInfo.idDspReloc)
                    {
                        emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                    }
#endif
                }
            }

            break;
        }
    }
    else
    {
        unsigned    regByte;

        /* We have a scaled index operand */

        size_t      mul = emitDecodeScale(id->idAddr.iiaAddrMode.amScale);

        /* Is the index operand scaled? */

        if  (mul > 1)
        {
            /* Is there a base register? */

            if  (reg != SR_NA)
            {
                /* The address is "[reg + {2/4/8} * rgx + icon]" */

                regByte = insEncodeReg012(reg) |
                          insEncodeReg345(rgx) | insSSval(mul);

                /* Emit [ebp + {2/4/8} * rgz] as [ebp + {2/4/8} * rgx + 0] */

                if  (dspIsZero && reg != SR_EBP)
                {
                    /* The address is "[reg + {2/4/8} * rgx]" */

                    dst += emitOutputWord(dst, code | 0x0400);
                    dst += emitOutputByte(dst, regByte);
                }
                else
                {
                    /* The address is "[reg + {2/4/8} * rgx + disp]" */

                    if  (dspInByte)
                    {
                        dst += emitOutputWord(dst, code | 0x4400);
                        dst += emitOutputByte(dst, regByte);
                        dst += emitOutputByte(dst, dsp);
                    }
                    else
                    {
                        dst += emitOutputWord(dst, code | 0x8400);
                        dst += emitOutputByte(dst, regByte);
                        dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                        if (id->idInfo.idDspReloc)
                        {
                            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                        }
#endif
                    }
                }
            }
            else
            {
                /* The address is "[{2/4/8} * rgx + icon]" */

                regByte = insEncodeReg012(SR_EBP) |
                          insEncodeReg345( rgx  ) | insSSval(mul);

                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, regByte);

                /* Special case: jump through a jump table */
                if  (ins == INS_i_jmp)
                    dsp += (int)emitConsBlock;

                dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                if (id->idInfo.idDspReloc)
                {
                    emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                }
#endif
            }
        }
        else
        {
            /* The address is "[reg+rgx+dsp]" */

            regByte = insEncodeReg012(reg) |
                      insEncodeReg345(rgx);

            if  (dspIsZero && reg != SR_EBP)
            {
                /* This is [reg+rgx]" */

                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, regByte);
            }
            else
            {
                /* This is [reg+rgx+dsp]" -- does the offset fit in a byte? */

                if  (dspInByte)
                {
                    dst += emitOutputWord(dst, code | 0x4400);
                    dst += emitOutputByte(dst, regByte);
                    dst += emitOutputByte(dst, dsp);
                }
                else
                {
                    dst += emitOutputWord(dst, code | 0x8400);
                    dst += emitOutputByte(dst, regByte);
                    dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                    if (id->idInfo.idDspReloc)
                    {
                        emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                    }
#endif
                }
            }
        }
    }

    /* Now generate the constant value, if present */

    if  (addc)
    {
        long cval = addc->cnsVal;
        switch (opsz)
        {
        case 0:
        case 4:
        case 8: dst += emitOutputLong(dst, cval); break;
        case 2: dst += emitOutputWord(dst, cval); break;
        case 1: dst += emitOutputByte(dst, cval); break;

        default:
            assert(!"unexpected operand size");
        }

#ifdef RELOC_SUPPORT
        if (addc->cnsReloc)
        {
            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            assert(opsz == 4);
        }
#endif
    }

DONE:

    /* Does this instruction operate on a GC ref value? */

    if  (id->idGCref)
    {
        switch (id->idInsFmt)
        {
        case IF_ARD:
        case IF_AWR:
        case IF_ARW:
            break;

        case IF_RRD_ARD:
            break;

        case IF_RWR_ARD:
            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
            break;

        case IF_RRW_ARD:
            assert(id->idGCrefGet() == GCT_BYREF);

#ifdef DEBUG
            regMaskTP regMask;
            regMask = emitRegMask(id->idRegGet());

            // r1 could have been a GCREF as GCREF + int=BYREF
            //                            or BYREF+/-int=BYREF
            assert(((regMask & emitThisGCrefRegs) && (ins == INS_add                  )) ||
                   ((regMask & emitThisByrefRegs) && (ins == INS_add || ins == INS_sub)));
#endif
            // Mark it as holding a GCT_BYREF
            emitGCregLiveUpd(GCT_BYREF, id->idRegGet(), dst);
            break;

        case IF_ARD_RRD:
        case IF_AWR_RRD:
            break;

        case IF_ARD_CNS:
        case IF_AWR_CNS:
            break;

        case IF_ARW_RRD:
        case IF_ARW_CNS:
            assert(id->idGCrefGet() == GCT_BYREF && (ins == INS_add || ins == INS_sub));
            break;

        default:
#ifdef  DEBUG
            emitDispIns(id, false, false, false);
#endif
            assert(!"unexpected GC ref instruction format");
        }

        // mul can never produce a GC ref

        assert(!instrIs3opImul(ins));
        assert(ins != INS_mulEAX && ins != INS_imulEAX);
    }
    else
    {
        switch (id->idInsFmt)
        {
        case IF_RWR_ARD:
            emitGCregDeadUpd(id->idRegGet(), dst);
            break;
        }

        if (ins == INS_mulEAX || ins == INS_imulEAX)
        {
            emitGCregDeadUpd(SR_EAX, dst);
            emitGCregDeadUpd(SR_EDX, dst);
        }

        // For the three operand imul instruction the target register
        // is encoded in the opcode

        if (instrIs3opImul(ins))
        {
            emitRegs tgtReg = ((emitRegs) Compiler::inst3opImulReg(ins));
            emitGCregDeadUpd(tgtReg, dst);
        }
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Output an instruction involving a stack frame value.
 */

BYTE    *  emitter::emitOutputSV  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal*  addc)
{
    int             adr;
    int             dsp;
    bool            EBPbased;
    bool            dspInByte;
    bool            dspIsZero;

    instruction     ins  = id->idInsGet();
    emitAttr        size = emitDecodeSize(id->idOpSize);
    size_t          opsz = EA_SIZE_IN_BYTES(size);

    assert(ins != INS_imul || id->idReg == SR_EAX || size == EA_4BYTE);

    /* Is there a large constant operand? */

    if  (addc && (size > EA_1BYTE))
    {
        long cval = addc->cnsVal;
        /* Does the constant fit in a byte? */
        if  ((signed char)cval == cval &&
#ifdef RELOC_SUPPORT
             addc->cnsReloc == false   &&
#endif
             ins != INS_mov            &&
             ins != INS_test)
        {
            if  (id->idInsFmt != IF_SRW_SHF)
                code |= 2;

            opsz = 1;
        }
    }

    /* Is this a 'big' opcode? */

    if  (code & 0x00FF0000)
    {
        /* Output the highest byte of the opcode */

        dst += emitOutputByte(dst, code >> 16); code &= 0x0000FFFF;

        /* Use the large version if this is not a byte */

        if ((size != EA_1BYTE) && (ins != INS_imul) && (!insIsCMOV(ins)))
            code |= 0x1;
    }
    else if (Compiler::instIsFP(ins))
    {
        assert(size == EA_4BYTE || size == EA_8BYTE);

        if  (size == EA_8BYTE)
            code += 4;
    }
    else
    {
        /* Is the operand size larger than a byte? */

        switch (size)
        {
        case EA_1BYTE:
            break;

        case EA_2BYTE:

            /* Output a size prefix for a 16-bit operand */

            dst += emitOutputByte(dst, 0x66);

            // Fall through ...

        case EA_4BYTE:

            /* Set the 'w' size bit to indicate 32-bit operation
             * Note that incrementing "code" for INS_call (0xFF) would
             * overflow, whereas setting the lower bit to 1 just works out */

            code |= 0x01;
            break;

        case EA_8BYTE:

            /* Double operand - set the appropriate bit */

            code |= 0x04;
            break;

        default:
            assert(!"unexpected size");
        }
    }

    /* Figure out the variable's frame position */

    int varNum = id->idAddr.iiaLclVar.lvaVarNum;

    adr = emitComp->lvaFrameAddress(varNum, &EBPbased);
    dsp = adr + id->idAddr.iiaLclVar.lvaOffset;

    dspInByte = ((signed char)dsp == (int)dsp);
    dspIsZero = (dsp == 0);

#ifdef RELOC_SUPPORT
    /* for stack varaibles the dsp should never be a reloc */
    assert(id->idInfo.idDspReloc == 0);
#endif

    if  (EBPbased)
    {
        /* EBP-based variable: does the offset fit in a byte? */

        if  (dspInByte)
        {
            dst += emitOutputWord(dst, code | 0x4500);
            dst += emitOutputByte(dst, dsp);
        }
        else
        {
            dst += emitOutputWord(dst, code | 0x8500);
            dst += emitOutputLong(dst, dsp);
        }
    }
    else
    {
        /* Adjust the offset by the amount currently pushed on the CPU stack */

        dsp += emitCurStackLvl;

        dspInByte = ((signed char)dsp == (int)dsp);
        dspIsZero = (dsp == 0);

        /* Does the offset fit in a byte? */

        if (dspInByte)
        {
            if  (dspIsZero)
            {
                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, 0x24);
            }
            else
            {
                dst += emitOutputWord(dst, code | 0x4400);
                dst += emitOutputByte(dst, 0x24);
                dst += emitOutputByte(dst, dsp);
            }
        }
        else
        {
            dst += emitOutputWord(dst, code | 0x8400);
            dst += emitOutputByte(dst, 0x24);
            dst += emitOutputLong(dst, dsp);
        }
    }

    /* Now generate the constant value, if present */

    if  (addc)
    {
        long cval = addc->cnsVal;
        switch (opsz)
        {
        case 0:
        case 4:
        case 8: dst += emitOutputLong(dst, cval); break;
        case 2: dst += emitOutputWord(dst, cval); break;
        case 1: dst += emitOutputByte(dst, cval); break;

        default:
            assert(!"unexpected operand size");
        }

#ifdef RELOC_SUPPORT
        if (addc->cnsReloc)
        {
            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            assert(opsz == 4);
        }
#endif
    }

    /* Does this instruction operate on a GC ref value? */

    if  (id->idGCref)
    {
        switch (id->idInsFmt)
        {
        case IF_SRD:
            /* Read  stack                    -- no change */
            break;

        case IF_SWR:
            /* Write stack                    -- GC var may be born */
            emitGCvarLiveUpd(adr, varNum, id->idGCrefGet(), dst);
            break;

        case IF_SRD_CNS:
            /* Read  stack                    -- no change */
            break;

        case IF_SWR_CNS:
            /* Write stack                    -- no change */
            break;

        case IF_SRD_RRD:
        case IF_RRD_SRD:
            /* Read  stack   , read  register -- no change */
            break;

        case IF_RWR_SRD:

            /* Read  stack   , write register -- GC reg may be born */

            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
            break;

        case IF_SWR_RRD:
            /* Read  register, write stack    -- GC var may be born */
            emitGCvarLiveUpd(adr, varNum, id->idGCrefGet(), dst);
            break;

        case IF_RRW_SRD:

            // reg could have been a GCRE