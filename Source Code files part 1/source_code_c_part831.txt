/ fetch key and value
                        lResult = RegEnumValue( m_hkeyShort,
                                                dwIndex, 
                                                szName, 
                                                &cchName,
                                                0,
                                                &dwType,
                                                lpbValue, 
                                                &dwSize );

                        if ( lResult == ERROR_SUCCESS ) {
                            // Do not replace if the canonical entry already has a
                            // .Owner value that is "Unknown Owner"
                            if ( lstrcmp( szName, ".Owner" ) == 0 ) {
                                TCHAR szCanonValue[MAX_PATH];
                                DWORD dwType;
                                DWORD lcbCanonValue = MAX_PATH;
                                if ( RegQueryValueEx( hkeyCanon, ".Owner", NULL, &dwType,
                                                      (LPBYTE)szCanonValue, &lcbCanonValue ) == ERROR_SUCCESS &&
                                     lstrcmp( szCanonValue, "Unknown Owner" ) == 0 )
                                    continue;
                            }

                            // Add the value to the canonical version of the key
                            if ( RegSetValueEx( hkeyCanon, szName, NULL, dwType,
                                                lpbValue, dwSize ) != ERROR_SUCCESS )
                                hr = E_FAIL;
                           
                        } else
                            hr = E_FAIL;
                    } // for each value in the non-canoncical key

                    // Now we are finished with the non-canonical key
                    if ( SUCCEEDED(hr) &&
                         RegDeleteKey( hkeyMU, m_szName ) != ERROR_SUCCESS )
                        hr = E_FAIL;
                }
                else // lpbValue.
                {
                    delete [] szName;
                    hr = E_OUTOFMEMORY;
                }
            }
            else  // szName
            {
                hr = E_OUTOFMEMORY;
            }
        } 

        return hr;
    };

    HRESULT MergeSharedDlls( HKEY hkeySD )
    {
        HRESULT hr = E_FAIL;
        DWORD dwShortVal = 0;
        DWORD dwCanonicalVal = 0;
        DWORD dwType;
        DWORD dwSize;
        
        // The value names under shared DLLs are raw paths
        MakeFileSysFriendly( m_szName );
        MakeFileSysFriendly( m_szCanonicalName );

        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx( hkeySD, m_szName, NULL,
                              &dwType, (LPBYTE)&dwShortVal, &dwSize ) == ERROR_SUCCESS &&
              dwType == REG_DWORD ) {
            dwCanonicalVal = 0;
            dwSize = sizeof(DWORD);
            // the canonical form may not be there, so we don't care if this
            // fails.
            RegQueryValueEx( hkeySD, m_szCanonicalName, NULL,
                             &dwType, (LPBYTE)&dwCanonicalVal, &dwSize );
            dwCanonicalVal += dwShortVal;
            dwSize = sizeof(DWORD);
            if ( RegSetValueEx( hkeySD, m_szCanonicalName, NULL, REG_DWORD,
                                (LPBYTE)&dwCanonicalVal, dwSize ) == ERROR_SUCCESS ) {
                RegDeleteValue( hkeySD, m_szName );
            }
        } else {
            dwCanonicalVal = 1;
            dwSize = sizeof(DWORD);
            if ( RegSetValueEx( hkeySD, m_szCanonicalName, NULL, REG_DWORD,
                                (LPBYTE)&dwCanonicalVal, dwSize ) == ERROR_SUCCESS )
                hr = S_OK;
        }

        MakeRegFriendly( m_szName );
        MakeRegFriendly( m_szCanonicalName );

        return hr;
    }

    HRESULT CanonicalizeMU( HKEY hkeyMU, HKEY hkeySD )
    {
        HRESULT hr = E_FAIL; 
        HKEY    hkeyCanon;
        LONG    lResult = RegOpenKeyEx( hkeyMU, m_szCanonicalName, 0, KEY_ALL_ACCESS, &hkeyCanon);
           
            
        if ( lResult != ERROR_SUCCESS )
            lResult = RegCreateKey( hkeyMU, 
                                    m_szCanonicalName, 
                                    &hkeyCanon );

        if ( lResult == ERROR_SUCCESS ) {
            hr = MergeMU( hkeyCanon, hkeyMU );
            if ( SUCCEEDED(hr) )
                hr = MergeSharedDlls( hkeySD );
            RegCloseKey( hkeyCanon );
        } else
            hr = E_FAIL;

        return S_OK;
    };
};

// FAddModuleUsageKeys adds a module usage key to the list.

BOOL FAddModuleUsageKeys( ModuleUsageKeys*&pmuk, // head of ModuleUsageKeys list
                         LPTSTR szName,          // name of key value
                         DWORD  cchName,         // length of szName, minus null terminator
                         HKEY  hkeyMU            // hkey of parent
                        )
{
    BOOL fAdd = FALSE;
    ModuleUsageKeys* pmukNew;
    HKEY hkeySub = NULL;
    LRESULT lr;

    pmukNew = new ModuleUsageKeys;
    if ( pmukNew &&
         (lr = RegOpenKeyEx( hkeyMU, szName, 0, KEY_ALL_ACCESS, &hkeySub)) == ERROR_SUCCESS ) {
 
        fAdd = pmukNew->FSetName( szName, cchName );

        if ( fAdd ) {
            // append to head of the list
            pmukNew->m_hkeyShort = hkeySub;
            pmukNew->m_pmukNext = pmuk;
            pmuk = pmukNew;
        }
    }

    if ( !fAdd ) {
        if ( hkeySub )
            RegCloseKey( hkeySub );
        if ( pmukNew != NULL )
            delete pmukNew;
    }

    return fAdd;
}

EXTERN_C HRESULT
CanonicalizeModuleUsage(void)
{
    HKEY hkeyMU = NULL;
    HKEY hkeySD = NULL;
    HRESULT hr = S_OK;
    LONG lResult;

    // get the main SHAREDDLLS key ready; this is never freed!


    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_SHAREDDLLS,
                        0, KEY_ALL_ACCESS, &hkeySD)) == ERROR_SUCCESS &&
        (lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_MODULE_USAGE,
                        0, KEY_ALL_ACCESS, &hkeyMU)) == ERROR_SUCCESS )
    {
        DWORD          dwIndex = 0;
        ModuleUsageKeys *pmukUpdate = NULL; // records for values we want to update.
        ModuleUsageKeys *pmuk;
        ModuleUsageKeys *pmukNext;
 
        // Examine each value.
        do  {
            TCHAR szName[MAX_PATH];        // Value name
            DWORD cchName = MAX_PATH;
            FILETIME ftT;

            // fetch key and value
            lResult = RegEnumKeyEx( hkeyMU, dwIndex, szName, &cchName,
                                    0, NULL, NULL, &ftT );

             if ( lResult == ERROR_SUCCESS ) {

                if ( !IsCanonicalName( szName ) )
                    if ( !FAddModuleUsageKeys( pmukUpdate, szName, cchName, hkeyMU ) )
                        hr = E_OUTOFMEMORY;
                dwIndex++;
             } else if ( lResult == ERROR_NO_MORE_ITEMS )
                 hr = S_FALSE;
             else
                 hr = E_FAIL;
        } while ( hr == S_OK );

   
        if ( SUCCEEDED(hr) ) {
            hr = S_OK; // don't need S_FALSE any longer
            for ( pmuk = pmukUpdate; pmuk != NULL; pmuk = pmukNext ) {
                HRESULT hr2 = pmuk->CanonicalizeMU( hkeyMU, hkeySD );
                if ( FAILED(hr2) )
                    hr = hr2;
                pmukNext = pmuk->m_pmukNext; 
                delete pmuk;
            } // for 
        } //  if enumeration succeeded
    } // if keys opened

    if (hkeyMU)
        RegCloseKey(hkeyMU);

    if ( hkeySD )
        RegCloseKey( hkeySD );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\utils.h ===
#ifndef __UTILS__
#define __UTILS__

#include <windows.h>
#include <advpub.h>
#include <CleanOC.h>
#include <debug.h>
#include "general.h"

#define LStrNICmp(sz1, sz2, cch) (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)

#define MODULE_UNKNOWN_OWNER   "Unknown Owner"
#define MAX_MESSAGE_LEN        2048

// numeric constants
#define GD_EXTRACTDIR    0
#define GD_CACHEDIR      1
#define GD_CONFLICTDIR   2
#define GD_CONTAINERDIR  3
#define GD_WINDOWSDIR   10
#define GD_SYSTEMDIR    11

#define LENGTH_NAME             200
#define MAX_INF_SECTION_SIZE    1024
#define OLEUI_CCHKEYMAX         256
#define OLEUI_CCHKEYMAX_SIZE    (OLEUI_CCHKEYMAX*sizeof(TCHAR))
#define TIMESTAMP_MAXSIZE       64
#define VERSUBBLOCK_SIZE        256

#define MAX_VERSION_SIZE      16

// string constants
#define INPROCSERVER       TEXT("InprocServer")
#define LOCALSERVER        TEXT("LocalServer")
#define INPROCSERVERX86    TEXT("InProcServerX86")
#define LOCALSERVERX86     TEXT("LocalServerX86")
#define INPROCSERVER32     TEXT("InprocServer32")
#define LOCALSERVER32      TEXT("LocalServer32")
#define INFFILE            TEXT("InfFile")
#define UNKNOWNDATA        TEXT("n/a")
#define UNKNOWNOWNER       TEXT("Unknown Owner")
#define VARTRANSLATION     TEXT("\\VarFileInfo\\Translation")
#define FILEVERSION        TEXT("\\FileVersion")
#define STRINGFILEINFO     TEXT("\\StringFileInfo\\")
#define HKCR_CLSID         TEXT("CLSID")
#define HKCR_TYPELIB       TEXT("TypeLib")
#define HKCR_INTERFACE     TEXT("Interface")
#define VALUE_OWNER        TEXT(".Owner")
#define VALUE_ACTIVEXCACHE TEXT("ActiveXCache")
#define VALUE_PATH         TEXT("PATH")
#define VALUE_SYSTEM       TEXT("SystemComponent")
#define CONTAINER_APP      TEXT("IEXPLORE.EXE")
#define DEMO_PAGE          TEXT("DemoTmp.html")
#define KEY_HOOK           TEXT("Hook")
#define KEY_INFFILE        TEXT("InfFile")
#define KEY_INFSECTION     TEXT("InfSection")
#define KEY_DEFAULTUNINSTALL TEXT("DefaultUninstall")
#define KEY_UNINSTALL      TEXT("UNINSTALL")
#define KEY_SETUPHOOK      TEXT("SETUP HOOKS")
#define INF_EXTENSION      TEXT(".INF")
#define ENV_PATH           TEXT("PATH")
#define KEY_ADDCODE        TEXT("Add.Code")
#define DEFAULT_VALUE      TEXT("")
#define DEFAULT_CACHE      TEXT("\\OCCACHE")
#define DEFAULT_CONFLICT   TEXT("\\CONFLICT")
#define DU_INSTALLER_VALUE TEXT("Installer")
#define CDL_INSTALLER      TEXT("MSICD")

// registry paths for ModuleUsage
#define REGSTR_PATH_SHAREDDLLS     TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls")
#define REGSTR_PATH_MODULE_USAGE   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ModuleUsage")
#define REGSTR_PATH_IE             TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths")
#define REGSTR_PATH_IE_SETTINGS    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
//#define REGSTR_PATH_ACTIVEX_CACHE  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache\\Paths")
#define REGSTR_PATH_ACTIVEX_CACHE  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache")
#define SOFTWARECLASSES            TEXT("SOFTWARE\\CLASSES")

// CLSIDLIST_ITEM declaration
struct tagCLSIDLIST_ITEM;
typedef struct tagCLSIDLIST_ITEM CLSIDLIST_ITEM;
typedef CLSIDLIST_ITEM* LPCLSIDLIST_ITEM;
struct tagCLSIDLIST_ITEM
{
    TCHAR szFile[MAX_PATH];
    TCHAR szCLSID[MAX_DIST_UNIT_NAME_LEN];
    BOOL bIsDistUnit;
    LPCLSIDLIST_ITEM pNext;
};

// function prototypes
// void RemoveObsoleteKeys();
void ReverseSlashes(LPTSTR pszStr);
LPTSTR ReverseStrchr(LPCTSTR szString, TCHAR ch);
HRESULT NullLastSlash(LPTSTR szString, UINT uiOffset); 
LONG DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey);
BOOL FileExist(LPCTSTR lpszFileName);
HRESULT LookUpModuleUsage(
                LPCTSTR lpszFileName, 
                LPCTSTR lpszCLSID,
                LPTSTR lpszOwner = NULL, 
                DWORD dwOwnerSize = 0);
DWORD SubtractModuleOwner( LPCTSTR lpszFileName, LPCTSTR lpszGUID );

HRESULT SetSharedDllsCount(
                LPCTSTR lpszFileName, 
                LONG cRef, 
                LONG *pcRefOld = NULL);
HRESULT GetSizeOfFile(LPCTSTR lpszFile, LPDWORD lpSize);
HRESULT CleanOrphanedRegistry(
                LPCTSTR szFileName, 
                LPCTSTR szClientClsId,
                LPCTSTR szTypeLibCLSID);
HRESULT UnregisterOCX(LPCTSTR pszFile);
HRESULT GetDirectory(
                UINT nDirType, 
                LPTSTR szDirBuffer, 
                int nBufSize, 
                LPCTSTR szOCXFullName = NULL);
/*
HRESULT GetTypeLibId(
                LPCTSTR lpszClientClsId, 
                LPTSTR lpszTypeLibId, 
                LONG* pLibIdSize);
*/
HRESULT CleanInterfaceEntries(LPCTSTR lpszTypeLibCLSID);
HRESULT ConvertToLongFileName(
                LPTSTR lpszShortFileName,
                BOOL bToUpper = FALSE);

void RemoveList(LPCLSIDLIST_ITEM lpListHead);
BOOL ReadInfFileNameFromRegistry(LPCTSTR lpszCLSID, LPTSTR lpszInf, LONG nBufLen);
BOOL WriteInfFileNameToRegistry(LPCTSTR lpszCLSID, LPTSTR lpszInf);

HRESULT FindDLLInModuleUsage(
      LPTSTR lpszFileName,
      LPCTSTR lpszCLSID,
      DWORD &iSubKey);
HRESULT
ExpandCommandLine(
    LPCSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[]);

BOOL PatternMatch(LPCTSTR szModName, LPTSTR szSectionName);

DWORD OCCGetLongPathName( LPTSTR szLong, LPCTSTR szShort, DWORD cchBuffer );

TCHAR *CatPathStrN( TCHAR *szDst, const TCHAR *szHead, const TCHAR *szTail, int cchDst );

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : CoTaskMemAlloc(cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) CoTaskMemFree(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\property.cpp ===
#include "item.h"
#include "parseinf.h"
#include <mstask.h>
#include <iehelpid.h>
#include "parseinf.h"

#include <mluisupp.h>

#ifdef AUTO_UPDATE
#define NUM_PAGES 4
#else
#define NUM_PAGES 3
#endif

#define DEFAULT_LANG_CODEPAGE_PAIR                   0x040904B0
#define MAX_QUERYPREFIX_LEN                          512
#define MAX_QUERYSTRING_LEN                          1024

// defined in utils.cpp
extern LPCTSTR g_lpszUpdateInfo;
extern LPCTSTR g_lpszCookieValue;
extern LPCTSTR g_lpszSavedValue;

///////////////////////////////////////////////////////////////////////////////
// functions that deal with web check

// define a macro to make life easier
#define QUIT_IF_FAIL if (FAILED(hr)) goto Exit

void DestroyDialogIcon(HWND hDlg)
{
    HICON hIcon = (HICON)SendDlgItemMessage(
                                   hDlg, IDC_STATIC_ICON, 
                                   STM_GETICON, 0, 0);
    if (hIcon != NULL)
       DestroyIcon(hIcon);

}

  
///////////////////////////////////////////////////////////////////////////////
// functions that deal with property page 1

void InitPropPage1(HWND hDlg, LPARAM lParam)
{
    BOOL bHasActiveX;
    BOOL bHasJava;

    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)((LPPROPSHEETPAGE)lParam)->lParam;
    if (pcpidl)
    {
        // draw control icon
        {
            HICON hIcon = ExtractIcon(g_hInst, GetStringInfo(pcpidl, SI_LOCATION), 0);
            if (hIcon == NULL)
                hIcon = GetDefaultOCIcon( pcpidl );
            Assert(hIcon != NULL);
            SendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_SETICON, (WPARAM)hIcon, 0);
        }

        SetDlgItemText(hDlg, IDC_STATIC_CONTROL, GetStringInfo(pcpidl, SI_CONTROL));
        SetDlgItemText(hDlg, IDC_STATIC_CREATION, GetStringInfo(pcpidl, SI_CREATION));
        SetDlgItemText(hDlg, IDC_STATIC_LASTACCESS, GetStringInfo(pcpidl, SI_LASTACCESS));
        SetDlgItemText(hDlg, IDC_STATIC_CLSID, GetStringInfo(pcpidl, SI_CLSID));
        SetDlgItemText(hDlg, IDC_STATIC_CODEBASE, GetStringInfo(pcpidl, SI_CODEBASE));

        TCHAR szBuf[MESSAGE_MAXSIZE];


        GetContentBools( pcpidl, &bHasActiveX, &bHasJava );
        if ( bHasJava )
        {
            if ( bHasActiveX )
                MLLoadString(IDS_PROPERTY_TYPE_MIXED, szBuf, MESSAGE_MAXSIZE);
            else
                MLLoadString(IDS_PROPERTY_TYPE_JAVA, szBuf, MESSAGE_MAXSIZE);
        }
        else
            MLLoadString(IDS_PROPERTY_TYPE_ACTX, szBuf, MESSAGE_MAXSIZE);

        SetDlgItemText(hDlg, IDC_STATIC_TYPE, szBuf);

        GetStatus(pcpidl, szBuf, MESSAGE_MAXSIZE);
        SetDlgItemText(hDlg, IDC_STATIC_STATUS, szBuf);

        DWORD dwSizeSaved = GetSizeSaved(pcpidl);
        TCHAR szSize[20];
        wsprintf(szSize, "%u", dwSizeSaved);
    
        // insert commas to separate groups of digits
        int nLen = lstrlen(szSize);
        int i = 0, j = (nLen <= 3 ? nLen : (nLen % 3));
        TCHAR *pCh = szSize + j;

        for (; i < j; i++)
            szBuf[i] = szSize[i];

        for (; *pCh != '\0'; i++, pCh++)
        {
            if (((pCh - szSize) % 3 == j) && (i > 0))
                szBuf[i++] = ',';
            szBuf[i] = *pCh;
        }
        szBuf[i] = '\0';

        TCHAR szBytes[BYTES_MAXSIZE];

        MLLoadString(IDS_PROPERTY_BYTES, szBytes, BYTES_MAXSIZE);
        lstrcat(szBuf, TEXT(" "));
        lstrcat(szBuf, szBytes);
        lstrcat(szBuf, TEXT("  ("));

        GetSizeSaved(pcpidl, szBuf + lstrlen(szBuf));
        lstrcat(szBuf, TEXT(")"));
        SetDlgItemText(hDlg, IDC_STATIC_TOTALSIZE, szBuf);
    }
}

// Dialog proc for page 1
INT_PTR CALLBACK ControlItem_PropPage1Proc(
                                  HWND hDlg, 
                                  UINT message, 
                                  WPARAM wParam, 
                                  LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCONTROLPIDL pcpidl = lpPropSheet ? (LPCONTROLPIDL)lpPropSheet->lParam : NULL;

    const static DWORD aIds[] = {
        IDC_STATIC_LABEL_TYPE, IDH_DLOAD_TYPE,
        IDC_STATIC_LABEL_CREATION, IDH_DLOAD_CREATED,
        IDC_STATIC_LABEL_LASTACCESS, IDH_DLOAD_LASTACC,
        IDC_STATIC_LABEL_TOTALSIZE, IDH_DLOAD_TOTALSIZE,
        IDC_STATIC_LABEL_CLSID, IDH_DLOAD_ID,
        IDC_STATIC_LABEL_STATUS, IDH_DLOAD_STATUS,
        IDC_STATIC_LABEL_CODEBASE, IDH_DLOAD_CODEBASE,
        IDC_STATIC_TYPE, IDH_DLOAD_TYPE,
        IDC_STATIC_CREATION, IDH_DLOAD_CREATED,
        IDC_STATIC_LASTACCESS, IDH_DLOAD_LASTACC,
        IDC_STATIC_TOTALSIZE, IDH_DLOAD_TOTALSIZE,
        IDC_STATIC_CLSID, IDH_DLOAD_ID,
        IDC_STATIC_STATUS, IDH_DLOAD_STATUS,
        IDC_STATIC_CODEBASE, IDH_DLOAD_CODEBASE,
        IDC_STATIC_CONTROL, IDH_DLOAD_OBJNAME,
        0, 0 
    };

    switch(message) 
    {
    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle), "iexplore.hlp", HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND)wParam, "iexplore.hlp", HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aIds);
        break;
    
    case WM_INITDIALOG:
        InitPropPage1(hDlg, lParam);
        break;            
    
    case WM_DESTROY:
        DestroyDialogIcon(hDlg);
        break;

    case WM_COMMAND:
        // user can't change anything, so we don't care about any messages

        break;

    default:
        return FALSE;
        
    } // end of switch
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// functions that deal with property page 2

int ListCtrl_InsertColumn(
                       HWND hwnd,
                       int nCol, 
                       LPCTSTR lpszColumnHeading, 
                       int nFormat,
                           int nWidth, 
                       int nSubItem)
{
        LV_COLUMN column;
        column.mask = LVCF_TEXT|LVCF_FMT;
        column.pszText = (LPTSTR)lpszColumnHeading;
        column.fmt = nFormat;
        if (nWidth != -1)
        {
                column.mask |= LVCF_WIDTH;
                column.cx = nWidth;
        }
        if (nSubItem != -1)
        {
                column.mask |= LVCF_SUBITEM;
                column.iSubItem = nSubItem;
        }

    return (int)::SendMessage(hwnd, LVM_INSERTCOLUMN, nCol, (LPARAM)&column);
}

BOOL ListCtrl_SetItemText(
                     HWND hwnd,
                     int nItem, 
                     int nSubItem, 
                     LPCTSTR lpszItem)
{
        LV_ITEM lvi;
        lvi.mask = LVIF_TEXT;
        lvi.iItem = nItem;
        lvi.iSubItem = nSubItem;
        lvi.stateMask = 0;
        lvi.state = 0;
        lvi.pszText = (LPTSTR) lpszItem;
        lvi.iImage = 0;
        lvi.lParam = 0;
        return (BOOL)::SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&lvi);
}

int ListCtrl_InsertItem(
                     HWND hwnd,
                     UINT nMask, 
                     int nItem, 
                     LPCTSTR lpszItem, 
                     UINT nState, 
                     UINT nStateMask,
                         int nImage, 
                     LPARAM lParam)
{
        LV_ITEM item;
        item.mask = nMask;
        item.iItem = nItem;
        item.iSubItem = 0;
        item.pszText = (LPTSTR)lpszItem;
        item.state = nState;
        item.stateMask = nStateMask;
        item.iImage = nImage;
        item.lParam = lParam;

    return (int)::SendMessage(hwnd, LVM_INSERTITEM, 0, (LPARAM)&item);
}

void InitPropPage2(HWND hDlg, LPARAM lParam)
{
    int                iFileNameWidth = 0;

    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)((LPPROPSHEETPAGE)lParam)->lParam;
    UINT cTotalFiles = GetTotalNumOfFiles(pcpidl);

    {
        HICON hIcon = ExtractIcon(g_hInst, GetStringInfo(pcpidl, SI_LOCATION), 0);
        if (hIcon == NULL)
            hIcon = GetDefaultOCIcon( pcpidl );
        Assert(hIcon != NULL);
        SendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    // insert columns into file list box
    RECT rect;
    int nWidth;
    TCHAR szBuf[MAX_PATH];
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_DEPENDENCYLIST);

    Assert(::IsWindow(hwndCtrl));
    GetClientRect(hwndCtrl, &rect);
    nWidth = rect.right - rect.left;

    MLLoadString(IDS_LISTTITLE_FILENAME, szBuf, MAX_PATH);
    iFileNameWidth = nWidth * 7 / 10;
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      0, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      iFileNameWidth, 0);

    MLLoadString(IDS_LISTTITLE_FILESIZE, szBuf, MAX_PATH);
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      1, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      nWidth * 3 / 10, 
                      0);

    // insert dependent files into list box
    int iIndex = -1;
    LONG lResult = ERROR_SUCCESS;
    DWORD dwFileSize = 0;
    BOOL bOCXRemovable = IsModuleRemovable(GetStringInfo(pcpidl, SI_LOCATION));

        for (UINT iFile = 0; iFile < cTotalFiles; iFile++)
        {
            if (!GetDependentFile(pcpidl, iFile, szBuf, &dwFileSize))
            {
                Assert(FALSE);
                break;
            }

            // put a star after file name if file is not safe for removal
            if (!bOCXRemovable)
            {
                lstrcat(szBuf, TEXT("*"));
            }
            else if (!IsModuleRemovable(szBuf))
            {
                // check if it is inf file.
                TCHAR szExt[10];
                MLLoadString(IDS_EXTENSION_INF, szExt, 10);
                int nLen = lstrlen(szBuf);
                int nLenExt = lstrlen(szExt);
                if ((nLen > nLenExt) && 
                    (lstrcmpi(szBuf+(nLen-nLenExt), szExt) != 0))
                    lstrcat(szBuf, TEXT("*"));
            }            

            PathCompactPath(NULL, szBuf, iFileNameWidth);
            iIndex = ListCtrl_InsertItem(hwndCtrl, LVIF_TEXT, iFile, szBuf, 0, 0, 0, 0);

            if (dwFileSize > 0)
            {
                TCHAR szBuf2[100];
                wsprintf(szBuf2, "%u", dwFileSize);
            
                // insert commas to separate groups of digits
                int nLen = lstrlen(szBuf2);
                int i = 0, j = (nLen <= 3 ? nLen : (nLen % 3));
                TCHAR *pCh = szBuf2 + j;

                for (; i < j; i++)
                    szBuf[i] = szBuf2[i];

                for (; *pCh != '\0'; i++, pCh++)
                {
                    if (((pCh - szBuf2) % 3 == j) && (i > 0))
                        szBuf[i++] = ',';
                    szBuf[i] = *pCh;
                }
                szBuf[i] = '\0';
            }
            else
                MLLoadString(IDS_STATUS_DAMAGED, szBuf, MAX_PATH);

            ListCtrl_SetItemText(hwndCtrl, iIndex, 1, szBuf);
        }

    // insert columns into file list box
    hwndCtrl = GetDlgItem(hDlg, IDC_PACKAGELIST);

    Assert(::IsWindow(hwndCtrl));
    GetClientRect(hwndCtrl, &rect);
    nWidth = (rect.right - rect.left) / 2;

    MLLoadString(IDS_LISTTITLE_PACKAGENAME, szBuf, MAX_PATH);
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      0, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      nWidth, 0);

    MLLoadString(IDS_LISTTITLE_NAMESPACE, szBuf, MAX_PATH);
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      1, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      nWidth, 0);

    // insert dependent packages into list box
    UINT         cTotalPackages = 0;;

    if ( pcpidl->ci.dwIsDistUnit )
    {
        CParseInf    parseInf;

        if ( SUCCEEDED(parseInf.DoParseDU( GetStringInfo( pcpidl, SI_LOCATION), GetStringInfo( pcpidl,SI_CLSID ))) )
        {
            CPackageNode *ppn;

            for ( ppn = parseInf.GetFirstPackage();
                  ppn != NULL;
                  ppn = parseInf.GetNextPackage(), cTotalPackages++ )
            {
                iIndex = ListCtrl_InsertItem(hwndCtrl, LVIF_TEXT, cTotalPackages, ppn->GetName(), 0, 0, 0, 0);
                ListCtrl_SetItemText(hwndCtrl, iIndex, 1, ppn->GetNamespace());
            }
        }
    }

     // update description
    {
        TCHAR szMsg[MESSAGE_MAXSIZE];
        TCHAR szBuf[MESSAGE_MAXSIZE];
        // BUG: This is not the correct way to make va_list for Alpha
        DWORD_PTR adwArgs[3];
        adwArgs[0] =  cTotalFiles;
        adwArgs[1] =  cTotalPackages;
        adwArgs[2] =  (DWORD_PTR) GetStringInfo(pcpidl, SI_CONTROL);
        MLLoadString(IDS_MSG_DEPENDENCY, szBuf, MESSAGE_MAXSIZE);
        FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szBuf, 0, 0, szMsg, MESSAGE_MAXSIZE, (va_list*)adwArgs );
        SetDlgItemText(hDlg, IDC_STATIC_DESCRIPTION, szMsg);
    }
}

// Dialog proc for page 2
INT_PTR CALLBACK ControlItem_PropPage2Proc(
                                  HWND hDlg, 
                                  UINT message, 
                                  WPARAM wParam, 
                                  LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCONTROLPIDL pcpidl = lpPropSheet ? (LPCONTROLPIDL)lpPropSheet->lParam : NULL;

    const static DWORD aIds[] = {
        IDC_DEPENDENCYLIST, IDH_DLOAD_FILE_DEP,
        IDC_PACKAGELIST, IDH_DLOAD_JAVAPKG_DEP,
        0, 0 
    };

    switch(message) 
    {
    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle), "iexplore.hlp", HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND)wParam, "iexplore.hlp", HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aIds);
        break;
    
    case WM_INITDIALOG:
        InitPropPage2(hDlg, lParam);
        break;            
    
    case WM_DESTROY:
        DestroyDialogIcon(hDlg);
        break;

    case WM_COMMAND:
        break;

    default:
        return FALSE;
    } // end of switch
    
    return TRUE;
}

#if 0
// Do UI update
BOOL Page3_OnCommand(HWND hDlg, WORD wCmd)
{
    HWND hwnd = GetDlgItem(hDlg, IDC_CHECK_NEVERUPDATE);
    Assert(hwnd != NULL);

    // if top check box is checked, disable the edit box
    BOOL bEnable = ((int)::SendMessage(hwnd, BM_GETCHECK, 0, 0) != 1);

    hwnd = GetDlgItem(hDlg, IDC_EDIT_UPDATEINTERVAL);
    Assert(hwnd != NULL);

    EnableWindow(hwnd, bEnable);

    // if top check box is not checked and edit box does not
    // have the focus and it is empty, put in default interval
    if (bEnable && (GetFocus() != hwnd))
    {
        TCHAR szText[10];
        if (GetWindowText(hwnd, szText, 10) == 0)
        {
            // wsprintf(szText, "%i", g_dwDefaultInterval);
            SetWindowText(hwnd, szText);
        }
    }

    return TRUE;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// functions that deal with property page 4

void InitPropPage4(HWND hDlg, LPARAM lParam)
{
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)((LPPROPSHEETPAGE)lParam)->lParam;

    LPTSTR lpszFileName = (LPTSTR)GetStringInfo(pcpidl, SI_LOCATION);

    TCHAR szBuf[MESSAGE_MAXSIZE];
    DWORD dwHandle = 0, dwSizeVer = 0;
    LPTSTR lpBuffer = NULL;
    UINT uSize = 0;
    LPVOID lpVerData = NULL;
    UINT uLen = 0;
    DWORD dwLangCodePage = 0;
    char szQueryPrefix[MAX_QUERYPREFIX_LEN];
    char szQueryString[MAX_QUERYSTRING_LEN];
            

    // draw control icon
    {
        LPCTSTR pszIcon = GetStringInfo(pcpidl, SI_LOCATION);
        HICON hIcon = NULL;
        if (!pszIcon || !(hIcon = ExtractIcon(g_hInst, pszIcon, 0)))
        {
            hIcon = GetDefaultOCIcon( pcpidl );
        }
        Assert(hIcon != NULL);
        SendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    // set page header
    if (MLLoadString(IDS_VERSION_PAGE_HEADER, szBuf, MESSAGE_MAXSIZE))
    {
        TCHAR szHeading[MESSAGE_MAXSIZE];
        LPCTSTR pszControl = GetStringInfo(pcpidl, SI_CONTROL);
        if (pszControl)
        {
            wsprintf(szHeading, szBuf, pszControl);
            SetDlgItemText(hDlg, IDC_STATIC_VER_HEADING, szHeading);
        }
    }

    // set Version field
    LPCTSTR pszVersion = GetStringInfo(pcpidl, SI_VERSION);
    if (!pszVersion)
        return;

    SetDlgItemText(hDlg, IDC_STATIC_VER_VERSION, pszVersion);

    if (!lpszFileName)
        return;

    dwSizeVer = GetFileVersionInfoSize(lpszFileName, &dwHandle);
    if (dwSizeVer <= 0)
        return;

    BYTE *pbData = new BYTE[dwSizeVer];
    if (pbData == NULL)
        return;

    if (GetFileVersionInfo(lpszFileName, 0, dwSizeVer, pbData))
    {
        // Get correct codepage information

        if (!VerQueryValue(pbData, "\\VarFileInfo\\Translation", &lpVerData, &uLen))
        {
            wsprintf(szQueryPrefix, "\\StringFileInfo\\%x\\CompanyName", DEFAULT_LANG_CODEPAGE_PAIR);
        }
        else
        {
            char szLangCodePad[9];
            char szVBufPad[5], szVBuf[5];     // To fit a DWORD (padded)
            ASSERT(lpVerData);
            wnsprintf(szVBuf, ARRAYSIZE(szVBuf), "%x", LOWORD(*((DWORD *)lpVerData)));
            
            // Pad the low word to 4 digits

            lstrcpyn(szVBufPad, "0000", ARRAYSIZE(szVBufPad));
            char *pszTmp = szVBufPad + (4 - lstrlen(szVBuf));
            ASSERT(pszTmp > szVBufPad);
            lstrcpy(pszTmp, szVBuf);

            lstrcpyn(szLangCodePad, szVBufPad, ARRAYSIZE(szLangCodePad));

            // Pad the high word to 4 digits

            wnsprintf(szVBuf, ARRAYSIZE(szVBuf), "%x", HIWORD(*((DWORD *)lpVerData)));
            lstrcpy(szVBufPad, "0000");
            pszTmp = szVBufPad + (4 - lstrlen(szVBuf));
            ASSERT(pszTmp > szVBufPad);
            lstrcpy(pszTmp, szVBuf);

            // Concatenate to get a codepage/lang-id string
            lstrcatn(szLangCodePad, szVBufPad, ARRAYSIZE(szLangCodePad));

            lstrcpy(szQueryPrefix, "\\StringFileInfo\\");
            lstrcat(szQueryPrefix, szLangCodePad);
        }

        // set Company field
        wnsprintf(szQueryString, ARRAYSIZE(szQueryString), "%s\\CompanyName", szQueryPrefix);
        if (VerQueryValue(pbData, szQueryString, (void **)&lpBuffer, &uSize))
            SetDlgItemText(hDlg, IDC_STATIC_VER_COMPANY, lpBuffer);
        
        // set Description field
        wnsprintf(szQueryString, ARRAYSIZE(szQueryString), "%s\\FileDescription", szQueryPrefix);
        if (VerQueryValue(pbData, szQueryString, (void **)&lpBuffer, &uSize))
            SetDlgItemText(hDlg, IDC_STATIC_VER_DESCRIPTION, lpBuffer);

        // set CopyRight field
        wnsprintf(szQueryString, ARRAYSIZE(szQueryString), "%s\\LegalCopyright", szQueryPrefix);
        if (VerQueryValue(pbData, szQueryString, (void **)&lpBuffer, &uSize))
            SetDlgItemText(hDlg, IDC_STATIC_VER_COPYRIGHT, lpBuffer);

        // set Language field
        if (VerQueryValue(pbData, TEXT("\\VarFileInfo\\Translation"), (void **)&lpBuffer, &uSize))
        {
            LPWORD lpLangId = (LPWORD)lpBuffer;
            VerLanguageName(*lpLangId, szBuf, MESSAGE_MAXSIZE);
            SetDlgItemText(hDlg, IDC_STATIC_VER_LANGUAGE, szBuf);
        }
    }

    delete [] pbData;
}

// Dialog proc for page 4
INT_PTR CALLBACK ControlItem_PropPage4Proc(
                                  HWND hDlg, 
                                  UINT message, 
                                  WPARAM wParam, 
                                  LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCONTROLPIDL pcpidl = lpPropSheet ? (LPCONTROLPIDL)lpPropSheet->lParam : NULL;

    const static DWORD aIds[] = {
        IDC_STATIC_VER_LABEL_VERSION, IDH_DLOAD_VERSION,
        IDC_STATIC_VER_LABEL_DESCRIPTION, IDH_DLOAD_DESC,
        IDC_STATIC_VER_LABEL_COMPANY, IDH_DLOAD_COMPANY,
        IDC_STATIC_VER_LABEL_LANGUAGE, IDH_DLOAD_LANG,
        IDC_STATIC_VER_LABEL_COPYRIGHT, IDH_DLOAD_COPYRIGHT,
        IDC_STATIC_VER_VERSION, IDH_DLOAD_VERSION,
        IDC_STATIC_VER_DESCRIPTION, IDH_DLOAD_DESC,
        IDC_STATIC_VER_COMPANY, IDH_DLOAD_COMPANY,
        IDC_STATIC_VER_LANGUAGE, IDH_DLOAD_LANG,
        IDC_STATIC_VER_COPYRIGHT, IDH_DLOAD_COPYRIGHT,
        IDC_STATIC_CONTROL, IDH_DLOAD_OBJNAME,
        0, 0 
    };

    switch(message) 
    {
        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle), "iexplore.hlp", HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, "iexplore.hlp", HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aIds);
            break;
        
        case WM_INITDIALOG:
            InitPropPage4(hDlg, lParam);
            break;            
        
        case WM_DESTROY:
            DestroyDialogIcon(hDlg);
            break;

        case WM_COMMAND:
            // user can't change anything, so we don't care about any messages

            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// functions that deal with property dialog

HRESULT CreatePropDialog(HWND hwnd, LPCONTROLPIDL pcpidl) 
{
#ifdef AUTO_UPDATE
    PROPSHEETPAGE psp[NUM_PAGES] = {{0},{0},{0},{0}};
#else
    PROPSHEETPAGE psp[NUM_PAGES] = {{0},{0},{0}};
#endif
    PROPSHEETHEADER psh = {0};

    // initialize propsheet page 1.
    psp[0].dwSize          = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags         = 0;
    psp[0].hInstance       = MLGetHinst();
    psp[0].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_GENERAL);
    psp[0].pszIcon         = NULL;
    psp[0].pfnDlgProc      = ControlItem_PropPage1Proc;
    psp[0].pszTitle        = NULL;
    psp[0].lParam          = (LPARAM)pcpidl; // send it the cache entry struct

    // initialize propsheet page 2.
    psp[1].dwSize          = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags         = 0;
    psp[1].hInstance       = MLGetHinst();
    psp[1].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_DEPENDENCY);
    psp[1].pszIcon         = NULL;
    psp[1].pfnDlgProc      = ControlItem_PropPage2Proc;
    psp[1].pszTitle        = NULL;
    psp[1].lParam          = (LPARAM)pcpidl; // send it the cache entry struct


#ifdef AUTO_UPDATE
    // initialize propsheet page 3.
    psp[2].dwSize          = sizeof(PROPSHEETPAGE);
    psp[2].dwFlags         = 0;
    psp[2].hInstance       = MLGetHinst();
    psp[2].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_UPDATE);
    psp[2].pszIcon         = NULL;
    psp[2].pfnDlgProc      = ControlItem_PropPage3Proc;
    psp[2].pszTitle        = NULL;
    psp[2].lParam          = (LPARAM)pcpidl; // send it the cache entry struct
#endif

    // initialize propsheet page 4.
    psp[NUM_PAGES-1].dwSize          = sizeof(PROPSHEETPAGE);
    psp[NUM_PAGES-1].dwFlags         = 0;
    psp[NUM_PAGES-1].hInstance       = MLGetHinst();
    psp[NUM_PAGES-1].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_VERSION);
    psp[NUM_PAGES-1].pszIcon         = NULL;
    psp[NUM_PAGES-1].pfnDlgProc      = ControlItem_PropPage4Proc;
    psp[NUM_PAGES-1].pszTitle        = NULL;
    psp[NUM_PAGES-1].lParam          = (LPARAM)pcpidl; // send it the cache entry struct

    // initialize propsheet header.
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW|PSH_PROPTITLE;
    psh.hwndParent  = hwnd;
    psh.pszCaption  = GetStringInfo(pcpidl, SI_CONTROL);
    psh.nPages      = NUM_PAGES;
    psh.nStartPage  = 0;
    psh.ppsp        = (LPCPROPSHEETPAGE)&psp;

    // invoke the property sheet
    PropertySheet(&psh);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\occache\view.cpp ===
#include "folder.h"
#include "item.h"
#include "utils.h"

#include <mluisupp.h>

///////////////////////////////////////////////////////////////////////////////
// View functions

const struct {
    short int iCol;
    short int ids;
    short int cchCol;
    short int iFmt;
} s_ControlFolder_cols[] = {
    {SI_CONTROL, IDS_COL_CONTROL, 20, LVCFMT_LEFT},
    {SI_STATUS, IDS_COL_STATUS, 20, LVCFMT_LEFT},
    {SI_TOTALSIZE, IDS_COL_TOTALSIZE, 18, LVCFMT_LEFT},
    {SI_CREATION, IDS_COL_CREATION, 18, LVCFMT_LEFT},
    {SI_LASTACCESS, IDS_COL_LASTACCESS, 18, LVCFMT_LEFT},
    {SI_VERSION, IDS_COL_VERSION, 18, LVCFMT_LEFT}
};

HRESULT ControlFolderView_Command(HWND hwnd, UINT uID)
{
    switch (uID)
    {
    case IDM_SORTBYNAME:
    case IDM_SORTBYSTATUS:
    case IDM_SORTBYTOTALSIZE:
    case IDM_SORTBYCREATION:
    case IDM_SORTBYLASTACCESS:
    case IDM_SORTBYVERSION:
        ShellFolderView_ReArrange(hwnd, uID - IDM_SORTBYNAME);
        break;

    default:
        return E_FAIL;
    }

    return NOERROR;
}

HMENU GetMenuFromID(HMENU hmenu, UINT idm)
{
    MENUITEMINFO mii = {sizeof(mii), MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0};
    GetMenuItemInfo(hmenu, idm, FALSE, &mii);
    return mii.hSubMenu;
}

UINT MergeMenuHierarchy(
                    HMENU hmenuDst, 
                    HMENU hmenuSrc, 
                    UINT idcMin, 
                    UINT idcMax)
{
    UINT idcMaxUsed = idcMin;
    int imi = GetMenuItemCount(hmenuSrc);

    while (--imi >= 0) 
    {
        MENUITEMINFO mii = {sizeof(mii), MIIM_ID | MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0};

        if (GetMenuItemInfo(hmenuSrc, imi, TRUE, &mii)) 
        {
            UINT idcT = Shell_MergeMenus(
                                  GetMenuFromID(hmenuDst, mii.wID),
                                  mii.hSubMenu, 
                                  0, idcMin, idcMax, 
                                  MM_ADDSEPARATOR|MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }
    return idcMaxUsed;
}

HRESULT ControlFolderView_MergeMenu(LPQCMINFO pqcm)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_CONTROLFOLDER));
    Assert(hmenu != NULL);
    if (hmenu)
    {
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID;
        mii.wID = SFVIDM_MENU_ARRANGE;
        SetMenuItemInfo(hmenu, 0, TRUE, &mii);
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        DestroyMenu(hmenu);
    }
    return NOERROR;
}

HRESULT ControlFolderView_InitMenuPopup(
                                   HWND hwnd, 
                                   UINT idCmdFirst, 
                                   int nIndex, 
                                   HMENU hmenu)
{
    return NOERROR;
}

HRESULT ControlFolderView_OnGetDetailsOf(
                                    HWND hwnd, 
                                    UINT iColumn, 
                                    PDETAILSINFO pdi)
{
    BOOL bResult = TRUE;
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)pdi->pidl;

    if (iColumn >= NUM_COLUMNS)
        return E_NOTIMPL;

    pdi->str.uType = STRRET_CSTR;
    pdi->str.cStr[0] = '\0';

    // if NULL, asking for column info
    if (pcpidl == NULL)
    {
        MLLoadString(
              s_ControlFolder_cols[iColumn].ids, 
              pdi->str.cStr, 
              ARRAYSIZE(pdi->str.cStr));

        pdi->fmt = s_ControlFolder_cols[iColumn].iFmt;
        pdi->cxChar = s_ControlFolder_cols[iColumn].cchCol;

        return NOERROR;
    }
           
    switch (iColumn)
    {
    case SI_CONTROL:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_CONTROL));
        break;

    case SI_VERSION:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_VERSION));
        break;

    case SI_CREATION:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_CREATION));
        break;

    case SI_LASTACCESS:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_LASTACCESS));
        break;

    case SI_TOTALSIZE:
        GetSizeSaved(pcpidl, pdi->str.cStr);
        break;

    case SI_STATUS:
        GetStatus(pcpidl, pdi->str.cStr, sizeof(pdi->str.cStr));
        break;

    default:
        bResult = FALSE;
    }

    return (bResult ? NOERROR : E_FAIL);
}

HRESULT ControlFolderView_OnColumnClick(HWND hwnd, UINT iColumn)
{
    ShellFolderView_ReArrange(hwnd, iColumn);
    return NOERROR;
}

HRESULT ControlFolderView_DidDragDrop(HWND hwnd, IDataObject *pdo, DWORD dwEffect)
{
    HRESULT hr = E_FAIL;

    if (dwEffect & DROPEFFECT_MOVE)
    {
        CControlItem *pCItem;
        if (SUCCEEDED(pdo->QueryInterface(CLSID_ControlFolder, (void **)&pCItem)))
        {
            hr = pCItem->Remove(hwnd);
            pCItem->Release();
        }
    }

    return hr;
}

HRESULT CALLBACK ControlFolderView_ViewCallback(
                                     IShellView *psvOuter,
                                     IShellFolder *psf,
                                     HWND hwnd,
                                     UINT uMsg,
                                     WPARAM wParam,
                                     LPARAM lParam)
{
    HRESULT hres = NOERROR;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
        {
            UINT id = LOWORD(wParam);
            UINT cchBuf = HIWORD(wParam);
            LPTSTR pszBuf = (LPTSTR)lParam;
            MLLoadString(id + IDS_HELP_SORTBYNAME ,pszBuf, cchBuf);
        }
        break;

    case DVM_DIDDRAGDROP:
        hres = ControlFolderView_DidDragDrop(
                                        hwnd, 
                                        (IDataObject*)lParam, 
                                        (DWORD)wParam);
        break;

    case DVM_INITMENUPOPUP:
        hres = ControlFolderView_InitMenuPopup(
                                           hwnd, 
                                           LOWORD(wParam), 
                                           HIWORD(wParam), 
                                           (HMENU)lParam);
        break;

    case DVM_INVOKECOMMAND:
        ControlFolderView_Command(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        hres = ControlFolderView_OnColumnClick(hwnd, (UINT)wParam);
        break;

    case DVM_GETDETAILSOF:
        hres = ControlFolderView_OnGetDetailsOf(hwnd, (UINT)wParam, (PDETAILSINFO)lParam);
        break;

    case DVM_MERGEMENU:
        hres = ControlFolderView_MergeMenu((LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    default:
        hres = E_FAIL;
    }

    return hres;
}

HRESULT ControlFolderView_CreateInstance(
                                    CControlFolder *pCFolder, 
                                    LPCITEMIDLIST pidl, 
                                    void **ppvOut)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder*)pCFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pidl;
    csfv.lEvents = SHCNE_DELETE | SHCNE_UPDATEITEM; // SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_GLOBALEVENTS;
    csfv.pfnCallback = ControlFolderView_ViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppvOut); // &this->psv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\ids.h ===
#ifndef IDS_H__
#define IDS_H__


// Used by pack2.rc
//

#define IDI_DOCUMENT			1

// Dialogs
#define IDD_SELECTFILE                  102
#define IDD_SELECTICON                  103
#define IDD_SELECTLABEL                 107
#define IDD_EDITEMBEDPACKAGE            108
#define IDD_EDITCMDPACKAGE              109

#define IDC_COMMAND                     1003
#define IDC_BROWSE                      1004
#define IDC_CHANGEICON                  1005
#define IDC_PACKICON                    1007
#define IDC_WIZBMP                      1009
#define IDC_EDIT1                       1013
#define IDC_EDIT2                       1014
#define IDC_CHECK1                      1015

// Strings
#define	IDS_BROWSEEXT			2001
#define	IDS_BROWSEFILTER		2002
#define	IDS_BROWSETITLE			2003
#define	IDS_APP_TITLE           3000
#define	IDS_UPDATE_ERROR        3001
#define	IDS_OLD_FORMAT_ERROR    3002
#define	IDS_CREATE_ERROR        3003
#define	IDS_COPY_ERROR          3004
#define	IDS_COPY_COMPLETE       3005
#define IDS_INVALID_COMMAND_LINE      3006
#define IDS_COMMAND_LINE_NOT_ALLOWED  3007
#define IDS_NO_SUCH_FILE_CANNOT_SAVE  3008
#define IDS_CANNOT_EDIT_PACKAGE       3009
#define IDS_ICON_TITLE_FORMAT	      3010
#define IDS_PACKAGE_WARNING           3011
#define IDS_PACKAGE_EXECUTABLE_WARNING 3012
#define IDS_WARNING_DLG_TITLE         3013
#define IDS_COMMAND_LINE              3014
#define IDS_ICON_COMMAND_LINE_FORMAT  3015
// Icons
#define IDI_PACKAGER                  1500
#define IDI_PACKAGE_WARNING           1501

// Bitmaps
#define IDB_PACKWIZBMP			5000

#define IDC_STATIC                      -1



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\iperfile.cpp ===
#include "privcpp.h"

//////////////////////////////////
//
// IPersistFile Methods...
//
HRESULT CPackage::GetClassID(LPCLSID pClassID)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE, "pack ps - GetClassID() called.");
    
    if (NULL == pClassID)
        hr = E_INVALIDARG;
    else
        *pClassID = CLSID_CPackage;        // CLSID_OldPackage;

    return hr;
}

HRESULT CPackage::IsDirty(void)
{
    DebugMsg(DM_TRACE, "pack ps - IsDirty() called.");
    return _fIsDirty ? S_OK : S_FALSE;
}

    
HRESULT CPackage::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT     hr;

    DebugMsg(DM_TRACE, "pack pf - Load() called.");

    if (!pszFileName) 
    {
        DebugMsg(DM_TRACE,"            bad pointer!!");
        hr = E_POINTER;
    }
    else
    {
        // We blow off the mode flags
        hr = EmbedInitFromFile(pszFileName, TRUE);
    }

    DebugMsg(DM_TRACE, "            leaving Load()");
    
    return hr;
}

    
HRESULT CPackage::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    DebugMsg(DM_TRACE, "pack pf - Save() called.");
    return E_NOTIMPL;    
}

    
HRESULT CPackage::SaveCompleted(LPCOLESTR pszFileName)
{
    DebugMsg(DM_TRACE, "pack pf - SaveCompleted() called.");
    return E_NOTIMPL;
}

    
HRESULT CPackage::GetCurFile(LPOLESTR *ppszFileName)
{
    HRESULT hr = E_NOTIMPL;
    DebugMsg(DM_TRACE, "pack pf - GetCurFile() called.");

    if (!ppszFileName)
        hr = E_POINTER;
    else
        *ppszFileName = NULL;           // null the out param

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\iadvsink.cpp ===
#include "privcpp.h"

//////////////////////////////////
//
// IAdviseSink Methods...
//

void CPackage::OnDataChange(LPFORMATETC, LPSTGMEDIUM)
{
    // NOTE: currently, we never set up a data advise connection with
    // anyone, but if we ever do, we'll want to set our dirty flag
    // when we get a datachange notificaiton.
    
    DebugMsg(DM_TRACE, "pack as - OnDataChange() called.");
    // when we get a data change notification, set our dirty flag
    _fIsDirty = TRUE;
    return;
}


void CPackage::OnViewChange(DWORD, LONG) 
{
    DebugMsg(DM_TRACE, "pack as - OnViewChange() called.");
    //
    // there's nothing to do here....we don't care about view changes.
    return;
}

void CPackage::OnRename(LPMONIKER)
{
    DebugMsg(DM_TRACE, "pack as - OnRename() called.");
    //
    // once again, nothing to do here...if the user for some unknown reason
    // tries to save the packaged file by a different name when he's done
    // editing the contents then we'll just give not receive those changes.
    // why would anyone want to rename a temporary file, anyway?
    //
    return;
}

void CPackage::OnSave(void)
{
    DebugMsg(DM_TRACE, "pack as - OnSave() called.");

    // if the contents have been saved, then our storage is out of date,
    // so set our dirty flag, then the container can choose to save us or not
    _fIsDirty = TRUE;

    // NOTE: even though Word sends us OnSave, it doesn't actually save
    // the file.  Getting IPersistFile here and calling Save
    // fails with RPC_E_CANTCALLOUT_INASYNCCALL.  W2K didn't pick
    // up Word's save either...

    // we just notifiy our own container that we've been saved and it 
    // can do whatever it wants to.
    if (_pIOleAdviseHolder)
        _pIOleAdviseHolder->SendOnSave();
}

void CPackage::OnClose(void) 
{
    DebugMsg(DM_TRACE, "pack as - OnClose() called.");
    _bClosed = TRUE;

    // The SendOnDataChange is necessary for Word to save any changes
    if(_pIDataAdviseHolder)
    {
        // if it fails, no harm, no foul?
        _pIDataAdviseHolder->SendOnDataChange(this, 0, 0);
    }

    switch(_panetype)
    {
    case PEMBED:
        // get rid of advsiory connnection
        _pEmbed->poo->Unadvise(_dwCookie);
        _pEmbed->poo->Release();
        _pEmbed->poo = NULL;

        // this updates the size of the packaged file in our _pPackage->_pEmbed
        if (FAILED(EmbedInitFromFile(_pEmbed->pszTempName, FALSE)))
        {
#ifdef USE_RESOURCE_DLL
            HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(!hInstRes)
                return;
#endif

            ShellMessageBox(hInstRes,
                            NULL,
                            MAKEINTRESOURCE(IDS_UPDATE_ERROR),
                            MAKEINTRESOURCE(IDS_APP_TITLE),
                            MB_TASKMODAL | MB_ICONERROR | MB_OK);
#ifdef USE_RESOURCE_DLL
            FreeLibrary(hInstRes);
#endif

        }

        if (FAILED(_pIOleClientSite->SaveObject()))
        {
#ifdef USE_RESOURCE_DLL
            HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(!hInstRes)
                return;
#endif

            ShellMessageBox(hInstRes,
                            NULL,
                            MAKEINTRESOURCE(IDS_UPDATE_ERROR),
                            MAKEINTRESOURCE(IDS_APP_TITLE),
                            MB_TASKMODAL | MB_ICONERROR | MB_OK);
#ifdef USE_RESOURCE_DLL
            FreeLibrary(hInstRes);
#endif

        }

        if (_pIOleAdviseHolder)
            _pIOleAdviseHolder->SendOnSave();
if (!_fNoIOleClientSiteCalls)
            _pIOleClientSite->OnShowWindow(FALSE);

        // we just notify out own container that we've been closed and let
        // it do whatever it wants to.
        if (_pIOleAdviseHolder)
            _pIOleAdviseHolder->SendOnClose();

        break;

    case CMDLINK:
        // there shouldn't be anything to do here, since a CMDLINK is always
        // executed using ShellExecute and never through OLE, so who would be
        // setting up an advisory connection with the package?
        break;
    }

    _bClosed = TRUE;

}

DWORD CPackage::AddConnection(DWORD exconn, DWORD dwreserved )
{
    return 0;
}



DWORD CPackage::ReleaseConnection(DWORD extconn, DWORD dwreserved, BOOL fLastReleaseCloses )
{
    if(fLastReleaseCloses && !_bClosed)
    {
        // For those applications (say MSPaint) that call this with fLastReleaseCloses immediate after they are activated,
        // and then we never hear from them again, this gives us a way to call OnClose();
        _fNoIOleClientSiteCalls = TRUE;
        _bCloseIt = TRUE;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\idataobj.cpp ===
#include "priv.h"
#include "privcpp.h"


//////////////////////////////////
//
// IDataObject Methods...
//
HRESULT CPackage::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    UINT cf = pFEIn->cfFormat;

    DebugMsg(DM_TRACE, "pack do - GetData() called.");
    
    // Check the aspects we support
    if (!(pFEIn->dwAspect & DVASPECT_CONTENT)) 
    {
        // Let it go through if it's asking for an icon and CF_METAFILEPICT,
        // otherwise bail
        if(!((pFEIn->dwAspect & DVASPECT_ICON) && (cf == CF_METAFILEPICT || cf == CF_ENHMETAFILE)))
        {
            DebugMsg(DM_TRACE, "            Invalid Aspect! dwAspect=%d",pFEIn->dwAspect);
            return DATA_E_FORMATETC;
        }
    }
    
    // we set this to NULL so we aren't responsible for freeing memory
    pSTM->pUnkForRelease = NULL;

    // Go render the appropriate data for the format.
    if (cf == CF_FILEDESCRIPTOR) 
        return GetFileDescriptor(pFEIn,pSTM);
    
    else if (cf == CF_FILECONTENTS) 
        return GetFileContents(pFEIn,pSTM);
    
    else if (cf == CF_METAFILEPICT) 
        return GetMetafilePict(pFEIn,pSTM);

    else if (cf == CF_ENHMETAFILE)
        return GetEnhMetafile(pFEIn,pSTM);

    else if (cf == CF_OBJECTDESCRIPTOR)
        return GetObjectDescriptor(pFEIn,pSTM);
                

#ifdef DEBUG
    else {
        TCHAR szFormat[80];
        GetClipboardFormatName(cf, szFormat, ARRAYSIZE(szFormat));
        DebugMsg(DM_TRACE,"            unknown format: %s",szFormat);
        return DATA_E_FORMATETC;
    }
#endif

    return DATA_E_FORMATETC;

}

HRESULT CPackage::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DebugMsg(DM_TRACE, "pack do - GetDataHere() called.");
    
    HRESULT     hr;
    
    // The only reasonable time this is called is for CFSTR_EMEDSOURCE and
    // TYMED_ISTORAGE.  This means the same as IPersistStorage::Save
    
    // Aspect is unimportant to us here, as is lindex and ptd.
    if (pFE->cfFormat == CF_EMBEDSOURCE && (pFE->tymed & TYMED_ISTORAGE)) {
        // we have an IStorage we can write into.
        pSTM->tymed = TYMED_ISTORAGE;
        pSTM->pUnkForRelease = NULL;
        
        hr = Save(pSTM->pstg, FALSE);
        SaveCompleted((IStorage *) NULL);
        return hr;
    }
    
    return DATA_E_FORMATETC;
}
    
    
HRESULT CPackage::QueryGetData(LPFORMATETC pFE)
{
    UINT cf = pFE->cfFormat;
    BOOL fRet = FALSE;

    DebugMsg(DM_TRACE, "pack do - QueryGetData() called.");

    if (!(pFE->dwAspect & DVASPECT_CONTENT))
        return S_FALSE;

    if (cf == CF_FILEDESCRIPTOR) {
        DebugMsg(DM_TRACE,"            Getting File Descriptor");
        fRet = (BOOL)(pFE->tymed & TYMED_HGLOBAL);
    }
    else if (cf == CF_FILECONTENTS) {
        DebugMsg(DM_TRACE,"            Getting File Contents");
        fRet = (BOOL)(pFE->tymed & (TYMED_HGLOBAL|TYMED_ISTREAM)); 
    }
    else if (cf == CF_EMBEDSOURCE) {
        DebugMsg(DM_TRACE,"            Getting Embed Source");
        fRet = (BOOL)(pFE->tymed & TYMED_ISTORAGE);
    }
    else if (cf == CF_OBJECTDESCRIPTOR) {
        DebugMsg(DM_TRACE,"            Getting Object Descriptor");
        fRet = (BOOL)(pFE->tymed & TYMED_HGLOBAL);
    }
    else if (cf == CF_METAFILEPICT) {
        DebugMsg(DM_TRACE,"            Getting MetafilePict");
        fRet = (BOOL)(pFE->tymed & TYMED_MFPICT);
    }
    else if (cf == CF_ENHMETAFILE) {
        DebugMsg(DM_TRACE,"            Getting EnhancedMetafile");
        fRet = (BOOL)(pFE->tymed & TYMED_ENHMF);
    }


#ifdef DEBUG
    else {
        TCHAR szFormat[255];
        GetClipboardFormatName(cf, szFormat, ARRAYSIZE(szFormat));
        DebugMsg(DM_TRACE,"            unknown format: %s",szFormat);
        fRet = FALSE;
    }
#endif
            
    DebugMsg(DM_TRACE, "            fRet == %s",fRet ? TEXT("TRUE") : TEXT("FALSE"));
    return fRet ? S_OK : S_FALSE;
}

    
HRESULT CPackage::GetCanonicalFormatEtc(LPFORMATETC pFEIn,
LPFORMATETC pFEOut)
{
    DebugMsg(DM_TRACE, "pack do - GetCanonicalFormatEtc() called.");
    
    if (!pFEOut)  
        return E_INVALIDARG;
    
    pFEOut->ptd = NULL;
    return DATA_S_SAMEFORMATETC;
}

    
HRESULT CPackage::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease) 
{
    HRESULT hr;
    
    DebugMsg(DM_TRACE, "pack do - SetData() called.");

    if ((pFE->cfFormat == CF_FILENAMEW) && (pFE->tymed & (TYMED_HGLOBAL|TYMED_FILE)))
    {
        LPWSTR pwsz = pSTM->tymed == TYMED_HGLOBAL ? (LPWSTR)pSTM->hGlobal : pSTM->lpszFileName;
       
        hr = CmlInitFromFile(pwsz, TRUE, CMDLINK);
        _pCml->fCmdIsLink = TRUE;

        // REVIEW: Why don't we return some sort of success code here?
    }
    else if (pFE->cfFormat == CF_METAFILEPICT)
    {
        return S_OK;        // thanks for playing, but we like OUR icon
    }
    else
    {
        DebugMsg(DM_TRACE, "Format = %d Tymed = %08lX\n", pFE->cfFormat, pFE->tymed);
    }
    return DATA_E_FORMATETC;
}

    
HRESULT CPackage::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    DebugMsg(DM_TRACE, "pack do - EnumFormatEtc() called.");
    
    // NOTE: This means that we'll have to put the appropriate entries in 
    // the registry for this to work.
    //
    return OleRegEnumFormatEtc(CLSID_CPackage, dwDirection, ppEnum);
}

    
HRESULT CPackage::DAdvise(LPFORMATETC pFE, DWORD grfAdv,
LPADVISESINK pAdvSink, LPDWORD pdwConnection)
{
    HRESULT hr;

    DebugMsg(DM_TRACE, "pack do - DAdvise() called.");
    
    if (_pIDataAdviseHolder == NULL) 
    {
        hr = CreateDataAdviseHolder(&_pIDataAdviseHolder);
        if (FAILED(hr))
            return E_OUTOFMEMORY;
    }

    return _pIDataAdviseHolder->Advise(this, pFE, grfAdv, pAdvSink, pdwConnection);
}

     
HRESULT CPackage::DUnadvise(DWORD dwConnection)
{
    DebugMsg(DM_TRACE, "pack do - DUnadvise() called.");
    
    if (_pIDataAdviseHolder == NULL) 
        return E_UNEXPECTED;
    
    return _pIDataAdviseHolder->Unadvise(dwConnection);
}

   
HRESULT CPackage::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    DebugMsg(DM_TRACE, "pack do - EnumAdvise() called.");
    
    if (_pIDataAdviseHolder == NULL)
        return E_UNEXPECTED;
    
    return _pIDataAdviseHolder->EnumAdvise(ppEnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\iperstor.cpp ===
#include "privcpp.h"


HRESULT CPackage::InitNew(IStorage *pstg)
{
    HRESULT hr;
    LPSTREAM pstm;

    DebugMsg(DM_TRACE, "pack ps - InitNew() called.");

    if (_psState != PSSTATE_UNINIT)  
        return E_UNEXPECTED;

    if (!pstg)  
        return E_POINTER;

    // Create a stream to save the package and cache the pointer.  By doing 
    // this now we ensure being able to save in low memory conditions.
    //
    hr = pstg->CreateStream(SZCONTENTS,STGM_DIRECT | STGM_CREATE | 
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, 
                            &pstm);
    if (SUCCEEDED(hr))
    {
        hr = WriteFmtUserTypeStg(pstg, (CLIPFORMAT)_cf,SZUSERTYPE);
        if (SUCCEEDED(hr))
        {     
            _fIsDirty = TRUE;
            _psState = PSSTATE_SCRIBBLE;
            
            DebugMsg(DM_TRACE, "            leaving InitNew()");
        }
        pstm->Release();
        pstm = NULL;

    }

    return hr;
}

    
HRESULT CPackage::Load(IStorage *pstg)
{
    HRESULT     hr;
    LPSTREAM    pstm = NULL;         // package contents
    CLSID       clsid;

    DebugMsg(DM_TRACE, "pack ps - Load() called.");

    if (_psState != PSSTATE_UNINIT) 
    {
        DebugMsg(DM_TRACE,"            wrong state!!");
        return E_UNEXPECTED;
    }
    
    if (!pstg) 
    {
        DebugMsg(DM_TRACE,"            bad pointer!!");
        return E_POINTER;
    }
    
    
    // check to make sure this is one of our storages
    hr = ReadClassStg(pstg, &clsid);
    if (SUCCEEDED(hr) &&
        (clsid != CLSID_CPackage && clsid != CLSID_OldPackage) || FAILED(hr))
    {
        DebugMsg(DM_TRACE,"            bad storage type!!");
        return E_UNEXPECTED;
    }
    
    hr = pstg->OpenStream(SZCONTENTS,0, STGM_DIRECT | STGM_READWRITE | 
                          STGM_SHARE_EXCLUSIVE, 0, &pstm);
    if (SUCCEEDED(hr))
    {
        hr = PackageReadFromStream(pstm);

        _psState = PSSTATE_SCRIBBLE;
        _fIsDirty = FALSE;
        _fLoaded  = TRUE;
    
        pstm->Release();
    }
    else
    {
        DebugMsg(DM_TRACE,"            couldn't open contents stream!!");
        DebugMsg(DM_TRACE,"            hr==%Xh",hr);
    }

    return hr;
}

    
HRESULT CPackage::Save(IStorage *pstg, BOOL fSameAsLoad)
{
    HRESULT     hr;
    LPSTREAM    pstm;

    DebugMsg(DM_TRACE, "pack ps - Save() called.");

    if(!_pEmbed || !(*_pEmbed->fd.cFileName))
        return S_OK;

    // must come here from scribble state
    if ((_psState != PSSTATE_SCRIBBLE) && fSameAsLoad) 
    {
        DebugMsg(DM_TRACE,"            bad state!!");
        return E_UNEXPECTED;
    }
    
    // must have an IStorage if not SameAsLoad
    if (!pstg && !fSameAsLoad) 
    {
        DebugMsg(DM_TRACE,"            bad pointer!!");
        return E_POINTER;
    }

    CreateTempFile();       // Make sure we have the temp file created

    // hopefully, the container calls WriteClassStg with our CLSID before
    // we get here, that way we can overwrite that and write out the old
    // packager's CLSID so that the old packager can read new packages.
    //
    if (FAILED(WriteClassStg(pstg, CLSID_OldPackage))) 
    {
        DebugMsg(DM_TRACE,
            "            couldn't write CLSID to storage!!");
        return E_FAIL;
    }

    
    // 
    // ok, we have four possible ways we could be calling Save:
    //          1. we're creating a new package and saving to the same
    //             storage we received in InitNew
    //          2. We're creating a new package and saving to a different
    //             storage than we received in InitNew
    //          3. We were loaded by a container and we're saving to the
    //             same stream we received in Load
    //          4. We were loaded by a container and we're saving to a
    //             different stream than we received in Load
    //
    

    //////////////////////////////////////////////////////////////////
    //
    // Same Storage as Load
    //
    //////////////////////////////////////////////////////////////////
    
    if (fSameAsLoad) 
    {          

        DebugMsg(DM_TRACE,"            Same as load.");

        LARGE_INTEGER   li = {0,0};

        // If we're not dirty, so there's nothing new to save.
        
        if (FALSE == _fIsDirty) {
            DebugMsg(DM_TRACE, "            not saving cause we're not dirty!!");
            return S_OK;
        }

        hr = pstg->OpenStream(SZCONTENTS,0, STGM_DIRECT | STGM_READWRITE |
                              STGM_SHARE_EXCLUSIVE, 0, &pstm);
        if (SUCCEEDED(hr))
        {
            // case 1: new package
            if (!_fLoaded)
            {
                switch(_panetype)
                {
                    LPTSTR temp;
                    case PEMBED:
                        // if haven't created a temp file yet, then use the the
                        // file to be packaged to get our file contents from,
                        // otherwise we just use the temp file, because if we
                        // have a temp file, it contains the most recent info.
                        //
                        temp = _pEmbed->pszTempName;

                        if (!_pEmbed->pszTempName)
                        {
                            DebugMsg(DM_TRACE, "      case 1a:not loaded, using initFile.");
                            _pEmbed->pszTempName = _pEmbed->fd.cFileName;
                        }
                        else {
                            DebugMsg(DM_TRACE, "      case 1b:not loaded, using tempfile.");
                        }

                        hr = PackageWriteToStream(pstm);
                        // reset our temp name back, since we might have changed it
                        // basically, this just sets it to NULL if it was before
                        _pEmbed->pszTempName = temp;
                        break;

                    case CMDLINK:
                        // nothing screwy to do here...just write out the info
                        // which we already have in memory.
                        hr = PackageWriteToStream(pstm);
                        break;
                }

            }
            // case 3: loaded package
            else {
                hr = PackageWriteToStream(pstm);
            }

            pstm->Release();
            if (FAILED(hr))
                return hr;
        }
    }
    //////////////////////////////////////////////////////////////////
    //
    // NEW Storage
    //
    //////////////////////////////////////////////////////////////////

    else
    {

        DebugMsg(DM_TRACE,"            NOT same as load.");
        hr = pstg->CreateStream(SZCONTENTS,STGM_DIRECT | STGM_CREATE |
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0,
                                &pstm);
        if (FAILED(hr))
        {
            DebugMsg(DM_TRACE, "            couldn't create contents stream!!");
            return hr;
        }

        WriteFmtUserTypeStg(pstg, (CLIPFORMAT)_cf,SZUSERTYPE);

        // case 2:
        if (!_fLoaded)
        {
            switch(_panetype)
            {
                LPTSTR temp;
                case PEMBED:

                    temp = _pEmbed->pszTempName;
                    if (!_pEmbed->pszTempName)
                    {
                        DebugMsg(DM_TRACE, "      case 2a:not loaded, using initFile.");
                        _pEmbed->pszTempName = _pEmbed->fd.cFileName;
                    }
                    else
                    {
                        DebugMsg(DM_TRACE, "      case 2b:not loaded, using tempfile.");
                    }

                    hr = PackageWriteToStream(pstm);

                    // reset our temp name back, since we might have changed it
                    // basically, this just sets it to NULL if it was before
                    _pEmbed->pszTempName = temp;
                    break;

                case CMDLINK:
                    // nothing interesting to do here, other than write out
                    // the package.
                    hr = PackageWriteToStream(pstm);
                    break;
            }
        }
        // case 4:
        else
        {
            DebugMsg(DM_TRACE,"    case 4:loaded.");
            hr = PackageWriteToStream(pstm);
        }

        pstm->Release();
    }

    if (FAILED(hr))
        return hr;

    _psState = PSSTATE_ZOMBIE;
    
    DebugMsg(DM_TRACE, "            leaving Save()");
    return S_OK;
}

    
HRESULT CPackage::SaveCompleted(IStorage *pstg)
{
    DebugMsg(DM_TRACE, "pack ps - SaveCompleted() called.");

    // must be called from no-scribble or hands-off state
    if (!(_psState == PSSTATE_ZOMBIE || _psState == PSSTATE_HANDSOFF))
        return E_UNEXPECTED;
    
    // if we're hands-off, we'd better get a storage to re-init from
    if (!pstg && _psState == PSSTATE_HANDSOFF)
        return E_UNEXPECTED;
    
    _psState = PSSTATE_SCRIBBLE;
    _fIsDirty = FALSE;
    DebugMsg(DM_TRACE, "            leaving SaveCompleted()");
    return S_OK;
}

    
HRESULT CPackage::HandsOffStorage(void)
{
    DebugMsg(DM_TRACE, "pack ps - HandsOffStorage() called.");

    // must come from scribble or no-scribble.  a repeated call to 
    // HandsOffStorage is an unexpected error (bug in client).
    //
    if (_psState == PSSTATE_UNINIT || _psState == PSSTATE_HANDSOFF)
        return E_UNEXPECTED;
    
    _psState = PSSTATE_HANDSOFF;
    DebugMsg(DM_TRACE, "            leaving HandsOffStorage()");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\ioleobj.cpp ===
#include "privcpp.h"
#include <initguid.h>
#include "packguid.h"

HWND            g_hTaskWnd;
BOOL CALLBACK GetTaskWndProc(HWND hwnd, DWORD lParam);
DWORD CALLBACK MainWaitOnChildThreadProc(void *lpv);
BOOL IsProgIDInList(LPCTSTR pszProgID, LPCTSTR pszExt, const LPCTSTR *arszList, UINT nExt);

typedef struct 
{
    IStream * pIStreamIOleCommandTarget;   // an interface we can marshal
    HANDLE h;
} MAINWAITONCHILD;


//
HRESULT CPackage::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    DebugMsg(DM_TRACE, "pack oo - SetClientSite() called.");

    if (_pIOleClientSite)
        _pIOleClientSite->Release();

    _pIOleClientSite = pClientSite;

    if (_pIOleClientSite)
        _pIOleClientSite->AddRef();

    return S_OK;
}

HRESULT CPackage::GetClientSite(LPOLECLIENTSITE *ppClientSite) 
{
    DebugMsg(DM_TRACE, "pack oo - GetClientSite() called.");

    if (ppClientSite == NULL)
        return E_INVALIDARG;
    
    // Be sure to AddRef the pointer we're giving away.
    *ppClientSite = _pIOleClientSite;
    _pIOleClientSite->AddRef();
    
    return S_OK;
}

HRESULT CPackage::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    DebugMsg(DM_TRACE, "pack oo - SetHostNames() called.");

    delete [] _lpszContainerApp;
    
    DWORD cch = lstrlenW(szContainerApp) + 1;
    if (NULL != (_lpszContainerApp = new OLECHAR[cch]))
    {
        StringCchCopy(_lpszContainerApp, cch, szContainerApp);
    }
    
    delete [] _lpszContainerObj;
    cch = lstrlenW(szContainerObj) + 1;
    if (NULL != (_lpszContainerObj = new OLECHAR[cch]))
    {
        StringCchCopy(_lpszContainerObj,cch, szContainerObj);
    }

    switch(_panetype) {
        case PEMBED:
            if (_pEmbed->poo) 
                _pEmbed->poo->SetHostNames(szContainerApp,szContainerObj);
            break;
        case CMDLINK:
            // nothing to do...we're a link to a file, so we don't ever get
            // opened and need to be edited or some such thing.
            break;
    }
    
    return S_OK;
}

HRESULT CPackage::Close(DWORD dwSaveOption) 
{
    DebugMsg(DM_TRACE, "pack oo - Close() called.");

    switch (_panetype) {
        case PEMBED:
            if (_pEmbed == NULL)
                return S_OK;
            
            // tell the server to close, and release our pointer to it
            if (_pEmbed->poo) 
            {
                _pEmbed->poo->Close(dwSaveOption);  // Unadvise/release done in OnClose
            }
            break;
        case CMDLINK:
            // again, nothing to do...we shouldn't be getting close
            // messages since we're never activated through OLE.
            break;
    }
    if ((dwSaveOption != OLECLOSE_NOSAVE) && (_fIsDirty))
    {
        _pIOleClientSite->SaveObject();
        if (_pIOleAdviseHolder)
            _pIOleAdviseHolder->SendOnSave();
    }

    
    
    return S_OK;
}

HRESULT CPackage::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    DebugMsg(DM_TRACE, "pack oo - SetMoniker() called.");
    
    // NOTE: Uninteresting for embeddings only.
    return (E_NOTIMPL);
}

HRESULT CPackage::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, 
                               LPMONIKER *ppmk)
{
    DebugMsg(DM_TRACE, "pack oo - GetMoniker() called.");
    
    // NOTE: Unintersting for embeddings only.
    return (E_NOTIMPL);
}

HRESULT CPackage::InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, 
                                 DWORD dwReserved)
{
    DebugMsg(DM_TRACE, "pack oo - InitFromData() called.");
    
    // NOTE: This isn't supported at this time
    return (E_NOTIMPL);
}

HRESULT CPackage::GetClipboardData(DWORD dwReserved, LPDATAOBJECT *ppDataObject)
{
    DebugMsg(DM_TRACE, "pack oo - GetClipboardData() called.");
    
    if (ppDataObject == NULL) 
        return E_INVALIDARG;
    
    *ppDataObject = this;  // ->_pIDataObject;
    AddRef();
    return S_OK;
}

HRESULT CPackage::DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, 
                           LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    void *lpFileData = NULL;
    BOOL fError = TRUE;
    SHELLEXECUTEINFO sheinf = {sizeof(SHELLEXECUTEINFO)};
    HRESULT hr ;

    DebugMsg(DM_TRACE, "pack oo - DoVerb() called.");
    DebugMsg(DM_TRACE, "            iVerb==%d",iVerb);

    // We allow show, primary verb, edit, and context menu verbs on our packages...
    //
    if (iVerb < OLEIVERB_SHOW)
        return E_NOTIMPL;

    // Some applications (WordPerfect 10 for one) give us incorrect verb numbers
    // In that case they are giving us OLEIVERB_SHOW for activation
    if(OLEIVERB_SHOW == iVerb)
    {
        if(_pEmbed  && _pEmbed->fd.cFileName)
            iVerb = OLEIVERB_PRIMARY;
    }
    else if(2 == iVerb) 
    {
        // And they give us a 2 (menu item position) for "Properties
        iVerb = _iPropertiesMenuItem;
    }

    /////////////////////////////////////////////////////////////////
    // SHOW VERB
    /////////////////////////////////////////////////////////////////
    //
    if (iVerb == OLEIVERB_SHOW) {
        PACKAGER_INFO packInfo = {0};
        
        // Run the Wizard...
#ifdef USE_RESOURCE_DLL
        HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if(!hInstRes)
            return E_FAIL;
        g_hinstResDLL = hInstRes;
#endif

        PackWiz_CreateWizard(hwndParent, &packInfo);
        if(0 == lstrlen(packInfo.szFilename))
        {
            return S_OK;
        }

        HRESULT hr = InitFromPackInfo(&packInfo);

#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif

        return hr;
    }

    /////////////////////////////////////////////////////////////////
    // EDIT PACKAGE VERB
    /////////////////////////////////////////////////////////////////
    //
    else if (iVerb == OLEIVERB_EDITPACKAGE) 
    {
        // Call the edit package dialog.  Which dialog is ultimately called will
        // depend on whether we're a cmdline package or an embedded file
        // package.
        int idDlg;
        PACKAGER_INFO packInfo;
        ZeroMemory(&packInfo, sizeof(PACKAGER_INFO));
        int ret;

        StringCchCopy(packInfo.szLabel, ARRAYSIZE(packInfo.szLabel), _lpic->szIconText);
        StringCchCopy(packInfo.szIconPath, ARRAYSIZE(packInfo.szIconPath), _lpic->szIconPath);
        packInfo.iIcon = _lpic->iDlgIcon;
        
        switch(_panetype) 
        {
            case PEMBED:
                if(!PathFileExists(_pEmbed->fd.cFileName))
                {
#ifdef USE_RESOURCE_DLL
                    HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
                    if(!hInstRes)
                        return E_FAIL;
#endif

                    ShellMessageBox(hInstRes,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_CANNOT_EDIT_PACKAGE),
                                    MAKEINTRESOURCE(IDS_APP_TITLE),
                                    MB_ICONERROR | MB_TASKMODAL | MB_OK);


#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif
                    return S_OK;
                }

                StringCchCopy(packInfo.szFilename, ARRAYSIZE(packInfo.szFilename), _pEmbed->fd.cFileName);
                idDlg = IDD_EDITEMBEDPACKAGE;
                break;
            case CMDLINK:
                StringCchCopy(packInfo.szFilename, ARRAYSIZE(packInfo.szFilename), _pCml->szCommandLine);
                idDlg = IDD_EDITCMDPACKAGE;
                break;
        }

#ifdef USE_RESOURCE_DLL
        HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if(!hInstRes)
            return E_FAIL;
        g_hinstResDLL = hInstRes;
#endif
        ret = PackWiz_EditPackage(hwndParent, idDlg, &packInfo);
#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif


        // If User cancels the edit package...just return.  
        if (ret == -1)
            return S_OK;

        switch(_panetype) 
        {
            case PEMBED:
                if (_pEmbed->pszTempName) 
                {
                    // It's possible that the file name was changed, so our temp file name could be out of date
                    DeleteFile(_pEmbed->pszTempName);
                    delete [] _pEmbed->pszTempName;
                    _pEmbed->pszTempName = NULL;
                    _fLoaded = FALSE;
                    ReleaseContextMenu();
                }

                InitFromPackInfo(&packInfo);
                break;
                
            case CMDLINK:
                InitFromPackInfo(&packInfo);
                break;
        }
        return S_OK;
    }
    else if (iVerb == OLEIVERB_PRIMARY)
    {
        /////////////////////////////////////////////////////////////////
        // ACTIVATE CONTENTS VERB
        /////////////////////////////////////////////////////////////////
        // NOTE: This is kind of crazy looking code, partially because we have
        // to worry about two ways of launching things--ShellExecuteEx and 
        // calling through OLE.
        //

        switch(_panetype)
        {
            case PEMBED:
            {

                // ok, we now have a file name.  If necessary give a warning message to the user before
                // proceeding.
                if(IDCANCEL == _GiveWarningMsg())
                    return S_OK;
        
                // if this is an OLE file then, activate through OLE
                // Note that the only way to know is if this fails.  We start out all files as OLE the first time
                if (_pEmbed->fIsOleFile)
                {
                    // If we've activated the server, then we can just pass this
                    // call along to it.
                    _bClosed = FALSE; 
                    if (_pEmbed->poo) 
                    {
                        return _pEmbed->poo->DoVerb(iVerb,lpmsg, pActiveSite,lindex, hwndParent, lprcPosRect);
                    }

                    // We don't want to use OleCreateFromFile since that can turn around and create a packaged object...
                    CLSID clsid;
                    hr = GetClassFile(_pEmbed->pszTempName, &clsid);
                    if (SUCCEEDED(hr)) 
                    {
                        IOleObject* poo;
                        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IOleObject, (void **)&poo);
                        if (SUCCEEDED(hr)) 
                        {
                            hr = poo->Advise(this, &_dwCookie);
                            if (SUCCEEDED(hr))
                            {
                                // NOTE: apparently we have to call
                                // OleRun before we can get IPersistFile from some apps, namely
                                // Word and Excel. If we don't call OleRun, they fail our QI
                                // for IPersistfile.
                                OleRun(poo);
            
                                IPersistFile* ppf;
                                hr = poo->QueryInterface(IID_IPersistFile, (void **)&ppf);
                                if (SUCCEEDED(hr))
                                {
                                    hr = ppf->Load(_pEmbed->pszTempName, STGM_READWRITE | STGM_SHARE_DENY_WRITE);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = poo->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
                                        if (SUCCEEDED(hr))
                                        {
                                            // By passing NULL for the container object, this forces apps such
                                            // as Office to save to our temp file rather than something like
                                            // "Document in Outer.doc".  
                                            poo->SetHostNames(_lpszContainerApp, NULL); // _lpszContainerObj 
                                            if (!_fNoIOleClientSiteCalls)
                                            {
                                                _pIOleClientSite->ShowObject();
                                                _pIOleClientSite->OnShowWindow(TRUE);
                                            }
                                            _pEmbed->poo = poo;  // save this so when we get a
                                            poo = NULL;
                                            
                                        }
                                    }
                                    ppf->Release();
                                }
                                if (FAILED(hr))
                                    poo->Unadvise(_dwCookie);
                            }
                            if (FAILED(hr))
                                poo->Release();
                        }
                    }

                    // This flag gets set in the our IExternalConnection ReleaseConnection method.
                    // Some applications (MSPaint for one) give us a final release before we get here
                    // so we can safely assume that we're done and can close.
                    if(_bCloseIt)
                    {
                        OnClose();
                    }

                    if (SUCCEEDED(hr))
                        return hr;

                    // We weren't an OLE file after all, change our state to reflect this,
                    // and fall through to try the ShellExecuteEx
                    _pEmbed->fIsOleFile = FALSE;
                    _fIsDirty = TRUE;
                }   

                // Try to execute the file
                _pEmbed->hTask = NULL;
                sheinf.fMask  = SEE_MASK_NOCLOSEPROCESS;
                sheinf.lpFile = _pEmbed->pszTempName;
                sheinf.nShow  = SW_SHOWNORMAL;

                if (ShellExecuteEx(&sheinf))
                {
                    // if we get a valid process handle, we want to create a thread
                    // to wait for the process to exit so we know when we can load
                    // the tempfile back into memory.
                    //
                    if (sheinf.hProcess)
                    {
                        _pEmbed->hTask = sheinf.hProcess;
                        MAINWAITONCHILD *pmwoc = new MAINWAITONCHILD;
                        if(!pmwoc)
                        {
                            CloseHandle(sheinf.hProcess);
                            return E_OUTOFMEMORY;
                        }

                        HRESULT hr;
                        hr = CoMarshalInterThreadInterfaceInStream(IID_IOleCommandTarget, (IUnknown*)static_cast<IDataObject*>(this), &pmwoc->pIStreamIOleCommandTarget);

                        if(FAILED(hr))
                        {
                            CloseHandle(sheinf.hProcess);
                            delete pmwoc;
                            return hr;
                        }
                        
                        if (pmwoc)
                        {
                            pmwoc->h = sheinf.hProcess;
                        
                            if(SHCreateThread(MainWaitOnChildThreadProc, pmwoc, CTF_COINIT , NULL))  
                                fError = FALSE;
                            else 
                            {
                                CloseHandle(sheinf.hProcess);
                                return E_FAIL;
                            }
                        }
                    }
                    // NOTE: there's not much we can do if the ShellExecute
                    // succeeds and we don't get a valid handle back.  we'll just
                    // load from the temp file when we're asked to save and hope
                    // for the best.

                    // According to ShellExecuteEx, if hInstApp > 32 then we succeeded.  This is a DDE launch
                    // rather than a CreateProcess.  However, since we don't have the hProcess, we have nothing
                    // to wait for.
                    if(!sheinf.hProcess && reinterpret_cast<INT_PTR>(sheinf.hInstApp) > 32)
                    {
                        _fIsDirty = TRUE;
                        return S_OK;
                    }
                }   
                else // ShellExecuteEx failed!
                {
                    return E_FAIL;
                }           
        
                // show that the object is now active
                if (!fError && !_fNoIOleClientSiteCalls)
                {
                    _pIOleClientSite->ShowObject();
                    _pIOleClientSite->OnShowWindow(TRUE);
                }
                return fError ? E_FAIL : S_OK;
            }
            case CMDLINK: 
                if(gCmdLineOK)
                {
                    TCHAR szPath[MAX_PATH];
                    TCHAR szArgs[CBCMDLINKMAX-MAX_PATH];

                    StringCchCopy(szPath,  ARRAYSIZE(szPath), _pCml->szCommandLine);
                    PathSeparateArgs(szPath, szArgs, ARRAYSIZE(szPath));

                    sheinf.fMask  = SEE_MASK_NOCLOSEPROCESS;
                    sheinf.lpFile = szPath;
                    sheinf.lpParameters = szArgs;   
                    sheinf.nShow  = SW_SHOWNORMAL;

                    // NOTE: This code is much nicer than ShellExec-ing an embedded
                    // file.  Here, we just need to ShellExec the command line and
                    // the we're done.  We don't need to know when that process
                    // finishes or anything else.

                    return ShellExecuteEx(&sheinf)? S_OK:E_FAIL;                

                }
                else
                {
#ifdef USE_RESOURCE_DLL
                    HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
                    if(!hInstRes)
                        return E_FAIL;
#endif

                    ShellMessageBox(hInstRes,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_COMMAND_LINE_NOT_ALLOWED),
                                    MAKEINTRESOURCE(IDS_APP_TITLE),
                                    MB_ICONERROR | MB_TASKMODAL | MB_OK);

#ifdef USE_RESOURCE_DLL
                FreeLibrary(hInstRes);
#endif

                }

                break;

            case PACKAGE:  
                {
                    PACKAGER_INFO packInfo = {0};

                    ASSERT(_pCml);
                    StringCchCopy(packInfo.szFilename,  ARRAYSIZE(packInfo.szFilename), _pCml->szCommandLine);

                    // Run the Wizard...
#ifdef USE_RESOURCE_DLL
                    HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
                    if(!hInstRes)
                        return E_FAIL;
                    g_hinstResDLL = hInstRes;
#endif

                    PackWiz_CreateWizard(hwndParent, &packInfo);
                    HRESULT hr = InitFromPackInfo(&packInfo);
#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif


                    return hr;
                }
                break;
        }
    }
    else
    {
        // Let's see if it is a context menu verb:
        HRESULT hr;
        IContextMenu* pcm;
        if (SUCCEEDED(hr = GetContextMenu(&pcm)))
        {
            HMENU hmenu = CreatePopupMenu();
            if (NULL != hmenu)
            {
                if (SUCCEEDED(hr = pcm->QueryContextMenu(hmenu,
                                                         0,
                                                         OLEIVERB_FIRST_CONTEXT,
                                                         OLEIVERB_LAST_CONTEXT,
                                                         CMF_NORMAL)))
                {
                    MENUITEMINFO mii;
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID;
                    if (GetMenuItemInfo(hmenu, (UINT) (iVerb - OLEIVERB_FIRST_CONTEXT), TRUE, &mii))
                    {
                        if (PEMBED == _panetype)
                        {
                            // If we have an embedding, we have to make sure that
                            // the temp file is created before we execute a command:
                            hr =CreateTempFile();
                        }
                        if (SUCCEEDED(hr))
                        {
                            CMINVOKECOMMANDINFO ici;
                            ici.cbSize = sizeof(ici);
                            ici.fMask = 0;
                            ici.hwnd = NULL;
                            ici.lpVerb = (LPCSTR) IntToPtr(mii.wID - OLEIVERB_FIRST_CONTEXT);
                            ici.lpParameters = NULL;
                            ici.lpDirectory = NULL;
                            ici.nShow = SW_SHOWNORMAL;
                            // REVIEW: should we return OLEOBJ_S_CANNOT_DOVERB_NOW if this fails?
                            hr = pcm->InvokeCommand(&ici);
                        }
                    }
                    else
                    {
                        hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
                    }
                }
                DestroyMenu(hmenu);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            pcm->Release();
        }
        return hr;
    }
    return E_FAIL;
}



HRESULT CPackage::EnumVerbs(LPENUMOLEVERB *ppEnumOleVerb)
{
    DebugMsg(DM_TRACE, "pack oo - EnumVerbs() called.");
    HRESULT hr;
    
    IContextMenu* pcm;
     // tell the package to release the cached context menu:
    ReleaseContextMenu();
    if (SUCCEEDED(hr = GetContextMenu(&pcm)))
    {
        HMENU hmenu = CreatePopupMenu();
        if (NULL != hmenu)
        {
            if (SUCCEEDED(hr = pcm->QueryContextMenu(hmenu,
                                                     0,
                                                     OLEIVERB_FIRST_CONTEXT,
                                                     OLEIVERB_LAST_CONTEXT,
                                                     CMF_NORMAL)))
            {
                // FEATURE: remove problematic items by canonical names
                int nItems = GetMenuItemCount(hmenu);
                if (nItems > 0)
                {
                    const DWORD cdwNumVerbs = 3;   // (3) change if the number of registry verbs changes

                    OLEVERB* pVerbs = new OLEVERB[nItems + cdwNumVerbs];
                    if(!pVerbs)
                        return E_OUTOFMEMORY;
                    
                    // NOTE: we allocate nItems, but we may not use all of them
                    // First, get the registry based verbs
                    IEnumOLEVERB * pIVerbEnum;
                    UINT cRegFetched = 0;
                    if(SUCCEEDED(OleRegEnumVerbs(CLSID_CPackage, &pIVerbEnum)))
                    {
                        // There are currently only two, but ask for cdwNumVerbs to double check
                        pIVerbEnum->Next(cdwNumVerbs, pVerbs, (ULONG *) &cRegFetched);
                        ASSERT(cRegFetched < cdwNumVerbs);

                        if(cRegFetched)
                        {
                            for(UINT i = 0; i < (ULONG) cRegFetched; i++)
                            {
                                InsertMenu(hmenu, i, MF_BYPOSITION, i, pVerbs[i].lpszVerbName);  
                            }
                        }

                        pIVerbEnum->Release();
                    }
                      

                    if (NULL != pVerbs)
                    {
                        MENUITEMINFO mii;
                        TCHAR szMenuName[MAX_PATH];
                        mii.cbSize = sizeof(mii);
                        mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE | MIIM_ID;
                        int cOleVerbs = cRegFetched;

                        for (ULONG i = cRegFetched; i < nItems + cRegFetched; i++)
                        {
                            mii.dwTypeData = szMenuName;
                            mii.cch = ARRAYSIZE(szMenuName);
                            // NOTE: use GetMenuState() to avoid converting flags:
                            DWORD dwState = GetMenuState(hmenu, i, MF_BYPOSITION);
                            if (0 == (dwState & (MF_BITMAP | MF_OWNERDRAW | MF_POPUP)))
                            {
                                if (GetMenuItemInfo(hmenu, i, TRUE, &mii) && (MFT_STRING == mii.fType))
                                {
                                    TCHAR szVerb[MAX_PATH];
                                    if (FAILED(pcm->GetCommandString(mii.wID - OLEIVERB_FIRST_CONTEXT,
                                                                     GCS_VERB,
                                                                     NULL,
                                                                     (LPSTR) szVerb,
                                                                     ARRAYSIZE(szVerb))))
                                    {
                                        // Some commands don't have canonical names - just
                                        // set the verb string to empty
                                        szVerb[0] = TEXT('\0');
                                    }

                                    // hardcode the verbs we want to add.  We expect this list to be quite
                                    // limited. For now, just properties
                                    if (0 == lstrcmp(szVerb, TEXT("properties")))
                                    {
                                        // In the first design, the context menu ID was used as
                                        // the lVerb - however MFC apps only give us a range of
                                        // 16 ID's and context menu ID's are often over 100
                                        // (they aren't contiguous)
                                        // Instead, we use the menu position plus the verb offset
                                        pVerbs[cOleVerbs].lVerb = (LONG) i;
                                        _iPropertiesMenuItem = i;
                                        int cchMenu = lstrlen(mii.dwTypeData) + 1;
                                        if (NULL != (pVerbs[cOleVerbs].lpszVerbName = new WCHAR[cchMenu]))
                                        {
                                            SHTCharToUnicode(mii.dwTypeData, pVerbs[cOleVerbs].lpszVerbName, cchMenu);
                                        }
                                        pVerbs[cOleVerbs].fuFlags = dwState;
                                        pVerbs[cOleVerbs].grfAttribs = OLEVERBATTRIB_ONCONTAINERMENU;
                                        DebugMsg(DM_TRACE, "  Adding verb: id==%d,name=%s,verb=%s",mii.wID,mii.dwTypeData,szVerb);
                                        cOleVerbs++;
                                    }
                                }
                            }
                        }
                        if (SUCCEEDED(hr = InitVerbEnum(pVerbs, cOleVerbs)))
                        {
                            hr = QueryInterface(IID_IEnumOLEVERB, (void**) ppEnumOleVerb);
                        }
                        else
                        {
                            delete [] pVerbs;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = OLEOBJ_E_NOVERBS;
                }
            }
            DestroyMenu(hmenu);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pcm->Release();
    }

    return hr; // OleRegEnumVerbs(CLSID_CPackage, ppEnumOleVerb);
}

HRESULT CPackage::Update(void)
{
    DebugMsg(DM_TRACE, "pack - Update called");
    return S_OK;
}

    
HRESULT CPackage::IsUpToDate(void)
{
    DebugMsg(DM_TRACE, "pack - IsUpToDate called");
    return S_OK;
}

    
HRESULT CPackage::GetUserClassID(LPCLSID pClsid)
{
    DebugMsg(DM_TRACE, "pack - GetUserClassID called");
    *pClsid = CLSID_CPackage;       // CLSID_OldPackage;
    return S_OK;
}

    
HRESULT CPackage::GetUserType(DWORD dwFromOfType, LPOLESTR *pszUserType)
{
    DebugMsg(DM_TRACE, "pack - GetUserType called");
    return OleRegGetUserType(CLSID_CPackage, dwFromOfType, pszUserType);
}

    
HRESULT CPackage::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    DebugMsg(DM_TRACE, "pack - SetExtent called");
    return E_FAIL;
}

    
HRESULT CPackage::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    DebugMsg(DM_TRACE, "pack - GetExtent called");
    return GetExtent(dwDrawAspect, -1, NULL,psizel);
}

    
HRESULT CPackage::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE, "pack - Advise called");
    if (NULL == _pIOleAdviseHolder) 
    {
        hr = CreateOleAdviseHolder(&_pIOleAdviseHolder);
    }

    if(SUCCEEDED(hr))
    {
        hr = _pIOleAdviseHolder->Advise(pAdvSink, pdwConnection);
    }

    return hr;
}

    
HRESULT CPackage::Unadvise(DWORD dwConnection)
{
    HRESULT hr = E_FAIL;
    DebugMsg(DM_TRACE, "pack oo - Unadvise() called.");
    
    if (NULL != _pIOleAdviseHolder)
        hr = _pIOleAdviseHolder->Unadvise(dwConnection);
    
    return hr;
}

    
HRESULT CPackage::EnumAdvise(LPENUMSTATDATA *ppenumAdvise)
{
    HRESULT hr = E_FAIL;
    DebugMsg(DM_TRACE, "pack oo - EnumAdvise() called.");
    
    if (NULL != _pIOleAdviseHolder)
        hr = _pIOleAdviseHolder->EnumAdvise(ppenumAdvise);
    
    return hr;
}

    
HRESULT CPackage::GetMiscStatus(DWORD dwAspect, LPDWORD pdwStatus)
{
    DebugMsg(DM_TRACE, "pack - GetMiscStatus called");
    return OleRegGetMiscStatus(CLSID_CPackage, dwAspect, pdwStatus);
}


HRESULT CPackage::SetColorScheme(LPLOGPALETTE pLogpal)
{
    DebugMsg(DM_TRACE, "pack - SetColorScheme called");
    return E_NOTIMPL;
}


DEFINE_GUID(SID_targetGUID, 0xc7b318a8, 0xfc2c, 0x47e6, 0x8b, 0x2, 0x46, 0xa9, 0xc, 0xc9, 0x1b, 0x43);

// Wait for the spawned application to exit,then call back to the main thread to do some notifications
DWORD CALLBACK MainWaitOnChildThreadProc(void *lpv)
{
    DebugMsg(DM_TRACE, "pack oo - MainWaitOnChildThreadProc() called.");

    HRESULT hr;
    MAINWAITONCHILD *pmwoc = (MAINWAITONCHILD *)lpv;

    IOleCommandTarget * pIOleCommandTarget;

     // Unmarshal the IOleCommandTarget interface that we need to call back into the main thread interfaces
    hr = CoGetInterfaceAndReleaseStream(pmwoc->pIStreamIOleCommandTarget, IID_PPV_ARG(IOleCommandTarget, &pIOleCommandTarget));
    if(SUCCEEDED(hr))
    {
 
        DWORD ret = WaitForSingleObject(pmwoc->h, INFINITE);
        DebugMsg(DM_TRACE,"WaitForSingObject exits...ret==%d",ret);
        if(WAIT_OBJECT_0 == ret)
        {
            // Use the IOleCommandTarget interface to execute on the main thread.  Can't marshal _pIOleAdviseHolder
            pIOleCommandTarget->Exec(&SID_targetGUID, 0, 0, NULL, NULL);
            pIOleCommandTarget->Release();
        }
    }

    CloseHandle(pmwoc->h);
    delete pmwoc;
      
    DebugMsg(DM_TRACE, "            MainWaitOnChildThreadProc exiting.");
    

    return 0;
}

BOOL CALLBACK GetTaskWndProc(HWND hwnd, DWORD lParam)
{
    BOOL result = TRUE;
    DebugMsg(DM_TRACE, "pack oo - GetTaskWndProc() called.");
    
    if (IsWindowVisible(hwnd))
    {
        g_hTaskWnd = hwnd;
        result = FALSE;
    }
    return result;
}


// We need an IOLECache Interface to Keep Office97 happy.
HRESULT CPackage::Cache(FORMATETC * pFormatetc, DWORD advf, DWORD * pdwConnection)
{
    DebugMsg(DM_TRACE, "Cache called");
    return S_OK;
}

HRESULT CPackage::Uncache(DWORD dwConnection)
{
    DebugMsg(DM_TRACE, "Uncache called");
    return S_OK;
}

HRESULT CPackage::EnumCache(IEnumSTATDATA ** ppenumSTATDATA)
{
    DebugMsg(DM_TRACE, "EnumCache called - returning failure");
    return E_NOTIMPL;
}

HRESULT CPackage::InitCache(IDataObject *pDataObject)
{
    DebugMsg(DM_TRACE, "InitCache called");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\irunobj.cpp ===
#include "privcpp.h"


//////////////////////////////////
//
// IRunnable Object Methods...
//
// NOTE: To answer your question, yes, this is kind of a pointless interface,
// but some apps feel better when it's around.  Basically we just tell what
// they want to hear (ie. return S_OK).
//
HRESULT CPackage::GetRunningClass(LPCLSID pclsid)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE, "pack ro - GetRunningClass() called.");
    
    if (pclsid == NULL)
        hr = E_INVALIDARG;
    else
        *pclsid = CLSID_CPackage;
    return hr;
}

HRESULT CPackage::Run(LPBC lpbc)
{
    // we're an inproc-server, so telling us to run is kind of pointless
    DebugMsg(DM_TRACE, "pack ro - Run() called.");
    return S_OK;
}

BOOL CPackage::IsRunning() 
{
    DebugMsg(DM_TRACE, "pack ro - IsRunning() called.");
    // we're an inproc-server, so this is kind of pointless
    return TRUE;
} 

HRESULT CPackage::LockRunning(BOOL, BOOL)
{
    DebugMsg(DM_TRACE, "pack ro - LockRunning() called.");
    // again, we're an inproc-server, so this is also pointless
    return S_OK;
} 

HRESULT CPackage::SetContainedObject(BOOL)
{
    DebugMsg(DM_TRACE, "pack ro - SetContainedObject() called.");
    // again, we don't really care about this
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\iviewobj.cpp ===
#include "privcpp.h"

const DWORD g_cookie = 111176;

//
// IViewObject2 Methods...
//
HRESULT CPackage::Draw(DWORD dwDrawAspect, LONG lindex,
    LPVOID pvAspect, DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,BOOL (CALLBACK *pfnContinue)(ULONG_PTR),
    ULONG_PTR dwContinue)
{
    DebugMsg(DM_TRACE,"pack vo - Draw() called.");
    _IconDraw(_lpic, hdcDraw, (RECT *)lprcBounds);
    return S_OK;
}

    
HRESULT CPackage::GetColorSet(DWORD dwAspect, LONG lindex, 
                                LPVOID pvAspect, DVTARGETDEVICE *ptd, 
                                HDC hdcTargetDev, LPLOGPALETTE *ppColorSet)
{
    HRESULT hr = S_FALSE;
    DebugMsg(DM_TRACE,"pack vo - GetColorSet() called.");
    
    if (ppColorSet == NULL)
        hr = E_INVALIDARG;
    else
        *ppColorSet = NULL;         // null the out param

    return hr;
}

    
HRESULT CPackage::Freeze(DWORD dwDrawAspect, LONG lindex, 
                                      LPVOID pvAspect, LPDWORD pdwFreeze)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE,"pack vo - Freeze() called.");

    if (pdwFreeze == NULL)
        hr = E_INVALIDARG;
    else
    {
        if (_fFrozen) 
        {
            *pdwFreeze = g_cookie;
        }
        else
        {
            
            //
            // This is where we would take a snapshot of the icon to use as
            // the "frozen" image in subsequent routines.  For now, we just
            // return the cookie.  Draw() will use the current icon regardless 
            // of the fFrozen flag.
            //
            _fFrozen = TRUE;
            *pdwFreeze = g_cookie;
        }
    }
    
    return hr;
}

    
HRESULT CPackage::Unfreeze(DWORD dwFreeze)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE,"pack vo - Unfreeze() called.");
    
    // If the pass us an invalid cookie or we're not frozen then bail
    if (dwFreeze != g_cookie || !_fFrozen)
        hr = OLE_E_NOCONNECTION;
    else
    {
        // 
        // This is where we'd get rid of the frozen presentation we saved in
        // IViewObject::Freeze().
        //
        _fFrozen = FALSE;
    }
    return hr;
}

    
HRESULT CPackage::SetAdvise(DWORD dwAspects, DWORD dwAdvf,
                              LPADVISESINK pAdvSink)
{
    DebugMsg(DM_TRACE,"pack vo - SetAdvise() called.");
    
    if (_pViewSink)
        _pViewSink->Release();
    
    _pViewSink = pAdvSink;
    _dwViewAspects = dwAspects;
    _dwViewAdvf = dwAdvf;
    
    if (_pViewSink) 
        _pViewSink->AddRef();
    
    return S_OK;
}

    
HRESULT CPackage::GetAdvise(LPDWORD pdwAspects, LPDWORD pdwAdvf,
                              LPADVISESINK *ppAdvSink)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE,"pack vo - GetAdvise() called.");
    
    if (!ppAdvSink || !pdwAdvf || !pdwAspects)
        hr = E_INVALIDARG;
    else
    {
        
        *ppAdvSink = _pViewSink;
        _pViewSink->AddRef();
        
        if (pdwAspects != NULL)
            *pdwAspects = _dwViewAspects;
        
        if (pdwAdvf != NULL)
            *pdwAdvf = _dwViewAdvf;
    }

    return hr;
}

    
HRESULT CPackage::GetExtent(DWORD dwAspect, LONG lindex,
DVTARGETDEVICE *ptd, LPSIZEL pszl)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE,"pack vo - GetExtent() called.");

    if (pszl == NULL)
        hr = E_INVALIDARG;

    if (!_lpic)
        hr = OLE_E_BLANK;
    
    if(SUCCEEDED(hr))
    {
        pszl->cx = _lpic->rc.right;
        pszl->cy = _lpic->rc.bottom;
        
        pszl->cx = MulDiv(pszl->cx,HIMETRIC_PER_INCH,DEF_LOGPIXELSX);
        pszl->cy = MulDiv(pszl->cy,HIMETRIC_PER_INCH,DEF_LOGPIXELSY);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packager.cpp ===
#include "privcpp.h"

class ATL_NO_VTABLE CPackager :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComControl<CPackager>,
        public IOleObjectImpl<CPackager>,
        public IViewObjectExImpl<CPackager>,
        public IDataObject,
        public IPersistStorage,
        public IPersistFile,
        public IAdviseSink,
        public IRunnableObjectImpl<CPackager>
{
BEGIN_COM_MAP(CPackager)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IAdviseSink)
    COM_INTERFACE_ENTRY(IRunnableObject)
END_COM_MAP()

BEGIN_MSG_MAP(CPackager)
CHAIN_MSG_MAP(CComControl<CPackager>)
END_MSG_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\pack2cls.cpp ===
#include "privcpp.h"
#include "ids.h"
#include <advpub.h>

#define INITGUID
#include <initguid.h>
#include "packguid.h"

#define DECL_CRTFREE
#include <crtfree.h>

LONG g_cRefThisDll = 0;
HINSTANCE g_hinst = NULL;
HINSTANCE g_hinstResDLL = NULL;

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hinst = hDll;
        g_hinstResDLL = hDll;
#ifdef DEBUG
        CcshellGetDebugFlags();
#endif // DEBUG
        break;

    default:
        break;
    }

    return TRUE;
}

class CMyClassFactory : public IClassFactory
{
public:
    CMyClassFactory(REFCLSID rclsid);
    ~CMyClassFactory() { g_cRefThisDll--; }

    // IUnKnown
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

protected:
    LONG   _cRef;
    CLSID  _clsid;
};

CMyClassFactory::CMyClassFactory(REFCLSID rclsid) : _cRef(1), _clsid(rclsid)
{
    g_cRefThisDll++;
}

HRESULT CMyClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, IID_IClassFactory) || IsEqualGUID(riid, IID_IUnknown)) 
    {
        DebugMsg(DM_TRACE, "pack cf - QueryInterface called");

        _cRef++;
        *ppvObject = (IClassFactory *)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = E_NOINTERFACE;
    }

    return hres;
}

ULONG CMyClassFactory::AddRef(void)
{
    DebugMsg(DM_TRACE, "pack cf - AddRef called");
    return ++_cRef;
}

ULONG CMyClassFactory::Release(void)
{
    DebugMsg(DM_TRACE, "pack cf - Release called");

   LONG cRef = InterlockedDecrement( &_cRef );
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CMyClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvObject)
{
    DebugMsg(DM_TRACE, "CMyClassFactory::CreateInstance called");

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    IUnknown* punk;
    HRESULT hres;
    if (IsEqualGUID(_clsid, CLSID_CPackage))
    {
        hres = CPackage_CreateInstance(&punk);
    }
    else
    {
        return E_UNEXPECTED;
    }

    if (SUCCEEDED(hres))
    {
        hres = punk->QueryInterface(riid, ppvObject);
        punk->Release();
    }
    return hres;
}

HRESULT CMyClassFactory::LockServer(BOOL fLock)
{
    DebugMsg(DM_TRACE, "pack cf - LockServer called");
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvOut)
{
    DebugMsg(DM_TRACE, "pack - DllGetClassObject called");

    if (IsEqualGUID(rclsid,CLSID_CPackage))
    {
        CMyClassFactory *pmycls = new CMyClassFactory(rclsid);
        if (pmycls)
        {
            HRESULT hres = pmycls->QueryInterface(riid, ppvOut);
            pmycls->Release();
            return hres;
        }
        return E_OUTOFMEMORY;
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    DebugMsg(DM_TRACE, "pack - DllCanUnloadNow called");
    if (g_cRefThisDll)
    {
        return S_FALSE;
    }

    DebugMsg(DM_TRACE, "pack - DllCanUnloadNow returning S_OK (bye, bye...)");

    return S_OK;
}

// Call ADVPACK for the given section of our resource based INF>
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if ( pfnri )
        {
#ifdef WINNT
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
#else
            hr = pfnri(hInstance, szSection, NULL);
#endif
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(g_hinst, "RegDll");
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(g_hinst, "UnregDll");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\pack2.cpp ===
#include "privcpp.h"

#define CPP_FUNCTIONS
// #include <crtfree.h>


UINT    g_cfFileContents;
UINT    g_cfFileDescriptor;
UINT    g_cfObjectDescriptor;
UINT    g_cfEmbedSource;
UINT    g_cfFileNameW;

INT     g_cxIcon;
INT     g_cyIcon;
INT     g_cxArrange;
INT     g_cyArrange;
HFONT   g_hfontTitle;

BOOL gCmdLineOK = FALSE;    // this global flag will (eventually) be set by security policy in packager constructor
static TCHAR szUserType[] = TEXT("Package");
static TCHAR szDefTempFile[] = TEXT("PKG");

DEFINE_GUID(SID_targetGUID, 0xc7b318a8, 0xfc2c, 0x47e6, 0x8b, 0x2, 0x46, 0xa9, 0xc, 0xc9, 0x1b, 0x43);

CPackage::CPackage() : 
    _cRef(1)
{
    DebugMsg(DM_TRACE, "pack - CPackage() called.");
    g_cRefThisDll++;

    // Excel v.5 - v2000 has a hosting bug when they host an object as a link.
    // They always remove their hpmbed->hpobj object, yet all their methods
    // on the IOleClientSite interface they give us dereference this and fault.
    //
    _fNoIOleClientSiteCalls = FALSE;
    TCHAR szProcess[MAX_PATH];
    if (GetModuleFileName(NULL, szProcess, ARRAYSIZE(szProcess)) &&
        !lstrcmp(TEXT("EXCEL.EXE"), PathFindFileName(szProcess)))
    {
        DWORD dwVersionSize = GetFileVersionInfoSize(szProcess, 0);
        char * pVersionBuffer = new char[dwVersionSize];
        GetFileVersionInfo(szProcess, 0, ARRAYSIZE(szProcess), pVersionBuffer);
        VS_FIXEDFILEINFO * pVersionInfo;
        UINT dwVerLen;
        BOOL result = VerQueryValue(pVersionBuffer, L"\\", (LPVOID *) &pVersionInfo, &dwVerLen);
        if(result)
        {
            if(pVersionInfo->dwFileVersionLS < 0x0a0000)
                _fNoIOleClientSiteCalls = TRUE;
            else
                _fNoIOleClientSiteCalls = FALSE; // Except that they fixed it in version 10.
        }
        else
        {
            _fNoIOleClientSiteCalls = TRUE;
        }

        delete [] pVersionBuffer;
    }
    
    ASSERT(_cf == 0);
    ASSERT(_panetype == NOTHING);
}


CPackage::~CPackage()
{
    DebugMsg(DM_TRACE, "pack - ~CPackage() called.");
   
    // We should never be destroyed unless our ref count is zero.
    ASSERT(_cRef == 0);
    
    g_cRefThisDll--;
    
    // Destroy the packaged file structure...
    //
    _DestroyIC();
    
    // we destroy depending on which type of object we had packaged
    switch(_panetype)
    {
    case PEMBED:
        if (_pEmbed->pszTempName) 
        {
            DeleteFile(_pEmbed->pszTempName);
            delete [] _pEmbed->pszTempName;
        }
        delete _pEmbed;
    break;
        
    case CMDLINK:
        delete _pCml;
    break;

    }
    
    // Release Advise pointers...
    //
    if (_pIDataAdviseHolder)
        _pIDataAdviseHolder->Release();
    if (_pIOleAdviseHolder)
        _pIOleAdviseHolder->Release();
    if (_pIOleClientSite)
        _pIOleClientSite->Release();


    
    delete [] _lpszContainerApp;
    delete [] _lpszContainerObj;

    ReleaseContextMenu();
    if (NULL != _pVerbs)
    {
        for (ULONG i = 0; i < _cVerbs; i++)
        {
            delete _pVerbs[i].lpszVerbName;
        }
        delete _pVerbs;
    }
    

    DebugMsg(DM_TRACE,"CPackage being destroyed. _cRef == %d",_cRef);
}

HRESULT CPackage::Init() 
{
    // 
    // initializes parts of a package object that have a potential to fail
    // return:  S_OK            -- everything initialized
    //          E_FAIL          -- error in initialzation
    //          E_OUTOFMEMORY   -- out of memory
    //


    DebugMsg(DM_TRACE, "pack - Init() called.");
    
    // Get some system metrics that we'll need later...
    //
    LOGFONT lf;
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    SystemParametersInfo(SPI_ICONHORIZONTALSPACING, 0, &g_cxArrange, FALSE);
    SystemParametersInfo(SPI_ICONVERTICALSPACING, 0, &g_cyArrange, FALSE);
    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_hfontTitle = CreateFontIndirect(&lf);
    
    // register some clipboard formats that we support...
    //
    g_cfFileContents    = RegisterClipboardFormat(CFSTR_FILECONTENTS);
    g_cfFileDescriptor  = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
    g_cfObjectDescriptor= RegisterClipboardFormat(CFSTR_OBJECTDESCRIPTOR);
    g_cfEmbedSource     = RegisterClipboardFormat(CFSTR_EMBEDSOURCE);
    g_cfFileNameW       = RegisterClipboardFormat(TEXT("FileNameW"));
    
    // Get the value of the group policy (if it exists) for the "Software\Policies\Microsoft\Packager -- AllowCommandLinePackages key
    DWORD dwAllowCL = 0;
    DWORD dwDataType;
    DWORD dwcb = sizeof(DWORD);
    
    if(ERROR_SUCCESS == SHGetValue(
        HKEY_CURRENT_USER,
        L"Software\\Policies\\Microsoft\\Packager",
        L"AllowCommandLinePackages",
        &dwDataType,
        &dwAllowCL,
        &dwcb))
    {
        if(REG_DWORD == dwDataType && dwAllowCL)
        {
            gCmdLineOK = TRUE;
        }
    }

    // Initialize a generic icon
    _lpic = IconCreate();
    _IconRefresh();

    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
// IUnknown Methods...
//
////////////////////////////////////////////////////////////////////////

HRESULT CPackage::QueryInterface(REFIID riid, void ** ppv)
{

    DebugMsg(DM_TRACE, "pack - QueryInterface() called.");
    static const QITAB qit[] = 
    {
        QITABENT(CPackage, IOleObject),
        QITABENT(CPackage, IViewObject),
        QITABENT(CPackage, IViewObject2),
        QITABENT(CPackage, IDataObject),
        QITABENT(CPackage, IPersistStorage),
        QITABENT(CPackage, IPersistFile),
        QITABENT(CPackage, IAdviseSink),
        QITABENT(CPackage, IRunnableObject),
        QITABENT(CPackage, IEnumOLEVERB),
        QITABENT(CPackage, IOleCommandTarget),
        QITABENT(CPackage, IOleCache),
        QITABENT(CPackage, IExternalConnection),
        { 0 },
    };

    HRESULT hr =  QISearch(this, qit, riid, ppv);

    if(FAILED(hr))
    {
        DebugMsg(DM_TRACE, "pack - QueryInterface() failed! .");
    }

    return hr;
    
}

ULONG CPackage::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CPackage::Release()
{
   DebugMsg(DM_TRACE, "pack - Release() called.");
   ULONG cRef = InterlockedDecrement( &_cRef );
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CPackage_CreateInstance(LPUNKNOWN * ppunk)
{
    HRESULT hr = S_OK;
    DebugMsg(DM_TRACE, "pack - CreateInstance called");
    
    *ppunk = NULL;              // null the out param
 
    CPackage* pPack = new CPackage;
    if (!pPack)  
        hr = E_OUTOFMEMORY;
    else
    {
        if (FAILED(pPack->Init())) {
            delete pPack;
            hr = E_OUTOFMEMORY;
        }
    }    

    if(SUCCEEDED(hr))
    {
        hr = pPack->QueryInterface(IID_IUnknown, (void **) ppunk);
        pPack->Release();
    }

    return hr;
}

STDMETHODIMP CPackage::Next(ULONG celt, OLEVERB* rgVerbs, ULONG* pceltFetched)
{
    DebugMsg(DM_TRACE, "Next called");
    HRESULT hr;
    if (NULL != rgVerbs)
    {
        if (1 == celt)
        {
            if (_nCurVerb < _cVerbs)
            {
                ASSERT(NULL != _pVerbs);
                *rgVerbs = _pVerbs[_nCurVerb];
                if ((NULL != _pVerbs[_nCurVerb].lpszVerbName))
                {
                    DWORD cch = lstrlenW(_pVerbs[_nCurVerb].lpszVerbName) + 1;
                    if(NULL != (rgVerbs->lpszVerbName = (LPWSTR) CoTaskMemAlloc(cch * SIZEOF(WCHAR))))
                    {
                        StringCchCopy(rgVerbs->lpszVerbName, cch, _pVerbs[_nCurVerb].lpszVerbName);
                    }
                }
                _nCurVerb++;
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
            if (NULL != pceltFetched)
            {
                *pceltFetched = (S_OK == hr) ? 1 : 0;
            }
        }
        else if (NULL != pceltFetched)
        {
            int cVerbsToCopy = min(celt, _cVerbs - _nCurVerb);
            if (cVerbsToCopy > 0)
            {
                ASSERT(NULL != _pVerbs);
                CopyMemory(rgVerbs, &(_pVerbs[_nCurVerb]), cVerbsToCopy * sizeof(OLEVERB));
                for (int i = 0; i < cVerbsToCopy; i++)
                {
                    if ((NULL != _pVerbs[_nCurVerb + i].lpszVerbName))
                    {
                        DWORD cch = lstrlenW(_pVerbs[_nCurVerb + i].lpszVerbName) + 1;
                        if(NULL != (rgVerbs[i].lpszVerbName = (LPWSTR) CoTaskMemAlloc(cch * SIZEOF(WCHAR))))
                        {
                            StringCchCopy(rgVerbs[i].lpszVerbName, cch, _pVerbs[_nCurVerb + i].lpszVerbName);
                        }
                        else
                            return E_OUTOFMEMORY;
                    }
                }
                _nCurVerb += cVerbsToCopy;
            }
            *pceltFetched = (ULONG) cVerbsToCopy;
            hr = (celt == (ULONG) cVerbsToCopy) ? S_OK : S_FALSE;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CPackage::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, "Skip called");
    HRESULT hr = S_OK;

    if (_nCurVerb + celt > _cVerbs)
    {
        // there aren't enough elements, go to the end and return S_FALSE
        _nCurVerb = _cVerbs;
        hr = S_FALSE;
    }
    else
    {
        _nCurVerb += celt;
    }
    return hr;
}

STDMETHODIMP CPackage::Reset()
{
    DebugMsg(DM_TRACE, "pack - Reset() called.");
    _nCurVerb = 0;
    return S_OK;
}

STDMETHODIMP CPackage::Clone(IEnumOLEVERB** ppEnum)
{
    DebugMsg(DM_TRACE, "pack - Clone() called.");

    if (NULL != ppEnum)
    {
        *ppEnum = NULL;
    }
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////
//
// Package helper functions
//
///////////////////////////////////////////////////////////////////

HRESULT  CPackage::EmbedInitFromFile(LPCTSTR lpFileName, BOOL fInitFile) 
{
    DebugMsg(DM_TRACE, "pack - EmbedInitFromFile() called.");

    //
    // get's the file size of the packaged file and set's the name 
    // of the packaged file if fInitFile == TRUE.
    // return:  S_OK    -- initialized ok
    //          E_FAIL  -- error initializing file
    //
    
    DWORD dwSize;
    
    // if this is the first time we've been called, then we need to allocate
    // memory for the _pEmbed structure
    if (_pEmbed == NULL) 
    {
        _pEmbed = new EMBED;
        if (_pEmbed)
        {
            _pEmbed->pszTempName = NULL;
            _pEmbed->hTask = NULL;
            _pEmbed->poo = NULL;
            _pEmbed->fIsOleFile = TRUE;
        }
    }

    if (_pEmbed == NULL)
        return E_OUTOFMEMORY;

    
    // open the file to package...
    //
    HANDLE fh = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READWRITE, 
            NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL); 

    if (fh == INVALID_HANDLE_VALUE) 
    {
        DWORD dwError = GetLastError();
        return E_FAIL;
    }

    _panetype = PEMBED;
    
    // Get the size of the file
    _pEmbed->fd.nFileSizeLow = GetFileSize(fh, &dwSize);
    if (_pEmbed->fd.nFileSizeLow == 0xFFFFFFFF) 
    {
        DWORD dwError = GetLastError();
        return E_FAIL;
    }

    ASSERT(dwSize == 0);
    _pEmbed->fd.nFileSizeHigh = 0L;
    _pEmbed->fd.dwFlags = FD_FILESIZE;

    // We only want to set the filename if this is the file to be packaged.
    // If it's only a temp file that we're reloading (fInitFile == FALSE) then
    // don't bother setting the filename.
    //
    if (fInitFile) 
    {
        StringCchCopy(_pEmbed->fd.cFileName, ARRAYSIZE(_pEmbed->fd.cFileName), lpFileName);
        _DestroyIC();
        _lpic = _IconCreateFromFile(lpFileName);
        if (_pIDataAdviseHolder)
            _pIDataAdviseHolder->SendOnDataChange(this,0, NULL);
        if (_pViewSink)
            _pViewSink->OnViewChange(_dwViewAspects,_dwViewAdvf);
    }

    _fIsDirty = TRUE;
    CloseHandle(fh);
    return S_OK;
}    


HRESULT CPackage::CmlInitFromFile(LPTSTR lpFileName, BOOL fUpdateIcon, PANETYPE paneType) 
{
    DebugMsg(DM_TRACE, "pack - CmlINitFromFile() called.");

    // if this is the first time we've been called, then we need to allocate
    // memory for the _pCml structure
    if (_pCml == NULL) 
    {
        _pCml = new CML;
        if (_pCml)
        {
            // we don't use this, but an old packager accessing us might.
            _pCml->fCmdIsLink = FALSE;
        }
    }

    if (_pCml == NULL)
        return E_OUTOFMEMORY;

    _panetype = paneType;
    StringCchCopy(_pCml->szCommandLine, ARRAYSIZE(_pCml->szCommandLine), lpFileName);
    _fIsDirty = TRUE;
    
    if (fUpdateIcon)
    {
        _DestroyIC();
        _lpic = _IconCreateFromFile(lpFileName);
    
        if (_pIDataAdviseHolder)
            _pIDataAdviseHolder->SendOnDataChange(this, 0, NULL);
    
        if (_pViewSink)
            _pViewSink->OnViewChange(_dwViewAspects, _dwViewAdvf);
    }
    return S_OK;
}    


HRESULT CPackage::InitFromPackInfo(LPPACKAGER_INFO lppi)
{
    DebugMsg(DM_TRACE, "pack - InitFromPackInfo() called.");

    HRESULT hr = E_FAIL;
    
    // Ok, we need to test whether the user tried to package a folder
    // instead of a file.  If s/he did, then we'll just create a link
    // to that folder instead of an embedded file.
    //
    
    if (lppi->bUseCommandLine)
    {
        hr = CmlInitFromFile(lppi->szFilename, FALSE, CMDLINK);
    }
    else
    {
        // we pass FALSE here, because we don't want to write the icon
        hr = EmbedInitFromFile(lppi->szFilename, FALSE);
        StringCchCopy(_pEmbed->fd.cFileName, ARRAYSIZE(_pEmbed->fd.cFileName), lppi->szFilename);
        _panetype = PEMBED;
    }

    if(!SUCCEEDED(hr))
        return hr;

    // set the icon information    
    if (PathFileExists(lppi->szFilename))
    {
        StringCchCopy(_lpic->szIconPath, ARRAYSIZE(_lpic->szIconPath), *lppi->szIconPath? lppi->szIconPath : lppi->szFilename);
    }

    _lpic->iDlgIcon = lppi->iIcon;

    StringCchCopy(_lpic->szIconText, ARRAYSIZE(_lpic->szIconText), lppi->szLabel);
    _IconRefresh();

    // we need to tell the client we want to be saved...it should be smart
    // enough to do it anyway, but we can't take any chances.
    if (_pIOleClientSite)
        _pIOleClientSite->SaveObject();


    return hr;
}    

HRESULT CPackage::CreateTempFileName()
{
    ASSERT(NULL != _pEmbed);
    TCHAR szDefPath[MAX_PATH];
    if (_pEmbed->pszTempName)
    {
        return S_OK;
    }
    else if (GetTempPath(ARRAYSIZE(szDefPath), szDefPath))
    {
        LPTSTR pszFile;
        pszFile = PathFindFileName(_pEmbed->fd.cFileName);
        if(!PathAppend(szDefPath, pszFile))
            return E_FAIL;

        HRESULT hr;
        if (PathFileExists(szDefPath))
        {
            TCHAR szOriginal[MAX_PATH];
            StringCchCopy(szOriginal, ARRAYSIZE(szOriginal), szDefPath);
            hr = PathYetAnotherMakeUniqueName(szDefPath, szOriginal, NULL, NULL)
                ? S_OK
                : E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
        if (SUCCEEDED(hr))
        {
            DWORD cch = lstrlen(szDefPath) + 1;
            _pEmbed->pszTempName = new TCHAR[cch];
            if (!_pEmbed->pszTempName) 
            {
                DebugMsg(DM_TRACE,"            couldn't alloc memory for pszTempName!!");
                return E_OUTOFMEMORY;
            }    
            StringCchCopy(_pEmbed->pszTempName, cch, szDefPath);
        }
        return hr;
    }
    else
    {
        DebugMsg(DM_TRACE,"            couldn't get temp path!!");
        return E_FAIL;
    }
}

HRESULT CPackage::CreateTempFile(bool deleteExisting) 
{
    //
    // used to create a temporary file that holds the file contents of the
    // packaged file.  the old packager used to keep the packaged file in 
    // memory which is just a total waste.  so, being as we're much more 
    // efficient, we create a temp file whenever someone wants to do something
    // with our contents.  we initialze the temp file from the original file
    // to package or our persistent storage depending on whether we are a new
    // package or a loaded package
    // return:  S_OK    -- temp file created
    //          E_FAIL  -- error creating temp file
    //
    
    DebugMsg(DM_TRACE,"            CreateTempFile() called.");


    HRESULT hr = CreateTempFileName();
    if (FAILED(hr))
    {
        return hr;
    }


    if (_pEmbed->pszTempName && PathFileExists(_pEmbed->pszTempName))
    {
        DebugMsg(DM_TRACE,"            already have a temp file!!");
        if(!deleteExisting)
            return S_OK;
        else
        {
            DeleteFile(_pEmbed->pszTempName);
        }
    }
    
    // if we weren't loaded from a storage then we're in the process of
    // creating a package, and should be able to copy the packaged file
    // to create a temp file
    //
    if (!_fLoaded) 
    {
        if (!(CopyFile(_pEmbed->fd.cFileName, _pEmbed->pszTempName, FALSE))) 
        {
            DebugMsg(DM_TRACE,"            couldn't copy file!!");
            return E_FAIL;
        }
    }
    else 
    {
        // nothing to do, we've already loaded it.  temp file must exist
        ASSERT(_pEmbed);
        ASSERT(_pEmbed->pszTempName);
    }
    
    // whenever we create a tempfile we are activating the contents which 
    // means we are dirty until we get a save message
    return S_OK;
}



///////////////////////////////////////////////////////////////////////
//
// Data Transfer Functions
//
///////////////////////////////////////////////////////////////////////

HRESULT CPackage::GetFileDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM) 
{
    DebugMsg(DM_TRACE, "pack - GetFileDescriptor called");
    FILEGROUPDESCRIPTOR *pfgd;

    HRESULT hr = S_OK;
    
    DebugMsg(DM_TRACE,"            Getting File Descriptor");

    // we only support HGLOBAL at this time
    //
    if (!(pFE->tymed & TYMED_HGLOBAL)) {
        DebugMsg(DM_TRACE,"            does not support HGLOBAL!");
        return DATA_E_FORMATETC;
    }

    //// Copy file descriptor to HGLOBAL ///////////////////////////
    //
    pSTM->tymed = TYMED_HGLOBAL;
    
    // render the file descriptor 
    if (!(pfgd = (FILEGROUPDESCRIPTOR *)GlobalAlloc(GPTR,
        sizeof(FILEGROUPDESCRIPTOR))))
        return E_OUTOFMEMORY;

    pSTM->hGlobal = pfgd;
    
    pfgd->cItems = 1;

    switch(_panetype) 
    {
        case PEMBED:
            pfgd->fgd[0] = _pEmbed->fd;
            GetDisplayName(pfgd->fgd[0].cFileName, _pEmbed->fd.cFileName);  // This is packagers, not the shell (for now)
            break;

        case CMDLINK:
            // the label for the package will serve as the filename for the
            // shortcut we're going to create.
            hr = StringCchCopy(pfgd->fgd[0].cFileName, ARRAYSIZE(pfgd->fgd[0].cFileName), _lpic->szIconText);
            // harcoded use of .lnk extension!!
            if(SUCCEEDED(hr))
            {
                hr = StringCchCat(pfgd->fgd[0].cFileName, ARRAYSIZE(pfgd->fgd[0].cFileName), TEXT(".lnk"));
            }

            // we want to add the little arrow to the shortcut.
            pfgd->fgd[0].dwFlags = FD_LINKUI;
            break;
    }

    return hr;
}

HRESULT CPackage::GetFileContents(LPFORMATETC pFE, LPSTGMEDIUM pSTM) 
{
    void *  lpvDest = NULL;
    DWORD   dwSize;
    HANDLE  hFile = NULL;
    HRESULT hr = E_FAIL;
    
    DebugMsg(DM_TRACE,"            Getting File Contents");
    
    //// Copy file contents to ISTREAM ///////////////////////////
    // 
    // NOTE: Hopefully, everyone using our object supports TYMED_ISTREAM,
    // otherwise we could get some really slow behavior.  We might later
    // want to implement TYMED_ISTORAGE as well and shove our file contents
    // into a single stream named CONTENTS.
    //
    if (pFE->tymed & TYMED_ISTREAM) 
    {
        DWORD dwFileLength;
        DebugMsg(DM_TRACE,"            using TYMED_ISTREAM");
        pSTM->tymed = TYMED_ISTREAM;

        hr = CreateStreamOnHGlobal(NULL, TRUE, &pSTM->pstm);
        if (SUCCEEDED(hr))
        {
            switch (_panetype)
            {
                case PEMBED:
                    hr = CopyFileToStream(_pEmbed->pszTempName, pSTM->pstm, &dwFileLength);
                    break;

                case CMDLINK:
                    hr = CreateShortcutOnStream(pSTM->pstm);
                    break;
            }
        }

        if (FAILED(hr))
        {
            pSTM->pstm->Release();
            pSTM->pstm = NULL;
        }
        return hr;
    }
    
    //// Copy file contents to HGLOBAL ///////////////////////////
    //
    // NOTE: This is really icky and could potentially be very slow if
    // somebody decides to package really large files.  Hopefully, 
    // everyone should be able to get the info it wants through TYMED_ISTREAM,
    // but this is here as a common denominator
    //
    if (pFE->tymed & TYMED_HGLOBAL)
    {
        DebugMsg(DM_TRACE,"            using TYMED_HGLOBAL");
        pSTM->tymed = TYMED_HGLOBAL;

        if (_panetype == CMDLINK) 
        {
            DebugMsg(DM_TRACE, "    H_GLOBAL not supported for CMDLINK");
            return DATA_E_FORMATETC;
        }
        
        dwSize = _pEmbed->fd.nFileSizeLow;
        
        // caller is responsible for freeing this memory, even if we fail.
        if (!(lpvDest = GlobalAlloc(GPTR, dwSize))) 
        {
            DebugMsg(DM_TRACE,"            out o memory!!");
            return E_OUTOFMEMORY;
        }
        pSTM->hGlobal = lpvDest;

        // open file to copy to stream
        hFile = CreateFile(_pEmbed->pszTempName, GENERIC_READ,
                           FILE_SHARE_READWRITE, NULL,
                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            DebugMsg(DM_TRACE, "         couldn't open file!!");
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrRet;
        }

        DWORD dwSizeLow;
        DWORD dwSizeHigh;

        // Figure out how much to copy...
        dwSizeLow = GetFileSize(hFile, &dwSizeHigh);
        ASSERT(dwSizeHigh == 0);

        SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);

        // read in the file
        DWORD cbRead;
        if (ReadFile(hFile, lpvDest, dwSize, &cbRead, NULL))
        {
            return S_OK;
        }
        else
        {
            hr = E_FAIL;
        }

ErrRet:
        CloseHandle(hFile);
        GlobalFree(pSTM->hGlobal);
        pSTM->hGlobal = NULL;
        return hr;
    }

    return DATA_E_FORMATETC;
}



void CPackage::_DrawIconToDC(HDC hdcMF, LPIC lpic, bool stripAlpha, LPCTSTR pszActualFileName)
{
    RECT  rcTemp;
    HFONT hfont = NULL;

    // Initializae the metafile
    _IconCalcSize(lpic);
    SetWindowOrgEx(hdcMF, 0, 0, NULL);
    SetWindowExtEx(hdcMF, lpic->rc.right - 1, lpic->rc.bottom - 1, NULL);

    SetRect(&rcTemp, 0, 0, lpic->rc.right,lpic->rc.bottom);
    hfont = SelectFont(hdcMF, g_hfontTitle);
    
    // Center the icon
    if(stripAlpha)
        AlphaStripRenderIcon(hdcMF, (rcTemp.right - g_cxIcon) / 2, 0, lpic->hDlgIcon, NULL);
    else
        DrawIcon(hdcMF, (rcTemp.right - g_cxIcon) / 2, 0, lpic->hDlgIcon);
    
    // Center the text below the icon
    SetBkMode(hdcMF, TRANSPARENT);
    SetTextAlign(hdcMF, TA_CENTER);


    // Set's the icon text for MF ie Word display's it from here. 
    WCHAR szLabel[MAX_PATH];
    _CreateSaferIconTitle(szLabel, lpic->szIconText);

    TextOut(hdcMF, rcTemp.right / 2, g_cxIcon + 1, szLabel, lstrlen(szLabel));

    if (hfont)
        SelectObject(hdcMF, hfont);
}


HRESULT CPackage::GetEnhMetafile(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DebugMsg(DM_TRACE,"            Getting EnhancedMetafile");
    
    if (!(pFE->tymed & TYMED_ENHMF)) 
    {
        DebugMsg(DM_TRACE,"            does not support ENHMF!");
        return DATA_E_FORMATETC;
    }

    // Map to device independent coordinates
    RECT rcTemp;
    SetRect(&rcTemp, 0, 0, _lpic->rc.right,_lpic->rc.bottom);
    rcTemp.right = MulDiv((rcTemp.right - rcTemp.left), HIMETRIC_PER_INCH, DEF_LOGPIXELSX);
    rcTemp.bottom = MulDiv((rcTemp.bottom - rcTemp.top), HIMETRIC_PER_INCH, DEF_LOGPIXELSY);

    HDC hdc = CreateEnhMetaFile(NULL, NULL, &rcTemp, NULL);
    if (hdc)
    {
        _DrawIconToDC(hdc, _lpic, false, _pEmbed->fd.cFileName);
        pSTM->tymed = TYMED_ENHMF;
        pSTM->hEnhMetaFile = CloseEnhMetaFile(hdc);

        return S_OK;
    }
    else
    {
        pSTM->tymed = TYMED_NULL;
        return E_OUTOFMEMORY;
    }
}


HRESULT CPackage::GetMetafilePict(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    LPMETAFILEPICT      lpmfpict;
    RECT                rcTemp;
    LPIC                lpic = _lpic;
    HDC                 hdcMF = NULL;
    
    
    DebugMsg(DM_TRACE,"            Getting MetafilePict");
    
    if (!(pFE->tymed & TYMED_MFPICT)) 
    {
        DebugMsg(DM_TRACE,"            does not support MFPICT!");
        return DATA_E_FORMATETC;
    }
    pSTM->tymed = TYMED_MFPICT;
    
    // Allocate memory for the metafilepict and get a pointer to it
    // NOTE: the caller is responsible for freeing this memory, even on fail
    //
    if (!(pSTM->hMetaFilePict = GlobalAlloc(GPTR, sizeof(METAFILEPICT))))
        return E_OUTOFMEMORY;
    lpmfpict = (LPMETAFILEPICT)pSTM->hMetaFilePict;
        
    // Create the metafile
    if (!(hdcMF = CreateMetaFile(NULL))) 
        return E_OUTOFMEMORY;

    _DrawIconToDC(hdcMF, _lpic, true, _pEmbed->fd.cFileName);

    // Map to device independent coordinates
    SetRect(&rcTemp, 0, 0, lpic->rc.right,lpic->rc.bottom);
    rcTemp.right =
        MulDiv((rcTemp.right - rcTemp.left), HIMETRIC_PER_INCH, DEF_LOGPIXELSX);
    rcTemp.bottom =
        MulDiv((rcTemp.bottom - rcTemp.top), HIMETRIC_PER_INCH, DEF_LOGPIXELSY);

    // Finish filling in the metafile header
    lpmfpict->mm = MM_ANISOTROPIC;
    lpmfpict->xExt = rcTemp.right;
    lpmfpict->yExt = rcTemp.bottom;
    lpmfpict->hMF = CloseMetaFile(hdcMF);
    
    return S_OK;
}


HRESULT CPackage::GetObjectDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM) 
{
    LPOBJECTDESCRIPTOR lpobj;
    DWORD   dwFullUserTypeNameLen;
    
    DebugMsg(DM_TRACE,"            Getting Object Descriptor");

    // we only support HGLOBAL at this time
    //
    if (!(pFE->tymed & TYMED_HGLOBAL)) 
    {
        DebugMsg(DM_TRACE,"            does not support HGLOBAL!");
        return DATA_E_FORMATETC;
    }

    //// Copy file descriptor to HGLOBAL ///////////////////////////

    dwFullUserTypeNameLen = 0; //lstrlen(szUserType) + 1;
    pSTM->tymed = TYMED_HGLOBAL;

    if (!(lpobj = (OBJECTDESCRIPTOR *)GlobalAlloc(GPTR,
        sizeof(OBJECTDESCRIPTOR)+dwFullUserTypeNameLen)))
        return E_OUTOFMEMORY;

    pSTM->hGlobal = lpobj;
    
    lpobj->cbSize       = sizeof(OBJECTDESCRIPTOR) + dwFullUserTypeNameLen;
    lpobj->clsid        = CLSID_CPackage;
    lpobj->dwDrawAspect = DVASPECT_CONTENT|DVASPECT_ICON;
    GetMiscStatus(DVASPECT_CONTENT|DVASPECT_ICON,&(lpobj->dwStatus));
    lpobj->dwFullUserTypeName = 0L; //sizeof(OBJECTDESCRIPTOR);
    lpobj->dwSrcOfCopy = 0L;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////
//
// Stream I/O Functions
//
/////////////////////////////////////////////////////////////////////////

HRESULT CPackage::PackageReadFromStream(IStream* pstm)
{
    //
    // initialize the package object from a stream
    // return:  s_OK   - package properly initialized
    //          E_FAIL - error initializing package
    //
    
    WORD  w;
    DWORD dw;
    
    DebugMsg(DM_TRACE, "pack - PackageReadFromStream called.");

    // read in the package size, which we don't really need, but the old 
    // packager puts it there.
    if (FAILED(pstm->Read(&dw, sizeof(dw), NULL)))
        return E_FAIL;

    // NOTE: Ok, this is really dumb.  The old packager allowed the user
    // to create packages without giving them icons or labels, which
    // in my opinion is just dumb, it should have at least created a default
    // icon and shoved it in the persistent storage...oh well...
    //     So if the appearance type comes back as NOTHING ( == 0)
    // then we just won't read any icon information.
    
    // read in the appearance type
    pstm->Read(&w, sizeof(w), NULL);
    
    // read in the icon information
    if (w == (WORD)ICON)
    {
        if (FAILED(IconReadFromStream(pstm))) 
        {
            DebugMsg(DM_TRACE,"         error reading icon info!!");
            return E_FAIL;
        }
    }
    else if (w == (WORD)PICTURE)
    {
        DebugMsg(DM_TRACE, "         old Packager Appearance, not supported!!");
        // NOTE: Ideally, we could just ignore the appearance and continue, but to
        // do so, we'll need to know how much information to skip over before continuing
        // to read from the stream
#ifdef USE_RESOURCE_DLL
    HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    if(!hInstRes)
        return E_FAIL;
#endif

        ShellMessageBox(hInstRes,
                        NULL,
                        MAKEINTRESOURCE(IDS_OLD_FORMAT_ERROR),
                        MAKEINTRESOURCE(IDS_APP_TITLE),
                        MB_OK | MB_ICONERROR | MB_TASKMODAL);
#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif
        return E_FAIL;
    }
    
    // read in the contents type
    pstm->Read(&w, sizeof(w), NULL);

    _panetype = (PANETYPE)w;
    
    switch((PANETYPE)w)
    {
    case PEMBED:
        // read in the contents information
        return EmbedReadFromStream(pstm);

    case CMDLINK:
        // read in the contents information
        return CmlReadFromStream(pstm); 

    default:
        return E_FAIL;
    }
}

//
// read the icon info from a stream
// return:  S_OK   -- icon read correctly
//          E_FAIL -- error reading icon
//
HRESULT CPackage::IconReadFromStream(IStream* pstm) 
{
    UINT cb;
    DebugMsg(DM_TRACE, "pack - IconReadFromStream() called.");

    LPIC lpic = IconCreate();
    if (lpic)
    {
        CHAR szTemp[MAX_PATH];
        cb = (UINT) StringReadFromStream(pstm, szTemp, ARRAYSIZE(szTemp));
        SHAnsiToTChar(szTemp, lpic->szIconText, ARRAYSIZE(lpic->szIconText));
        
        cb = (UINT) StringReadFromStream(pstm, szTemp, ARRAYSIZE(szTemp));
        SHAnsiToTChar(szTemp, lpic->szIconPath, ARRAYSIZE(lpic->szIconPath));
      
        WORD wDlgIcon;
        pstm->Read(&wDlgIcon, sizeof(wDlgIcon), NULL);
        lpic->iDlgIcon = (INT) wDlgIcon;
        _GetCurrentIcon(lpic);
        _IconCalcSize(lpic);
    }

    _DestroyIC();
    _lpic = lpic;

    return lpic ? S_OK : E_FAIL;
}

HRESULT CPackage::EmbedReadFromStream(IStream* pstm) 
{
    //
    // reads embedded file contents from a stream
    // return:  S_OK   - contents read succesfully
    //          E_FAIL - error reading contents
    //

    DWORD dwSize;
    DWORD cb;
    CHAR  szFileName[MAX_PATH];
    
    DebugMsg(DM_TRACE, "pack - EmbedReadFromStream called.");
    
    pstm->Read(&dwSize, sizeof(dwSize), &cb);  // get string size
    if(dwSize < MAX_PATH)
    {
        pstm->Read(szFileName, dwSize, &cb);       // get string
    }
    else
        return E_FAIL;

    pstm->Read(&dwSize, sizeof(dwSize), &cb);  // get file size

    if (_pEmbed) 
    {
        if (_pEmbed->pszTempName) 
        {
            DeleteFile(_pEmbed->pszTempName);
            delete [] _pEmbed->pszTempName;
        }
        delete _pEmbed;
    }

    _pEmbed = new EMBED;
    if (NULL != _pEmbed)
    {
        _pEmbed->fd.dwFlags = FD_FILESIZE;
        _pEmbed->fd.nFileSizeLow = dwSize;
        _pEmbed->fd.nFileSizeHigh = 0;
        _pEmbed->fIsOleFile = TRUE;     // Give it a chance to do ole style launch
        SHAnsiToTChar(szFileName, _pEmbed->fd.cFileName, ARRAYSIZE(_pEmbed->fd.cFileName));

        DebugMsg(DM_TRACE,"         %s\n\r         %d",_pEmbed->fd.cFileName,_pEmbed->fd.nFileSizeLow);

        HRESULT hr = CreateTempFileName();
        if (FAILED(hr))
        {
            return hr;
        }

        if (FAILED(CopyStreamToFile(pstm, _pEmbed->pszTempName, _pEmbed->fd.nFileSizeLow)))
        {
            DebugMsg(DM_TRACE,"            couldn't copy from stream!!");
            return E_FAIL;
        }
        return S_OK;

    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

HRESULT CPackage::CmlReadFromStream(IStream* pstm)
{
    //
    // reads command line contents from a stream
    // return:  S_OK   - contents read succesfully
    //          E_FAIL - error reading contents
    //
    DebugMsg(DM_TRACE, "pack - CmlReadFromStream() called.");

    WORD w;
    CHAR  szCmdLink[CBCMDLINKMAX];
    
    DebugMsg(DM_TRACE, "pack - CmlReadFromStream called.");

    // read in the fCmdIsLink and the command line string
    if (FAILED(pstm->Read(&w, sizeof(w), NULL)))    
        return E_FAIL;
    StringReadFromStream(pstm, szCmdLink, ARRAYSIZE(szCmdLink));

    if (_pCml != NULL)
        delete _pCml;
    
    _pCml = new CML;
    SHAnsiToTChar(szCmdLink, _pCml->szCommandLine, ARRAYSIZE(_pCml->szCommandLine));
    
    return S_OK;
}    
    

HRESULT CPackage::PackageWriteToStream(IStream* pstm)
{
    //
    // write the package object to a stream
    // return:  s_OK   - package properly written
    //          E_FAIL - error writing package
    //
    
    WORD w;
    DWORD cb = 0L;
    DWORD dwSize;

  
    DebugMsg(DM_TRACE, "pack - PackageWriteToStream called.");

    // write out a DWORD where the package size will go
    if (FAILED(pstm->Write(&cb, sizeof(DWORD), NULL)))
        return E_FAIL;

    cb = 0;
   
    // write out the appearance type
    w = (WORD)ICON;
    if (FAILED(pstm->Write(&w, sizeof(WORD), NULL)))
        return E_FAIL;
    cb += sizeof(WORD);
    
    // write out the icon information
    if (FAILED(IconWriteToStream(pstm,&dwSize))) 
    {
        DebugMsg(DM_TRACE,"         error writing icon info!!");
        return E_FAIL;
    }
    cb += dwSize;

    // write out the contents type
    w = (WORD)_panetype;
    if (FAILED(pstm->Write(&_panetype, sizeof(WORD), NULL)))
        return E_FAIL;
    cb += sizeof(WORD);

    switch(_panetype) 
    {
        case PEMBED:
            
            // write out the contents information
            if (FAILED(EmbedWriteToStream(pstm,&dwSize))) 
            {
                DebugMsg(DM_TRACE,"         error writing embed info!!");
                return E_FAIL;
            }

            cb += dwSize;
            break;

        case CMDLINK:
            // write out the contents information
            if (FAILED(CmlWriteToStream(pstm,&dwSize))) 
            {
                DebugMsg(DM_TRACE,"         error writing cml info!!");
                return E_FAIL;
            }

            cb += dwSize;
            break;
    }
    
    LARGE_INTEGER li = {0, 0};
    if (FAILED(pstm->Seek(li, STREAM_SEEK_SET, NULL)))
        return E_FAIL;
    if (FAILED(pstm->Write(&cb, sizeof(DWORD), NULL)))
        return E_FAIL;

    return S_OK;
}


//
// write the icon to a stream
// return:  s_OK   - icon properly written
//          E_FAIL - error writing icon
//
HRESULT CPackage::IconWriteToStream(IStream* pstm, DWORD *pdw)
{
    ASSERT(pdw);
    DebugMsg(DM_TRACE, "pack - IconWriteToStream() called.");

    CHAR szTemp[MAX_PATH];
    SHTCharToAnsi(_lpic->szIconText, szTemp, ARRAYSIZE(szTemp));
    *pdw = 0;
    HRESULT hr = StringWriteToStream(pstm, szTemp, pdw);
    if (SUCCEEDED(hr))
    {
        SHTCharToAnsi(_lpic->szIconPath, szTemp, ARRAYSIZE(szTemp));
        hr = StringWriteToStream(pstm, szTemp, pdw);

        if (SUCCEEDED(hr))
        {
            DWORD dwWrite;
            WORD wDlgIcon = (WORD) _lpic->iDlgIcon;
            hr = pstm->Write(&wDlgIcon, sizeof(wDlgIcon), &dwWrite);
            if (SUCCEEDED(hr))
            {
                *pdw += dwWrite;
            }
        }
    }
    return hr;
}

//
// write embedded file contents to a stream
// return:  S_OK   - contents written succesfully
//          E_FAIL - error writing contents
//
HRESULT CPackage::EmbedWriteToStream(IStream* pstm, DWORD *pdw)
{
    DebugMsg(DM_TRACE, "pack - EmbedWriteToStream() called.");

    DWORD cb = 0;
    CHAR szTemp[MAX_PATH];
    SHTCharToAnsi(_pEmbed->fd.cFileName, szTemp, ARRAYSIZE(szTemp));
    DWORD dwSize = lstrlenA(szTemp) + 1;
    HRESULT hr = pstm->Write(&dwSize, sizeof(dwSize), &cb);
    if (SUCCEEDED(hr))
    {
        DWORD dwWrite = 0;
        hr = StringWriteToStream(pstm, szTemp, &dwWrite);

        if (SUCCEEDED(hr))
        {
            cb += dwWrite;
            hr = pstm->Write(&_pEmbed->fd.nFileSizeLow, sizeof(_pEmbed->fd.nFileSizeLow), &dwWrite);
            if (SUCCEEDED(hr))
            {
                cb += dwWrite;

                // This is for screwy apps, like MSWorks that ask us to save ourselves 
                // before they've even told us to initialize ourselves.  
                //
                if (_pEmbed->pszTempName && _pEmbed->pszTempName[0])
                {
                    DWORD dwFileSize;
                    hr = CopyFileToStream(_pEmbed->pszTempName, pstm, &dwFileSize);
                    if (SUCCEEDED(hr))
                    {
                        cb += dwFileSize;
                    }
                }
                else
                {
                    ASSERT(0);
                    hr = E_FAIL;
                }

                if (pdw)
                    *pdw = cb;
            }
        }
    }
    return hr;
}

//
// write embedded file contents to a stream
// return:  S_OK   - contents written succesfully
//          E_FAIL - error writing contents
//
HRESULT CPackage::CmlWriteToStream(IStream* pstm, DWORD *pdw)
{
    DWORD cb = 0;
    WORD w = (WORD)_pCml->fCmdIsLink;
    
    DebugMsg(DM_TRACE, "pack - CmlWriteToStream called.");

    if (FAILED(pstm->Write(&w, sizeof(w), NULL)))
        return E_FAIL;                                   // write fCmdIsLink
    cb += sizeof(w);      // for fCmdIsLink

    CHAR szTemp[MAX_PATH];
    SHTCharToAnsi(_pCml->szCommandLine, szTemp, ARRAYSIZE(szTemp));
    HRESULT hres = StringWriteToStream(pstm, szTemp, &cb);
    if (FAILED(hres))
        return hres;                                   // write command link

    // return the number of bytes written in the outparam    
    if (pdw)
        *pdw = cb;
    
    return S_OK;
}


HRESULT CPackage::CreateShortcutOnStream(IStream* pstm)
{
    DebugMsg(DM_TRACE, "pack - CreateShortcutOnStream() called.");

    HRESULT hr;
    IShellLink *psl;
    TCHAR szArgs[CBCMDLINKMAX];
    TCHAR szPath[CBCMDLINKMAX];
    
    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
        IID_IShellLink, (void **)&psl);
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;

        StringCchCopy(szPath, ARRAYSIZE(szPath), _pCml->szCommandLine);
        PathSeparateArgs(szPath, szArgs, ARRAYSIZE(szPath));

        psl->SetPath(szPath);
        psl->SetIconLocation(_lpic->szIconPath, _lpic->iDlgIcon);
        psl->SetShowCmd(SW_SHOW);
        psl->SetArguments(szArgs);
        
        hr = psl->QueryInterface(IID_IPersistStream, (void **)&pps);
        if (SUCCEEDED(hr))
        {
            hr = pps->Save(pstm,TRUE);
            pps->Release();
        }
        psl->Release();
    }
    
    LARGE_INTEGER li = {0,0};
    pstm->Seek(li,STREAM_SEEK_SET,NULL);

    return hr;
}

HRESULT CPackage::InitVerbEnum(OLEVERB* pVerbs, ULONG cVerbs)
{
    DebugMsg(DM_TRACE, "pack - InitVerbEnum called");
    if (NULL != _pVerbs)
    {
        for (ULONG i = 0; i < _cVerbs; i++)
        {
            delete _pVerbs[i].lpszVerbName;
        }
        delete [] _pVerbs;
    }

    _pVerbs = pVerbs;
    _cVerbs = cVerbs;
    _nCurVerb = 0;
    return (NULL != pVerbs) ? S_OK : E_FAIL;
}


VOID CPackage::ReleaseContextMenu()
{
    if (NULL != _pcm)
    {
        _pcm->Release();
        _pcm = NULL;
    }
}

HRESULT CPackage::GetContextMenu(IContextMenu** ppcm)
{
    DebugMsg(DM_TRACE, "pack - GetContextMenu called");
    HRESULT hr = E_FAIL;
    ASSERT(NULL != ppcm);
    if (NULL != _pcm)
    {
        _pcm->AddRef();
        *ppcm = _pcm;
        hr = S_OK;
    }
    else if ((PEMBED == _panetype) || (CMDLINK == _panetype))
    {
        if (PEMBED == _panetype)
        {
            hr = CreateTempFileName();
        }
        else
        {
            hr = S_OK;
        }
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl = SHSimpleIDListFromPath((PEMBED == _panetype) ?
                                                        _pEmbed->pszTempName :
                                                        _pCml->szCommandLine);
            if (NULL != pidl)
            {
                IShellFolder* psf;
                LPCITEMIDLIST pidlChild;
                if (SUCCEEDED(hr = SHBindToIDListParent(pidl, IID_IShellFolder, (void **)&psf, &pidlChild)))
                {
                    hr = psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_IContextMenu, NULL, (void**) &_pcm);
                    if (SUCCEEDED(hr))
                    {
                        _pcm->AddRef();
                        *ppcm = _pcm;
                    }
                    psf->Release();
                }
                ILFree(pidl);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

HRESULT CPackage::_IconRefresh()
{
    DebugMsg(DM_TRACE, "pack - IconRefresh() called.");

    // we refresh the icon.  typically, this will be called the first time
    // the package is created to load the new icon and calculate how big
    // it should be.  this will also be called after we edit the package,
    // since the user might have changed the icon.
    
    // First, load the appropriate icon.  We'll load the icon specified by
    // lpic->szIconPath and lpic->iDlgIcon if possible, otherwise we'll just
    // use the generic packager icon.
    //
    _GetCurrentIcon(_lpic);

    // Next, we need to have the icon recalculate its size, since it's text
    // might have changed, causing it to get bigger or smaller.
    //
  
    _IconCalcSize(_lpic);

    // Next, notify our containers that our view has changed.
    if (_pIDataAdviseHolder)
        _pIDataAdviseHolder->SendOnDataChange(this,0, NULL);
    if (_pViewSink)
        _pViewSink->OnViewChange(_dwViewAspects,_dwViewAdvf);

    // Set our dirty flag
    _fIsDirty = TRUE;

    return S_OK;
}

    

void CPackage::_DestroyIC()
{
    if (_lpic)
    {
        if (_lpic->hDlgIcon)
            DestroyIcon(_lpic->hDlgIcon);
        
        GlobalFree(_lpic);
    }
}


// This is an IOleCommandTarget method that we use because we cannot marshal the pIOleAdviseHolder.
// While we're at it, we use the _pIOleClientSite methods too.

HRESULT CPackage::Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    DebugMsg(DM_TRACE, "pack Exec called");
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup != SID_targetGUID)
    {
        return hr;
    }

    if(nCmdID == 0)     // for future expansion
    {
        // this will set our dirty flag...
        if (FAILED(EmbedInitFromFile(_pEmbed->pszTempName,FALSE)))
        {
#ifdef USE_RESOURCE_DLL
            HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(!hInstRes)
                return E_FAIL;
#endif

            ShellMessageBox(hInstRes,
                            NULL,
                            MAKEINTRESOURCE(IDS_UPDATE_ERROR),
                            MAKEINTRESOURCE(IDS_APP_TITLE),
                            MB_ICONERROR | MB_TASKMODAL | MB_OK);
#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif

        }

        // The SendOnDataChange is necessary for Word to save any changes
        if(_pIDataAdviseHolder)
        {
            // if it fails, no harm, no foul?
            _pIDataAdviseHolder->SendOnDataChange(this, 0, 0);
        }

        if(_pIOleClientSite)
            _pIOleClientSite->SaveObject();
    
        hr = _pIOleAdviseHolder->SendOnSave();
        if(FAILED(hr))
            return hr;

        hr = _pIOleAdviseHolder->SendOnClose();
        _pEmbed->hTask = NULL;
        if(FAILED(hr))
            return hr;


        if (_pIOleClientSite && !_fNoIOleClientSiteCalls) 
            hr = _pIOleClientSite->OnShowWindow(FALSE);

        _pEmbed->hTask = NULL;
    }

    return hr;
}

// This is a required IOleCommandTarget method that should never be called

HRESULT CPackage::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText)
{
    DebugMsg(DM_TRACE, "pack - QueryStatus called");
    return OLECMDERR_E_UNKNOWNGROUP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packguid.h ===
// {F20DA720-C02F-11CE-927B-0800095AE340}
DEFINE_GUID(CLSID_CPackage, 0xF20DA720L, 0xC02F, 0x11CE, 0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40);

// old packager guid...
// {0003000C-0000-0000-C000-000000000046}
DEFINE_GUID(CLSID_OldPackage, 0x0003000CL, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packutil.cpp ===
#include "privcpp.h"
#include "shlwapi.h"

extern HINSTANCE g_hinst;

// This list needs to continue to be updated and we should try to keep parity with Office
const LPCTSTR c_arszUnsafeExts[]  =
{TEXT(".exe"), TEXT(".com"), TEXT(".bat"), TEXT(".lnk"), TEXT(".url"),
 TEXT(".cmd"), TEXT(".inf"), TEXT(".reg"), TEXT(".isp"), TEXT(".bas"), TEXT(".pcd"),
 TEXT(".mst"), TEXT(".pif"), TEXT(".scr"), TEXT(".hlp"), TEXT(".chm"), TEXT(".hta"), TEXT(".asp"), 
 TEXT(".js"),  TEXT(".jse"), TEXT(".vbs"), TEXT(".vbe"), TEXT(".ws"),  TEXT(".wsh"), TEXT(".msi"),
 TEXT(".ade"), TEXT(".adp"), TEXT(".crt"), TEXT(".ins"), TEXT(".mdb"),
 TEXT(".mde"), TEXT(".msc"), TEXT(".msp"), TEXT(".sct"), TEXT(".shb"),
 TEXT(".vb"),  TEXT(".wsc"), TEXT(".wsf"), TEXT(".cpl"), TEXT(".shs"),
 TEXT(".vsd"), TEXT(".vst"), TEXT(".vss"), TEXT(".vsw"), TEXT(".its"), TEXT(".tmp"),
 TEXT(".mdw"), TEXT(".mdt"), TEXT(".ops")
};

const LPCTSTR c_arszExecutableExtns[]  =
{TEXT(".exe"), TEXT(".com"), TEXT(".bat"), TEXT(".lnk"), TEXT(".cmd"), TEXT(".pif"),
 TEXT(".scr"), TEXT(".js"),  TEXT(".jse"), TEXT(".vbs"), TEXT(".vbe"), TEXT(".wsh"),
 TEXT(".sct"), TEXT(".vb"),  TEXT(".wsc"), TEXT(".wsf")
};

BOOL IsProgIDInList(LPCTSTR pszProgID, LPCTSTR pszExt, const LPCTSTR *arszList, UINT nExt)
{
    TCHAR szClassName[MAX_PATH];
    DWORD cbSize = SIZEOF(szClassName);

    if ((!pszProgID || !*pszProgID) && (!pszExt || !*pszExt))
        return FALSE;

    if (!pszProgID || !*pszProgID)
    {
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szClassName, &cbSize))
            pszProgID = szClassName;
        else
            pszProgID = NULL;
    }

    for (UINT n = 0; n < nExt; n++)
    {
        // check extension if available
        if (pszExt && (0 == StrCmpI(pszExt, arszList[n])))
            return TRUE;

        if (!pszProgID)     // no progid available, just check the extension
            continue;

        DWORD dwValueType;
        TCHAR szTempID[MAX_PATH];
        szTempID[0] = TEXT('\0');
        ULONG cb = ARRAYSIZE(szTempID)*sizeof(TCHAR);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, arszList[n], NULL, &dwValueType, (PBYTE)szTempID, &cb))
            if (!StrCmpI(pszProgID, szTempID))
                return TRUE;
    }
    return FALSE;
}


//////////////////////////////////////////////////////////////////////
//
// Icon Helper Functions
//
//////////////////////////////////////////////////////////////////////

void CPackage::_CreateSaferIconTitle(LPTSTR szSaferTitle, LPCTSTR szIconText)
{
    // Note: szSaferTitle must be at least MAX_PATH.  In theory the szIconText could be MAX_PATH, and
    // the real file name could also be MAX_PATH.  However, since this is just trying to be "safer",
    // and anything even approaching MAX_PATH in length would be very, very, strange (and would look that way to the user)
    // we are just assuming MAX_PATH.  Anything greater will be truncated.
#ifdef USE_RESOURCE_DLL
    HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    if(!hInstRes)
        return ;
#endif

    WCHAR szTemp[MAX_PATH];

    if(CMDLINK == _panetype)
    {
        // As a security we display the words "(Command Line)" in the title
        WCHAR szCommandLine[80];
        WCHAR szFormat[20];        
        LoadString(hInstRes, IDS_COMMAND_LINE, szCommandLine, ARRAYSIZE(szCommandLine));
        LoadString(hInstRes, IDS_ICON_COMMAND_LINE_FORMAT, szFormat, ARRAYSIZE(szFormat));

        // I don't want to muck with the szIconText so using szTemp
        // Limited to 80 so we can be sure of seeing the (.exe) or whatever
        StringCchCopy(szTemp, 80, szIconText);  
        LPTSTR args[3];
        args[0] = (LPTSTR) szTemp;
        args[1] = szCommandLine;
        args[2] = NULL;

        if(! FormatMessage( 
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
            szFormat,
            0,
            0, // Default language
            szSaferTitle,
            MAX_PATH,
            (va_list *) args
            ))
        {
            StringCchCopy(szSaferTitle, MAX_PATH, szIconText);
        }
    }
    else if(_pEmbed && *_pEmbed->fd.cFileName)
    {
       
        LPTSTR szExtLabel;
        LPTSTR szExtFile;
        szExtLabel = PathFindExtension(szIconText);
        szExtFile = PathFindExtension(_pEmbed->fd.cFileName);

        if(szExtFile && *szExtFile && lstrcmpi(szExtFile, szExtLabel) != 0)
        {
            // I don't want to muck with the szIconText so using szTemp
            // Limited to 60 so we can be sure of seeing the (.exe) or whatever
            StringCchCopy(szTemp, 80, szIconText);  
            LPTSTR args[3];
            args[0] = (LPTSTR) szTemp;
            args[1] = szExtFile;
            args[2] = NULL;

            // As a security we display the truefileName + trueExt in ()
            WCHAR szFormat[20];
            LoadString(hInstRes, IDS_ICON_TITLE_FORMAT, szFormat, ARRAYSIZE(szFormat));
            if(! FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                szFormat,
                0,
                0, // Default language
                szSaferTitle,
                MAX_PATH,
                (va_list *) args
                ))
            {
                StringCchCopy(szSaferTitle, MAX_PATH, szIconText);
            }
        }
        else
            StringCchCopy(szSaferTitle, MAX_PATH, szIconText);
    }
    else
        StringCchCopy(szSaferTitle, MAX_PATH, szIconText);
#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif

}


void CPackage::_IconDraw(LPIC lpic, HDC hdc, LPRECT lprc)
{
    //
    // draw's the icon and the text to the specfied DC in the given 
    // bounding rect.  
    //    

    // Visual Basic calls us with a NULL lprc
    // It's a bit hoaky but for now we'll just make a rect the same size as the icon
    RECT aFakeRect;
    if(!lprc)
    {
        aFakeRect.top = 0;
        aFakeRect.left = 0;
        aFakeRect.bottom = lpic->rc.bottom + 1;
        aFakeRect.right = lpic->rc.right + 1;
        lprc = &aFakeRect;
    }


    DebugMsg(DM_TRACE, "pack - IconDraw() called.");
    DebugMsg(DM_TRACE, "         left==%d,top==%d,right==%d,bottom==%d",
             lprc->left,lprc->top,lprc->right,lprc->bottom);

    // make sure we'll fit in the given rect
    //comment out for now -- if fixes a MS Project bug (rect is 1 pixel too short).  If it creates more problems we'll take another look
    //if (((lpic->rc.right-lpic->rc.left) > (lprc->right - lprc->left)) ||
    //    ((lpic->rc.bottom-lpic->rc.top) > (lprc->bottom - lprc->top)))
    //    return;
    
    // Draw the icon
    if (lpic->hDlgIcon)
    {
        DrawIcon(hdc, (lprc->left + lprc->right - g_cxIcon) / 2,
            (lprc->top + lprc->bottom - lpic->rc.bottom) / 2, lpic->hDlgIcon);
    
    }

    WCHAR szLabel[MAX_PATH];
    _CreateSaferIconTitle(szLabel, lpic->szIconText); 

    if (*szLabel)
    {    
        HFONT hfont = SelectFont(hdc, g_hfontTitle);
        RECT rcText;

        rcText.left = lprc->left;
        rcText.right = lprc->right;
        rcText.top = (lprc->top + lprc->bottom - lpic->rc.bottom) / 2 + g_cyIcon + 1;
        rcText.bottom = lprc->bottom;
        DrawText(hdc, szLabel, -1, &rcText, DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE | DT_TOP);

        if (hfont)
            SelectObject(hdc, hfont);
    }
}


LPIC IconCreate(void)
{
    // 
    // allocates space for our icon structure which holds icon index,
    // the icon path, the handle to the icon, and the icon text
    // return:  NULL on failure
    //          a valid pointer on success
    //
    
    DebugMsg(DM_TRACE, "pack - IconCreate() called.");

    // Allocate memory for the IC structure
    return (LPIC)GlobalAlloc(GPTR, sizeof(IC));
}

LPIC CPackage::_IconCreateFromFile(LPCTSTR lpstrFile)
{
    //
    // initializes an IC structure (defined in pack2.h) from a given
    // filename.
    // return:  NULL on failure
    //          a valid pointer on success
    //
    
    LPIC lpic;

    DebugMsg(DM_TRACE, "pack - IconCreateFromFile() called.");

    if (lpic = IconCreate())
    {
        // Get the icon
        StringCchCopy(lpic->szIconPath, ARRAYSIZE(lpic->szIconPath), lpstrFile);
        lpic->iDlgIcon = 0;

        if (*(lpic->szIconPath))
            _GetCurrentIcon(lpic);

        // Get the icon text -- calls ILGetDisplayName
        // 
        GetDisplayName(lpic->szIconText, lpstrFile);
        if (!_IconCalcSize(lpic)) 
        {
            if (lpic->hDlgIcon)
                DestroyIcon(lpic->hDlgIcon);
            GlobalFree(lpic);
            lpic = NULL;
        }
    }
    return lpic;
}


BOOL CPackage::_IconCalcSize(LPIC lpic) 
{
    HDC hdcWnd;
    RECT rcText = { 0 };
    SIZE Image;
    HFONT hfont;
    
    DebugMsg(DM_TRACE, "pack - IconCalcSize called.");
    
    // get the window DC, and make a DC compatible to it
    if (!(hdcWnd = GetDC(NULL)))  {
        DebugMsg(DM_TRACE, "         couldn't get DC!!");
        return FALSE;
    }
    ASSERT(lpic);

    WCHAR szLabel[MAX_PATH];
    _CreateSaferIconTitle(szLabel, lpic->szIconText); 
    if (*szLabel)
    {    
        SetRect(&rcText, 0, 0, g_cxArrange, g_cyArrange);
        
        // Set the icon text rectangle, and the icon font
        hfont = SelectFont(hdcWnd, g_hfontTitle);

        // Figure out how large the text region will be
        rcText.bottom = DrawText(hdcWnd, szLabel, -1, &rcText,
            DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

        if (hfont)
            SelectObject(hdcWnd, hfont);
    }
    
    // Compute the image size
    rcText.right++;
    Image.cx = (rcText.right > g_cxIcon) ? rcText.right : g_cxIcon;
    Image.cy = g_cyIcon + rcText.bottom + 1;
    
    // grow the image a bit
    Image.cx += Image.cx / 4;
    Image.cy += Image.cy / 8;
    
    lpic->rc.right = Image.cx;
    lpic->rc.bottom = Image.cy;
    
    DebugMsg(DM_TRACE,"         lpic->rc.right==%d,lpic->rc.bottom==%d",
             lpic->rc.right,lpic->rc.bottom);
    
    return TRUE;
}    

void CPackage::_GetCurrentIcon(LPIC lpic)
{
#ifdef USE_RESOURCE_DLL
    HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    if(!hInstRes)
        return;
#endif
    
    WORD wIcon = (WORD)lpic->iDlgIcon;
    
    DebugMsg(DM_TRACE, "pack - GetCurrentIcon() called.");

    if (lpic->hDlgIcon)
        DestroyIcon(lpic->hDlgIcon);

    SHFILEINFO shInfo;
    // Check to see if we can get an icon from the specified path
    // SECURITY!! 
    // SHGFI_USEFILEATTRIBUTES will get the icon for the this ext.  
    // We just want to use this icon for files we THINK may be, possibly, could be, should be, we
    // hope are SAFE. We'll use some "scary" icon for files that are potentially dangerous
    LPTSTR szIconFileName;

    if(_pEmbed && *_pEmbed->fd.cFileName)
    {
        szIconFileName = _pEmbed->fd.cFileName;
    }
    else
    {
        szIconFileName = lpic->szIconPath;
    }

    // LPTSTR szExt = PathFindExtension(lpic->szIconText);
    LPTSTR szExt = PathFindExtension(szIconFileName);

    if(CMDLINK == _panetype)
    {

        // If it's a command line package, it always gets the warning icon
        lpic->hDlgIcon = (HICON)LoadImage(hInstRes, MAKEINTRESOURCE(IDI_PACKAGE_WARNING),
                            IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
    }
    else if(szExt && *szExt)
    {
        // If it's in our list of dangerous ext, then use the "scary" icon
        // For now I'm using the "executable" list to avoid crying wolf too often
        // we may want to re-visit and use c_arszUnsafeExts
        if(IsProgIDInList(NULL, szExt, c_arszExecutableExtns, ARRAYSIZE(c_arszExecutableExtns)))
        {
            shInfo.hIcon = (HICON)LoadImage(hInstRes, MAKEINTRESOURCE(IDI_PACKAGE_WARNING),
                                IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
        }
        else
        {
            // No, not scary, then just use the icon associated with the ext 
            if(!SHGetFileInfo(szExt, 
                FILE_ATTRIBUTE_NORMAL, 
                &shInfo, 
                sizeof(SHFILEINFO),
                SHGFI_ICON | SHGFI_USEFILEATTRIBUTES))
            {
                // OK, that still didn't work, so it's an unrecognized ext.
                // In that case we'll go back and use the warning icon.
                shInfo.hIcon = (HICON)LoadImage(hInstRes, MAKEINTRESOURCE(IDI_PACKAGE_WARNING),
                                    IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);

            }
        }

        lpic->hDlgIcon = shInfo.hIcon;
    }
    else
    {
        // OK, we didn't have an extension,so use the packager icon
        if (!lpic->szIconPath || *lpic->szIconPath == TEXT('\0'))
        {
            lpic->hDlgIcon = (HICON)LoadImage(hInstRes, MAKEINTRESOURCE(IDI_PACKAGER),
                                    IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
        }
    }

    if (_pIDataAdviseHolder)
        _pIDataAdviseHolder->SendOnDataChange(this,0, NULL);
    if (_pViewSink)
        _pViewSink->OnViewChange(_dwViewAspects,_dwViewAdvf);

#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif

}


void GetDisplayName(LPTSTR szName, LPCTSTR szPath)
{
    LPTSTR pszTemp = PathFindFileName(szPath);
    StringCchCopy(szName, MAX_PATH, pszTemp);   // all packager callers verified as MAX_PATH
}


/////////////////////////////////////////////////////////////////////////
//
// Stream Helper Functions
//
/////////////////////////////////////////////////////////////////////////

HRESULT CopyFileToStream(LPTSTR lpFileName, IStream* pstm, DWORD * pdwFileLength) 
{
    //
    // copies the given file to the current seek pointer in the given stream
    // return:  S_OK            -- successfully copied
    //          E_POINTER       -- one of the pointers was NULL
    //          E_OUTOFMEMORY   -- out of memory
    //          E_FAIL          -- other error
    //
    
    LPVOID      lpMem;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HRESULT     hr;
    DWORD       dwSizeLow;
    DWORD       dwSizeHigh;
    DWORD       dwPosLow = 0L;
    LONG        lPosHigh = 0L;
    
    DebugMsg(DM_TRACE,"pack - CopyFileToStream called.");

    ASSERT(pdwFileLength);
    if(pdwFileLength)
    {
        *pdwFileLength = 0;
    }

    if (!pstm || !lpFileName) 
    {
        DebugMsg(DM_TRACE,"          bad pointer!!");
        return E_POINTER;
    }    
    
    // Allocate memory buffer for tranfer operation...
    if (!(lpMem = (LPVOID)GlobalAlloc(GPTR, BUFFERSIZE))) 
    {
        DebugMsg(DM_TRACE, "         couldn't alloc memory buffer!!");
        hr = E_OUTOFMEMORY;
        goto ErrRet;
    }
    
    // open file to copy to stream
    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READWRITE, NULL, 
                       OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        DebugMsg(DM_TRACE, "         couldn't open file!!");
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrRet;
    }
    
    // Figure out how much to copy...
    dwSizeLow = GetFileSize(hFile, &dwSizeHigh);
    ASSERT(dwSizeHigh == 0);
    
    SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
        
    // read in the file, and write to stream
    DWORD       cbRead = BUFFERSIZE;
    DWORD       cbWritten = BUFFERSIZE;
    while (cbRead == BUFFERSIZE && cbWritten == BUFFERSIZE)
    {
        if(ReadFile(hFile, lpMem, BUFFERSIZE, &cbRead, NULL))
        {
            if(!SUCCEEDED(pstm->Write(lpMem, cbRead, &cbWritten)))
            {
                hr = E_FAIL;
                goto ErrRet;
            }

            *pdwFileLength += cbWritten;
        }
    }

    // verify that we are now at end of block to copy
    dwPosLow = SetFilePointer(hFile, 0L, &lPosHigh, FILE_CURRENT);
    ASSERT(lPosHigh == 0);
    if (dwPosLow != dwSizeLow) 
    {
        DebugMsg(DM_TRACE, "         error copying file!!");
        hr = E_FAIL;
        goto ErrRet;
    }
    
    hr = S_OK;
    
ErrRet:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (lpMem)
        GlobalFree((HANDLE)lpMem);
    return hr;
}   

HRESULT CopyStreamToFile(IStream* pstm, LPTSTR lpFileName, DWORD dwFileLength) 
{
    //
    // copies the contents of the given stream from the current seek pointer
    // to the end of the stream into the given file.
    //
    // NOTE: the given filename must not exist, if it does, the function fails
    // with E_FAIL
    //
    // return:  S_OK            -- successfully copied
    //          E_POINTER       -- one of the pointers was NULL
    //          E_OUTOFMEMORY   -- out of memory
    //          E_FAIL          -- other error
    //
    
    LPVOID      lpMem;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HRESULT     hr = S_OK;

    DebugMsg(DM_TRACE,"pack - CopyStreamToFile called.");
    
    // pstm must be a valid stream that is open for reading
    // lpFileName must be a valid filename to be written
    //
    if (!pstm || !lpFileName)
        return E_POINTER;
    
    // Allocate memory buffer...
    if (!(lpMem = (LPVOID)GlobalAlloc(GPTR, BUFFERSIZE))) 
    {
        DebugMsg(DM_TRACE, "         couldn't alloc memory buffer!!");
        hr = E_OUTOFMEMORY;
        goto ErrRet;
    }
    
    // open file to receive stream data
    hFile = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, 
                       CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        DebugMsg(DM_TRACE, "         couldn't open file!!");
        hr = E_FAIL;
        goto ErrRet;
    }

    
    // read in the stream, and write to the file
    DWORD       cbCopied = 0;
    DWORD       cbRead = BUFFERSIZE;
    DWORD       cbWritten = BUFFERSIZE;
    while (cbRead == BUFFERSIZE && cbWritten == BUFFERSIZE)  
    {
        DWORD cbToCopy;
        hr = pstm->Read(lpMem, BUFFERSIZE, &cbRead);
        cbToCopy = cbRead;
        if(cbCopied + cbToCopy > dwFileLength)
            cbToCopy = dwFileLength - cbCopied;

        if(WriteFile(hFile, lpMem, cbToCopy, &cbWritten, NULL))
        {
            cbCopied += cbWritten;
        }
    }
    

    if (hr != S_OK) 
    {
        DebugMsg(DM_TRACE, "         error copying file!!");
        hr = E_FAIL;
        goto ErrRet;
    }
    
ErrRet:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (lpMem)
        GlobalFree((HANDLE)lpMem);
    return hr;
}   

// FEATURE: write persistence formats in UNICODE!

HRESULT StringReadFromStream(IStream* pstm, LPSTR pszBuf, UINT cchBuf)
{
    //
    // read byte by byte until we hit the null terminating char
    // return: the number of bytes read
    //
    
    UINT cch = 0;
    
    do 
    {
        pstm->Read(pszBuf, sizeof(CHAR), NULL);
        cch++;
    } while (*pszBuf++ && cch <= cchBuf);  
    return cch;
} 

DWORD _CBString(LPCSTR psz)
{
    return sizeof(psz[0]) * (lstrlenA(psz) + 1);
}

HRESULT StringWriteToStream(IStream* pstm, LPCSTR psz, DWORD *pdwWrite)
{
    DWORD dwWrite;
    DWORD dwSize = _CBString(psz);
    HRESULT hr = pstm->Write(psz, dwSize, &dwWrite);
    if (SUCCEEDED(hr))
        *pdwWrite += dwWrite;
    return hr;
}


// parse pszPath into a unquoted path string and put the args in pszArgs
//
// returns:
//      TRUE    we verified the thing exists
//      FALSE   it may not exist
//
// taken from \ccshell\shell32\link.c
//
BOOL PathSeparateArgs(LPTSTR pszPath, LPTSTR pszArgs, DWORD cch)
{
    LPTSTR pszT;
    
    PathRemoveBlanks(pszPath);
    
    // if the unquoted sting exists as a file just use it
    
    if (PathFileExists(pszPath))
    {
        *pszArgs = 0;
        return TRUE;
    }
    
    pszT = PathGetArgs(pszPath);
    if (*pszT)
        *(pszT - 1) = TEXT('\0');
    StringCchCopy(pszArgs, cch, pszT);
    
    PathUnquoteSpaces(pszPath);
    
    return FALSE;
}   


int CPackage::_GiveWarningMsg()
{

    int iResult = IDOK;
    LPWSTR szFileName = NULL;
    if(_pEmbed && *_pEmbed->fd.cFileName)
    {
        szFileName = _pEmbed->fd.cFileName;
    }
    else if(_lpic)
    {
        szFileName = _lpic->szIconPath;
    }

    LPTSTR szExt = NULL;
    if(szFileName)
        szExt = PathFindExtension(szFileName);

    UINT uWarningMsg = 0;
    if(szExt)
    {
        if(IsProgIDInList(NULL, szExt, c_arszExecutableExtns, ARRAYSIZE(c_arszExecutableExtns)))
        {
            uWarningMsg = IDS_PACKAGE_EXECUTABLE_WARNING;
        }
        else if(IsProgIDInList(NULL, szExt, c_arszUnsafeExts, ARRAYSIZE(c_arszUnsafeExts)))
        {
            uWarningMsg = IDS_PACKAGE_WARNING;
        }
    }

    if(uWarningMsg)
    {
        WCHAR szText[512];
        WCHAR szTitle[80];
    
        int iTryAgain = 0;

#ifdef USE_RESOURCE_DLL
        HINSTANCE hInstRes = LoadLibraryEx(L"sp1res.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if(!hInstRes)
            return E_FAIL;
#endif
        
        LoadString(hInstRes, uWarningMsg, szText, ARRAYSIZE(szText));
        LoadString(hInstRes, IDS_WARNING_DLG_TITLE, szTitle, ARRAYSIZE(szTitle));

        iResult =  MessageBox(NULL, szText, szTitle, MB_OKCANCEL | MB_ICONWARNING | MB_DEFBUTTON2 | MB_SETFOREGROUND);
#ifdef USE_RESOURCE_DLL
        FreeLibrary(hInstRes);
#endif

    }
    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packutil.h ===
#ifndef PACKUTIL_H__
#define PACKUTIL_H__

#define CHAR_SPACE          TEXT(' ')
#define CHAR_QUOTE          TEXT('"')
#define SZ_QUOTE            TEXT("\"")
#define BUFFERSIZE          4096    // 4k buffer size for copy operations

extern BOOL gCmdLineOK;

/////////////////////////////////
// Icon structure
//
typedef struct _IC                      // ic
{
    HICON hDlgIcon;                     // handle to icon
    TCHAR szIconPath[MAX_PATH];        // path to icon
    TCHAR szIconText[MAX_PATH];        // text for icon
    INT iDlgIcon;                       // index of icon in a resource
    RECT rc;                            // bounding rect of icon and text
} IC, *LPIC;
    

VOID ReplaceExtension(LPTSTR lpstrTempFile,LPTSTR lpstrOrigFile);
LPIC IconCreate(void);
LPIC IconCreateFromFile(LPCTSTR);
VOID GetDisplayName(LPTSTR, LPCTSTR);

HRESULT CopyStreamToFile(IStream*, LPTSTR, DWORD fileLength);
HRESULT CopyFileToStream(LPTSTR lpFileName, IStream* pstm, DWORD * pdwFileLength);
HRESULT StringReadFromStream(IStream* pstm, LPSTR pszBuffer, UINT cchChar);
HRESULT StringWriteToStream(IStream* pstm, LPCSTR pszBuffer, DWORD *pdwWrite);
BOOL PathSeparateArgs(LPTSTR pszPath, LPTSTR pszArgs, DWORD cch);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\priv.h ===
#ifndef pack2_h__
#define pack2_h__


#define INC_OLE2        // Prevent windows.h from pulling in OLE 1
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <shlobj.h>         // ;Internal
#include <shellapi.h>       // ;Internal
#include <shlwapi.h>
#include <shlwapip.h>       // ;Internal
#include <ole2.h>


#include <ole2ver.h>
// #include <crtfree.h>    // don't use CRT libs
#include <ccstock.h>
// #include <shsemip.h>    // in ccshell\inc
// #include <shellp.h>     // in ccshell\inc
// #include <debug.h>      // in ccshell\inc
// #include <shguidp.h>    // in ccshell\inc

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "packutil.h"
#include "packguid.h"
#include "ids.h"

HRESULT CPackage_CreateInstance(IUnknown ** ppunk);

//////////////////////////////////
// External Variables
//
#define USE_RESOURCE_DLL 1

extern LONG             g_cRefThisDll;        // per-instance
extern HINSTANCE        g_hinst;                
extern HINSTANCE        g_hinstResDLL;    
extern UINT             g_cfFileContents;       
extern UINT             g_cfFileDescriptor;
extern UINT             g_cfObjectDescriptor;
extern UINT             g_cfEmbedSource;
extern UINT             g_cfFileNameW;
extern INT              g_cxIcon;
extern INT              g_cyIcon;
extern INT              g_cxArrange;
extern INT              g_cyArrange;
extern HFONT            g_hfontTitle;


//////////////////////////////////
// Global Constants
//
#define HIMETRIC_PER_INCH       2540    // Number of HIMETRIC units per inch
#define DEF_LOGPIXELSX          96      // Default values for pixels per
#define DEF_LOGPIXELSY          96      // logical inch
#define CBCMDLINKMAX            500     // num chars in cmdline package
#define FILE_SHARE_READWRITE    (FILE_SHARE_READ | FILE_SHARE_WRITE)
#define OLEIVERB_EDITPACKAGE    (OLEIVERB_PRIMARY+1)
#define OLEIVERB_FIRST_CONTEXT  (OLEIVERB_PRIMARY+2)
#define OLEIVERB_LAST_CONTEXT   (OLEIVERB_PRIMARY+0xFFFF)
#define PACKWIZ_NUM_PAGES    2    // number of pages in our wizard


//////////////////////////////////
// Clipboard Formats
//
#define CF_FILECONTENTS     g_cfFileContents
#define CF_FILEDESCRIPTOR   g_cfFileDescriptor
#define CF_OBJECTDESCRIPTOR g_cfObjectDescriptor
#define CF_EMBEDSOURCE      g_cfEmbedSource
#define CF_FILENAMEW        g_cfFileNameW
#define CFSTR_EMBEDSOURCE   TEXT("Embed Source")
#define CFSTR_OBJECTDESCRIPTOR TEXT("Object Descriptor")


//////////////////////////////////
// String constants
//
#define SZUSERTYPE              L"OLE Package"
#define SZCONTENTS              L"\001Ole10Native"
#define SZAPPNAME               TEXT("Object Packager")

//////////////////////////////////
// Old packager junk...
//
// NOTE: This enumeration is used to determine what kind of information
// is stored in a packager object.  Currently, the new packager on supports
// ICON and PEMBED.  We will probably want to implement CMDLINK and PICTURE
// to remain back compatible with the old packager.
//
typedef enum
{
    NOTHING,
    CMDLINK,
    ICON,
    PEMBED,
    PICTURE,
    PACKAGE
} PANETYPE;

//////////////////////////////////
// Embedded File structure
//
// NOTE: This is similar to the structure used by the old packager to store
// information about the embedded file, however it is slightly different.
// Most notably, I use a FILEDESCRIPTOR structure to hold onto the filename
// and filesize so this information can be easily transferred in a GetData call
// Also, I've deleted some uncessary fields that the old packager used to 
// deal with OLE 1 ways of dealing with things.

typedef struct _EMBED           // embed
{
    FILEDESCRIPTOR fd;          // file descriptor of embedded file
    LPTSTR  pszTempName;        // temp. file name used when shellexec'ing
    HANDLE hTask;               // handle to task on shellexec'ed objects
    LPOLEOBJECT poo;            // oleobject interface on running contents
    BOOL   fIsOleFile;          // TRUE if OLE can activate this type of file
} EMBED, *LPEMBED;


//////////////////////////////////
// Command line structure
//
// NOTE: This is the structure the old packager used when implementing
// the command line packages.  It will be best to use this structure for
// the new packager for ease of use in reading and writing old packager
// formats.
//
typedef struct _CML             // cml
{
    BOOL fCmdIsLink;
    TCHAR szCommandLine[CBCMDLINKMAX];
} CML, *LPCML;

////////////////////////////////
// PackageInfo Structure
//
// NOTE: This structure is used by the Create New Package Wizard and the
// Edit Package dialogs.  We use it to hold onto package information, so that
// the CPackage Object can initialize/reinitialize itself after one of these
// calls.
//
typedef struct _packageInfo 
{
    TCHAR    szLabel[MAX_PATH];
    TCHAR    szFilename[MAX_PATH];
    TCHAR    szIconPath[MAX_PATH];
    int     iIcon;                // must be an int for PickIconDlg
    BOOL    bUseCommandLine;
} PACKAGER_INFO, *LPPACKAGER_INFO;


////////////////////////////////
// PersistStorage enumeration
//
typedef enum
{
        PSSTATE_UNINIT = 0, //Uninitialized
        PSSTATE_SCRIBBLE,   //Scribble
        PSSTATE_ZOMBIE,     //No scribble
        PSSTATE_HANDSOFF    //Hand-off
} PSSTATE;

#endif

#include "debug.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packwiz.cpp ===
#include <privcpp.h>

#include <windows.h>
#include <prsht.h>
#include <shlwapi.h>

#include <shsemip.h>
#include "ids.h"
#define IDS_FILENOTFOUND        0x2331
//
// FUNCTION: PackWiz_SelectFileDlgProc(HWND,UINT,WPARAM,LPARAM)
//
// PURPOSE:  Dialog procedure for FIRST page of Create New Package Wizard
// 
//
INT_PTR CALLBACK PackWiz_SelectFileDlgProc(HWND hDlg, UINT uMsg , WPARAM wParam, LPARAM lParam)
{
    LPPACKAGER_INFO lppi = (LPPACKAGER_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    static BOOL bStayHere = FALSE;
    

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        lppi = (LPPACKAGER_INFO)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lppi);
        Edit_LimitText(GetDlgItem(hDlg, IDC_COMMAND), ARRAYSIZE(lppi->szFilename) - 1);
        CheckDlgButton(hDlg, IDC_CHECK1, lppi->bUseCommandLine);

        if (*lppi->szFilename)
            SetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename);

        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            break;
            
        case IDC_COMMAND:
            // Check to see if we have a change in the edit control
            switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
            {
            case EN_CHANGE:
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                break;
            }
            break;
            
            case IDC_BROWSE: 
                {
                    TCHAR szExt[MAX_PATH];		
                    TCHAR szFilter[80];			
                    TCHAR szTitle[80];
                    TCHAR szFilename[MAX_PATH];
                    int ret;
                    LPTSTR lpsz = szFilter;
                    
                    // load the filter and then replace all the @ characters
                    // with NULL.  The end of the string will be doubly
                    // null-terminated

                    LoadString(g_hinstResDLL, IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter)-1);
                    while (*lpsz) {
                        if (*lpsz == TEXT('@')) {
                            *lpsz = 0;
                            lpsz++;
                        }
                        else {
                            lpsz = CharNext(lpsz);
                        }
                    }
                    *(lpsz+1) = 0;
                    

                    LoadString(g_hinstResDLL, IDS_BROWSEEXT, szExt, ARRAYSIZE(szExt));
                    LoadString(g_hinstResDLL, IDS_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
                    
                    GetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
                    
                    // Danger - this is a TCHAR API!
                    ret = GetFileNameFromBrowse(hDlg,szFilename, ARRAYSIZE(lppi->szFilename), NULL, szExt, szFilter, szTitle);
                    if (ret > 0) 
                    {
                        StringCchCopy(lppi->szFilename, ARRAYSIZE(lppi->szFilename), szFilename);
                    }
                    
                    SetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename);
                    break;
                }
        }
        break;
        
        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code) 
            {
            case PSN_KILLACTIVE:
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, bStayHere);
                return TRUE;
                
            case PSN_RESET:
                // reset to original values
                *lppi->szFilename = TEXT('\0');
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                break;
                
            case PSN_SETACTIVE:
                Edit_SetText(GetDlgItem(hDlg, IDC_COMMAND), lppi->szFilename);
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                break;
                
            case PSN_WIZNEXT:
                {
                    bStayHere = FALSE;
                    GetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
                    lppi->bUseCommandLine = IsDlgButtonChecked(hDlg, IDC_CHECK1);
                    if(!lppi->bUseCommandLine)
                    {
                        DWORD dwFileAttributes = GetFileAttributes(lppi->szFilename);
                        if(-1 == dwFileAttributes || (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                        {
                            HINSTANCE shell32Inst;
                            shell32Inst = LoadLibraryEx(L"shell32.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
                            ShellMessageBox(shell32Inst,
                            NULL,
                            MAKEINTRESOURCE(IDS_FILENOTFOUND),
                            MAKEINTRESOURCE(IDS_FILENOTFOUND),
                            MB_OK | MB_ICONERROR | MB_TASKMODAL);
                            FreeLibrary(shell32Inst);
                            bStayHere = TRUE;
                            return TRUE;
                        }
                    }
                }
                break;
                
            case PSN_QUERYCANCEL:
                *lppi->szFilename = TEXT('\0');
                return FALSE;
                
            default:
                return FALSE;
            }
            break;
            
            case WM_DESTROY:
            case WM_HELP:
            case WM_CONTEXTMENU:
                break;
                
            default:
                return FALSE;
                
    } // end of switch on uMsg
    return TRUE;
}  



//
// FUNCTION: PackWiz_SelectLabelDlgProc(HWND, UINT, WPARAM, LPARAM)
//
// PURPOSE:  Dialog procedure for THIRD page of Create New Package Wizard
// 
//
INT_PTR CALLBACK PackWiz_SelectLabelDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPPACKAGER_INFO lppi = (LPPACKAGER_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (uMsg) 
    {
        
    case WM_INITDIALOG:
        lppi = (LPPACKAGER_INFO)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lppi);
        Edit_LimitText(GetDlgItem(hDlg, IDC_COMMAND), ARRAYSIZE(lppi->szLabel) - 1);
        GetDisplayName(lppi->szLabel, lppi->szFilename);
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            break;
            
        case IDC_COMMAND:
            // Check to see if we have a change in the edit control
	    switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
            {
            case EN_CHANGE:
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                break;
            }
            break;
        }
        break;
        
        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code) 
            {
            case PSN_KILLACTIVE:
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                return TRUE;
                
            case PSN_RESET:
                // reset to original values
                *lppi->szLabel = TEXT('\0');
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                break;
                
            case PSN_SETACTIVE:
                Edit_SetText(GetDlgItem(hDlg, IDC_COMMAND), lppi->szLabel);
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                break;
                
            case PSN_WIZBACK:
                GetDlgItemText(hDlg, IDC_COMMAND, lppi->szLabel, ARRAYSIZE(lppi->szLabel));
                break;
                
            case PSN_WIZFINISH:
                GetDlgItemText(hDlg, IDC_COMMAND, lppi->szLabel, ARRAYSIZE(lppi->szLabel));
                break;
                
            case PSN_QUERYCANCEL:
                *lppi->szFilename = TEXT('\0');
                return FALSE;
                
            default:
                return FALSE;
            }
            break;
            
            case WM_DESTROY:
            case WM_HELP:
            case WM_CONTEXTMENU:
                break;
                
            default:
                return FALSE;
                
    } // end of switch on uMsg
    return TRUE;
}


//
// FUNCTION: PackWiz_EditPackageDlgProc(HWND,UINT,WPARAM,LPARAM)
//
// PURPOSE:  Dialog procedure for Edit Package
//
// NOTE: We have two different types of packages we could edit, but they
// both have exactly the same dialog layout, except for some static text, which
// doesn't affect the dialog procedure
// 
//
INT_PTR CALLBACK PackWiz_EditPackageDlgProc(HWND hDlg, UINT uMsg , WPARAM wParam, LPARAM lParam)
{
    LPPACKAGER_INFO lppi = (LPPACKAGER_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
        
    case WM_INITDIALOG: 
        {
            HICON hicon;
            
            lppi = (LPPACKAGER_INFO)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT1), ARRAYSIZE(lppi->szFilename) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT2), ARRAYSIZE(lppi->szLabel) - 1);
            SetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename);
            SetDlgItemText(hDlg, IDC_EDIT2, lppi->szLabel);
            
            if (*lppi->szIconPath != TEXT('\0'))
                hicon = ExtractAssociatedIcon(g_hinstResDLL, lppi->szIconPath, (LPWORD)&(lppi->iIcon));
            else
                hicon = LoadIcon(g_hinstResDLL, MAKEINTRESOURCE(IDI_PACKAGER));
            
            HWND hPackIcon = GetDlgItem(hDlg, IDC_PACKICON);
            SendMessage(hPackIcon, STM_SETICON, (WPARAM)hicon, (LPARAM)0);
            
            break; 
        }
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            break;
            
        case IDOK:
            if(!gCmdLineOK && !PathFileExists(lppi->szFilename))
            {

                ShellMessageBox(g_hinstResDLL,
                NULL,
                MAKEINTRESOURCE(IDS_NO_SUCH_FILE_CANNOT_SAVE),
                MAKEINTRESOURCE(IDS_APP_TITLE),
                MB_OK | MB_ICONERROR | MB_TASKMODAL);
            }
            else
            {
                GetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
                GetDlgItemText(hDlg, IDC_EDIT2, lppi->szLabel, ARRAYSIZE(lppi->szLabel));
            }

            EndDialog(hDlg, 1);
            break;
            
        case IDCANCEL:
            EndDialog(hDlg, -1);
            break;
            
        case IDC_BROWSE: 
            {
                TCHAR szExt[80];		
                TCHAR szFilter[80];			
                TCHAR szTitle[80];
                LPTSTR lpsz = szFilter;
            
                // load the filter and then replace all the @ characters
                // with NULL.  The end of the string will be doubly
                // null-terminated

                LoadString(g_hinstResDLL, IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter)-1);
                while (*lpsz) {
                    if (*lpsz == TEXT('@')) {
                        *lpsz = 0;
                        lpsz++;
                    }
                    else {
                        lpsz = CharNext(lpsz);
                    }
                }
                *(lpsz+1) = 0;
            
                LoadString(g_hinstResDLL, IDS_BROWSEEXT, szExt, ARRAYSIZE(szExt));
                LoadString(g_hinstResDLL, IDS_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
            
                GetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
            
                GetFileNameFromBrowse(hDlg,lppi->szFilename,
                    ARRAYSIZE(lppi->szFilename), NULL, szExt, szFilter, szTitle);
            
                SetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename);
            }
            break;
        }
        break;
        
        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;
            
        default:
            return FALSE;
            
    } // end of switch on uMsg
    return TRUE;
}  


//
//
// FUNCTION: PackWiz_FillInPropertyPage(PROPSHEETPAGE *, int, LPFN) 
//
// PURPOSE: Fills in the given PROPSHEETPAGE structure 
//
// COMMENTS:
//
//      This function fills in a PROPSHEETPAGE structure with the
//      information the system needs to create the page.
// 
void PackWiz_FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg, DLGPROC pfnDlgProc, LPPACKAGER_INFO lppi)
{
    ZeroMemory(psp, sizeof(PROPSHEETPAGE));
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = 0;
    psp->hInstance = g_hinstResDLL;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pszIcon = NULL;
    psp->pfnDlgProc = pfnDlgProc;
    psp->pszTitle = NULL;
    psp->lParam = (LPARAM)lppi;
}

//
//
// FUNCTION: PackWiz_CreateWizard(HWND)
//
// PURPOSE: Create the Wizard control. 
//
// COMMENTS:
//	
//      This function creates the wizard property sheet.
//
int PackWiz_CreateWizard(HWND hwndOwner, LPPACKAGER_INFO lppi)
{
    PROPSHEETPAGE psp[PACKWIZ_NUM_PAGES];
    PROPSHEETHEADER psh;
    ZeroMemory(&psh, sizeof(psh));

    PackWiz_FillInPropertyPage(&psp[0], IDD_SELECTFILE, PackWiz_SelectFileDlgProc,lppi);
    PackWiz_FillInPropertyPage(&psp[1], IDD_SELECTLABEL, PackWiz_SelectLabelDlgProc,lppi);
    
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD;
    psh.hwndParent = hwndOwner;
    psh.nPages = ARRAYSIZE(psp);
    psh.nStartPage = 0;
    psh.pszIcon = NULL;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (int)(PropertySheet(&psh));
}


//
// FUNCTION: PackWiz_EditPackage(HWND, WORD, LPPACKAGER_INFO)
//
// PURPOSE:  To Run the Edit Package Dialog Procedure
//
//
int PackWiz_EditPackage(HWND hwnd, int idDlg, LPPACKAGER_INFO lppi)
{
    return (int)DialogBoxParam(g_hinstResDLL, MAKEINTRESOURCE(idDlg), hwnd, PackWiz_EditPackageDlgProc, (LPARAM)lppi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\stdafx.cpp ===
// stdafx.cpp : (ATL) source file that includes just the standard includes
#include "privcpp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\privcpp.h ===
#ifndef pack2cpp_h__
#define pack2cpp_h__

#include <priv.h>

#ifdef __cplusplus

#undef DebugMsg
#define DebugMsg TraceMsg

////////////////////////////////
// CPackage Definition
//
class CPackage : public IEnumOLEVERB,
                 public IOleCommandTarget,
                 public IOleObject,
                 public IViewObject2,
                 public IDataObject,
                 public IPersistStorage,
                 public IAdviseSink,
                 public IRunnableObject,
                 public IPersistFile,
                 public IOleCache,
                 public IExternalConnection

                 // cleanup -- inherit interfaces
{

    
public:
    CPackage();                 // constructor
   ~CPackage();                 // destructor
   
    HRESULT Init();             // used to initialze fields that could fail
    BOOL    RunWizard();

    // IUnknown methods...
    STDMETHODIMP            QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    // IEnumOLEVERB methods...
    STDMETHODIMP            Next(ULONG celt, OLEVERB* rgVerbs, ULONG* pceltFetched);
    STDMETHODIMP            Skip(ULONG celt);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumOLEVERB** ppEnum);

    // IOleCommandTarget methods
    STDMETHODIMP            QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText);
    STDMETHODIMP            Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut);

    // IPersistStorage Methods...
    STDMETHODIMP        GetClassID(LPCLSID pClassID);
    STDMETHODIMP        IsDirty(void);
    STDMETHODIMP        InitNew(IStorage* pstg);
    STDMETHODIMP        Load(IStorage* pstg);
    STDMETHODIMP        Save(IStorage* pstg, BOOL fSameAsLoad);
    STDMETHODIMP        SaveCompleted(IStorage* pstg);
    STDMETHODIMP        HandsOffStorage(void);

    // IPersistFile Methods...
    // STDMETHODIMP        GetClassID(LPCLSID pClassID);
    // STDMETHODIMP        IsDirty(void);
    STDMETHODIMP        Load(LPCOLESTR pszFileName, DWORD dwdMode);
    STDMETHODIMP        Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP        SaveCompleted(LPCOLESTR pszFileName);
    STDMETHODIMP        GetCurFile(LPOLESTR *ppszFileName);

  
    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);
 
    // IOleObject Methods...
    STDMETHODIMP SetClientSite(LPOLECLIENTSITE pClientSite);
    STDMETHODIMP GetClientSite(LPOLECLIENTSITE *ppClientSite);
    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHODIMP Close(DWORD dwSaveOption);
    STDMETHODIMP SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMonkier,LPMONIKER *ppmk);
    STDMETHODIMP InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, 
                                 DWORD dwReserved);
    STDMETHODIMP GetClipboardData(DWORD dwReserved, LPDATAOBJECT *ppDataObject);
    STDMETHODIMP DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, 
                           LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHODIMP EnumVerbs(LPENUMOLEVERB *ppEnumOleVerb);
    STDMETHODIMP Update(void);
    STDMETHODIMP IsUpToDate(void);
    STDMETHODIMP GetUserClassID(LPCLSID pClsid);
    STDMETHODIMP GetUserType(DWORD dwFromOfType, LPOLESTR *pszUserType);
    STDMETHODIMP SetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    STDMETHODIMP GetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    STDMETHODIMP Advise(LPADVISESINK pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP Unadvise(DWORD dwConnection);
    STDMETHODIMP EnumAdvise(LPENUMSTATDATA *ppenumAdvise);
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHODIMP SetColorScheme(LPLOGPALETTE pLogpal);

    // IViewObject2 Methods...
    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
                         DVTARGETDEVICE *ptd, HDC hdcTargetDev,
                         HDC hdcDraw, LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                         BOOL (CALLBACK *pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue);
    STDMETHODIMP GetColorSet(DWORD dwAspect, LONG lindex, void *pvAspect,
                                DVTARGETDEVICE *ptd, HDC hdcTargetDev,
                                LPLOGPALETTE *ppColorSet);
    STDMETHODIMP Freeze(DWORD dwDrawAspect, LONG lindex, void * pvAspect, 
                           DWORD *pdwFreeze);
    STDMETHODIMP Unfreeze(DWORD dwFreeze);
    STDMETHODIMP SetAdvise(DWORD dwAspects, DWORD dwAdvf,
                              LPADVISESINK pAdvSink);
    STDMETHODIMP GetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
                              LPADVISESINK *ppAdvSink);
    STDMETHODIMP GetExtent(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd,
                              LPSIZEL pszl);
    // IAdviseSink Methods...
    STDMETHODIMP_(void)  OnDataChange(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP_(void)  OnViewChange(DWORD, LONG);
    STDMETHODIMP_(void)  OnRename(LPMONIKER);
    STDMETHODIMP_(void)  OnSave(void);
    STDMETHODIMP_(void)  OnClose(void);

    // IRunnable Object methods...
    STDMETHODIMP        GetRunningClass(LPCLSID);
    STDMETHODIMP        Run(LPBC);
    STDMETHODIMP_(BOOL) IsRunning();
    STDMETHODIMP        LockRunning(BOOL,BOOL);
    STDMETHODIMP        SetContainedObject(BOOL);

    // IOleCache methods
    // We need an IOLECache Interface to Keep Office97 happy.
    STDMETHODIMP        Cache(FORMATETC * pFormatetc, DWORD advf, DWORD * pdwConnection);
    STDMETHODIMP        Uncache(DWORD dwConnection);
    STDMETHODIMP        EnumCache(IEnumSTATDATA ** ppenumSTATDATA);
    STDMETHODIMP        InitCache(IDataObject *pDataObject);

    // IExternalConnection
    // Some applications RealeaseConnect and then we never hear from them again.
    // This allows us to call OnClose() after the activations.
    STDMETHODIMP_(DWORD)        AddConnection(DWORD exconn, DWORD dwreserved );
    STDMETHODIMP_(DWORD)        ReleaseConnection(DWORD extconn, DWORD dwreserved, BOOL fLastReleaseCloses );

protected:
    LONG        _cRef;          // package reference count
    UINT        _cf;            // package clipboard format

    LPIC        _lpic;          // icon for the packaged object
    PANETYPE    _panetype;      // tells us whether we have a cmdlink or embed
    PSSTATE     _psState;               // persistent storage state
    // These are mutually exclusive, so should probably be made into a union,
    // but that's a minor point.
    LPEMBED     _pEmbed;        // embedded file structure
    LPCML       _pCml;          // command line structure

    BOOL        _fLoaded;       // true if data from persistent storage
    
    // IOleObject vars from SetHostNames
    LPOLESTR    _lpszContainerApp;
    LPOLESTR    _lpszContainerObj;
    
    BOOL        _fIsDirty;      // dirty flag for our internal storage from the pov of our container
    DWORD       _dwCookie;      // connection value for AdviseSink
        
    // Advise interfaces
    LPDATAADVISEHOLDER          _pIDataAdviseHolder;
    LPOLEADVISEHOLDER           _pIOleAdviseHolder;
    LPOLECLIENTSITE             _pIOleClientSite;

    // Excel hack: when Excel hosts what it thinks is a link it always NULLs out
    // it's "object" pointer.  If we call anything on IOleClientSite other than
    // save then it will fault.
    BOOL    _fNoIOleClientSiteCalls;

    BOOL                _fFrozen;

    // to be able to send view change notifications we need these vars
    IAdviseSink                *_pViewSink;
    DWORD                       _dwViewAspects;
    DWORD                       _dwViewAdvf;

    // IEnumOLEVERB variables:
    ULONG       _cVerbs;
    ULONG       _nCurVerb;
    OLEVERB*    _pVerbs;
    IContextMenu* _pcm;

    // IEnumOLEVERB helper methods:
    HRESULT InitVerbEnum(OLEVERB* pVerbs, ULONG cVerbs);
    HRESULT GetContextMenu(IContextMenu** ppcm);
    VOID ReleaseContextMenu();

    // if fInitFile is TRUE, then we will totally initialize ourselves
    // from the given filename.  In other words, all our structures will be
    // initialized after calling this is fInitFile = TRUE.  On the other hand,
    // if it's FALSE, then we'll just reinit our data and not update icon
    // and filename information.
    //
    HRESULT EmbedInitFromFile(LPCTSTR lpFileName, BOOL fInitFile);
    HRESULT CmlInitFromFile(LPTSTR lpFilename, BOOL fUpdateIcon, PANETYPE paneType);
    HRESULT InitFromPackInfo(LPPACKAGER_INFO lppi);
    
    HRESULT CreateTempFile(bool deleteExisting = false);
    HRESULT CreateTempFileName();
    HRESULT _IconRefresh();
    void  _DestroyIC();
    BOOL _IconCalcSize(LPIC lpic);
    VOID _IconDraw(LPIC,HDC, LPRECT);
    LPIC _IconCreateFromFile(LPCTSTR lpstrFile);
    VOID _GetCurrentIcon(LPIC lpic);
    void _CreateSaferIconTitle(LPTSTR szSaferTitle, LPCTSTR szIconTitle);
    void _DrawIconToDC(HDC hdcMF, LPIC lpic, bool stripAlpha, LPCTSTR pszActualFileName);
    
    // Data Transfer functions...
    HRESULT GetFileDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetFileContents(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetMetafilePict(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetEnhMetafile(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetObjectDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM) ;

    HRESULT CreateShortcutOnStream(IStream* pstm); 

    // Packager Read/Write Functions...
    HRESULT PackageReadFromStream(IStream* pstm);
    HRESULT IconReadFromStream(IStream* pstm);
    HRESULT EmbedReadFromStream(IStream* pstm);
    HRESULT CmlReadFromStream(IStream* pstm);
    HRESULT PackageWriteToStream(IStream* pstm);
    HRESULT IconWriteToStream(IStream* pstm, DWORD *pdw);
    HRESULT EmbedWriteToStream(IStream* pstm, DWORD *pdw);
    HRESULT CmlWriteToStream(IStream* pstm, DWORD *pdw);

    // Some utility functions and data
    void _FixupTempFile(IPersistFile * ppf, LPEMBED pEmbed);

    int _GiveWarningMsg();

    // Misc AppCompat Stuff
    int _iPropertiesMenuItem;
    BOOL _bClosed;          // the close happened
    BOOL _bCloseIt;         // that we should close at the end of the activate

};


////////////////////////////////////////////
//
// Package Wizard and Edit Package Dialog Procs and functions
//

// Pages for Wizard
INT_PTR APIENTRY PackWiz_CreatePackageDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY PackWiz_SelectFileDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY PackWiz_SelectLabelDlgProc(HWND, UINT, WPARAM, LPARAM);

// Edit dialog procs
INT_PTR APIENTRY PackWiz_EditEmbedPackageDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY PackWiz_EditCmdPackakgeDlgProc(HWND, UINT, WPARAM, LPARAM);

// functions
int  PackWiz_CreateWizard(HWND,LPPACKAGER_INFO);
int  PackWiz_EditPackage(HWND,int,LPPACKAGER_INFO);
VOID PackWiz_FillInPropertyPage(PROPSHEETPAGE *, INT, DLGPROC);


#endif  // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packexe\ids.h ===
#ifndef IDS_H__
#define IDS_H__


// Used by packager.rc
//

#define IDI_DOCUMENT			1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\stdafx.h ===
// stdafx.h : (ATL) include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_)
#define AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\ratings.inc ===
#
# Common makefile include for this project
#

C_DEFINES       = $(C_DEFINES) \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!endif

# always expect the latest IE
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)

# Do this to assure that we run on NT 4.0 and Win95, even with 
# NT5/Memphis headers.
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400 
SUBSYSTEM_VERSION=4.00

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL = 1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES       = $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

# !include $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4217 

# SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packexe\priv.h ===
#define STRICT
#define _INC_OLE        // REVIEW: don't include ole.h in windows.h

#define OEMRESOURCE


#ifdef WINNT

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif
#endif

#include <windows.h>
#ifdef WINNT
#include <stddef.h>
#include <wingdip.h>
#endif
#include <commctrl.h>
#ifdef WINNT
#include <comctrlp.h>
#endif
#include <windowsx.h>
#include <ole2.h>
#include <shlobj.h>     // Includes <fcext.h>

#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#include <port32.h>
// #include <heapaloc.h>
#include <..\inc\debug.h>      // our version of Assert etc.
#include <shellp.h>

extern "C" BOOL WINAPI PackWizRunFromExe();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\alloc.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* alloc.c -- 
 *
 * History:
 *	10/06/93	gregj	Created.
 *	11/29/93	gregj	Added debug instrumentation.
 *
 */

#include "npcommon.h"
#include <npalloc.h>
#include <netlib.h>


//====== Memory allocation functions =================================

// Alloc a chunk of memory, quickly, with no 64k limit on size of
// individual objects or total object size.
//
void * WINAPI MemAlloc(long cb)
{
	return (void *)::LocalAlloc(LPTR, cb);
}

// Realloc one of above.  If pb is NULL, then this function will do
// an alloc for you.
//
void * WINAPI MemReAlloc(void * pb, long cb)
{
	if (pb == NULL)
		return ::MemAlloc(cb);

	return (void *)::LocalReAlloc((HLOCAL)pb, cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
}

// Free a chunk of memory alloced or realloced with above routines.
//
BOOL WINAPI MemFree(void * pb)
{
    return ::LocalFree((HLOCAL)pb) ? TRUE : FALSE;
}

#ifdef DEBUG

MEMWATCH::MEMWATCH(LPCSTR lpszLabel)
	: _lpszLabel(lpszLabel)
{
	_info.pNext = NULL;
	_info.cAllocs = 0;
	_info.cFrees = 0;
	_info.cbAlloc = 0;
	_info.cbMaxAlloc = 0;
	_info.cbTotalAlloc = 0;
    fStats = TRUE;
	MemRegisterWatcher(&_info);
}

MEMWATCH::~MEMWATCH()
{
	MemDeregisterWatcher(&_info);
    if (fStats || ((_info.cAllocs - _info.cFrees) != 0)) {
        if (!fStats) {
            OutputDebugString("Memory leak: ");
        }
    	OutputDebugString(_lpszLabel);
    	char szBuf[100];
    	wsprintf(szBuf, "%d allocs, %d orphans, %d byte footprint, %d byte usage\r\n",
    			 _info.cAllocs,
    			 _info.cAllocs - _info.cFrees,
    			 _info.cbMaxAlloc,
    			 _info.cbTotalAlloc);
    	OutputDebugString(szBuf);
    }
}

MemLeak::MemLeak(LPCSTR lpszLabel)
	: MEMWATCH(lpszLabel)
{
    fStats = FALSE;
}

MemOff::MemOff()
{
    pvContext = MemUpdateOff();
}

MemOff::~MemOff()
{
    MemUpdateContinue(pvContext);
}

#endif	/* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\bufbase.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFBASE.CPP -- Implementation of BUFFER_BASE class.
 *
 * History:
 *	03/24/93	gregj	Created base class
 *
 */

#include "npcommon.h"
#include "buffer.h"

// The following code would be nice in OOP fashion, but since the
// derived class's virtuals aren't available until after the derived
// class's constructor is done, this Alloc() call will not go anywhere.
// Therefore each derived class must stick the if statement in its
// constructor.
#if 0
BUFFER_BASE::BUFFER_BASE( UINT cbInitial /* =0 */ )
  : _cb( 0 )		// buffer not allocated yet
{
	if (cbInitial)
		Resize( cbInitial );
}
#endif

BOOL BUFFER_BASE::Resize( UINT cbNew )
{
	BOOL fSuccess;

	if (QuerySize() == 0)
		fSuccess = Alloc( cbNew );
	else {
		fSuccess = Realloc( cbNew );
	}
	if (fSuccess)
		_cb = cbNew;
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\buffer.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFFER.CPP -- Implementation of BUFFER class.
 *
 * History:
 *	03/24/93	gregj	Created
 *	10/25/93	gregj	Use shell232.dll routines
 */

#include "npcommon.h"
#include "buffer.h"
#include <netlib.h>

BOOL BUFFER::Alloc( UINT cbBuffer )
{
	_lpBuffer = (LPSTR)::MemAlloc(cbBuffer);
	if (_lpBuffer != NULL) {
		_cb = cbBuffer;
		return TRUE;
	}
	return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
	LPVOID lpNew = ::MemReAlloc(_lpBuffer, cbNew);
	if (lpNew == NULL)
		return FALSE;

	_lpBuffer = (LPSTR)lpNew;
	_cb = cbNew;
	return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
	_lpBuffer( NULL )
{
	if (cbInitial)
		Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
	if (_lpBuffer != NULL) {
		::MemFree(_lpBuffer);
		_lpBuffer = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\pack\packexe\packager.c ===
#include "priv.h"

int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);

extern "C" int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine = GetCommandLine();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitThread(i);  // We only come here when we are not the shell...
    return i;
}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hinst, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    return PackWizRunFromExe();
}

extern "C" int __cdecl _purecall(void) { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\bufglob.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFGLOB.CPP -- Implementation of GLOBAL_BUFFER class.
 *
 * History:
 *	03/22/93	gregj	Created
 *	03/24/93	gregj	Renamed from plain BUFFER, derived from BUFFER_BASE
 *
 */

#include "npcommon.h"
#include "buffer.h"

BOOL GLOBAL_BUFFER::Alloc( UINT cbBuffer )
{
	_hMem = ::GlobalAlloc( GMEM_DDESHARE | GMEM_MOVEABLE, cbBuffer );
	if (_hMem == NULL) {
		_lpBuffer = NULL;
		_cb = 0;
		return FALSE;
	}

	_lpBuffer = ::GlobalLock( _hMem );
	_cb = cbBuffer;
	return TRUE;
}

BOOL GLOBAL_BUFFER::Realloc( UINT cbNew )
{
	if (_hMem == NULL)
		return FALSE;

	::GlobalUnlock( _hMem );

        HGLOBAL hNew = ::GlobalReAlloc( _hMem, cbNew, GMEM_MOVEABLE );
	if (hNew == NULL) {
		::GlobalLock( _hMem );
		return FALSE;
	}

	_hMem = hNew;
	_lpBuffer = ::GlobalLock( _hMem );
	_cb = cbNew;
	return TRUE;
}

GLOBAL_BUFFER::GLOBAL_BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
	_hMem( NULL ),
	_lpBuffer( NULL )
{
	if (cbInitial)
		Alloc( cbInitial );
}

GLOBAL_BUFFER::~GLOBAL_BUFFER()
{
	if (_hMem != NULL) {
		::GlobalUnlock( _hMem );
		::GlobalFree( _hMem );
		_hMem = NULL;
		_lpBuffer = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\bufloc.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFGLOB.CPP -- Implementation of GLOBAL_BUFFER class.
 *
 * History:
 *	03/24/93	gregj	Created
 */

#include "npcommon.h"
#include "buffer.h"

BOOL LOCAL_BUFFER::Alloc( UINT cbBuffer )
{
	_hMem = ::LocalAlloc( LMEM_MOVEABLE, cbBuffer );
	if (_hMem == NULL) {
		_npBuffer = NULL;
		_cb = 0;
		return FALSE;
	}

	_npBuffer = ::LocalLock( _hMem );
	_cb = cbBuffer;
	return TRUE;
}

BOOL LOCAL_BUFFER::Realloc( UINT cbNew )
{
	if (_hMem == NULL)
		return FALSE;

	::LocalUnlock( _hMem );

        HLOCAL hNew = ::LocalReAlloc( _hMem, cbNew, LMEM_MOVEABLE );
	if (hNew == NULL) {
		::LocalLock( _hMem );
		return FALSE;
	}

	_hMem = hNew;
	_npBuffer = ::LocalLock( _hMem );
	_cb = cbNew;
	return TRUE;
}

LOCAL_BUFFER::LOCAL_BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
	_hMem( NULL ),
	_npBuffer( NULL )
{
	if (cbInitial)
		Alloc( cbInitial );
}

LOCAL_BUFFER::~LOCAL_BUFFER()
{
	if (_hMem != NULL) {
		::LocalUnlock( _hMem );
		::LocalFree( _hMem );
		_hMem = NULL;
		_npBuffer = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\chr.cpp ===
#include "npcommon.h"

// strchrf(str, ch)
//
// Returns a pointer to the first occurrence of ch in str.
// Returns NULL if not found.
// May search for a double-byte character.

LPSTR WINAPI strchrf(LPCSTR lpString, UINT ch)
{
    while (*lpString) {
        if (ch == (IS_LEAD_BYTE(*lpString) ? GetTwoByteChar(lpString) : *lpString))
            return (LPSTR)lpString;
        ADVANCE(lpString);
    }
    return NULL;
}


// strrchrf(str, ch)
//
// Returns a pointer to the last occurrence of ch in str.
// Returns NULL if not found.
// May search for a double-byte character.

LPSTR WINAPI strrchrf(LPCSTR lpString, UINT ch)
{
    LPSTR lpLast = NULL;

    while (*lpString) {
        if (ch == (IS_LEAD_BYTE(*lpString) ? GetTwoByteChar(lpString) : *lpString))
            lpLast = (LPSTR)lpString;
        ADVANCE(lpString);
    }
    return lpLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\convtime.cpp ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/
/* :ts=4 */

/***	convtime.cpp - map between SYSTEM & NET time formats
 */

#include "npcommon.h"
#include <convtime.h>


void
NetToSystemDate(
DWORD time,
LPSYSTEMTIME pinfo)			// ptr for return data:
{
	UINT secs, days;
	WORD r;

	// Base the time on 1980, not 1970, to make leap year calculation
	// easier -- 1980 is a leap year, but 1970 isn't.  This code is being
	// written in 1996, so we aren't going to be dealing with dates before
	// 1980 anyway.

    time -= _70_to_80_bias;				// # of seconds since 1980
	secs = time % SECS_IN_DAY;			// seconds into day
	days = time / SECS_IN_DAY;			// days since Jan 1 1980
	pinfo->wDayOfWeek = (days + 2) % 7;	// Jan 1 1980 was a Tuesday, hence "+2"

	pinfo->wMilliseconds = 0;
	pinfo->wSecond = secs % 60;					// # of seconds
	secs /= 60;
	pinfo->wMinute = secs % 60;					// # of minutes
	pinfo->wHour = secs / 60;					// # of hours

	r = days / FOURYEARS;			// (r) = four year period past 1980
	days %= FOURYEARS;				// (days) = days into four year period
	r *= 4;							// (r) = years since 1980 (within 3)

	if (days == 31+28) {			// this many days into a 4-year period is feb 29
		//* Special case for FEB 29th
		pinfo->wDay = 29;
		pinfo->wMonth = 2;
	} else {
		if (days > 31+28)
			--days;						// compensate for leap year
		while (days >= 365) {
			++r;
			days -= 365;
		}

		for (secs = 1; days >= MonTotal[secs+1] ; ++secs)
			;
		days -= MonTotal[secs];

		pinfo->wDay = days + 1;
		pinfo->wMonth = (unsigned short) secs;
	}

	pinfo->wYear = r + 1980;
}


DWORD
SystemToNetDate(LPSYSTEMTIME pinfo)
{
    UINT days, secs;

	days = pinfo->wYear - 1980;
	days = days*365 + days/4;			// # of years in days
	days += pinfo->wDay + MonTotal[pinfo->wMonth];
	if (!(pinfo->wYear % 4)
		&& pinfo->wMonth <= 2)
		--days;						// adjust days for early in leap year

	secs = (((pinfo->wHour * 60) + pinfo->wMinute) * 60) + pinfo->wSecond;
	return days*SECS_IN_DAY + _70_to_80_bias + secs;
}


DWORD
GetCurrentNetDate(void)
{
	SYSTEMTIME st;

	GetSystemTime(&st);

	return SystemToNetDate(&st);
}


DWORD
GetLocalNetDate(void)
{
	SYSTEMTIME st;

	GetLocalTime(&st);

	return SystemToNetDate(&st);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\initstr.cpp ===
/*****************************************************************/
/**				  Microsoft Internet Explorer   				**/
/**		      Copyright (C) Microsoft Corp., 1997   			**/
/*****************************************************************/ 

/* INITSTR -- Initialize string library
 *
 * History:
 *	08/11/97	gregj	Created
 */

#include "npcommon.h"

BOOL fDBCSEnabled = FALSE;

void WINAPI InitStringLibrary(void)
{
    ::fDBCSEnabled = ::GetSystemMetrics(SM_DBCSENABLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\cmp.cpp ===
#include "npcommon.h"

#ifdef strcmpf

#undef strcmpf
int WINAPI strcmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    return lstrcmp(lpStr1, lpStr2);
}

#else

// strcmpf(str1, str2)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2

int WINAPI strcmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    for (; *lpStr1 && *lpStr2; ADVANCE(lpStr1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lpStr1) ? GetTwoByteChar(lpStr1) : *lpStr1;
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : *lpStr2;

        if (ch1 > 0xff || ch2 > 0xff)
            nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);
        else
        {
            if (CollateTable[ch1] == CollateTable[ch2])
                nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);
            else
                nCmp = (CollateTable[ch1] < CollateTable[ch2]) ? -1 : 1;
        }

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lpStr1 > *lpStr2) ? -1 : (*lpStr1 == *lpStr2) ? 0 : 1;
}

#endif  /* ifndef strcmpf */


#ifdef stricmpf

#undef stricmpf
int WINAPI stricmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    return lstrcmpi(lpStr1, lpStr2);
}

#else

// stricmpf(str1, str2)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2
// All comparisons are case-insensitive

int WINAPI stricmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    for (; *lpStr1 && *lpStr2; ADVANCE(lpStr1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lpStr1) ? GetTwoByteChar(lpStr1) : *lpStr1;
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : *lpStr2;

        if (ch1 > 0xff || ch2 > 0xff)
            nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);
        else
        {
            ch1 = ToUpperCaseTable[ch1];
            ch2 = ToUpperCaseTable[ch2];
            if (CollateTable[ch1] == CollateTable[ch2])
                nCmp = 0;
            else
                nCmp = (CollateTable[ch1] < CollateTable[ch2]) ? -1 : 1;
        }

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lpStr1 > *lpStr2) ? -1 : (*lpStr1 == *lpStr2) ? 0 : 1;
}

#endif  /* ifndef stricmpf */


// strncmpf(str1, str2, cb)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2
// At most cb bytes are compared before returning

int WINAPI strncmpf(LPCSTR lpStr1, LPCSTR lpStr2, UINT cb)
{
    LPCSTR lp1 = lpStr1;

    for (; *lp1 && *lpStr2; ADVANCE(lp1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // see if we've reached the byte limit.  only need
        // to compare one string for length, since if they
        // get out of sync (DBCS only), we will get a compare
        // error immediately.
        if ((UINT)(lp1 - lpStr1) >= cb)
            return 0;   // no failures, reached limit

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lp1) ? GetTwoByteChar(lp1) : *lp1;
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : *lpStr2;

        nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  check the length to see if
    // we have compared as many bytes as needed.
    if ((UINT)(lp1 - lpStr1) >= cb)
        return 0;   // no failures, reached limit

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lp1 > *lpStr2) ? -1 : (*lp1 == *lpStr2) ? 0 : 1;
}


// strnicmpf(str1, str2, cb)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2
// All comparisons are case-insensitive
// At most cb bytes are compared

int WINAPI strnicmpf(LPCSTR lpStr1, LPCSTR lpStr2, UINT cb)
{
    LPCSTR lp1 = lpStr1;

    for (; *lp1 && *lpStr2; ADVANCE(lp1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // see if we've reached the byte limit.  only need
        // to compare one string for length, since if they
        // get out of sync (DBCS only), we will get a compare
        // error immediately.
        if ((UINT)(lp1 - lpStr1) >= cb)
            return 0;   // no failures, reached limit

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lp1) ? GetTwoByteChar(lp1) : PtrToUlong(CharUpper((LPTSTR) *((BYTE *)lp1)));
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : PtrToUlong(CharUpper((LPTSTR) *((BYTE *)lpStr2)));

        nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  check the length to see if
    // we have compared as many bytes as needed.
    if ((UINT)(lp1 - lpStr1) >= cb)
        return 0;   // no failures, reached limit

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lp1 > *lpStr2) ? -1 : (*lp1 == *lpStr2) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\dostime.cpp ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/
/* :ts=4 */

/***	dostime.cpp - map between DOS & NET time formats
 */

#include "npcommon.h"
#include <convtime.h>


#define YR_MASK		0xFE00
#define LEAPYR_MASK	0x0600
#define YR_BITS		7
#define MON_MASK	0x01E0
#define MON_BITS	4
#define DAY_MASK	0x001F
#define DAY_BITS	5

#define HOUR_MASK	0xF800
#define HOUR_BITS	5
#define MIN_MASK	0x07E0
#define MIN_BITS	6
#define SEC2_MASK	0x001F
#define SEC2_BITS	5

void
NetToDosDate(
DWORD time,
dos_time *pinfo)			// ptr for return data:
{
	UINT secs, days;
	WORD r;

    time = (time - _70_to_80_bias) / 2;	// # of 2 second periods since 1980
	secs = time % SEC2S_IN_DAY;			// 2 second period into day
	days = time / SEC2S_IN_DAY;			// days since Jan 1 1980

	r = secs % 30;					// # of 2 second steps
	secs /= 30;
	r |= (secs % 60) << SEC2_BITS;	// # of minutes
        r |= (secs / 60) << (SEC2_BITS+MIN_BITS);         // # of hours
	pinfo->dt_time = r;

	r = days / FOURYEARS;			// (r) = four year period past 1980
	days %= FOURYEARS;				// (days) = days into four year period
	r *= 4;							// (r) = years since 1980 (within 3)

	if (days == 31+28) {
		//* Special case for FEB 29th
		r = (r<<(MON_BITS+DAY_BITS)) + (2<<DAY_BITS) + 29;
	} else {
		if (days > 31+28)
			--days;						// compensate for leap year
		while (days >= 365) {
			++r;
			days -= 365;
		}

		for (secs = 1; days >= MonTotal[secs+1] ; ++secs)
			;
		days -= MonTotal[secs];
		r <<= MON_BITS;
		r += (unsigned short) secs;
		r <<= DAY_BITS;
		r += (unsigned short) days+1;
	}
	pinfo->dt_date = r;
}


DWORD
DosToNetDate(dos_time dt)
{
    UINT days, secs2;

        days = dt.dt_date >> (MON_BITS + DAY_BITS);
	days = days*365 + days/4;			// # of years in days
	days += (dt.dt_date & DAY_MASK) + MonTotal[(dt.dt_date&MON_MASK) >> DAY_BITS];
	if ((dt.dt_date&LEAPYR_MASK) == 0
				&& (dt.dt_date&MON_MASK) <= (2<<DAY_BITS))
		--days;						// adjust days for early in leap year

        secs2 = ( ((dt.dt_time&HOUR_MASK) >> (MIN_BITS+SEC2_BITS)) * 60
				+ ((dt.dt_time&MIN_MASK) >> SEC2_BITS) ) * 30
				+ (dt.dt_time&SEC2_MASK);
	return (DWORD)days*SECS_IN_DAY + _70_to_80_bias + (DWORD)secs2*2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\cpycat.cpp ===
#include "npcommon.h"

// strncpyf(dest, src, cb)
//
// Always stores cb bytes to dest.  If total characters copied
// ends up less than cb bytes, zero-fills dest.
// If strlen(src) >= cb, dest is NOT null-terminated.
// Returns dest.

LPSTR WINAPI strncpyf(LPSTR lpDest, LPCSTR lpSrc, UINT cbCopy)
{
    LPCSTR lpChr = lpSrc;
    UINT cbToCopy = 0;

    // find ptr past last char to copy
    while (*lpChr) {
        if (cbToCopy + (IS_LEAD_BYTE(*lpChr) ? 2 : 1) > cbCopy)
            break;  // copying this char would run over the limit
        cbToCopy += IS_LEAD_BYTE(*lpChr) ? 2 : 1;
        ADVANCE(lpChr);
    }

    // copy that many bytes
    memcpyf(lpDest, lpSrc, cbToCopy);
    memsetf(lpDest + cbToCopy, '\0', cbCopy - cbToCopy);

    return lpDest;
}


// strncatf(dest, src, cb)
//
// Concatenates at most cb bytes of src onto the end of dest.
// Unlike strncpyf, does not pad with extra nulls, but does
// guarantee a null-terminated destination.
// Returns dest.

LPSTR WINAPI strncatf(LPSTR lpDest, LPCSTR lpSrc, UINT cbCopy)
{
    LPCSTR lpChr = lpSrc;
    UINT cbToCopy = 0;

    // find ptr past last char to copy
    while (*lpChr) {
        if (cbToCopy + (IS_LEAD_BYTE(*lpChr) ? 2 : 1) > cbCopy)
            break;  // copying this char would run over the limit
        cbToCopy += IS_LEAD_BYTE(*lpChr) ? 2 : 1;
        ADVANCE(lpChr);
    }

    // copy that many bytes
    memcpyf(lpDest, lpSrc, cbToCopy);
    lpDest[cbToCopy] = '\0';

    return lpDest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\istr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	istr.cxx
	NLS/DBCS-aware string class: string index class

	This file contains the core implementation of the string
	indexer class.

	FILE HISTORY:
		gregj	03/30/93	Removed ISTR to separate module
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:      ISTR::ISTR

	SYNOPSIS:  ISTR construction methods

	ENTRY:
		ISTR::ISTR( ISTR& ) - Copy passed ISTR (both string and positional
							  info is copied).

		ISTR::ISTR( IB, NLS_STR& ) - Private, create an ISTR with index
									 at IB for string NLS_STR

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/20/90	Created

********************************************************************/

ISTR::ISTR( const ISTR& istr )
{
	*this = istr;
}


ISTR::ISTR( const NLS_STR& nls )
{
	*this = nls;
}


/*******************************************************************

	NAME:		ISTR::operator=

	SYNOPSIS:	Copy operator for the ISTR class

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		Johnl	11/20/90	Created
		gregj	03/30/93	Allow assignment of NLS_STR to ISTR

********************************************************************/

ISTR& ISTR::operator=( const ISTR& istr )
{
	_ibString = istr._ibString;
	SetPNLS( (NLS_STR *) istr.QueryPNLS() );
#ifdef DEBUG
	_usVersion = istr._usVersion;
#endif
	return *this;
}


ISTR& ISTR::operator=( const NLS_STR& nls )
{
	_ibString = 0;
	SetPNLS( &nls );
#ifdef DEBUG
	_usVersion = nls.QueryVersion();
#endif
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\iconlbox.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1993                         **/
/***************************************************************************/

/****************************************************************************

    ICONLBOX.C

    Implementation for IconListBox class

    May 93, JimH

    See ICONLBOX.H for details on use.

****************************************************************************/

#include "npcommon.h"
#include <windows.h>
#include <memory.h>
#include <iconlbox.h>

#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>


/****************************************************************************

IconListBox constructor

Some initialization is done here, and some is done in SetHeight
(when window handles are known.)

****************************************************************************/

IconListBox::IconListBox(HINSTANCE hInst, int nCtlID,
                    int iconWidth, int iconHeight) :
                    _nCtlID(nCtlID), _hInst(hInst),
                    _iconWidth(iconWidth), _iconHeight(iconHeight),
                    _hbrSelected(NULL), _hbrUnselected(NULL),
                    _fCombo(FALSE), _cIcons(0), _cTabs(0),_iCurrentMaxHorzExt(0),
                    _hwndDialog(NULL), _hwndListBox(NULL)
{
    _colSel       = ::GetSysColor(COLOR_HIGHLIGHT);
    _colSelText   = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
    _colUnsel     = ::GetSysColor(COLOR_WINDOW);
    _colUnselText = ::GetSysColor(COLOR_WINDOWTEXT);
}


/****************************************************************************

IconListBox destructor

deletes any GDI objects created by IconListBox

****************************************************************************/

IconListBox::~IconListBox()
{
    for (int i = 0; i < _cIcons; i++)
    {
        if (_aIcons[i].hbmSelected)
        {
            if (_aIcons[i].hbmSelected)
            {
                ::DeleteObject(_aIcons[i].hbmSelected);
                ::DeleteObject(_aIcons[i].hbmUnselected);
            }

            // Subsequent _aIcons may have used the same bitmap.
            // Mark those as already deleted.

            for (int j = i + 1; j < _cIcons; j++)
            {
                if (_aIcons[j].nResID == _aIcons[i].nResID)
                {
                    _aIcons[j].hbmSelected = NULL;
                    _aIcons[j].hbmUnselected = NULL;
                }
            }
        }
    }

    if (_hbrSelected)
        ::DeleteObject(_hbrSelected);

    if (_hbrUnselected)
        ::DeleteObject(_hbrUnselected);
}


/****************************************************************************

IconListBox::SetHeight

This function MUST be called in reponse to the WM_MEASUREITEM message.
It creates some GDI objects, and initializes class variables not known
at construction time.

****************************************************************************/

void IconListBox::SetHeight(HWND hwndDlg,
                        LPMEASUREITEMSTRUCT lpm,
                        int itemHeight)             // defaults to 16
{
    ASSERT(hwndDlg != NULL);
    ASSERT((int)lpm->CtlID == _nCtlID);

    _hwndDialog  = hwndDlg;
    _hwndListBox = ::GetDlgItem(_hwndDialog, _nCtlID);

    // Determine if this is a combo box

    char    szClass[32];
    GetClassName(_hwndListBox,szClass,sizeof(szClass));
    if (::lstrcmpi(szClass,"combobox") == 0 )
         _fCombo = TRUE;


    // Create the background brushes used for filling listbox entries...

    _hbrSelected   = ::CreateSolidBrush(_colSel);
    _hbrUnselected = ::CreateSolidBrush(_colUnsel);

    // Calculate how to centre the text vertically in the listbox item.

    TEXTMETRIC  tm;
    HDC         hDC = ::GetDC(hwndDlg);

    GetTextMetrics(hDC, &tm);

    // Set the only lpm entry that matters

	// allow larger height if passed in - but at least large enough
	// to fit font.

	lpm->itemHeight = max( itemHeight, tm.tmHeight + tm.tmExternalLeading );

    _nTextOffset = tm.tmExternalLeading / 2 + 1;

    ::ReleaseDC(hwndDlg, hDC);
}


/****************************************************************************

IconListBox::DrawItem

This function MUST be called in response to the WM_DRAWITEM message.
It takes care of drawing listbox items in selected or unselected state.

Drawing and undrawing the focus rectangle takes advantage of the fact
that DrawFocusRect uses an XOR pen, and Windows is nice enough to assume
this in the order of the ODA_FOCUS messages.

****************************************************************************/

void IconListBox::DrawItem(LPDRAWITEMSTRUCT lpd)
{
    ASSERT(_hwndDialog != NULL);    // make sure SetHeight has been called

    char string[MAXSTRINGLEN];
    BOOL bSelected = (lpd->itemState & ODS_SELECTED);

    GetString(lpd->itemID, string);

    // fill entire rectangle with background color

    ::FillRect(lpd->hDC, &(lpd->rcItem),
                            bSelected ? _hbrSelected : _hbrUnselected);

    // Look for registered icon to display, and paint it if found

    for (int id = 0; id < _cIcons; id++)
        if (_aIcons[id].nID == (int) lpd->itemData)
            break;

    if (id != _cIcons)              // if we found a bitmap to display
    {
        HDC hdcMem = ::CreateCompatibleDC(lpd->hDC);
        HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hdcMem,
            bSelected ? _aIcons[id].hbmSelected : _aIcons[id].hbmUnselected);

        // draw bitmap ICONSPACE pixels from left and centred vertically

        int x = lpd->rcItem.left + ICONSPACE;
        int y = ((lpd->rcItem.bottom - lpd->rcItem.top) - _iconHeight) / 2;
        y += lpd->rcItem.top;

        ::BitBlt(lpd->hDC, x, y, _iconWidth, _iconHeight, hdcMem,
                    _aIcons[id].x, _aIcons[id].y, SRCCOPY);

        ::SelectObject(hdcMem, hOldBitmap);
        ::DeleteDC(hdcMem);
    }

	if (lpd->itemState & ODS_FOCUS)
        ::DrawFocusRect(lpd->hDC, &(lpd->rcItem));


    lpd->rcItem.left += (_iconWidth + (2 * ICONSPACE));

    // Paint string

    ::SetTextColor(lpd->hDC, bSelected ? _colSelText : _colUnselText);
    ::SetBkColor(lpd->hDC, bSelected ? _colSel : _colUnsel);
    (lpd->rcItem.top) += _nTextOffset;

    if (_cTabs == 0)        // if no tabs registered
    {
        ::DrawText(lpd->hDC, string, lstrlen(string), &(lpd->rcItem),
                        DT_LEFT | DT_EXPANDTABS);
    }
    else
    {
        ::TabbedTextOut(lpd->hDC, lpd->rcItem.left, lpd->rcItem.top,
                string, lstrlen(string), _cTabs, _aTabs, 0);
    }
}


/****************************************************************************

IconListBox::RegisterIcons

Icons must be registered before they can be referenced in AddString.

Note that if you are using several icons from the same bitmap (with different
x and y offsets) they must all have the same background color.

****************************************************************************/

void IconListBox::RegisterIcon( int nIconID,            // caller's code
                                int nResID,             // RC file id
                                int x, int y,           // top left corner
                                COLORREF colTransparent)  // def. bright green
{
    ASSERT( _cIcons < MAXICONS );

    _aIcons[_cIcons].nID    = nIconID;
    _aIcons[_cIcons].nResID = nResID;
    _aIcons[_cIcons].x = x;
    _aIcons[_cIcons].y = y;

    // Check to see if we already have bitmaps for this resource ID
    // (which may have different x and y offsets.)

    for (int i = 0; i < _cIcons; i++)
    {
        if (_aIcons[i].nResID == nResID)
        {
            _aIcons[_cIcons].hbmSelected   = _aIcons[i].hbmSelected;
            _aIcons[_cIcons].hbmUnselected = _aIcons[i].hbmUnselected;
            _cIcons++;
            return;
        }
    }

    // Otherwise, create new selected and unselected bitmaps

    // Get pointer to DIB

    HRSRC h = ::FindResource(_hInst, MAKEINTRESOURCE(nResID), RT_BITMAP);
    if (h == NULL)
        return;

    HANDLE hRes = ::LoadResource(_hInst, h);
    if (hRes == NULL)
        return;

    LPBITMAPINFOHEADER lpInfo = (LPBITMAPINFOHEADER) LockResource(hRes);
    if (NULL == lpInfo)
        return;

    // Get pointers to start of color table, and start of actual bitmap bits

    // Note that we make a copy of the bitmap header info and the color
    // table.  This is so applications that use iconlistbox can keep their
    // resource segments read only.

    LPBYTE lpBits = (LPBYTE)
                (lpInfo + 1) + (1 << (lpInfo->biBitCount)) * sizeof(RGBQUAD);

    int cbCopy = (int) (lpBits - (LPBYTE)lpInfo);

    BYTE *lpCopy = new BYTE[cbCopy];

    if (!lpCopy)
        return;

    memcpy(lpCopy, lpInfo, cbCopy);

    RGBQUAD FAR *lpRGBQ =
                    (RGBQUAD FAR *) ((LPSTR)lpCopy + lpInfo->biSize);

    // Find transparent color in color table

    BOOL bFound = FALSE;            // did we find a transparent match?

    int nColorTableSize = (int) (lpBits - (LPBYTE)lpRGBQ);
    nColorTableSize /= sizeof(RGBQUAD);

    for (i = 0; i < nColorTableSize; i++)
    {
        if (colTransparent ==
                RGB(lpRGBQ[i].rgbRed, lpRGBQ[i].rgbGreen, lpRGBQ[i].rgbBlue))
        {
            bFound = TRUE;
            break;
        }
    }

    // Replace the transparent color with the background for selected and
    // unselected entries.  Use these to create selected and unselected
    // bitmaps, and restore color table.

    RGBQUAD rgbqTemp;                       // color table entry to replace
    HDC hDC = ::GetDC(_hwndDialog);

    if (bFound)
    {
        rgbqTemp = lpRGBQ[i];
        lpRGBQ[i].rgbRed   = GetRValue(_colUnsel);
        lpRGBQ[i].rgbBlue  = GetBValue(_colUnsel);
        lpRGBQ[i].rgbGreen = GetGValue(_colUnsel);
    }
    _aIcons[_cIcons].hbmUnselected = ::CreateDIBitmap(hDC,
                            (LPBITMAPINFOHEADER)lpCopy, CBM_INIT, lpBits,
                            (LPBITMAPINFO)lpCopy, DIB_RGB_COLORS);

    if (bFound)
    {
        lpRGBQ[i].rgbRed   = GetRValue(_colSel);
        lpRGBQ[i].rgbBlue  = GetBValue(_colSel);
        lpRGBQ[i].rgbGreen = GetGValue(_colSel);
    }
    _aIcons[_cIcons].hbmSelected = ::CreateDIBitmap(hDC,
                            (LPBITMAPINFOHEADER)lpCopy, CBM_INIT, lpBits,
                            (LPBITMAPINFO)lpCopy, DIB_RGB_COLORS);

    if (bFound)
        lpRGBQ[i] = rgbqTemp;           // restore original color table entry

    ::ReleaseDC(_hwndDialog, hDC);
    ::FreeResource(hRes);
    delete [] lpCopy;

    _cIcons++;
}


/****************************************************************************

IconListBox::SetTabStops

Since this is an owner-draw listbox, we can't rely on LB_SETTABS.
Instead, tabs are registered here and TabbedTextOut is used to display
strings.  Dialogbox units have to be converted to pixels.

****************************************************************************/

void IconListBox::SetTabStops(int cTabs, const int *pTabs)
{
    ASSERT(cTabs <= MAXTABS);

    int nSize  = (int) LOWORD(GetDialogBaseUnits());

    for (int i = 0; i < cTabs; i++)
        _aTabs[i] = ((nSize * pTabs[i]) / 4);

    _cTabs = cTabs;
}

/****************************************************************************

IconListBox::UpdateHorizontalExtent

****************************************************************************/
int IconListBox::UpdateHorizontalExtent(int	nIcon,const char *string)
{
    ASSERT(_hwndDialog != NULL);    // make sure SetHeight has been called

	if (!string)
		return 0;
	// Calculate width in pixels for given string, taking into account icon, spacing and tabs
    int iItemWidth = ICONSPACE + (_iconWidth + (2 * ICONSPACE));
    HDC	hDC = ::GetDC(_hwndDialog);
	iItemWidth += LOWORD(GetTabbedTextExtent(hDC,string,::lstrlen(string),_cTabs, _aTabs));
    ::ReleaseDC(_hwndDialog, hDC);

	// Update maximum value
    _iCurrentMaxHorzExt = max(_iCurrentMaxHorzExt,iItemWidth);

	return (int)SendDlgItemMessage(_hwndDialog,_nCtlID,
								LB_SETHORIZONTALEXTENT,
								(WPARAM)_iCurrentMaxHorzExt,0L);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\istraux.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	istraux.cpp
	NLS/DBCS-aware string class: secondary methods of index class

	This file contains the implementation of the auxiliary methods
	for the ISTR class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx
		beng	04/26/91	Relocated some funcs from string.hxx
		gregj	03/25/93	Ported to Chicago environment
		gregj	04/02/93	Use NLS_STR::IsDBCSLeadByte()
*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		ISTR::Reset

	SYNOPSIS:	Reset the ISTR so the index is 0;
				updates the version number of the string.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		Johnl	11/28/90	Created

********************************************************************/

VOID ISTR::Reset()
{
	_ibString = 0;
#ifdef DEBUG
	_usVersion = QueryPNLS()->QueryVersion();
#endif
}


/*******************************************************************

	NAME:		ISTR::operator-

	SYNOPSIS:	Returns the difference in CB between the two ISTR

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		Johnl	11/28/90	Created

********************************************************************/

INT ISTR::operator-( const ISTR& istr2 ) const
{
	UIASSERT( QueryPNLS() == istr2.QueryPNLS() );

	return ( QueryIB() - istr2.QueryIB() );
}


/*******************************************************************

	NAME:		ISTR::operator++

	SYNOPSIS:	Increment the ISTR to the next logical character

	ENTRY:

	EXIT:

	NOTES:		Stops if we are at the end of the string

	HISTORY:
		Johnl	11/28/90	Created
		beng	07/23/91	Simplified CheckIstr

********************************************************************/

ISTR& ISTR::operator++()
{
	QueryPNLS()->CheckIstr( *this );
	CHAR c = *(QueryPNLS()->QueryPch() + QueryIB());
	if ( c != '\0' )
	{
		SetIB( QueryIB() + (QueryPNLS()->IsDBCSLeadByte(c) ? 2 : 1) );
	}
	return *this;
}


/*******************************************************************

	NAME:		ISTR::operator+=

	SYNOPSIS:	Increment the ISTR to the nth logical character

	NOTES:		Stops if we are at the end of the string

	HISTORY:
		Johnl	01/14/90	Created

********************************************************************/

VOID ISTR::operator+=( INT iChars )
{
	while ( iChars-- )
		operator++();
}


/*******************************************************************

	NAME:		ISTR::operator==

	SYNOPSIS:	Equality operator

	RETURNS:	TRUE if the two ISTRs are equivalent.

	NOTES:		Only valid between two ISTRs of the same string.

	HISTORY:
		beng	07/22/91	Header added

********************************************************************/

BOOL ISTR::operator==( const ISTR& istr ) const
{
	UIASSERT( QueryPNLS() == istr.QueryPNLS() );
	return QueryIB() == istr.QueryIB();
}


/*******************************************************************

	NAME:		ISTR::operator>

	SYNOPSIS:	Greater-than operator

	RETURNS:	TRUE if this ISTR points further into the string
				than the argument.

	NOTES:		Only valid between two ISTRs of the same string.

	HISTORY:
		beng	07/22/91	Header added

********************************************************************/

BOOL ISTR::operator>( const ISTR& istr )  const
{
	UIASSERT( QueryPNLS() == istr.QueryPNLS() );
	return QueryIB() > istr.QueryIB();
}


/*******************************************************************

	NAME:		ISTR::operator<

	SYNOPSIS:	Lesser-than operator

	RETURNS:	TRUE if this ISTR points less further into the string
				than the argument.

	NOTES:		Only valid between two ISTRs of the same string.

	HISTORY:
		beng	07/22/91	Header added

********************************************************************/

BOOL ISTR::operator<( const ISTR& istr )  const
{
	UIASSERT( QueryPNLS() == istr.QueryPNLS() );
	return QueryIB() < istr.QueryIB();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\npcommon.h ===
#include <npdefs.h>
#include <netlib.h>

#define ADVANCE(p)    (p += IS_LEAD_BYTE(*p) ? 2 : 1)

#define SPN_SET(bits,ch)    bits[(ch)/8] |= (1<<((ch) & 7))
#define SPN_TEST(bits,ch)    (bits[(ch)/8] & (1<<((ch) & 7)))

// The following is created to avoid an alignment fault on Win64 platforms.
inline UINT GetTwoByteChar( LPCSTR lpString )
{
    BYTE        bFirst = *lpString;

    lpString++;

    BYTE        bSecond = *lpString;

    UINT        uiChar = ( bFirst << 8) | bSecond;

    return uiChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\npassert.cpp ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/*
    uiassert.c
    Environment specific stuff for the UIASSERT & REQUIRE macro

    This file contains the environment specific (windows vs. OS/2/DOS)
    features of the assert macro, specifically, the output method
    (everything is hidden by the standard C-Runtime).

    FILE HISTORY:
        johnl       10/17/90    Created
        johnl       10/18/90    Added OutputDebugString
        beng        04/30/91    Made a 'C' file
        beng        08/05/91    Withdrew expressions; reprototyped
                                all functions
        beng        09/17/91    Withdrew additional consistency checks
        beng        09/26/91    Withdrew nprintf calls
        gregj       03/23/93    Ported to Chicago environment
*/

#include "npcommon.h"
#include "npassert.h"

extern "C" {

const CHAR szShouldBeAnsi[] = "String should be ANSI but isn't";
const CHAR szShouldBeOEM[] = "String should be OEM but isn't";

static CHAR szFmt0[] = "File %.40s, Line %u";
static CHAR szFmt1[] = "%.60s: File %.40s, Line %u";
static CHAR szMBCaption[] = "ASSERTION FAILED";
static CHAR szFAE[] = "ASSERTION FAILURE IN APP";

VOID UIAssertHelper(
    const CHAR* pszFileName,
    UINT    nLine )
{
    CHAR szBuff[sizeof(szFmt0)+60+40];

    wsprintf(szBuff, szFmt0, pszFileName, nLine);
    MessageBox(NULL, szBuff, szMBCaption,
           (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    FatalAppExit(0, szFAE);
}


VOID UIAssertSzHelper(
    const CHAR* pszMessage,
    const CHAR* pszFileName,
    UINT    nLine )
{
    CHAR szBuff[sizeof(szFmt1)+60+40];

    wsprintf(szBuff, szFmt1, pszMessage, pszFileName, nLine);
    MessageBox(NULL, szBuff, szMBCaption,
           (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    FatalAppExit(0, szFAE);
}

//========== Debug output routines =========================================

UINT uiNetDebugMask = 0xffff;

UINT WINAPI NetSetDebugMask(UINT mask)
{
#ifdef DEBUG
    UINT uiOld = uiNetDebugMask;
    uiNetDebugMask = mask;

    return uiOld;
#else
    return 0;
#endif
}

UINT WINAPI NetGetDebugMask()
{
#ifdef DEBUG
    return uiNetDebugMask;
#else
    return 0;
#endif
}

#ifndef WINCAPI
#ifdef WIN32
#define WINCAPI __cdecl
#else
#define WINCAPI __far __cdecl
#endif
#endif

#ifdef DEBUG

/* debug message output log file */

UINT 	g_uSpewLine = 0;
PCSTR 	g_pcszSpewFile = NULL;
CHAR	s_cszLogFile[MAX_PATH] = {'\0'};
CHAR	s_cszDebugName[MAX_PATH] = {'\0'};

UINT WINAPI  NetSetDebugParameters(PSTR pszName,PSTR pszLogFile)
{
	lstrcpy(s_cszLogFile,pszLogFile);
	lstrcpy(s_cszDebugName,pszName);

	return 0;
}


BOOL LogOutputDebugString(PCSTR pcsz)
{
   BOOL 	bResult = FALSE;
   UINT 	ucb;
   char 	rgchLogFile[MAX_PATH];

   if (IS_EMPTY_STRING(s_cszLogFile) )
	   return FALSE;

   ucb = GetWindowsDirectory(rgchLogFile, sizeof(rgchLogFile));

   if (ucb > 0 && ucb < sizeof(rgchLogFile)) {

      HANDLE hfLog;

      lstrcat(rgchLogFile, "\\");
      lstrcat(rgchLogFile, s_cszLogFile);

      hfLog = ::CreateFile(rgchLogFile,
						   GENERIC_WRITE,
						   0,
						   NULL,
						   OPEN_ALWAYS,
						   0,
						   NULL);

      if (hfLog != INVALID_HANDLE_VALUE) {

         if (SetFilePointer(hfLog, 0, NULL, FILE_END) != INVALID_FILE_SIZE) {
            DWORD dwcbWritten;

            bResult = WriteFile(hfLog, pcsz, lstrlen(pcsz), &dwcbWritten, NULL);

            if (! CloseHandle(hfLog) && bResult)
               bResult = FALSE;
         }
      }
   }

   return(bResult);
}

CHAR	*achDebugDisplayPrefix[] = {"t ","w ","e ","a ","t ","t ","t ","t ","t ","t ","t "};

void WINCAPI NetDebugMsg(UINT mask, LPCSTR pszMsg, ...)
{
    char 	ach[1024];
	UINT	uiDisplayMask = mask & 0xff;

	// Determine prefix
	*ach = '\0';
	if (uiNetDebugMask & DM_PREFIX) {
		// Add trace type
		::lstrcat(ach,achDebugDisplayPrefix[uiDisplayMask]);

		// Add component name
		::lstrcat(ach,s_cszDebugName);

		// Add thread ID
		CHAR	szThreadId[16];
		::wsprintf(szThreadId,"[%#lx] ",::GetCurrentThreadId());
		::lstrcat(ach,szThreadId);
	}

    ::wvsprintf(ach+::lstrlen(ach), pszMsg, (va_list)((&pszMsg) + 1));
	::lstrcat(ach,"\r\n");

	if (uiNetDebugMask & DM_LOG_FILE) {
		 LogOutputDebugString(ach);
	}

	// Check if we need to display this trace
    if (uiNetDebugMask & uiDisplayMask) {
        OutputDebugString(ach);
    }
}

#endif

}   /* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\npgenerr.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* NPGENERR.C -- Implementation of the DisplayGenericError subroutine.
 *
 * History:
 *	10/07/93	gregj	Created
 */

#include "npcommon.h"
#include "npmsg.h"
#include "npstring.h"

/*******************************************************************

	NAME:		DisplayGenericError

	SYNOPSIS:	Displays an error message, substituting in a
				description of an error code.

	ENTRY:		hwnd - parent window handle
				msg  - string ID for message template
				err  - error code to substitute in
				psz1 - main substitution string
				psz2 - error code substitution string
				wFlags - flags to MessageBox
				nMsgBase - bias for error code

	EXIT:		Returns control ID of user's choice

	NOTES:		nMsgBase is so that the error code need not
				be the same as the string ID.  It is added to
				the error code before loading the description,
				but the error code alone is the number inserted
				into the template.

				The text for "msg" should be of the form:

				The following error occurred while trying to fiddle with %1:

				Error %2: %3

				Do you want to continue fiddling?

				The text for "err" (+nMsgBase if appropriate) should
				be of the form:

				%1 cannot be fiddled with.

				In the primary message, %1 is replaced with psz1, %2
				is replaced with atoi(err), and %3 is replaced with
				a LoadString of "err".  In the specific error text,
				%1 is replaced with psz2.

	HISTORY:
		gregj	09/30/93	Created for Chicago

********************************************************************/

UINT DisplayGenericError(HWND hwnd, UINT msg, UINT err, LPCSTR psz1, LPCSTR psz2,
						 WORD wFlags, UINT nMsgBase)
{
	/*
	 * setup the object name
	 */
	NLS_STR nlsObjectName(STR_OWNERALLOC, (LPSTR)psz1);

	/*
	 * now the error number
	 */
	CHAR szErrorCode[16];
	wsprintf(szErrorCode,"%u",err);
	NLS_STR nlsErrorCode(STR_OWNERALLOC, szErrorCode);

	/*
	 * fetch the error string. If cannot get, use "".
	 */
	NLS_STR nlsSub1(STR_OWNERALLOC, (LPSTR)psz2);

	NLS_STR *apnlsParamStrings[4];
	apnlsParamStrings[0] = &nlsSub1;
	apnlsParamStrings[1] = NULL;

	NLS_STR nlsErrorString(NULL) ;
	nlsErrorString.LoadString(err + nMsgBase, (const NLS_STR **)apnlsParamStrings);
	err = nlsErrorString.QueryError() ;
	if (err)
		nlsErrorString = (const CHAR *)NULL;

	/*
	 * then create the insert strings table
	 */
	apnlsParamStrings[0] = &nlsObjectName;
	apnlsParamStrings[1] = &nlsErrorCode;
	apnlsParamStrings[2] = &nlsErrorString;
	apnlsParamStrings[3] = NULL;

    return MsgBox(hwnd, msg, wFlags, (const NLS_STR **)apnlsParamStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\npmsg.cpp ===
/*****************************************************************/
/**                  Microsoft Windows for Workgroups                **/
/**              Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/ 

/* NPMSG.CPP -- Implementation of MsgBox subroutine.
 *
 * History:
 *    05/06/93    gregj    Created
 */

#include "npcommon.h"
#include "npmsg.h"
#include "npstring.h"

#include <mluisupp.h>

extern "C" {
#include <netlib.h>
};

LPSTR pszTitle = NULL;

int MsgBox( HWND hwndOwner, UINT idMsg, UINT wFlags, const NLS_STR **apnls /* = NULL */ )
{
    if (pszTitle == NULL) {
        pszTitle = new char[MAX_RES_STR_LEN];
        if (pszTitle != NULL) {
            MLLoadString(IDS_MSGTITLE, pszTitle, MAX_RES_STR_LEN );
            UINT cbTitle = ::strlenf(pszTitle) + 1;
            delete pszTitle;
            pszTitle = new char[cbTitle];
            if (pszTitle != NULL)
                MLLoadStringA(IDS_MSGTITLE, pszTitle, cbTitle);
        }
    }
    NLS_STR nlsMsg( MAX_RES_STR_LEN );
    if (apnls == NULL)
        nlsMsg.LoadString((unsigned short) idMsg );
    else
        nlsMsg.LoadString((unsigned short) idMsg, apnls );
    return ::MessageBox( hwndOwner, nlsMsg, pszTitle, wFlags | MB_SETFOREGROUND );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\npcrit.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1993-1994			**/
/*****************************************************************/ 

/* npcrit.c -- Implementation of critical section classes.
 *
 * History:
 *	11/01/93	gregj	Created
 */

#include "npcommon.h"
#include <npcrit.h>
#include <npassert.h>

/*
 * Very simple interlock routines, used to stop race conditions when
 * initializing and de-initializing critical sections.  Do NOT use
 * these for anything other than infrequent extremely short-term locks, 
 * since WaitForInterlock contains a spin loop with a millisecond delay!
 */
BYTE InterlockedSet(volatile BYTE *pByte)
{
	BYTE bRet;
	_asm {
		mov		edi, pByte
		mov		al, 1
		xchg	[edi], al		/* store non-zero value, get what was there before */
		mov		bRet, al
	}
	return bRet;
}

void WaitForInterlock(volatile BYTE *pByte)
{
	for (;;) {
		BYTE bAlreadyOwned = InterlockedSet(pByte);	/* attempt to grab the interlock */
		if (!bAlreadyOwned)				/* is someone else in there? */
			break;						/* nope, we now own it */
		Sleep(1);						/* yield to whomever owns it, then try again */
	}
}

void ReleaseInterlock(volatile BYTE *pByte)
{
	*pByte = 0;							/* clear the interlock to release others */
}

#if 0
// Remove CRITSEC code but keep for a while before deleting.
/*******************************************************************

    NAME:		CRITSEC::Init

    SYNOPSIS:	Initializes a global critical section object

    ENTRY:		pszName - name for the critical section

    EXIT:		No return value

    NOTES:		Currently pszName is not used;  it will be used
				for named mutexes later.

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Init(char *pszName)
{
	WaitForInterlock(&_bInterlock);
	if (!_fInitialized) {
		::InitializeCriticalSection(&_critsec);
#ifdef DEBUG
		_wClaimCount = 0;
#endif
		_fInitialized = 1;
	}
	ReleaseInterlock(&_bInterlock);
	_cClients++;
}


/*******************************************************************

    NAME:		CRITSEC::Term

    SYNOPSIS:	Cleans up resources allocated for a critical section

    ENTRY:		No parameters

    EXIT:		No return value

    NOTES:		This function should be callled at process attach.
				It will take care of making sure it only deletes
				the critical section when the last process using
				it calls Term().

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Term()
{
	WaitForInterlock(&_bInterlock);
	BOOL fShouldCleanUp = (--_cClients == 0);
	if (fShouldCleanUp) {
		::DeleteCriticalSection(&_critsec);
		_fInitialized = 0;
	}
	ReleaseInterlock(&_bInterlock);
}


#ifdef DEBUG		/* in retail, these are inline */
/*******************************************************************

    NAME:		CRITSEC::Enter

    SYNOPSIS:	Enters a critical section

    ENTRY:		No parameters

    EXIT:		No return value;  critical section is owned by
				the calling thread

    NOTES:		This function is private, and is invoked indirectly
				by the friend class TAKE_CRITSEC.

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Enter()
{
#ifdef DEBUG
	UIASSERT(_fInitialized != 0);
#endif

	::EnterCriticalSection(&_critsec);

#ifdef DEBUG
	_wClaimCount++;
#endif
}


/*******************************************************************

    NAME:		CRITSEC::Leave

    SYNOPSIS:	Leaves a critical section

    ENTRY:		No parameters

    EXIT:		No return value;  critical section is released

    NOTES:		This function is private, and is invoked indirectly
				by the friend class TAKE_CRITSEC.

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Leave()
{
#ifdef DEBUG
	UIASSERT(_fInitialized != 0);
	UIASSERT(_wClaimCount > 0);
	_wClaimCount--;
#endif

	::LeaveCriticalSection(&_critsec);
}
#endif	/* DEBUG */
#endif	/* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\purecall.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* PURECALL.C -- Implementation of __purecall function.
 *
 * History:
 *	04/11/94	gregj	Created
 */

#include "npcommon.h"

extern "C" {

/*
 * This function serves to avoid linking CRT code like assert etc.
 * we really don;t do anything when pure virtual function is not redefined
 */

int __cdecl  _purecall(void)
{
#ifdef DEBUG
	DebugBreak();
#endif

	return(FALSE);
}

int __cdecl atexit(void (__cdecl *)(void))
{
	return 0;
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\str.cpp ===
#include "npcommon.h"

// strstrf(str, srch)
//
// Returns a pointer to the first occurrence of srch within
// str (like strchrf, but search parameter is a string, not
// a single character).  Returns NULL if not found.
// REVIEW: simple algorithm here, but depending on usage,
// might be overkill to complicate it.

LPSTR WINAPI strstrf(LPCSTR lpString, LPCSTR lpSearch)
{
    INT cbSearch = strlenf(lpSearch);
    INT cbToSearch;
    LPSTR lp;

    // calculate the maximum distance to go -- the length
    // of the string to look in less the length of the
    // string to search for, since beyond that the string
    // being searched for would not fit.
    cbToSearch = strlenf(lpString) - cbSearch;
    if (cbToSearch < 0)
        return NULL;    /* string being searched is shorter */

    for (lp = (LPSTR)lpString; lp - lpString <= cbToSearch; ADVANCE(lp)) {
        if (strncmpf(lp, lpSearch, cbSearch) == 0)
            return lp;
    }

    return NULL;
}


// stristrf(str, srch)
//
// Returns a pointer to the first occurrence of srch within
// str, case-insensitive.  Returns NULL if not found.
// REVIEW: simple algorithm here, but depending on usage,
// might be overkill to complicate it.

LPSTR WINAPI stristrf(LPCSTR lpString, LPCSTR lpSearch)
{
    INT cbSearch = strlenf(lpSearch);
    INT cbToSearch;
    LPSTR lp;

    // calculate the maximum distance to go -- the length
    // of the string to look in less the length of the
    // string to search for, since beyond that the string
    // being searched for would not fit.
    cbToSearch = strlenf(lpString) - cbSearch;
    if (cbToSearch < 0)
        return NULL;    /* string being searched is shorter */

    for (lp = (LPSTR)lpString; lp - lpString <= cbToSearch; ADVANCE(lp)) {
        if (strnicmpf(lp, lpSearch, cbSearch) == 0)
            return lp;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\spn.cpp ===
#include "npcommon.h"

void InitSpn(
    char *abBits,
    char *abDBCBits,
    LPCSTR lpSpn
)
{
    LPCSTR lpCur;

    ::memset(abBits, '\0', 256/8);
    if (::fDBCSEnabled)
        ::memset(abDBCBits, '\0', 256/8);

    for (lpCur = lpSpn; *lpCur; ADVANCE(lpCur)) {
        if (IS_LEAD_BYTE(*lpCur)) {
            char chXOR = *lpCur ^ *(lpCur+1);
            SPN_SET(abDBCBits, chXOR);
        }
        else
            SPN_SET(abBits, *lpCur);
    }
}

// strspn(str, spn)
//
// Returns count of leading characters in str which exist
// in spn;  equivalent to returning the index of the first
// character which is not in spn.

UINT WINAPI strspnf(LPCSTR lpString, LPCSTR lpSpn)
{
    char abBits[256/8];
    char abDBCBits[256/8];
    LPCSTR lpCur;

    InitSpn(abBits, abDBCBits, lpSpn);

    for (lpCur = lpString; *lpCur; ADVANCE(lpCur)) {
        if (IS_LEAD_BYTE(*lpCur)) {
            char chXOR = *lpCur ^ *(lpCur + 1);
            if (!SPN_TEST(abDBCBits, chXOR) ||
                (strchrf(lpSpn, GetTwoByteChar(lpCur)) == NULL))
                break;
        }
        else if (!SPN_TEST(abBits, *lpCur))
            break;
    }

    return (UINT) (lpCur - lpString);
}


// strcspn(str, spn)
//
// Returns count of leading characters in str which do not
// exist in spn;  equivalent to returning the index of the
// first character which is in spn.

UINT WINAPI strcspnf(LPCSTR lpString, LPCSTR lpSpn)
{
    char abBits[256/8];
    char abDBCBits[256/8];
    LPCSTR lpCur;

    InitSpn(abBits, abDBCBits, lpSpn);

    for (lpCur = lpString; *lpCur; ADVANCE(lpCur)) {
        if (IS_LEAD_BYTE(*lpCur)) {
            char chXOR = *lpCur ^ *(lpCur + 1);
            if (SPN_TEST(abDBCBits, chXOR) &&
                (strchrf(lpSpn, GetTwoByteChar(lpCur)) != NULL))
                break;
        }
        else if (SPN_TEST(abBits, *lpCur))
            break;
    }
    return (UINT)(lpCur-lpString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\stratoi.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stratoi.cxx
	NLS/DBCS-aware string class: atoi method

	This file contains the implementation of the atoi method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this member function need not link to it.

	FILE HISTORY:
		markbl	06/04/91	Created

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
	#include <stdlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::atoi

	SYNOPSIS:	Returns *this in its integer numeric equivalent

	ENTRY:		With no arguments, parses from beginning of string.
				Given an ISTR, starts at that point within the string.

	EXIT:

	NOTES:		Uses C-Runtime atoi function

	HISTORY:
		markbl	06/04/91	Written
		beng	07/22/91	Callable on erroneous string; simplified CheckIstr

********************************************************************/

INT NLS_STR::atoi() const
{
	if (QueryError())
		return 0;

	return ::atoi( _pchData );
}


INT NLS_STR::atoi( const ISTR & istrStart ) const
{
	if (QueryError())
		return 0;

	CheckIstr( istrStart );

	return ::atoi( QueryPch(istrStart) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strassgn.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strassgn.cxx
	NLS/DBCS-aware string class: assignment operator

	This file contains the implementation of the assignment operator
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx
		beng	07/26/91	Replaced min with local inline
		gregj	04/02/93	Do buffer overflow checks for OWNERALLOC strings
							instead of asserting
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::operator=

	SYNOPSIS:	Assignment operator

	ENTRY:		Either NLS_STR or CHAR*.

	EXIT:		If successful, contents of string overwritten.
				If failed, the original contents of the string remain.

	RETURNS:	Reference to self.

	HISTORY:
		beng	10/23/90	Created
		johnl	11/13/90	Added UIASSERTion checks for using bad
							strings
		beng	02/05/91	Uses CHAR * instead of PCH
		Johnl	03/06/91	Removed assertion check for *this
							being valid
		johnl	04/12/91	Resets error variable on PCH assignment
							if successful.
		beng	07/22/91	Allow assignment of an erroneous string;
							reset error on nls assignment as well
		gregj	04/02/93	Do buffer overflow checks for OWNERALLOC strings
							instead of asserting

********************************************************************/

NLS_STR& NLS_STR::operator=( const NLS_STR& nlsSource )
{
	if ( this == &nlsSource )
		return *this;

	if (!nlsSource)
	{
		// Assignment of an erroneous string
		//
		ReportError((unsigned short)nlsSource.QueryError());
		return *this;
	}

	INT cbToCopy = nlsSource.strlen();

	if ( !IsOwnerAlloc() )
	{
		if ( QueryAllocSize() < nlsSource.strlen()+1 )
		{
			/* Don't use Realloc because we want to retain the contents
			 * of the string if we fail to get the memory.
			 */
			CHAR * pchNew = new CHAR[nlsSource.strlen()+1];

			if ( pchNew == NULL )
			{
				ReportError( WN_OUT_OF_MEMORY );
				return *this;
			}

			delete _pchData;
			_pchData = pchNew;
			_cbData = nlsSource.strlen()+1;
		}

	}
	else
	{
        if (::fDBCSEnabled) {
    		if (QueryAllocSize() <= cbToCopy) {
    			cbToCopy = QueryAllocSize() - 1;	/* leave room for the null */
    			const CHAR *p = nlsSource.QueryPch();
    			while (p < nlsSource.QueryPch() + cbToCopy)
    				p += nlsSource.IsDBCSLeadByte(*p) ? 2 : 1;
    			if (p - nlsSource.QueryPch() != cbToCopy)	/* last char was DB */
    				cbToCopy--;								/* don't copy lead byte either */
    		}
        }
        else {
    		if (QueryAllocSize() <= cbToCopy)
	    		cbToCopy = QueryAllocSize() - 1;
        }
	}

	if (nlsSource.IsOEM())
		SetOEM();
	else
		SetAnsi();

	::memcpyf( _pchData, nlsSource.QueryPch(), cbToCopy );	/* copy string data */
	_pchData[cbToCopy] = '\0';		/* terminate the string */
	_cchLen = cbToCopy;
	IncVers();

	/* Reset the error state, since the string is now valid.
	 */
	ReportError( WN_SUCCESS );
	return *this;
}


NLS_STR& NLS_STR::operator=( const CHAR *pchSource )
{
	if ( pchSource == NULL )
	{
		if ( !IsOwnerAlloc() && !QueryAllocSize() )
		{
			if ( !Alloc(1) )
				ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}

		UIASSERT( QueryAllocSize() > 0 );

		*_pchData = '\0';
		_cchLen = 0;
	}
	else
	{
		INT iSourceLen = ::strlenf( pchSource );
		INT cbToCopy;

		if ( !IsOwnerAlloc() )
		{
			if ( QueryAllocSize() < iSourceLen + 1 )
			{
				CHAR * pchNew = new CHAR[iSourceLen + 1];

				if ( pchNew == NULL )
				{
					ReportError( WN_OUT_OF_MEMORY );
					return *this;
				}

				delete _pchData;
				_pchData = pchNew;
				_cbData = iSourceLen + 1;
			}
			cbToCopy = iSourceLen;
		}
		else
		{
			if (QueryAllocSize() <= iSourceLen) {
                if (::fDBCSEnabled) {
    				cbToCopy = QueryAllocSize() - 1;	/* leave room for the null */
    				const CHAR *p = pchSource;
    				while (p < pchSource + cbToCopy)
    					p += IsDBCSLeadByte(*p) ? 2 : 1;
    				if (p - pchSource != cbToCopy)		/* last char was DB */
    					cbToCopy--;						/* don't copy lead byte either */
    			}
                else
	    			cbToCopy = QueryAllocSize() - 1;
            }
			else
				cbToCopy = iSourceLen;
		}

		::memcpyf( _pchData, pchSource, cbToCopy );
		_pchData[cbToCopy] = '\0';		/* terminate the string */
		_cchLen = cbToCopy;
	}

	IncVers();

	/* Reset the error state, since the string is now valid.
	 */
	ReportError( WN_SUCCESS );
	return *this;
}


#ifdef EXTENDED_STRINGS
/*******************************************************************

	NAME:		NLS_STR::CopyFrom()

	SYNOPSIS:	Assignment method which returns an error code

	ENTRY:
		nlsSource - source argument, either a nlsstr or char vector.
		achSource

	EXIT:
		Copied argument into this.  Error code of string set.

	RETURNS:
		Error code of string - WN_SUCCESS if successful.

	NOTES:
		If the CopyFrom fails, the current string will retain its
		original contents and error state.

	HISTORY:
		beng	09/18/91	Created
		beng	09/19/91	Added content-preserving behavior

********************************************************************/

APIERR NLS_STR::CopyFrom( const NLS_STR & nlsSource )
{
	if (!nlsSource)
		return nlsSource.QueryError();

	*this = nlsSource;

	APIERR err = QueryError();
	if (err)
		Reset();
	else {
		if (nlsSource.IsOEM())
			SetOEM();
		else
			SetAnsi();
	}
	return err;
}


APIERR NLS_STR::CopyFrom( const CHAR * achSource )
{
	*this = achSource;

	APIERR err = QueryError();
	if (err)
		Reset();
	return err;
}
#endif	// EXTENDED_STRINGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\sched.cpp ===
/*****************************************************************/
/**		      	Copyright (C) Microsoft Corp., 1994				**/
/*****************************************************************/ 

/* SCHED.C -- Miscellaneous scheduling helpers
 *
 * History:
 *	gregj	10/17/94	created
 */


#include "npcommon.h"
#include <sched.h>

/* FlushInputQueue is a private routine to collect and dispatch all
 * messages in the input queue.  It returns TRUE if a WM_QUIT message
 * was detected in the queue, FALSE otherwise.
 */
BOOL FlushInputQueue(volatile DWORD *pidOtherThread)
{
	MSG msgTemp;
	while (PeekMessage(&msgTemp, NULL, 0, 0, PM_REMOVE)) {
		DispatchMessage(&msgTemp);

		// If we see a WM_QUIT in the queue, we need to do the same
		// sort of thing that a modal dialog does:  break out of our
		// waiting, and repost the WM_QUIT to the queue so that the
		// next message loop up in the app will also see it.  We also
		// post the message to the server thread's queue so that any
		// dialog stack displayed there will be destroyed as well.
		if (msgTemp.message == WM_QUIT) {
			if (pidOtherThread != NULL && *pidOtherThread != NULL) {
				PostThreadMessage(*pidOtherThread, msgTemp.message, msgTemp.wParam, msgTemp.lParam);
			}
			PostQuitMessage((int)msgTemp.wParam);
			return TRUE;
		}
	}
	return FALSE;
}


/* WaitAndYield() waits for the specified object using
 * MsgWaitForMultipleObjects.  If messages are received,
 * they are dispatched and waiting continues.  The return
 * value is the same as from MsgWaitForMultipleObjects.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout, volatile DWORD *pidOtherThread /* = NULL */)
{
	DWORD dwTickCount, dwWakeReason, dwTemp;

	do {
		/* Flush any messages before we wait.  This is because
		 * MsgWaitForMultipleObjects will only return when NEW
		 * messages are put in the queue.
		 */
		if (FlushInputQueue(pidOtherThread)) {
			dwWakeReason = WAIT_TIMEOUT;
			break;
		}

    	// in case we handle messages, we want close to a true timeout
   		if ((dwTimeout != 0) && 
			(dwTimeout != (DWORD)-1)) {
   			// if we can timeout, store the current tick count
    		// every time through
   			dwTickCount = GetTickCount();
		}
		dwWakeReason = MsgWaitForMultipleObjects(1,
												 &hObject,
												 FALSE,
												 dwTimeout,
												 QS_ALLINPUT);
	    // if we got a message, dispatch it, then try again
	    if (dwWakeReason == 1) {
			// if we can timeout, see if we did before processing the message
			// that way, if we haven't timed out yet, we'll get at least one
			// more shot at the event
			if ((dwTimeout != 0) && 
			    (dwTimeout != (DWORD)-1)) {
			    if ((dwTemp = (GetTickCount()-dwTickCount)) >= dwTimeout) {
					// if we timed out, make us drop through
					dwWakeReason = WAIT_TIMEOUT;
				} else {
					// subtract elapsed time from timeout and continue
					// (we don't count time spent dispatching message)
					dwTimeout -= dwTemp;
				}
			}
			if (FlushInputQueue(pidOtherThread)) {
				dwWakeReason = WAIT_TIMEOUT;
				break;
			}
	    }
	} while (dwWakeReason == 1);

	return dwWakeReason;
}


/* WaitAndProcessSends is similar to WaitAndYield, but it only processes
 * SendMessage messages, not input messages.
 */
DWORD WaitAndProcessSends(HANDLE hObject, DWORD dwTimeout)
{
	DWORD dwWakeReason;

	do {
		dwWakeReason = MsgWaitForMultipleObjects(1,
												 &hObject,
												 FALSE,
												 dwTimeout,
												 QS_SENDMESSAGE);
	    // if we got a message, yield, then try again
	    if (dwWakeReason == 1) {
			MSG msgTemp;
			PeekMessage(&msgTemp, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD);
	    }
	} while (dwWakeReason == 1);

	return dwWakeReason;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\regentry.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	regentry.cxx
	registry access

	This file contains those routines which enable net providers to
    conveniently access the registry for their entries.

	FILE HISTORY:
		lens	03/15/94	Created
*/

#include "npcommon.h"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>
#include <regentry.h>

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
	_error = RegCreateKey(hkey, pszSubKey, &_hkey);
	if (_error) {
		bhkeyValid = FALSE;
	}
	else {
		bhkeyValid = TRUE;
	}
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
    	_error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
    				(unsigned char *)string, lstrlen(string)+1);
    }
	return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
    	_error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
    				(unsigned char *)&dwNumber, sizeof(dwNumber));
    }
	return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
    	_error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
	}
	return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
	DWORD 	dwType = REG_SZ;
	
    if (bhkeyValid) {
    	_error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
    				&length);
    }
	if (_error)
		*string = '\0';

	return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
 	DWORD 	dwType = REG_BINARY;
 	long	dwNumber = 0L;
 	DWORD	dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
    	_error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
    				&dwSize);
	}
	if (_error)
		dwNumber = dwDefault;
	
	return dwNumber;
}

VOID RegEntry::GetValue(const char *pszValueName, NLS_STR *pnlsString)
{
	DWORD 	dwType = REG_SZ;
    DWORD   length = 0;
    CHAR *  string = NULL;
    BOOL    bReallocDoneOK = FALSE;

    if (bhkeyValid) {
        _error = RegQueryValueEx( _hkey,
                                  (LPTSTR) pszValueName,
                                  0,
                                  &dwType,
                                  NULL,
                                  &length );
    	if (_error == ERROR_SUCCESS) {
            if (!pnlsString->IsOwnerAlloc()) {
                bReallocDoneOK = pnlsString->realloc(length);
            }
            else if (length <= (UINT)pnlsString->QueryAllocSize()) {
                bReallocDoneOK = TRUE;
            }
            else {
                _error = ERROR_MORE_DATA;
            }
        }
    	string = pnlsString->Party();
        if (bReallocDoneOK) {
        	_error = RegQueryValueEx( _hkey,
                                      (LPTSTR) pszValueName,
                                      0,
                                      &dwType,
                                      (LPBYTE) string,
                                      &length );
            if (_error == ERROR_SUCCESS) {
                if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) {
                    _error = ERROR_INVALID_PARAMETER;
                }
            }
        }
        else {
            _error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (_error != ERROR_SUCCESS) {
        if (string != NULL) {
    		*string = '\0';
        }
    }
    pnlsString->DonePartying();
}

VOID RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY	_hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
    	_error = RegFlushKey(_hkey);
    }
	return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

NPMachineEntries::NPMachineEntries(const char *pszReqSectionName)
: RegEntry("System\\CurrentControlSet\\Services", HKEY_LOCAL_MACHINE),
  pszSectionName(pszReqSectionName)
{
    if (GetError() == ERROR_SUCCESS) {
        MoveToSubKey(pszSectionName);
        if (GetError() == ERROR_SUCCESS) {
            MoveToSubKey("NetworkProvider");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strcat.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strcat.cxx
	NLS/DBCS-aware string class: strcat method

	This file contains the implementation of the strcat method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx
		beng	07/26/91	Replaced min with local inline
*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strcat

	SYNOPSIS:	Concantenate string

	ENTRY:		nlsSuffix - appended to end of string
				- or -
				pszSuffix - appended to end of string

	EXIT:

	NOTES:		String doesn't change if a memory allocation failure occurs
				Currently checks to see if we need to reallocate the
				string (but we have to traverse it to determine the
				actual storage required).  We may want to change
				this.

	HISTORY:
		johnl	11/13/90	Written
		beng	07/22/91	Allow on erroneous strings
		gregj	07/05/94	Added LPCSTR overload

********************************************************************/

NLS_STR & NLS_STR::strcat( const NLS_STR & nlsSuffix )
{
	if (QueryError() || !nlsSuffix)
		return *this;

	if ( QueryAllocSize() < (strlen() + nlsSuffix.strlen() + 1) )
	{
		if (IsOwnerAlloc() || !realloc( strlen() + nlsSuffix.strlen() + 1 ))
		{
			ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}
	}

	::strcatf( _pchData, nlsSuffix.QueryPch() );
	_cchLen += nlsSuffix.strlen();

	return *this;
}


NLS_STR & NLS_STR::strcat( LPCSTR pszSuffix )
{
	if (QueryError())
		return *this;

	UINT cbSuffix = ::strlenf(pszSuffix);
	if ( (UINT)QueryAllocSize() < (strlen() + cbSuffix + 1) )
	{
		if (IsOwnerAlloc() || !realloc( strlen() + cbSuffix + 1 ))
		{
			ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}
	}

	::strcatf( _pchData, pszSuffix );
	_cchLen += cbSuffix;

	return *this;
}


#ifdef EXTENDED_STRINGS
/*******************************************************************

    NAME:	NLS_STR::Append

    SYNOPSIS:	Append a string to the end of current string

    ENTRY:	nlsSuffix - appended to end of string

    EXIT:

    RETURNS:

    NOTES:	Little more than a wrapper around strcat.

    HISTORY:
	beng	    22-Jul-1991     Created (parallel of AppendChar)

********************************************************************/

APIERR NLS_STR::Append( const NLS_STR &nlsSuffix )
{
    strcat(nlsSuffix);
    return QueryError();
}


/*******************************************************************

    NAME:	NLS_STR::AppendChar

    SYNOPSIS:	Append a single character to the end of current string

    ENTRY:	wch - appended to end of string

    EXIT:

    RETURNS:	0 if successful

    NOTES:
	CODEWORK: This member would do well to skip the "strcat" step
	and append directly to the subject string.

    HISTORY:
	beng	    23-Jul-1991     Created

********************************************************************/

APIERR NLS_STR::AppendChar( WCHAR wch )
{
#if defined(UNICODE)
    STACK_NLS_STR(nlsTemp, 1);

    nlsTemp._pchData[0] = (CHAR)wch;
    nlsTemp._pchData[1] = 0;
    nlsTemp._cchLen = sizeof(CHAR); // since it's really in bytes

#else
    STACK_NLS_STR(nlsTemp, 2);

    if (HIBYTE(wch) == 0)
    {
	// Single-byte character
	nlsTemp._pchData[0] = LOBYTE(wch);
	nlsTemp._pchData[1] = '\0';
	nlsTemp._cchLen = sizeof(CHAR);
    }
    else
    {
	// Double-byte character
	nlsTemp._pchData[0] = HIBYTE(wch); // lead byte
	nlsTemp._pchData[1] = LOBYTE(wch);
	nlsTemp._pchData[2] = '\0';
	nlsTemp._cchLen = 2*sizeof(CHAR);
    }

#endif

    strcat(nlsTemp);
    return QueryError();
}
#endif	// EXTENDED_STRINGS


/*******************************************************************

	NAME:		NLS_STR::operator+=

	SYNOPSIS:	Append a string to the end of current string

	ENTRY:		wch - character to append

	EXIT:

	RETURNS:

	NOTES:		Little more than a wrapper around strcat.

	HISTORY:
		beng	07/23/91	Header added
		gregj	03/25/93	Added WCHAR version to replace AppendChar
		gregj	07/13/94	NLS_STR version was identical to strcat, so inlined

********************************************************************/

NLS_STR & NLS_STR::operator+=( WCHAR wch )
{
#if defined(UNICODE)
	STACK_NLS_STR(nlsTemp, 1);

	nlsTemp._pchData[0] = (CHAR)wch;
	nlsTemp._pchData[1] = 0;
	nlsTemp._cchLen = sizeof(CHAR); // since it's really in bytes

#else
	STACK_NLS_STR(nlsTemp, 2);

	if (HIBYTE(wch) == 0)
	{
		// Single-byte character
		nlsTemp._pchData[0] = LOBYTE(wch);
		nlsTemp._pchData[1] = '\0';
		nlsTemp._cchLen = sizeof(CHAR);
	}
	else
	{
		// Double-byte character
		nlsTemp._pchData[0] = HIBYTE(wch); // lead byte
		nlsTemp._pchData[1] = LOBYTE(wch);
		nlsTemp._pchData[2] = '\0';
		nlsTemp._cchLen = 2*sizeof(CHAR);
	}

#endif

    strcat(nlsTemp);
    return *this;
}


/*******************************************************************

	NAME:		NLS_STR::realloc

	SYNOPSIS:	Reallocate an NLS_STR to the passed count of bytes, copying
				the current contents to the reallocated string.

	ENTRY:		cb - number of bytes desired in string storage

	EXIT:
		Returns TRUE if successful:

			_pchData points to allocated storage of "cb" bytes.
			_cbData set to cb.
			Old storage is copied

		Returns FALSE upon allocation failure, the string is preserved

	NOTES:
		A string will never be downsized (i.e., realloc can only be used
		to increase the size of a string).  If a request comes in to make
		the string smaller, it will be ignored, and TRUE will be returned.

		DO NOT CALL REALLOC ON AN OWNERALLOCED STRING!!  You will cause
		an assertion error if you do.

	HISTORY:
		johnl	11/11/90	Created
		beng	04/26/91	Changed USHORT parm to INT

********************************************************************/

BOOL NLS_STR::realloc( INT cb )
{
	UIASSERT( !IsOwnerAlloc() );
	UIASSERT( cb != 0 );

	if ( cb <= QueryAllocSize() )
		return TRUE;

	CHAR * pchNewMem = new CHAR[cb];

	if (pchNewMem == NULL)
		return FALSE;

	::memcpyf( pchNewMem, _pchData, min( cb-1, QueryAllocSize() ) );
	delete _pchData;
	_pchData = pchNewMem;
	_cbData = cb;
	*( _pchData + cb - 1 ) = '\0';

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\stratol.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stratol.cxx
	NLS/DBCS-aware string class: atol method

	This file contains the implementation of the atol method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this member function need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
	#include <stdlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::atol

	SYNOPSIS:	Returns *this in its long numeric equivalent

	ENTRY:		With no arguments, parses from beginning of string.
				Given an ISTR, starts at that point within the string.

	EXIT:

	NOTES:		Uses C-Runtime atol function

	HISTORY:
		johnl	11/26/90	Written
		beng	07/22/91	Callable on erroneous string; simplified CheckIstr

********************************************************************/

LONG NLS_STR::atol() const
{
	if (QueryError())
		return 0;

	return ::atol( _pchData );
}


LONG NLS_STR::atol( const ISTR & istrStart ) const
{
	if (QueryError())
		return 0;

	CheckIstr( istrStart );

	return ::atol( QueryPch(istrStart) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strchr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strchr.cxx
	NLS/DBCS-aware string class: strchr method

	This file contains the implementation of the strchr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strchr

	SYNOPSIS:	Puts the index of the first occurrence of ch in *this
				into istrPos.


	ENTRY:		pistrPos - points to ISTR in which to leave pos
				ch		 - character sought
				istrStart- staring point in string.  If omitted, start
							at beginning

	EXIT:		pistrPos

	RETURNS:	TRUE if character found; otherwise FALSE

	NOTES:		This routine only works for CHAR - not WCHAR.
				Hence it's useless for double-byte characters
				under MBCS.

	HISTORY:
		johnl	11/26/90	Written
		beng	07/22/91	Allow on erroneous strings; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strchr( ISTR * pistrPos, const CHAR ch ) const
{
	if ( QueryError() )
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strchrf( QueryPch(), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((DWORD)(pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::strchr( ISTR * pistrPos, const CHAR ch,
					  const ISTR & istrStart ) const
{
	if ( QueryError() )
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strchrf( QueryPch(istrStart), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((DWORD)(pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strcspn.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strcspn.cxx
	NLS/DBCS-aware string class: strcspn method

	This file contains the implementation of the strcspn method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strcspn

	SYNOPSIS:	Set membership.  Finds the first matching character
				in the passed string

	ENTRY:		pistrPos - destination for results
				nls	 - set of sought characters

	EXIT:		*pistrPos contains offset within "this" of element
				found (assuming it was successful); otherwise it
				is moved to the end of the string.

	RETURNS:	TRUE if any character found; FALSE otherwise

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous strings; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strcspn( ISTR* pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	pistrPos->SetIB( ::strcspnf( QueryPch(), nls.QueryPch() ) );
	return *QueryPch( *pistrPos ) != '\0';
}


BOOL NLS_STR::strcspn( ISTR * pistrPos, const NLS_STR & nls,
						const ISTR& istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );
	CheckIstr( istrStart );

	pistrPos->SetIB( ::strcspnf( QueryPch(istrStart), nls.QueryPch() )
								 + istrStart.QueryIB()  );
	return *QueryPch( *pistrPos ) != '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strcmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strcmp.cxx
	NLS/DBCS-aware string class: strcmp method and equality operator

	This file contains the implementation of the strcmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::operator==

	SYNOPSIS:	Case-sensitive test for equality

	RETURNS:	TRUE if the two operands are equal (case sensitive);
				else FALSE

	NOTES:		An erroneous string matches nothing.

	HISTORY:
		johnl	11/11/90	Written
		beng	07/23/91	Allow on erroneous strings

********************************************************************/

BOOL NLS_STR::operator==( const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	return !::strcmpf( QueryPch(), nls.QueryPch() );
}


/*******************************************************************

	NAME:		NLS_STR::operator!=

	SYNOPSIS:	Case-sensitive test for inequality

	RETURNS:	TRUE if the two operands are unequal (case sensitive);
				else FALSE

	NOTES:		An erroneous string matches nothing.

	HISTORY:
		beng	07/23/91	Header added

********************************************************************/

BOOL NLS_STR::operator!=( const NLS_STR & nls ) const
{
	return ! operator==( nls );
}


/*******************************************************************

	NAME:		NLS_STR::strcmp

	SYNOPSIS:	Standard string compare with optional character indexes

	ENTRY:		nls					  - string against which to compare
				istrStart1 (optional) - index into "this"
				istrStart2 (optional) - index into "nls"

	RETURNS:	As the C runtime "strcmp".

	NOTES:		If either string is erroneous, return "match."
				This runs contrary to the eqop.

				Glock doesn't allow default parameters which require
				construction; hence this member is overloaded multiply.

	HISTORY:
		johnl	11/15/90	Written
		johnl	11/19/90	Changed to use ISTR, overloaded for
							different number of ISTRs
		beng	07/23/91	Allow on erroneous strings;
							simplified CheckIstr

********************************************************************/

int NLS_STR::strcmp( const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return 0;

	return ::strcmpf( QueryPch(), nls.QueryPch() );
}

int NLS_STR::strcmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );

	return ::strcmpf( QueryPch(istrStart1) , nls.QueryPch() );
}

int NLS_STR::strcmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::strcmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\stricmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stricmp.cxx
	NLS/DBCS-aware string class: stricmp method

	This file contains the implementation of the stricmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::stricmp

	SYNOPSIS:	Case insensitive string compare w/ optional indices

	ENTRY:		nls					  - string against which to compare
				istrStart1 (optional) - index into "this"
				istrStart2 (optional) - index into "nls"

	RETURNS:	As the C runtime "strcmp".

	NOTES:		If either string is erroneous, return "match."
				This runs contrary to the eqop.

				Glock doesn't allow default parameters which require
				construction; hence this member is overloaded multiply.

	HISTORY:
		johnl	11/15/90	Written
		beng	07/23/91	Allow on erroneous strings;
							simplified CheckIstr

********************************************************************/

INT NLS_STR::stricmp( const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return 0;

	return ::stricmpf( QueryPch(), nls.QueryPch() );
}


INT NLS_STR::stricmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );

	return ::stricmpf( QueryPch(istrStart1), nls.QueryPch() );
}


INT NLS_STR::stricmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::stricmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strdss.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strdss.cxx
	NLS/DBCS-aware string class: DelSubStr method

	This file contains the implementation of the DelSubStr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::DelSubStr

	SYNOPSIS:	Collapse the string by removing the characters from
				istrStart to:
				  istrStart  to the end of string
				  istrStart + istrEnd
				The string is not reallocated

	ENTRY:

	EXIT:		Modifies istrStart

	NOTES:		The method DelSubStr( ISTR&, CB) is private and does
				the work.

	HISTORY:
		johnl	11/26/90	Created
		beng	04/26/91	Replaced CB with INT
		beng	07/23/91	Allow on erroneous strings; simplified CheckIstr

********************************************************************/

VOID NLS_STR::DelSubStr( ISTR & istrStart, INT cbLen )
{
	if (QueryError())
		return;

	CheckIstr( istrStart );

	// cbLen == -1 means delete to end of string
	if ( cbLen == -1 )
		*(_pchData + istrStart.QueryIB() ) = '\0';
	else
	{
		INT cbNewEOS = 1 + ::strlenf( QueryPch(istrStart) + cbLen );

		::memmovef( (CHAR *)QueryPch(istrStart),
					(CHAR *)QueryPch(istrStart) + cbLen,
					cbNewEOS );
	}

	_cchLen = ::strlenf( QueryPch() );

	IncVers();
	UpdateIstr( &istrStart );
}


VOID NLS_STR::DelSubStr( ISTR & istrStart )
{
	if (QueryError())
		return;

	DelSubStr( istrStart, -1 );
}


VOID NLS_STR::DelSubStr( ISTR & istrStart, const ISTR & istrEnd  )
{
	if (QueryError())
		return;

	CheckIstr( istrEnd );
	UIASSERT( istrEnd.QueryIB() >= istrStart.QueryIB() );

	DelSubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\string.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	string.cxx
	NLS/DBCS-aware string class: essential core methods

	This file contains those routines which every client of
	the string classes will always need.

	Most of the implementation has been exploded into other files,
	so that an app linking to string doesn't end up dragging the
	entire string runtime library along with it.

	FILE HISTORY:
		beng	10/23/90	Created
		johnl	12/11/90	Remodeled beyond all recognizable form
		beng	01/18/91	Most methods relocated into other files
		beng	02/07/91	Uses lmui.hxx
		beng	07/26/91	Replaced min with local inline
		gregj	03/30/93	Removed ISTR to separate module
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::NLS_STR

	SYNOPSIS:	Constructor for NLS_STR

	ENTRY:		NLS_STR takes many (too many) ctor forms.

	EXIT:		String constructed

	NOTES:
		The default constructor creates an empty string.

	HISTORY:
		beng	10/23/90	Created
		beng	04/26/91	Replaced 'CB' and USHORT with INT
		beng	07/22/91	Uses member-init ctor forms

********************************************************************/

NLS_STR::NLS_STR()
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if ( !Alloc(1) )
		return;

	*_pchData = '\0';
	InitializeVers();
}


NLS_STR::NLS_STR( INT cchInitLen )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if (!Alloc(cchInitLen+1))
		return;

	::memsetf( _pchData, '\0', cchInitLen );

	_cchLen = 0;

	InitializeVers();
}


NLS_STR::NLS_STR( const CHAR * pchInit )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if (pchInit == NULL)
	{
		if (!Alloc(1))
			ReportError( WN_OUT_OF_MEMORY );
		else
		{
			*_pchData = '\0';
		}
		return;
	}

	INT iSourceLen = ::strlenf( pchInit );

	if ( !Alloc( iSourceLen + 1 ) )
		return;

	::strcpyf( _pchData, pchInit );

	_cchLen = iSourceLen;

	InitializeVers();
}


NLS_STR::NLS_STR( const NLS_STR & nlsInit )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	UIASSERT( !nlsInit.QueryError() );

	if (!Alloc( nlsInit.strlen()+1 ) )
		return;

	::memcpyf( _pchData, nlsInit.QueryPch(), nlsInit.strlen()+1 );

	_cchLen = nlsInit.strlen();

	InitializeVers();
}


#ifdef EXTENDED_STRINGS
NLS_STR::NLS_STR( const CHAR * pchInit, INT iTotalLen )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if (pchInit == NULL)
	{
		if (!Alloc( 1 + iTotalLen ))
			return;
		*_pchData = '\0';
	}
	else
	{
		_cchLen = ::strlenf( pchInit );
		if ( _cchLen > iTotalLen )
		{
			_cchLen = 0;
			ReportError( WN_OUT_OF_MEMORY );
			return;
		}

		if ( !Alloc( iTotalLen ) )
		{
			_cchLen = 0;
			return;
		}

		::memcpyf( _pchData, pchInit, _cchLen+1 );
	}

	InitializeVers();
}
#endif	// EXTENDED_STRINGS


NLS_STR::NLS_STR( unsigned stralloc, CHAR *pchInit, INT cbSize )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(SF_OWNERALLOC)
{
	UIASSERT( stralloc == STR_OWNERALLOC || stralloc == STR_OWNERALLOC_CLEAR);
	UIASSERT( pchInit != NULL );

	if ( stralloc == STR_OWNERALLOC_CLEAR )
	{
		UIASSERT( cbSize > 0 );
		*(_pchData = pchInit ) = '\0';
		_cchLen = 0;
	}
	else
	{
		_pchData = pchInit;
		_cchLen = ::strlenf( pchInit );
	}

	if ( cbSize == -1 )
		_cbData = _cchLen + 1;
	else
		_cbData = cbSize;

	InitializeVers();
}


#ifdef EXTENDED_STRINGS
NLS_STR::NLS_STR( unsigned stralloc, CHAR *pchBuff, INT cbSize,
				  const CHAR *pchInit )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(SF_OWNERALLOC)
{
	UIASSERT( stralloc == STR_OWNERALLOC );
	UIASSERT( stralloc != STR_OWNERALLOC_CLEAR );
	UIASSERT( pchBuff != NULL || pchInit != NULL );
	UIASSERT( cbSize > 0 && ::strlenf( pchInit ) <= cbSize );

	UNREFERENCED( stralloc );

	_pchData = pchBuff;

	INT cbToCopy = min( ::strlenf( pchInit ), cbSize - 1 );
	::memcpyf( _pchData, pchInit, cbToCopy );
	*(_pchData + cbToCopy) = '\0';

	_cchLen = cbToCopy;
	_cbData = cbSize;

	InitializeVers();
}
#endif


/*******************************************************************

	NAME:		NLS_STR::~NLS_STR

	SYNOPSIS:	Destructor for NLS_STR

	ENTRY:

	EXIT:		Storage deallocated, if not owner-alloc

	HISTORY:
		beng	10/23/90	Created
		beng	07/22/91	Zeroes only in debug version

********************************************************************/

NLS_STR::~NLS_STR()
{
	if ( !IsOwnerAlloc() )
		delete _pchData;

#if defined(DEBUG)
	_pchData = NULL;
	_cchLen  = 0;
	_cbData = 0;
#endif
}


/*******************************************************************

	NAME:		NLS_STR::Alloc

	SYNOPSIS:	Common code for constructors.

	ENTRY:
		cb - number of bytes desired in string storage

	EXIT:
		Returns TRUE if successful:

			_pchData points to allocated storage of "cb" bytes.
			_cbData set to cb.
			Allocated storage set to 0xF2 in debug version

		Returns FALSE upon allocation failure.

	NOTES:

	HISTORY:
		beng	10/23/90	Created
		johnl	12/11/90	Updated as per code review
		beng	04/26/91	Changed USHORT parm to INT

********************************************************************/

BOOL NLS_STR::Alloc( INT cb )
{
	UIASSERT( cb != 0 );

	_pchData = new CHAR[cb];
	if (_pchData == NULL)
	{
		// For now, assume not enough memory.
		//
		ReportError(WN_OUT_OF_MEMORY);
		return FALSE;
	}

#ifdef DEBUG
	::memsetf(_pchData, 0xf2, cb);
#endif
	_cbData = cb;

	return TRUE;
}


/*******************************************************************

	NAME:		NLS_STR::Reset

	SYNOPSIS:	Attempts to clear the error state of the string

	ENTRY:		String is in error state

	EXIT:		If recoverable, string is correct again

	RETURNS:	TRUE if successful; FALSE otherwise

	NOTES:
		An operation on a string may fail, if this occurs, the error
		flag is set and you can't use the string until the flag
		is cleared.  By calling Reset, you can clear the flag,
		thus allowing you to get access to the string again.  The
		string will be in a consistent state.  Reset will return
		FALSE if the string couldn't be restored (for example, after
		construction failure).

    HISTORY:
		Johnl	12/12/90	Created

********************************************************************/

BOOL NLS_STR::Reset()
{
	UIASSERT( QueryError() ) ;	// Make sure an error exists

	if ( QueryError() == WN_OUT_OF_MEMORY && _pchData != NULL )
	{
		ReportError( WN_SUCCESS );
		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strinsrt.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strinsrt.cxx
	NLS/DBCS-aware string class: InsertParams method

	This file contains the implementation of the InsertParams method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		Johnl	01/31/91	Created
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


#define MAX_INSERT_PARAMS	9

/*******************************************************************

	NAME:		NLS_STR::InsertParams

	SYNOPSIS:	Fill in a message string from the resource file replacing
				the number parameters with the real text.

	ENTRY:		pchMessage is a pointer to the message text
				apnlsParamStrings is an array of pointers to NLS_STRs

				Example:

				*this = "Error %1 occurred, do %2, or %1 will happen again"
				apnlsParamStrings[0] = "696969"
				apnlsParamStrings[1] = "Something else"

				Return string = "Error 696969 occurred, do Something else or
				696969 will happen again"

	EXIT:		0 if successful, error code otherwise, one of:
					WN_OUT_OF_MEMORY

	NOTES:		The minimum parameter is 1, the maximum parameter is 9.
				The array of param strings must have a NULL to mark
				the end of the array.

	HISTORY:
		JohnL	01/30/91	Created
		beng	04/26/91	Uses WCHAR
		beng	07/23/91	Allow on erroneous string

********************************************************************/

#define PARAM_ESC  '%'

USHORT NLS_STR::InsertParams( const NLS_STR * apnlsParamStrings[] )
{
	if (QueryError())
		return (USHORT) QueryError();

	INT iNumParams = 0;	// Number of param strings in the array
						// Max string length of expanded message (include \0)
	INT iMaxMessLen = strlen() + 1;

	/* How many parameters were we passed?
	*/
	for ( ; apnlsParamStrings[iNumParams] != NULL ; iNumParams++ )
		;

	UIASSERT(iNumParams <= MAX_INSERT_PARAMS);
	if ( iNumParams > MAX_INSERT_PARAMS )
		return WN_OUT_OF_MEMORY;

	/* Determine total string length required for the expanded string
	 * and get out if we can't fulfill the request
	 */

	ISTR istrCurPos( *this );
	while ( 1 )
	{
		if ( !strchr( &istrCurPos, PARAM_ESC, istrCurPos ) )
			break;

		WCHAR wchParam = QueryChar( ++istrCurPos );

		if ( wchParam >= '1' && wchParam <= '9' )
		{
			INT iParamIndex = wchParam - '1';
			if ( iNumParams < iParamIndex )
				return WN_OUT_OF_MEMORY;

			iMaxMessLen += apnlsParamStrings[iParamIndex]->strlen() - 2;
		}
	}

	if ( iMaxMessLen > QueryAllocSize() )
	{
		if ( IsOwnerAlloc() )
			return WN_OUT_OF_MEMORY;
		else
			if ( !realloc( iMaxMessLen ) )
				return WN_OUT_OF_MEMORY;
	}

	/* Now do the parameter substitution
	 */

	istrCurPos.Reset();
	for (;;)
	{
		if ( !strchr( &istrCurPos, PARAM_ESC, istrCurPos ) )
			break;

		ISTR istrParamEsc( istrCurPos );
		WCHAR wchParam = QueryChar( ++istrCurPos );

		if ( wchParam >= '1' && wchParam <= '9' )
		{
			INT iParamIndex = wchParam - '1';

			if (iParamIndex < iNumParams) {
				ReplSubStr( *apnlsParamStrings[iParamIndex],
							istrParamEsc,
							++istrCurPos ) ;   // Replace #
				// Skip past entire substituted string
				istrCurPos.SetIB(istrParamEsc.QueryIB() +
								 apnlsParamStrings[iParamIndex]->strlen());
			}
			// else istrCurPos has been advanced past the out-of-range digit
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\stris.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stris.cxx
	NLS/DBCS-aware string class: InsertStr method

	This file contains the implementation of the InsertStr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::InsertStr

	SYNOPSIS:	Insert passed string into *this at istrStart

	ENTRY:

	EXIT:		If this function returns FALSE, ReportError has been
				called to report the error that occurred.

	RETURN:		TRUE on success, FALSE otherwise.

	NOTES:		If *this is not STR_OWNERALLOCed and the inserted string
				won't fit in the allocated space for *this, then *this
				will be reallocated.

	HISTORY:
		johnl	11/28/90	Created
		rustanl 04/14/91	Fixed new length calculation.  Report
							error if owner alloc'd and not enough
							space.
		beng	04/26/91	Replaced CB with INT
		beng	07/23/91	Allow on erroneous string;
							simplified CheckIstr

********************************************************************/

BOOL NLS_STR::InsertStr( const NLS_STR & nlsIns, ISTR & istrStart )
{
	if (QueryError() || !nlsIns)
		return FALSE;

	CheckIstr( istrStart );

	INT cbNewSize = strlen() + nlsIns.strlen() + 1 ; // include new null char

	if ( QueryAllocSize() < cbNewSize )
	{
		if ( IsOwnerAlloc())
		{
			// Big trouble!  Report error, and return failure.
			//
			UIASSERT( !"Owner alloc'd string not big enough" );
			ReportError( WN_OUT_OF_MEMORY );
			return FALSE;
		}

		// Attempt to allocate more memory
		//
		if ( !realloc( cbNewSize ) )
		{
			ReportError( WN_OUT_OF_MEMORY );
			return FALSE;
		}
	}

	::memmovef( (CHAR *)QueryPch(istrStart) + nlsIns.strlen(),
				(CHAR *)QueryPch(istrStart),
				::strlenf(QueryPch(istrStart) ) + 1 );
	::memmovef( (CHAR *)QueryPch(istrStart),
				(CHAR *)nlsIns.QueryPch(),
				nlsIns.strlen() );

	UIASSERT( cbNewSize >= 1 ); // should have been assigned something +1 above
	_cchLen = cbNewSize - 1;	// don't count null character here

	IncVers();
	UpdateIstr( &istrStart );		// This ISTR does not become invalid
									// after the string update
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\stristr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stristr.cxx
	NLS/DBCS-aware string class: stristr method

	This file contains the implementation of the stristr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	11/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:	NLS_STR::stristr

	SYNOPSIS:	Same as strstr on case insensitive

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::stristr( ISTR * pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::stristrf( QueryPch(), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::stristr( ISTR *    pistrPos,
					   const NLS_STR & nls,
					   const ISTR    & istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::stristrf(QueryPch(istrStart), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strnchar.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strnchar.cxx
	NLS/DBCS-aware string class:QueryNumChar method

	This file contains the implementation of the QueryNumChar method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		terryk	04/04/91	Creation

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


#ifdef EXTENDED_STRINGS
/*******************************************************************

	NAME:		NLS_STR::QueryNumChar

	SYNOPSIS:	return the total number of character within the string   

	RETURNS:	The number of logical character within the string

	NOTES:
		Treats erroneous string as having length 0

	HISTORY:
		terryk	04/04/91	Written
		beng	07/23/91	Allow on erroneous string

********************************************************************/

INT NLS_STR::QueryNumChar() const
{
	if (QueryError())
		return 0;

	ISTR  istrCurPos( *this );
	INT   cchCounter = 0;

	for ( ;
		this->QueryChar( istrCurPos ) != '\0';
		istrCurPos++, cchCounter ++ )
		;

	return cchCounter;
}


/*******************************************************************

	NAME:		NLS_STR::QueryTextLength

	SYNOPSIS:	Calculate length of text in CHARS, sans terminator

	RETURNS:	Count of CHARs

	NOTES:
		Compare QueryNumChar, which returns a number of glyphs.
		In a DBCS environment, this member will return 2 CHARS for
		each double-byte character, since a CHAR is there only 8 bits.

	HISTORY:
		beng	07/23/91	Created

********************************************************************/

INT NLS_STR::QueryTextLength() const
{
	return _cchLen / sizeof(CHAR);
}


/*******************************************************************

	NAME:		NLS_STR::QueryTextSize

	SYNOPSIS:	Calculate length of text in BYTES, including terminator

	RETURNS:	Count of BYTES

	NOTES:
		QueryTextSize returns the number of bytes needed to duplicate
		the string into a byte vector.

    HISTORY:
		beng	07/23/91	Created

********************************************************************/

INT NLS_STR::QueryTextSize() const
{
	return _cchLen+sizeof(CHAR);
}
#endif	// EXTENDED_STRINGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strload.cpp ===
/*****************************************************************/ 
/**                  Microsoft Windows for Workgroups                **/
/**              Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/ 

/*
    strload.cxx
    NLS/DBCS-aware string class:  LoadString methods

    This file contains the implementation of the LoadString methods
    for the NLS_STR class.  It is separate so that clients of NLS_STR who
    do not use this operator need not link to it.

    FILE HISTORY:
        rustanl    01/31/91    Created
        beng    02/07/91    Uses lmui.hxx
        gregj    03/10/92    Added caching to speed up PM ext
        gregj    04/22/93    #ifdef'd out caching to save space
*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>
#include <shlwapi.h>

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

// we define this before we include mluisupp.h so we get code
// instead of just prototypes
#define MLUI_INIT
#include <mluisupp.h>

#ifdef RESOURCE_STRING_CACHING

/*************************************************************************

    NAME:        RESOURCE_CACHE

    SYNOPSIS:    Caches a loaded resource string

    INTERFACE:    RESOURCE_CACHE()
                    Construct from an existing NLS_STR.  Automatically
                    links itself into its list.

                FindResourceCache()    [friend function]
                    Finds an ID in the list.  If not found, returns NULL,
                    else automatically promotes itself to the head of the
                    list.

                AddResourceCache()    [friend function]

                Set()
                    Sets the cached message ID and string.

                all NLS_STR methods

    PARENT:        NLS_STR

    USES:

    CAVEATS:

    NOTES:

    HISTORY:
        gregj    03/10/92    Created

**************************************************************************/

class RESOURCE_CACHE : public NLS_STR
{
friend const RESOURCE_CACHE *FindResourceCache( USHORT idMsg, RESOURCE_CACHE **ppLast,
                                                RESOURCE_CACHE **ppTrail );
friend void AddResourceCache( USHORT idMsg, const NLS_STR *nls, RESOURCE_CACHE *pLast,
                              RESOURCE_CACHE *pTrail );
protected:
    USHORT _idMsg;
    RESOURCE_CACHE *_pFwd;
    static RESOURCE_CACHE *_pList;
    static INT _cItems;
    void Promote();

public:
    RESOURCE_CACHE( USHORT idMsg, const NLS_STR &nls );
    ~RESOURCE_CACHE();
    RESOURCE_CACHE & operator=( const NLS_STR & nlsSource )
    { return (RESOURCE_CACHE&) NLS_STR::operator=( nlsSource ); }

    void Set( USHORT idMsg, const NLS_STR &nls );
};

RESOURCE_CACHE *RESOURCE_CACHE::_pList = NULL;
INT RESOURCE_CACHE::_cItems = 0;

#define RESCACHE_MAX    8    /* max number of strings to cache */

RESOURCE_CACHE::RESOURCE_CACHE( USHORT idMsg, const NLS_STR &nls )
        : NLS_STR( MAX_RES_STR_LEN + 1 ),
          _idMsg( idMsg ),
          _pFwd( NULL )
{
    if (QueryError() != WN_SUCCESS)
        return;

    *this = nls;            /* copy contents */

    _pFwd = _pList;
    _pList = this;            /* make this the new list head */

    _cItems++;                /* and count this one */
}

RESOURCE_CACHE::~RESOURCE_CACHE()
{
    RESOURCE_CACHE *pThis, *pTrail;

    for (pThis = _pList, pTrail = NULL;
         pThis != this && pThis != NULL;
         pTrail = pThis, pThis = pThis->_pFwd)
        ;

    if (pThis == NULL)
        return;

    if (pTrail == NULL)
        _pList = _pFwd;
    else
        pTrail->_pFwd = _pFwd;

    _cItems--;
}


void RESOURCE_CACHE::Promote()
{
    RESOURCE_CACHE *pThis, *pTrail;

    for (pThis = _pList, pTrail = NULL;
         pThis != this && pThis != NULL;
         pTrail = pThis, pThis = pThis->_pFwd)
        ;

    if (pThis == NULL)            /* item not found??? */
        _cItems++;                /* try to keep count accurate */
    else if (pTrail == NULL)
        return;                    /* already at list head, no change */
    else
        pTrail->_pFwd = _pFwd;    /* remove item from list */

    _pFwd = _pList;
    _pList = this;                /* make this the new list head */
}


const RESOURCE_CACHE *FindResourceCache( USHORT idMsg, RESOURCE_CACHE **ppLast,
                                         RESOURCE_CACHE **ppTrail )
{
    RESOURCE_CACHE *pThis, *pTrail;

    if (RESOURCE_CACHE::_pList == NULL) {    /* empty list? */
        *ppLast = NULL;
        *ppTrail = NULL;
        return NULL;
    }

    for (pThis = RESOURCE_CACHE::_pList;
         pThis->_pFwd != NULL && pThis->_idMsg != idMsg;
         pTrail = pThis, pThis = pThis->_pFwd)
        ;

    if (pThis->_idMsg != idMsg) {    /* item not found? */
        *ppLast = pThis;            /* return ptr to last item */
        *ppTrail = pTrail;            /* and to its predecessor */
        return NULL;
    }

    pThis->Promote();                /* item found, promote it */
    return pThis;                    /* and return it */
}


void AddResourceCache( USHORT idMsg, const NLS_STR *nls, RESOURCE_CACHE *pLast,
                        RESOURCE_CACHE *pTrail )
{
    if (RESOURCE_CACHE::_cItems < RESCACHE_MAX) {    /* cache not full, make a new entry */
        RESOURCE_CACHE *pNew = new RESOURCE_CACHE( idMsg, *nls );
                            /* automatically adds itself to the list */
    }
    else {
        if (pTrail != NULL) {        /* if not already first item */
            pTrail->_pFwd = pLast->_pFwd;    /* unlink from list */
            pLast->_pFwd = RESOURCE_CACHE::_pList;    /* and move to front */
            RESOURCE_CACHE::_pList = pLast;
        }

        pLast->Set( idMsg, *nls );    /* set new contents */
    }
}


void RESOURCE_CACHE::Set( USHORT idMsg, const NLS_STR &nls )
{
    *this = nls;
    _idMsg = idMsg;
}

#endif    /* RESOURCE_STRING_CACHING */


/*******************************************************************

    NAME:        NLS_STR::LoadString

    SYNOPSIS:    Loads a string from a resource file.

    ENTRY:

    EXIT:        Returns an error value, which is WN_SUCCESS on success.

    NOTES:        Requires that owner alloc strings must have an allocated
                size enough to fit strings of length MAX_RES_STR_LEN.
                This is requires even if the programmer thinks the string
                to be loaded is very small.  The reason is that after the
                string has been localized, the string length bound is not
                known.    Hence, the programmer always needs to allocate
                MAX_RES_STR_LEN + 1 bytes, which is guaranteed to be
                enough.

    HISTORY:
        rustanl    01/31/91    Created
        beng    07/23/91    Allow on erroneous string
        gregj    04/22/93    #ifdef'd out caching to save space

********************************************************************/

USHORT NLS_STR::LoadString( USHORT usMsgID )
{
    if (QueryError())
        return (USHORT) QueryError();

    //    Impose requirement on owner alloc'd strings (see function header).
    UIASSERT( !IsOwnerAlloc() ||
              ( QueryAllocSize() >= MAX_RES_STR_LEN + 1 ));

    if ( ! IsOwnerAlloc())
    {
        //  Resize the buffer to be big enough to hold any message.
        //  If the buffer is already this big, realloc will do nothing.
        if ( ! realloc( MAX_RES_STR_LEN + 1 ))
        {
            return WN_OUT_OF_MEMORY;
        }
    }

    //    At this point, we have a buffer which is big enough.
    UIASSERT( QueryAllocSize() >= MAX_RES_STR_LEN );

#ifdef RESOURCE_STRING_CACHING
    RESOURCE_CACHE *pLast, *pTrail;
    const RESOURCE_CACHE *prc = FindResourceCache( usMsgID, &pLast, &pTrail );
    if (prc != NULL) {
        *this = *prc;        /* copy contents */
        return WN_SUCCESS;    /* all done */
    }
#endif    /* RESOURCE_STRING_CACHING */

    int cbCopied = MLLoadStringA(usMsgID, (LPSTR)QueryPch(),
                                 QueryAllocSize());
    if ( cbCopied == 0 )
    {
        return WN_BAD_VALUE;
    }

    _cchLen = cbCopied;
    IncVers();

#ifdef RESOURCE_STRING_CACHING
    AddResourceCache( usMsgID, this, pLast, pTrail );
#endif    /* RESOURCE_STRING_CACHING */

    return WN_SUCCESS;
}


/*******************************************************************

    NAME:        NLS_STR::LoadString

    SYNOPSIS:    Loads a string from a resource file, and then inserts
                some parameters into it.

    ENTRY:

    EXIT:        Returns an error value, which is WN_SUCCESS on success.

    NOTES:        This method is provides a simple way to call the above
                LoadString and InsertParams consecutively.

    HISTORY:
        rustanl    01/31/91    Created

********************************************************************/

USHORT NLS_STR::LoadString( USHORT usMsgID,
                            const NLS_STR * apnlsParamStrings[] )
{
    USHORT usErr = LoadString( usMsgID );

    if ( usErr == WN_SUCCESS )
    {
        usErr = InsertParams( apnlsParamStrings );
    }

    return usErr;
}


#ifdef EXTENDED_STRINGS
/*******************************************************************

    NAME:        RESOURCE_STR::RESOURCE_STR

    SYNOPSIS:    Constructs a nls-string from a resource ID.

    ENTRY:        idResource

    EXIT:        Successful construct, or else ReportError

    NOTES:        This string may not be owner-alloc!  For owner-alloc,
                cons up a new one and copy this into it.

    HISTORY:
        beng    07/23/91    Created

********************************************************************/

RESOURCE_STR::RESOURCE_STR( UINT idResource )
    : NLS_STR()
{
    UIASSERT(!IsOwnerAlloc());

    USHORT usErr = LoadString(idResource);
    if (usErr)
        ReportError(usErr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strmisc.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	strmisc.cxx
	Miscellaneous members of the string classes

	The NLS_STR and ISTR classes have many inline member functions
	which bloat clients, especially in debug versions.	This file
	gives those unhappy functions a new home.

	FILE HISTORY:
		beng	04/26/91	Created (relocated from string.hxx)
		gregj	05/22/92	Added ToOEM, ToAnsi methods

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


#ifdef DEBUG
/*******************************************************************

	NAME:		NLS_STR::CheckIstr

	SYNOPSIS:	Checks association between ISTR and NLS_STR instances

	ENTRY:		istr - ISTR to check against this NLS_STR

	NOTES:
		Does nothing in retail build.

	HISTORY:
		beng		07/23/91	Header added; removed redundant "nls" parameter.

********************************************************************/

VOID NLS_STR::CheckIstr( const ISTR& istr ) const
{
	UIASSERT( (istr).QueryPNLS() == this );
	UIASSERT( (istr).QueryVersion() == QueryVersion() );
}


VOID NLS_STR::IncVers()
{
	_usVersion++;
}


VOID NLS_STR::InitializeVers()
{
	_usVersion = 0;
}


VOID NLS_STR::UpdateIstr( ISTR *pistr ) const
{
	pistr->SetVersion( QueryVersion() );
}


USHORT NLS_STR::QueryVersion() const
{
	return _usVersion;
}


const CHAR * NLS_STR::QueryPch() const
{
	if (QueryError()) {
		UIASSERT(FALSE);
		return NULL;
	}

	return _pchData;
}


const CHAR * NLS_STR::QueryPch( const ISTR& istr ) const
{
	if (QueryError())
		return NULL;

	CheckIstr( istr );
	return _pchData+istr.QueryIB();
}


WCHAR NLS_STR::QueryChar( const ISTR& istr ) const
{
	if (QueryError())
		return 0;

	CheckIstr( istr );
	return *(_pchData+istr.QueryIB());
}
#endif	// DEBUG


/*******************************************************************

	NAME:		NLS_STR::ToOEM

	SYNOPSIS:	Convert string to OEM character set

	ENTRY:		No parameters

	EXIT:		String is in OEM character set

	RETURNS:

	NOTES:		If the string is already OEM, nothing happens.
				A string may be constructed as OEM by constructing
				as usual, then calling SetOEM().  Casemap conversion
				does NOT work on OEM strings!

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::ToOEM()
{
	if (IsOEM())
		return;			// string is already OEM

	SetOEM();

#ifdef WIN31
	::AnsiToOem( _pchData, _pchData );
#endif
}


/*******************************************************************

	NAME:		NLS_STR::ToAnsi

	SYNOPSIS:	Convert string to ANSI character set

	ENTRY:		No parameters

	EXIT:		String is in ANSI character set

	RETURNS:

	NOTES:		If the string is already ANSI (the default), nothing
				happens.

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::ToAnsi()
{
	if (!IsOEM())
		return;			// string is already ANSI

	SetAnsi();

#ifdef WIN31
	::OemToAnsiBuff( _pchData, _pchData, _cbData);
#endif
}


/*******************************************************************

	NAME:		NLS_STR::SetOEM

	SYNOPSIS:	Declares string to be in OEM character set

	ENTRY:		No parameters

	EXIT:		OEM flag set

	RETURNS:

	NOTES:		Use this method if you construct a string which is
				known to be in the OEM character set (e.g., it came
				back from a Net API).

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::SetOEM()
{
	_fsFlags |= SF_OEM;
}


/*******************************************************************

	NAME:		NLS_STR::SetAnsi

	SYNOPSIS:	Declares string to be in ANSI character set

	ENTRY:		No parameters

	EXIT:		OEM flag set

	RETURNS:

	NOTES:		This method is used primarily by NLS_STR itself,
				when an ANSI string is assigned to a previously
				OEM one.

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::SetAnsi()
{
	_fsFlags &= ~SF_OEM;
}


/*******************************************************************

	NAME:		NLS_STR::IsDBCSLeadByte

	SYNOPSIS:	Returns whether a character is a lead byte or not

	ENTRY:		ch - byte to check

	EXIT:		TRUE if "ch" is a lead byte

	RETURNS:

	NOTES:		This method works whether the string is OEM or ANSI.
				In a non-DBCS build, this function is inline and
				always returns FALSE.

	HISTORY:
		gregj	04/02/93	Created

********************************************************************/

BOOL NLS_STR::IsDBCSLeadByte( CHAR ch ) const
{
	return IS_LEAD_BYTE(ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strncmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strncmp.cxx
	NLS/DBCS-aware string class: strncmp method

	This file contains the implementation of the strncmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strncmp

	SYNOPSIS:	Case sensitve string compare up to index position istrLen

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/15/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

INT NLS_STR::strncmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrEnd );

	return ::strncmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIB() );
}


INT NLS_STR::strncmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB() );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );

	return ::strncmpf( QueryPch(istrStart1),
					   nls.QueryPch(),
					   istrEnd - istrStart1 );
}


INT NLS_STR::strncmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB() );
	UIASSERT( istrEnd.QueryIB() >= istrStart2.QueryIB() );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::strncmpf( QueryPch(istrStart1),
					   nls.QueryPch(istrStart2),
					   istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strncpy.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	strncpy.c
	NLS/DBCS-aware string class: strncpy method

	This file contains the implementation of the strncpy method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		gregj	04/08/93	Created
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strncpy

	SYNOPSIS:	Copy non-null-terminated string

	ENTRY:		pchSource - string to copy
				cbSource - number of bytes to copy

	EXIT:		If successful, contents of string overwritten.
				If failed, the original contents of the string remain.

	RETURNS:	Reference to self.

	HISTORY:
		gregj	04/08/93	Created

********************************************************************/

NLS_STR& NLS_STR::strncpy( const CHAR *pchSource, UINT cbSource )
{
	if ( cbSource == 0)
		pchSource = NULL;

	if ( pchSource == NULL )
	{
		if ( !IsOwnerAlloc() && !QueryAllocSize() )
		{
			if ( !Alloc(1) )
				ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}

		UIASSERT( QueryAllocSize() > 0 );

		*_pchData = '\0';
		_cchLen = 0;
	}
	else
	{
		if ( !IsOwnerAlloc() )
		{
			if ( (UINT)QueryAllocSize() < cbSource + 1 )
			{
				CHAR * pchNew = new CHAR[cbSource + 1];

				if ( pchNew == NULL )
				{
					ReportError( WN_OUT_OF_MEMORY );
					return *this;
				}

				delete _pchData;
				_pchData = pchNew;
				_cbData = cbSource + 1;
			}
		}
		else
		{
			if ((UINT)QueryAllocSize() < cbSource + 1)
				cbSource = QueryAllocSize() - 1;
		}

		::strncpyf( _pchData, pchSource, cbSource );

		/*
		 * Get the new length of the string.  It may not necessarily be
		 * cbSource because if the string is getting truncated, cbSource
		 * might be halfway through a double-byte character.
		 */

		 _pchData[cbSource] = '\0';

		_cchLen = ::strlenf( _pchData );
		
	}

	IncVers();

	/* Reset the error state, since the string is now valid.
	 */	
	ReportError( WN_SUCCESS );
	return *this;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strparty.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strparty.cxx
	NLS/DBCS-aware string class: party support

	This file contains the implementation of the Party() and
	DonePartying() methods of NLS_STR, used for string operations
	outside the set supported by NLS_STR itself.

	FILE HISTORY:
		gregj	03/25/93	Created
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::Party

	SYNOPSIS:	Obtains read-write access to the string buffer, and
				disables standard member function access to the string.

	ENTRY:		No parameters

	EXIT:		Returns a pointer to the string, NULL if in an error state

	NOTES:		Use Party() with care.  Check your partying code to
				make sure it's DBCS-safe, doesn't overflow the string
				buffer, etc.

				Each Party() must be matched with a DonePartying() call.
				They cannot be nested.  It's probably not a good idea
				to leave a string in the Party()ing state for long.

	HISTORY:
		gregj	03/25/93	Created

********************************************************************/

CHAR *NLS_STR::Party()
{
	if (QueryError())
		return NULL;

	ReportError( WN_ACCESS_DENIED );	// keep other folks out
	return _pchData;					// OK, go party
}


/*******************************************************************

	NAME:		NLS_STR::DonePartying

	SYNOPSIS:	Releases read-write access to the string buffer, and
				re-enables standard member access.

	ENTRY:		cchNew - new string length (may be omitted, in which
						 case it's determined by strlenf())

	EXIT:		No return value

	NOTES:

	HISTORY:
		gregj	03/25/93	Created
        lens    03/16/94    Don't let Party/DonePartying pairs lose hard allocation errors.

********************************************************************/

VOID NLS_STR::DonePartying( INT cchNew )
{
	_cchLen = cchNew;			// store new length
	if (QueryError() == WN_ACCESS_DENIED ) {
    	ReportError( WN_SUCCESS );	// standard members can access now
    }
	IncVers();					// all ISTRs are invalid now
}


VOID NLS_STR::DonePartying( VOID )
{
	DonePartying( ::strlenf( _pchData ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strnicmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strnicmp.cxx
	NLS/DBCS-aware string class: strnicmp method

	This file contains the implementation of the strnicmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strnicmp

	SYNOPSIS:	Case insensitve string compare up to index position istrEnd

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/15/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

int NLS_STR::strnicmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrEnd );

	return ::strnicmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIB() );
}


int NLS_STR::strnicmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB() );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );

	return ::strnicmpf( QueryPch(istrStart1),
						nls.QueryPch(),
						istrEnd - istrStart1 );
}


int NLS_STR::strnicmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB()  );
	UIASSERT( istrEnd.QueryIB() >= istrStart2.QueryIB()  );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::strnicmpf( QueryPch(istrStart1),
						nls.QueryPch(istrStart2),
						istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strprof.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strprof.c
	NLS/DBCS-aware string class:  GetPrivateProfileString method

	This file contains the implementation of the GetPrivateProfileString method
	for the NLS_STR class.  It is separate so that clients of NLS_STR who
	do not use this operator need not link to it.

	FILE HISTORY:
		04/08/93	gregj	Created
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::GetPrivateProfileString

	SYNOPSIS:	Loads a string from an INI file.

	ENTRY:		pszFile - name of INI file to read.
				pszSection - name of section (excluding square brackets).
				pszKey - key name to retrieve.
				pszDefault - default value if key not found.

	EXIT:		String contains the value associated with the key.

	NOTES:		The string is truncated if it's being loaded into an
				owner-alloc string and doesn't entirely fit.

				No character-set assumptions are made about the string.
				If the character set of the string being loaded is
				different from the ambient set of the NLS_STR, use
				SetOEM() or SetAnsi() to make the NLS_STR correct.

	HISTORY:
		gregj	04/08/93	Created

********************************************************************/

VOID NLS_STR::GetPrivateProfileString( const CHAR *pszFile,
									   const CHAR *pszSection,
									   const CHAR *pszKey,
									   const CHAR *pszDefault /* = NULL */ )
{
	static CHAR szNull[] = "";

	if (QueryError())
		return;

	if (pszDefault == NULL)
		pszDefault = szNull;

	if (!IsOwnerAlloc() && !QueryAllocSize()) {
		if (!realloc( MAX_RES_STR_LEN )) {
			ReportError( WN_OUT_OF_MEMORY );
			return;
		}
	}

	INT cbCopied;

	for (;;) {						/* really just tries twice */
		cbCopied = ::GetPrivateProfileString( pszSection, pszKey,
							pszDefault, _pchData, _cbData, pszFile );

		if (IsOwnerAlloc() || cbCopied < QueryAllocSize() - 1 ||
			(QueryAllocSize() >= MAX_RES_STR_LEN))
			break;					/* string fit, or can't grow */

		if (!realloc( MAX_RES_STR_LEN ))
			break;					/* tried to grow, but couldn't */
	}

	_cchLen = cbCopied;
	IncVers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strspn.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strspn.cxx
	NLS/DBCS-aware string class: strspn method

	This file contains the implementation of the strspn method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strspn

	SYNOPSIS:	Find first char in *this that is not a char in arg. and puts
				the position in pistrPos.
				Returns FALSE when no characters do not match

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strspn( ISTR * pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	pistrPos->SetIB( ::strspnf( QueryPch(), nls.QueryPch() ) );
	return *QueryPch( *pistrPos ) != '\0';
}


BOOL NLS_STR::strspn( ISTR *	      pistrPos,
					  const NLS_STR & nls,
					  const ISTR    & istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( istrStart );

	pistrPos->SetIB( ::strspnf(QueryPch( istrStart ), nls.QueryPch() ) +
					 istrStart.QueryIB()  );
	return *QueryPch( *pistrPos ) != '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strqss.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strqss.cxx
	NLS/DBCS-aware string class: QuerySubStr method

	This file contains the implementation of the QuerySubStr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


// Magic value used below
//
#define CB_ENTIRE_STRING (-1)


/*******************************************************************

	NAME:		NLS_STR::QuerySubStr

	SYNOPSIS:	Return a pointer to a new NLS_STR that contains the contents
				of *this from istrStart to:
				  istrStart end of string or
				  istrStart + istrEnd

	ENTRY:

	EXIT:

	RETURNS:	Pointer to newly alloc'd NLS_STR, or NULL if error

	NOTES:		The private method QuerySubStr(ISTR&, CB) is the worker
				method, the other two just check the parameters and
				pass the data. It is private since we can't allow the
				user to access the string on a byte basis

	CAVEAT:		Note that this method creates an NLS_STR that the client is
				responsible for deleting.

	HISTORY:
		johnl	11/26/90	Created
		beng	04/26/91	Replaced CB wth INT; broke out CB_ENTIRE_STRING
							magic value
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart, INT cbLen ) const
{
	if (QueryError())
		return NULL;

	CheckIstr( istrStart );

	INT cchStrLen = ::strlenf(QueryPch(istrStart) );
	INT cbCopyLen = ( cbLen == CB_ENTIRE_STRING || cbLen >= cchStrLen )
					? cchStrLen
					: cbLen;

	NLS_STR *pnlsNew = new NLS_STR( cbCopyLen + 1 );
	if ( pnlsNew == NULL )
		return NULL;

	if ( pnlsNew->QueryError() )
	{
		delete pnlsNew;
		return NULL;
	}

	::memcpyf( pnlsNew->_pchData, QueryPch(istrStart), cbCopyLen );
	*(pnlsNew->_pchData + cbCopyLen) = '\0';

	pnlsNew->_cchLen = cbCopyLen;

	return pnlsNew;
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart ) const
{
	return QuerySubStr( istrStart, CB_ENTIRE_STRING );
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR  & istrStart,
								const ISTR  & istrEnd  ) const
{
	CheckIstr( istrEnd );
	UIASSERT( istrEnd.QueryIB() >= istrStart.QueryIB() );

	return QuerySubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strrchr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strrchr.cxx
	NLS/DBCS-aware string class: strrchr method

	This file contains the implementation of the strrchr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strrchr

	SYNOPSIS:	Puts the index of the last occurrence of ch in *this into
				istrPos.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/26/90	Written
		beng	07/23/91	Allow on erroneous string; update CheckIstr

********************************************************************/

BOOL NLS_STR::strrchr( ISTR * pistrPos, const CHAR ch ) const
{
	if (QueryError())
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strrchrf( QueryPch(), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::strrchr(
	ISTR *pistrPos,
	const CHAR ch,
	const ISTR& istrStart ) const
{
	if (QueryError())
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strrchrf(QueryPch(istrStart), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strtok.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strtok.cxx
	NLS/DBCS-aware string class: strtok method

	This file contains the implementation of the strtok method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strtok

	SYNOPSIS:	Basic strtok functionality.  Returns FALSE after the
				string has been traversed.

	ENTRY:

	EXIT:

	NOTES:		We don't update the version on the string since the
				::strtokf shouldn't cause DBCS problems.  It would also
				be painful on the programmer if on each call to strtok
				they had to update all of the ISTR associated with this
				string

				fFirst is required to be TRUE on the first call to
				strtok, it is FALSE afterwards (is defaulted to FALSE)

	CAVEAT:		Under windows, all calls to strtok must be done while
				processing a single message.  Otherwise another process
				my confuse it.

	HISTORY:
		johnl	11/26/90	Created
		beng	07/23/91	Allow on erroneous string

********************************************************************/

BOOL NLS_STR::strtok( 
	ISTR *pistrPos,
	const NLS_STR& nlsBreak,
	BOOL fFirst )
{
	if (QueryError())
		return FALSE;

	const CHAR * pchToken = ::strtokf( fFirst ? _pchData : NULL, (CHAR *)nlsBreak.QueryPch());

	if ( pchToken == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchToken - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strrss.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strrss.cxx
	NLS/DBCS-aware string class: strrss method

	This file contains the implementation of the strrss method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::ReplSubStr

	SYNOPSIS:	Replace the substring starting at istrStart with the
				passed nlsRepl string.

				If both a start and end is passed, then the operation is
				equivalent to a DelSubStr( start, end ) and an
				InsertSubStr( start ).

				If just a start is passed in, then the operation is
				equivalent to DelSubStr( start ), concat new string to end.

				The ReplSubStr( NLS_STR&, istrStart&, INT cbDel) method is
				private.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/29/90	Created
		beng	04/26/91	Replaced CB with INT
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl, ISTR& istrStart )
{
	if (QueryError() || !nlsRepl)
		return;

	CheckIstr( istrStart );

	DelSubStr( istrStart );
	strcat( nlsRepl );
}


VOID NLS_STR::ReplSubStr( const NLS_STR& nlsRepl,
						  ISTR& istrStart,
						  const ISTR& istrEnd )
{
	CheckIstr( istrEnd );
	UIASSERT( istrEnd.QueryIB() >= istrStart.QueryIB() );

	ReplSubStr( nlsRepl, istrStart, istrEnd - istrStart );
}


VOID NLS_STR::ReplSubStr( const NLS_STR& nlsRepl,
						  ISTR& istrStart,
						  INT cbToBeDeleted )
{
	if (QueryError() || !nlsRepl)
		return;

	CheckIstr( istrStart );

	INT cbRequired = strlen() - cbToBeDeleted + nlsRepl.strlen() + 1;
	if ( !IsOwnerAlloc() && QueryAllocSize() < cbRequired )
	{
		if ( !realloc( cbRequired ) )
		{
			ReportError( WN_OUT_OF_MEMORY );
			return;
		}
	}
	else
		UIASSERT( QueryAllocSize() >= cbRequired );

	CHAR * pchStart = (CHAR *)QueryPch(istrStart) + cbToBeDeleted;
	::memmovef( pchStart + nlsRepl.strlen()-cbToBeDeleted,
				pchStart,
				::strlenf( pchStart ) + 1 );
	::memmovef( (CHAR *)QueryPch(istrStart),
				nlsRepl._pchData,
				nlsRepl.strlen() );

	_cchLen = strlen() + nlsRepl.strlen() - cbToBeDeleted;

	IncVers();
	UpdateIstr( &istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strupr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strupr.cxx
	NLS/DBCS-aware string class: strupr method

	This file contains the implementation of the strupr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strupr

	SYNOPSIS:	Convert *this lower case letters to upper case

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/26/90	Written
		beng	07/23/91	Allow on erroneous string

********************************************************************/

NLS_STR& NLS_STR::strupr()
{
	if (!QueryError())
		::struprf( _pchData );

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\strstr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strstr.cxx
	NLS/DBCS-aware string class: strstr method

	This file contains the implementation of the strstr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strstr

	SYNOPSIS:	Returns TRUE if the passed string is found, false otherwise.
				pistrPos contains start of the specified string if TRUE
				is returned.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strstr( ISTR * pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strstrf( QueryPch(), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::strstr( ISTR    * pistrPos,
					  const NLS_STR & nls,
					  const ISTR    & istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strstrf(QueryPch(istrStart), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int)(pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\timedata.cpp ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/
/* :ts=4 */

/***	timedata.cpp - table of days in each month for time conversion
 */

#include "npcommon.h"
#include <convtime.h>

WORD MonTotal[] = { 0,					// dummy entry for month 0
	0,									// days before Jan 1
	31,									// days before Feb 1
	31+28,								// days before Mar 1
	31+28+31,							// days before Apr 1
	31+28+31+30,						// days before May 1
	31+28+31+30+31,						// days before Jun 1
	31+28+31+30+31+30,					// days before Jul 1
	31+28+31+30+31+30+31,				// days before Aug 1
	31+28+31+30+31+30+31+31, 			// days before Sep 1
	31+28+31+30+31+30+31+31+30,			// days before Oct 1
	31+28+31+30+31+30+31+31+30+31,		// days before Nov 1
	31+28+31+30+31+30+31+31+30+31+30,	// days before Dec 1
	31+28+31+30+31+30+31+31+30+31+30+31	// days before end of year
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\common\upr.cpp ===
#include "npcommon.h"

/* In a DBCS build, the Win32 CharUpper API will uppercase double-byte
 * Romanji characters, but many low-level network components such as
 * IFSMGR (and NetWare servers!) do not uppercase any double-byte
 * characters.  So we have to have our own function which avoids them.
 *
 * This could be implemented by just calling CharUpper on each character,
 * but the NLS APIs have a fair amount of overhead to them, so calling
 * into the NLS subsystem as few times as possible is desirable.
 */
LPSTR WINAPI struprf(LPSTR lpString)
{
    if (!::fDBCSEnabled)
        return CharUpper(lpString);

	LPSTR pchStart = lpString;

	while (*pchStart != '\0') {
		// Skip any double-byte characters that may be here.
		// Don't need to check for end of string in the loop because
		// the null terminator is not a DBCS lead byte.
		while (IsDBCSLeadByte(*pchStart))
			pchStart += 2;	/* skip double-byte chars */

		if (*pchStart == '\0')
			break;			/* no more SBCs to uppercase */

		// Find the end of this range of single-byte characters, and
		// uppercase them.
		LPSTR pchEnd = pchStart + 1;
		while (*pchEnd && !IsDBCSLeadByte(*pchEnd))
			pchEnd++;		/* count single-byte chars */

		CharUpperBuff(pchStart, (int)(pchEnd-pchStart));
		pchStart = pchEnd;
	}

	return lpString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\buffer.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFFER.H -- Definition of BUFFER class.
 *
 * History:
 *	03/22/93	gregj	Created
 *	03/24/93	gregj	Created base class, GLOBAL_BUFFER
 *	10/06/93	gregj	Removed LOCAL_BUFFER and GLOBAL_BUFFER because
 *						they're incompatible with Win32.
 */

#ifndef _INC_BUFFER
#define _INC_BUFFER

/*************************************************************************

    NAME:		BUFFER_BASE

    SYNOPSIS:	Base class for transient buffer classes

    INTERFACE:	BUFFER_BASE()
					Construct with optional size of buffer to allocate.

				Resize()
					Resize buffer to specified size.  Returns TRUE if
					successful.

				QuerySize()
					Return the current size of the buffer in bytes.

				QueryPtr()
					Return a pointer to the buffer.

    PARENT:		None

    USES:		None

    CAVEATS:	This is an abstract class, which unifies the interface
				of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:		In standard OOP fashion, the buffer is deallocated in
				the destructor.

    HISTORY:
		03/24/93	gregj	Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
	UINT _cb;

	virtual BOOL Alloc( UINT cbBuffer ) = 0;
	virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
	BUFFER_BASE()
		{ _cb = 0; }	// buffer not allocated yet
	~BUFFER_BASE()
		{ _cb = 0; }	// buffer size no longer valid
	BOOL Resize( UINT cbNew );
	UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER	BUFFER

/*************************************************************************

    NAME:		BUFFER

    SYNOPSIS:	Wrapper class for new and delete

    INTERFACE:	BUFFER()
					Construct with optional size of buffer to allocate.

				Resize()
					Resize buffer to specified size.  Only works if the
					buffer hasn't been allocated yet.

				QuerySize()
					Return the current size of the buffer in bytes.

				QueryPtr()
					Return a pointer to the buffer.

    PARENT:		BUFFER_BASE

    CAVEATS:

    NOTES:		In standard OOP fashion, the buffer is deallocated in
				the destructor.

    HISTORY:
		03/24/93	gregj	Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
	CHAR *_lpBuffer;

	virtual BOOL Alloc( UINT cbBuffer );
	virtual BOOL Realloc( UINT cbBuffer );

public:
	BUFFER( UINT cbInitial=0 );
	~BUFFER();
	LPVOID QueryPtr() const { return (LPVOID)_lpBuffer; }
	operator void*() const { return (void *)_lpBuffer; }
};

#define LOCAL_BUFFER	BUFFER

#endif	/* _INC_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\netlib.h ===
// placeholder

#ifdef __cplusplus
extern "C" {
#endif

void * WINAPI MemAlloc(long cb);
void * WINAPI MemReAlloc(void * pb, long cb);
BOOL WINAPI MemFree(void * pb);

#define memcmpf(d,s,l)  memcmp((d),(s),(l))
#define memcpyf(d,s,l)  memcpy((d),(s),(l))
#define memmovef(d,s,l) MoveMemory((d),(s),(l))
#define memsetf(s,c,l)  memset((s),(c),(l))
#define strcatf(d,s)    lstrcat((d),(s))
#define strcmpf(s1,s2)  lstrcmp(s1,s2)
#define strcpyf(d,s)    lstrcpy((d),(s))
#define stricmpf(s1,s2) lstrcmpi(s1,s2)
#define strlenf(s)      lstrlen((s))

LPSTR WINAPI strncpyf(LPSTR, LPCSTR, UINT);
LPSTR WINAPI strrchrf(LPCSTR, UINT);
UINT  WINAPI strspnf(LPCSTR, LPCSTR);
LPSTR WINAPI strchrf(LPCSTR, UINT);
int   WINAPI strnicmpf(LPCSTR, LPCSTR, UINT);
UINT  WINAPI strcspnf(LPCSTR, LPCSTR);
LPSTR WINAPI strtokf(LPSTR, LPSTR);
LPSTR WINAPI strstrf(LPCSTR, LPCSTR);
LPSTR WINAPI stristrf(LPCSTR, LPCSTR);
int   WINAPI strncmpf(LPCSTR, LPCSTR, UINT);

LPSTR WINAPI struprf(LPSTR s);

extern BOOL fDBCSEnabled;

#ifdef __cplusplus
#define IS_LEAD_BYTE(c)     (fDBCSEnabled ? ::IsDBCSLeadByte(c) : 0)
#else
#define IS_LEAD_BYTE(c)     (fDBCSEnabled ? IsDBCSLeadByte(c) : 0)
#endif

void WINAPI InitStringLibrary(void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\base.h ===
/*****************************************************************/ 
/**				Microsoft Windows for Workgroups				**/
/**			Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
    base.h
    Universal base class for error cascading and debugging information

    FILE HISTORY
	beng	    09-Jul-1990     created
	beng	    17-Jul-1990     added standard comment header to BASE
	beng	    31-Jul-1991     added FORWARDING_BASE
	rustanl     11-Sep-1991     Added DECLARE_OUTLINE_NEWBASE,
				    DECLARE_MI_NEWBASE, DEFINE_MI2_NEWBASE,
				    DEFINE_MI3_NEWBASE, and DEFINE_MI4_NEWBASE
	gregj		22-Mar-1993		Ported to Chicago environment
*/


#ifndef _BASE_HXX_
#define _BASE_HXX_

/*************************************************************************

    NAME:	BASE (base)

    SYNOPSIS:	Universal base object, root of every class.
		It contains universal error status and debugging
		support.

    INTERFACE:	ReportError()	- report an error on the object from
				  within the object.

		QueryError()	- return the current error state,
				  or 0 if no error outstanding.

		operator!()	- return TRUE if an error is outstanding.
				  Typically means that construction failed.

    CAVEATS:	This sort of error reporting is safe enough in a single-
		threaded system, but loses robustness when multiple threads
		access shared objects.	Use it for constructor-time error
		handling primarily.

    NOTES:	A class which inherits BASE through a private class should
		use the NEWBASE macro (q.v.) in its definition; otherwise
		its clients will lose the use of ! and QueryError.

    HISTORY:
	rustanl     07-Jun-1990     Created as part of LMOD
	beng	    09-Jul-1990     Gutted, removing LMOD methods
	beng	    17-Jul-1990     Added USHORT error methods
	beng	    19-Oct-1990     Finally, removed BOOL error methods
	johnl	    14-Nov-1990     Changed QueryError to be a const method
	beng	    25-Jan-1991     Added the ! Boolean operator and NEWBASE
	beng	    31-Jul-1991     Made FORWARDING_BASE a friend
	gregj		22-Mar-1993		Ported to Chicago (removed excess baggage)

*************************************************************************/

class BASE
{
private:
    UINT _err;

protected:
    BASE() { _err = 0; }
    VOID    ReportError( WORD err ) { _err = err; }

public:
    UINT	QueryError() const { return _err; }
    BOOL    operator!() const  { return (_err != 0); }
};

#endif // _BASE_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\convtime.h ===
/*****************************************************************/
/**		      	Copyright (C) Microsoft Corp., 1996				**/
/*****************************************************************/ 

/* CONVTIME.H -- Header file for time conversion subroutines.
 *
 * History:
 *	gregj	04/22/96	Created for subroutines snarfed from vredir.
 */


#ifndef _INC_CONVTIME
#define _INC_CONVTIME

#ifndef RC_INVOKED
#ifdef __cplusplus
extern "C" {
#endif


#define _70_to_80_bias	0x012CEA600L
#define SECS_IN_DAY (60L*60L*24L)
#define SEC2S_IN_DAY (30L*60L*24L)
#define FOURYEARS	(3*365+366)

extern WORD MonTotal[];


typedef struct tagdos_time {
	WORD dt_date;
	WORD dt_time;
} dos_time;

void
NetToDosDate(
DWORD time,
dos_time *pinfo);

DWORD
DosToNetDate(dos_time dt);

void
NetToSystemDate(
DWORD time,
LPSYSTEMTIME pinfo);

DWORD
SystemToNetDate(LPSYSTEMTIME pinfo);

DWORD
GetCurrentNetDate(void);

DWORD
GetLocalNetDate(void);


#ifdef __cplusplus
};	/* extern "C" */
#endif

#endif	/* RC_INVOKED */

#endif	/* _INC_CONVTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\contxids.h ===
/*
   Definitions of Help IDs
*/
#define IDH_IGNORE                                              (-1)

/* Options - Appearance Page */
#define IDH_APPEARANCE_SHOW_PICTURES                            0x1000  
#define IDH_APPEARANCE_USE_CUSTOM_COLORS                        0x1001  
#define IDH_APPEARANCE_COLORS_TEXT                              0x1002  
#define IDH_APPEARANCE_COLORS_BACKGROUND                        0x1003  
#define IDH_APPEARANCE_COLORS_VIEWED                            0x1004  
#define IDH_APPEARANCE_COLORS_NOT_VIEWED                        0x1005  
#define IDH_APPEARANCE_UNDERLINE_SHORTCUTS                      0x1006  
#define IDH_APPEARANCE_SHOW_URL_IN_SB                           0x1007
#define IDH_APPEARANCE_SHOW_SIMPLE_URL                          0x1008  
#define IDH_APPEARANCE_SHOW_FULL_URL                            0x1009 

/* Options - Home Base */
#define IDH_HOME_BASE_USE_CURRENT                               0x100a
#define IDH_HOME_BASE_USE_DEFAULT                               0x100b

/* Options - Advanced Page */
#define IDH_ADVANCED_HST_NUM_PLACES                             0x100c
#define IDH_ADVANCED_HST_EMPTY                                  0x100d
#define IDH_ADVANCED_HST_LOCATION                               0x100e  
#define IDH_ADVANCED_HST_BROWSE                                 0x100f
#define IDH_ADVANCED_CACHE_PERCENT                              0x1010
#define IDH_ADVANCED_CACHE_EMPTY                                0x1011
#define IDH_ADVANCED_CACHE_LOCATION                             0x1012  
#define IDH_ADVANCED_CACHE_BROWSE                               0x1013

/* Goto Dialog Box */
#define IDH_GOTOURL_COMBO                                       0x1014
#define IDH_GOTOURL_NEWWINDOW                                   0x1015
#define IDH_GOTOURL_OPENFILE                                    0x1016

/* Find Dialog Box */
#define IDH_FIND_TEXTTOFIND                                     0x1017
#define IDH_FIND_STARTFROMTOP                                   0x1018
#define IDH_FIND_MATCHCASE                                      0x1019
#define IDH_FIND_FINDNEXT                                       0x101a

/* Page Setup Dialog Box */
#define IDH_PAGESETUP_MARGIN_LEFT                               0x101b
#define IDH_PAGESETUP_MARGIN_TOP                                0x101c
#define IDH_PAGESETUP_MARGIN_RIGHT                              0x101d
#define IDH_PAGESETUP_MARGIN_BOTTOM                             0x101e
#define IDH_PAGESETUP_HEADER_LEFT                               0x101f
#define IDH_PAGESETUP_HEADER_RIGHT                              0x1020
#define IDH_PAGESETUP_FOOTER_LEFT                               0x1021
#define IDH_PAGESETUP_FOOTER_RIGHT                              0x1022

/* More Options - Advanced Page */
#define IDH_ADVANCED_CACHE_ONCEPERSESS                          0x1023
#define IDH_ADVANCED_CACHE_NEVER                                0x1024

/* File Type */
#define IDH_FILETYPE_CONTENT_TYPE                               0x1025
#define IDH_FILETYPE_OPENS_WITH                                 0x1026
#define IDH_NEW_FILETYPE_CONTENT_TYPE                           0x1027
#define IDH_NEWFILETYPE_DEFAULT_EXT                             0x1028
#define IDH_FILETYPE_EXTENSION                                  0x1029

/* New Help IDs for Internet Explorer 1.x below */
/* More Options - Appearance */
#define IDH_APPEARANCE_PLAY_SOUNDS                              0x102a
#define IDH_APPEARANCE_PROPORTIONAL_FONT                        0x102b
#define IDH_APPEARANCE_FIXED_FONT                               0x102c
#define IDH_APPEARANCE_SHOW_URL                                 0x102d

/* Options - News */
#define IDH_NEWS_SERVER                                         0x102e
#define IDH_NEWS_ENABLE_AUTH                                    0x102f
#define IDH_NEWS_USERNAME                                       0x1030
#define IDH_NEWS_PASSWORD                                       0x1031
#define IDH_NEWS_ON_OFF                                         0x104a  /* note order! */

/* Options - Start and Search Pages */
#define IDH_PAGES_LISTBOX                                       0x1032
#define IDH_PAGES_START_URL                                     0x1033
#define IDH_PAGES_START_USE_CURRENT                             0x1034
#define IDH_PAGES_START_USE_DEFAULT                             0x1035
#define IDH_PAGES_SEARCH_URL                                    0x1036
#define IDH_PAGES_SEARCH_USE_CURRENT                            0x1037
#define IDH_PAGES_SEARCH_USE_DEFAULT                            0x1038

/* Options - Security */
#define IDH_SECURITY_TELL_ME                                    0x1039
#define IDH_SECURITY_SEND_HIGH                                  0x103a
#define IDH_SECURITY_SEND_MED                                   0x103b
#define IDH_SECURITY_SEND_LOW                                   0x103c
#define IDH_SECURITY_VIEW_HIGH                                  0x103d
#define IDH_SECURITY_VIEW_LOW                                   0x103e




/* Properties - General */
#define IDH_PROPG_ICON                                          0x103f
#define IDH_PROPG_TITLE                                         0x1040
#define IDH_PROPG_PROTOCOL                                      0x1041
#define IDH_PROPG_TYPE                                          0x1042
#define IDH_PROPG_URL                                           0x1043
#define IDH_PROPG_SIZE                                          0x1044
#define IDH_PROPG_CREATED                                       0x1045
#define IDH_PROPG_MODIFIED                                      0x1046
#define IDH_PROPG_UPDATED                                       0x1047

/* Properties - Security */
#define IDH_PROPS_DESC                                          0x1048
#define IDH_PROPS_CERT                                          0x1049
/* used above: #define IDH_NEWS_ON_OFF                          0x104a  */

/* File Type (continued from above) */
#define IDH_FILETYPE_CONFIRM_OPEN                               0X104b
#define IDH_APPEARANCE_SHOW_VIDEO                               0x104c


#define IDH_COMMON_GROUPBOX                                     0x104d

#define IDH_ADVANCED_ASSOC_CHECK                                0x104e 

#ifndef IDH_GROUPBOX
/* Common group box help ID */
#define IDH_GROUPBOX                                            0x2000
#endif

/* help topic that the user gets when he clicks on 
 "tell me about Internet Security" Button */
#define HELP_TOPIC_SECURITY                                     0x104f

#define IDH_SECURITY_BAD_CN_SEND                                0x1050
#define IDH_SECURITY_BAD_CN_RECV                                0x1051


/* help topic that the user gets when he clicks on 
  Help Button in Proxy settings page*/
#define HELP_TOPIC_PROXY_SUPPORT                   HELP_TOPIC_SECURITY


/* Help button at bottom of Print/headers & footers dialog */
#define IDH_PAGESETUP_OVERVIEW                                  0x1052

/* new fields on news tab */
#define IDH_NEWS_EMAIL_ADDRESS                                  0x1053
#define IDH_NEWS_POSTING_NAME                                   0x1054

/* ratings control panel */
#define IDH_RATINGS_SET_RATINGS_BUTTON                          0x1055
#define IDH_RATINGS_TURNON_BUTTON                               0x1056
#define IDH_RATINGS_CATEGORY_LABEL                              0x1057
#define IDH_RATINGS_CATEGORY_LIST                               0x1058
#define IDH_RATINGS_RATING_LABEL                                0x1059
#define IDH_RATINGS_RATING_TEXT                                 0x105a
#define IDH_RATINGS_DESCRIPTION_LABEL                           0x105b
#define IDH_RATINGS_DESCRIPTION_TEXT                            0x105c
#define IDH_RATINGS_UNRATED_CHECKBOX                            0x105d
#define IDH_RATINGS_RATING_SYSTEM_BUTTON                        0x105e
#define IDH_RATINGS_RATING_SYSTEM_TEXT                          0x105f
#define IDH_RATINGS_CHANGE_PASSWORD_BUTTON                      0x1060
#define IDH_RATINGS_CHANGE_PASSWORD_TEXT                        0x1061
#define IDH_RATINGS_OVERRIDE_CHECKBOX                           0x1062
#define IDH_RATINGS_SUPERVISOR_PASSWORD                         0x1063
#define IDH_RATINGS_SUPERVISOR_CREATE_PASSWORD                  0x1064       
#define IDH_RATINGS_CHANGE_PASSWORD_CONFIRM                     0x1065
#define IDH_RATINGS_BUREAU                                      0x1066
#define IDH_RATINGS_VIEW_PROVIDER_PAGE                          0x1067
#define IDH_RATINGS_SYSTEM_RATSYS_LIST                          0x1068
#define IDH_RATINGS_SYSTEM_RATSYS_ADD                           0x1069
#define IDH_RATINGS_SYSTEM_RATSYS_REMOVE                        0x106a
#define IDH_RATINGS_CHANGE_PASSWORD_OLD                         0x106b
#define IDH_RATINGS_CHANGE_PASSWORD_NEW                         0x106c
#define IDH_PICSRULES_OPEN                                      0x1070
#define IDH_PICSRULES_EDIT                                      0x1071
#define IDH_PICSRULES_APPROVEDNEVER                             0x1072
#define IDH_PICSRULES_APPROVEDALWAYS                            0x1073
#define IDH_PICSRULES_APPROVEDREMOVE                            0x1074
#define IDH_PICSRULES_APPROVEDLIST                              0x1075
#define IDH_PICSRULES_APPROVEDEDIT                              0x1076
#define IDH_FIND_RATING_SYSTEM_BUTTON                           0x1077
#define IDH_ADVANCED_TAB_DOWN_ARROW_BUTTON                      0x1078
#define IDH_ADVANCED_TAB_UP_ARROW_BUTTON                        0x1079
#define IDH_PICS_RULES_LIST                                     0x1080
#define IDH_RATINGS_VIEW_RESTRICTED                             0x1081
#define IDH_RATINGS_ENTER_PW_HINT                               0x1085
#define IDH_RATINGS_DISPLAY_PW_HINT                             0x1086
#define IDH_RATINGS_DESCRIBE_RESTRICTED                         0x108f

// Safety: Protecting you from the net
#define IDH_SAFETY_YOUWEREPROTECTED                             0x106d


// reserve range       0x3000 -- 0x4000 for shell
#define IDH_FOR_SHDOCVW_BEGIN                                   0x3000
#define IDH_FOR_SHDOCVW_END                                     0x4000

//  Contents:   Helpids for User project

#define IDH_USERS_LIST                                          81000
#define IDH_NEW_USER                                            81001
#define IDH_REMOVE_USER                                         81002
#define IDH_COPY_USER                                           81003
#define IDH_SET_PASSWORD                                        81004
#define IDH_OLD_PASSWORD                                        81005
#define IDH_NEW_PASSWORD                                        81006
#define IDH_CONFIRM_PASSWORD                                    81007
#define IDH_CHANGE_DESKTOP                                      81008
#define IDH_DESKTOP_NETHOOD                                     81009
#define IDH_START_MENU                                          81010
#define IDH_FAVORITES                                           81011
#define IDH_TEMP_FILES                                          81012
#define IDH_MY_DOCS                                             81013
#define IDH_EMPTY_FOLDERS                                       81014
#define IDH_EXISTING_FILES                                      81015
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\netmpr.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    netmpr.h

Abstract:

    DDK WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:


Revision History:

    20-Mar-1995     LenS
        Created.

--*/

#ifndef _INC_NETMPR_
#define _INC_NETMPR_


//
//  Authentication and Logon/Logoff.
//

#define LOGON_DONE              0x00000001
#define LOGON_PRIMARY           0x00000002
#define LOGON_MUST_VALIDATE     0x00000004

#define LOGOFF_PENDING  1
#define LOGOFF_COMMIT   2
#define LOGOFF_CANCEL   3


//
//  Password Cache.
//

#ifndef PCE_STRUCT_DEFINED
#define PCE_STRUCT_DEFINED

struct PASSWORD_CACHE_ENTRY {
    WORD cbEntry;               /* size of this entry in bytes, incl. pad */
    WORD cbResource;            /* size of resource name in bytes */
    WORD cbPassword;            /* size of password in bytes */
    BYTE iEntry;                /* index number of this entry, for MRU */
    BYTE nType;                 /* type of entry (see below) */
    char abResource[1];         /* resource name (may not be ASCIIZ at all) */
};

#define PCE_MEMORYONLY          0x01    /* for flags field when adding */

/*
    Typedef for the callback routine passed to the enumeration functions.
    It will be called once for each entry that matches the criteria
    requested.  It returns TRUE if it wants the enumeration to
    continue, FALSE to stop.
*/
typedef BOOL (FAR PASCAL *CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData );

#endif  /* PCE_STRUCT_DEFINED */

DWORD APIENTRY
WNetCachePassword(
    LPSTR pbResource,
    WORD  cbResource,
    LPSTR pbPassword,
    WORD  cbPassword,
    BYTE  nType,
    UINT  fnFlags
    );

DWORD APIENTRY
WNetGetCachedPassword(
    LPSTR  pbResource,
    WORD   cbResource,
    LPSTR  pbPassword,
    LPWORD pcbPassword,
    BYTE   nType
    );

DWORD APIENTRY
WNetRemoveCachedPassword(
    LPSTR pbResource,
    WORD  cbResource,
    BYTE  nType
    );

DWORD APIENTRY
WNetEnumCachedPasswords(
    LPSTR pbPrefix,
    WORD  cbPrefix,
    BYTE  nType,
    CACHECALLBACK pfnCallback,
    DWORD dwRefData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\nowindep.h ===
#define	NOGDI
#define	NONLS
#define NORESOURCE
#define NOSCROLL
#define NOSHOWWINDOW
#define NOVIRTUALKEYCODES
#define NOWH
#define NODESKTOP
#define NOWINDOWSTATION
#define NOSECURITY
#define NOMSG
#define NOWINOFFSETS
#define NONCMESSAGES
#define NOKEYSTATES
#define NOCLIPBOARD
#define NODEFERWINDOWPOS
#define NOSYSMETRICS
#define NOMENUS
#define NODRAWTEXT
#define NOMB
#define NOCOLOR
#define NOSYSCOMMANDS
#define NOICONS
#define NOWINMESSAGES
#define NOMDI
#define NOHELP
#define NOSYSPARAMSINFO
#define NOSERVICE
#define _INC_MMSYSTEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\iconlbox.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1993                         **/
/***************************************************************************/

/****************************************************************************

    ICONLBOX.H

    Header file for IconListBox class (hard tabs at 4)

    May 93,         JimH (combobox support added by VladS)

    IconListBox is constructed by specifying the application's hInst and
    the ID of the listbox control.  All the properties of the listbox (font,
    single or muliple selection, etc.) are defined in the .RC file.  It must
    include the LBS_OWNERDRAWFIXED style.

    Icons are really bitmaps or parts of bitmaps.  They must all be the same
    size.  If they are not 16 by 16 this size must be specified in the
    constructor.  By default, bright green (RGB(0,255,0)) is the transparent
    color but this can be overridden for each individual icon.

    Construction of the IconListBox object should occur when the dialog is
    created.  You cannot wait until WM_INITDIALOG time because you need to
    handle the WM_MEASUREITEM message which comes first by passing to the
    constructed IconListBox.  Similarly, the IconListBox cannot be destructed
    during OK or Cancel handling because you will have to handle subsequent
    WM_DRAWITEM messages.

    Follow these steps to use IconListBox (assumes 16 by 16 icons)

    1.  Construct IconListBox(hInst, IDC_MYLISTBOX);

    2.  Handle WM_MEASUREITEM by calling

        mylistbox->SetHeight(hwndDlg, (MEASUREITESTRUCT FAR *)lParam);

        You MUST do this step even if you are using the default height of 16
        pixels.

    3.  During WM_INITDIALOG processing, register each possible icon by
        specifying your internal identifier for this icon, a bitmap id, and
        if necessary, the x and y offset in the bitmap of this icon.
        Don't load the bitmap yourself.  Just pass the .RC file id.

        mylistbox->RegisterIcon(typeFission, IDB_MushroomCloud);

        Note that you can register several icons from the same .RC file
        bitmap.  These may or may not have different x and y offsets but
        they must all have the same transparent color.  There is no
        extra overhead associated with reusing bitmaps or parts of bitmaps.

    4   Also during WM_INITDIALOG, add the listbox entries.

        mylistbox->AddString(typeColdFusion, "Pons & Fleishman");

    5.  Handle the WM_DRAWITEM message by calling

        if (wParam == IDC_MYLISTBOX)
            mylistbox->DrawItem((DRAWITEMSTRUCT FAR *)lParam);

    6.  When handling OK, do whatever listbox stuff you have to do.

        n = mylistbox->GetCurrentSelection();
        mylistbox->GetString(n, pbuffer);

    7.  Destruct IconListBox

    Inline wrappers for common listbox functions are at the end of this file.

****************************************************************************/

#ifndef _ICONLBOX_H_
#define _ICONLBOX_H_

struct IconList {
    int             nID;                // ID icon was registered with
    int             nResID;             // .RC file resource ID
    int             x, y;               // offset within specified icon
    HBITMAP         hbmSelected;
    HBITMAP         hbmUnselected;
};

const int MAXICONS      = 10;   // max number that can be registered
const int MAXTABS       = 10;   // max number of tabs in string
const int MAXSTRINGLEN  = MAX_PATH;  // AddString and InsertString limit
const int ICONSPACE     = 3;    // whitespace around Icons in listbox

class IconListBox {

    public:
        IconListBox(HINSTANCE hInst, int nID,
        int iconWidth = 16, int iconHeight = 16);
        ~IconListBox();

        int  AddString(int nIcon, const char far *string);
        void Clear();
        void DeleteString(int nIndex);
        virtual void DrawItem(LPDRAWITEMSTRUCT lpd);
        int  FindString(const char far *string, int nIndexStart = -1) const;
        int  FindStringExact(const char far *string, int nIndexStart = -1) const;
        int  GetCount();
        int  GetCurrentSelection(void) const;
        int  GetIconID(int nIndex) const;
        BOOL GetSel(int nIndex);
        int  GetSelCount() const;
        int  GetSelItems(int cItems, int FAR *lpItems) const;
        int  GetString(int nIndex, char far *string) const;
        int  InsertString(int nIcon, const char far *string, int nIndex);
        void RegisterIcon(int nIconID, int nResID, int x=0, int y=0,
                            COLORREF colTransparent = RGB(0, 255, 0));
        int  SelectString(int nIndex, const char far *string);
        int  SetCurrentSelection(int nIndex = -1) const;
        void SetHeight(HWND hwndDlg, LPMEASUREITEMSTRUCT lpm, int height=16);
        void SetRedraw(BOOL bRedraw = TRUE) const;
        void SetSel(int nIndex, BOOL bSelected = TRUE) const;
        void SetTabStops(int cTabs, const int *pTabs);

    protected:
        int         SetItemData(int nIndex, int nIconID) const;
		int			UpdateHorizontalExtent(int	nIconID,const char *string);

        int         _cIcons;                    // number of icons registered
        IconList    _aIcons[MAXICONS];          // registered icons
        int         _cTabs;                     // number of tabs registered
        int         _aTabs[MAXTABS];            // registered tabs
        int         _iconWidth, _iconHeight;    // size of icons
		int			_iCurrentMaxHorzExt;		// Currently maximum horizontal extent

        COLORREF    _colSel, _colSelText, _colUnsel, _colUnselText;

        HINSTANCE   _hInst;                     // application's hInst
        int         _nCtlID;                    // id of listbox control
        int         _nTextOffset;               // vertical DrawText offset

        BOOL        _fCombo;                    // Dropdown combo box ?

        HWND        _hwndDialog;
        HWND        _hwndListBox;

        HBRUSH      _hbrSelected;               // background colours
        HBRUSH      _hbrUnselected;
};


// AddString - returns index of new string, or LB_ERR or LB_ERRSPACE

inline int IconListBox::AddString(int nIcon, const char far *string)
{
    int nIndex =  (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                            _fCombo ? CB_ADDSTRING : LB_ADDSTRING,
                             0, (LPARAM) ((LPSTR) string));
    SetItemData(nIndex, nIcon);
	UpdateHorizontalExtent(nIcon,string);

    return nIndex;
}


// Clear - clears contents of listbox

inline void IconListBox::Clear()
{
    ::SendMessage(_hwndListBox,
                  _fCombo ? CB_RESETCONTENT : LB_RESETCONTENT, 0, 0);

    _iCurrentMaxHorzExt = 0;
}


// DeleteString - removes a string specified by the index

inline void IconListBox::DeleteString(int nIndex)
{
    ::SendMessage(_hwndListBox,
                  _fCombo ? CB_DELETESTRING : LB_DELETESTRING, nIndex, 0);

	// May be horizontal extent changed - recalculate again
	UpdateHorizontalExtent(0,NULL);

}

// FindString & FindStringExact
//
// These functions find a listbox entry that begins with the characters
// specifed in string (FindString) or exactly matches string (FindStringExact)
// They return LB_ERR if the string is not found.  Otherwise, you can call
// GetString on the returned index.
//
// nIndexStart defaults to -1 which means search from the beginning of the
// listbox or combobox.

inline int IconListBox::FindString(const char far *string, int nIndexStart) const
{
    return (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                _fCombo ? CB_FINDSTRING : LB_FINDSTRING, nIndexStart, (LPARAM)string);
}
inline int IconListBox::FindStringExact(const char far *string, int nIndexStart) const
{
    return (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                        _fCombo ? CB_FINDSTRINGEXACT : LB_FINDSTRINGEXACT,
                        nIndexStart, (LPARAM)string);
}

// GetCount - returns the current number of listbox entries

inline int IconListBox::GetCount()
{
    return (int) ::SendMessage(_hwndListBox,
                              _fCombo ? CB_GETCOUNT : LB_GETCOUNT, 0, 0);
}


// GetCurrentSelection - returns index or LB_ERR if no selection.
// This function is not useful for multi-select listboxen.

inline int IconListBox::GetCurrentSelection() const
{
    return (int) ::SendMessage(_hwndListBox,
                               _fCombo ? CB_GETCURSEL : LB_GETCURSEL, 0, 0);
}


// GetItemData - retrieve ICON id

inline int IconListBox::GetIconID(int nIndex) const
{
    return (int) ::SendMessage(_hwndListBox,
                     _fCombo ? CB_GETITEMDATA : LB_GETITEMDATA, nIndex, 0);
}


// GetSel - returns nonzero if nIndex is selected

inline BOOL IconListBox::GetSel(int nIndex)
{
    return (BOOL) ::SendMessage(_hwndListBox, LB_GETSEL, nIndex, 0);
}


// GetSelCount - returns number of selected entries in multi-select listbox

inline int IconListBox::GetSelCount() const
{
    return (int) ::SendMessage(_hwndListBox, LB_GETSELCOUNT, 0, 0);
}


// GetSelItems - places index of each selected item in array.  Returns
// LB_ERR if not multi-select listbox, otherwise number of items in array.

inline int IconListBox::GetSelItems(int cItems, int FAR *lpItems) const
{
    return (int)
        ::SendMessage(_hwndListBox, LB_GETSELITEMS, cItems, (LPARAM) lpItems);
}


// GetString - returns length of string returned or LB_ERR if nIndex invalid

inline int IconListBox::GetString(int nIndex, char far *string) const
{
    return (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                        _fCombo ? CB_GETLBTEXT : LB_GETTEXT, nIndex,
                        (LPARAM) ((LPSTR) string));
}


// InsertString - same returns as AddString

inline int IconListBox::InsertString(int nIcon, const char far *string, int nIndex)
{
    int nNewIndex =  (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                 _fCombo ? CB_INSERTSTRING : LB_INSERTSTRING,
                 (WPARAM) nIndex, (LPARAM) ((LPSTR) string));

    SetItemData(nNewIndex, nIcon);
	UpdateHorizontalExtent(nIcon,string);

    return(nNewIndex);
}


// SelectString
// nIndex specifies where to start searching (-1 means from top).
// string specifies the initial characters of the string to match.
// Function returns index or LB_ERR if string not found

inline int IconListBox::SelectString(int nIndex, const char far *string)
{
    return (int) ::SendMessage(_hwndListBox,
                              _fCombo ? CB_SELECTSTRING : LB_SELECTSTRING,
                               nIndex,(LRESULT)string);
}


// SetCurrentSelection -
// This function sets the current selection in a single-select style
// listbox.  It returns LB_ERR if an error occurs, or if nIndex is -1
// (the default) meaning no current selection.

inline int IconListBox::SetCurrentSelection(int nIndex) const
{
    return (int) ::SendMessage(_hwndListBox,
                        _fCombo ? CB_SETCURSEL : LB_SETCURSEL, nIndex, 0);
}


// SetItemData - used to store icon id, returns LB_ERR if error occurs
// Use GetIconID to retrieve this id later.

inline int IconListBox::SetItemData(int nIndex, int nData) const
{
    return (int) ::SendMessage(_hwndListBox,
                              _fCombo ? CB_SETITEMDATA : LB_SETITEMDATA,
                               nIndex, nData);
}


// SetRedraw - turn on (TRUE) or off (FALSE) visual updates

inline void IconListBox::SetRedraw(BOOL bRedraw) const
{
    ::SendMessage(_hwndListBox, WM_SETREDRAW, bRedraw, 0);
}


// SetSel - used in multiselect listboxen.  TRUE selects, FALSE deselects.
// bSelected defaults to TRUE.  nIndex == -1 means select all.

inline void IconListBox::SetSel(int nIndex, BOOL bSelected) const
{
    ::SendMessage(_hwndListBox, LB_SETSEL, bSelected, nIndex);
}


#endif  // _ICONLBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\npalloc.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* npalloc.h -- Definitions for new/delete functions.
 *
 * History:
 *	10/06/93	gregj	Created
 *	11/29/93	gregj	Added debug instrumentation
 */

#ifndef _INC_NPALLOC
#define _INC_NPALLOC

inline BOOL InitHeap(void)
{
	return TRUE;
}

#ifdef DEBUG

#ifndef _INC_NETLIB
#include <netlib.h>
#endif

class MEMWATCH
{
private:
	LPCSTR _lpszLabel;
	MemAllocInfo _info;

protected:
    BOOL   fStats;

public:
	MEMWATCH(LPCSTR lpszLabel);
	~MEMWATCH();
};

class MemLeak : MEMWATCH
{
public:
	MemLeak(LPCSTR lpszLabel);
	~MemLeak() {}
};

class MemOff 
{
private:
    LPVOID  pvContext;
public:
    MemOff();
    ~MemOff();
};
#endif

#ifdef DEBUG
#define MEMLEAK(d,t) MemLeak d ( t )
#define MEMOFF(d) MemOff d
#else
#define MEMLEAK(d,t)
#define MEMOFF(d)
#endif    

#endif	/* _INC_NPALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\npassert.h ===
/*****************************************************************/
/**             Microsoft Windows for Workgroups                **/
/**         Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/

/*
    npassert.h
    NP environment independent assertion/logging routines

    Usage:

        ASSERT(exp)     Evaluates its argument.  If "exp" evals to
                        FALSE, then the app will terminate, naming
                        the file name and line number of the assertion
                        in the source.

        UIASSERT(exp)   Synonym for ASSERT.

        ASSERTSZ(exp,sz) As ASSERT, except will also print the message
                        "sz" with the assertion message should it fail.

        REQUIRE(exp)    As ASSERT, except that its expression is still
                        evaluated in retail versions.  (Other versions
                        of ASSERT disappear completely in retail builds.)

        ANSI_ASSERTABLE(sz) Declares "sz" to be a string buffer which
                        can be used with the ASSERT_ANSI and ASSERT_OEM
                        macros (effectively declares a debug-only BOOL
                        associated with the string).

        ASSERT_ANSI(sz) Asserts that sz is in the ANSI character set.

        ASSERT_OEM(sz)  Asserts that sz is in the OEM character set.

        IS_ANSI(sz)     Declares that sz is in the ANSI character set
                        (e.g., if it's just come back from a GetWindowText).

        IS_OEM(sz)      Declares that sz is in the OEM character set.

        TO_ANSI(sz)     Does OemToAnsi in place.

        TO_OEM(sz)      Does AnsiToOem in place.

        COPY_TO_ANSI(src,dest)  Does OemToAnsi, not in place.

        COPY_TO_OEM(src,dest)   Does AnsiToOem, not in place.

        NOTE: the latter two, just like the APIs themselves, have the
        source first and destination second, opposite from strcpy().

    The ASSERT macros expect a symbol _FILENAME_DEFINED_ONCE, and will
    use the value of that symbol as the filename if found; otherwise,
    they will emit a new copy of the filename, using the ANSI C __FILE__
    macro.  A client sourcefile may therefore define __FILENAME_DEFINED_ONCE
    in order to minimize the DGROUP footprint of a number of ASSERTs.

    FILE HISTORY:
        Johnl   11/15/90    Converted from CAssert to general purpose
        Johnl   12/06/90    Changed _FAR_ to _far in _assert prototype
        beng    04/30/91    Made C-includable
        beng    08/05/91    Made assertions occupy less dgroup; withdrew
                            explicit heapchecking (which was crt
                            dependent anyway)
        beng    09/17/91    Removed additional consistency checks;
                            rewrote to minimize dgroup footprint,
                            check expression in-line
        beng    09/19/91    Fixed my own over-cleverness
        beng    09/25/91    Fixed bug in retail REQUIRE
        gregj   03/23/93    Ported to Chicago environment
        gregj   05/11/93    Added ANSI/OEM asserting routines
        gregj   05/25/93    Added COPY_TO_ANSI and COPY_TO_OEM
*/


#ifndef _NPASSERT_H_
#define _NPASSERT_H_

#if defined(__cplusplus)
extern "C"
{
#else
extern
#endif

VOID UIAssertHelper( const CHAR* pszFileName, UINT nLine );
VOID UIAssertSzHelper( const CHAR* pszMessage, const CHAR* pszFileName, UINT nLine );
extern const CHAR szShouldBeAnsi[];
extern const CHAR szShouldBeOEM[];

#if defined(__cplusplus)
}
#endif

#if defined(DEBUG)

# if defined(_FILENAME_DEFINED_ONCE)

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(_FILENAME_DEFINED_ONCE, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), _FILENAME_DEFINED_ONCE, __LINE__); }

# else

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), __FILE__, __LINE__); }

# endif

# define UIASSERT(exp)  ASSERT(exp)
# define REQUIRE(exp)   ASSERT(exp)

#define EXTERN_ANSI_ASSERTABLE(sz)  extern BOOL fAnsiIs##sz;
#define ANSI_ASSERTABLE(sz) BOOL fAnsiIs##sz=FALSE;
#define ASSERT_ANSI(sz)     ASSERTSZ(fAnsiIs##sz,szShouldBeAnsi)
#define ASSERT_OEM(sz)      ASSERTSZ(!fAnsiIs##sz,szShouldBeOEM)
#define IS_ANSI(sz)         fAnsiIs##sz = TRUE;
#define IS_OEM(sz)          fAnsiIs##sz = FALSE;
#define TO_ANSI(sz)         { ASSERT_OEM(sz); ::OemToAnsi(sz,sz); IS_ANSI(sz); }
#define TO_OEM(sz)          { ASSERT_ANSI(sz); ::AnsiToOem(sz,sz); IS_OEM(sz); }
#define COPY_TO_ANSI(s,d)   { ASSERT_OEM(s); ::OemToAnsi(s,d); IS_ANSI(d); }
#define COPY_TO_OEM(s,d)    { ASSERT_ANSI(s); ::AnsiToOem(s,d); IS_OEM(d); }

#else // !DEBUG

# define ASSERT(exp)        ;
# define UIASSERT(exp)      ;
# define ASSERTSZ(exp, sz)  ;
# define REQUIRE(exp)       { (exp); }

#define EXTERN_ANSI_ASSERTABLE(sz)  ;
#define ANSI_ASSERTABLE(sz) ;
#define ASSERT_ANSI(sz)     ;
#define ASSERT_OEM(sz)      ;
#define IS_ANSI(sz)         ;
#define IS_OEM(sz)          ;
#define TO_ANSI(sz)         ::OemToAnsi(sz,sz)
#define TO_OEM(sz)          ::AnsiToOem(sz,sz)
#define COPY_TO_ANSI(s,d)   ::OemToAnsi(s,d)
#define COPY_TO_OEM(s,d)    ::AnsiToOem(s,d)

#endif // DEBUG


// Debug mask APIs

// NOTE: You can #define your own DM_* values using bits in the HI BYTE

#define DM_TRACE    0x0001      // Trace messages
#define DM_WARNING  0x0002      // Warning
#define DM_ERROR    0x0004      // Error
#define DM_ASSERT   0x0008      // Assertions

#define	DM_LOG_FILE 0x0100
#define	DM_PREFIX 	0x0200


#if !defined(NetDebugMsg)

//
// DebugMsg(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//

#if defined(__cplusplus)
extern "C"
{
#else
extern
#endif

#define REGVAL_STR_DEBUGMASK	"DebugMask"

void __cdecl NetDebugMsg(UINT mask, LPCSTR psz, ...);

UINT WINAPI  NetSetDebugParameters(PSTR pszName,PSTR pszLogFile);
UINT WINAPI  NetSetDebugMask(UINT mask);
UINT WINAPI  NetGetDebugMask(void);

#if defined(__cplusplus)
}
#endif

#endif

#ifdef	DEBUG

#define Break() 		{_asm _emit 0xcc}
//#define	Trap()			{_asm {_emit 0xcc}}
//#define	TrapC(c)		{if(c) {Trap()}}

#define DPRINTF  NetDebugMsg

#else

#define Break()
#define	Trap()
#define	TrapC(c)

// Nb: Following definition is needed to avoid compiler complaining
// about empty function name in expression. In retail builds using this macro
// will cause string parameters not appear in executable
#define DPRINTF 	1?(void)0 : (void)

#endif

#endif // _NPASSERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\npcrit.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/* NPCRIT.H -- Definition of CRITSEC classes.
 *
 * History:
 *	gregj	11/01/93	Created
 *  lens    02/25/94    Modified to use CRITICAL_SECTIONs Reinitialize().
 *                      Took out spin-loop interlock.
 */

#ifndef _INC_CRITSEC
#define _INC_CRITSEC

#ifndef RC_INVOKED
#pragma pack(1)
#endif

extern "C"
{

/* extern DECLSPEC_IMPORT
VOID
WINAPI
ReinitializeCriticalSection(LPCRITICAL_SECTION lpcs); - in windefs.h */

extern DECLSPEC_IMPORT
VOID
WINAPI
UninitializeCriticalSection(LPCRITICAL_SECTION lpcs);

// codework: remove following and make MEMWATCH use critical sections.
#ifdef DEBUG
void WaitForInterlock(volatile BYTE *pByte);
void ReleaseInterlock(volatile BYTE *pByte);
#endif	/* DEBUG */

}

/*************************************************************************

    NAME:		CRITSEC

    SYNOPSIS:	Class wrapper for global critical section

    INTERFACE:	Init(pszName)
					Initializes the critical section.

				Term()
					Cleans up the critical section.

	PRIVATE:	Enter()
					Enter the critical section, waiting for others
					to leave if necessary.

				Leave()
					Leave the critical section, unblocking other waiters.

    PARENT:		None

    USES:		None

    CAVEATS:	This class is not initialized with its constructor because
				it should be instantiated at global scope, which introduces
				constructor-linker problems.  Instead, its fields should be
				initialized to all zeroes, and Init() should be called at
				process attach time.  Term() should be called at process
				detach.

    NOTES:		The class's initialization takes care of synchronizing
				itself to protect against multiple simultaneous inits.

    HISTORY:
		11/01/93	gregj	Created
        02/25/94    lens    Modified to use CRITICAL_SECTION directly.

**************************************************************************/

class CRITSEC
{
friend class TAKE_CRITSEC;

private:
	CRITICAL_SECTION _critsec;

public:
	void Enter() { ::EnterCriticalSection(&_critsec); }
	void Leave() { ::LeaveCriticalSection(&_critsec); }
#ifndef WINNT
	void Init() { ::ReinitializeCriticalSection(&_critsec); }
	void Term() { /* codework: add ::UninitializeCriticalSection(&_critsec); */}
#endif /* WINNT */
};


/*************************************************************************

    NAME:		TAKE_CRITSEC

    SYNOPSIS:	Class wrapper to take a critical section.

    INTERFACE:	TAKE_CRITSEC(critsec)
					Construct with the global CRITICAL_SECTION object to take.

				~TAKE_CRITSEC()
					Destructor automatically releases the critical section.

				Release()
					Releases the critical section manually.

				Take()
					Takes the critical section manually.

    PARENT:		None

    USES:		None

    CAVEATS:	None

    NOTES:		Instantiate one of these classes in a block of code
				when you want that block of code to be protected
				against re-entrancy.
                The Take() and Release() functions should rarely be necessary,
                and must be used in matched pairs with Release() called first.

    HISTORY:
		11/01/93	gregj	Created

**************************************************************************/

class TAKE_CRITSEC
{
private:
	CRITSEC & const _critsec;

public:
	void Take(void) { _critsec.Enter(); }
	void Release(void) { _critsec.Leave(); }
	TAKE_CRITSEC(CRITSEC& critsec) : _critsec(critsec) { Take(); }
	~TAKE_CRITSEC() { Release(); }
};


/*************************************************************************

    NAME:		TAKE_MUTEX

    SYNOPSIS:	Class wrapper to take a mutex.

    INTERFACE:	TAKE_MUTEX(hMutex)
					Construct with the mutex handle to take.

				~TAKE_MUTEX()
					Destructor automatically releases the mutex.

				Release()
					Releases the mutex manually.

				Take()
					Takes the mutex manually.

    PARENT:		None

    USES:		None

    CAVEATS:	None

    NOTES:		Instantiate one of these classes in a block of code
				when you want that block of code to be protected
				against re-entrancy.
                The Take() and Release() functions should rarely be necessary,
                and must be used in matched pairs with Release() called first.

    HISTORY:
		09/27/94	lens	Created

**************************************************************************/

class TAKE_MUTEX
{
private:
	HANDLE const _hMutex;

public:
	void Take(void) { WaitForSingleObject(_hMutex, INFINITE); }
	void Release(void) { ReleaseMutex(_hMutex); }
	TAKE_MUTEX(HANDLE hMutex) : _hMutex(hMutex) { Take(); }
	~TAKE_MUTEX() { Release(); }
};

#ifndef RC_INVOKED
#pragma pack()
#endif

#endif	/* _INC_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\netspi.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

/* NETSPI.H -- Network service provider interface definitions.
 */

#ifndef _INC_NETSPI
#define _INC_NETSPI

#ifndef _WINNETWK_
#include <winnetwk.h>
#endif

#ifndef _INC_NETMPR_
#include <netmpr.h>
#endif

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// Capability masks and values.
//

#define WNNC_SPEC_VERSION   0x01
#define     WNNC_SPEC_VERSION51 0x00050001

#define WNNC_NET_TYPE       0x02
// Net types defined in Winnetwk.h

#define WNNC_DRIVER_VERSION 0x03

#define WNNC_USER           0x04
#define     WNNC_USR_GETUSER    0x01

#define WNNC_CONNECTION     0x06
#define     WNNC_CON_ADDCONNECTION      0x01
#define     WNNC_CON_CANCELCONNECTION   0x02
#define     WNNC_CON_GETCONNECTIONS     0x04
#define     WNNC_CON_GETPERFORMANCE     0x08
#define     WNNC_CON_GETUNIVERSALNAME   0x10
#define     WNNC_CON_FORMATCONNECTION   0x20

#define WNNC_DIALOG         0x08
#define     WNNC_DLG_FORMATNETWORKNAME  0x080
#define     WNNC_DLG_GETRESOURCEPARENT  0x100
#define     WNNC_DLG_GETRESOURCEINFORMATION  0x800

#define WNNC_ERROR          0x0A
#define  WNNC_ERR_GETERROR              0x01
#define  WNNC_ERR_GETERRORTEXT          0x02

#define WNNC_ENUMERATION    0x0B
#define     WNNC_ENUM_GLOBAL    0x01
#define     WNNC_ENUM_LOCAL     0x02
#define     WNNC_ENUM_CONTEXT   0x04

#define WNNC_START          0x0C
#define     WNNC_START_WONT     0x00
#define     WNNC_START_UNKNOWN  0xFFFFFFFF
#define     WNNC_START_DONE     0x01
#define     WNNC_START_INACTIVE 0xFFFFFFFE

#define WNNC_RESOURCE       0x0D
#define     WNNC_RES_VALIDLOCALDEVICE   0x80

#define WNNC_AUTHENTICATION 0x0E
#define     WNNC_AUTH_LOGON             0x02
#define     WNNC_AUTH_LOGOFF            0x04
#define		WNNC_AUTH_GETHOMEDIRECTORY	0x10
#define		WNNC_AUTH_GETPOLICYPATH		0x20

#define WNNC_MAXCAPNO WNNC_AUTHENTICATION

//
// Profile strings.
//
#define NPProvider      "NPProvider"
#define NPName          "NPName"
#define NPDescription   "NPDescription"
#define NPID            "NPID"

//
// Various defines.
//
//Spec version
#define WNNC_DRIVER_MAJOR1  1  
#define WNNC_DRIVER_MINOR1  1
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)

//
// NP SPI Definitions.
//

#define SPIENTRY DWORD WINAPI

typedef SPIENTRY F_NPGetCaps(
    DWORD nIndex
    );

F_NPGetCaps NPGetCaps;
typedef F_NPGetCaps FAR *PF_NPGetCaps;

typedef SPIENTRY F_NPGetUniversalName(
	LPTSTR  lpLocalPath,
	DWORD   dwInfoLevel,
	LPVOID  lpBuffer,
	LPDWORD lpBufferSize
    );

F_NPGetUniversalName NPGetUniversalName;
typedef F_NPGetUniversalName FAR *PF_NPGetUniversalName;

typedef SPIENTRY F_NPGetUser(
    LPTSTR  lpName,
    LPTSTR  lpAuthenticationID,
    LPDWORD lpBufferSize
    );

F_NPGetUser NPGetUser;
typedef F_NPGetUser FAR *PF_NPGetUser;

typedef SPIENTRY F_NPValidLocalDevice(
    DWORD dwType,
    DWORD dwNumber
    );

F_NPValidLocalDevice NPValidLocalDevice;
typedef F_NPValidLocalDevice FAR *PF_NPValidLocalDevice;

typedef SPIENTRY F_NPAddConnection(
    HWND hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword,
    LPTSTR lpUserID,
    DWORD dwFlags,
	LPTSTR lpAccessName,
	LPDWORD lpBufferSize,
	LPDWORD lpResult
    );

F_NPAddConnection NPAddConnection;
typedef F_NPAddConnection FAR *PF_NPAddConnection;

typedef SPIENTRY F_NPCancelConnection(
    LPTSTR lpName,
    BOOL fForce,
 	DWORD dwFlags
    );

F_NPCancelConnection NPCancelConnection;
typedef F_NPCancelConnection FAR *PF_NPCancelConnection;

typedef SPIENTRY F_NPGetConnection(
    LPTSTR lpLocalName,
    LPTSTR lpRemoteName,
    LPDWORD lpBufferSize
    );

F_NPGetConnection NPGetConnection;
typedef F_NPGetConnection FAR *PF_NPGetConnection;

typedef SPIENTRY F_NPGetConnectionPerformance(
    LPTSTR lpRemoteName, 
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );

F_NPGetConnectionPerformance NPGetConnectionPerformance;
typedef F_NPGetConnectionPerformance FAR *PF_NPGetConnectionPerformance;

typedef SPIENTRY F_NPFormatNetworkName(
    LPTSTR lpRemoteName,
    LPTSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    );

F_NPFormatNetworkName NPFormatNetworkName;
typedef F_NPFormatNetworkName FAR *PF_NPFormatNetworkName;

typedef DWORD (FAR PASCAL *NPDISPLAYCALLBACK)(
    LPVOID  lpUserData,
    DWORD   dwDisplayType,
    LPTSTR  lpszHeaders
    );

typedef SPIENTRY F_NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCE lpNetResource,
    LPHANDLE lphEnum
    );

F_NPOpenEnum NPOpenEnum;
typedef F_NPOpenEnum FAR *PF_NPOpenEnum;

typedef SPIENTRY F_NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbFree
    );

F_NPEnumResource NPEnumResource;
typedef F_NPEnumResource FAR *PF_NPEnumResource;

typedef SPIENTRY F_NPCloseEnum(
    HANDLE hEnum
    );

F_NPCloseEnum NPCloseEnum;
typedef F_NPCloseEnum FAR *PF_NPCloseEnum;

typedef SPIENTRY F_NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    );

F_NPGetResourceParent NPGetResourceParent;
typedef F_NPGetResourceParent FAR *PF_NPGetResourceParent;

typedef SPIENTRY F_NPGetResourceInformation(
	LPNETRESOURCE lpNetResource,
	LPVOID lpBuffer,
	LPDWORD cbBuffer,
	LPSTR *lplpSystem
    );

F_NPGetResourceInformation NPGetResourceInformation;
typedef F_NPGetResourceInformation FAR *PF_NPGetResourceInformation;

typedef struct _LOGONINFO {
    LPTSTR lpUsername;
    LPTSTR lpPassword;
	DWORD cbUsername;
	DWORD cbPassword;
} LOGONINFO, FAR *LPLOGONINFO;

typedef SPIENTRY F_NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    );

F_NPLogon NPLogon;
typedef F_NPLogon FAR *PF_NPLogon;

typedef SPIENTRY F_NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    );

F_NPLogoff NPLogoff;
typedef F_NPLogoff FAR *PF_NPLogoff;

typedef SPIENTRY F_NPChangePassword(
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
	DWORD		dwAction
	);

F_NPChangePassword NPChangePassword;
typedef F_NPChangePassword FAR *PF_NPChangePassword;

typedef SPIENTRY F_NPChangePasswordHwnd(
	HWND hwndOwner
	);

F_NPChangePasswordHwnd NPChangePasswordHwnd;
typedef F_NPChangePasswordHwnd FAR *PF_NPChangePasswordHwnd;


typedef SPIENTRY F_NPGetPasswordStatus(
	DWORD		nIndex
	);

F_NPGetPasswordStatus NPGetPasswordStatus;
typedef F_NPGetPasswordStatus FAR *PF_NPGetPasswordStatus;


typedef SPIENTRY F_NPGetHomeDirectory(
    LPTSTR lpDirectory,
    LPDWORD lpBufferSize
    );

F_NPGetHomeDirectory NPGetHomeDirectory;
typedef F_NPGetHomeDirectory FAR *PF_NPGetHomeDirectory;

typedef SPIENTRY F_NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
	DWORD dwFlags
    );

// flags for NPGetPolicyPath
#define GPP_LOADBALANCE	0x0001

F_NPGetPolicyPath NPGetPolicyPath;
typedef F_NPGetPolicyPath FAR *PF_NPGetPolicyPath;

//
// MPR Services.
//

#define NPSGetProviderHandle NPSGetProviderHandleA
#define NPSGetProviderName NPSGetProviderNameA
#define NPSGetSectionName NPSGetSectionNameA
#define NPSSetExtendedError NPSSetExtendedErrorA
#define NPSSetCustomText NPSSetCustomTextA
#define NPSCopyString NPSCopyStringA
#define NPSDeviceGetNumber NPSDeviceGetNumberA
#define NPSDeviceGetString NPSDeviceGetStringA
#define NPSNotifyRegister NPSNotifyRegisterA
#define NPSNotifyGetContext NPSNotifyGetContextA
#define NPSAuthenticationDialog NPSAuthenticationDialogA

#define NPSERVICE	WINAPI
#define HPROVIDER   LPVOID
typedef HPROVIDER FAR * PHPROVIDER;

typedef struct {
    DWORD  cbStructure;       /* size of this structure in bytes */
    HWND   hwndOwner;         /* owner window for the authentication dialog */
    LPCSTR lpResource;        /* remote name of resource being accessed */
    LPSTR  lpUsername;        /* default username to show, NULL to hide field */
    DWORD  cbUsername;        /* size of lpUsername buffer, set to length copied on exit */
    LPSTR  lpPassword;        /* default password to show */
    DWORD  cbPassword;        /* size of lpPassword buffer, set to length copied on exit */
    LPSTR  lpOrgUnit;         /* default org unit to show, NULL to hide field */
    DWORD  cbOrgUnit;         /* size of lpOrgUnit buffer, set to length copied on exit */
    LPCSTR lpOUTitle;         /* title of org unit field, NULL for default title */
    LPCSTR lpExplainText;     /* explanatory text at top, NULL for default text */
    LPCSTR lpDefaultUserName; /* explanatory text at top, NULL for default text */
    DWORD  dwFlags;           /* flags (see below) */
} AUTHDLGSTRUCTA, FAR *LPAUTHDLGSTRUCTA;
#define AUTHDLGSTRUCT AUTHDLGSTRUCTA
#define LPAUTHDLGSTRUCT LPAUTHDLGSTRUCTA

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

DWORD
NPSERVICE
NPSAuthenticationDialog(
    LPAUTHDLGSTRUCT lpAuthDlgStruct
    );

DWORD
NPSERVICE
NPSGetProviderHandle( 
	PHPROVIDER phProvider
	);

DWORD
NPSERVICE
NPSGetProviderName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszProviderName
	);

DWORD
NPSERVICE
NPSGetSectionName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszSectionName
	);

DWORD
NPSERVICE NPSSetExtendedError (
	DWORD NetSpecificError,
	LPSTR lpExtendedErrorText 
    );

VOID
NPSERVICE NPSSetCustomText (
	LPSTR lpCustomErrorText 
    );

DWORD
NPSERVICE
NPSCopyString (
    LPCTSTR lpString,
    LPVOID  lpBuffer,
    LPDWORD lpdwBufferSize
    );

DWORD
NPSERVICE
NPSDeviceGetNumber (
    LPTSTR  lpLocalName,
    LPDWORD lpdwNumber,
    LPDWORD lpdwType
    );

DWORD
NPSERVICE
NPSDeviceGetString (
    DWORD   dwNumber,
    DWORD   dwType,
    LPTSTR  lpLocalName,
    LPDWORD lpdwBufferSize
    );

// Notification Service.

enum NOTIFYTYPE { NotifyAddConnection, 
                  NotifyCancelConnection, 
                  NotifyGetConnectionPerformance };

#define NOTIFY_PRE              0x00
#define NOTIFY_POST             0x01

typedef struct _NOTIFYINFO {
    DWORD cbStructure;          /* size of NOTIFYINFO */
    DWORD  dwNotifyStatus;      /* Pre/post notification status */
    DWORD  dwOperationStatus;   /* Status of operation */
    LPVOID lpNPContext;         /* NP context */
} NOTIFYINFO, FAR *LPNOTIFYINFO;

typedef struct _NOTIFYADD {
    DWORD cbStructure;          /* size of NOTIFYADD */
    HWND hwndOwner;             /* hWnd for UI */
    NETRESOURCE NetResource;    /* Resource to add */
    DWORD dwAddFlags;           /* Add flags */
    LPTSTR lpAccessName;        /* System name for connection */
    LPDWORD lpBufferSize;       /* Size of AccessName buffer */
    DWORD dwResult;             /* Info about connection */
    DWORD dwAddContext;         /* Context of add connection */
} NOTIFYADD, FAR *LPNOTIFYADD;

#define CONNECT_CTXT_RESTORE        0x00000001
#define CONNECT_CTXT_GLOBAL         0x00000002
#define CONNECT_CTXT_PROVIDER       0x00000004
#define CONNECT_CTXT_SINGLE         0x00000008

typedef struct _NOTIFYCANCEL {
    DWORD cbStructure;          /* size of NOTIFYCANCEL */
    LPTSTR lpName;              /* Local device name or remote name of resource */
    LPTSTR lpProvider;          /* Provider name of resource cancelled */
    DWORD dwFlags;              /* Cancel flags */
    BOOL fForce;                /* Cancel force */
} NOTIFYCANCEL, FAR *LPNOTIFYCANCEL;

typedef struct _NOTIFYPERFORMANCE {
	DWORD cbStructure;          /* size of NOTIFYPERFORMANCE */
	LPTSTR lpRemoteName;        /* network resource name */
	LPTSTR lpProviderName;      /* provider to try/provider that responded */
	LPNETCONNECTINFOSTRUCT lpNetConnectInfo; /* performance information requested/returned */
} NOTIFYPERFORMANCE, FAR *LPNOTIFYPERFORMANCE;

typedef DWORD (FAR PASCAL *NOTIFYCALLBACK)( LPNOTIFYINFO lpNotifyInfo, LPVOID lpOperationInfo );

DWORD
NPSERVICE
NPSNotifyRegister(
    enum NOTIFYTYPE NotifyType,
    NOTIFYCALLBACK P_FNotifyCallBack
    );

LPVOID
NPSERVICE
NPSNotifyGetContext (
    NOTIFYCALLBACK P_FNotifyCallBack
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_NETSPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\npdefs.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NPCOMMON.H -- Internal standard header for network provider common library.
 *
 * ATTENTION: This file is used by 16bit components and should be
 *			  maintained as such.
 *
 * History:
 *  03/22/93    gregj   Created
 *  04/02/93    lens    Added _INC_NPDEFS define and _INC_WINDOWS test.
 *
 */
#ifndef _INC_NPDEFS
#define _INC_NPDEFS

#ifndef RC_INVOKED
#pragma warning(disable:4147)       // warning about ignoring __loadds on function
                                    // ptr decls, of which there are 5 in windows.h
#pragma warning(disable:4118)       // warning about not accepting the intrinsic function pragma
                                    // during a fast compile

// Macro to quiet compiler for an unused formal parameter.
#define UNUSED(x) ((void)(x))
#endif

#ifndef _INC_WINDOWS
#include <windows.h>
#endif

#ifdef IS_32
#ifndef _INC_NETSPI
#include <netspi.h>
#endif

#ifndef _STRING_HXX_
#include <npstring.h>
#endif
#endif  /* IS_32 */

// Fixup for when RESOURCETYPE_ANY was not compatible with NT.
// Codework: remove from system.
#define RESOURCETYPE_ANY1 RESOURCETYPE_RESERVED

#define CHAR char
#define INT int

typedef unsigned short WCHAR;
typedef unsigned short USHORT;
typedef WORD HANDLE16;

#ifndef APIENTRY
#define APIENTRY    FAR PASCAL
#endif

#define FAR_NETLIB              /* our netlib is in netapi.dll, and always far */

#ifndef IS_32
#ifndef LOADDS
#define LOADDS __loadds
#endif
#else
#define LOADDS
#endif

#ifndef HNRES
typedef HANDLE HNRES;
#endif


// That is common return type used in both common and mnr projects
#ifndef MNRSTATUS
#ifdef IS_32
#define MNRSTATUS UINT
#else
#define MNRSTATUS WORD
#endif
#endif

#define MNRENTRY DWORD APIENTRY

// Find size of structure upto and including a field that may be the last field in the structure.
#define SIZE_TO_FIELD(s,f) (sizeof(((s *)NULL)->f) + (LPBYTE)&(((s *)NULL)->f) - (LPBYTE)NULL)

// Null strings are quite often taken to be either a NULL pointer or a zero
#define IS_EMPTY_STRING(pch) ( !pch || !*(pch) )

/*******************************************************************

Macro Description:

    This macro is used to test that a LoadLibrary call succeeded.

Arguments:

    hModule          - the handle returned from the LoadLibrary call.

Notes:

    Win31 documentation says that errors are less than HINSTANCE_ERROR
    and that success is greater than 32. Since HINSTANCE_ERROR is 32,
    this leaves the value of 32 as being undefined!

*******************************************************************/

#ifdef IS_32
#define MNRVALIDDLLHANDLE(hdll) (hdll != NULL)
#else
#define MNRVALIDDLLHANDLE(hdll) (hdll > HINSTANCE_ERROR)
#endif

/*******************************************************************

Macro Description:

    This macro is used to determine if a buffer passed in has valid 
    addresses and writeable memory.

Arguments:

    lpBuffer	- the address of the buffer.

    lpcbBuffer	- the address of a DWORD containing the size of the
				  buffer that is filled in on return with the 
				  required size of the buffer if the buffer
				  is not large enough.

Evalutes to:

	An expression that returns TRUE or FALSE.

Notes:

	Only valid for Win32 applications to call.
    The macro does weak validation as it is used generically in many APIs.
	In particular, this means that the macro succeeds a NULL lpcbBuffer, 
    and zero *lpcbBuffer. In neither of these cases does it validate
	that lpBuffer is a valid address (and relies upon the behavior of 
    IsBadWritePtr when *lpcbBuffer is zero).

*******************************************************************/

#define IS_BAD_WRITE_BUFFER(lpBuffer,lpcbBuffer) \
((lpcbBuffer != NULL) && \
 (IsBadWritePtr(lpcbBuffer, sizeof(DWORD)) || \
  IsBadWritePtr(lpBuffer, *lpcbBuffer))) 

#ifdef IS_32
extern "C" { /* Know we're using C++ internally */

NLS_STR FAR * NPSERVICE NPSGetStatusText(DWORD dwError, 
										 LPBOOL pbStatic);

DWORD NPSERVICE NPSCopyNLS(NLS_STR FAR *pnlsSourceString, 
						   LPVOID lpDestBuffer, 
						   LPDWORD lpBufferSize);

}
#endif  /* IS_32 */

#endif  /* !_INC_NPDEFS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\npmsg.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* NPMSG.H -- Definition of MsgBox subroutine.
 *
 * History:
 *	05/06/93	gregj	Created
 *	10/07/93	gregj	Added DisplayGenericError.
 */

#ifndef _INC_NPMSG
#define _INC_NPMSG

class NLS_STR;			/* forward declaration */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#define	IDS_MSGTITLE	1024

extern int MsgBox( HWND hwndDlg, UINT idMsg, UINT wFlags, const NLS_STR **apnls = NULL );
extern UINT DisplayGenericError(HWND hwnd, UINT msg, UINT err, LPCSTR psz1, LPCSTR psz2, WORD wFlags, UINT nMsgBase);


#ifndef RC_INVOKED
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif	/* _INC_NPMSG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\npstubx.h ===
#define szNPSTUBClassName "WndClass_NPSTUBMonitor"
#define WM_NPSTUB_LOADDLL (WM_USER)
#define WM_NPSTUB_UNLOADDLL (WM_USER + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\sched.h ===
/*****************************************************************/
/**				 MPR Client/Server DLL Header File				**/
/**		      	Copyright (C) Microsoft Corp., 1994				**/
/*****************************************************************/ 

/* SCHED.H -- Header file for miscellaneous common scheduling primitives.
 *
 * History:
 *	gregj	10/17/94	created
 */


#ifndef _INC_SCHED
#define _INC_SCHED

#ifndef RC_INVOKED
#ifdef __cplusplus
extern "C" {
#endif

/* WaitAndYield processes all input messages.  WaitAndProcessSends only
 * processes SendMessages.
 *
 * WaitAndYield takes an optional parameter which is the ID of another
 * thread concerned with the waiting.  If it's not NULL, WM_QUIT messages
 * will be posted to that thread's queue when they are seen in the message
 * loop.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout, volatile DWORD *pidOtherThread = NULL);
DWORD WaitAndProcessSends(HANDLE hObject, DWORD dwTimeout);

#ifdef __cplusplus
};	/* extern "C" */
#endif

#endif	/* RC_INVOKED */

#endif	/* _INC_SCHED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\regentry.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991-1994                    **/
/***************************************************************************/


/****************************************************************************

regentry.h

Mar. 94		JimH
Mar. 94     LenS    Added NLS_STR form of GetStringValue
Mar. 94     LenS    Added MoveToSubKey
Mar. 94     LenS    Added RegEnumValues class
Mar. 94     LenS    Added NPMachineEntries class

hard tabs at 4

Wrapper for registry access


Construct a RegEntry object by specifying the subkey (under
HKEY_CURRENT_USER by default, but can be overridden.)

All member functions are inline so there is minimal overhead.

All member functions (except the destructor) set an internal
error state which can be retrieved with GetError().
Zero indicates no error.

RegEntry works only with strings and DWORDS which are both set
using the overloaded function SetValue()

	SetValue("valuename", "string");
	SetValue("valuename", 42);
	
Values are retrieved with GetString() and GetNumber().  GetNumber()
allows you to specificy a default if the valuename doesn't exist.

DeleteValue() removes the valuename and value pair.

****************************************************************************/

#ifndef	REGENTRY_INC
#define	REGENTRY_INC

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <npstring.h>


class RegEntry
{
	public:
		RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
		~RegEntry();
		
		long	GetError()	{ return _error; }
		long	SetValue(const char *pszValue, const char *string);
		long	SetValue(const char *pszValue, unsigned long dwNumber);
		char *	GetString(const char *pszValue, char *string, unsigned long length);
		VOID    GetValue(const char *pszValueName, NLS_STR *pnlsString);
		long	GetNumber(const char *pszValue, long dwDefault = 0);
		long	DeleteValue(const char *pszValue);
		long	FlushKey();
        VOID    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

	private:
		HKEY	_hkey;
		long	_error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
	public:
		RegEnumValues(RegEntry *pRegEntry);
		~RegEnumValues();
		long	Next();
		char *	GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}

	private:
        RegEntry * pRegEntry;
		DWORD   iEnum;
        DWORD   cEntries;
		CHAR *  pchName;
		LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

class NPMachineEntries : public RegEntry
{
    public:
		NPMachineEntries(const char *pszSectionName);
        const char * GetSectionName() { return pszSectionName; }

    private:
        const char * pszSectionName; // Warning: data not copied into object.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\inc\npstring.h ===
/*****************************************************************/ 
/**                  Microsoft Windows for Workgroups                **/
/**              Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/ 

/*
    npstring.h
    String classes: definition

    This file contains the basic string classes for the Thor UI.
    Its requirements are:

        - provide a modestly object-oriented interface to string
          manipulation, the better to work with the rest of our code;

        - encapsulate NLS and DBCS support as much as possible;

        - ensure that apps get correct form of library support,
          particularly with possible interference from intrinsics;

    The current solution consists of two classes: NLS_STR, and ISTR.

    class NLS_STR:      use wherever NLS/DBCS support is needed.
                      Most strings (in the UI, anyway) should be
                      of this class.

    class ISTR:      Indexes an NLS_STR in a DBCS safe manner.  All
                  positioning within an NLS_STR is done with ISTRs

    The class hierarchy looks like:

        BASE
            NLS_STR
                RESOURCE_STR
        ISTR

    This file also contains the STACK_NLS_STR macro and the
    strcpy( CHAR *, const NLS_STR& ) prototype.

    FILE HISTORY:
        beng        10/21/90        Created from email memo of last week
        johnl        11/13/90        Removed references to EB_STRING
        johnl        11/28/90        Release fully functional version
        johnl        12/07/90        Numerous revisions after code review
                                    (Removed SZ_STR, ISTR must associate
                                    w/a string upon decl etc.)
        beng        02/05/91        Replaced PCH with CHAR * for
                                    const-placement
        beng        04/26/91        Expunged of CB, IB types; relocated
                                    inline functions to string/strmisc.cxx
        beng        07/23/91        Added more *_STR types
        gregj        03/22/93        Ported to Chicago environment.
        gregj        03/25/93        Added Party(), DonePartying()
        gregj        03/30/93        Allow assigning NLS_STR to ISTR
        gregj        04/02/93        Added NLS_STR::IsDBCSLeadByte()
        gregj        04/02/93        Added ISTR::operator int
        gregj        04/08/93        Added NLS_STR::strncpy()
        gregj        04/08/93        Added NLS_STR::GetPrivateProfileString()
*/

#define WIN31    /* for certain string and NETLIB stuff */

#ifndef _BASE_HXX_
#include "base.h"
#endif

#ifndef _STRING_HXX_
#define _STRING_HXX_

extern HINSTANCE hInstance;        // for NLS_STR::LoadString

// String class doesn't allocate or deallocate memory
// for STR_OWNERALLOC strings
//
#define STR_OWNERALLOC         0x8000

// Same as owner alloc only the string is initialized with the null string.
//
#define STR_OWNERALLOC_CLEAR 0x8001

// Maximum resource string size, owner alloced strings must be at least
// MAX_RES_STR_LEN, otherwise an error will occur.
//
#define MAX_RES_STR_LEN    255


// The maximum number of insert parameters the InsertParams method can
// handle
//
#define MAX_INSERT_PARAMS    9


/*************************************************************************

    NAME:    ISTR

    SYNOPSIS:    String index object, used in conjunction with NLS_STR

    INTERFACE:
        ISTR()    - this ISTR gets associated with
                  the passed string and can only be used
                  on this string (NOTE:  on non-debug
                  versions this turns into a nop, can still
                  be useful for decl. clarity however).

        ISTR()    - Initialize to passed ISTR;
                  this ISTR will be associated with
                  the same string that the passed ISTR
                  is associated with.

        operator=()   - Copy passed ISTR (see prev.)

        operator=()   - Associate ISTR with a new NLS_STR.

        operator-()   - Returns CB diff. between *this & Param.
                        (must both belong to the same string)

        operator++()  - Advance the ISTR to the next logical
                        character (use only where absolutely
                        necessary).  Stops at end of string

        operator+=()  - Advance the ISTR to the ith logical
                        character (call operator++ i times)
                        Stops at end of string.

        operator==()  - Returns TRUE if the two ISTRs point to
                        the same position in the string (causes
                        an assertion failure if the two ISTRs
                        don't point to the same string).

        operator>()   - Returns true of *this is greater then
                        the passed ISTR (i.e., further along
                        in the string).

        operator<()   - Same as operator>, only less then.

        Reset()       - Resets ISTR to beginning of string and
                        updates the ISTR version number with the
                        string's current version number

    private:
        QueryIB()     - Returns the index in bytes
        QueryPNLS()   - Returns the pointer to the NLS_STR this ISTR
                        references
        SetPNLS()     - Sets the pointer to point to the NLS_STR
                        this ISTR references

    DEBUG ONLY:
        QueryVersion()     - Gets the version number of
                           the string this ISTR is associated with
        SetVersion()     - Sets the version number of this ISTR.

    USES:

    CAVEATS:    Each NLS_STR has a version number associated with it.  When
                an operation is performed that modifies the string, the
                version number is updated.  It is invalid to use an ISTR
                after its associated NLS_STR has been modified (can use
                Reset to resync it with the NLS_STR, the index gets reset
                to zero).

                You must associate an NLS_STR with an ISTR at the
                declaration of the ISTR.

    NOTES:        The version checking and string association checking goes
                away in the non-debug version.

    HISTORY:
        johnl        11/16/90        Created
        johnl        12/07/90        Modified after code review
        gregj        03/30/93        Allow assigning NLS_STR to ISTR

**************************************************************************/

class ISTR
{
friend class NLS_STR;

public:
    ISTR( const ISTR& istr );
    ISTR( const NLS_STR& nls );
    ISTR& operator=( const ISTR& istr );
    ISTR& operator=( const NLS_STR& nls );

    INT operator-( const ISTR& istr ) const;

    ISTR& operator++();
    VOID operator+=( INT iChars );

    BOOL operator==( const ISTR& istr ) const;
    BOOL operator>( const ISTR& istr )  const;
    BOOL operator<( const ISTR& istr )  const;

    operator INT() const { return QueryIB(); }

    VOID Reset();

private:
    INT _ibString;        // Index (in bytes) into an NLS_STR
    NLS_STR *_pnls;        // Pointer to "owner" NLS

    INT QueryIB() const
        { return _ibString; }
    VOID SetIB( INT ib )
        { _ibString = ib; }

    const NLS_STR* QueryPNLS() const
        { return _pnls; }
    VOID SetPNLS( const NLS_STR * pnls )
        { _pnls = (NLS_STR*)pnls; }

#ifdef DEBUG
    // Version number of NLS_STR this ISTR is associated with
    //
    USHORT _usVersion;

    USHORT QueryVersion() const { return _usVersion; }
    VOID SetVersion( USHORT usVers ) { _usVersion = usVers; }
#endif
};


/*************************************************************************

    NAME:        NLS_STR (nls)

    SYNOPSIS:    Provide a better string abstraction than the standard ASCIIZ
                representation offered by C (and C++).  The abstraction is
                better mainly because it handles double-byte characters
                (DBCS) in the string and makes intelligent use of operator
                overloading.

    INTERFACE:    NLS_STR()        Construct a NLS_STR (initialized to a CHAR *,
                                NLS_STR or NULL).  Reports errors via BASE.

                ~NLS_STR()        Destructor

                operator=()        Assign one NLS_STR (or CHAR *) value
                                to another (old string is deleted, new
                                string is allocated and copies source)

                operator+=()    Concatenate with assignment (equivalent to
                                strcat - see strcat).

                operator==()    Compare two NLS_STRs for equality

                operator!=()    Compare two NLS_STRs for inequality

                QueryPch()        Access operator, returning a "char *"
                                aliased to the string.  DO NOT MODIFY
                                THE STRING USING THIS METHOD (or pass
                                it to procedures that might modify it).
                                Synonym: operator const CHAR *().

                operator[]()    Same as QueryPch, except the string
                                is offset by ISTR characters

                IsDBCSLeadByte()    Returns whether a byte is a lead byte,
                                according to the ANSI- or OEM-ness of the
                                string.

        C-runtime-style methods.

                strlen()        Return the length of the string in bytes,
                                less terminator.  Provided only for crt
                                compatibility; please use a Query method
                                if possible.

                strcat()        Append an NLS_STR.  Will cause *this to be
                                reallocated if the appended string is larger
                                then this->QueryCb() and this is not an
                                STR_OWNERALLOC string

                strncpy()        Copy a non-null-terminated string into an
                                NLS_STR.  DBCS-safe.  For similar functionality
                                with an NLS_STR as the source, use the sub-
                                string members.

                strcmp()        Compare two NLS_STRs
                stricmp()        "
                strncmp()        Compare a portion of two NLS_STRs
                strnicmp()        "

                strcspn()        Find first char in *this that is
                                a char in arg
                strspn()        Find first char in *this that is
                                not a char in arg

                strtok()        Returns a token from the string

                strstr()        Search for a NLS_STR.

                strchr()        Search for a CHAR from beginning.
                                Returns offset.
                strrchr()        Search for a CHAR from end.
                strupr()        Convert NLS_STR to upper case.
                atoi()            Returns integer numeric value
                atol()            Returns long value

                realloc()        Resize string preserving its contents

        Other methods.

                QueryAllocSize()    Returns total # of bytes allocated (i.e.,
                                    number new was called with, or size of
                                    memory block if STR_OWNERALLOC
                IsOwnerAlloc()        Returns TRUE if this string is an owner
                                    allocated string
                QuerySubStr()        Return a substring
                InsertStr()            Insert a NLS_STR at given index.
                DelSubStr()            Delete a substring
                ReplSubStr()        Replace a substring (given start and
                                    NLS_STR)

                InsertParams()        Replace %1-%9 params in *this with the
                                    corresponding NLS_STRs contained in the
                                    array of pointers

                LoadString()        Load the string associated with the passed
                                    resource into *this (OWNER_ALLOC strings must
                                    be at least MAX_RES_STR_LEN).  Optionally
                                    calls InsertParams with a passed array of
                                    nls pointers.

                GetPrivateProfileString()    Loads a string from an INI file.

                Reset()                After an operation fails (due to memory
                                    failure), it is invalid to use the string
                                    until Reset has been called.  If the object
                                    wasn't successfully constructed, Reset will
                                    fail.

                QueryTextLength()    Returns the number of CHARS, less
                                    terminator.

                QueryTextSize()        Returns the number of bytes, including
                                    terminator.  Denotes amount of storage
                                    needed to dup string into a bytevector.

                QueryNumChar()        Returns total number of logical characters
                                    within the string.  Rarely needed.

                Append()            Appends a string to the current string,
                                    like strcat.
                AppendChar()        Appends a single character.

                Compare()            As strcmp().

                CopyFrom()            As operator=(), but returns an APIERR.

                ToOEM()                Convert string to OEM character set.

                ToAnsi()            Convert string to ANSI character set.

                Party()                Obtain read-write access to the buffer.
                DonePartying()        Release read-write access.

    PARENT:    BASE

    USES:    ISTR

    CAVEATS:    A NLS_STR object can enter an error state for various
                reasons - typically a memory allocation failure.  Using
                an object in such a state is theoretically an error.
                Since string operations frequently occur in groups,
                we define operations on an erroneous string as no-op,
                so that the check for an error may be postponed until
                the end of the complex operation.  Most member functions
                which calculate a value will treat an erroneous string
                as having zero length; however, clients should not depend
                on this.

                Attempting to use an ISTR that is registered with another
                string will cause an assertion failure.

                Each NLS_STR has a version/modification flag that is also
                stored in the the ISTR.  An attempt to use an ISTR on an
                NLS_STR that has been modified (by calling one of the methods
                listed below) will cause an assertion failure.    To use the
                ISTR after a modifying method, you must first call ISTR::Reset
                which will update the version in the ISTR.  See the
                method definition for more detail.

                List of modifying methods:
                    All NLS::operator= methods
                    NLS::DelSubStr
                    NLS::ReplSubStr
                    NLS::InsertSubStr

                NOTE: The ISTR used as a starting index on the
                Substring methods remains valid after the call.

                Party() and DonePartying() can be used when you need to
                do something that the standard NLS_STR methods don't
                cover.  For example, you might want to tweak the first
                couple of characters in a pathname;  if you know they're
                definitely not double-byte characters, this is safe to
                do with ordinary character assignments.
                
                Calling Party() returns a pointer to the string buffer,
                and places the NLS_STR in an error state to prevent the
                standard methods from operating on it (and thereby getting
                confused by the possibly incorrect cached length).  You
                can still call QueryAllocSize() to find out the maximum
                size of the buffer.  When you've finished, call DonePartying()
                to switch the NLS_STR back to "normal" mode.  There are two
                overloaded forms of DonePartying().  If you know what the
                length of the string is, you can pass it in, and NLS_STR
                will just use that.  Otherwise, it will use strlenf() to
                find out what the new length is.  If you don't plan to
                change the length, call strlen() on the string before you
                Party(), save that length, and pass it to DonePartying().
                The initial strlen() is fast because it's cached.

                If you find yourself constantly Party()ing in order to
                accomplish a particular function, that function should
                be formally added to the NLS_STR definition.

    NOTES:        The lack of a strlwr() method comes from a shortcoming
                in the casemap tables.    Sorry.

                STR_OWNERALLOC strings are a special type of NLS_STR
                You mark a string as STR_OWNERALLOC on
                construction by passing the flag STR_OWNERALLOC and a pointer
                to your memory space where you want the string to reside
                plus the size of the memory block.
                THE POINTER MUST POINT TO A VALID NULL TERMINATED STRING.
                You are guaranteed this pointer will never be
                resized or deleted.  Note that no checking is performed for
                writing beyond the end of the string.  Valid uses include
                static strings, severe optimization, owner controlled
                memory allocation or stack controlled memory allocation.

                CODEWORK: Owner-alloc strings should be a distinct
                class from these normal strings.

                CODEWORK: Should add a fReadOnly flag.

                CODEWORK: Should clean up this mess, and make the
                owner-alloc constructor protected.

                I wish I could clean up this mess...

    HISTORY:
        johnl        11/28/90        First fully functioning version
        johnl        12/07/90        Incorporated code review changes
        terryk        04/05/91        add QueryNumChar method
        beng        07/22/91        Added more methods; separated fOwnerAlloc
                                    from cbData
        gregj        05/22/92        Added ToOEM, ToAnsi methods
        gregj        03/22/93        Ported to Chicago environment
        gregj        04/02/93        Added IsDBCSLeadByte()
        gregj        04/08/93        Added strncpy()

**************************************************************************/

class NLS_STR : public BASE
{
friend class ISTR; // Allow access to CheckIstr

public:
    // Default constructor, creating an empty string.
    //
    NLS_STR();

    // Initialize to "cchInitLen" characters, each "chInit",
    // plus trailing NUL.
    //
    NLS_STR( INT cchInitLen );

    // Initialize from a NUL-terminated character vector.
    //
    NLS_STR( const CHAR *pchInit );

    // Initialize an NLS_STR to memory position passed in achInit
    // No memory allocation of any type will be performed on this string
    // cbSize should be the total memory size of the buffer, if cbSize == -1
    // then the size of the buffer will assumed to be strlen(achInit)+1
    //
    NLS_STR( unsigned stralloc, CHAR *pchInit, INT cbSize = -1 );

    // Initialize from an existing x_STRING.
    //
    NLS_STR( const NLS_STR& nlsInit );

    ~NLS_STR();

    // Number of bytes the string uses (not including terminator)
    // Cf. QueryTextLength and QueryTextSize.
    //
    inline INT strlen() const;

    // Return a read-only CHAR vector, for the APIs.
    //
    const CHAR *QueryPch() const
#ifdef DEBUG
        ;
#else
        { return _pchData; }
#endif

    const CHAR *QueryPch( const ISTR& istr ) const
#ifdef DEBUG
        ;
#else
        { return _pchData + istr.QueryIB(); }
#endif

    WCHAR QueryChar( const ISTR& istr ) const
#ifdef DEBUG
        ;
#else
        { return *(_pchData+istr.QueryIB()); }
#endif

    operator const CHAR *() const
        { return QueryPch(); }

    const CHAR *operator[]( const ISTR& istr ) const
        { return QueryPch(istr); }

    BOOL IsDBCSLeadByte( CHAR ch ) const;

    // Total allocated storage
    //
    inline INT QueryAllocSize() const;

    inline BOOL IsOwnerAlloc() const;

    // Increase the size of a string preserving its contents.
    // Returns TRUE if successful, false otherwise (illegal to
    // call for an owner alloced string).  If you ask for a string smaller
    // then the currently allocated one, the request will be ignored and TRUE
    // will be returned.
    //
    BOOL realloc( INT cbNew );

    // Returns TRUE if error was successfully cleared (string is now in valid
    // state), FALSE otherwise.
    //
    BOOL Reset();

    NLS_STR& operator=( const NLS_STR& nlsSource );
    NLS_STR& operator=( const CHAR *achSource );

    NLS_STR& operator+=( WCHAR wch );        // NEW, replaces AppendChar
    NLS_STR& operator+=( const NLS_STR& nls ) { return strcat(nls); }
    NLS_STR& operator+=( LPCSTR psz ) { return strcat(psz); }

    NLS_STR& strncpy( const CHAR *pchSource, UINT cbSource );

    NLS_STR& strcat( const NLS_STR& nls );
    NLS_STR& strcat( LPCSTR psz );

    BOOL operator== ( const NLS_STR& nls ) const;
    BOOL operator!= ( const NLS_STR& nls ) const;

    INT strcmp( const NLS_STR& nls ) const;
    INT strcmp( const NLS_STR& nls, const ISTR& istrThis ) const;
    INT strcmp( const NLS_STR& nls, const ISTR& istrThis,
                const ISTR& istrStart2 ) const;

    INT stricmp( const NLS_STR& nls ) const;
    INT stricmp( const NLS_STR& nls, const ISTR& istrThis ) const;
    INT stricmp( const NLS_STR& nls, const ISTR& istrThis,
                 const ISTR& istrStart2 ) const;

    INT strncmp( const NLS_STR& nls, const ISTR& istrLen ) const;
    INT strncmp( const NLS_STR& nls, const ISTR& istrLen,
                 const ISTR& istrThis ) const;
    INT strncmp( const NLS_STR& nls, const ISTR& istrLen,
                 const ISTR& istrThis, const ISTR& istrStart2 ) const;

    INT strnicmp( const NLS_STR& nls, const ISTR& istrLen ) const;
    INT strnicmp( const NLS_STR& nls, const ISTR& istrLen,
                  const ISTR& istrThis ) const;
    INT strnicmp( const NLS_STR& nls, const ISTR& istrLen,
                  const ISTR& istrThis, const ISTR& istrStart2 ) const;

    // The following str* functions return TRUE if successful (istrPos has
    // meaningful data), false otherwise.
    //
    BOOL strcspn( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL strcspn( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;
    BOOL strspn( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL strspn( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;

    BOOL strstr( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL strstr( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;

    BOOL stristr( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL stristr( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;

    BOOL strchr( ISTR *istrPos, const CHAR ch ) const;
    BOOL strchr( ISTR *istrPos, const CHAR ch, const ISTR& istrStart ) const;

    BOOL strrchr( ISTR *istrPos, const CHAR ch ) const;
    BOOL strrchr( ISTR *istrPos, const CHAR ch, const ISTR& istrStart ) const;

    BOOL strtok( ISTR *istrPos, const NLS_STR& nlsBreak, BOOL fFirst = FALSE );

    LONG atol() const;
    LONG atol( const ISTR& istrStart ) const;

    INT atoi() const;
    INT atoi( const ISTR& istrStart ) const;

    NLS_STR& strupr();

    // Return a pointer to a new NLS_STR that contains the contents
    // of *this from istrStart to:
    //        End of string if no istrEnd is passed
    //        istrStart + istrEnd
    //
    NLS_STR *QuerySubStr( const ISTR& istrStart ) const;
    NLS_STR *QuerySubStr( const ISTR& istrStart, const ISTR& istrEnd ) const;

    // Collapse the string by removing the characters from istrStart to:
    //        End of string
    //        istrStart + istrEnd
    // The string is not reallocated
    //
    VOID DelSubStr( ISTR& istrStart );
    VOID DelSubStr( ISTR& istrStart, const ISTR& istrEnd );

    BOOL InsertStr( const NLS_STR& nlsIns, ISTR& istrStart );

    // Replace till End of string of either *this or replacement string
    // (or istrEnd in the 2nd form) starting at istrStart
    //
    VOID ReplSubStr( const NLS_STR& nlsRepl, ISTR& istrStart );
    VOID ReplSubStr( const NLS_STR& nlsRepl, ISTR& istrStart,
                     const ISTR& istrEnd );

    // Replace %1-%9 in *this with corresponding index from apnlsParamStrings
    // Ex. if *this="Error %1" and apnlsParamStrings[0]="Foo" the resultant
    //       string would be "Error Foo"
    //
    USHORT InsertParams( const NLS_STR *apnlsParamStrings[] );

    // Load a message from a resource file into *this (if string is an
    // OWNER_ALLOC string, then must be at least MAX_RES_STR_LEN.  Heap
    // NLS_STRs will be reallocated if necessary
    //
    USHORT LoadString( USHORT usMsgID );

    // Combines functionality of InsertParams & LoadString.  *this gets loaded
    // with the string from the resource file corresponding to usMsgID.
    //
    USHORT LoadString( USHORT usMsgID, const NLS_STR *apnlsParamStrings[] );

    VOID GetPrivateProfileString( const CHAR *pszFile, const CHAR *pszSection,
                                  const CHAR *pszKey, const CHAR *pszDefault = NULL );

    VOID ToOEM();            // convert ANSI to OEM

    VOID ToAnsi();            // convert OEM to ANSI

    VOID SetOEM();            // declare that string was constructed as OEM
    VOID SetAnsi();            // declare that string was constructed as ANSI

    inline BOOL IsOEM() const;

    CHAR *Party();            // get read-write access
    VOID DonePartying( VOID );            // if you don't have the length handy
    VOID DonePartying( INT cchNew );    // if you do

#ifdef EXTENDED_STRINGS
    // Initialize from a NUL-terminated character vector
    // and allocate a minimum of: cbTotalLen+1 bytes or strlen(achInit)+1
    //
    NLS_STR( const CHAR *pchInit, INT iTotalLen );

    // Similar to prev. except the string pointed at by pchInit is copied
    // to pchBuff.  The address of pchBuff is used as the string storage.
    // cbSize is required.  stralloc can only be STR_OWNERALLOC (it makes
    // no sense to use STR_OWNERALLOC_CLEAR).
    //
    NLS_STR( unsigned stralloc, CHAR *pchBuff, INT cbSize,
             const CHAR *pchInit );

    // return the number of logical characters within the string
    //
    INT QueryNumChar() const;

    // Return the number of printing CHARs in the string.
    // This number does not include the termination character.
    //
    // Cf. QueryNumChar, which returns a count of glyphs.
    //
    INT QueryTextLength() const;

    // Return the number of BYTES occupied by the string's representation.
    // Cf. QueryAllocSize, which returns the total amount alloc'd.
    //
    INT QueryTextSize() const;

    APIERR Append( const NLS_STR& nls );

    APIERR AppendChar( WCHAR wch );

    APIERR CopyFrom( const NLS_STR& nlsSource );
    APIERR CopyFrom( const CHAR *achSource );

    INT Compare( const NLS_STR *nls ) const { return strcmp(*nls); }

#endif

private:
    UINT _fsFlags;        // owner-alloc, character set flags
#define SF_OWNERALLOC    0x1
#define SF_OEM            0x2

    INT _cchLen;        // Number of bytes string uses (strlen)
    INT _cbData;        // Total storage allocated
    CHAR *_pchData;        // Pointer to Storage

#ifdef DEBUG
    USHORT _usVersion;    // Version count (inc. after each change)
#endif

    // The following substring functions are used internally (can't be
    // exposed since they take an INT cbLen parameter for an index).
    //
    VOID DelSubStr( ISTR&istrStart, INT cbLen );

    NLS_STR *QuerySubStr( const ISTR& istrStart, INT cbLen ) const;

    VOID ReplSubStr( const NLS_STR& nlsRepl, ISTR& istrStart, INT cbLen );

    BOOL Alloc( INT cchLen );      // Allocate memory for a string

#ifdef DEBUG        // DEBUG is new for these
    // CheckIstr checks whether istr is associated with this, asserts out
    // if it is not.  Also checks version numbers in debug version.
    //
    VOID CheckIstr( const ISTR& istr ) const;

    // UpdateIstr syncs the version number between *this and the passed
    // ISTR.  This is for operations that cause an update to the string
    // but the ISTR that was passed in is still valid (see InsertSubSt).
    //
    VOID UpdateIstr( ISTR *pistr ) const;

    // IncVers adds one to this strings version number because the previous
    // operation caused the contents to change thus possibly rendering
    // ISTRs on this string as invalid.
    //
    VOID IncVers();

    // InitializeVers sets the version number to 0
    //
    VOID InitializeVers();

    // QueryVersion returns the current version number of this string
    //
    USHORT QueryVersion() const;
#else    // DEBUG
    VOID CheckIstr( const ISTR& istr ) const { }
    VOID UpdateIstr( ISTR *pistr ) const { }
    VOID IncVers() { }
    VOID InitializeVers() { }
    USHORT QueryVersion() const { return 0; }
#endif
};


/***********************************************************************/

/***********************************************************************
 *
 *  Macro STACK_NLS_STR(name, len )
 *
 *    Define an NLS string on the stack with the name of "name" and the
 *    length of "len".    The strlen will be 0 and the first character will
 *    be '\0'.    One byte is added for the NULL terminator.  Usage:
 *        STACK_NLS_STR( UncPath, UNCLEN );
 *
 *  Macro ISTACK_NLS_STR(name, len, pchInitString )
 *
 *    Same as STACK_NLS_STR except ISTACK_NLS_STR takes an initializer.
 **********************************************************************/

#define STACK_NLS_STR( name, len )                \
    CHAR _tmp##name[ len+1 ] ;                    \
    *_tmp##name = '\0' ;                    \
    NLS_STR name( STR_OWNERALLOC, _tmp##name, len+1 );

#define ISTACK_NLS_STR( name, len, pchInitString )        \
    STACK_NLS_STR( name, len ) ;                \
    name = pchInitString;

/***********************************************************************/

BOOL NLS_STR::IsOwnerAlloc() const
{
    return _fsFlags & SF_OWNERALLOC;
}

BOOL NLS_STR::IsOEM() const
{
    return _fsFlags & SF_OEM;
}

INT NLS_STR::strlen() const
{
    return _cchLen;
}

INT NLS_STR::QueryAllocSize()  const
{
    return _cbData;
}

#endif // _STRING_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\mslocusr.h ===
//#define DBCS

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <regstr.h>
#define WIN31
#include "pwlapi.h"

#include <string.h>
#include <netlib.h>

#ifdef DEBUG
#define SAVE_DEBUG
#undef DEBUG
#endif

#include <npstring.h>
#include <npdefs.h>
#define _COMCTL32_                      // We delay-load Comctl32
#include <prsht.h>

#ifdef SAVE_DEBUG
#define DEBUG
#endif

#include <ole2.h>
#include "msluguid.h"

#include "msluapi.h"

void Netlib_EnterCriticalSection(void);
void Netlib_LeaveCriticalSection(void);
#ifdef DEBUG
extern BOOL g_fCritical;
#endif
#define ENTERCRITICAL   Netlib_EnterCriticalSection();
#define LEAVECRITICAL   Netlib_LeaveCriticalSection();
#define ASSERTCRITICAL  ASSERT(g_fCritical);

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))

extern "C" {
HRESULT VerifySupervisorPassword(LPCSTR pszPassword);
HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword);
};

const UINT cchMaxUsername = 128;

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern void LockThisDLL(BOOL fLock);
extern void RefThisDLL(BOOL fRef);

extern void UnloadShellEntrypoint(void);
extern void CleanupWinINet(void);

UINT NPSCopyNLS (NLS_STR FAR *pnlsSourceString, LPVOID lpDestBuffer, LPDWORD lpBufferSize);

extern APIERR MakeSupervisor(HPWL hPWL, LPCSTR pszSupervisorPassword);

HRESULT GetSystemCurrentUser(NLS_STR *pnlsCurrentUser);
HRESULT GetUserPasswordCache(LPCSTR pszUsername, LPCSTR pszPassword, LPHANDLE phOut, BOOL fCreate);

typedef void (*PFNSELNOTIFY)(HWND hwndLB, int iSel);
HRESULT FillUserList(HWND hwndLB, IUserDatabase *pDB, LPCSTR pszDefaultSelection,
                     BOOL fIncludeGuest, PFNSELNOTIFY pfnSelNotify);
void DestroyUserList(HWND hwndLB);
void AddPage(LPPROPSHEETHEADER ppsh, UINT id, DLGPROC pfn, LPVOID pwd);
void InitWizDataPtr(HWND hDlg, LPARAM lParam);
void InsertControlText(HWND hDlg, UINT idCtrl, const NLS_STR *pnlsInsert);
HRESULT GetControlText(HWND hDlg, UINT idCtrl, NLS_STR *pnls);
HRESULT DoAddUserWizard(HWND hwndParent, IUserDatabase *pDB,
                        BOOL fPickUserPage, IUser *pUserToClone);
BOOL InstallLogonDialog(void);
void DeinstallLogonDialog(void);

HRESULT DoUserDialog(HWND hwndOwner, DWORD dwFlags, IUser **ppOut);
void CacheLogonCredentials(LPCSTR pszUsername, LPCSTR pszPassword);

void ReportUserError(HWND hwndOwner, HRESULT hres);
void SetErrorFocus(HWND hDlg, UINT idCtrl, BOOL fClear = TRUE);

class CLUClassFactory : public IClassFactory
{
public:
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP CreateInstance( 
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
	STDMETHODIMP LockServer( 
            /* [in] */ BOOL fLock);
};


HRESULT CreateUserDatabase(REFIID riid, void **ppOut);

class CLUUser;
class BUFFER;

class CLUDatabase : public IUserDatabase
{
//friend class CLUClassFactory;
friend HRESULT CreateUserDatabase(REFIID riid, void **ppOut);

private:
	ULONG m_cRef;
	CLUUser *m_CurrentUser;

	CLUDatabase();
	~CLUDatabase();

	STDMETHODIMP CreateUser(LPCSTR pszName, IUser *pCloneFrom,
	                        BOOL fFixInstallStubs, IUserProfileInit *pInit);

public:
	// *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP Install(LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
						 LPCSTR pszRatingsPassword, IUserProfileInit *pInit);

	STDMETHODIMP AddUser(LPCSTR pszName, IUser *pSourceUser,
	                     IUserProfileInit *pInit, IUser **ppOut);
	STDMETHODIMP GetUser(LPCSTR pszName, IUser **ppOut);
	STDMETHODIMP GetSpecialUser(DWORD nSpecialUserCode, IUser **ppOut);
	STDMETHODIMP GetCurrentUser(IUser **ppOut);
	STDMETHODIMP SetCurrentUser(IUser *pUser);
	STDMETHODIMP DeleteUser(LPCSTR pszName);
	STDMETHODIMP RenameUser(LPCSTR pszOldName, LPCSTR pszNewName);
	STDMETHODIMP EnumUsers(IEnumUnknown **ppOut);

	STDMETHODIMP Authenticate(HWND hwndOwner, DWORD dwFlags,
							 LPCSTR pszName, LPCSTR pszPassword,
							 IUser **ppOut);

	STDMETHODIMP InstallComponent(REFCLSID clsidComponent, LPCSTR pszName,
								 DWORD dwFlags);
	STDMETHODIMP RemoveComponent(REFCLSID clsidComponent, LPCSTR pszName);
    STDMETHODIMP InstallWizard(HWND hwndParent);
    STDMETHODIMP AddUserWizard(HWND hwndParent);
    STDMETHODIMP UserCPL(HWND hwndParent);
};


class CLUUser : public IUser
{
friend class CLUDatabase;
friend class CLUEnum;

private:
	NLS_STR m_nlsUsername;
	NLS_STR m_nlsDir;
	NLS_STR m_nlsPassword;
	BOOL m_fAuthenticated;
    BOOL m_fTempSupervisor;
	HKEY m_hkeyDB;
	HKEY m_hkeyUser;
	BOOL m_fUserExists;
	BOOL m_fAppearsSupervisor;
    BOOL m_fLoadedProfile;
	ULONG m_cRef;

	CLUDatabase *m_pDB;

	CLUUser(CLUDatabase *m_pDB);
	~CLUUser();
	HRESULT Init(LPCSTR pszUsername);

	BOOL Exists() { return m_fUserExists; }
	HRESULT GetSupervisorPassword(BUFFER *pbufPCE);
    BOOL IsSystemCurrentUser(void);

public: 
	// *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP GetName(LPSTR pbBuffer, LPDWORD pcbBuffer);
	STDMETHODIMP GetProfileDirectory(LPSTR pbBuffer, LPDWORD pcbBuffer);

	STDMETHODIMP IsSupervisor(void);
	STDMETHODIMP SetSupervisorPrivilege(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword);
	STDMETHODIMP MakeTempSupervisor(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword);
	STDMETHODIMP AppearsSupervisor(void);

	STDMETHODIMP Authenticate(LPCSTR pszPassword);
	STDMETHODIMP ChangePassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword);
	STDMETHODIMP GetPasswordCache(LPCSTR pszPassword, LPHANDLE phOut);

    STDMETHODIMP LoadProfile(HKEY *phkeyUser);
    STDMETHODIMP UnloadProfile(HKEY hkeyUser);

	STDMETHODIMP GetComponentSettings(REFCLSID clsidComponent,
									  LPCSTR pszName, IUnknown **ppOut,
									  DWORD fdwAccess);
	STDMETHODIMP EnumerateComponentSettings(IEnumUnknown **ppOut,
										    DWORD fdwAccess);
};


class CLUEnum : public IEnumUnknown
{
friend class CLUDatabase;

private:
	ULONG m_cRef;
	HKEY m_hkeyDB;
	LPSTR *m_papszNames;
	UINT m_cNames;
	UINT m_cAlloc;
	UINT m_iCurrent;

	CLUDatabase *m_pDB;

	CLUEnum(CLUDatabase *m_pDB);
	~CLUEnum();
	HRESULT Init(void);
	void Cleanup(void);

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP Next(ULONG celt, IUnknown __RPC_FAR *__RPC_FAR *rgelt,
					  ULONG __RPC_FAR *pceltFetched);
	STDMETHODIMP Skip(ULONG celt);
	STDMETHODIMP Reset(void);
	STDMETHODIMP Clone(IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);
};


#ifdef USER_SETTINGS_IMPLEMENTED

class CUserSettings : public IUserSettings
{
private:
	ULONG m_cRef;
	CLSID m_clsid;
	NLS_STR m_nlsName;
	HKEY m_hkey;

	CUserSettings();
	~CUserSettings();

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP GetCLSID(CLSID *pclsidOut);
	STDMETHODIMP GetName(LPSTR pbBuffer, LPDWORD pcbBuffer);
	STDMETHODIMP GetDisplayName(LPSTR pbBuffer, LPDWORD pcbBuffer);

	STDMETHODIMP QueryKey(HKEY *phkeyOut);
};

#endif

class CWizData : public IUserProfileInit
{
public:
    HRESULT m_hresRatings;          /* result of VerifySupervisorPassword("") */
    BOOL m_fGoMultiWizard;          /* TRUE if this is the big go-multiuser wizard */
    NLS_STR m_nlsSupervisorPassword;
    NLS_STR m_nlsUsername;
    NLS_STR m_nlsUserPassword;
    IUserDatabase *m_pDB;
    IUser *m_pUserToClone;
    int m_idPrevPage;               /* ID of page before Finish */
    UINT m_cRef;
    DWORD m_fdwOriginalPerUserFolders;
    DWORD m_fdwNewPerUserFolders;
    DWORD m_fdwCloneFromDefault;
    BOOL m_fCreatingProfile;
    IUser *m_pNewUser;
    BOOL m_fChannelHack;

    CWizData();
    ~CWizData();

	// *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
    STDMETHODIMP PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
};

void InitFolderCheckboxes(HWND hDlg, CWizData *pwd);
void FinishChooseFolders(HWND hDlg, CWizData *pwd);

BOOL ProfileUIRestricted(void);
void ReportRestrictionError(HWND hwndOwner);

typedef HRESULT (*PFNPROGRESS)(LPARAM lParam);
HRESULT CallWithinProgressDialog(HWND hwndOwner, UINT idResource, PFNPROGRESS pfn,
                                 LPARAM lParam);


HRESULT IsCurrentUserSupervisor(IUserDatabase *pDB);


/* NOTE: Keep the following flags in the same order as the corresponding
 * entries in the folder descriptor table in msluwiz.cpp.
 */
const DWORD FOLDER_DESKTOP   = 0x00000001;
const DWORD FOLDER_NETHOOD   = 0x00000002;
const DWORD FOLDER_RECENT    = 0x00000004;
const DWORD FOLDER_STARTMENU = 0x00000008;
const DWORD FOLDER_PROGRAMS  = 0x00000010;
const DWORD FOLDER_STARTUP   = 0x00000020;
const DWORD FOLDER_FAVORITES = 0x00000040;
const DWORD FOLDER_CACHE     = 0x00000080;
const DWORD FOLDER_MYDOCS    = 0x00000100;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\dllload.c ===
#include <windows.h>
#include "netmpr.h"
#include "pwlapi.h"
#include <pcerr.h>

/* Avoid inconsistent-DLL-linkage warnings on shell32 and comctl32 APIs. */
#undef DECLSPEC_IMPORT
#define DECLSPEC_IMPORT
#include <prsht.h>
#include <shellapi.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
// 

// These macros produce code that looks like
#if 0

BOOL GetOpenFileNameA(LPOPENFILENAME pof)
{
    static BOOL (*pfnGetOpenFileNameA)(LPOPENFILENAME pof);
    _GetProcFromDLL(&g_hinstCOMDLG32, "COMDLG32.DLL",  "GetOpenFileNameA", &pfnGetoptnFileNameA);
    if (pfnGetOpenFileNameA)
        return pfnGetOpenFileNameA(pof);
    return -1;
}
#endif

/**********************************************************************/

void _GetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    // If it's already loaded, return.
    if (*ppfn) {
        return;
    }

    if (*phinst == NULL) {
        *phinst = LoadLibrary(pszDLL);
        if (*phinst == NULL) {
            return;
        }
    }

    *ppfn = GetProcAddress(*phinst, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

//
// For private entrypoints exported by ordinal.
// 

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}


/**********************************************************************/
/**********************************************************************/



// --------- MSPWL32.DLL ---------------

HINSTANCE g_hinstMSPWL32 = NULL;

#define DELAY_LOAD_PWL(_fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(g_hinstMSPWL32, mspwl32.dll, APIERR, _fn, _ord, _args, _nargs, IERR_CachingDisabled)

DELAY_LOAD_PWL(OpenPasswordCache, 10,
			   (LPHPWL lphCache,const CHAR *pszUsername,const CHAR *pszPassword,BOOL fWritable),
			   (lphCache, pszUsername, pszPassword, fWritable));
DELAY_LOAD_PWL(ClosePasswordCache, 11,
			   (HPWL hCache, BOOL fDiscardMemory), (hCache, fDiscardMemory));
DELAY_LOAD_PWL(CreatePasswordCache, 12,
			   (LPHPWL lphCache,const CHAR *pszUsername,const CHAR *pszPassword),
			   (lphCache, pszUsername, pszPassword));
DELAY_LOAD_PWL(DeletePasswordCache, 22,
			   (const CHAR *pszUsername), (pszUsername));
DELAY_LOAD_PWL(FindCacheResource, 16,
			   (HPWL hCache,const CHAR *pbResource,WORD cbResource,CHAR *pbBuffer,WORD cbBuffer,UCHAR nType),
			   (hCache, pbResource, cbResource, pbBuffer, cbBuffer, nType));
DELAY_LOAD_PWL(DeleteCacheResource, 17,
			   (HPWL hCache,const CHAR *pbResource,WORD cbResource,UCHAR nType),
			   (hCache, pbResource, cbResource, nType));
DELAY_LOAD_PWL(AddCacheResource, 18,
			   (HPWL hCache,const CHAR *pbResource,WORD cbResource,const CHAR *pbPassword,WORD cbPassword,UCHAR nType,UINT fnFlags),
			   (hCache, pbResource, cbResource, pbPassword, cbPassword, nType, fnFlags));
DELAY_LOAD_PWL(SetCachePassword, 21,
			   (HPWL hCache, const CHAR *pszNewPassword),
			   (hCache, pszNewPassword));


// --------- MPR.DLL ---------------

HINSTANCE g_hinstMPR = NULL;

DELAY_LOAD_ERR(g_hinstMPR, mpr.dll, DWORD, WNetCachePassword,
               (LPSTR pbResource, WORD cbResource, LPSTR pbPassword, WORD cbPassword, BYTE nType, UINT fnFlags),
               (pbResource, cbResource, pbPassword, cbPassword, nType, fnFlags),
               WN_CANCEL);
DELAY_LOAD_ERR(g_hinstMPR, mpr.dll, DWORD, WNetGetCachedPassword,
               (LPSTR pbResource, WORD cbResource, LPSTR pbPassword, LPWORD pcbPassword, BYTE nType),
               (pbResource, cbResource, pbPassword, pcbPassword, nType),
               WN_CANCEL);
DELAY_LOAD_ERR(g_hinstMPR, mpr.dll, DWORD, WNetRemoveCachedPassword,
               (LPSTR pbResource, WORD cbResource, BYTE nType),
               (pbResource, cbResource, nType),
               WN_CANCEL);

// --------- COMCTL32.DLL ---------------

HINSTANCE g_hinstCOMCTL32 = NULL;

DELAY_LOAD(g_hinstCOMCTL32, comctl32.dll, HPROPSHEETPAGE, CreatePropertySheetPageA,
           (LPCPROPSHEETPAGEA lpPage), (lpPage));
DELAY_LOAD(g_hinstCOMCTL32, comctl32.dll, INT_PTR, PropertySheetA,
           (LPCPROPSHEETHEADERA lpHdr), (lpHdr));

// --------- SHELL32.DLL ----------------

HINSTANCE g_hinstSHELL32 = NULL;

#ifdef UNICODE
DELAY_LOAD(g_hinstSHELL32, SHELL32.DLL, BOOL, ShellExecuteExW,
	(LPSHELLEXECUTEINFOW lpExecInfo), (lpExecInfo));
#else
DELAY_LOAD(g_hinstSHELL32, SHELL32.DLL, BOOL, ShellExecuteExA,
	(LPSHELLEXECUTEINFOA lpExecInfo), (lpExecInfo));
#endif
DELAY_LOAD_ORD_VOID(g_hinstSHELL32, SHELL32.DLL, SHFlushSFCache, 526, (), ());

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\msludb.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include "profiles.h"

#include <regentry.h>

#include <ole2.h>

CLUDatabase::CLUDatabase(void)
	: m_cRef(0),
	  m_CurrentUser(NULL)
{
    RefThisDLL(TRUE);
}


CLUDatabase::~CLUDatabase(void)
{
	if (m_CurrentUser != NULL) {
		m_CurrentUser->Release();
		m_CurrentUser = NULL;
	}
    RefThisDLL(FALSE);
}


STDMETHODIMP CLUDatabase::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IUserDatabase)) {
        *ppvObj = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CLUDatabase::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CLUDatabase::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}
	/* Handle circular refcount because of cached current user object. */
	else if (1L == m_cRef && m_CurrentUser != NULL) {
		IUser *pCurrentUser = m_CurrentUser;
		m_CurrentUser = NULL;
		pCurrentUser->Release();
	}

	return cRef;
}


STDMETHODIMP CLUDatabase::Install(LPCSTR pszSupervisorName,
								  LPCSTR pszSupervisorPassword,
								  LPCSTR pszRatingsPassword,
								  IUserProfileInit *pInit)
{
	/* If the system already has a supervisor password, make sure the caller's
	 * password matches.  If there isn't already a password, the caller's
	 * (account) password is it.  We use the account password because the
	 * caller (the setup program) probably didn't pass us a ratings password
	 * in that case -- he also checks to see if there's an old ratings
	 * password and knows to prompt for one only if it's already there.
	 */
	HRESULT hres = ::VerifySupervisorPassword(pszRatingsPassword);
	
	if (FAILED(hres)) {
        if (pszRatingsPassword == NULL)
    		pszRatingsPassword = pszSupervisorPassword;
		::ChangeSupervisorPassword(::szNULL, pszRatingsPassword);
	}
	else if (hres == S_FALSE)
		return E_ACCESSDENIED;


	/* User profiles and password caching have to be enabled for us to work.
	 * We also have to be able to open or create the supervisor's PWL using
	 * the given password.  Thus we validate the password at the same time.
	 */

	{
		RegEntry re(::szLogonKey, HKEY_LOCAL_MACHINE);
		if (re.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(re.GetError());
		if (!re.GetNumber(::szUserProfiles))
			re.SetValue(::szUserProfiles, 1);
		if (re.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(re.GetError());
	}

    /* Make copies of the username and password for passing to the PWL APIs.
     * They need to be in OEM (PWL is accessible from DOS), and must be upper
     * case since the Windows logon dialog uppercases all PWL passwords.
     */
    NLS_STR nlsPWLName(pszSupervisorName);
    NLS_STR nlsPWLPassword(pszSupervisorPassword);
    if (nlsPWLName.QueryError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(nlsPWLName.QueryError());
    if (nlsPWLPassword.QueryError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(nlsPWLPassword.QueryError());
    nlsPWLName.strupr();
    nlsPWLName.ToOEM();
    nlsPWLPassword.strupr();
    nlsPWLPassword.ToOEM();

	HPWL hPWL = NULL;
	APIERR err = ::OpenPasswordCache(&hPWL, nlsPWLName.QueryPch(),
									 nlsPWLPassword.QueryPch(), TRUE);

	if (err != ERROR_SUCCESS) {
        if (err != IERR_IncorrectUsername)
    		err = ::CreatePasswordCache(&hPWL, nlsPWLName.QueryPch(), nlsPWLPassword.QueryPch());
		if (err != ERROR_SUCCESS)	
			return HRESULT_FROM_WIN32(err);
	}


	/* Now that the system has a supervisor password, call a worker function
	 * to clone the supervisor account from the default profile.  The worker
	 * function assumes that the caller has validated that the current user is
	 * a supervisor.
	 */

	err = ::MakeSupervisor(hPWL, pszRatingsPassword);
	::ClosePasswordCache(hPWL, TRUE);
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	IUser *pSupervisor = NULL;
    hres = GetUser(pszSupervisorName, &pSupervisor);
	if (FAILED(hres)) {
		hres = CreateUser(pszSupervisorName, NULL, TRUE, pInit);
		if (pSupervisor != NULL) {
			pSupervisor->Release();
			pSupervisor = NULL;
		}
		if (SUCCEEDED(hres))
			hres = GetUser(pszSupervisorName, &pSupervisor);	/* reinitialize with created profile */
	}

	if (pSupervisor != NULL) {
		if (SUCCEEDED(hres))
			hres = pSupervisor->Authenticate(pszSupervisorPassword);
		if (SUCCEEDED(hres))
			hres = SetCurrentUser(pSupervisor);
        if (SUCCEEDED(hres))
            pSupervisor->SetSupervisorPrivilege(TRUE, pszRatingsPassword);  /* set appears-supervisor flag */

		pSupervisor->Release();
		pSupervisor = NULL;
	}

	return hres;
}


/* Some install stubs are "clone-user" install stubs, that get re-run if a
 * profile is cloned to become a new user's profile.  For example, if you
 * clone Fred to make Barney, Outlook Express doesn't want Barney to inherit
 * Fred's mailbox.
 *
 * When you run the go-multiuser wizard, we assume that the first user being
 * created is the one who's been using the machine all along, so that one
 * copy should be exempt from this.  So we go through all the install stub
 * keys for the newly created profile and, for any that are marked with a
 * username (even a blank one indicates that it's a clone-user install stub),
 * we mark it with the new username so it won't get re-run.
 */
void FixInstallStubs(LPCSTR pszName, HKEY hkeyProfile)
{
    HKEY hkeyList;
    LONG err = RegOpenKeyEx(hkeyProfile, "Software\\Microsoft\\Active Setup\\Installed Components", 0,
                            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hkeyList);

    if (err == ERROR_SUCCESS) {
        DWORD cbKeyName, iKey;
        TCHAR szKeyName[80];

        /* Enumerate components that are installed for the profile. */
        for (iKey = 0; ; iKey++)
        {
            LONG lEnum;

            cbKeyName = ARRAYSIZE(szKeyName);

            if ((lEnum = RegEnumKey(hkeyList, iKey, szKeyName, cbKeyName)) == ERROR_MORE_DATA)
            {
                // ERROR_MORE_DATA means the value name or data was too large
                // skip to the next item
                continue;
            }
            else if( lEnum != ERROR_SUCCESS )
            {
                // could be ERROR_NO_MORE_ENTRIES, or some kind of failure
                // we can't recover from any other registry problem, anyway
                break;
            }

            HKEY hkeyComponent;
            if (RegOpenKeyEx(hkeyList, szKeyName, 0,
                             KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyComponent) == ERROR_SUCCESS) {
                cbKeyName = sizeof(szKeyName);
                err = RegQueryValueEx(hkeyComponent, "Username", NULL, NULL,
                                      (LPBYTE)szKeyName, &cbKeyName);
                if (err == ERROR_SUCCESS || err == ERROR_MORE_DATA) {
                    RegSetValueEx(hkeyComponent, "Username",
                                  0, REG_SZ,
                                  (LPBYTE)pszName,
                                  lstrlen(pszName)+1);
                }
                RegCloseKey(hkeyComponent);
            }
        }
        RegCloseKey(hkeyList);
    }
}


STDMETHODIMP CLUDatabase::CreateUser(LPCSTR pszName, IUser *pCloneFrom,
                                     BOOL fFixInstallStubs, IUserProfileInit *pInit)
{
    if (::strlenf(pszName) > cchMaxUsername)
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);

	RegEntry reRoot(::szProfileList, HKEY_LOCAL_MACHINE);
	if (reRoot.GetError() != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(reRoot.GetError());

	/* See if the user's subkey exists.  If it doesn't, create it. */
	reRoot.MoveToSubKey(pszName);
	if (reRoot.GetError() != ERROR_SUCCESS) {
		RegEntry reUser(pszName, reRoot.GetKey());
		if (reUser.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(reUser.GetError());

		reRoot.MoveToSubKey(pszName);
		if (reRoot.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(reRoot.GetError());
	}

	NLS_STR nlsProfilePath(MAX_PATH);
	if (nlsProfilePath.QueryError() != ERROR_SUCCESS)
		return E_OUTOFMEMORY;

	reRoot.GetValue(::szProfileImagePath, &nlsProfilePath);

	/* If the profile path is already recorded for the user, see if the
	 * profile itself exists.  If it does, then CreateUser is an error.
	 */
	BOOL fComputePath = FALSE;

	if (reRoot.GetError() == ERROR_SUCCESS) {
		if (!DirExists(nlsProfilePath.QueryPch())) {
			if (!::CreateDirectory(nlsProfilePath.QueryPch(), NULL)) {
				fComputePath = TRUE;
			}
		}
	}
	else {
		fComputePath = TRUE;
	}

	if (fComputePath) {
		ComputeLocalProfileName(pszName, &nlsProfilePath);
		reRoot.SetValue(::szProfileImagePath, nlsProfilePath.QueryPch());
	}

	AddBackslash(nlsProfilePath);
	nlsProfilePath.strcat(::szStdNormalProfile);
	if (FileExists(nlsProfilePath.QueryPch()))
		return HRESULT_FROM_WIN32(ERROR_USER_EXISTS);

	/* The user's profile directory now exists, and its path is recorded
	 * in the registry.  nlsProfilePath is now the full pathname for the
	 * user's profile file, which does not exist yet.
	 */

	NLS_STR nlsOtherProfilePath(MAX_PATH);
	if (nlsOtherProfilePath.QueryError() != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(nlsOtherProfilePath.QueryError());

	HRESULT hres;
	DWORD cbPath = nlsOtherProfilePath.QueryAllocSize();
	if (pCloneFrom == NULL ||
		FAILED(pCloneFrom->GetProfileDirectory(nlsOtherProfilePath.Party(), &cbPath)))
	{
		/* Cloning default profile. */

		hres = GiveUserDefaultProfile(nlsProfilePath.QueryPch());
        nlsOtherProfilePath.DonePartying();
        nlsOtherProfilePath = "";
	}
	else {
		/* Cloning other user's profile. */
        nlsOtherProfilePath.DonePartying();
		AddBackslash(nlsOtherProfilePath);
		nlsOtherProfilePath.strcat(::szStdNormalProfile);
		hres = CopyProfile(nlsOtherProfilePath.QueryPch(), nlsProfilePath.QueryPch());
	}

	if (FAILED(hres))
		return hres;

	/* Now the user has a profile.  Load it and perform directory
	 * reconciliation.
	 */

	LONG err = ::MyRegLoadKey(HKEY_USERS, pszName, nlsProfilePath.QueryPch());
	if (err == ERROR_SUCCESS) {
		HKEY hkeyNewProfile;
		err = ::RegOpenKey(HKEY_USERS, pszName, &hkeyNewProfile);
		if (err == ERROR_SUCCESS) {

            /* Build just the profile directory, no "user.dat" on the end. */
        	ISTR istrBackslash(nlsProfilePath);
	        if (nlsProfilePath.strrchr(&istrBackslash, '\\')) {
                ++istrBackslash;
		        nlsProfilePath.DelSubStr(istrBackslash);
            }

            if (pInit != NULL) {
                hres = pInit->PreInitProfile(hkeyNewProfile, nlsProfilePath.QueryPch());
                if (hres == E_NOTIMPL)
                    hres = S_OK;
            }
            else
                hres = S_OK;

            if (SUCCEEDED(hres)) {
    			err = ReconcileFiles(hkeyNewProfile, nlsProfilePath, nlsOtherProfilePath);	/* modifies nlsProfilePath */
                hres = HRESULT_FROM_WIN32(err);

                if (fFixInstallStubs) {
                    ::FixInstallStubs(pszName, hkeyNewProfile);
                }

                if (pInit != NULL) {
                    hres = pInit->PostInitProfile(hkeyNewProfile, nlsProfilePath.QueryPch());
                    if (hres == E_NOTIMPL)
                        hres = S_OK;
                }
            }
			::RegFlushKey(hkeyNewProfile);
			::RegCloseKey(hkeyNewProfile);
		}
		::RegUnLoadKey(HKEY_USERS, pszName);
	}

	return hres;
}


STDMETHODIMP CLUDatabase::AddUser(LPCSTR pszName, IUser *pSourceUser,
                                  IUserProfileInit *pInit, IUser **ppOut)
{
	if (ppOut != NULL)
		*ppOut = NULL;

    if (IsCurrentUserSupervisor(this) != S_OK)
		return E_ACCESSDENIED;

	HRESULT hres = CreateUser(pszName, pSourceUser, FALSE, pInit);
	if (FAILED(hres))
		return hres;

	if (ppOut != NULL)
		hres = GetUser(pszName, ppOut);

	return hres;
}


STDMETHODIMP CLUDatabase::GetUser(LPCSTR pszName, IUser **ppOut)
{
	*ppOut = NULL;

	CLUUser *pUser = new CLUUser(this);

	if (pUser == NULL) {
		return ResultFromScode(E_OUTOFMEMORY);
	}

	HRESULT err = pUser->Init(pszName);
	if (SUCCEEDED(err) && !pUser->Exists()) {
		err = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
	}

	if (FAILED(err) || !pUser->Exists()) {
		pUser->Release();
		return err;
	}

	*ppOut = pUser;

	return NOERROR;
}


STDMETHODIMP CLUDatabase::GetSpecialUser(DWORD nSpecialUserCode, IUser **ppOut)
{
	switch (nSpecialUserCode) {
	case GSU_CURRENT:
		return GetCurrentUser(ppOut);
		break;

	case GSU_DEFAULT:
		return GetUser(szDefaultUserName, ppOut);
		break;

	default:
		return ResultFromScode(E_INVALIDARG);
	};

	return NOERROR;
}


HRESULT GetSystemCurrentUser(NLS_STR *pnlsCurrentUser)
{
	DWORD cbBuffer = pnlsCurrentUser->QueryAllocSize();
	UINT err;
	if (!::GetUserName(pnlsCurrentUser->Party(), &cbBuffer))
		err = ::GetLastError();
	else
		err = NOERROR;
	pnlsCurrentUser->DonePartying();

	return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CLUDatabase::GetCurrentUser(IUser **ppOut)
{
	if (m_CurrentUser == NULL) {
		NLS_STR nlsCurrentUser(cchMaxUsername+1);
		UINT err = nlsCurrentUser.QueryError();
		if (err)
			return HRESULT_FROM_WIN32(err);

		HRESULT hres = GetSystemCurrentUser(&nlsCurrentUser);
		if (FAILED(hres))
			return hres;

		hres = GetUser(nlsCurrentUser.QueryPch(), (IUser **)&m_CurrentUser);
		if (FAILED(hres))
			return hres;
	}

	*ppOut = m_CurrentUser;
	m_CurrentUser->AddRef();

	return NOERROR;
}


STDMETHODIMP CLUDatabase::SetCurrentUser(IUser *pUser)
{
	CLUUser *pCLUUser = (CLUUser *)pUser;
	HPWL hpwlUser;
	if (!pCLUUser->m_fAuthenticated ||
		FAILED(pCLUUser->GetPasswordCache(pCLUUser->m_nlsPassword.QueryPch(), &hpwlUser)))
	{
		return HRESULT_FROM_WIN32(ERROR_NOT_AUTHENTICATED);
	}
	::ClosePasswordCache(hpwlUser, TRUE);

	CLUUser *pClone;

	HRESULT hres = GetUser(pCLUUser->m_nlsUsername.QueryPch(), (IUser **)&pClone);
	if (FAILED(hres))
		return hres;

	/* Make sure the clone object is authenticated properly. */
	hres = pClone->Authenticate(pCLUUser->m_nlsPassword.QueryPch());
	if (FAILED(hres)) {
		return HRESULT_FROM_WIN32(ERROR_NOT_AUTHENTICATED);
	}

	if (m_CurrentUser != NULL) {
		m_CurrentUser->Release();
	}

	m_CurrentUser = pClone;
	return NOERROR;
}


STDMETHODIMP CLUDatabase::DeleteUser(LPCSTR pszName)
{
	NLS_STR nlsName(MAX_PATH);
	if (nlsName.QueryError() != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(nlsName.QueryError());

    /* Check supervisor privilege up front, this'll handle the not-logged-on
     * case later if we re-enable supervisor stuff.
     */
    if (IsCurrentUserSupervisor(this) != S_OK)
        return E_ACCESSDENIED;

	IUser *pCurrentUser;

    HRESULT hres = GetCurrentUser(&pCurrentUser);
    if (SUCCEEDED(hres)) {

    	/* Check current user's name and make sure we're not deleting him.
    	 * Note that because the current user must be an authenticated supervisor,
    	 * and you can't delete the current user, you can never delete the last
    	 * supervisor using this function.
    	 */
    	DWORD cb = nlsName.QueryAllocSize();
    	hres = pCurrentUser->GetName(nlsName.Party(), &cb);
    	nlsName.DonePartying();
    	if (SUCCEEDED(hres) && !::stricmpf(pszName, nlsName.QueryPch()))
            hres = HRESULT_FROM_WIN32(ERROR_BUSY);

    	if (FAILED(hres))
            return hres;
    }

    /* Check system's idea of current user as well. */

    hres = GetSystemCurrentUser(&nlsName);
    if (SUCCEEDED(hres)) {
        if (!::stricmpf(pszName, nlsName.QueryPch()))
            return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    return DeleteProfile(pszName);
}


STDMETHODIMP CLUDatabase::RenameUser(LPCSTR pszOldName, LPCSTR pszNewName)
{
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CLUDatabase::EnumUsers(IEnumUnknown **ppOut)
{
	*ppOut = NULL;

	CLUEnum *pEnum = new CLUEnum(this);

	if (pEnum == NULL) {
		return ResultFromScode(E_OUTOFMEMORY);
	}

	HRESULT err = pEnum->Init();
	if (FAILED(err)) {
		pEnum->Release();
		return err;
	}

	*ppOut = pEnum;

	return NOERROR;
}



STDMETHODIMP CLUDatabase::Authenticate(HWND hwndOwner, DWORD dwFlags,
							 LPCSTR pszName, LPCSTR pszPassword,
							 IUser **ppOut)
{
	if (dwFlags & LUA_DIALOG) {
        if (!UseUserProfiles() || FAILED(VerifySupervisorPassword(szNULL))) {
            return InstallWizard(hwndOwner);
        }
        return ::DoUserDialog(hwndOwner, dwFlags, ppOut);
	}

	/* Null out return pointer for error cases. */
	if (ppOut != NULL)
		*ppOut = NULL;

	IUser *pUser;
	BOOL fReleaseMe = TRUE;

	HRESULT hres = GetUser(pszName, &pUser);
	if (SUCCEEDED(hres)) {
		hres = pUser->Authenticate(pszPassword);
		if (SUCCEEDED(hres)) {
			if ((dwFlags & LUA_SUPERVISORONLY) && (pUser->IsSupervisor() != S_OK)) {
				hres = E_ACCESSDENIED;
			}
			else if (ppOut != NULL) {
				*ppOut = pUser;
				fReleaseMe = FALSE;
			}
		}
		if (fReleaseMe)
			pUser->Release();
	}
	return hres;
}


STDMETHODIMP CLUDatabase::InstallComponent(REFCLSID clsidComponent,
										   LPCSTR pszName, DWORD dwFlags)
{
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CLUDatabase::RemoveComponent(REFCLSID clsidComponent, LPCSTR pszName)
{
	return ResultFromScode(E_NOTIMPL);
}


#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD

HRESULT IsCurrentUserSupervisor(IUserDatabase *pDB)
{
    IUser *pCurrentUser = NULL;

    HRESULT hres = pDB->GetCurrentUser(&pCurrentUser);
    if (SUCCEEDED(hres)) {
        hres = pCurrentUser->IsSupervisor();
    }
    if (pCurrentUser != NULL) {
        pCurrentUser->Release();
    }
    return hres;
}
#else
HRESULT IsCurrentUserSupervisor(IUserDatabase *pDB) { return S_OK; }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\mslocusr.cpp ===
#include "mslocusr.h"
#include <netspi.h>
#define DECL_CRTFREE
#include <crtfree.h>

/* the following defs will make msluglob.h actually define globals */
#define EXTERN
#define ASSIGN(value) = value
#include "msluglob.h"

HANDLE g_hmtxShell = 0;              // Note: Handle is per-instance.

#ifdef DEBUG
BOOL g_fCritical=FALSE;
#endif

HINSTANCE hInstance = NULL;

const char szMutexName[] = "MSLocUsrMutex";
UINT g_cRefThisDll = 0;		// Reference count of this DLL.
UINT g_cLocks = 0;			// Number of locks on this server.


void LockThisDLL(BOOL fLock)
{
	ENTERCRITICAL
	{
		if (fLock)
			g_cLocks++;
		else
			g_cLocks--;
	}
	LEAVECRITICAL
}


void RefThisDLL(BOOL fRef)
{
	ENTERCRITICAL
	{
		if (fRef)
			g_cRefThisDll++;
		else
			g_cRefThisDll--;
	}
	LEAVECRITICAL
}


void Netlib_EnterCriticalSection(void)
{
    WaitForSingleObject(g_hmtxShell, INFINITE);
#ifdef DEBUG
    g_fCritical=TRUE;
#endif
}

void Netlib_LeaveCriticalSection(void)
{
#ifdef DEBUG
    g_fCritical=FALSE;
#endif
    ReleaseMutex(g_hmtxShell);
}

void _ProcessAttach()
{
    //
    // All the per-instance initialization code should come here.
    //
    // We should not pass TRUE as fInitialOwner, read the CreateMutex
    // section of Win32 API help file for detail.
    //
	::DisableThreadLibraryCalls(::hInstance);
    
    g_hmtxShell = CreateMutex(NULL, FALSE, ::szMutexName);  // per-instance

    ::InitStringLibrary();
}

void _ProcessDetach()
{
    UnloadShellEntrypoint();
    CloseHandle(g_hmtxShell);
}

STDAPI_(BOOL) DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        hInstance = hInstDll;
	_ProcessAttach();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
	_ProcessDetach();
    }


    return TRUE;
}


UINT
NPSCopyNLS ( 
    NLS_STR FAR *   pnlsSourceString, 
    LPVOID          lpDestBuffer, 
    LPDWORD         lpBufferSize )
{
    if ((!lpBufferSize) || (!lpDestBuffer && (*lpBufferSize != 0))) {
        return ERROR_INVALID_PARAMETER;
    }
    if (pnlsSourceString != NULL) {

        DWORD   dwDestLen = 0;  // bytes copied to dest buffer, including NULL
        DWORD   dwSourceLen = pnlsSourceString->strlen() + 1; // bytes in source buffer, including NULL

        if ((lpDestBuffer) && (*lpBufferSize != 0)) {
            NLS_STR nlsDestination( STR_OWNERALLOC_CLEAR, (LPSTR)lpDestBuffer, (UINT) *lpBufferSize );        
            nlsDestination = *pnlsSourceString;      /* copy source string to caller's buffer */
            dwDestLen = nlsDestination.strlen() + 1;
        }
        if (dwSourceLen != dwDestLen) {
            // Only update buffersize parameter if there is more data,
            // and store source string size, counting NULL.
            *lpBufferSize = dwSourceLen;
            return ERROR_MORE_DATA;
        }
        else {
            return NOERROR;
        }
    }
    else {
        if (*lpBufferSize == 0) {
            *lpBufferSize = 1;
            return ERROR_MORE_DATA;
        }
        else {
            *(LPSTR)lpDestBuffer = NULL; // validated to not be NULL above
            return NOERROR;
        }
    }            
}

DWORD
NPSCopyString (
    LPCTSTR lpSourceString,
    LPVOID  lpDestBuffer,
    LPDWORD lpBufferSize )
{
    if (lpSourceString != NULL) {    
        NLS_STR nlsSource( STR_OWNERALLOC, (LPTSTR)lpSourceString );
        return NPSCopyNLS ( &nlsSource,
                            lpDestBuffer,
                            lpBufferSize );
    }
    else {
        return NPSCopyNLS ( NULL,
                            lpDestBuffer,
                            lpBufferSize );    
    }                               
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\msluenum.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include <ole2.h>

CLUEnum::CLUEnum(CLUDatabase *pDB)
	: m_cRef(1),
	  m_hkeyDB(NULL),
	  m_papszNames(NULL),
	  m_cNames(0),
	  m_cAlloc(0),
	  m_iCurrent(0),
	  m_pDB(pDB)
{
	m_pDB->AddRef();
    RefThisDLL(TRUE);
}


CLUEnum::~CLUEnum(void)
{
	Cleanup();
	if (m_pDB != NULL)
		m_pDB->Release();
    RefThisDLL(FALSE);
}


#define cpPerAlloc 16		/* allocate 16 pointers at a go */
HRESULT CLUEnum::Init(void)
{
	UINT err = (UINT)RegOpenKey(HKEY_LOCAL_MACHINE, ::szProfileList, &m_hkeyDB);
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	m_papszNames = (LPSTR *)::MemAlloc(cpPerAlloc * sizeof(LPCSTR));	/* not "new", so we can realloc */
	if (m_papszNames == NULL)
		return ResultFromScode(E_OUTOFMEMORY);
	m_cAlloc = cpPerAlloc;

	NLS_STR nlsTempName(cchMaxUsername+1);

	err = nlsTempName.QueryError();
	if (err)
		return HRESULT_FROM_WIN32(err);

	for (DWORD iSubkey=0; err == ERROR_SUCCESS; iSubkey++) {
		DWORD cbBuffer = nlsTempName.QueryAllocSize();
		err = (UINT)RegEnumKey(m_hkeyDB, iSubkey, nlsTempName.Party(), cbBuffer);
		nlsTempName.DonePartying();		
		if (err == ERROR_SUCCESS) {
			if (m_cNames == m_cAlloc) {
				LPSTR *pNew = (LPSTR *)::MemReAlloc(m_papszNames, (m_cAlloc + cpPerAlloc) * sizeof(LPCSTR));
				if (pNew == NULL) {
					err = ERROR_NOT_ENOUGH_MEMORY;
					break;
				}
				m_cAlloc += cpPerAlloc;
				m_papszNames = pNew;
			}
			LPSTR pszNewName = new char[nlsTempName.strlen()+1];
			if (pszNewName == NULL) {
				err = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}
			::strcpyf(pszNewName, nlsTempName.QueryPch());
			m_papszNames[m_cNames++] = pszNewName;
		}
	}

	return NOERROR;
}


void CLUEnum::Cleanup(void)
{
	if (m_hkeyDB != NULL) {
		RegCloseKey(m_hkeyDB);
		m_hkeyDB = NULL;
	}

	if (m_papszNames != NULL) {
		for (UINT i=0; i<m_cNames; i++) {
			delete m_papszNames[i];
		}
		::MemFree(m_papszNames);
		m_papszNames = NULL;
		m_cNames = 0;
	}
}


STDMETHODIMP CLUEnum::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IEnumUnknown)) {
        *ppvObj = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CLUEnum::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CLUEnum::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}

	return cRef;
}


STDMETHODIMP CLUEnum::Next(ULONG celt, IUnknown __RPC_FAR *__RPC_FAR *rgelt,
						   ULONG __RPC_FAR *pceltFetched)
{
	ULONG celtFetched = 0;
	HRESULT hres = ResultFromScode(S_OK);

	while (celt) {
		if (m_iCurrent == m_cNames) {
			hres = ResultFromScode(S_FALSE);
			break;
		}

		CLUUser *pUser = new CLUUser(m_pDB);
		if (pUser == NULL) {
			hres = ResultFromScode(E_OUTOFMEMORY);
		}
		else {
			hres = pUser->Init(m_papszNames[m_iCurrent]);
		}
		if (FAILED(hres)) {
			for (ULONG i=0; i<celtFetched; i++) {
				rgelt[i]->Release();
			}
			celtFetched = 0;
			if (pUser != NULL)
				pUser->Release();
			break;
		}

		m_iCurrent++;

        /* If this is a name without a real profile attached, don't return
         * it, just go on to the next one.  Advancing m_iCurrent (the index
         * into the name array) above ensures that we won't infinite-loop.
         */
        if (!pUser->Exists()) {
            pUser->Release();
            continue;
        }

		rgelt[celtFetched++] = pUser;
		celt--;
	}

	if (pceltFetched != NULL)
		*pceltFetched = celtFetched;

	return hres;
}


STDMETHODIMP CLUEnum::Skip(ULONG celt)
{
	SCODE sc;

	if (m_iCurrent + celt > m_cNames) {
		m_iCurrent = m_cNames;
		sc = S_FALSE;
	}
	else {
		m_iCurrent += celt;
		sc = S_OK;
	}

	return ResultFromScode(sc);
}


STDMETHODIMP CLUEnum::Reset(void)
{
	Cleanup();
	m_iCurrent = 0;
	return Init();
}


STDMETHODIMP CLUEnum::Clone(IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum)
{
	CLUEnum *pNewEnum = new CLUEnum(m_pDB);

	if (pNewEnum == NULL)
		return ResultFromScode(E_OUTOFMEMORY);

	HRESULT hres = pNewEnum->Init();
	if (FAILED(hres)) {
		pNewEnum->Release();
		return hres;
	}

	if (m_iCurrent == m_cNames) {			/* if at end, new one is at end */
		pNewEnum->m_iCurrent = pNewEnum->m_cNames;
	}
	else {
		LPCSTR pszCurrentName = m_papszNames[m_iCurrent];
		for (UINT i=0; i<pNewEnum->m_cNames; i++) {
			if (!::strcmpf(pszCurrentName, pNewEnum->m_papszNames[i])) {
				pNewEnum->m_iCurrent = i;	/* names match, start here */
				break;
			}
		}
		if (i == pNewEnum->m_cNames)
			pNewEnum->m_iCurrent = 0;		/* current name not found, start at beginning */
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\mslucpl.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"

#include "profiles.h"
#include <npmsg.h>
#include <shellapi.h>

#include "contxids.h"


HRESULT GetLBItemText(HWND hDlg, UINT idCtrl, int iItem, NLS_STR *pnls)
{
    HWND hCtrl = GetDlgItem(hDlg, idCtrl);
    UINT cch = (UINT)SendMessage(hCtrl, LB_GETTEXTLEN, iItem, 0);
    if (pnls->realloc(cch + 1)) {
        SendMessage(hCtrl, LB_GETTEXT, iItem, (LPARAM)(LPSTR)pnls->Party());
        pnls->DonePartying();
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}


void SetErrorFocus(HWND hDlg, UINT idCtrl, BOOL fClear /* = TRUE */)
{
    HWND hCtrl = ::GetDlgItem(hDlg, idCtrl);
    ::SetFocus(hCtrl);
    if (fClear)
        ::SetWindowText(hCtrl, "");
    else
        ::SendMessage(hCtrl, EM_SETSEL, 0, -1);
}


INT_PTR CALLBACK PasswordDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_STATIC1,    IDH_RATINGS_SUPERVISOR_PASSWORD,
        IDC_STATIC2,    IDH_RATINGS_SUPERVISOR_PASSWORD,
        IDC_PASSWORD,   IDH_RATINGS_SUPERVISOR_PASSWORD,
        0,0
    };

    CHAR pszPassword[MAX_PATH];
    HRESULT hRet;

    switch (uMsg) {
        case WM_INITDIALOG:
            {
                HWND hwndCheckbox = GetDlgItem(hDlg, IDC_CACHE_PASSWORD);

                IUserDatabase *pDB = (IUserDatabase *)lParam;
                SetWindowLongPtr(hDlg, DWLP_USER, lParam);
                IUser *pCurrentUser;
                HRESULT hres;
                hres = pDB->GetCurrentUser(&pCurrentUser);
                if (SUCCEEDED(hres)) {
                    DWORD cbBuffer = sizeof(pszPassword);
                    hres = pCurrentUser->GetName(pszPassword, &cbBuffer);
                    if (SUCCEEDED(hres)) {
                        NLS_STR nlsName(STR_OWNERALLOC, pszPassword);
                        NLS_STR nlsTemp(MAX_RES_STR_LEN);
                        const NLS_STR *apnls[] = { &nlsName, NULL };
                        hres = HRESULT_FROM_WIN32(nlsTemp.LoadString(IDS_CACHE_PASSWORD, apnls));
                        if (SUCCEEDED(hres))
                            SetWindowText(hwndCheckbox, nlsTemp.QueryPch());
                    }
                    pCurrentUser->Release();
                }
                if (FAILED(hres)) {
                    ShowWindow(hwndCheckbox, SW_HIDE);
                    EnableWindow(hwndCheckbox, FALSE);
                }
                CheckDlgButton(hDlg, IDC_CACHE_PASSWORD, 0);
            }
            return TRUE;        /* we did not set the focus */

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                break;

            case IDOK:
                GetDlgItemText(hDlg, IDC_PASSWORD, pszPassword, sizeof(pszPassword));
                hRet = VerifySupervisorPassword(pszPassword);

                if (hRet == (NOERROR)) {
                    IUserDatabase *pDB = (IUserDatabase *)GetWindowLongPtr(hDlg, DWLP_USER);
                    IUser *pCurrentUser;
                    if (SUCCEEDED(pDB->GetCurrentUser(&pCurrentUser))) {
                        if (IsDlgButtonChecked(hDlg, IDC_CACHE_PASSWORD)) {
                            pCurrentUser->SetSupervisorPrivilege(TRUE, pszPassword);
                        }
                        else {
                            pCurrentUser->MakeTempSupervisor(TRUE, pszPassword);
                        }
                        pCurrentUser->Release();
                    }

                    EndDialog(hDlg, TRUE);
                }
                else
                {
                    MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                    SetErrorFocus(hDlg, IDC_PASSWORD);
                }
                break;

            default:
                return FALSE;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szRatingsHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, ::szRatingsHelpFile, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID)aIds);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK ChangePasswordDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_STATIC1,            IDH_OLD_PASSWORD,
        IDC_OLD_PASSWORD,       IDH_OLD_PASSWORD,
        IDC_STATIC2,            IDH_NEW_PASSWORD,
        IDC_PASSWORD,           IDH_NEW_PASSWORD,
        IDC_STATIC3,            IDH_CONFIRM_PASSWORD,
        IDC_CONFIRM_PASSWORD,   IDH_CONFIRM_PASSWORD,
        0,0
    };

    CHAR pszPassword[MAX_PATH];
    CHAR pszTempPassword[MAX_PATH];
    CHAR *p = NULL;
    HRESULT hRet;
    HWND hwndPassword;

    switch (uMsg) {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            return TRUE;    /* we didn't set the focus */

        case WM_COMMAND:
            switch (LOWORD(wParam))  {
            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                break;

            case IDOK:
                {
                    IUser *pUser = (IUser *)GetWindowLongPtr(hDlg, DWLP_USER);

                    hwndPassword = ::GetDlgItem(hDlg, IDC_PASSWORD);
                    GetWindowText(hwndPassword, pszPassword, sizeof(pszPassword));
                    GetDlgItemText(hDlg, IDC_CONFIRM_PASSWORD, pszTempPassword, sizeof(pszTempPassword));

                    /* if they've typed just the first password but not the
                     * second, let Enter take them to the second field
                     */
                    if (*pszPassword && !*pszTempPassword && GetFocus() == hwndPassword) {
                        SetErrorFocus(hDlg, IDC_CONFIRM_PASSWORD);
                        break;
                    }

                    if (strcmpf(pszPassword, pszTempPassword))
                    {
                        MsgBox(hDlg, IDS_NO_MATCH, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_CONFIRM_PASSWORD);
                        break;
                    }

                    GetDlgItemText(hDlg, IDC_OLD_PASSWORD, pszTempPassword, sizeof(pszTempPassword));
                    
                    hRet = pUser->ChangePassword(pszTempPassword, pszPassword);
                    
                    if (SUCCEEDED(hRet))
                        EndDialog(hDlg, TRUE);
                    else
                    {
                        MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_OLD_PASSWORD);
                    }
                    
                    break;
                }

            default:
                return FALSE;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID)aIds);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


BOOL DoPasswordConfirm(HWND hwndParent, IUserDatabase *pDB)
{
    return (BOOL)DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PASSWORD), hwndParent, PasswordDialogProc, (LPARAM)pDB);
}


const UINT MAX_PAGES = 1;

class CCPLData
{
public:
    IUserDatabase *m_pDB;
    LPCSTR m_pszNameToDelete;
};


void CPLUserSelected(HWND hwndLB, int iItem)
{
    HWND hDlg = GetParent(hwndLB);
    BOOL fEnableButtons = (iItem != LB_ERR);

    EnableWindow(GetDlgItem(hDlg, IDC_Delete), fEnableButtons);
    EnableWindow(GetDlgItem(hDlg, IDC_Clone), fEnableButtons);
    EnableWindow(GetDlgItem(hDlg, IDC_SetPassword), fEnableButtons);
    EnableWindow(GetDlgItem(hDlg, IDC_OpenProfileFolder), fEnableButtons);

    NLS_STR nlsTemp(MAX_RES_STR_LEN);

    if (fEnableButtons) {
        NLS_STR nlsName;
        if (SUCCEEDED(GetLBItemText(hDlg, IDC_USERNAME, iItem, &nlsName))) {
            const NLS_STR *apnls[] = { &nlsName, NULL };
            if (nlsTemp.LoadString(IDS_SETTINGS_FOR, apnls) != ERROR_SUCCESS)
                nlsTemp = szNULL;
        }
    }
    else {
        if (nlsTemp.LoadString(IDS_SELECTED_USER) != ERROR_SUCCESS)
            nlsTemp = szNULL;
    }
    if (nlsTemp.strlen())
        SetDlgItemText(hDlg, IDC_MAIN_CAPTION, nlsTemp.QueryPch());
}


void ReInitUserList(HWND hDlg, CCPLData *pcpld)
{
    HWND hwndLB = GetDlgItem(hDlg, IDC_USERNAME);

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0);
    DestroyUserList(hwndLB);
    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0);
    FillUserList(hwndLB, pcpld->m_pDB, NULL, FALSE, CPLUserSelected);
    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(hwndLB, NULL, TRUE);
}


void DoCloneUser(HWND hDlg, CCPLData *pcpld, IUser *pUserToClone)
{
    DoAddUserWizard(hDlg, pcpld->m_pDB, FALSE, pUserToClone);

    ReInitUserList(hDlg, pcpld);
}


HRESULT DeleteProgressFunc(LPARAM lParam)
{
    CCPLData *pcpld = (CCPLData *)lParam;

    return pcpld->m_pDB->DeleteUser(pcpld->m_pszNameToDelete);
}


void DoDeleteUser(HWND hDlg, CCPLData *pcpld, int iItem)
{
    NLS_STR nlsName;
    if (FAILED(GetLBItemText(hDlg, IDC_USERNAME, iItem, &nlsName)))
        return;

    const NLS_STR *apnls[] = { &nlsName, NULL };
    if (MsgBox(hDlg, IDS_CONFIRM_DELETE_USER,
               MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2,
               apnls) == IDNO)
        return;

    pcpld->m_pszNameToDelete = nlsName.QueryPch();
    HRESULT hres = CallWithinProgressDialog(hDlg, IDD_DeleteProgress,
                                            DeleteProgressFunc, (LPARAM)pcpld);

    if (SUCCEEDED(hres)) {
        ReInitUserList(hDlg, pcpld);
    }
    else {
        ReportUserError(hDlg, hres);
    }
}


void DoSetPassword(HWND hDlg, CCPLData *pcpld, int iItem)
{
    /* Note, getting pUser this way does not automatically AddRef it */
    IUser *pUser = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);

    if (pUser != NULL) {
        pUser->AddRef();        /* extra AddRef for life of dialog */
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CHANGE_PASSWORD), hDlg, ChangePasswordDialogProc, (LPARAM)pUser))
            MsgBox(hDlg, IDS_PASSWORD_CHANGED, MB_OK | MB_ICONINFORMATION);
        pUser->Release();       /* undo above AddRef */
    }
}


INT_PTR CALLBACK FoldersDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_CHECK_DESKTOP,      IDH_DESKTOP_NETHOOD,
        IDC_CHECK_STARTMENU,    IDH_START_MENU,
        IDC_CHECK_FAVORITES,    IDH_FAVORITES,
        IDC_CHECK_CACHE,        IDH_TEMP_FILES,
        IDC_CHECK_MYDOCS,       IDH_MY_DOCS,
        IDC_RADIO_EMPTY,        IDH_EMPTY_FOLDERS,
        IDC_RADIO_COPY,         IDH_EXISTING_FILES,
        0,0
    };

    switch(message)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))  {
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        case IDOK:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

                pwd->m_fdwCloneFromDefault = IsDlgButtonChecked(hDlg, IDC_RADIO_EMPTY) ? 0 : 0xffffffff;
                pwd->m_fdwNewPerUserFolders = 0;
                if (IsDlgButtonChecked(hDlg, IDC_CHECK_DESKTOP))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_STARTMENU))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_FAVORITES))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_FAVORITES;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_FAVORITES);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_CACHE))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_CACHE;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_CACHE);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_MYDOCS))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_MYDOCS;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_MYDOCS);

                FinishChooseFolders(hDlg, pwd);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            InitFolderCheckboxes(hDlg, pwd);
            CheckRadioButton(hDlg, IDC_RADIO_COPY, IDC_RADIO_EMPTY, IDC_RADIO_COPY);
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)aIds);
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void DoOpenProfileFolder(HWND hDlg, CCPLData *pcpld, int iItem)
{
    /* Note, getting pUser this way does not automatically AddRef it */
    IUser *pUser = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);

#if 0   /* old code to launch Explorer on the user's profile dir */
    if (pUser != NULL) {
        CHAR szHomeDir[MAX_PATH];
        DWORD cbBuffer = sizeof(szHomeDir);

        if (SUCCEEDED(pUser->GetProfileDirectory(szHomeDir, &cbBuffer)) &&
            cbBuffer > 0) {
            TCHAR szArgs[MAX_PATH+4];
            lstrcpy(szArgs, "/e,");
            lstrcat(szArgs, szHomeDir);

            SHELLEXECUTEINFO ei;

            ei.lpFile          = "explorer.exe";
            ei.cbSize          = sizeof(SHELLEXECUTEINFO);
            ei.hwnd            = NULL;
            ei.lpVerb          = NULL;
            ei.lpParameters    = szArgs;
            ei.lpDirectory     = szHomeDir;
            ei.nShow           = SW_SHOWNORMAL;
            ei.fMask           = SEE_MASK_NOCLOSEPROCESS;

            if (ShellExecuteEx(&ei))
            {
                CloseHandle(ei.hProcess);
            }
        }
    }
#else

    if (pUser != NULL) {
        CWizData wd;
        wd.m_pDB = pcpld->m_pDB;
        wd.m_pUserToClone = pUser;
        pUser->AddRef();

        DialogBoxParam(::hInstance, MAKEINTRESOURCE(IDD_ChooseFolders), hDlg, 
                       FoldersDlgProc, (LPARAM)&wd);
    }

#endif
}


INT_PTR CALLBACK UserCPLDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_USERNAME,           IDH_USERS_LIST,
        IDC_Add,                IDH_NEW_USER,
        IDC_Delete,             IDH_REMOVE_USER,
        IDC_Clone,              IDH_COPY_USER,
        IDC_SetPassword,        IDH_SET_PASSWORD,
        IDC_OpenProfileFolder,  IDH_CHANGE_DESKTOP,
        0,0
    };

    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                CPLUserSelected((HWND)lParam, iItem);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            PropSheet_CancelToClose(GetParent(hDlg));
            InitWizDataPtr(hDlg, lParam);
            CCPLData *pcpld = (CCPLData *)(((LPPROPSHEETPAGE)lParam)->lParam);
            FillUserList(GetDlgItem(hDlg, IDC_USERNAME), pcpld->m_pDB, NULL,
                         FALSE, CPLUserSelected);
        }
        break;

    case WM_DESTROY:
        DestroyUserList(GetDlgItem(hDlg, IDC_USERNAME));
        break;

    case WM_COMMAND:
        {
            CCPLData *pcpld = (CCPLData *)GetWindowLongPtr(hDlg, DWLP_USER);
            int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);

            switch (LOWORD(wParam)) {
            case IDC_USERNAME:
                if (HIWORD(wParam) == LBN_SELCHANGE) {
                    CPLUserSelected((HWND)lParam, iItem);
                }
                break;

            case IDC_Add:
                DoCloneUser(hDlg, pcpld, NULL);
                break;

            case IDC_Clone:
                {
                    if (iItem != LB_ERR) {
                        IUser *pUser = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);
                        DoCloneUser(hDlg, pcpld, pUser);
                    }
                }
                break;

            case IDC_Delete:
                DoDeleteUser(hDlg, pcpld, iItem);
                break;

            case IDC_SetPassword:
                DoSetPassword(hDlg, pcpld, iItem);
                break;

            case IDC_OpenProfileFolder:
                DoOpenProfileFolder(hDlg, pcpld, iItem);
                break;

            default:
                return FALSE;
            }   /* switch */
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)aIds);
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


STDMETHODIMP CLUDatabase::UserCPL(HWND hwndParent)
{
    if (ProfileUIRestricted()) {
        ReportRestrictionError(hwndParent);
        return E_ACCESSDENIED;
    }

    CCPLData cpld;
    cpld.m_pDB = this;

    if (!UseUserProfiles() || FAILED(VerifySupervisorPassword(szNULL))) {
        return InstallWizard(hwndParent);
    }
    else {
        BOOL fContinue = TRUE;

        if (IsCurrentUserSupervisor(this) != S_OK) {
            fContinue = DoPasswordConfirm(hwndParent, this);
        }

        if (fContinue) {
            LPPROPSHEETHEADER ppsh;

            // Allocate the property sheet header
            //
            if ((ppsh = (LPPROPSHEETHEADER)LocalAlloc(LMEM_FIXED, sizeof(PROPSHEETHEADER)+
                        (MAX_PAGES * sizeof(HPROPSHEETPAGE)))) != NULL)
            {
                ppsh->dwSize     = sizeof(*ppsh);
                ppsh->dwFlags    = PSH_NOAPPLYNOW;
                ppsh->hwndParent = hwndParent;
                ppsh->hInstance  = ::hInstance;
                ppsh->pszCaption = (LPSTR)IDS_MSGTITLE;
                ppsh->nPages     = 0;
                ppsh->nStartPage = 0;
                ppsh->phpage     = (HPROPSHEETPAGE *)(ppsh+1);

                AddPage(ppsh, IDD_Users, UserCPLDlgProc, &cpld);

                PropertySheet(ppsh);

                LocalFree((HLOCAL)ppsh);
            }
        }
    }

    return NOERROR;
}


void DoUserCPL(HWND hwndParent)
{
    IUserDatabase *pDB = NULL;
    if (FAILED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB)))
        return;

    pDB->UserCPL(hwndParent);

    pDB->Release();
}


extern "C" void UserCPL(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow)
{
    DoUserCPL(hwndParent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\netmpr.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    netmpr.h

Abstract:

    DDK WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:


Revision History:

    20-Mar-1995     LenS
        Created.

--*/

#ifndef _INC_NETMPR_
#define _INC_NETMPR_


//
//  Authentication and Logon/Logoff.
//

#define LOGON_DONE              0x00000001
#define LOGON_PRIMARY           0x00000002
#define LOGON_MUST_VALIDATE     0x00000004

#define LOGOFF_PENDING  1
#define LOGOFF_COMMIT   2
#define LOGOFF_CANCEL   3


//
//  Password Cache.
//

#ifndef PCE_STRUCT_DEFINED
#define PCE_STRUCT_DEFINED

struct PASSWORD_CACHE_ENTRY {
    WORD cbEntry;               /* size of this entry in bytes, incl. pad */
    WORD cbResource;            /* size of resource name in bytes */
    WORD cbPassword;            /* size of password in bytes */
    BYTE iEntry;                /* index number of this entry, for MRU */
    BYTE nType;                 /* type of entry (see below) */
    char abResource[1];         /* resource name (may not be ASCIIZ at all) */
};

#define PCE_MEMORYONLY          0x01    /* for flags field when adding */

/*
    Typedef for the callback routine passed to the enumeration functions.
    It will be called once for each entry that matches the criteria
    requested.  It returns TRUE if it wants the enumeration to
    continue, FALSE to stop.
*/
typedef BOOL (FAR PASCAL *CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData );

#endif  /* PCE_STRUCT_DEFINED */

DWORD APIENTRY
WNetCachePassword(
    LPSTR pbResource,
    WORD  cbResource,
    LPSTR pbPassword,
    WORD  cbPassword,
    BYTE  nType,
    UINT  fnFlags
    );

DWORD APIENTRY
WNetGetCachedPassword(
    LPSTR  pbResource,
    WORD   cbResource,
    LPSTR  pbPassword,
    LPWORD pcbPassword,
    BYTE   nType
    );

DWORD APIENTRY
WNetRemoveCachedPassword(
    LPSTR pbResource,
    WORD  cbResource,
    BYTE  nType
    );

DWORD APIENTRY
WNetEnumCachedPasswords(
    LPSTR pbPrefix,
    WORD  cbPrefix,
    BYTE  nType,
    CACHECALLBACK pfnCallback,
    DWORD dwRefData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\msluuser.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include <buffer.h>
#include <regentry.h>
#include "profiles.h"

extern "C" {
#include "netmpr.h"
};

#include <ole2.h>

CLUUser::CLUUser(CLUDatabase *pDB)
	: m_cRef(1),
	  m_hkeyDB(NULL),
	  m_hkeyUser(NULL),
	  m_fUserExists(FALSE),
	  m_fAppearsSupervisor(FALSE),
      m_fLoadedProfile(FALSE),
	  m_nlsUsername(),
	  m_nlsDir(MAX_PATH),
	  m_nlsPassword(),
	  m_fAuthenticated(FALSE),
	  m_pDB(pDB)
{
	/* We have a reference to the database so we can get back to its idea
	 * of the current user.  We handle circular refcount problems specifically
	 * in CLUDatabase::Release;  the database only has one reference to an
	 * IUser, so if his refcount gets down to 1, he releases his cached
	 * current-user object.
	 */
	m_pDB->AddRef();

    RefThisDLL(TRUE);
}


CLUUser::~CLUUser(void)
{
	if (m_hkeyDB != NULL)
		RegCloseKey(m_hkeyDB);

	if (m_hkeyUser != NULL)
		RegCloseKey(m_hkeyUser);

	if (m_pDB != NULL)
		m_pDB->Release();

    RefThisDLL(FALSE);
}


HRESULT CLUUser::Init(LPCSTR pszUsername)
{
	m_nlsUsername = pszUsername;

	UINT err = m_nlsUsername.QueryError();
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	err = m_nlsDir.QueryError();
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	err = (UINT)RegOpenKey(HKEY_LOCAL_MACHINE, ::szProfileList, &m_hkeyDB);
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	if (!::strcmpf(pszUsername, ::szDefaultUserName)) {
		m_fUserExists = TRUE;
		m_fAppearsSupervisor = FALSE;
	}
	else {
		err = (UINT)RegOpenKey(m_hkeyDB, pszUsername, &m_hkeyUser);
		if (err != ERROR_SUCCESS) {
			m_hkeyUser = NULL;
			m_fUserExists = FALSE;
		}
		else {
			DWORD cb = sizeof(m_fAppearsSupervisor);
			if (RegQueryValueEx(m_hkeyUser, ::szSupervisor, NULL, NULL,
								(LPBYTE)&m_fAppearsSupervisor, &cb) != ERROR_SUCCESS) {
				m_fAppearsSupervisor = FALSE;
			}
			DWORD cbDir = m_nlsDir.QueryAllocSize();
			LPBYTE pbDir = (LPBYTE)m_nlsDir.Party();
			err = RegQueryValueEx(m_hkeyUser, ::szProfileImagePath, NULL, NULL,
								  pbDir, &cbDir);
			if (err != ERROR_SUCCESS)
				*pbDir = '\0';
			m_nlsDir.DonePartying();
            m_fUserExists = (err == ERROR_SUCCESS);
		}
	}

	return NOERROR;
}


STDMETHODIMP CLUUser::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IUser)) {
        *ppvObj = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CLUUser::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CLUUser::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}

	return cRef;
}


STDMETHODIMP CLUUser::GetName(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	if (m_nlsUsername.QueryError())
		return ResultFromScode(E_OUTOFMEMORY);

	UINT err = NPSCopyNLS(&m_nlsUsername, pbBuffer, pcbBuffer);

	return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CLUUser::GetProfileDirectory(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	if (m_nlsDir.QueryError())
		return ResultFromScode(E_OUTOFMEMORY);

	if (!m_nlsDir.strlen())
		return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

	UINT err = NPSCopyNLS(&m_nlsDir, pbBuffer, pcbBuffer);

	return HRESULT_FROM_WIN32(err);
}


BOOL CLUUser::IsSystemCurrentUser(void)
{
    NLS_STR nlsSystemUsername(MAX_PATH);
    if (nlsSystemUsername.QueryError() == ERROR_SUCCESS) {
        if (SUCCEEDED(GetSystemCurrentUser(&nlsSystemUsername)) &&
            !m_nlsUsername.stricmp(nlsSystemUsername)) {
            return TRUE;
        }
    }
    return FALSE;
}


HRESULT CLUUser::GetSupervisorPassword(BUFFER *pbufOut)
{
	LPSTR pBuffer = (LPSTR)pbufOut->QueryPtr();

	if (!m_fAuthenticated) {
        if (IsSystemCurrentUser()) {
            WORD cbBuffer = (WORD)pbufOut->QuerySize();
            APIERR err = WNetGetCachedPassword((LPSTR)::szSupervisorPWLKey,
                                               (WORD)::strlenf(::szSupervisorPWLKey),
            								   pBuffer,
            								   &cbBuffer,
            								   PCE_MISC);
            if (err == ERROR_SUCCESS)
                return S_OK;
            if (err == WN_CANCEL)
                return S_FALSE;
            return HRESULT_FROM_WIN32(err);
        }
		return HRESULT_FROM_WIN32(ERROR_NOT_AUTHENTICATED);
    }

	HPWL hPWL;
	HRESULT hres = GetPasswordCache(m_nlsPassword.QueryPch(), &hPWL);
	if (FAILED(hres))
		return hres;

	APIERR err = FindCacheResource(hPWL, ::szSupervisorPWLKey,
								   (WORD)::strlenf(::szSupervisorPWLKey),
								   pBuffer,
								   (WORD)pbufOut->QuerySize(),
								   PCE_MISC);
	::ClosePasswordCache(hPWL, TRUE);

	if (err == IERR_CacheEntryNotFound)
		return S_FALSE;
	else if (err != NOERROR)
		return HRESULT_FROM_WIN32(err);

	CACHE_ENTRY_INFO *pcei = (CACHE_ENTRY_INFO *)pBuffer;
	::memmovef(pBuffer, pBuffer + pcei->dchPassword, pcei->cbPassword);

	return NOERROR;
}


STDMETHODIMP CLUUser::IsSupervisor(void)
{
    /* If the supervisor password is blank, then everybody's a supervisor */
    if (::VerifySupervisorPassword(::szNULL) == S_OK)
        return S_OK;

    /* If temporary supervisor privilege has been granted to this user object,
     * honor it.
     */

    if (m_fTempSupervisor)
        return S_OK;

	BUFFER bufPCE(MAX_ENTRY_SIZE+2);
	if (bufPCE.QueryPtr() == NULL)
		return E_OUTOFMEMORY;

	HRESULT hres = GetSupervisorPassword(&bufPCE);

	if (hres != S_OK)
		return hres;

	return ::VerifySupervisorPassword((LPCSTR)bufPCE.QueryPtr());
}


APIERR MakeSupervisor(HPWL hPWL, LPCSTR pszSupervisorPassword)
{
#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD
	return ::AddCacheResource(hPWL,
							  ::szSupervisorPWLKey,
							  ::strlenf(::szSupervisorPWLKey),
							  pszSupervisorPassword,
							  ::strlenf(pszSupervisorPassword)+1,
							  PCE_MISC, 0);
#else
    return ERROR_SUCCESS;
#endif
}


STDMETHODIMP CLUUser::SetSupervisorPrivilege(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
{
	if (m_pDB == NULL)
		return E_UNEXPECTED;

#ifndef MSLOCUSR_USE_SUPERVISOR_PASSWORD

    /* Don't write stuff to the user's password cache if we're not doing any
     * supervisor password stuff.
     */
    m_fAppearsSupervisor = fMakeSupervisor;
    return S_OK;

#else

	BUFFER bufPCE(MAX_ENTRY_SIZE+2);
	if (bufPCE.QueryPtr() == NULL)
		return E_OUTOFMEMORY;

    HRESULT hres = S_OK;

    /* If supervisor password is provided by the caller, use that, otherwise
     * inspect the current user's password cache.
     */
    if (pszSupervisorPassword == NULL) {
    	IUser *pCurrentUser;
	    if (FAILED(m_pDB->GetCurrentUser(&pCurrentUser)))
		    return E_ACCESSDENIED;

    	hres = ((CLUUser *)pCurrentUser)->GetSupervisorPassword(&bufPCE);
        pCurrentUser->Release();
        pszSupervisorPassword = (LPCSTR)bufPCE.QueryPtr();
    }

	if (SUCCEEDED(hres)) {
		hres = ::VerifySupervisorPassword(pszSupervisorPassword);
		if (hres == S_OK) {		/* not SUCCEEDED because S_FALSE means wrong PW */
			HPWL hpwlThisUser;
			hres = GetPasswordCache(m_nlsPassword.QueryPch(), &hpwlThisUser);
			if (SUCCEEDED(hres)) {
				APIERR err;
				if (fMakeSupervisor)
				{
					err = ::MakeSupervisor(hpwlThisUser, pszSupervisorPassword);
				}
				else {
					err = ::DeleteCacheResource(hpwlThisUser,
												::szSupervisorPWLKey,
												::strlenf(::szSupervisorPWLKey),
												PCE_MISC);
				}
				::ClosePasswordCache(hpwlThisUser, TRUE);

				hres = HRESULT_FROM_WIN32(err);
			}
            else if (!m_fAuthenticated && IsSystemCurrentUser()) {
                APIERR err;
                if (fMakeSupervisor) {
                    err = ::WNetCachePassword(
							  (LPSTR)::szSupervisorPWLKey,
							  ::strlenf(::szSupervisorPWLKey),
							  (LPSTR)pszSupervisorPassword,
							  ::strlenf(pszSupervisorPassword)+1,
							  PCE_MISC, 0);
                }
                else {
					err = ::WNetRemoveCachedPassword(
												(LPSTR)::szSupervisorPWLKey,
												::strlenf(::szSupervisorPWLKey),
												PCE_MISC);
                }
				hres = HRESULT_FROM_WIN32(err);
            }

			if (SUCCEEDED(hres)) {
				m_fAppearsSupervisor = fMakeSupervisor;
				if (m_hkeyUser != NULL)
					RegSetValueEx(m_hkeyUser, ::szSupervisor, NULL,
								  REG_DWORD, (LPBYTE)&m_fAppearsSupervisor,
								  sizeof(m_fAppearsSupervisor));
			}
		}
	}

	return hres;

#endif
}


STDMETHODIMP CLUUser::MakeTempSupervisor(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
{
    if (!fMakeSupervisor)
        m_fTempSupervisor = FALSE;
    else {
        HRESULT hres = ::VerifySupervisorPassword(pszSupervisorPassword);
        if (hres == S_FALSE)
            hres = E_ACCESSDENIED;
        if (FAILED(hres))
            return hres;

        m_fTempSupervisor = TRUE;
    }

    return S_OK;
}


STDMETHODIMP CLUUser::AppearsSupervisor(void)
{
    if (m_fTempSupervisor)
        return S_OK;

	return m_fAppearsSupervisor ? S_OK : S_FALSE;
}


STDMETHODIMP CLUUser::Authenticate(LPCSTR pszPassword)
{
	HPWL hPWL = NULL;

	HRESULT hres = GetPasswordCache(pszPassword, &hPWL);
	if (FAILED(hres))
		return hres;

	::ClosePasswordCache(hPWL, TRUE);

	return NOERROR;
}


STDMETHODIMP CLUUser::ChangePassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
{
	//  if current user is supervisor, allow null pszOldPassword

    NLS_STR nlsNewPassword(pszNewPassword);
    if (nlsNewPassword.QueryError())
        return HRESULT_FROM_WIN32(nlsNewPassword.QueryError());
    nlsNewPassword.strupr();
    nlsNewPassword.ToOEM();

	HPWL hPWL;

	HRESULT hres = GetPasswordCache(pszOldPassword, &hPWL);

	if (FAILED(hres))
		return hres;

	hres = HRESULT_FROM_WIN32(::SetCachePassword(hPWL, nlsNewPassword.QueryPch()));

	if (SUCCEEDED(hres)) {
		m_nlsPassword = pszNewPassword;	/* FEATURE - obfuscate me */
		m_fAuthenticated = TRUE;
	}

	::ClosePasswordCache(hPWL, TRUE);

	return hres;
}


HRESULT GetUserPasswordCache(LPCSTR pszUsername, LPCSTR pszPassword, LPHANDLE phOut, BOOL fCreate)
{
	NLS_STR nlsUsername(pszUsername);
	if (nlsUsername.QueryError())
		return HRESULT_FROM_WIN32(nlsUsername.QueryError());

	nlsUsername.strupr();
	nlsUsername.ToOEM();

	NLS_STR nlsPassword(pszPassword);
	if (nlsPassword.QueryError())
		return HRESULT_FROM_WIN32(nlsPassword.QueryError());

	nlsPassword.ToOEM();

	*phOut = NULL;
	UINT err = ::OpenPasswordCache(phOut, nlsUsername.QueryPch(), nlsPassword.QueryPch(), TRUE);

    if (fCreate &&
        (err == IERR_UsernameNotFound || err == ERROR_FILE_NOT_FOUND ||
         err == ERROR_PATH_NOT_FOUND)) {
   		err = ::CreatePasswordCache(phOut, nlsUsername.QueryPch(), nlsPassword.QueryPch());
    }

	if (err == IERR_IncorrectUsername) {
		nlsPassword.ToAnsi();			/* must convert to OEM to uppercase properly */
		nlsPassword.strupr();
		nlsPassword.ToOEM();
		err = ::OpenPasswordCache(phOut, nlsUsername.QueryPch(), nlsPassword.QueryPch(), TRUE);
	}

	if (err)
		return HRESULT_FROM_WIN32(err);

    return S_OK;
}


STDMETHODIMP CLUUser::GetPasswordCache(LPCSTR pszPassword, LPHANDLE phOut)
{
    HRESULT hres = ::GetUserPasswordCache(m_nlsUsername.QueryPch(), pszPassword,
                                          phOut, TRUE);
    if (FAILED(hres))
        return hres;

	m_nlsPassword = pszPassword;	/* FEATURE - obfuscate me */
	m_fAuthenticated = TRUE;

	return NOERROR;
}


STDMETHODIMP CLUUser::LoadProfile(HKEY *phkeyUser)
{
    if (IsSystemCurrentUser() ||
        !::strcmpf(m_nlsUsername.QueryPch(), ::szDefaultUserName)) {
        /* If he's the current or default user, his profile should be loaded
         * under HKEY_USERS.  If it is, we can return that key.  Otherwise,
         * we'll need to load it.
         */
        if (RegOpenKeyEx(HKEY_USERS, m_nlsUsername.QueryPch(), 0,
                         KEY_READ | KEY_WRITE, phkeyUser) == ERROR_SUCCESS) {
            m_fLoadedProfile = FALSE;
            return S_OK;
        }
    }
    else {
        if (IsCurrentUserSupervisor(m_pDB) != S_OK)
	    	return E_ACCESSDENIED;
    }

    RegEntry reRoot(::szProfileList, HKEY_LOCAL_MACHINE);
    if (reRoot.GetError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(reRoot.GetError());

    reRoot.MoveToSubKey(m_nlsUsername.QueryPch());
    if (reRoot.GetError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(reRoot.GetError());

    NLS_STR nlsProfilePath(MAX_PATH);
    if (nlsProfilePath.QueryError() != ERROR_SUCCESS)
        return E_OUTOFMEMORY;

    reRoot.GetValue(::szProfileImagePath, &nlsProfilePath);
    if (reRoot.GetError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(reRoot.GetError());

    AddBackslash(nlsProfilePath);
    nlsProfilePath.strcat(::szStdNormalProfile);
    if (!FileExists(nlsProfilePath.QueryPch()))
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    LONG err = ::MyRegLoadKey(HKEY_USERS, m_nlsUsername.QueryPch(), nlsProfilePath.QueryPch());
    if (err == ERROR_SUCCESS) {
        HKEY hkeyNewProfile;
        err = ::RegOpenKey(HKEY_USERS, m_nlsUsername.QueryPch(), phkeyUser);
        if (err != ERROR_SUCCESS) {
            ::RegUnLoadKey(HKEY_USERS, m_nlsUsername.QueryPch());
        }
        else {
            m_fLoadedProfile = TRUE;
        }
    }

    return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CLUUser::UnloadProfile(HKEY hkeyUser)
{
    RegFlushKey(hkeyUser);
    RegCloseKey(hkeyUser);

    if (m_fLoadedProfile) {
        RegUnLoadKey(HKEY_USERS, m_nlsUsername.QueryPch());
        m_fLoadedProfile = FALSE;
    }
    return S_OK;
}


STDMETHODIMP CLUUser::GetComponentSettings(REFCLSID clsidComponent,
										   LPCSTR pszName, IUnknown **ppOut,
										   DWORD fdwAccess)
{
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CLUUser::EnumerateComponentSettings(IEnumUnknown **ppOut,
											     DWORD fdwAccess)
{
	return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\msluobj.cpp ===
#include "mslocusr.h"
#include "msluglob.h"


STDMETHODIMP CLUClassFactory::QueryInterface(
	/* [in] */ REFIID riid,
	/* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
	*ppvObject = NULL;

	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IClassFactory)) {
		*ppvObject = (LPVOID)this;
		AddRef();
		return NOERROR;
	}
	return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CLUClassFactory::AddRef(void)
{
	RefThisDLL(TRUE);

	return 1;
}


STDMETHODIMP_(ULONG) CLUClassFactory::Release(void)
{
	RefThisDLL(FALSE);

	return 1;
}


HRESULT CreateUserDatabase(REFIID riid, void **ppOut)
{
	CLUDatabase *pObj = new CLUDatabase;

	if (NULL == pObj)
		return ResultFromScode(E_OUTOFMEMORY);

	HRESULT hr = pObj->QueryInterface(riid, ppOut);

	if (FAILED(hr)) {
		delete pObj;
	}
	else {
		pObj->AddRef();
	}

	return NOERROR;
}


STDMETHODIMP CLUClassFactory::CreateInstance(
	/* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
	/* [in] */ REFIID riid,
	/* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
	if (NULL != pUnkOuter)
		return ResultFromScode(CLASS_E_NOAGGREGATION);

	return CreateUserDatabase(riid, ppvObject);
}

        
STDMETHODIMP CLUClassFactory::LockServer( 
	/* [in] */ BOOL fLock)
{
	LockThisDLL(fLock);

	return NOERROR;
}


/* This function signals our stub NP DLL in MPREXE's context to load or
 * unload MSLOCUSR as a net provider DLL.  This way, when we uninstall,
 * DllUnregisterServer can get MSLOCUSR unloaded from MPREXE's process
 * space, so it can be deleted and upgraded.  Then, DllRegisterServer
 * will tell the stub NP to reload MSLOCUSR again.
 */
void SignalStubNP(BOOL fLoad)
{
    HWND hwnd = FindWindow("WndClass_NPSTUBMonitor", NULL);
    if (hwnd != NULL) {
        SendMessage(hwnd, fLoad ? WM_USER : (WM_USER+1), 0, 0);
    }
}


extern "C" {

STDAPI DllRegisterServer(void)
{
	HKEY hkeyCLSID;
	HKEY hkeyOurs;
	HKEY hkeyInproc;
	LONG err;

	err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
		err = ::RegCreateKey(hkeyCLSID, ::szOurCLSID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
			err = ::RegCreateKey(hkeyOurs, ::szINPROCSERVER32, &hkeyInproc);
			if (err == ERROR_SUCCESS) {
				err = ::RegSetValueEx(hkeyInproc, NULL, 0, REG_EXPAND_SZ,
									  (LPBYTE)::szDLLNAME, ::strlenf(::szDLLNAME));
				if (err == ERROR_SUCCESS) {
					err = ::RegSetValueEx(hkeyInproc, ::szTHREADINGMODEL, 0,
										  REG_SZ, (LPBYTE)::szAPARTMENT,
										  ::strlenf(::szAPARTMENT));
				}
				::RegCloseKey(hkeyInproc);
			}

			::RegCloseKey(hkeyOurs);
		}

		::RegCloseKey(hkeyCLSID);
	}

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}


STDAPI DllUnregisterServer(void)
{
	HKEY hkeyCLSID;
	HKEY hkeyOurs;
	LONG err;

	err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
		err = ::RegOpenKey(hkeyCLSID, ::szOurCLSID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
			err = ::RegDeleteKey(hkeyOurs, ::szINPROCSERVER32);

			::RegCloseKey(hkeyOurs);

			if (err == ERROR_SUCCESS)
				err = ::RegDeleteKey(hkeyCLSID, ::szOurCLSID);
		}

		::RegCloseKey(hkeyCLSID);
	}

    DeinstallLogonDialog();

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}


STDAPI DllInstall(BOOL fInstall, LPCSTR psz)
{
    SignalStubNP(fInstall);
    return S_OK;
}


STDAPI DllCanUnloadNow(void)
{
	SCODE sc;

	sc = (0 == g_cRefThisDll && 0 == g_cLocks) ? S_OK : S_FALSE;
	return ResultFromScode(sc);
}


STDAPI DllGetClassObject(
	REFCLSID rclsid,
	REFIID riid,
	LPVOID FAR *ppv)
{
	if (!IsEqualCLSID(rclsid, CLSID_LocalUsers)) {
		return ResultFromScode(E_FAIL);
	}

	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IClassFactory)) {
		return ResultFromScode(E_NOINTERFACE);
	}

	static CLUClassFactory cf;

	*ppv = (LPVOID)&cf;

	cf.AddRef();

	return NOERROR;
}

};	/* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\msluwiz.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"

#include <regentry.h>
#include "profiles.h"
#include <npmsg.h>

extern "C" void SHFlushSFCache(void);

void ReportUserError(HWND hwndParent, HRESULT hres)
{
    if (SUCCEEDED(hres))
        return;

    UINT idMsg;
    NLS_STR nlsSub(16);     /* long enough for any 32-bit number, any format */

    if ((((DWORD)hres) >> 16) == (FACILITY_WIN32 | 0x8000)) {
        UINT err = (hres & 0xffff);

        switch (err) {
        case ERROR_ACCESS_DENIED:       idMsg = IDS_E_ACCESSDENIED; break;
        case ERROR_NOT_AUTHENTICATED:   idMsg = IDS_ERROR_NOT_AUTHENTICATED; break;
        case ERROR_NO_SUCH_USER:        idMsg = IDS_ERROR_NO_SUCH_USER; break;
        case ERROR_USER_EXISTS:         idMsg = IDS_ERROR_USER_EXISTS; break;
        case ERROR_NOT_ENOUGH_MEMORY:   idMsg = IDS_ERROR_OUT_OF_MEMORY; break;
        case ERROR_BUSY:                idMsg = IDS_ERROR_BUSY; break;
        case ERROR_PATH_NOT_FOUND:      idMsg = IDS_ERROR_PATH_NOT_FOUND; break;
        case ERROR_BUFFER_OVERFLOW:     idMsg = IDS_ERROR_BUFFER_OVERFLOW; break;
        case IERR_CachingDisabled:      idMsg = IDS_IERR_CachingDisabled; break;
        case IERR_BadSig:               idMsg = IDS_IERR_BadSig; break;
        case IERR_CacheReadOnly :       idMsg = IDS_IERR_CacheReadOnly; break;
        case IERR_IncorrectUsername:    idMsg = IDS_IERR_IncorrectUsername; break;
        case IERR_CacheCorrupt:         idMsg = IDS_IERR_CacheCorrupt; break;
        case IERR_UsernameNotFound:     idMsg = IDS_IERR_UsernameNotFound; break;
        case IERR_CacheFull:            idMsg = IDS_IERR_CacheFull; break;
        case IERR_CacheAlreadyOpen:     idMsg = IDS_IERR_CacheAlreadyOpen; break;

        default:
            idMsg = IDS_UNKNOWN_ERROR;
            wsprintf(nlsSub.Party(), "%d", err);
            nlsSub.DonePartying();
            break;
        }
    }
    else {
        switch(hres) {
        case E_OUTOFMEMORY:             idMsg = IDS_ERROR_OUT_OF_MEMORY; break;
//        case E_ACCESSDENIED:            idMsg = IDS_E_ACCESSDENIED; break;

        default:
            idMsg = IDS_UNKNOWN_ERROR;
            wsprintf(nlsSub.Party(), "0x%x", hres);
            nlsSub.DonePartying();
            break;
        }
    }

    const NLS_STR *apnls[] = { &nlsSub, NULL };

    MsgBox(hwndParent, idMsg, MB_OK | MB_ICONSTOP, apnls);
}


const UINT MAX_WIZ_PAGES = 8;

#if 0   /* now in mslocusr.h */
class CWizData : public IUserProfileInit
{
public:
    HRESULT m_hresRatings;          /* result of VerifySupervisorPassword("") */
    BOOL m_fGoMultiWizard;          /* TRUE if this is the big go-multiuser wizard */
    NLS_STR m_nlsSupervisorPassword;
    NLS_STR m_nlsUsername;
    NLS_STR m_nlsUserPassword;
    IUserDatabase *m_pDB;
    IUser *m_pUserToClone;
    int m_idPrevPage;               /* ID of page before Finish */
    UINT m_cRef;
    DWORD m_fdwOriginalPerUserFolders;
    DWORD m_fdwNewPerUserFolders;
    DWORD m_fdwCloneFromDefault;
    BOOL m_fCreatingProfile;

    CWizData();
    ~CWizData();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
    STDMETHODIMP PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
};
#endif


CWizData::CWizData()
    : m_nlsSupervisorPassword(),
      m_nlsUsername(),
      m_nlsUserPassword(),
      m_cRef(0),
      m_fdwOriginalPerUserFolders(0),
      m_fdwNewPerUserFolders(0),
      m_fdwCloneFromDefault(0),
      m_fCreatingProfile(FALSE)
{

}


CWizData::~CWizData()
{
    if (m_pUserToClone != NULL)
        m_pUserToClone->Release();
}


STDMETHODIMP CWizData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IUserProfileInit)) {
        *ppvObj = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    *ppvObj = this;
    AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CWizData::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CWizData::Release(void)
{
    ULONG cRef;

    cRef = --m_cRef;

    if (0L == m_cRef) {
        delete this;
    }

    return cRef;
}


void LimitCredentialLength(HWND hDlg, UINT idCtrl)
{
    SendDlgItemMessage(hDlg, idCtrl, EM_LIMITTEXT, (WPARAM)cchMaxUsername, 0);
}


void AddPage(LPPROPSHEETHEADER ppsh, UINT id, DLGPROC pfn, LPVOID pwd)
{
    if (ppsh->nPages < MAX_WIZ_PAGES)
    {
        PROPSHEETPAGE psp;

        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = ::hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(id);
        psp.pfnDlgProc  = pfn;
        psp.lParam      = (LPARAM)pwd;

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
        if (ppsh->phpage[ppsh->nPages])
            ppsh->nPages++;
    }
}  // AddPage


INT_PTR CALLBACK IntroDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                break;
            }

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void GoToPage(HWND hDlg, int idPage)
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, idPage);
}


inline void FailChangePage(HWND hDlg)
{
    GoToPage(hDlg, -1);
}


void InitWizDataPtr(HWND hDlg, LPARAM lParam)
{
    CWizData *pwd = (CWizData *)(((LPPROPSHEETPAGE)lParam)->lParam);
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pwd);
}


void InsertControlText(HWND hDlg, UINT idCtrl, const NLS_STR *pnlsInsert)
{
    int cchText = GetWindowTextLength(GetDlgItem(hDlg, IDC_MAIN_CAPTION)) + pnlsInsert->strlen() + 1;
    NLS_STR nlsTemp(MAX_RES_STR_LEN);
    if (nlsTemp.QueryError() == ERROR_SUCCESS) {
        GetDlgItemText(hDlg, idCtrl, nlsTemp.Party(), nlsTemp.QueryAllocSize());
        nlsTemp.DonePartying();
        const NLS_STR *apnls[] = { pnlsInsert, NULL };
        nlsTemp.InsertParams(apnls);
        if (nlsTemp.QueryError() == ERROR_SUCCESS)
            SetDlgItemText(hDlg, idCtrl, nlsTemp.QueryPch());
    }
}


HRESULT GetControlText(HWND hDlg, UINT idCtrl, NLS_STR *pnls)
{
    HWND hCtrl = GetDlgItem(hDlg, idCtrl);
    if (pnls->realloc(GetWindowTextLength(hCtrl) + 1)) {
        GetWindowText(hCtrl, pnls->Party(), pnls->QueryAllocSize());
        pnls->DonePartying();
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}


INT_PTR CALLBACK EnterCAPWDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                if (SUCCEEDED(GetControlText(hDlg, IDC_PASSWORD, &pwd->m_nlsSupervisorPassword))) {
                    if (VerifySupervisorPassword(pwd->m_nlsSupervisorPassword.QueryPch()) == S_FALSE) {
                        MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_PASSWORD);
                        FailChangePage(hDlg);
                    }
                }
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        InitWizDataPtr(hDlg, lParam);
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


INT_PTR CALLBACK EnterUserPWDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                if (SUCCEEDED(GetControlText(hDlg, IDC_PASSWORD, &pwd->m_nlsUserPassword))) {
                    HANDLE hPWL = NULL;
                    if (FAILED(::GetUserPasswordCache(pwd->m_nlsUsername.QueryPch(),
                                                      pwd->m_nlsUserPassword.QueryPch(),
                                                      &hPWL, TRUE))) {
                        MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_PASSWORD);
                        FailChangePage(hDlg);
                    }
                    else {
                        if (FAILED(pwd->m_hresRatings))
                            pwd->m_nlsSupervisorPassword = pwd->m_nlsUserPassword;
                        pwd->m_idPrevPage = IDD_EnterUserPassword;
                        ::ClosePasswordCache(hPWL, TRUE);
                        int idNextPage;
                        if (pwd->m_fCreatingProfile)
                            idNextPage = IDD_ChooseFoldersWiz;
                        else
                            idNextPage = (pwd->m_fGoMultiWizard) ? IDD_FinishGoMulti : IDD_FinishAddUser;
                        GoToPage(hDlg, idNextPage);
                    }
                }
            }
            break;

        case PSN_WIZBACK:
            GoToPage(hDlg, IDD_EnterUsername);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
            InsertControlText(hDlg, IDC_MAIN_CAPTION, &pwd->m_nlsUsername);

            LimitCredentialLength(hDlg, IDC_PASSWORD);

            if (FAILED(pwd->m_hresRatings)) {
                NLS_STR nlsTemp(MAX_RES_STR_LEN);
                if (nlsTemp.QueryError() == ERROR_SUCCESS) {
                    nlsTemp.LoadString(IDS_RATINGS_PW_COMMENT);
                    if (nlsTemp.QueryError() == ERROR_SUCCESS)
                        SetDlgItemText(hDlg, IDC_RATINGS_PW_COMMENT, nlsTemp.QueryPch());
                }
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


INT_PTR CALLBACK EnterUsernameDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case PSN_WIZNEXT:
            {
                int cchUsername = GetWindowTextLength(GetDlgItem(hDlg, IDC_USERNAME));
                if (!cchUsername) {
                    MsgBox(hDlg, IDS_BLANK_USERNAME, MB_OK | MB_ICONSTOP);
                    SetErrorFocus(hDlg, IDC_USERNAME, FALSE);
                    FailChangePage(hDlg);
                }
                else {
                    CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                    if (SUCCEEDED(GetControlText(hDlg, IDC_USERNAME, &pwd->m_nlsUsername))) {
                        /* If we're in the add-user wizard, fail if the user
                         * already exists.  In the go-multiuser wizard, we
                         * just use the info to determine whether to offer
                         * the folder-personalization page.
                         */
                        IUser *pUser = NULL;
                        if (SUCCEEDED(pwd->m_pDB->GetUser(pwd->m_nlsUsername.QueryPch(), &pUser))) {
                            pUser->Release();
                            if (!pwd->m_fGoMultiWizard) {
                                const NLS_STR *apnls[] = { &pwd->m_nlsUsername, NULL };
                                if (MsgBox(hDlg, IDS_USER_EXISTS, MB_OKCANCEL | MB_ICONSTOP, apnls) == IDCANCEL) {
                                    PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                                    break;
                                }
                                SetErrorFocus(hDlg, IDC_USERNAME, FALSE);
                                FailChangePage(hDlg);
                                break;
                            }
                            else {
                                pwd->m_fCreatingProfile = FALSE;
                            }
                        }
                        else {
                            pwd->m_fCreatingProfile = TRUE;
                        }

                        /* See if the user already has a PWL.  If not, next
                         * page is to enter and confirm a password.  If there
                         * is a PWL and its password is non-blank, next page
                         * is simply to enter the password.  If there's a PWL
                         * and its password is blank, next page is Finish.
                         */
                        int idNextPage;
                        HANDLE hPWL = NULL;
                        HRESULT hres = ::GetUserPasswordCache(pwd->m_nlsUsername.QueryPch(),
                                                              szNULL, &hPWL, FALSE);
                        if (SUCCEEDED(hres)) {
                            ::ClosePasswordCache(hPWL, TRUE);
                            pwd->m_idPrevPage = IDD_EnterUsername;
                            if (pwd->m_fCreatingProfile)
                                idNextPage = IDD_ChooseFoldersWiz;
                            else
                                idNextPage = (pwd->m_fGoMultiWizard) ? IDD_FinishGoMulti : IDD_FinishAddUser;
                        }
                        else if (hres == HRESULT_FROM_WIN32(IERR_IncorrectUsername)) {
                            idNextPage = IDD_EnterUserPassword;
                        }
                        else {
                            idNextPage = IDD_NewUserPassword;
                        }
                        GoToPage(hDlg, idNextPage);
                    }
                }
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            LimitCredentialLength(hDlg, IDC_USERNAME);

            if (pwd->m_fGoMultiWizard) {
                NLS_STR nlsText(MAX_RES_STR_LEN);
                if (nlsText.QueryError() == ERROR_SUCCESS) {
                    nlsText.LoadString(IDS_ENTER_FIRST_USERNAME);
                    if (nlsText.QueryError() == ERROR_SUCCESS)
                        SetDlgItemText(hDlg, IDC_MAIN_CAPTION, nlsText.QueryPch());
                }
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void PickUserSelected(HWND hwndLB, int iItem)
{
    HWND hDlg = GetParent(hwndLB);

    if (iItem == LB_ERR) {
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else {
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
    }
}


INT_PTR CALLBACK PickUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                PickUserSelected((HWND)lParam, iItem);
            }
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                if (iItem != LB_ERR) {
                    if (pwd->m_pUserToClone != NULL)
                        pwd->m_pUserToClone->Release();
                    pwd->m_pUserToClone = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);
                    if (pwd->m_pUserToClone != NULL)
                        pwd->m_pUserToClone->AddRef();
                }
                else {
                    MsgBox(hDlg, IDS_PICK_USERNAME, MB_OK | MB_ICONSTOP);
                    FailChangePage(hDlg);
                }
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)(((LPPROPSHEETPAGE)lParam)->lParam);
            FillUserList(GetDlgItem(hDlg, IDC_USERNAME), pwd->m_pDB, NULL,
                         TRUE, PickUserSelected);
        }
        break;

    case WM_DESTROY:
        DestroyUserList(GetDlgItem(hDlg, IDC_USERNAME));
        break;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDC_USERNAME && HIWORD(wParam) == LBN_SELCHANGE) {
            int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
            PickUserSelected((HWND)lParam, iItem);
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


INT_PTR CALLBACK NewPasswordDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case PSN_WIZNEXT:
            {
                int cchPassword = GetWindowTextLength(GetDlgItem(hDlg, IDC_PASSWORD));

                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                GetControlText(hDlg, IDC_PASSWORD, &pwd->m_nlsUserPassword);

                BOOL fConfirmedOK = FALSE;
                int cchConfirm = GetWindowTextLength(GetDlgItem(hDlg, IDC_CONFIRM_PASSWORD));
                if (cchConfirm == cchPassword) {
                    NLS_STR nlsConfirm(cchConfirm+1);
                    if (SUCCEEDED(GetControlText(hDlg, IDC_CONFIRM_PASSWORD, &nlsConfirm))) {
                        if (!nlsConfirm.strcmp(pwd->m_nlsUserPassword))
                            fConfirmedOK = TRUE;
                    }
                }

                if (!fConfirmedOK) {
                    MsgBox(hDlg, IDS_NO_MATCH, MB_OK | MB_ICONSTOP);
                    SetDlgItemText(hDlg, IDC_PASSWORD, szNULL);
                    SetDlgItemText(hDlg, IDC_CONFIRM_PASSWORD, szNULL);
                    SetErrorFocus(hDlg, IDC_PASSWORD);
                    FailChangePage(hDlg);
                }
                else {
                    pwd->m_idPrevPage = IDD_NewUserPassword;
                    UINT idNextPage;
                    if (pwd->m_fCreatingProfile)
                        idNextPage = IDD_ChooseFoldersWiz;
                    else
                        idNextPage = pwd->m_fGoMultiWizard ? IDD_FinishGoMulti : IDD_FinishAddUser;
                    GoToPage(hDlg, idNextPage);
                }
            }
            break;

        case PSN_WIZBACK:
            GoToPage(hDlg, IDD_EnterUsername);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            LimitCredentialLength(hDlg, IDC_PASSWORD);
            LimitCredentialLength(hDlg, IDC_CONFIRM_PASSWORD);

            if (pwd->m_fGoMultiWizard) {
                NLS_STR nlsText(MAX_RES_STR_LEN);
                if (nlsText.QueryError() == ERROR_SUCCESS) {
                    nlsText.LoadString(IDS_YOURNEWPASSWORD);
                    if (nlsText.QueryError() == ERROR_SUCCESS)
                        SetDlgItemText(hDlg, IDC_MAIN_CAPTION, nlsText.QueryPch());
                    if (FAILED(pwd->m_hresRatings)) {
                        nlsText.LoadString(IDS_RATINGS_PW_COMMENT);
                        if (nlsText.QueryError() == ERROR_SUCCESS)
                            SetDlgItemText(hDlg, IDC_RATINGS_PW_COMMENT, nlsText.QueryPch());
                    }
                }
            }
            else {
                InsertControlText(hDlg, IDC_MAIN_CAPTION, &pwd->m_nlsUsername);
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


const TCHAR c_szExplorerUSFKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
const TCHAR c_szExplorerSFKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
const struct FolderDescriptor {
    UINT idsDirName;        /* Resource ID for directory name */
    LPCTSTR pszRegValue;    /* Name of reg value to set path in */
    LPCTSTR pszStaticName;  /* Static name for ProfileReconciliation subkey */
    LPCTSTR pszFiles;       /* Spec for which files should roam */
    DWORD dwAttribs;        /* Desired attributes */
    BOOL fSecondary : 1;    /* TRUE if subsidiary to the Start Menu */
    BOOL fDefaultInRoot : 1;/* TRUE if default is root of drive, not windir */
} aFolders[] = {

    /* NOTE: Keep the entries in the following table in the same order as the
     * corresponding FOLDER_XXXXXX bitflags in mslocusr.h.
     */

    { IDS_CSIDL_DESKTOP_L,  "Desktop",   "Desktop",   "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 0 },
    { IDS_CSIDL_NETHOOD_L,  "NetHood",   "NetHood",   "*.*", FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, 0, 0 },
    { IDS_CSIDL_RECENT_L,   "Recent",    "Recent",    "*.*", FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, 0, 0 },
    { IDS_CSIDL_STARTMENU_L,"Start Menu","Start Menu","*.lnk,*.pif,*.url", FILE_ATTRIBUTE_DIRECTORY, 0, 0 },
    { IDS_CSIDL_PROGRAMS_L, "Programs",  "Programs",  "*.lnk,*.pif,*.url", FILE_ATTRIBUTE_DIRECTORY, 1, 0 },
    { IDS_CSIDL_STARTUP_L,  "Startup",   "Startup",   "*.lnk,*.pif,*.url", FILE_ATTRIBUTE_DIRECTORY, 1, 0 },
    { IDS_CSIDL_FAVORITES_L,"Favorites", "Favorites", "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 0 },
    { IDS_CSIDL_CACHE_L,    "Cache",     "Cache",     "",    FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_SYSTEM, 0, 0 },
    { IDS_CSIDL_PERSONAL_L, "Personal",  "Personal",  "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 1 },
};

const struct FolderDescriptor fdChannels =
    { IDS_CSIDL_CHANNELS_L, NULL, "Channel Preservation Key", "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 0 };

void InitFolderCheckboxes(HWND hDlg, CWizData *pwd)
{
    IUser *pUserToClone;

    pwd->m_fdwOriginalPerUserFolders = 0;

    if (pwd->m_pUserToClone != NULL) {
        pUserToClone = pwd->m_pUserToClone;
        pUserToClone->AddRef();
    }
    else {
        pwd->m_pDB->GetSpecialUser(GSU_DEFAULT, &pUserToClone);
    }

    HKEY hkeyUser;
    if (pUserToClone != NULL && SUCCEEDED(pUserToClone->LoadProfile(&hkeyUser))) {
        HKEY hkeyProfRec, hkeyProfRec2;
        if (RegOpenKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation",
                         0, KEY_READ, &hkeyProfRec) != ERROR_SUCCESS)
            hkeyProfRec = NULL;
        if (RegOpenKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\SecondaryProfileReconciliation",
                         0, KEY_READ, &hkeyProfRec2) != ERROR_SUCCESS)
            hkeyProfRec2 = NULL;

        for (UINT iFolder = 0; iFolder < ARRAYSIZE(aFolders); iFolder++) {
            HKEY hkeyTemp;
            HKEY hkeyParent = aFolders[iFolder].fSecondary ? hkeyProfRec2 : hkeyProfRec;

            if (hkeyParent != NULL &&
                RegOpenKeyEx(hkeyParent,
                             aFolders[iFolder].pszStaticName,
                             0, KEY_READ, &hkeyTemp) == ERROR_SUCCESS) {
                RegCloseKey(hkeyTemp);
                pwd->m_fdwOriginalPerUserFolders |= 1 << iFolder;
            }
            /* else bit is already clear */
        }

        if (hkeyProfRec != NULL)
            RegCloseKey(hkeyProfRec);
        if (hkeyProfRec2 != NULL)
            RegCloseKey(hkeyProfRec2);

        pUserToClone->UnloadProfile(hkeyUser);
    }

    if (pUserToClone != NULL)
        pUserToClone->Release();

    CheckDlgButton(hDlg, IDC_CHECK_DESKTOP,
                   (pwd->m_fdwOriginalPerUserFolders & 
                    (FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT)) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_STARTMENU,
                   (pwd->m_fdwOriginalPerUserFolders & 
                    (FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP)) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_FAVORITES,
                   (pwd->m_fdwOriginalPerUserFolders & FOLDER_FAVORITES) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_CACHE,
                   (pwd->m_fdwOriginalPerUserFolders & FOLDER_CACHE) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_MYDOCS,
                   (pwd->m_fdwOriginalPerUserFolders & FOLDER_MYDOCS) ? 1 : 0);
}


INT_PTR CALLBACK ChooseFoldersDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

                InitFolderCheckboxes(hDlg, pwd);
            }
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

                pwd->m_fdwCloneFromDefault = IsDlgButtonChecked(hDlg, IDC_RADIO_EMPTY) ? 0 : 0xffffffff;
                pwd->m_fdwNewPerUserFolders = 0;
                if (IsDlgButtonChecked(hDlg, IDC_CHECK_DESKTOP))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_STARTMENU))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_FAVORITES))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_FAVORITES;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_FAVORITES);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_CACHE))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_CACHE;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_CACHE);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_MYDOCS))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_MYDOCS;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_MYDOCS);

                pwd->m_idPrevPage = IDD_ChooseFoldersWiz;
                GoToPage(hDlg, pwd->m_fGoMultiWizard ? IDD_FinishGoMulti : IDD_FinishAddUser);
            }
            break;

        case PSN_WIZBACK:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                GoToPage(hDlg, pwd->m_idPrevPage);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            CheckRadioButton(hDlg, IDC_RADIO_COPY, IDC_RADIO_EMPTY, IDC_RADIO_COPY);
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void GetWindowsRootPath(LPSTR pszBuffer, UINT cchBuffer)
{
    GetWindowsDirectory(pszBuffer, cchBuffer);

    LPSTR pszEnd = NULL;
    if (*pszBuffer == '\\' && *(pszBuffer+1) == '\\') {
        pszEnd = ::strchrf(pszBuffer+2, '\\');
        if (pszEnd != NULL) {
            pszEnd = ::strchrf(pszEnd+1, '\\');
            if (pszEnd != NULL)
                pszEnd++;
        }
    }
    else {
        LPSTR pszNext = CharNext(pszBuffer);
        if (*pszNext == ':' && *(pszNext+1) == '\\')
            pszEnd = pszNext + 2;
    }
    if (pszEnd != NULL)
        *pszEnd = '\0';
    else
        AddBackslash(pszBuffer);
}


void AddProfRecKey(HKEY hkeyUser, HKEY hkeyProfRec, const FolderDescriptor *pFolder,
                   BOOL fCloneFromDefault, LPCSTR pszProfileDir)
{
    TCHAR szDefaultPath[MAX_PATH];

    if (pFolder->fDefaultInRoot)
        GetWindowsRootPath(szDefaultPath, ARRAYSIZE(szDefaultPath));
    else
        ::strcpyf(szDefaultPath, TEXT("*windir\\"));

    LPTSTR pszEnd = szDefaultPath + ::strlenf(szDefaultPath);
    LoadString(::hInstance, pFolder->idsDirName,
               pszEnd, ARRAYSIZE(szDefaultPath) - (int)(pszEnd - szDefaultPath));
    LPTSTR pszLastComponent = ::strrchrf(pszEnd, '\\');
    if (pszLastComponent == NULL)
        pszLastComponent = pszEnd;
    else
        pszLastComponent++;

    HKEY hSubKey;

    LONG err = RegCreateKeyEx(hkeyProfRec, pFolder->pszStaticName, 0, NULL, REG_OPTION_NON_VOLATILE, 
                              KEY_WRITE, NULL, &hSubKey, NULL);
    if (err == ERROR_SUCCESS) {
        err = RegSetValueEx(hSubKey, "CentralFile", 0, REG_SZ,
                            (LPBYTE)pszLastComponent, ::strlenf(pszLastComponent)+1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "LocalFile", 0, REG_SZ, (LPBYTE)pszEnd,
                                ::strlenf(pszEnd)+1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "Name", 0, REG_SZ, (LPBYTE)pFolder->pszFiles,
                                ::strlenf(pFolder->pszFiles) + 1);

        if (fCloneFromDefault && err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "DefaultDir", 0, REG_SZ, (LPBYTE)szDefaultPath,
                                ::strlenf(szDefaultPath) + 1);

        DWORD dwOne = 1;
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "MustBeRelative", 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));
        if (fCloneFromDefault && err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "Default", 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));

        if (pFolder->pszRegValue != NULL) {
            if (err == ERROR_SUCCESS)
                err = RegSetValueEx(hSubKey, "RegKey", 0, REG_SZ, (LPBYTE)c_szExplorerUSFKey,
                                    ::strlenf(c_szExplorerUSFKey) + 1);
            if (err == ERROR_SUCCESS)
                err = RegSetValueEx(hSubKey, "RegValue", 0, REG_SZ, (LPBYTE)pFolder->pszRegValue,
                                    ::strlenf(pFolder->pszRegValue) + 1);
        }

        if (err == ERROR_SUCCESS && pFolder->fSecondary) {
            err = RegSetValueEx(hSubKey, "ParentKey", 0, REG_SZ, (LPBYTE)"Start Menu", 11);
        }

        RegCloseKey(hSubKey);
    }

    /* And if we're not adding a clone-from-default profrec key, we know that
     * no profile code is going to create the directory, so we'd better do it
     * ourselves, and set the path in the registry.
     */

    if (!fCloneFromDefault) {
        NLS_STR nlsTemp(MAX_PATH);
        if (nlsTemp.QueryError() == ERROR_SUCCESS) {
            nlsTemp = pszProfileDir;
            AddBackslash(nlsTemp);
            nlsTemp.strcat(pszEnd);

            HKEY hkeyExplorer;
            if (RegOpenKeyEx(hkeyUser, c_szExplorerSFKey, 0,
                             KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                RegSetValueEx(hkeyExplorer, pFolder->pszRegValue,
                              0, REG_SZ, (LPBYTE)nlsTemp.QueryPch(),
                              nlsTemp.strlen()+1);
                RegCloseKey(hkeyExplorer);
            }
            if (RegOpenKeyEx(hkeyUser, c_szExplorerUSFKey, 0,
                             KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                RegSetValueEx(hkeyExplorer, pFolder->pszRegValue,
                              0, REG_SZ, (LPBYTE)nlsTemp.QueryPch(),
                              nlsTemp.strlen()+1);
                RegCloseKey(hkeyExplorer);
            }
            CreateDirectoryPath(nlsTemp.QueryPch());
        }
    }
}


/* CWizData::PreInitProfile is called back by IUserDatabase::Install or
 * ::AddUser after the new user's profile has been created but before
 * directory reconciliation takes place.  This is our chance to add
 * roaming keys for any folders that we want to be per-user and initialized
 * from the defaults, and remove roaming keys for other folders we know about.
 */
STDMETHODIMP CWizData::PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
{
    HKEY hkeyProfRec, hkeyProfRec2;
    DWORD dwDisp;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec = NULL;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\SecondaryProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec2, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec2 = NULL;

    m_fChannelHack = FALSE;

    DWORD fdwFlag = 1;

    for (UINT iFolder = 0;
         iFolder < ARRAYSIZE(aFolders);
         iFolder++, fdwFlag <<= 1) {

        BOOL fWasPerUser = (m_fdwOriginalPerUserFolders & fdwFlag);
        BOOL fMakePerUser = (m_fdwNewPerUserFolders & fdwFlag);
        BOOL fCloneFromDefault = (m_fdwCloneFromDefault & fdwFlag);

        /* If the folder was shared and is staying that way, do nothing. */
        if (!fWasPerUser && !fMakePerUser)
            continue;

        /* If the folder was per-user and is staying that way, do nothing,
         * UNLESS we're creating a new profile and the user chose the start-
         * out-empty option.  In that case we want to make sure to kill the
         * profrec keys until PostInitProfile.
         */
        if (fWasPerUser && fMakePerUser && (!m_fCreatingProfile || fCloneFromDefault))
            continue;

        HKEY hkeyParent = aFolders[iFolder].fSecondary ? hkeyProfRec2 : hkeyProfRec;

        /* If the user is making a folder per-user when it wasn't, and they
         * want this folder cloned from the default, add a profrec key now.
         */
        if (fMakePerUser && fCloneFromDefault) {
            AddProfRecKey(hkeyUser, hkeyParent, &aFolders[iFolder], TRUE, pszProfileDir);
        }

        /* If the user is making a folder shared, or they want this per-user
         * folder to start out empty, delete the profrec key now.  In the
         * latter case, we will add it for roaming purposes during
         * PostInitProfile.
         */
        if (!fMakePerUser || !fCloneFromDefault) {

            RegDeleteKey(hkeyParent, aFolders[iFolder].pszStaticName);

            /* If we're making a folder shared and we're not cloning the
             * default profile, then the profile has a per-user directory
             * path in it which we need to clear out.
             *
             * We know that we need to delete the value from User Shell Folders,
             * and set the default path under Shell Folders.
             */

            if (!fMakePerUser && m_pUserToClone != NULL) {

                TCHAR szDefaultPath[MAX_PATH+1];

                if (aFolders[iFolder].fDefaultInRoot) {
                    GetWindowsRootPath(szDefaultPath, ARRAYSIZE(szDefaultPath));
                }
                else {
                    GetWindowsDirectory(szDefaultPath, ARRAYSIZE(szDefaultPath));
                    AddBackslash(szDefaultPath);
                }
                LPTSTR pszEnd = szDefaultPath + ::strlenf(szDefaultPath);

                LoadString(::hInstance, aFolders[iFolder].idsDirName,
                           pszEnd, ARRAYSIZE(szDefaultPath) - (int)(pszEnd - szDefaultPath));

                HKEY hkeyExplorer;

                if (RegOpenKeyEx(hkeyUser, c_szExplorerUSFKey, 0,
                                 KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                    if (aFolders[iFolder].fDefaultInRoot) {
                        RegSetValueEx(hkeyExplorer, aFolders[iFolder].pszRegValue,
                                      0, REG_SZ, (LPBYTE)szDefaultPath,
                                      ::strlenf(szDefaultPath)+1);
                    }
                    else {
                        RegDeleteValue(hkeyExplorer, aFolders[iFolder].pszRegValue);
                    }
                    RegCloseKey(hkeyExplorer);
                }

                if (RegOpenKeyEx(hkeyUser, c_szExplorerSFKey, 0,
                                 KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                    RegSetValueEx(hkeyExplorer, aFolders[iFolder].pszRegValue,
                                  0, REG_SZ, (LPBYTE)szDefaultPath,
                                  ::strlenf(szDefaultPath)+1);
                    RegCloseKey(hkeyExplorer);
                }
            }
        }

        /* Special code for start-out-empty folders:  Some of them need to
         * start out with certain crucial files, not totally empty.
         */

        if (fMakePerUser &&
            (!fWasPerUser || m_fCreatingProfile) &&
            !fCloneFromDefault) {

            /* Special hack for channels: If the user wants Favorites to be per-user,
             * but chooses to start it out empty, they get no channels either, because
             * Channels is a subdirectory of Favorites.  So, for that case only,
             * we force in a clone-from-default profrec key for Channels, which we'll
             * delete in PostInit.
             */

            if (fdwFlag == FOLDER_FAVORITES) {
                AddProfRecKey(hkeyUser, hkeyProfRec, &fdChannels, TRUE, pszProfileDir);
                m_fChannelHack = TRUE;
            }
        }
    }

    if (hkeyProfRec != NULL)
        RegCloseKey(hkeyProfRec);
    if (hkeyProfRec2 != NULL)
        RegCloseKey(hkeyProfRec2);

    return S_OK;
}


/* CWizData::PostInitProfile is called by IUserDatabase::Install or ::AddUser
 * after the user's folders have all been created and initialized.  Here we
 * add profrec keys for any folders which we want to be per-user but don't
 * want initialized from the default.
 */
STDMETHODIMP CWizData::PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
{
    HKEY hkeyProfRec, hkeyProfRec2;
    DWORD dwDisp;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec = NULL;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\SecondaryProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec2, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec2 = NULL;

    DWORD fdwFlag = 1;
    for (UINT iFolder = 0;
         iFolder < ARRAYSIZE(aFolders);
         iFolder++, fdwFlag <<= 1) {

        HKEY hkeyParent = aFolders[iFolder].fSecondary ? hkeyProfRec2 : hkeyProfRec;

        if (m_fdwNewPerUserFolders & fdwFlag) {
            /* If the user is making a folder per-user when it wasn't or making a
             * folder per-user in a new profile, and they want this folder to start 
             * out empty, add a profrec key now.
             */
            if ((!(m_fdwOriginalPerUserFolders & fdwFlag) || m_fCreatingProfile) &&
                !(m_fdwCloneFromDefault & fdwFlag)) {
                AddProfRecKey(hkeyUser, hkeyParent, &aFolders[iFolder], FALSE, pszProfileDir);
            }

            /* If the folder is per-user and is supposed to have special
             * attributes, make sure it has them.
             */
            if (aFolders[iFolder].dwAttribs != FILE_ATTRIBUTE_DIRECTORY) {
                RegEntry re(aFolders[iFolder].pszStaticName, hkeyParent);
                NLS_STR nlsTemp(MAX_PATH);
                if (re.GetError() == ERROR_SUCCESS && nlsTemp.QueryError() == ERROR_SUCCESS) {
                    GetSetRegistryPath(hkeyUser, re, &nlsTemp, FALSE);
                    if (nlsTemp.strlen()) {
                        ::SetFileAttributes(nlsTemp.QueryPch(), aFolders[iFolder].dwAttribs);
                    }
                }
            }
        }
    }

    /* If we added a hack for channels, undo that hack now that we're done
     * initializing the profile.
     */
    if (m_fChannelHack)
        RegDeleteKey(hkeyProfRec, fdChannels.pszStaticName);

    if (hkeyProfRec != NULL)
        RegCloseKey(hkeyProfRec);
    if (hkeyProfRec2 != NULL)
        RegCloseKey(hkeyProfRec2);

    return S_OK;
}


/* Following is actually for the CPL version of the choose-folders dialog */
HRESULT ChooseFoldersProgressFunc(LPARAM lParam)
{
    CWizData *pwd = (CWizData *)lParam;
    HKEY hkeyUser;

    if (pwd->m_pUserToClone != NULL &&
        SUCCEEDED(pwd->m_pUserToClone->LoadProfile(&hkeyUser))) {

        TCHAR szProfileDir[MAX_PATH];
        DWORD cbBuffer = sizeof(szProfileDir);
        pwd->m_pUserToClone->GetProfileDirectory(szProfileDir, &cbBuffer);

        pwd->PreInitProfile(hkeyUser, szProfileDir);

        NLS_STR nlsPath(szProfileDir);
        AddBackslash(nlsPath);

        DWORD fdwFlag = 1;
        for (UINT iFolder = 0;
             iFolder < ARRAYSIZE(aFolders);
             iFolder++, fdwFlag <<= 1) {

            /* Do reconciliation if we want to per-user-ize a folder that 
             * wasn't per-user before and we want to clone it from default.
             */
            if (!(pwd->m_fdwOriginalPerUserFolders & fdwFlag) &&
                (pwd->m_fdwNewPerUserFolders & fdwFlag) &&
                (pwd->m_fdwCloneFromDefault & fdwFlag)) {
                DefaultReconcileKey(hkeyUser, nlsPath,
                                    aFolders[iFolder].pszStaticName,
                                    aFolders[iFolder].fSecondary);
            }
        }

        /* Process the initialization hack for Channels, if it exists. */
        if (pwd->m_fChannelHack)
            DefaultReconcileKey(hkeyUser, nlsPath, fdChannels.pszStaticName,
                                fdChannels.fSecondary);

        pwd->PostInitProfile(hkeyUser, szProfileDir);

        pwd->m_pUserToClone->UnloadProfile(hkeyUser);

        SHFlushSFCache();

        return S_OK;
    }
    return E_FAIL;
}


void FinishChooseFolders(HWND hDlg, CWizData *pwd)
{
    if (SUCCEEDED(CallWithinProgressDialog(hDlg, IDD_CreateProgress,    
                                           ChooseFoldersProgressFunc, (LPARAM)pwd)))
        EndDialog(hDlg, TRUE);
}


HRESULT InstallProgressFunc(LPARAM lParam)
{
    CWizData *pwd = (CWizData *)lParam;

    return pwd->m_pDB->Install(pwd->m_nlsUsername.QueryPch(),
                               pwd->m_nlsUserPassword.QueryPch(),
                               pwd->m_nlsSupervisorPassword.QueryPch(),
                               pwd);
}


BOOL FinishGoMulti(HWND hDlg, CWizData *pwd)
{
    DWORD dwExitCode = 0xffffffff;  /* not a valid EWX_ value */

    /* If user profiles aren't enabled, enable them.  Using them requires
     * logging off.
     */
    if (!UseUserProfiles()) {
        dwExitCode = EWX_LOGOFF;
        EnableProfiles();
    }

    /* If there is no primary logon provider, install our logon dialog as
     * the primary.  Using this requires rebooting the system.
     */
    if (InstallLogonDialog()) {
        dwExitCode = EWX_REBOOT;
    }

    pwd->m_nlsUserPassword.strupr();
    HRESULT hres = CallWithinProgressDialog(hDlg, IDD_CreateProgress,
                                            InstallProgressFunc, (LPARAM)pwd);
    if (SUCCEEDED(hres)) {
        /* Set the new username as the default one to log on as. */
        HKEY hkeyLogon;
        if (OpenLogonKey(&hkeyLogon) == ERROR_SUCCESS) {
            pwd->m_nlsUsername.ToOEM();
            RegSetValueEx(hkeyLogon, ::szUsername, 0, REG_SZ,
                          (LPBYTE)pwd->m_nlsUsername.QueryPch(),
                          pwd->m_nlsUsername.strlen() + 1);
            pwd->m_nlsUsername.ToAnsi();
            RegCloseKey(hkeyLogon);
        }
        if ((dwExitCode != 0xffffffff) &&
            MsgBox(hDlg, IDS_GO_MULTI_RESTART, MB_YESNO | MB_ICONQUESTION) == IDYES) {
            ::ExitWindowsEx(dwExitCode, 0);
            ::ExitProcess(0);
        }
        return TRUE;
    }

    ReportUserError(hDlg, hres);
    return FALSE;
}


HRESULT AddUserProgressFunc(LPARAM lParam)
{
    CWizData *pwd = (CWizData *)lParam;

    return pwd->m_pDB->AddUser(pwd->m_nlsUsername.QueryPch(),
                               pwd->m_pUserToClone, pwd, &pwd->m_pNewUser);
}


BOOL FinishAddUser(HWND hDlg, CWizData *pwd)
{
    pwd->m_nlsUserPassword.strupr();

    pwd->m_pNewUser = NULL;
    HRESULT hres = CallWithinProgressDialog(hDlg, IDD_CreateProgress,
                                            AddUserProgressFunc, (LPARAM)pwd);
    if (SUCCEEDED(hres)) {
        hres = pwd->m_pNewUser->ChangePassword(szNULL, pwd->m_nlsUserPassword.QueryPch());
        pwd->m_pNewUser->Release();
        pwd->m_pNewUser = NULL;
    }
    else {
        ReportUserError(hDlg, hres);
    }

    return SUCCEEDED(hres);
}


INT_PTR CALLBACK FinishDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            }
            break;

        case PSN_WIZFINISH:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                BOOL fOK = pwd->m_fGoMultiWizard ? FinishGoMulti(hDlg, pwd) : FinishAddUser(hDlg, pwd);
                if (!fOK)
                    FailChangePage(hDlg);
                else
                    return FALSE;       /* destroy wizard */
            }
            break;

        case PSN_WIZBACK:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                GoToPage(hDlg, pwd->m_idPrevPage);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
            if (!pwd->m_fGoMultiWizard) {
                InsertControlText(hDlg, IDC_MAIN_CAPTION, &pwd->m_nlsUsername);
                InsertControlText(hDlg, IDC_MAIN_CAPTION2, &pwd->m_nlsUsername);
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


STDMETHODIMP CLUDatabase::InstallWizard(HWND hwndParent)
{
#if 0
    if (UseUserProfiles()) {
        MsgBox(hwndParent, IDS_PROFILES_ALREADY_ENABLED, MB_OK | MB_ICONINFORMATION);
        return E_FAIL;
    }
#endif

    if (ProfileUIRestricted()) {
        ReportRestrictionError(hwndParent);
        return E_ACCESSDENIED;
    }

    CWizData wd;
    wd.m_hresRatings = VerifySupervisorPassword(szNULL);
    wd.m_fGoMultiWizard = TRUE;
    wd.m_pDB = this;
    AddRef();           /* just in case */
    wd.m_pUserToClone = NULL;

    LPPROPSHEETHEADER ppsh;

    // Allocate the property sheet header
    //
    if ((ppsh = (LPPROPSHEETHEADER)LocalAlloc(LMEM_FIXED, sizeof(PROPSHEETHEADER)+
                (MAX_WIZ_PAGES * sizeof(HPROPSHEETPAGE)))) != NULL)
    {
        ppsh->dwSize     = sizeof(*ppsh);
        ppsh->dwFlags    = PSH_WIZARD;
        ppsh->hwndParent = hwndParent;
        ppsh->hInstance  = ::hInstance;
        ppsh->pszCaption = NULL;
        ppsh->nPages     = 0;
        ppsh->nStartPage = 0;
        ppsh->phpage     = (HPROPSHEETPAGE *)(ppsh+1);

        /* Add the pages for the wizard.  Note that we have two pages to
         * prompt for the user's account password -- one to enter, the other
         * to enter and confirm.  The code in EnterUsernameDlgProc jumps to
         * the right password page depending on whether the user has a PWL.
         * The code in NewPasswordDlgProc knows to jump ahead to the finish
         * page.
         *
         * If you add more pages here, be sure to update the code as necessary
         * so the sequence is correct.
         */
        AddPage(ppsh, IDD_EnableProfilesIntro, IntroDlgProc, &wd);
        if (wd.m_hresRatings == S_FALSE)
            AddPage(ppsh, IDD_EnterCAPassword, EnterCAPWDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUsername, EnterUsernameDlgProc, &wd);
        AddPage(ppsh, IDD_NewUserPassword, NewPasswordDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUserPassword, EnterUserPWDlgProc, &wd);
        AddPage(ppsh, IDD_ChooseFoldersWiz, ChooseFoldersDlgProc, &wd);
        AddPage(ppsh, IDD_FinishGoMulti, FinishDlgProc, &wd);

        PropertySheet(ppsh);

        LocalFree((HLOCAL)ppsh);
    }

    Release();  /* undo above AddRef() */

    return S_OK;
}


HRESULT DoAddUserWizard(HWND hwndParent, IUserDatabase *pDB,
                        BOOL fPickUserPage, IUser *pUserToClone)
{
    CWizData wd;
    wd.m_hresRatings = VerifySupervisorPassword(szNULL);
    wd.m_fGoMultiWizard = FALSE;
    wd.m_pDB = pDB;
    pDB->AddRef();      /* just in case */
    wd.m_pUserToClone = pUserToClone;
    if (wd.m_pUserToClone != NULL)
        wd.m_pUserToClone->AddRef();

    LPPROPSHEETHEADER ppsh;

    // Allocate the property sheet header
    //
    if ((ppsh = (LPPROPSHEETHEADER)LocalAlloc(LMEM_FIXED, sizeof(PROPSHEETHEADER)+
                (MAX_WIZ_PAGES * sizeof(HPROPSHEETPAGE)))) != NULL)
    {
        ppsh->dwSize     = sizeof(*ppsh);
        ppsh->dwFlags    = PSH_WIZARD;
        ppsh->hwndParent = hwndParent;
        ppsh->hInstance  = ::hInstance;
        ppsh->pszCaption = NULL;
        ppsh->nPages     = 0;
        ppsh->nStartPage = 0;
        ppsh->phpage     = (HPROPSHEETPAGE *)(ppsh+1);

        AddPage(ppsh, IDD_AddUserIntro, IntroDlgProc, &wd);

        if (IsCurrentUserSupervisor(pDB) != S_OK)
        {
            AddPage(ppsh, IDD_EnterCAPassword, EnterCAPWDlgProc, &wd);
        }

        if (fPickUserPage)
            AddPage(ppsh, IDD_PickUser, PickUserDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUsername, EnterUsernameDlgProc, &wd);
        AddPage(ppsh, IDD_NewUserPassword, NewPasswordDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUserPassword, EnterUserPWDlgProc, &wd);
        AddPage(ppsh, IDD_ChooseFoldersWiz, ChooseFoldersDlgProc, &wd);
        AddPage(ppsh, IDD_FinishAddUser, FinishDlgProc, &wd);

        PropertySheet(ppsh);

        LocalFree((HLOCAL)ppsh);
    }

    pDB->Release(); /* undo above AddRef() */

    return S_OK;
}


STDMETHODIMP CLUDatabase::AddUserWizard(HWND hwndParent)
{
    if (ProfileUIRestricted()) {
        ReportRestrictionError(hwndParent);
        return E_ACCESSDENIED;
    }

    return DoAddUserWizard(hwndParent, this, TRUE, NULL);
}


extern "C" void InstallWizard(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow)
{
    IUserDatabase *pDB;
    if (SUCCEEDED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        pDB->InstallWizard(hwndParent);
        pDB->Release();
    }
}


extern "C" void AddUserWizard(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow)
{
    IUserDatabase *pDB;
    if (SUCCEEDED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        pDB->AddUserWizard(hwndParent);
        pDB->Release();
    }
}


struct ProgressDlgData
{
    PFNPROGRESS pfn;
    LPARAM lParam;
    HRESULT hres;
};


void CallProgressFunc(HWND hDlg)
{
    ProgressDlgData *ppdd = (ProgressDlgData *)GetWindowLongPtr(hDlg, DWLP_USER);

    ppdd->hres = ppdd->pfn(ppdd->lParam);

    EndDialog(hDlg, FALSE);
}


const UINT WM_CALL_FUNC = WM_USER + 100;

INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            /* Defer function call to a posted message so the dialog manager
             * will show our dialog.
             *
             * If PostMessage fails, at least still call the function anyway.
             */
            if (!PostMessage(hDlg, WM_CALL_FUNC, 0, 0)) {
                CallProgressFunc(hDlg);
            }
        }

        return TRUE;        /* we didn't set the focus */

    case WM_CALL_FUNC:
        CallProgressFunc(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


HRESULT CallWithinProgressDialog(HWND hwndOwner, UINT idResource, PFNPROGRESS pfn,
                                 LPARAM lParam)
{
    ProgressDlgData pdd = { pfn, lParam, E_FAIL };

    DialogBoxParam(::hInstance, MAKEINTRESOURCE(idResource), hwndOwner,
                   ProgressDlgProc, (LPARAM)&pdd);

    return pdd.hres;
}


BOOL ProfileUIRestricted(void)
{
    RegEntry rePolicy("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System");

    if (rePolicy.GetError() == ERROR_SUCCESS) {
        if (rePolicy.GetNumber("NoProfilePage") != 0)
            return TRUE;
    }
    return FALSE;
}


void ReportRestrictionError(HWND hwndOwner)
{
    MsgBox(hwndOwner, IDS_PROFILE_POLICY, MB_OK | MB_ICONSTOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\msluglob.h ===
#if !defined (EXTERN)
#define EXTERN extern
#endif

#if !defined (ASSIGN)
#define ASSIGN(value)
#endif

/* the 'extern' must be forced for constant arrays, because 'const'
 * in C++ implies 'static' otherwise.
 */
#define EXTTEXT(n) extern const CHAR n[]
#define TEXTCONST(name,text) EXTTEXT(name) ASSIGN(text)

TEXTCONST(szProfileList,REGSTR_PATH_SETUP "\\ProfileList");
TEXTCONST(szSupervisor,"Supervisor");
TEXTCONST(szProfileImagePath,"ProfileImagePath");
TEXTCONST(szDefaultUserName,".Default");
TEXTCONST(szRATINGS,        "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings");
TEXTCONST(szRatingsSupervisorKeyName,"Key");
TEXTCONST(szUsersSupervisorKeyName,"Key2");
TEXTCONST(szLogonKey,"Network\\Logon");
TEXTCONST(szUserProfiles,"UserProfiles");
TEXTCONST(szUsername,"Username");
TEXTCONST(szSupervisorPWLKey,"MSLOCUSR!SuperPW");

TEXTCONST(szProfilePrefix,"PRO");	/* for generating temp. profile file names */
TEXTCONST(szProfiles,"Profiles");
#define szProfilesDirectory	szProfiles	/* name appended to windows dir */
#define szProfileListRootKey szProfileList
TEXTCONST(szStdNormalProfile,"USER.DAT");

TEXTCONST(szReconcileRoot,"Software\\Microsoft\\Windows\\CurrentVersion");
TEXTCONST(szReconcilePrimary,"ProfileReconciliation");
TEXTCONST(szReconcileSecondary,"SecondaryProfileReconciliation");
TEXTCONST(szLocalFile,"LocalFile");
TEXTCONST(szDefaultDir,"DefaultDir");
TEXTCONST(szReconcileName,"Name");
TEXTCONST(szWindirAlias,"*windir");
TEXTCONST(szReconcileRegKey,"RegKey");
TEXTCONST(szReconcileRegValue,"RegValue");
TEXTCONST(szUseProfiles,"UserProfiles");
TEXTCONST(szDisplayProfileErrors,"DisplayProfileErrors");

TEXTCONST(szNULL, "");

TEXTCONST(szOurCLSID, "{95D0F020-451D-11CF-8DAB-00AA006C1A01}");
TEXTCONST(szCLSID,			"CLSID");
TEXTCONST(szINPROCSERVER32,	"InProcServer32");
TEXTCONST(szDLLNAME,		"%SystemRoot%\\system32\\mslocusr.dll");
TEXTCONST(szTHREADINGMODEL,	"ThreadingModel");
TEXTCONST(szAPARTMENT,		"Apartment");

TEXTCONST(szHelpFile,       "users.hlp");
TEXTCONST(szRatingsHelpFile,"ratings.hlp");

EXTERN CHAR abSupervisorKey[16] ASSIGN({0});		/* supervisor password hash */
EXTERN CHAR fSupervisorKeyInit ASSIGN(FALSE);		/* whether abSupervisorKey has been initialized */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\msluinst.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include "resource.h"

/* InstallLogonDialog - check if there is a primary logon provider already on
 * the system, and if not, install MSLOCUSR as a net provider and make it the
 * primary logon.  Returns TRUE if the NP was installed.
 *
 * This chunk of hideous registry code exists because NETDI.DLL (the win95
 * network setup engine) (a) has no programmatic interface, it just assumes
 * it's being driven by NETCPL.CPL;  (b) is 16-bit code, so even if it had
 * a programmatic interface, we'd have to thunk;  and (c) if everything's
 * not consistent in his database of what network components are installed
 * and which are bound to which, then the next time the user brings up the
 * network CPL, any components which don't make sense just get silently
 * deinstalled.
 *
 * The set of registry keys and values which need to be added, changed, or
 * updated was gleaned from a registry diff done after using the real network
 * CPL to install this logon provider from an INF.  A similar registry diff
 * and similar code could be created to programmatically install a transport.
 * Don't ask me to do it for you, though...
 *
 * Note that in case of registry errors, we just bail out.  It would require
 * a huge amount of extra code to keep track of everything that had been done
 * up to that point and undo it.  The worst that happens if we do strange
 * things to the net component database is that NETDI will deinstall our
 * component the next time the user brings up the network control panel.  It
 * shouldn't actually cause any crashes or anything like that.
 */

BOOL InstallLogonDialog(void)
{
    HKEY hkey;          /* used for various work */
    LONG err;
    TCHAR szBuf[MAX_PATH];
    DWORD dwType;
    DWORD cbData;
    DWORD dwTemp;
    DWORD dwDisp;

    NLS_STR nlsNPName(MAX_RES_STR_LEN);
    if (nlsNPName.LoadString(IDS_NP_NAME) != ERROR_SUCCESS)
        return FALSE;

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon", 0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE, &hkey);
    if (err != ERROR_SUCCESS)
        return FALSE;           /* big problems if we can't get this guy */

    /* Get the PrimaryProvider value, which is the name of the net provider
     * that's handling the main logon dialog.  If it's there and not blank,
     * then presumably the user's on a LAN or something, so we don't want
     * to replace the logon dialog.
     */
    cbData = sizeof(szBuf);
    err = RegQueryValueEx(hkey, "PrimaryProvider", NULL, &dwType,
                          (LPBYTE)szBuf, &cbData);
    if (err == ERROR_SUCCESS && szBuf[0] != '\0') {
        RegCloseKey(hkey);
        return FALSE;
    }

    /* Make us the primary logon provider, as far as MPR and the logon code
     * are concerned.
     */
    err = RegSetValueEx(hkey, "PrimaryProvider", 0, REG_SZ,
                        (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
    RegCloseKey(hkey);
    if (err != ERROR_SUCCESS)
        return FALSE;

    /* Under HKLM\SW\MS\W\CV\Network\Real Mode Net, preferredredir=null string,
     * since we will now be the primary network in all respects.  NETDI needs
     * this to avoid getting confused.
     */
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Real Mode Net",
                       0, KEY_QUERY_VALUE, &hkey);
    if (err == ERROR_SUCCESS) {
        err = RegSetValueEx(hkey, "preferredredir", 0, REG_SZ, (LPBYTE)TEXT(""), sizeof(TCHAR));
        RegCloseKey(hkey);
    }

    /* Add new keys under HKLM\System\CurrentControlSet which will actually
     * make MPR load our DLL as a net provider.
     */
    HKEY hkeyFamilyClient;
    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB\\NetworkProvider", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        RegSetValueEx(hkeyFamilyClient, "Name", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
        RegSetValueEx(hkeyFamilyClient, "ProviderPath", 0, REG_SZ,
                      (LPBYTE)TEXT("ienpstub.dll"), 11 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "RealDLL", 0, REG_SZ,
                      (LPBYTE)TEXT("mslocusr.dll"), 13 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "Description", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);

        dwTemp = WNNC_NET_MSNET;
        RegSetValueEx(hkeyFamilyClient, "NetID", 0, REG_DWORD,
                      (LPBYTE)&dwTemp, sizeof(dwTemp));
        dwTemp = 0x40000000;
        RegSetValueEx(hkeyFamilyClient, "CallOrder", 0, REG_DWORD,
                      (LPBYTE)&dwTemp, sizeof(dwTemp));

        RegCloseKey(hkeyFamilyClient);
    }

    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\NetworkProvider\\Order", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        cbData = sizeof(szBuf);
        if (RegQueryValueEx(hkeyFamilyClient, "NPSTUB", NULL, &dwType, 
                            (LPBYTE)szBuf, &cbData) == ERROR_SUCCESS) {
            /* Our provider is already installed!  Better not do anything
             * more than just making it default, which we've already done.
             */
            RegCloseKey(hkeyFamilyClient);
            return FALSE;
        }
        RegSetValueEx(hkeyFamilyClient, "NPSTUB", 0, REG_SZ,
                      (LPBYTE)TEXT(""), sizeof(TCHAR));
        RegCloseKey(hkeyFamilyClient);
    }

    /* We've now installed our NP in the registry, and to see it appear we
     * need a reboot.  So from here on, if we bail out, we return TRUE.
     */

    /* First big chunk of network component database management.  Under
     * HKLM\System\CurrentControlSet\Services\Class\NetClient there is a
     * four-digit numeric subkey (e.g., "0000") for each network client.
     * One of them will be the default network client as far as NETDI's
     * database is concerned;  this is indicated by the existence of the
     * "Ndi\Default" subkey under the number key.  If we find one of those
     * guys, we save away the DeviceID value from the Ndi subkey so we can
     * tweak some configuration flags later in another part of the database.
     *
     * While enumerating the keys, we keep track of the highest number we've
     * seen so far.  When we're done, we add 1 to that and use that as the
     * subkey name for our client.  The number is kept separate from the
     * RegEnumKey index because the numbers are not necessarily packed (nor
     * will RegEnumKey necessarily return them in numeric order!).
     */

    HKEY hkeyNetClient;
    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Class\\NetClient",
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                         NULL, &hkeyNetClient, &dwDisp);
    if (err != ERROR_SUCCESS)
        return TRUE;

    UINT nFamilyNum;
    TCHAR szFamilyNumString[5]; /* four digits plus null */
    TCHAR szDefaultDeviceID[MAX_PATH] = "";

    if (dwDisp == REG_OPENED_EXISTING_KEY) {
        NLS_STR nlsSubKey(20);       /* enough for four digits, plus some just in case */
        DWORD iSubKey = 0;
        UINT maxSubKey = 0;

        for (;;) {
            err = RegEnumKey(hkeyNetClient, iSubKey, nlsSubKey.Party(), nlsSubKey.QueryAllocSize());
            nlsSubKey.DonePartying();
            if (err != ERROR_SUCCESS)
                break;

            NLS_STR nls2(nlsSubKey.strlen() + 12);
            if (nls2.QueryError() == ERROR_SUCCESS) {
                nls2 = nlsSubKey;
                nls2.strcat("\\Ndi\\Default");
                cbData = sizeof(szBuf);
                err = RegQueryValue(hkeyNetClient, nls2.QueryPch(), szBuf, (PLONG)&cbData);
                if (err == ERROR_SUCCESS) {
                    if (!lstrcmpi(szBuf, "True")) {
                        HKEY hkeyNdi;

                        NLS_STR nls3(nlsSubKey.strlen() + 5);
                        if (nls3.QueryError() == ERROR_SUCCESS) {
                            nls3 = nlsSubKey;
                            nls3.strcat("\\Ndi");

                            err = RegOpenKeyEx(hkeyNetClient, nls3.QueryPch(), 0, KEY_QUERY_VALUE, &hkeyNdi);
                            if (err == ERROR_SUCCESS) {
                                cbData = sizeof(szDefaultDeviceID);
                                RegQueryValueEx(hkeyNdi, "DeviceID", NULL, &dwType,
                                                (LPBYTE)szDefaultDeviceID, &cbData);
                                RegCloseKey(hkeyNdi);
                            }
                        }
                    }
                    RegDeleteKey(hkeyNetClient, nls2.QueryPch());
                }
            }

            UINT nSubKey = nlsSubKey.atoi();
            if (nSubKey > maxSubKey)
                maxSubKey = nSubKey;

            iSubKey++;
        }
        nFamilyNum = maxSubKey+1;
    }
    else
        nFamilyNum = 0;

    wsprintf(szFamilyNumString, "%04d", nFamilyNum);
    err = RegCreateKeyEx(hkeyNetClient, szFamilyNumString, 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        RegSetValueEx(hkeyFamilyClient, "DriverDesc", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
        RegSetValueEx(hkeyFamilyClient, "InfPath", 0, REG_SZ,
                      (LPBYTE)TEXT("NETFAM.INF"), 11 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "DriverDate", 0, REG_SZ,
                      (LPBYTE)TEXT(" 5-21-1997"), 11 * sizeof(TCHAR));
        err = RegCreateKeyEx(hkeyFamilyClient, "Ndi", 
                             0, "", REG_OPTION_NON_VOLATILE,
                             KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                             NULL, &hkey, &dwDisp);
        if (err == ERROR_SUCCESS) {
            RegSetValueEx(hkey, "DeviceID", 0, REG_SZ,
                          (LPBYTE)TEXT("FAMILY"), 7 * sizeof(TCHAR));
            RegSetValueEx(hkey, "NetworkProvider", 0, REG_SZ,
                          (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
            RegSetValueEx(hkey, "InstallInf", 0, REG_SZ,
                          (LPBYTE)TEXT(""), sizeof(TCHAR));
            RegSetValueEx(hkey, "InfSection", 0, REG_SZ,
                          (LPBYTE)TEXT("FAMILY.ndi"), 11 * sizeof(TCHAR));

            {
                NLS_STR nlsHelpText(MAX_RES_STR_LEN);
                if (nlsHelpText.LoadString(IDS_NETFAM_HELP_TEXT) == ERROR_SUCCESS) {
                    RegSetValueEx(hkey, "HelpText", 0, REG_SZ,
                                  (LPBYTE)nlsHelpText.QueryPch(), nlsHelpText.strlen() + 1);
                }
            }

            HKEY hkeyInterfaces;
            err = RegCreateKeyEx(hkey, "Interfaces", 
                                 0, "", REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                                 NULL, &hkeyInterfaces, &dwDisp);
            if (err == ERROR_SUCCESS) {
                RegSetValueEx(hkeyInterfaces, "DefLower", 0, REG_SZ,
                              (LPBYTE)TEXT("netbios,ipxDHost"), 13 * sizeof(TCHAR));
                RegSetValueEx(hkeyInterfaces, "LowerRange", 0, REG_SZ,
                              (LPBYTE)TEXT("netbios,ipxDHost"), 13 * sizeof(TCHAR));
                RegSetValueEx(hkeyInterfaces, "Lower", 0, REG_SZ,
                              (LPBYTE)TEXT("netbios,ipxDHost"), 13 * sizeof(TCHAR));
                RegSetValueEx(hkeyInterfaces, "Upper", 0, REG_SZ,
                              (LPBYTE)TEXT(""), sizeof(TCHAR));
                RegCloseKey(hkeyInterfaces);
            }
            if (err == ERROR_SUCCESS)
                err = RegSetValue(hkey, "Install", REG_SZ, "FAMILY.Install", 14);
            if (err == ERROR_SUCCESS)
                err = RegSetValue(hkey, "Remove", REG_SZ, "FAMILY.Remove", 13);
            if (err == ERROR_SUCCESS)
                err = RegSetValue(hkey, "Default", REG_SZ, "True", 5);

            RegCloseKey(hkey);
        }
        RegCloseKey(hkeyFamilyClient);
    }
    RegCloseKey(hkeyNetClient);

    if (err != ERROR_SUCCESS)
        return TRUE;

    /* Now the other half of the database, under HKLM\Enum\Network.  This has
     * a subkey (named by DeviceID, as seen above) for each network component.
     * Under each such subkey, there's a numbered subkey for each instance.
     * We have three tasks here:  First of all, for each instance of the client
     * that used to be the default, we have to mask out bit 0x00000010 from
     * the ConfigFlags value, to make it no longer the default client.  Then
     * we have to create a new branch for our own client, which mainly points
     * back to the other section of the database which we just finished with.
     * Finally, we must find MSTCP and add a binding between it and our client,
     * because NETDI assumes that a client that's not bound to any transports
     * must be messed up, so it deletes it.
     */

    HKEY hkeyEnum;
    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Enum\\Network", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                         NULL, &hkeyEnum, &dwDisp);
    if (err != ERROR_SUCCESS)
        return TRUE;

    /* Un-default the default client. */
    if (szDefaultDeviceID[0] != '\0') {
        HKEY hkeyDefaultDevice;
        err = RegOpenKeyEx(hkeyEnum, szDefaultDeviceID, 0,
                           KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                           &hkeyDefaultDevice);
        if (err == ERROR_SUCCESS) {
            NLS_STR nlsSubKey(20);       /* enough for four digits, plus some just in case */
            DWORD iSubKey = 0;

            for (;;) {
                err = RegEnumKey(hkeyDefaultDevice, iSubKey, nlsSubKey.Party(), nlsSubKey.QueryAllocSize());
                nlsSubKey.DonePartying();
                if (err != ERROR_SUCCESS)
                    break;

                HKEY hkeyInstance;
                err = RegOpenKeyEx(hkeyDefaultDevice, nlsSubKey.QueryPch(),
                                   0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
                if (err == ERROR_SUCCESS) {
                    DWORD dwConfigFlags;
                    cbData = sizeof(dwConfigFlags);
                    err = RegQueryValueEx(hkeyInstance, "ConfigFlags", NULL,
                                          &dwType, (LPBYTE)&dwConfigFlags,
                                          &cbData);
                    if (err == ERROR_SUCCESS &&
                        (dwType == REG_DWORD || dwType == REG_BINARY) &&
                        (dwConfigFlags & 0x10)) {
                        dwConfigFlags &= ~0x10;
                        RegSetValueEx(hkeyInstance, "ConfigFlags", 0, dwType,
                                      (LPBYTE)&dwConfigFlags, cbData);
                    }
                    RegCloseKey(hkeyInstance);
                }

                iSubKey++;
            }
            RegCloseKey(hkeyDefaultDevice);
        }
    }

    /* Now create a new branch for our client. */

    err = RegCreateKeyEx(hkeyEnum, "FAMILY\\0000", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        RegSetValueEx(hkeyFamilyClient, "Class", 0, REG_SZ,
                      (LPBYTE)TEXT("NetClient"), 10 * sizeof(TCHAR));
        lstrcpy(szBuf, "NetClient\\");
        lstrcat(szBuf, szFamilyNumString);
        RegSetValueEx(hkeyFamilyClient, "Driver", 0, REG_SZ, (LPBYTE)szBuf, lstrlen(szBuf)+1);
        RegSetValueEx(hkeyFamilyClient, "MasterCopy", 0, REG_SZ,
                      (LPBYTE)TEXT("Enum\\Network\\FAMILY\\0000"), 25 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "DeviceDesc", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
        RegSetValueEx(hkeyFamilyClient, "CompatibleIDs", 0, REG_SZ,
                      (LPBYTE)TEXT("FAMILY"), 7 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "Mfg", 0, REG_SZ,
                      (LPBYTE)TEXT("Microsoft"), 10 * sizeof(TCHAR));
        dwTemp = 0x00000010;
        RegSetValueEx(hkeyFamilyClient, "ConfigFlags", 0, REG_BINARY,
                      (LPBYTE)&dwTemp, sizeof(dwTemp));

        /* A "Bindings" subkey needs to exist here, with no values in it
         * (since our "client" isn't bound to any higher level components
         * like servers).
         */
        err = RegCreateKeyEx(hkeyFamilyClient, "Bindings", 
                             0, "", REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE,
                             NULL, &hkey, &dwDisp);
        if (err == ERROR_SUCCESS)
            RegCloseKey(hkey);

        RegCloseKey(hkeyFamilyClient);
    }

    /* Get MSTCP's enum key, get the first instance, and from it we can find
     * the "master" instance.  We can then add a binding to ourselves there.
     * Can't just assume "0000" as the first one, unfortunately.
     */
    err = RegOpenKeyEx(hkeyEnum, "MSTCP", 0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                       &hkey);
    if (err == ERROR_SUCCESS) {
        NLS_STR nlsSubKey(20);       /* enough for four digits, plus some just in case */
        DWORD iSubKey = 0;

        for (;;) {
            err = RegEnumKey(hkey, iSubKey, nlsSubKey.Party(), nlsSubKey.QueryAllocSize());
            nlsSubKey.DonePartying();
            if (err != ERROR_SUCCESS)
                break;

            HKEY hkeyInstance;
            err = RegOpenKeyEx(hkey, nlsSubKey.QueryPch(),
                               0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
            if (err == ERROR_SUCCESS) {
                cbData = sizeof(szBuf);
                err = RegQueryValueEx(hkeyInstance, "MasterCopy", NULL,
                                      &dwType, (LPBYTE)szBuf,
                                      &cbData);
                RegCloseKey(hkeyInstance);

                /* The MasterCopy value is actually a path to a registry key
                 * from HKEY_LOCAL_MACHINE.  We want to deal with its Bindings
                 * subkey.
                 */
                if (err == ERROR_SUCCESS) {
                    HKEY hkeyBindings;
                    lstrcat(szBuf, "\\Bindings");
                    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuf,
                                         0, "", REG_OPTION_NON_VOLATILE,
                                         KEY_SET_VALUE,
                                         NULL, &hkeyBindings, &dwDisp);
                    if (err == ERROR_SUCCESS) {
                        RegSetValueEx(hkeyBindings, "FAMILY\\0000", 0, REG_SZ,
                                      (LPBYTE)TEXT(""), sizeof(TCHAR));
                        RegCloseKey(hkeyBindings);
                    }
                    break;      /* abandon enum loop */
                }

                iSubKey++;
            }
        }
        RegCloseKey(hkey);
    }

    RegCloseKey(hkeyEnum);

    return TRUE;
}


/*
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

         Snarfed from shlwapi so we don't end up loading him at
         boot time.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyEx(hkey, pszSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkey, pszSubKey);
    }

    return dwRet;
}


void DeinstallLogonDialog(void)
{
    RegDeleteKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB\\NetworkProvider");
    RegDeleteKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB");

    HKEY hkey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                     0, KEY_WRITE, &hkey) == ERROR_SUCCESS) {
        RegDeleteValue(hkey, "NPSTUB");
        RegCloseKey(hkey);
    }

    char szBuf[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
                     0, KEY_WRITE, &hkey) == ERROR_SUCCESS) {
        DWORD cbData = sizeof(szBuf);
        DWORD dwType;
        LONG err = RegQueryValueEx(hkey, "PrimaryProvider", NULL, &dwType,
                                   (LPBYTE)szBuf, &cbData);
        if (err == ERROR_SUCCESS && szBuf[0] != '\0') {
            NLS_STR nlsNPName(MAX_RES_STR_LEN);
            if (nlsNPName.LoadString(IDS_NP_NAME) == ERROR_SUCCESS) {
                if (!::strcmpf(nlsNPName.QueryPch(), szBuf)) {
                    RegDeleteValue(hkey, "PrimaryProvider");
                }
            }
        }

        RegCloseKey(hkey);
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Enum\\Network\\FAMILY", 0,
                     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_WRITE,
                     &hkey) == ERROR_SUCCESS) {
        UINT i=0;

        /* For each instance of us under the Enum branch, fetch the
         * corresponding key name under the other half of the database
         * and delete it.
         */
        for (;;) {
            DWORD err = RegEnumKey(hkey, i, szBuf, sizeof(szBuf));
            if (err != ERROR_SUCCESS)
                break;

            HKEY hkeyInstance;
            err = RegOpenKeyEx(hkey, szBuf,
                               0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
            if (err == ERROR_SUCCESS) {
                strcpyf(szBuf, "System\\CurrentControlSet\\Services\\Class\\");

                DWORD dwType;
                DWORD cbData = sizeof(szBuf) - 40;  /* - length of above string */
                if (RegQueryValueEx(hkeyInstance, "Driver", NULL, &dwType,
                                    (LPBYTE)szBuf + 40, &cbData) == ERROR_SUCCESS) {
                    /* szBuf now equals the other branch we need to kill */
                    DeleteKeyRecursively(HKEY_LOCAL_MACHINE, szBuf);
                }
                RegCloseKey(hkeyInstance);
            }
            i++;
        }

        RegCloseKey(hkey);

        DeleteKeyRecursively(HKEY_LOCAL_MACHINE, "Enum\\Network\\FAMILY");
    }

    /* Now clean up bindings to our client, otherwise PNP will try to install
     * us as a new (unknown) device.  This involves enumerating components
     * under HKLM\Enum\Network;  for each one, enumerate the instances;  for
     * each instance's Bindings key, enumerate the values, and delete all
     * values that begin with FAMILY\.
     */

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Enum\\Network", 0,
                     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_WRITE,
                     &hkey) == ERROR_SUCCESS) {
        UINT iComponent = 0;

        for (;;) {
            DWORD err = RegEnumKey(hkey, iComponent, szBuf, sizeof(szBuf));
            if (err != ERROR_SUCCESS)
                break;

            HKEY hkeyComponent;
            err = RegOpenKeyEx(hkey, szBuf,
                               0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyComponent);
            if (err == ERROR_SUCCESS) {

                /* Opened a component's key.  Enumerate its instances, opening
                 * each one's Bindings subkey.
                 */
                TCHAR szInstance[16];       /* actually only needs to be "nnnn\Bindings" plus null char */

                UINT iInstance = 0;

                for (;;) {
                    err = RegEnumKey(hkeyComponent, iInstance, szInstance, sizeof(szInstance));
                    if (err != ERROR_SUCCESS)
                        break;

                    if (strlenf(szInstance)*sizeof(TCHAR) <= sizeof(szInstance) - sizeof("\\Bindings"))
                        strcatf(szInstance, "\\Bindings");
                    HKEY hkeyInstance;
                    err = RegOpenKeyEx(hkeyComponent, szInstance,
                               0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
                    if (err == ERROR_SUCCESS) {

                        /* Opened a Bindings subkey.  For each value under this
                         * key, the value name indicates the instance being
                         * bound to, and the value data is empty.  So we can
                         * enum values, ignoring the value data and type and
                         * just concentrating on the name.
                         */

                        TCHAR szValueName[64];      /* usually "COMPONENT\nnnn" */
                        UINT iValue = 0;
                        for (;;) {
                            DWORD cchValue = ARRAYSIZE(szValueName);
                            err = RegEnumValue(hkeyInstance, iValue, szValueName, 
                                               &cchValue, NULL, NULL, NULL, NULL);
                            if (err != ERROR_SUCCESS)
                                break;

                            /* If this is a binding to our client, delete the
                             * binding and reset (deleting values while enuming
                             * can be unpredictable).
                             */
                            if (!strnicmpf(szValueName, "FAMILY\\", 7)) {
                                RegDeleteValue(hkeyInstance, szValueName);
                                iValue = 0;
                                continue;
                            }

                            iValue++;
                        }

                        RegCloseKey(hkeyInstance);
                    }

                    iInstance++;
                }


                RegCloseKey(hkeyComponent);
            }
            iComponent++;
        }

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\mslunp.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"
#include <winnetwk.h>
#include <netspi.h>

#pragma data_seg(".shared")
char szDefaultLogonUsername[MAX_PATH] = "";
char szDefaultLogonPassword[MAX_PATH] = "";
BOOL fDoDefaultLogon = FALSE;
#pragma data_seg()


struct LogonData
{
    LPLOGONINFO lpAuthentInfo;
    DWORD dwFlags;
    IUser **ppOut;
    HBITMAP hbmTransparent;
};


void ObfuscateString(LPSTR pszBuffer)
{
    DWORD dwMask = 0xa95e633b;      /* nice random collection of bits */

    unsigned char ch;
    do {
        ch = *pszBuffer;

        *(pszBuffer++) = ch ^ (unsigned char)(dwMask & 0xff);
        dwMask = (dwMask >> 8) | (dwMask << 24);
    } while (ch);
}


void DeObfuscateString(LPSTR pszBuffer)
{
    DWORD dwMask = 0xa95e633b;      /* nice random collection of bits */

    unsigned char ch;
    do {
        ch = *pszBuffer ^ (unsigned char)(dwMask & 0xff);

        *(pszBuffer++) = ch;
        dwMask = (dwMask >> 8) | (dwMask << 24);
    } while (ch);
}


void CacheLogonCredentials(LPCSTR pszUsername, LPCSTR pszPassword)
{
    lstrcpy(szDefaultLogonUsername, pszUsername);
    lstrcpy(szDefaultLogonPassword, pszPassword);
    fDoDefaultLogon = TRUE;

    ObfuscateString(szDefaultLogonUsername);
    ObfuscateString(szDefaultLogonPassword);
}


SPIENTRY NPGetCaps(
    DWORD nIndex
    )
{
    switch (nIndex) {
    case WNNC_SPEC_VERSION:
        return 0x00040001;          /* spec version 4.1 */

    case WNNC_NET_TYPE:
        return WNNC_NET_MSNET;

    case WNNC_DRIVER_VERSION:
        return 0x00010000;          /* driver version 1.0 */

    case WNNC_USER:
        return
//          WNNC_USR_GETUSER |
            0;

    case WNNC_CONNECTION:
        return
            0;

    case WNNC_DIALOG:
        return
            0;

    case WNNC_ENUMERATION:
        return
            0;

    case WNNC_START:
        return 0x1;                 /* started */

    case WNNC_RESOURCE:
        return
            0;

    case WNNC_AUTHENTICATION:
        return
            WNNC_AUTH_LOGON |
            WNNC_AUTH_LOGOFF |
//          WNNC_AUTH_GETHOMEDIRECTORY |
//          WNNC_AUTH_GETPOLICYPATH |
            0;
    }

    return 0;
}

// FEATURE not multimonitor friendly

VOID PlaceDialog(HWND hDlg, BOOL fTopThird)
{
    RECT rc;
    int dyScreen = GetSystemMetrics(SM_CYSCREEN);
    int yDialog;

    GetWindowRect(hDlg,&rc);

    if (fTopThird)
        yDialog = (dyScreen / 3) - ((rc.bottom-rc.top) / 2);
    else
        yDialog = (dyScreen - (rc.bottom - rc.top)) / 2;

    SetWindowPos(hDlg,NULL,
               (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2,
               yDialog, 0, 0, SWP_NOSIZE);
}


void UserSelected(HWND hwndLB, int iItem)
{
    BOOL fNeedPassword;
    BOOL fEnableOK;

    if (iItem == LB_ERR) {
        fNeedPassword = FALSE;
        fEnableOK = FALSE;
    }
    else {
        IUser *pUser = (IUser *)::SendMessage(hwndLB, LB_GETITEMDATA, iItem, 0);
        fNeedPassword = FAILED(pUser->Authenticate(""));
        fEnableOK = TRUE;
    }
    HWND hDlg = GetParent(hwndLB);
    EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD_LABEL), fNeedPassword);
    EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD), fNeedPassword);
    EnableWindow(GetDlgItem(hDlg, IDOK), fEnableOK);
}


HRESULT FillUserList(HWND hwndLB, IUserDatabase *pDB, LPCSTR pszDefaultSelection,
                     BOOL fIncludeGuest, PFNSELNOTIFY pfnSelNotify)
{
    IEnumUnknown *pEnum;
    BOOL fSelectionSet = FALSE;

    if (fIncludeGuest) {
        NLS_STR nlsTemp(MAX_RES_STR_LEN);
        if (nlsTemp.LoadString(IDS_GUEST_USERNAME) == ERROR_SUCCESS) {
            UINT iItem = (UINT)::SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)nlsTemp.QueryPch());
            if (iItem != LB_ERR && iItem != LB_ERRSPACE) {
                ::SendMessage(hwndLB, LB_SETITEMDATA, iItem, 0);
            }
        }
    }

    HRESULT hres = pDB->EnumUsers(&pEnum);
    if (SUCCEEDED(hres)) {
        IUnknown *pUnk;
        while (pEnum->Next(1, &pUnk, NULL) == S_OK) {
            IUser *pUser;
            if (SUCCEEDED(pUnk->QueryInterface(IID_IUser, (void **)&pUser))) {
                char szBuf[cchMaxUsername+1];
                DWORD cbBuffer = sizeof(szBuf);

                if (SUCCEEDED(pUser->GetName(szBuf, &cbBuffer))) {
                    UINT iItem = (UINT)::SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuf);
                    if (iItem != LB_ERR && iItem != LB_ERRSPACE) {
                        if (::SendMessage(hwndLB, LB_SETITEMDATA, iItem, (LPARAM)pUser) == LB_ERR)
                            ::SendMessage(hwndLB, LB_SETITEMDATA, iItem, 0);
                        if (!fSelectionSet) {
                            if (pszDefaultSelection != NULL && !::stricmpf(szBuf, pszDefaultSelection)) {
                                fSelectionSet = TRUE;
                                ::SendMessage(hwndLB, LB_SETCURSEL, iItem, 0);
                                if (pfnSelNotify != NULL)
                                    (*pfnSelNotify)(hwndLB, iItem);
                            }
                        }
                    }
                }
                /* Note that pUser is not Release()d here, since the
                 * listbox has a pointer to it.
                 */
            }
            pUnk->Release();
        }

        if (!fSelectionSet) {
            if (pfnSelNotify)
                (*pfnSelNotify)(hwndLB, LB_ERR);
        }
        else {
            /* If we select the default item above, then insert more names
             * above it, the focus rect and the selection will be different,
             * which is confusing if the user tabs to the listbox.  Work
             * around this by setting the caret index manually.
             */
            LRESULT iItem = ::SendMessage(hwndLB, LB_GETCURSEL, 0, 0);
            if (iItem != LB_ERR)
                ::SendMessage(hwndLB, LB_SETCURSEL, iItem, 0);
        }

        pEnum->Release();
    }

    if (FAILED(hres))
        return hres;

    return fSelectionSet ? NOERROR : S_FALSE;
}


BOOL IsMemphis(void)
{
    OSVERSIONINFOA osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    return (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId &&
            (osvi.dwMajorVersion > 4 || 
             (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion >= 10)));
}


DWORD InitLogonDialog(HWND hwndDialog, LogonData *pld)
{
    DWORD err = WN_NO_NETWORK;
    BOOL fSelectionSet = FALSE;

    ::SetWindowLongPtr(hwndDialog, DWLP_USER, (LONG_PTR)pld);

    PlaceDialog(hwndDialog, FALSE);

    int idBitmap;
    DWORD dwFlags;

    if (IsMemphis())
        idBitmap = IDB_IMAGE_WIN98_LOGON;
    else
        idBitmap = IDB_IMAGE_LOGON;

    /* The bitmap we show at the top of the logon dialog has black text on a
     * transparent background.  If the dialog background is very dark, the
     * text will be unreadable.  In that case we use a static bitmap with
     * a white background.  For more common background colors, though, we use
     * LoadImage to load a transparent image and replace the bitmap in the
     * dialog.
     *
     * CODEWORK: Could try a variant of COLORISLIGHT macro from shell32,
     * defview.cpp;  it seems pretty aggressive about declaring blues in
     * particular as "dark".  Maybe we could have the alternate bitmap be
     * 3D-mapped as well, but have white text and maybe a white box around
     * the Windows flag, then we could always be transparent and just choose
     * one or the other at an arbitrary cutoff point.
     */
    DWORD clrBtnFace = GetSysColor(COLOR_3DFACE);
    if ((LOBYTE(clrBtnFace) >= 128) ||
        (LOBYTE(clrBtnFace >> 8) >= 128) ||
        (LOBYTE(clrBtnFace >> 16) >= 128)) {

        dwFlags = LR_LOADMAP3DCOLORS;       /* we'll use a transparent bitmap */
    }
    else {
        idBitmap++;             /* advance to static bitmap ID */
        dwFlags = LR_DEFAULTCOLOR;
    }

    pld->hbmTransparent = (HBITMAP)LoadImage(::hInstance,
                                        MAKEINTRESOURCE(idBitmap),
                                        IMAGE_BITMAP, 0, 0,
                                        dwFlags);
    if (pld->hbmTransparent != NULL) {
        HBITMAP hbmOld = (HBITMAP)SendDlgItemMessage(hwndDialog,
                                                     IDC_MAIN_CAPTION,
                                                     STM_SETIMAGE,
                                                     (WPARAM)IMAGE_BITMAP,
                                                     (LPARAM)pld->hbmTransparent);
        /* If we set the new bitmap into the control, we got the old one
         * back.  Delete the old one.  We will also have to delete the
         * new one when the dialog is dismissed.
         */
        if (hbmOld != NULL)
            DeleteObject(hbmOld);
    }

    IUserDatabase *pDB;

    if (SUCCEEDED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        HRESULT hres = FillUserList(GetDlgItem(hwndDialog, IDC_USERNAME),
                                    pDB, pld->lpAuthentInfo ? pld->lpAuthentInfo->lpUsername : NULL,
                                    FALSE, UserSelected);

        if (SUCCEEDED(hres)) {
            err = ERROR_SUCCESS;

            ::SetFocus(::GetDlgItem(hwndDialog, hres == NOERROR ? IDC_PASSWORD : IDC_USERNAME));
        }
        pDB->Release();
    }

    return err;
}


BOOL ValidateLogonDialog(HWND hwndDialog)
{
    LRESULT iItem = ::SendDlgItemMessage(hwndDialog, IDC_USERNAME, LB_GETCURSEL, 0, 0);
    if (iItem == LB_ERR)
        return FALSE;

    IUser *pUser = (IUser *)::SendDlgItemMessage(hwndDialog, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);

    if (pUser != NULL) {
        NLS_STR nlsUsername(cchMaxUsername+1);
        if (nlsUsername.QueryError())
            return FALSE;

        DWORD cbBuffer = nlsUsername.QueryAllocSize();
        pUser->GetName(nlsUsername.Party(), &cbBuffer);
        nlsUsername.DonePartying();

        HWND hwndPassword = ::GetDlgItem(hwndDialog, IDC_PASSWORD);
        NLS_STR nlsPassword(::GetWindowTextLength(hwndPassword)+2);
        if (nlsPassword.QueryError())
            return FALSE;

        ::GetWindowText(hwndPassword, nlsPassword.Party(), nlsPassword.QueryAllocSize()-1);
        nlsPassword.DonePartying();

        if (SUCCEEDED(pUser->Authenticate(nlsPassword.QueryPch()))) {
            LogonData *pld = (LogonData *)::GetWindowLongPtr(hwndDialog, DWLP_USER);
            if (pld->lpAuthentInfo) {
                DWORD cbUsername = pld->lpAuthentInfo->cbUsername;
                DWORD cbPassword = pld->lpAuthentInfo->cbPassword;
                NPSCopyNLS(&nlsUsername, pld->lpAuthentInfo->lpUsername, &cbUsername);
                NPSCopyNLS(&nlsPassword, pld->lpAuthentInfo->lpPassword, &cbPassword);
            }

            if (pld->ppOut) {
                *pld->ppOut = pUser;
                pUser->AddRef();
            }

            if (pld->dwFlags & LUA_FORNEXTLOGON) {
                CacheLogonCredentials(nlsUsername.QueryPch(), nlsPassword.QueryPch());
            }

            return TRUE;
        }

        NLS_STR nlsTitle(MAX_RES_STR_LEN);
        NLS_STR nlsMessage(MAX_RES_STR_LEN);
        if (!nlsTitle.QueryError() && !nlsMessage.QueryError()) {
            nlsTitle.LoadString(IDS_LOGONTITLE);
            nlsMessage.LoadString(IDS_BADPASSWORD);
            ::MessageBox(hwndDialog, nlsMessage.QueryPch(), nlsTitle.QueryPch(), MB_ICONSTOP | MB_OK);
        }
        ::SetFocus(hwndPassword);
        ::SendMessage(hwndPassword, EM_SETSEL, (WPARAM)(INT)0, (WPARAM)(INT)-1);
    }
    return FALSE;
}


void DestroyUserList(HWND hwndLB)
{
    LRESULT cItems = ::SendMessage(hwndLB, LB_GETCOUNT, 0, 0);

    for (LRESULT iItem = 0; iItem < cItems; iItem++) {
        IUser *pUser = (IUser *)::SendMessage(hwndLB, LB_GETITEMDATA, iItem, 0);
        if (pUser != NULL) {
            pUser->Release();
        }
    }
}


void ExitLogonDialog(HWND hwndDialog, DWORD err)
{
    DestroyUserList(GetDlgItem(hwndDialog, IDC_USERNAME));

    LogonData *pld = (LogonData *)::GetWindowLongPtr(hwndDialog, DWLP_USER);
    if (pld->hbmTransparent != NULL)
        DeleteObject(pld->hbmTransparent);

    ::EndDialog(hwndDialog, err);
}


extern "C" {

INT_PTR LogonDlgProc(
    HWND hwndDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
#if 0   /*** no help for now ***/
    // Help text array
    static DWORD aIds[] = {
        IDC_DUMMY1, IDH_NET_LOG_USERNAME,
        IDD_LOG_USERNAME, IDH_NET_LOG_USERNAME,
        IDC_DUMMY2, IDH_NET_LOG_PASSWORD,
        IDD_LOG_PASSWORD, IDH_NET_LOG_PASSWORD,
        IDC_LOGOFRAME, NO_HELP,
        IDC_DUMMY3, NO_HELP,
        0,0
    };
#endif

    switch (msg) {
    case WM_INITDIALOG:
        {
            DWORD err = ::InitLogonDialog(hwndDlg, (LogonData *)lParam);
            if (err != ERROR_SUCCESS) {
                ::ExitLogonDialog(hwndDlg, err);
            }
        }
        return FALSE;           /* we set the focus */

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            ::ExitLogonDialog(hwndDlg, WN_CANCEL);
            return TRUE;        /* we processed a message */

        case IDOK:
            if (::ValidateLogonDialog(hwndDlg))
                ::ExitLogonDialog(hwndDlg, WN_SUCCESS);
            return TRUE;        /* we processed a message */

        case IDC_USERNAME:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
                int iItem = (int)::SendDlgItemMessage(hwndDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                UserSelected((HWND)lParam, iItem);
            }
        }
        break;

#if 0   /*** no help for now ***/
    case WM_HELP:
        WinHelp( ((LPHELPINFO)lParam)->hItemHandle, szHelpFile,
                HELP_WM_HELP, (DWORD)(LPVOID)aIds );
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp( (HWND)wParam, szHelpFile, HELP_CONTEXTMENU,
                (DWORD)(LPVOID)aIds );
        return TRUE;
#endif
    }

    return FALSE;               /* we didn't process the message */
}

};  /* extern "C" */


DWORD DoLogonDialog(HWND hwndOwner, LPLOGONINFO lpAuthentInfo)
{
    LogonData ld;

    ld.lpAuthentInfo = lpAuthentInfo;
    ld.dwFlags = 0;
    ld.ppOut = NULL;
    ld.hbmTransparent = NULL;

    INT_PTR nRet = ::DialogBoxParam(::hInstance, MAKEINTRESOURCE(IDD_LOGON),
                                    hwndOwner, LogonDlgProc, (LPARAM)&ld);

    if (nRet == -1)
        return WN_OUT_OF_MEMORY;
    else
        return (DWORD)nRet;
}


HRESULT DoUserDialog(HWND hwndOwner, DWORD dwFlags, IUser **ppOut)
{
    LogonData ld;

    ld.lpAuthentInfo = NULL;
    ld.dwFlags = dwFlags;
    ld.ppOut = ppOut;
    if (ppOut != NULL)
        *ppOut = NULL;

    INT_PTR nRet = ::DialogBoxParam(::hInstance, MAKEINTRESOURCE(IDD_LOGON),
                                    hwndOwner, LogonDlgProc, (LPARAM)&ld);

    if (nRet == -1)
        return E_OUTOFMEMORY;
    else
        return (nRet == WN_SUCCESS) ? S_OK : E_ABORT;
}


DWORD TryDefaultLogon(LPCSTR pszUsername, LPCSTR pszPassword, LPLOGONINFO lpAuthentInfo)
{
    IUserDatabase *pDB = NULL;
    if (FAILED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        return WN_OUT_OF_MEMORY;
    }

    DWORD err;
    IUser *pUser;
    if (SUCCEEDED(pDB->GetUser(pszUsername, &pUser))) {
        if (SUCCEEDED(pUser->Authenticate(pszPassword)))
            err = WN_SUCCESS;
        else
            err = WN_BAD_PASSWORD;

        pUser->Release();
    }
    else {
        err = WN_BAD_USER;
    }

    pDB->Release();

    if (err == WN_SUCCESS) {
        DWORD cbUsername = lpAuthentInfo->cbUsername;
        DWORD cbPassword = lpAuthentInfo->cbPassword;
        NPSCopyString(pszUsername, lpAuthentInfo->lpUsername, &cbUsername);
        NPSCopyString(pszPassword, lpAuthentInfo->lpPassword, &cbPassword);
    }

    return err;
}


SPIENTRY NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    )
{
    /* ignore logon done notification, we only act on logon starting */
    if (dwFlags & LOGON_DONE) {
        return WN_SUCCESS;
    }

    /* we have nothing to do if we're not the primary logon provider */
    if (!(dwFlags & LOGON_PRIMARY)) {
        return WN_SUCCESS;
    }

    /* make sure profiles are enabled, fall back to windows logon if not */
    HKEY hkeyLogon;
    DWORD err;
    DWORD fProfilesEnabled = FALSE;
    DWORD cbData = sizeof(fProfilesEnabled);
    err = ::RegOpenKey(HKEY_LOCAL_MACHINE, ::szLogonKey, &hkeyLogon);
    if (err != ERROR_SUCCESS)
        return WN_NO_NETWORK;
    err = ::RegQueryValueEx(hkeyLogon, ::szUserProfiles, NULL, NULL,
                            (LPBYTE)&fProfilesEnabled, &cbData);
    ::RegCloseKey(hkeyLogon);
    if (err != ERROR_SUCCESS || !fProfilesEnabled)
        return WN_NO_NETWORK;

    /* If we have cached logon credentials, attempt to use them. */

    if (fDoDefaultLogon) {
        DeObfuscateString(szDefaultLogonUsername);
        DeObfuscateString(szDefaultLogonPassword);

        DWORD err = TryDefaultLogon(szDefaultLogonUsername, szDefaultLogonPassword, lpAuthentInfo);

        ::memsetf(szDefaultLogonUsername, '\0', sizeof(szDefaultLogonUsername));
        ::memsetf(szDefaultLogonPassword, '\0', sizeof(szDefaultLogonPassword));
        fDoDefaultLogon = FALSE;

        if (err == WN_SUCCESS)
            return WN_SUCCESS;
    }

    return DoLogonDialog(hwndOwner, lpAuthentInfo);
}


SPIENTRY NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    )
{
    return WN_SUCCESS;
}


SPIENTRY NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
    DWORD dwFlags
    )
{
    return WN_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\pcerr.h ===
/*****************************************************************/
/**				   Microsoft Windows for Workgroups				**/
/**				Copyright (C) Microsoft Corp., 1991-1992		**/
/*****************************************************************/

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
	Password cache error codes.
*/

#define IERR_PCACHE_BASE		7200
#define IERR_CachingDisabled	(IERR_PCACHE_BASE + 0)
#define IERR_BadSig				(IERR_PCACHE_BASE + 1)
#define IERR_VersionChanged		(IERR_PCACHE_BASE + 2)
#define IERR_CacheNotLoaded		(IERR_PCACHE_BASE + 3)
#define IERR_CacheEntryNotFound	(IERR_PCACHE_BASE + 4)
#define IERR_CacheReadOnly		(IERR_PCACHE_BASE + 5)
#define IERR_IncorrectUsername	(IERR_PCACHE_BASE + 6)
#define IERR_CacheCorrupt		(IERR_PCACHE_BASE + 7)
#define IERR_EntryTooLarge		(IERR_PCACHE_BASE + 8)
#define IERR_CacheEnumCancelled	(IERR_PCACHE_BASE + 9)
#define IERR_UsernameNotFound	(IERR_PCACHE_BASE + 10)
#define IERR_CacheFull			(IERR_PCACHE_BASE + 11)	/* only if cache would exceed 64K */
#define IERR_CacheAlreadyOpen	(IERR_PCACHE_BASE + 12)
#define IERR_CantCreateUniqueFile	(IERR_PCACHE_BASE + 13)
#define IERR_InvalidParameter	(IERR_PCACHE_BASE + 14)

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\netspi.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

/* NETSPI.H -- Network service provider interface definitions.
 */

#ifndef _INC_NETSPI
#define _INC_NETSPI

#ifndef _WINNETWK_
#include <winnetwk.h>
#endif

#ifndef _INC_NETMPR_
#include <netmpr.h>
#endif

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// Capability masks and values.
//

#define WNNC_SPEC_VERSION   0x01
#define     WNNC_SPEC_VERSION51 0x00050001

#define WNNC_NET_TYPE       0x02
// Net types defined in Winnetwk.h

#define WNNC_DRIVER_VERSION 0x03

#define WNNC_USER           0x04
#define     WNNC_USR_GETUSER    0x01

#define WNNC_CONNECTION     0x06
#define     WNNC_CON_ADDCONNECTION      0x01
#define     WNNC_CON_CANCELCONNECTION   0x02
#define     WNNC_CON_GETCONNECTIONS     0x04
#define     WNNC_CON_GETPERFORMANCE     0x08
#define     WNNC_CON_GETUNIVERSALNAME   0x10
#define     WNNC_CON_FORMATCONNECTION   0x20

#define WNNC_DIALOG         0x08
#define     WNNC_DLG_FORMATNETWORKNAME  0x080
#define     WNNC_DLG_GETRESOURCEPARENT  0x100
#define     WNNC_DLG_GETRESOURCEINFORMATION  0x800

#define WNNC_ERROR          0x0A
#define  WNNC_ERR_GETERROR              0x01
#define  WNNC_ERR_GETERRORTEXT          0x02

#define WNNC_ENUMERATION    0x0B
#define     WNNC_ENUM_GLOBAL    0x01
#define     WNNC_ENUM_LOCAL     0x02
#define     WNNC_ENUM_CONTEXT   0x04

#define WNNC_START          0x0C
#define     WNNC_START_WONT     0x00
#define     WNNC_START_UNKNOWN  0xFFFFFFFF
#define     WNNC_START_DONE     0x01
#define     WNNC_START_INACTIVE 0xFFFFFFFE

#define WNNC_RESOURCE       0x0D
#define     WNNC_RES_VALIDLOCALDEVICE   0x80

#define WNNC_AUTHENTICATION 0x0E
#define     WNNC_AUTH_LOGON             0x02
#define     WNNC_AUTH_LOGOFF            0x04
#define		WNNC_AUTH_GETHOMEDIRECTORY	0x10
#define		WNNC_AUTH_GETPOLICYPATH		0x20

#define WNNC_MAXCAPNO WNNC_AUTHENTICATION

//
// Profile strings.
//
#define NPProvider      "NPProvider"
#define NPName          "NPName"
#define NPDescription   "NPDescription"
#define NPID            "NPID"

//
// Various defines.
//
//Spec version
#define WNNC_DRIVER_MAJOR1  1  
#define WNNC_DRIVER_MINOR1  1
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)

//
// NP SPI Definitions.
//

#define SPIENTRY DWORD WINAPI

typedef SPIENTRY F_NPGetCaps(
    DWORD nIndex
    );

F_NPGetCaps NPGetCaps;
typedef F_NPGetCaps FAR *PF_NPGetCaps;

typedef SPIENTRY F_NPGetUniversalName(
	LPTSTR  lpLocalPath,
	DWORD   dwInfoLevel,
	LPVOID  lpBuffer,
	LPDWORD lpBufferSize
    );

F_NPGetUniversalName NPGetUniversalName;
typedef F_NPGetUniversalName FAR *PF_NPGetUniversalName;

typedef SPIENTRY F_NPGetUser(
    LPTSTR  lpName,
    LPTSTR  lpAuthenticationID,
    LPDWORD lpBufferSize
    );

F_NPGetUser NPGetUser;
typedef F_NPGetUser FAR *PF_NPGetUser;

typedef SPIENTRY F_NPValidLocalDevice(
    DWORD dwType,
    DWORD dwNumber
    );

F_NPValidLocalDevice NPValidLocalDevice;
typedef F_NPValidLocalDevice FAR *PF_NPValidLocalDevice;

typedef SPIENTRY F_NPAddConnection(
    HWND hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword,
    LPTSTR lpUserID,
    DWORD dwFlags,
	LPTSTR lpAccessName,
	LPDWORD lpBufferSize,
	LPDWORD lpResult
    );

F_NPAddConnection NPAddConnection;
typedef F_NPAddConnection FAR *PF_NPAddConnection;

typedef SPIENTRY F_NPCancelConnection(
    LPTSTR lpName,
    BOOL fForce,
 	DWORD dwFlags
    );

F_NPCancelConnection NPCancelConnection;
typedef F_NPCancelConnection FAR *PF_NPCancelConnection;

typedef SPIENTRY F_NPGetConnection(
    LPTSTR lpLocalName,
    LPTSTR lpRemoteName,
    LPDWORD lpBufferSize
    );

F_NPGetConnection NPGetConnection;
typedef F_NPGetConnection FAR *PF_NPGetConnection;

typedef SPIENTRY F_NPGetConnectionPerformance(
    LPTSTR lpRemoteName, 
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );

F_NPGetConnectionPerformance NPGetConnectionPerformance;
typedef F_NPGetConnectionPerformance FAR *PF_NPGetConnectionPerformance;

typedef SPIENTRY F_NPFormatNetworkName(
    LPTSTR lpRemoteName,
    LPTSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    );

F_NPFormatNetworkName NPFormatNetworkName;
typedef F_NPFormatNetworkName FAR *PF_NPFormatNetworkName;

typedef DWORD (FAR PASCAL *NPDISPLAYCALLBACK)(
    LPVOID  lpUserData,
    DWORD   dwDisplayType,
    LPTSTR  lpszHeaders
    );

typedef SPIENTRY F_NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCE lpNetResource,
    LPHANDLE lphEnum
    );

F_NPOpenEnum NPOpenEnum;
typedef F_NPOpenEnum FAR *PF_NPOpenEnum;

typedef SPIENTRY F_NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbFree
    );

F_NPEnumResource NPEnumResource;
typedef F_NPEnumResource FAR *PF_NPEnumResource;

typedef SPIENTRY F_NPCloseEnum(
    HANDLE hEnum
    );

F_NPCloseEnum NPCloseEnum;
typedef F_NPCloseEnum FAR *PF_NPCloseEnum;

typedef SPIENTRY F_NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    );

F_NPGetResourceParent NPGetResourceParent;
typedef F_NPGetResourceParent FAR *PF_NPGetResourceParent;

typedef SPIENTRY F_NPGetResourceInformation(
	LPNETRESOURCE lpNetResource,
	LPVOID lpBuffer,
	LPDWORD cbBuffer,
	LPSTR *lplpSystem
    );

F_NPGetResourceInformation NPGetResourceInformation;
typedef F_NPGetResourceInformation FAR *PF_NPGetResourceInformation;

typedef struct _LOGONINFO {
    LPTSTR lpUsername;
    LPTSTR lpPassword;
	DWORD cbUsername;
	DWORD cbPassword;
} LOGONINFO, FAR *LPLOGONINFO;

typedef SPIENTRY F_NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    );

F_NPLogon NPLogon;
typedef F_NPLogon FAR *PF_NPLogon;

typedef SPIENTRY F_NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    );

F_NPLogoff NPLogoff;
typedef F_NPLogoff FAR *PF_NPLogoff;

typedef SPIENTRY F_NPChangePassword(
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
	DWORD		dwAction
	);

F_NPChangePassword NPChangePassword;
typedef F_NPChangePassword FAR *PF_NPChangePassword;

typedef SPIENTRY F_NPChangePasswordHwnd(
	HWND hwndOwner
	);

F_NPChangePasswordHwnd NPChangePasswordHwnd;
typedef F_NPChangePasswordHwnd FAR *PF_NPChangePasswordHwnd;


typedef SPIENTRY F_NPGetPasswordStatus(
	DWORD		nIndex
	);

F_NPGetPasswordStatus NPGetPasswordStatus;
typedef F_NPGetPasswordStatus FAR *PF_NPGetPasswordStatus;


typedef SPIENTRY F_NPGetHomeDirectory(
    LPTSTR lpDirectory,
    LPDWORD lpBufferSize
    );

F_NPGetHomeDirectory NPGetHomeDirectory;
typedef F_NPGetHomeDirectory FAR *PF_NPGetHomeDirectory;

typedef SPIENTRY F_NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
	DWORD dwFlags
    );

// flags for NPGetPolicyPath
#define GPP_LOADBALANCE	0x0001

F_NPGetPolicyPath NPGetPolicyPath;
typedef F_NPGetPolicyPath FAR *PF_NPGetPolicyPath;

//
// MPR Services.
//

#define NPSGetProviderHandle NPSGetProviderHandleA
#define NPSGetProviderName NPSGetProviderNameA
#define NPSGetSectionName NPSGetSectionNameA
#define NPSSetExtendedError NPSSetExtendedErrorA
#define NPSSetCustomText NPSSetCustomTextA
#define NPSCopyString NPSCopyStringA
#define NPSDeviceGetNumber NPSDeviceGetNumberA
#define NPSDeviceGetString NPSDeviceGetStringA
#define NPSNotifyRegister NPSNotifyRegisterA
#define NPSNotifyGetContext NPSNotifyGetContextA
#define NPSAuthenticationDialog NPSAuthenticationDialogA

#define NPSERVICE	WINAPI
#define HPROVIDER   LPVOID
typedef HPROVIDER FAR * PHPROVIDER;

typedef struct {
    DWORD  cbStructure;       /* size of this structure in bytes */
    HWND   hwndOwner;         /* owner window for the authentication dialog */
    LPCSTR lpResource;        /* remote name of resource being accessed */
    LPSTR  lpUsername;        /* default username to show, NULL to hide field */
    DWORD  cbUsername;        /* size of lpUsername buffer, set to length copied on exit */
    LPSTR  lpPassword;        /* default password to show */
    DWORD  cbPassword;        /* size of lpPassword buffer, set to length copied on exit */
    LPSTR  lpOrgUnit;         /* default org unit to show, NULL to hide field */
    DWORD  cbOrgUnit;         /* size of lpOrgUnit buffer, set to length copied on exit */
    LPCSTR lpOUTitle;         /* title of org unit field, NULL for default title */
    LPCSTR lpExplainText;     /* explanatory text at top, NULL for default text */
    LPCSTR lpDefaultUserName; /* explanatory text at top, NULL for default text */
    DWORD  dwFlags;           /* flags (see below) */
} AUTHDLGSTRUCTA, FAR *LPAUTHDLGSTRUCTA;
#define AUTHDLGSTRUCT AUTHDLGSTRUCTA
#define LPAUTHDLGSTRUCT LPAUTHDLGSTRUCTA

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

DWORD
NPSERVICE
NPSAuthenticationDialog(
    LPAUTHDLGSTRUCT lpAuthDlgStruct
    );

DWORD
NPSERVICE
NPSGetProviderHandle( 
	PHPROVIDER phProvider
	);

DWORD
NPSERVICE
NPSGetProviderName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszProviderName
	);

DWORD
NPSERVICE
NPSGetSectionName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszSectionName
	);

DWORD
NPSERVICE NPSSetExtendedError (
	DWORD NetSpecificError,
	LPSTR lpExtendedErrorText 
    );

VOID
NPSERVICE NPSSetCustomText (
	LPSTR lpCustomErrorText 
    );

DWORD
NPSERVICE
NPSCopyString (
    LPCTSTR lpString,
    LPVOID  lpBuffer,
    LPDWORD lpdwBufferSize
    );

DWORD
NPSERVICE
NPSDeviceGetNumber (
    LPTSTR  lpLocalName,
    LPDWORD lpdwNumber,
    LPDWORD lpdwType
    );

DWORD
NPSERVICE
NPSDeviceGetString (
    DWORD   dwNumber,
    DWORD   dwType,
    LPTSTR  lpLocalName,
    LPDWORD lpdwBufferSize
    );

// Notification Service.

enum NOTIFYTYPE { NotifyAddConnection, 
                  NotifyCancelConnection, 
                  NotifyGetConnectionPerformance };

#define NOTIFY_PRE              0x00
#define NOTIFY_POST             0x01

typedef struct _NOTIFYINFO {
    DWORD cbStructure;          /* size of NOTIFYINFO */
    DWORD  dwNotifyStatus;      /* Pre/post notification status */
    DWORD  dwOperationStatus;   /* Status of operation */
    LPVOID lpNPContext;         /* NP context */
} NOTIFYINFO, FAR *LPNOTIFYINFO;

typedef struct _NOTIFYADD {
    DWORD cbStructure;          /* size of NOTIFYADD */
    HWND hwndOwner;             /* hWnd for UI */
    NETRESOURCE NetResource;    /* Resource to add */
    DWORD dwAddFlags;           /* Add flags */
    LPTSTR lpAccessName;        /* System name for connection */
    LPDWORD lpBufferSize;       /* Size of AccessName buffer */
    DWORD dwResult;             /* Info about connection */
    DWORD dwAddContext;         /* Context of add connection */
} NOTIFYADD, FAR *LPNOTIFYADD;

#define CONNECT_CTXT_RESTORE        0x00000001
#define CONNECT_CTXT_GLOBAL         0x00000002
#define CONNECT_CTXT_PROVIDER       0x00000004
#define CONNECT_CTXT_SINGLE         0x00000008

typedef struct _NOTIFYCANCEL {
    DWORD cbStructure;          /* size of NOTIFYCANCEL */
    LPTSTR lpName;              /* Local device name or remote name of resource */
    LPTSTR lpProvider;          /* Provider name of resource cancelled */
    DWORD dwFlags;              /* Cancel flags */
    BOOL fForce;                /* Cancel force */
} NOTIFYCANCEL, FAR *LPNOTIFYCANCEL;

typedef struct _NOTIFYPERFORMANCE {
	DWORD cbStructure;          /* size of NOTIFYPERFORMANCE */
	LPTSTR lpRemoteName;        /* network resource name */
	LPTSTR lpProviderName;      /* provider to try/provider that responded */
	LPNETCONNECTINFOSTRUCT lpNetConnectInfo; /* performance information requested/returned */
} NOTIFYPERFORMANCE, FAR *LPNOTIFYPERFORMANCE;

typedef DWORD (FAR PASCAL *NOTIFYCALLBACK)( LPNOTIFYINFO lpNotifyInfo, LPVOID lpOperationInfo );

DWORD
NPSERVICE
NPSNotifyRegister(
    enum NOTIFYTYPE NotifyType,
    NOTIFYCALLBACK P_FNotifyCallBack
    );

LPVOID
NPSERVICE
NPSNotifyGetContext (
    NOTIFYCALLBACK P_FNotifyCallBack
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_NETSPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\pch.cpp ===
#include "mslocusr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\profiles.cpp ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* PROFILES.CPP -- Code for user profile management.
 *
 * History:
 *  01/04/94    gregj   Created
 *	06/28/94	gregj	Use sync engine for desktop, programs reconciliation
 *	09/05/96	gregj	Snarfed from MPR for use by IE4 family logon.
 */

#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"

#include <npmsg.h>
#include <regentry.h>
#include <buffer.h>
#include <shellapi.h>

HMODULE g_hmodShell = NULL;
typedef int (*PFNSHFILEOPERATIONA)(LPSHFILEOPSTRUCTA lpFileOp);
PFNSHFILEOPERATIONA g_pfnSHFileOperationA = NULL;


HRESULT LoadShellEntrypoint(void)
{
    if (g_pfnSHFileOperationA != NULL)
        return S_OK;

    HRESULT hres;
    ENTERCRITICAL
    {
        if (g_hmodShell == NULL) {
            g_hmodShell = ::LoadLibrary("SHELL32.DLL");
        }
        if (g_hmodShell != NULL) {
            g_pfnSHFileOperationA = (PFNSHFILEOPERATIONA)::GetProcAddress(g_hmodShell, "SHFileOperationA");
        }
        if (g_pfnSHFileOperationA == NULL)
            hres = HRESULT_FROM_WIN32(::GetLastError());
        else
            hres = S_OK;
    }
    LEAVECRITICAL

    return hres;
}


void UnloadShellEntrypoint(void)
{
    ENTERCRITICAL
    {
        if (g_hmodShell != NULL) {
            ::FreeLibrary(g_hmodShell);
            g_hmodShell = NULL;
            g_pfnSHFileOperationA = NULL;
        }
    }
    LEAVECRITICAL
}


const DWORD attrLocalProfile = FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY;

extern "C" {
extern LONG __stdcall RegRemapPreDefKey(HKEY hkeyNew, HKEY hkeyPredef);
};

#ifdef DEBUG

extern "C" {
BOOL fNoisyReg = FALSE;
};

#endif

LONG MyRegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFile)
{
#ifdef DEBUG
	if (fNoisyReg) {
		char buf[300];
		::wsprintf(buf, "MyRegLoadKey(\"%s\", \"%s\")\r\n", lpszSubKey, lpszFile);
		::OutputDebugString(buf);
	}
#endif

	/* Since the registry doesn't support long filenames, get the short
	 * alias for the path.  If that succeeds, we use that path, otherwise
	 * we just use the original one and hope it works.
	 */
	CHAR szShortPath[MAX_PATH+1];
	if (GetShortPathName(lpszFile, szShortPath, sizeof(szShortPath)))
		lpszFile = szShortPath;

	return ::RegLoadKey(hKey, lpszSubKey, lpszFile);
}


#ifdef DEBUG
LONG MyRegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey)
{
	if (fNoisyReg) {
		char buf[300];
		::wsprintf(buf, "MyRegUnLoadKey(\"%s\")\r\n", lpszSubKey);
		::OutputDebugString(buf);
	}
	return ::RegUnLoadKey(hKey, lpszSubKey);
}
#endif


LONG MyRegSaveKey(HKEY hKey, LPCSTR lpszFile, LPSECURITY_ATTRIBUTES lpsa)
{
#ifdef DEBUG
	if (fNoisyReg) {
		char buf[300];
		::wsprintf(buf, "MyRegSaveKey(\"%s\")\r\n", lpszFile);
		::OutputDebugString(buf);
	}
#endif

	/* Since the registry doesn't support long filenames, get the short
	 * alias for the path.  If that succeeds, we use that path, otherwise
	 * we just use the original one and hope it works.
	 *
	 * GetShortPathName only works if the file exists, so we have to
	 * create a dummy copy first.
	 */

	HANDLE hTemp = ::CreateFile(lpszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
								FILE_ATTRIBUTE_NORMAL, NULL);
	if (hTemp == INVALID_HANDLE_VALUE)
		return ::GetLastError();
	::CloseHandle(hTemp);

	CHAR szShortPath[MAX_PATH+1];
	if (::GetShortPathName(lpszFile, szShortPath, sizeof(szShortPath)))
		lpszFile = szShortPath;

	return ::RegSaveKey(hKey, lpszFile, lpsa);
}

#ifndef DEBUG
#define MyRegUnLoadKey	RegUnLoadKey
#endif

LONG OpenLogonKey(HKEY *phKey)
{
	return ::RegOpenKey(HKEY_LOCAL_MACHINE, szLogonKey, phKey);
}


void AddBackslash(LPSTR lpPath)
{
	LPCSTR lpBackslash = ::strrchrf(lpPath, '\\');
	if (lpBackslash == NULL || *(lpBackslash+1) != '\0')
		::strcatf(lpPath, "\\");
}


void AddBackslash(NLS_STR& nlsPath)
{
	ISTR istrBackslash(nlsPath);
	if (!nlsPath.strrchr(&istrBackslash, '\\') ||
		*nlsPath.QueryPch(++istrBackslash) != '\0')
		nlsPath += '\\';
}


void GetDirFromPath(NLS_STR& nlsTempDir, LPCSTR pszPath)
{
	nlsTempDir = pszPath;

	ISTR istrBackslash(nlsTempDir);
	if (nlsTempDir.strrchr(&istrBackslash, '\\'))
		nlsTempDir.DelSubStr(istrBackslash);
}


BOOL FileExists(LPCSTR pszPath)
{
	DWORD dwAttrs = ::GetFileAttributes(pszPath);

	if (dwAttrs != 0xffffffff && !(dwAttrs & FILE_ATTRIBUTE_DIRECTORY))
		return TRUE;
	else
		return FALSE;
}


BOOL DirExists(LPCSTR pszPath)
{
	if (*pszPath == '\0')
		return FALSE;

	DWORD dwAttrs = ::GetFileAttributes(pszPath);

	if (dwAttrs != 0xffffffff && (dwAttrs & FILE_ATTRIBUTE_DIRECTORY))
		return TRUE;
	else
		return FALSE;
}


/* CreateDirectoryPath attempts to create the specified directory;  if the
 * create attempt fails, it tries to create each element of the path in case
 * any intermediate directories also don't exist.
 */
BOOL CreateDirectoryPath(LPCSTR pszPath)
{
    BOOL fRet = ::CreateDirectory(pszPath, NULL);

    if (fRet || (::GetLastError() != ERROR_PATH_NOT_FOUND))
        return fRet;

    NLS_STR nlsTemp(pszPath);
    if (nlsTemp.QueryError() != ERROR_SUCCESS)
        return FALSE;

    LPSTR pszTemp = nlsTemp.Party();
    LPSTR pszNext = pszTemp;

    /* If it's a drive-based path (which it should be), skip the drive
     * and first backslash -- we don't need to attempt to create the
     * root directory.
     */
    if (::strchrf(pszTemp, ':') != NULL) {
        pszNext = ::strchrf(pszTemp, '\\');
        if (pszNext != NULL)
            pszNext++;
    }

    /* Now walk through the path creating one directory at a time. */

    for (;;) {
        pszNext = ::strchrf(pszNext, '\\');
        if (pszNext != NULL) {
            *pszNext = '\0';
        }
        else {
            break;          /* no more intermediate directories to create */
        }

        /* Create the intermediate directory.  No error checking because we're
         * not extremely performance-critical, and we can get errors if the
         * directory already exists, etc.  With security and other things,
         * the set of benign error codes we'd have to check for could be
         * large.
         */
        fRet = ::CreateDirectory(pszTemp, NULL);

        *pszNext = '\\';
        pszNext++;
        if (!*pszNext)      /* ended with trailing slash? */
            return fRet;    /* return last result */
    }

    /* We should have created all the intermediate directories by now.
     * Create the final path.
     */

    return ::CreateDirectory(pszPath, NULL);
}


UINT SafeCopy(LPCSTR pszSrc, LPCSTR pszDest, DWORD dwAttrs)
{
	NLS_STR nlsTempDir(MAX_PATH);
	NLS_STR nlsTempFile(MAX_PATH);
	if (!nlsTempDir || !nlsTempFile)
		return ERROR_NOT_ENOUGH_MEMORY;

	GetDirFromPath(nlsTempDir, pszDest);

	if (!::GetTempFileName(nlsTempDir.QueryPch(), ::szProfilePrefix, 0,
						   nlsTempFile.Party()))
		return ::GetLastError();

	nlsTempFile.DonePartying();

	if (!::CopyFile(pszSrc, nlsTempFile.QueryPch(), FALSE)) {
		UINT err = ::GetLastError();
		::DeleteFile(nlsTempFile.QueryPch());
		return err;
	}

	::SetFileAttributes(pszDest, FILE_ATTRIBUTE_NORMAL);

	::DeleteFile(pszDest);

	// At this point, the temp file has the same attributes as the original
	// (usually read-only, hidden, system).  Some servers, such as NetWare
	// servers, won't allow us to rename a read-only file.  So we have to
	// take the attributes off, rename the file, then put back whatever the
	// caller wants.
	::SetFileAttributes(nlsTempFile.QueryPch(), FILE_ATTRIBUTE_NORMAL);

	if (!::MoveFile(nlsTempFile.QueryPch(), pszDest))
		return ::GetLastError();

	::SetFileAttributes(pszDest, dwAttrs);

	return ERROR_SUCCESS;
}


#ifdef LOAD_PROFILES

void SetProfileTime(LPCSTR pszLocalPath, LPCSTR pszCentralPath)
{
	HANDLE hFile = ::CreateFile(pszCentralPath,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ, NULL,
								OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE) {
		FILETIME ft;

		::GetFileTime(hFile, NULL, NULL, &ft);
		::CloseHandle(hFile);

		DWORD dwAttrs = ::GetFileAttributes(pszLocalPath);
		if (dwAttrs & FILE_ATTRIBUTE_READONLY) {
			::SetFileAttributes(pszLocalPath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);
		}
		hFile = ::CreateFile(pszLocalPath, GENERIC_READ | GENERIC_WRITE,
							 FILE_SHARE_READ, NULL, OPEN_EXISTING,
							 FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE) {
			::SetFileTime(hFile, NULL, NULL, &ft);
			::CloseHandle(hFile);
		}
		if (dwAttrs & FILE_ATTRIBUTE_READONLY) {
			::SetFileAttributes(pszLocalPath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);
		}
	}
}


UINT DefaultReconcile(LPCSTR pszCentralPath, LPCSTR pszLocalPath, DWORD dwFlags)
{
	UINT err;

	if (dwFlags & RP_LOGON) {
		if (dwFlags & RP_INIFILE)
			return SafeCopy(pszCentralPath, pszLocalPath, FILE_ATTRIBUTE_NORMAL);

		HANDLE hFile = ::CreateFile(pszCentralPath, GENERIC_READ, FILE_SHARE_READ,
									NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		FILETIME ftCentral;
		if (hFile != INVALID_HANDLE_VALUE) {
			::GetFileTime(hFile, NULL, NULL, &ftCentral);
			::CloseHandle(hFile);
		}
		else {
			ftCentral.dwLowDateTime = 0;	/* can't open, pretend it's really old */
			ftCentral.dwHighDateTime = 0;
		}

		hFile = ::CreateFile(pszLocalPath, GENERIC_READ, FILE_SHARE_READ,
							 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		FILETIME ftLocal;
		if (hFile != INVALID_HANDLE_VALUE) {
			::GetFileTime(hFile, NULL, NULL, &ftLocal);
			::CloseHandle(hFile);
		}
		else {
			ftLocal.dwLowDateTime = 0;	/* can't open, pretend it's really old */
			ftLocal.dwHighDateTime = 0;
		}

		LPCSTR pszSrc, pszDest;

		/*
		 * Find out which file is newer, and make that the source
		 * for the copy.
		 */

		LONG lCompare = ::CompareFileTime(&ftCentral, &ftLocal);
		if (!lCompare) {
			::dwProfileFlags |= PROF_CENTRALWINS;
			return WN_SUCCESS;		/* timestamps match, no copy to do */
		}
		else if (lCompare > 0) {
			pszSrc = pszCentralPath;
			pszDest = pszLocalPath;
			::dwProfileFlags |= PROF_CENTRALWINS;
		}
		else {
			pszSrc = pszLocalPath;
			pszDest = pszCentralPath;
			::dwProfileFlags &= ~PROF_CENTRALWINS;
		}

		err = SafeCopy(pszSrc, pszDest,
					   pszDest == pszCentralPath ? FILE_ATTRIBUTE_NORMAL
					   : attrLocalProfile);
	}
	else {
		err = SafeCopy(pszLocalPath, pszCentralPath, FILE_ATTRIBUTE_NORMAL);
		if (err == WN_SUCCESS) {	/* copied back successfully */

#ifdef EXTENDED_PROFILES	/* chicago doesn't special-case resident profiles */
			if (dwFlags & PROF_RESIDENT) {
				DeleteProfile(pszLocalPath);	/* delete temp file */
			}
#endif

			SetProfileTime(pszLocalPath, pszCentralPath);
		}
	}

	return err;
}


#endif	/* LOAD_PROFILES */


void GetLocalProfileDirectory(NLS_STR& nlsPath)
{
	::GetWindowsDirectory(nlsPath.Party(), nlsPath.QueryAllocSize());
	nlsPath.DonePartying();

	AddBackslash(nlsPath);

	nlsPath.strcat(::szProfilesDirectory);

	::CreateDirectory(nlsPath.QueryPch(), NULL);
}


HRESULT GiveUserDefaultProfile(LPCSTR lpszPath)
{
	HKEY hkeyDefaultUser;
	LONG err = ::RegOpenKey(HKEY_USERS, ::szDefaultUserName, &hkeyDefaultUser);
	if (err == ERROR_SUCCESS) {
		err = ::MyRegSaveKey(hkeyDefaultUser, lpszPath, NULL);
		::RegCloseKey(hkeyDefaultUser);
	}
	return HRESULT_FROM_WIN32(err);
}


void ComputeLocalProfileName(LPCSTR pszUsername, NLS_STR *pnlsLocalProfile)
{
	GetLocalProfileDirectory(*pnlsLocalProfile);

	UINT cbPath = pnlsLocalProfile->strlen();
	LPSTR lpPath = pnlsLocalProfile->Party();
	LPSTR lpFilename = lpPath + cbPath;

	*(lpFilename++) = '\\';
	::strcpyf(lpFilename, pszUsername);		/* start with whole username */

	LPSTR lpFNStart = lpFilename;

	UINT iFile = 0;
	while (!::CreateDirectory(lpPath, NULL)) {
		if (!DirExists(lpPath))
			break;

		/* Couldn't use whole username, start with 5 bytes of username + numbers. */
		if (iFile == 0) {
			::strncpyf(lpFilename, pszUsername, 5);	/* copy at most 5 bytes of username */
			*(lpFilename+5) = '\0';					/* force null term, just in case */
			lpFilename += ::strlenf(lpFilename);
		}
		else if (iFile >= 4095) {	/* max number expressible in 3 hex digits */
			lpFilename = lpFNStart;	/* start using big numbers with no uname prefix */
			if ((int)iFile < 0)	/* if we run out of numbers, abort */
				break;
		}

		::wsprintf(lpFilename, "%03lx", iFile);

		iFile++;
	}

	pnlsLocalProfile->DonePartying();
}


HRESULT CopyProfile(LPCSTR pszSrcPath, LPCSTR pszDestPath)
{
	UINT err = SafeCopy(pszSrcPath, pszDestPath, attrLocalProfile);

	return HRESULT_FROM_WIN32(err);
}


BOOL UseUserProfiles(void)
{
	HKEY hkeyLogon;

	LONG err = OpenLogonKey(&hkeyLogon);
	if (err == ERROR_SUCCESS) {
		DWORD fUseProfiles = 0;
		DWORD cbData = sizeof(fUseProfiles);
		err = ::RegQueryValueEx(hkeyLogon, (LPSTR)::szUseProfiles, NULL, NULL,
								(LPBYTE)&fUseProfiles, &cbData);
		::RegCloseKey(hkeyLogon);
		return (err == ERROR_SUCCESS) && fUseProfiles;
	}

	return FALSE;
}


void EnableProfiles(void)
{
	HKEY hkeyLogon;

	LONG err = OpenLogonKey(&hkeyLogon);
	if (err == ERROR_SUCCESS) {
		DWORD fUseProfiles = 1;
		::RegSetValueEx(hkeyLogon, (LPSTR)::szUseProfiles, 0, REG_DWORD,
						(LPBYTE)&fUseProfiles, sizeof(fUseProfiles));
		::RegCloseKey(hkeyLogon);
	}
}


struct SYNCSTATE
{
    HKEY hkeyProfile;
    NLS_STR *pnlsProfilePath;
    NLS_STR *pnlsOtherProfilePath;
    HKEY hkeyPrimary;
};


/*
 * PrefixMatch determines whether a given path is equal to or a descendant
 * of a given base path.
 */
BOOL PrefixMatch(LPCSTR pszPath, LPCSTR pszBasePath)
{
	UINT cchBasePath = ::strlenf(pszBasePath);
	if (!::strnicmpf(pszPath, pszBasePath, cchBasePath)) {
		/* make sure that the base path matches the whole last component */
		if ((pszPath[cchBasePath] == '\\' || pszPath[cchBasePath] == '\0'))
			return TRUE;
		/* check to see if the base path is a root path;  if so, match */
		LPCSTR pszBackslash = ::strrchrf(pszBasePath, '\\');
		if (pszBackslash != NULL && *(pszBackslash+1) == '\0')
			return TRUE;
		else
			return FALSE;
	}
	else
		return FALSE;
}


#if 0
void ReportReconcileError(SYNCSTATE *pSyncState, TWINRESULT tr, PRECITEM pri,
						  PRECNODE prnSrc, PRECNODE prnDest, BOOL fSrcCentral)
{
	/* If we're copying the file the "wrong" way, swap our idea of the
	 * source and destination.  For the purposes of other profile code,
	 * source and destination refer to the entire profile copy direction.
	 * For this particular error message, they refer to the direction
	 * that this particular file was being copied.
	 */
	if (prnSrc->rnaction == RNA_COPY_TO_ME) {
		PRECNODE prnTemp = prnSrc;
		prnSrc = prnDest;
		prnDest = prnTemp;
		fSrcCentral = !fSrcCentral;
	}

	/* Set the error status on this key to be the destination of the copy,
	 * which is the copy that's now out of date because of the error and
	 * needs to be guarded from harm next time.
	 */
	pSyncState->uiRecError |= fSrcCentral ? RECERROR_LOCAL : RECERROR_CENTRAL;

	pSyncState->dwFlags |= SYNCSTATE_ERROR;

	if (pSyncState->dwFlags & SYNCSTATE_ERRORMSG)
		return;			/* error already reported */

	pSyncState->dwFlags |= SYNCSTATE_ERRORMSG;

	RegEntry re(::szReconcileRoot, pSyncState->hkeyProfile);
	if (re.GetError() == ERROR_SUCCESS && !re.GetNumber(::szDisplayProfileErrors, TRUE))
		return;		/* user doesn't want to see this error message */

	PCSTR pszFile;
	UINT uiMainMsg;

	switch (tr) {
	case TR_DEST_OPEN_FAILED:
	case TR_DEST_WRITE_FAILED:
		uiMainMsg = IERR_ProfRecWriteDest;
		pszFile = prnDest->pcszFolder;
		break;
	case TR_SRC_OPEN_FAILED:
	case TR_SRC_READ_FAILED:
		uiMainMsg = IERR_ProfRecOpenSrc;
		pszFile = prnSrc->pcszFolder;
		break;
	default:
		uiMainMsg = IERR_ProfRecCopy;
		pszFile = pri->pcszName;
		break;
	}

	if (DisplayGenericError(NULL, uiMainMsg, tr, pszFile, ::szNULL,
							MB_YESNO | MB_ICONEXCLAMATION, IDS_TRMsgBase) == IDNO) {
		re.SetValue(::szDisplayProfileErrors, (ULONG)FALSE);
	}
}


#ifdef DEBUG
char szOutbuf[200];
#endif


/*
 * MyReconcile is a wrapper around ReconcileItem.  It needs to detect merge
 * type operations and transform them into copies in the appropriate direction,
 * and recognize when the sync engine wants to replace a file that the user
 * really wants deleted.
 */
void MyReconcile(PRECITEM pri, SYNCSTATE *pSyncState)
{
	if (pri->riaction == RIA_NOTHING)
		return;

	/* Because we don't have a persistent briefcase, we can't recognize when
	 * the user has deleted an item;  the briefcase will want to replace it
	 * with the other version, which is not what the user wants.  So we use
	 * the direction of the profile's copy, and if the sync engine wants to
	 * copy a file from the "destination" of the profile's copy to the "source"
	 * because the "source" doesn't exist, we recognize that as the source
	 * having been deleted and synchronize manually by deleting the dest.
	 *
	 * prnSrc points to the recnode for the item that's coming from the same
	 * side of the transaction that the more recent profile was on;  prnDest
	 * points to the recnode for the other side.
	 *
	 * The test is complicated because we first have to figure out which of
	 * the two directories (nlsDir1, the local dir; or nlsDir2, the central
	 * dir) is the source and which the destination.  Then we have to figure
	 * out which of the two RECNODEs we got matches which directory.
	 */
	PRECNODE prnSrc;
	PRECNODE prnDest;
	LPCSTR pszSrcBasePath;
	BOOL fSrcCentral;
	if (pSyncState->IsMandatory() || (pSyncState->dwFlags & PROF_CENTRALWINS)) {
		pszSrcBasePath = pSyncState->nlsDir2.QueryPch();
		fSrcCentral = TRUE;
	}
	else {
		pszSrcBasePath = pSyncState->nlsDir1.QueryPch();
		fSrcCentral = FALSE;
	}

	if (PrefixMatch(pri->prnFirst->pcszFolder, pszSrcBasePath)) {
		prnSrc = pri->prnFirst;
		prnDest = prnSrc->prnNext;
	}
	else {
		prnDest = pri->prnFirst;
		prnSrc = prnDest->prnNext;
	}

	/*
	 * If files of the same name exist in both places, the sync engine thinks
     * they need to be merged (since we have no persistent briefcase database,
     * it doesn't know that they were originally the same).  The sync engine
     * sets the file stamp of a copied destination file to the file stamp of
     * the source file after copying.  If the file stamps of two files to be
     * merged are the same, we assume that the files are already up-to-date,
     * and we take no reconciliation action.  If the file stamps of two files
     * to be merged are different, we really just want a copy, so we figure out
     * which one is supposed to be definitive and transform the RECITEM and
     * RECNODEs to indicate a copy instead of a merge.
	 *
	 * The definitive copy is the source for mandatory or logoff cases,
	 * otherwise it's the newer file.
	 */
	if (pri->riaction == RIA_MERGE || pri->riaction == RIA_BROKEN_MERGE) {
		BOOL fCopyFromSrc;
        COMPARISONRESULT cr;

		if (pSyncState->IsMandatory())
			fCopyFromSrc = TRUE;
        else {
	        fCopyFromSrc = ! pSyncState->IsLogon();  

            if (pSyncState->CompareFileStamps(&prnSrc->fsCurrent, &prnDest->fsCurrent, &cr) == TR_SUCCESS) {
                if (cr == CR_EQUAL) {
#ifdef MAXDEBUG
			       ::OutputDebugString("Matching file stamps, no action taken\r\n");  
#endif
                   return;
                }
                else if (cr==CR_FIRST_LARGER)       
			       fCopyFromSrc = TRUE;
            }
        }

#ifdef MAXDEBUG
		if (fCopyFromSrc)
			::OutputDebugString("Broken merge, copying from src\r\n");
		else
			::OutputDebugString("Broken merge, copying from dest\r\n");
#endif

		prnSrc->rnaction = fCopyFromSrc ? RNA_COPY_FROM_ME : RNA_COPY_TO_ME;
		prnDest->rnaction = fCopyFromSrc ? RNA_COPY_TO_ME : RNA_COPY_FROM_ME;
		pri->riaction = RIA_COPY;
	}

	/*
	 * If the preferred source file doesn't exist, the sync engine is trying
	 * to create a file to make the two trees the same, when the user/admin
	 * really wanted to delete it (the sync engine doesn't like deleting
	 * files).  So we detect that case here and delete the "destination"
	 * to make the two trees match that way.
	 *
	 * If the last reconciliation had an error, we don't do the deletion
	 * if the site of the error is the current source (i.e., if we're
	 * about to delete the file we couldn't copy before).  Instead we'll
	 * try the operation that the sync engine wants, since that'll be the
	 * copy that failed before.
	 */
	if (prnSrc->rnstate == RNS_DOES_NOT_EXIST &&
		prnSrc->rnaction == RNA_COPY_TO_ME &&
		!((pSyncState->uiRecError & RECERROR_CENTRAL) && fSrcCentral) &&
		!((pSyncState->uiRecError & RECERROR_LOCAL) && !fSrcCentral)) {
		if (IS_EMPTY_STRING(pri->pcszName)) {
			::RemoveDirectory(prnDest->pcszFolder);
		}
		else {
			NLS_STR nlsTemp(prnDest->pcszFolder);
			AddBackslash(nlsTemp);
			nlsTemp.strcat(pri->pcszName);
			if (!nlsTemp.QueryError()) {
#ifdef MAXDEBUG
				if (pSyncState->IsMandatory())
					::OutputDebugString("Mandatory copy wrong way\r\n");

				wsprintf(::szOutbuf, "Deleting 'destination' file %s\r\n", nlsTemp.QueryPch());
				::OutputDebugString(::szOutbuf);
#endif
				::DeleteFile(nlsTemp.QueryPch());
			}
		}
		return;
	}

#ifdef MAXDEBUG
	::OutputDebugString("Calling ReconcileItem.\r\n");
#endif

	TWINRESULT tr;
	if ((tr=pSyncState->ReconcileItem(pri, NULL, 0, 0, NULL, NULL)) != TR_SUCCESS) {
		ReportReconcileError(pSyncState, tr, pri, prnSrc, prnDest, fSrcCentral);
#ifdef MAXDEBUG
		::wsprintf(::szOutbuf, "Error %d from ReconcileItem.\r\n", tr);
		::OutputDebugString(::szOutbuf);
#endif
	}
	else if (!IS_EMPTY_STRING(pri->pcszName))
		pSyncState->dwFlags |= SYNCSTATE_SOMESUCCESS;
}


/*
 * MakePathAbsolute examines a path to see whether it is absolute or relative.
 * If it is relative, it is prepended with the given base path.
 *
 * If the fMustBeRelative parameter is TRUE, then an error is returned if the
 * path was (a) absolute and (b) not a subdirectory of the old profile directory.
 */
BOOL MakePathAbsolute(NLS_STR& nlsDir, LPCSTR lpszBasePath,
					  NLS_STR& nlsOldProfileDir, BOOL fMustBeRelative)
{
	/* If the path starts with a special keyword, replace it. */

	if (*nlsDir.QueryPch() == '*') {
		return ReplaceCommonPath(nlsDir);
	}

	/* If the path is absolute and is relative to whatever the old profile
	 * directory was, transform it to a relative path.  We will then make
	 * it absolute again, using the new base path.
	 */
	if (PrefixMatch(nlsDir, nlsOldProfileDir)) {
		UINT cchDir = nlsDir.strlen();
		LPSTR lpStart = nlsDir.Party();
		::memmovef(lpStart, lpStart + nlsOldProfileDir.strlen(), cchDir - nlsOldProfileDir.strlen() + 1);
		nlsDir.DonePartying();
	}
	else if (::strchrf(nlsDir.QueryPch(), ':') != NULL || *nlsDir.QueryPch() == '\\')
		return !fMustBeRelative;

	if (*lpszBasePath == '\0') {
		nlsDir = lpszBasePath;
		return TRUE;
	}

	NLS_STR nlsBasePath(lpszBasePath);
	if (nlsBasePath.QueryError())
		return FALSE;
	AddBackslash(nlsBasePath);

	ISTR istrStart(nlsDir);
	nlsDir.InsertStr(nlsBasePath, istrStart);
	return !nlsDir.QueryError();
}
#endif  /**** 0 ****/


/*
 * ReplaceCommonPath takes a relative path beginning with a special keyword
 * and replaces the keyword with the corresponding real path.  Currently the
 * keyword supported is:
 *
 * *windir - replaced with the Windows (user) directory
 */
BOOL ReplaceCommonPath(NLS_STR& nlsDir)
{
	NLS_STR *pnlsTemp;
	ISTR istrStart(nlsDir);
	ISTR istrEnd(nlsDir);

	nlsDir.strchr(&istrEnd, '\\');
	pnlsTemp = nlsDir.QuerySubStr(istrStart, istrEnd);
	if (pnlsTemp == NULL)
		return FALSE;				/* out of memory, can't do anything */

	BOOL fSuccess = TRUE;
	if (!::stricmpf(pnlsTemp->QueryPch(), ::szWindirAlias)) {
		UINT cbBuffer = pnlsTemp->QueryAllocSize();
		LPSTR lpBuffer = pnlsTemp->Party();
		UINT cchWindir = ::GetWindowsDirectory(lpBuffer, cbBuffer);
		if (cchWindir >= cbBuffer)
			*lpBuffer = '\0';
		pnlsTemp->DonePartying();
		if (cchWindir >= cbBuffer) {
			pnlsTemp->realloc(cchWindir+1);
			if (!pnlsTemp->QueryError()) {
				::GetWindowsDirectory(pnlsTemp->Party(), cchWindir+1);
				pnlsTemp->DonePartying();
			}
			else
				fSuccess = FALSE;
		}
		if (fSuccess) {
			nlsDir.ReplSubStr(*pnlsTemp, istrStart, istrEnd);
			fSuccess = !nlsDir.QueryError();
		}
	}
	delete pnlsTemp;
	return fSuccess;
}


/*
 * GetSetRegistryPath goes to the registry key and value specified by
 * the current reconciliations's RegKey and RegValue settings, and
 * retrieves or sets a path there.
 */
void GetSetRegistryPath(HKEY hkeyProfile, RegEntry& re, NLS_STR *pnlsPath, BOOL fSet)
{
	NLS_STR nlsKey;

	re.GetValue(::szReconcileRegKey, &nlsKey);
	if (nlsKey.strlen() > 0) {
		NLS_STR nlsValue;
		re.GetValue(::szReconcileRegValue, &nlsValue);
		RegEntry re2(nlsKey, hkeyProfile);
		if (fSet) {
			re2.SetValue(nlsValue, pnlsPath->QueryPch());
            if (!nlsKey.stricmp("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")) {
                nlsKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
                RegEntry reShell(nlsKey, hkeyProfile);
                reShell.SetValue(nlsValue, pnlsPath->QueryPch());
            }
        }
		else
			re2.GetValue(nlsValue, pnlsPath);
	}
}


/* CopyFolder calls the shell's copy engine to copy files.  The source is a
 * double-null-terminated list;  the destination is a folder.
 */
void CopyFolder(LPBYTE pbSource, LPCSTR pszDest)
{
    CHAR szDest[MAX_PATH];

    ::strcpyf(szDest, pszDest);
    szDest[::strlenf(szDest) + 1] = '\0';

    SHFILEOPSTRUCT fos;

    fos.hwnd = NULL;
    fos.wFunc = FO_COPY;
    fos.pFrom = (LPCSTR)pbSource;
    fos.pTo = szDest;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOERRORUI;
    fos.fAnyOperationsAborted = FALSE;
    fos.hNameMappings = NULL;
    fos.lpszProgressTitle = NULL;

    g_pfnSHFileOperationA(&fos);
}


/*
 * ReconcileKey performs reconciliation for a particular key in the
 * ProfileReconciliation branch of the registry.  It reads the config
 * parameters for the reconciliation, sets up an appropriate twin in
 * the temporary briefcase, and performs the reconciliation.
 */
BOOL ReconcileKey(HKEY hkeySection, LPCSTR lpszSubKey, SYNCSTATE *pSyncState)
{
#ifdef DEBUG
	DWORD dwStart = ::GetTickCount();
#endif

	BOOL fShouldDelete = FALSE;

	RegEntry re(lpszSubKey, hkeySection);
	if (re.GetError() == ERROR_SUCCESS) {
        BUFFER bufSrcStrings(MAX_PATH);
        NLS_STR nlsSrcPath(MAX_PATH);
        NLS_STR nlsDestPath(MAX_PATH);
        NLS_STR nlsName(MAX_PATH);
        if (bufSrcStrings.QueryPtr() != NULL &&
            nlsSrcPath.QueryError() == ERROR_SUCCESS &&
            nlsDestPath.QueryError() == ERROR_SUCCESS &&
            nlsName.QueryError() == ERROR_SUCCESS) {

            /* Get the source path to copy.  Usually it's in the profile,
             * left over from the profile we cloned.  If not, we take the
             * default local name from the ProfileReconciliation key.  If
             * the path already in the registry is not relative to the cloned
             * profile directory, then it's probably set by system policies
             * or something, and we shouldn't touch it.
             */
            if (pSyncState->pnlsOtherProfilePath != NULL) {
        		GetSetRegistryPath(pSyncState->hkeyProfile, re, &nlsSrcPath, FALSE);
                if (nlsSrcPath.strlen() && 
                    !PrefixMatch(nlsSrcPath.QueryPch(), pSyncState->pnlsOtherProfilePath->QueryPch())) {
                    return FALSE;   /* not profile-relative, nothing to do */
                }
            }
            if (!nlsSrcPath.strlen()) {
				re.GetValue(::szDefaultDir, &nlsSrcPath);
            	if (*nlsSrcPath.QueryPch() == '*') {
            		ReplaceCommonPath(nlsSrcPath);
            	}
            }

            /* Get the set of files to copy.  Like NT and unlike win95, we
             * want to clone the entire contents, not necessarily just the
             * files listed (for example, the desktop -- we want all the
             * files and subfolders, not just links).  So, unless the string
             * is empty, which means don't copy any content, just set the reg
             * path, we change any pattern containing wildcards to *.*.
             */
            re.GetValue(::szReconcileName, &nlsName);
            if (nlsName.strlen()) {
                if (::strchrf(nlsName.QueryPch(), '*') != NULL ||
                    ::strchrf(nlsName.QueryPch(), '?') != NULL) {
                    nlsName = "*.*";
                }
            }

            /* Get the destination path.  This is generated from the new
             * profile directory and the LocalFile entry in the registry.
             *
             * Should always do this, even if we're not going to call the
             * copy engine, because we're going to write this path out to
             * the registry.
             */
            re.GetValue(::szLocalFile, &nlsDestPath);
            ISTR istr(nlsDestPath);
            nlsDestPath.InsertStr(*(pSyncState->pnlsProfilePath), istr);

            /* Always create the destination path, even if we don't copy
             * any files into it because the source directory doesn't exist.
             */
            CreateDirectoryPath(nlsDestPath.QueryPch());

            /* Make sure the source directory exists so we won't get useless
             * error messages from the shell copy engine.
             */
            DWORD dwAttr = GetFileAttributes(nlsSrcPath.QueryPch());
            if (dwAttr != 0xffffffff && (dwAttr & FILE_ATTRIBUTE_DIRECTORY) &&
                nlsName.strlen()) {

                AddBackslash(nlsSrcPath);

                /* Build up the double-null-terminated list of file specs to copy. */

                UINT cbUsed = 0;

		    	LPSTR lpName = nlsName.Party();
			    do {
				    LPSTR lpNext = ::strchrf(lpName, ',');
    				if (lpNext != NULL) {
	    				*(lpNext++) = '\0';
		    		}

                    UINT cbNeeded = nlsSrcPath.strlen() + ::strlenf(lpName) + 1;
                    if (bufSrcStrings.QuerySize() - cbUsed < cbNeeded) {
                        if (!bufSrcStrings.Resize(bufSrcStrings.QuerySize() + MAX_PATH))
                            return FALSE;
                    }
                    LPSTR lpDest = ((LPSTR)bufSrcStrings.QueryPtr()) + cbUsed;
                    ::strcpyf(lpDest, nlsSrcPath.QueryPch());
                    lpDest += nlsSrcPath.strlen();
                    ::strcpyf(lpDest, lpName);
                    cbUsed += cbNeeded;

    				lpName = lpNext;
	    		} while (lpName != NULL);

                *((LPSTR)bufSrcStrings.QueryPtr() + cbUsed) = '\0';    /* double null terminate */
	    		nlsName.DonePartying();

                CopyFolder((LPBYTE)bufSrcStrings.QueryPtr(), nlsDestPath.QueryPch());
            }

    		/*
		     * Set a registry key to point to the new local path to this directory.
	    	 */
    		GetSetRegistryPath(pSyncState->hkeyProfile, re, &nlsDestPath, TRUE);
		}
    }

#ifdef MAXDEBUG
	::wsprintf(::szOutbuf, "ReconcileKey duration %d ms.\r\n", ::GetTickCount() - dwStart);
	::OutputDebugString(::szOutbuf);
#endif

	return fShouldDelete;
}


/*
 * GetMaxSubkeyLength just calls RegQueryInfoKey to get the length of the
 * longest named subkey of the given key.  The return value is the size
 * of buffer needed to hold the longest key name, including the null
 * terminator.
 */
DWORD GetMaxSubkeyLength(HKEY hKey)
{
	DWORD cchClass = 0;
	DWORD cSubKeys;
	DWORD cchMaxSubkey;
	DWORD cchMaxClass;
	DWORD cValues;
	DWORD cchMaxValueName;
	DWORD cbMaxValueData;
	DWORD cbSecurityDescriptor;
	FILETIME ftLastWriteTime;

	RegQueryInfoKey(hKey, NULL, &cchClass, NULL, &cSubKeys, &cchMaxSubkey,
					&cchMaxClass, &cValues, &cchMaxValueName, &cbMaxValueData,
					&cbSecurityDescriptor, &ftLastWriteTime);
	return cchMaxSubkey + 1;
}


/*
 * ReconcileSection walks through the ProfileReconciliation key and performs
 * reconciliation for each subkey.  One-time keys are deleted after they are
 * processed.
 */
void ReconcileSection(HKEY hkeyRoot, SYNCSTATE *pSyncState)
{
	NLS_STR nlsKeyName(GetMaxSubkeyLength(hkeyRoot));
	if (!nlsKeyName.QueryError()) {
		DWORD iKey = 0;

		for (;;) {
			DWORD cchKey = nlsKeyName.QueryAllocSize();

			UINT err = ::RegEnumKey(hkeyRoot, iKey, nlsKeyName.Party(), cchKey);
			if (err != ERROR_SUCCESS)
				break;

			nlsKeyName.DonePartying();
			if (ReconcileKey(hkeyRoot, nlsKeyName, pSyncState)) {
				::RegDeleteKey(hkeyRoot, nlsKeyName.QueryPch());
			}
			else
				iKey++;
		}
	}
}


/*
 * ReconcileFiles is called just after the user's profile and policies are
 * loaded at logon, and just before the profile is unloaded at logoff.  It
 * performs all file type reconciliation for the user's profile, excluding
 * the profile itself, of course.
 *
 * nlsOtherProfilePath is the path to the profile which is being cloned,
 * or an empty string if the default profile is being cloned.
 */
HRESULT ReconcileFiles(HKEY hkeyProfile, NLS_STR& nlsProfilePath,
                    NLS_STR& nlsOtherProfilePath)
{
    HRESULT hres = LoadShellEntrypoint();
    if (FAILED(hres))
        return hres;

    if (nlsOtherProfilePath.strlen())
    {
    	ISTR istrBackslash(nlsOtherProfilePath);
	    if (nlsOtherProfilePath.strrchr(&istrBackslash, '\\')) {
            ++istrBackslash;
		    nlsOtherProfilePath.DelSubStr(istrBackslash);
        }
    }

	RegEntry re(::szReconcileRoot, hkeyProfile);
	if (re.GetError() == ERROR_SUCCESS) {
        SYNCSTATE s;
        s.hkeyProfile = hkeyProfile;
        s.pnlsProfilePath = &nlsProfilePath;
        s.pnlsOtherProfilePath = (nlsOtherProfilePath.strlen() != 0) ? &nlsOtherProfilePath : NULL;
        s.hkeyPrimary = NULL;

		RegEntry rePrimary(::szReconcilePrimary, re.GetKey());
		RegEntry reSecondary(::szReconcileSecondary, re.GetKey());
		if (rePrimary.GetError() == ERROR_SUCCESS) {
			ReconcileSection(rePrimary.GetKey(), &s);

			if (reSecondary.GetError() == ERROR_SUCCESS) {
                s.hkeyPrimary = rePrimary.GetKey();
				ReconcileSection(reSecondary.GetKey(), &s);
			}
		}
	}

	return ERROR_SUCCESS;
}


HRESULT DefaultReconcileKey(HKEY hkeyProfile, NLS_STR& nlsProfilePath,
                            LPCSTR pszKeyName, BOOL fSecondary)
{
    HRESULT hres = LoadShellEntrypoint();
    if (FAILED(hres))
        return hres;

	RegEntry re(::szReconcileRoot, hkeyProfile);
	if (re.GetError() == ERROR_SUCCESS) {
        SYNCSTATE s;
        s.hkeyProfile = hkeyProfile;
        s.pnlsProfilePath = &nlsProfilePath;
        s.pnlsOtherProfilePath = NULL;
        s.hkeyPrimary = NULL;

		RegEntry rePrimary(::szReconcilePrimary, re.GetKey());
		if (rePrimary.GetError() == ERROR_SUCCESS) {
            if (fSecondary) {
        		RegEntry reSecondary(::szReconcileSecondary, re.GetKey());
                s.hkeyPrimary = rePrimary.GetKey();
    			ReconcileKey(reSecondary.GetKey(), pszKeyName, &s);
            }
            else
    			ReconcileKey(rePrimary.GetKey(), pszKeyName, &s);
		}
	}

	return ERROR_SUCCESS;
}


HRESULT DeleteProfileFiles(LPCSTR pszPath)
{
    HRESULT hres = LoadShellEntrypoint();
    if (FAILED(hres))
        return hres;

    SHFILEOPSTRUCT fos;
    TCHAR szFrom[MAX_PATH];

    lstrcpy(szFrom, pszPath);

    /* Before we build the complete source filespec, check to see if the
     * directory exists.  In the case of lesser-used folders such as
     * "Application Data", the default may not have ever been created.
     * In that case, we have no contents to copy.
     */
    DWORD dwAttr = GetFileAttributes(szFrom);
    if (dwAttr == 0xffffffff || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
        return S_OK;

    AddBackslash(szFrom);
    lstrcat(szFrom, TEXT("*.*"));
    szFrom[lstrlen(szFrom)+1] = '\0';   /* double null terminate from string */

    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.pFrom = szFrom;
    fos.pTo = NULL;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOERRORUI;
    fos.fAnyOperationsAborted = FALSE;
    fos.hNameMappings = NULL;
    fos.lpszProgressTitle = NULL;

    g_pfnSHFileOperationA(&fos);

    ::RemoveDirectory(pszPath);

	return NOERROR;
}


HRESULT DeleteProfile(LPCSTR pszName)
{
	RegEntry re(::szProfileList, HKEY_LOCAL_MACHINE);

	HRESULT hres;

	if (re.GetError() == ERROR_SUCCESS) {
		{	/* extra scope for next RegEntry */
			RegEntry reUser(pszName, re.GetKey());
			if (reUser.GetError() == ERROR_SUCCESS) {
				NLS_STR nlsPath(MAX_PATH);
				if (nlsPath.QueryError() == ERROR_SUCCESS) {
					reUser.GetValue(::szProfileImagePath, &nlsPath);
					if (reUser.GetError() == ERROR_SUCCESS) {
						hres = DeleteProfileFiles(nlsPath.QueryPch());
					}
					else
						hres = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);

				}
				else
					hres = HRESULT_FROM_WIN32(nlsPath.QueryError());
			}
			else
				hres = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
		}
		if (SUCCEEDED(hres)) {
		    ::RegDeleteKey(re.GetKey(), pszName);
            NLS_STR nlsOEMName(pszName);
			if (nlsOEMName.QueryError() == ERROR_SUCCESS) {
			    nlsOEMName.strupr();
			    nlsOEMName.ToOEM();
    			::DeletePasswordCache(nlsOEMName.QueryPch());
            }
		}
	}
	else
		hres = E_UNEXPECTED;

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\settings.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include <ole2.h>

CUserSettings::CUserSettings(void)
	: m_cRef(1),
	  m_clsid(GUID_NULL),
	  m_nlsName(NULL),
	  m_hkey(NULL)
{
	// nothing else
}


CUserSettings::~CUserSettings(void)
{
	if (m_hkey != NULL) {
		::RegCloseKey(m_hkey);
#ifdef DEBUG
		m_hkey = NULL;
#endif
	}
}


STDMETHODIMP CUserSettings::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IUserSettings)) {
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CUserSettings::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CUserSettings::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}

	return cRef;
}


STDMETHODIMP CUserSettings::GetCLSID(CLSID *pclsidOut)
{
	return E_NOTIMPL;
}


STDMETHODIMP CUserSettings::GetName(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	if (m_nlsName.QueryError())
		return ResultFromScode(E_OUTOFMEMORY);

	UINT err = NPSCopyNLS(&m_nlsName, pbBuffer, pcbBuffer);

	return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CUserSettings::GetDisplayName(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	return E_NOTIMPL;
}


STDMETHODIMP CUserSettings::QueryKey(HKEY *phkeyOut)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by logonui.rc
//
#define IDS_LOGONTITLE                  10
#define IDS_BADPASSWORD                 11
#define IDS_YOURNEWPASSWORD             12
#define IDS_RATINGS_PW_COMMENT          13
#define IDS_PROFILES_ALREADY_ENABLED    14
#define IDS_ENTER_FIRST_USERNAME        15
#define IDS_BLANK_USERNAME              16
#define IDS_NO_MATCH                    17
#define IDS_GO_MULTI_RESTART            18
#define IDS_CLONE_USER_MESSAGE          19
#define IDS_GUEST_USERNAME              20
#define IDS_PICK_USERNAME               21
#define IDS_USER_EXISTS                 22
#define IDS_SELECTED_USER               23
#define IDS_SETTINGS_FOR                24
#define IDS_CONFIRM_DELETE_USER         25
#define IDS_PASSWORD_CHANGED            26
#define IDS_NP_NAME                     27
#define IDS_CACHE_PASSWORD              28
#define IDS_NETFAM_HELP_TEXT            29
#define IDS_PROFILE_POLICY              30

#define IDC_STATIC                      -1
#define IDC_STATIC1                     100
#define IDD_Users                       101
#define IDB_BITMAP1                     101
#define IDC_STATIC2                     101
#define IDD_AddUserIntro                102
#define IDC_STATIC3                     102
#define IDD_PickUser                    103
#define IDD_EnterUsername               104
#define IDD_NewUserPassword             105
#define IDD_LOGON                       106
#define IDD_EnableProfilesIntro         107
#define IDD_EnterCAPassword             108
#define IDD_FinishGoMulti               109
#define IDD_FinishAddUser               110
#define IDD_EnterUserPassword           111
#define IDD_CHANGE_PASSWORD             112
#define IDD_PASSWORD                    113
#define IDD_ChooseFolders               114
#define IDD_ChooseFoldersWiz            115
#define IDD_CreateProgress              116
#define IDD_DeleteProgress              117
#define IDC_MAIN_CAPTION                120
#define IDC_MAIN_CAPTION2               122
#define IDC_PASSWORD_LABEL              124
#define IDC_PASSWORD                    125
#define IDC_CONFIRM_PASSWORD            126
#define IDC_OLD_PASSWORD                132
#define IDC_CHECK_DESKTOP               80
#define IDC_CHECK_STARTMENU             81
#define IDC_CHECK_FAVORITES             82
#define IDC_CHECK_CACHE                 83
#define IDC_CHECK_MYDOCS                84
#define IDC_RADIO_COPY                  85
#define IDC_RADIO_EMPTY                 86
#define IDC_USERNAME                    152
#define IDC_LIST1                       1000
#define IDC_Add                         1002
#define IDC_Delete                      1003
#define IDC_SetPassword                 1004
#define IDC_OpenProfileFolder           1005
#define IDC_Clone                       1006
#define IDC_RATINGS_PW_COMMENT          1007
#define IDC_CACHE_PASSWORD              1008

/* Note: Code knows that IDB_IMAGE_XXXX_LOGON + 1 == IDB_STATIC_XXXX_LOGON */
#define IDB_IMAGE_LOGON                 106
#define IDB_STATIC_LOGON                107

#define IDB_IMAGE_WIN98_LOGON           108
#define IDB_STATIC_WIN98_LOGON          109

#define IDS_UNKNOWN_ERROR               2000

#define IDS_ERROR_NOT_AUTHENTICATED     2001
#define IDS_ERROR_NO_SUCH_USER          2002
#define IDS_ERROR_USER_EXISTS           2003
#define IDS_ERROR_OUT_OF_MEMORY         2004
#define IDS_ERROR_BUSY                  2005
#define IDS_ERROR_PATH_NOT_FOUND        2006
#define IDS_ERROR_BUFFER_OVERFLOW       2007

#define IDS_IERR_CachingDisabled	    2010
#define IDS_IERR_BadSig			        2011
#define IDS_IERR_CacheReadOnly		    2012
#define IDS_IERR_IncorrectUsername	    2013
#define IDS_IERR_CacheCorrupt		    2014
#define IDS_IERR_UsernameNotFound	    2015
#define IDS_IERR_CacheFull			    2016
#define IDS_IERR_CacheAlreadyOpen	    2017

#define IDS_E_ACCESSDENIED              2030

#define IDS_CSIDL_PERSONAL_L            2040
#define IDS_CSIDL_FAVORITES_L           2041
#define IDS_CSIDL_APPDATA_L             2042
#define IDS_CSIDL_CACHE_L               2043
#define IDS_CSIDL_DESKTOP_L             2046
#define IDS_CSIDL_RECENT_L              2047
#define IDS_CSIDL_NETHOOD_L             2048
#define IDS_CSIDL_STARTMENU_L           2049
#define IDS_CSIDL_PROGRAMS_L            2050
#define IDS_CSIDL_STARTUP_L             2051

#define IDS_CSIDL_CHANNELS_L            2052

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\profiles.h ===
void AddBackslash(LPSTR lpPath);
void AddBackslash(NLS_STR& nlsPath);
BOOL FileExists(LPCSTR pszPath);
BOOL DirExists(LPCSTR pszPath);
UINT SafeCopy(LPCSTR pszSrc, LPCSTR pszDest, DWORD dwAttrs);
HRESULT GiveUserDefaultProfile(LPCSTR pszPath);
HRESULT CopyProfile(LPCSTR pszSrcPath, LPCSTR pszDestPath);
LONG MyRegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFile);
HRESULT ReconcileFiles(HKEY hkeyProfile, NLS_STR& nlsProfilePath, NLS_STR& nlsOtherProfilePath);
HRESULT DefaultReconcileKey(HKEY hkeyProfile, NLS_STR& nlsProfilePath,
                            LPCSTR pszKeyName, BOOL fSecondary);
void ComputeLocalProfileName(LPCSTR pszUsername, NLS_STR *pnlsLocalProfile);
HRESULT DeleteProfile(LPCSTR pszName);
BOOL UseUserProfiles(void);
void EnableProfiles(void);
LONG OpenLogonKey(HKEY *phkey);
BOOL CreateDirectoryPath(LPCSTR pszPath);

#ifdef REGENTRY_INC
void GetSetRegistryPath(HKEY hkeyProfile, RegEntry& re, NLS_STR *pnlsPath, BOOL fSet);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "windows.h"       // Don't use precompiled header here
#include "commctrl.h"       // Don't use precompiled header here
#include "prsht.h"
#include "shlwapi.h"

PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst)
{
    PROPSHEETPAGE* ppsPage = LocalAlloc(LPTR, sizeof(PROPSHEETPAGE));
    if (ppsPage)
    {
        ppsPage->dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        ppsPage->hInstance = hinst;
        ppsPage->dwFlags = PSP_DEFAULT;
    }

    return ppsPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

INCLUDES        = $(INCLUDES);$(INETCORE_INC_PATH);$(DS_INC_PATH);


# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\inetcplp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\pwlapi.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	pcache.h
	Definitions for password cache code

	FILE HISTORY:
		gregj	06/25/92	Created
		gregj	07/13/92	Finishing up lots more stuff, incl. classes
		gregj	04/23/93	Ported to Chicago environment
		gregj	09/16/93	Added memory-only entry support for Chicago
		gregj	11/30/95	Support for new file format
		gregj	08/13/96	Removed everything but MSPWL32 API definitions
*/

#ifndef _PWLAPI_H_
#define _PWLAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned char UCHAR;
typedef UINT APIERR;

#include <pcerr.h>

#ifndef _SIZE_T_DEFINED
# include <stddef.h>
#endif

#ifndef PCE_STRUCT_DEFINED

#define PCE_STRUCT_DEFINED		/* for benefit of pcache.h */

struct PASSWORD_CACHE_ENTRY {
	USHORT cbEntry;				/* size of this entry in bytes, incl. pad */
								/* high bit marks end of bucket */
	USHORT cbResource;			/* size of resource name in bytes */
	USHORT cbPassword;			/* size of password in bytes */
	UCHAR iEntry;				/* index number of this entry, for MRU */
	UCHAR nType;				/* type of entry (see below) */
	CHAR abResource[1];			/* resource name (may not be ASCIIZ at all) */
//	CHAR abPassword[cbPassword]; /* password (also may not be ASCIIZ) */
//	CHAR abPad[];				/* WORD padding */
};

typedef BOOL (*CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY *pce, DWORD dwRefData );

#endif	/* PCE_STRUCT_DEFINED */


/*
    the following nType values are only for the purposes of enumerating
    entries from the cache.  note that PCE_ALL is reserved and should not
    be the nType value for any entry.
*/

// NOTE BENE!  All of the following MUST be synchronized with
//             \\flipper\wb\src\common\h\pcache.hxx!

#define PCE_DOMAIN		0x01	/* entry is for a domain */
#define PCE_SERVER		0x02	/* entry is for a server */
#define PCE_UNC			0x03	/* entry is for a server/share combo */
#define PCE_MAIL		0x04	/* entry is a mail password */
#define PCE_SECURITY	0x05	/* entry is a security entry */
#define PCE_MISC		0x06	/* entry is for some other resource */
#define PCE_NDDE_WFW	0x10	/* entry is WFW DDE password */
#define PCE_NDDE_NT		0x11	/* entry is NT DDE password */
#define PCE_NW_SERVER	0x12	/* entry is Netware server*/
#define PCE_PCONN		0x81	/* persistent connection */
#define PCE_DISKSHARE	0x82	/* persistent disk share */
#define PCE_PRINTSHARE	0x83	/* persistent print share */
#define PCE_DOSPRINTSHARE	0x84	/* persistent DOS print share */
#define	PCE_NW_PSERVER	0x85	/* for NetWare Print Server login (MSPSRV.EXE) */

#define PCE_NOTMRU	0x80		/* bit set if entry is exempt from MRU aging */
#define PCE_ALL		0xff		/* retrieve all entries */

#define MAX_ENTRY_SIZE	250	/* so total file size < 64K */

struct CACHE_ENTRY_INFO {
	USHORT cbResource;		/* size of resource name in bytes */
	USHORT cbPassword;		/* size of password in bytes */
	UCHAR iEntry;			/* index number of entry */
	UCHAR nType;			/* type of entry (see below) */
	USHORT dchResource;		/* offset in buffer to resource name */
	USHORT dchPassword;		/* offset in buffer to password */
};


/*
	Externally exposed API-like things.
*/

typedef LPVOID HPWL;
typedef HPWL *LPHPWL;

APIERR OpenPasswordCache(
	LPHPWL lphCache,
	const CHAR *pszUsername,
	const CHAR *pszPassword,
	BOOL fWritable );
APIERR ClosePasswordCache( HPWL hCache, BOOL fDiscardMemory );
APIERR CreatePasswordCache(
	LPHPWL lphCache,
	const CHAR *pszUsername,
	const CHAR *pszPassword );
APIERR DeletePasswordCache(const CHAR *pszUsername);
APIERR CheckCacheVersion( HPWL hCache, ULONG ulVersion );
APIERR LoadCacheImage( HPWL hCache );
APIERR MakeCacheDirty( HPWL hCache );
APIERR FindCacheResource(
	HPWL hCache,
	const CHAR *pbResource,
	WORD cbResource,
	CHAR *pbBuffer,
	WORD cbBuffer,
	UCHAR nType );
APIERR DeleteCacheResource(
	HPWL hCache,
	const CHAR *pbResource,
	WORD cbResource,
	UCHAR nType );
APIERR AddCacheResource(
	HPWL hCache,
	const CHAR *pbResource,
	WORD cbResource,
	const CHAR *pbPassword,
	WORD cbPassword,
	UCHAR nType,
	UINT fnFlags );
#define PCE_MEMORYONLY		0x01

APIERR EnumCacheResources(
	HPWL hCache,
	const CHAR *pbPrefix,
	WORD cbPrefix,
	UCHAR nType,
	CACHECALLBACK pfnCallback,
	DWORD dwRefData );
APIERR UpdateCacheMRU(
	HPWL hCache,
	const struct CACHE_ENTRY_INFO *pce );
APIERR SetCachePassword(
	HPWL hCache,
	const CHAR *pszNewPassword );
APIERR GetCacheFileName(
	const CHAR *pszUsername,
	CHAR *pszFilename,
	UINT cbFilename );

#ifdef __cplusplus
}	/* extern "C" */
#endif


#endif	/* _PWLAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\advdlg.cpp ===
/****************************************************************************\
 *
 *   advdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Advanced Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "parselbl.h"
#include "picsrule.h"
#include "advdlg.h"         // CAdvancedDialog
// #include "custfile.h"       // CCustomFileDialog
#include "debug.h"          // TraceMsg()
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

// $KLUDGE begins -- These should not be a global set outside the class!!
extern PICSRulesRatingSystem * g_pPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;
// $KLUDGE ends -- These should not be a global set outside the class!!

DWORD CAdvancedDialog::aIds[] = {
    IDC_TEXT1,              IDH_RATINGS_BUREAU,
    IDC_TEXT2,              IDH_RATINGS_BUREAU,
    IDC_TEXT3,              IDH_RATINGS_BUREAU,
    IDC_3RD_COMBO,          IDH_RATINGS_BUREAU,
    IDC_STATIC_PICSRULES,   IDH_IGNORE,
    IDC_STATIC_PICSRULES2,  IDH_IGNORE,
    IDC_PICSRULESOPEN,      IDH_PICSRULES_OPEN,
    IDC_PICSRULESEDIT,      IDH_PICSRULES_EDIT,
    IDC_PICSRULES_UP,       IDH_ADVANCED_TAB_UP_ARROW_BUTTON,
    IDC_PICSRULES_DOWN,     IDH_ADVANCED_TAB_DOWN_ARROW_BUTTON,
    IDC_STATIC1,            IDH_IGNORE,
    IDC_PICSRULES_LIST,     IDH_PICS_RULES_LIST,
    0,0
};

CAdvancedDialog::CAdvancedDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

LRESULT CAdvancedDialog::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND hDlg = m_hWnd;

    HICON   hIcon, hOldIcon;

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_UP),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    
    hOldIcon=(HICON) SendDlgItemMessage(IDC_PICSRULES_UP,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    if(hOldIcon!=NULL)
    {
        DeleteObject(hOldIcon);
    }

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_DOWN),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

    hOldIcon=(HICON) SendDlgItemMessage(IDC_PICSRULES_DOWN,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    if(hOldIcon!=NULL)
    {
        DeleteObject(hOldIcon);
    }

    return 0L;
}

LRESULT CAdvancedDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HICON   hIcon;
    int     iCounter;

    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CAdvancedDialog::OnInitDialog() - pPRSD is NULL!" );
        return 0L;
    }

    FillBureauList( pPRSD->pPRSI);

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_UP),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    
    SendDlgItemMessage(IDC_PICSRULES_UP,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_DOWN),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    
    SendDlgItemMessage(IDC_PICSRULES_DOWN,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    g_arrpPICSRulesPRRSPreApply.DeleteAll();

    if(g_lGlobalCounterValue!=SHGlobalCounterGetValue(g_HandleGlobalCounter))
    {
        HRESULT               hRes;
        DWORD                 dwNumSystems;
        PICSRulesRatingSystem * pPRRS=NULL;

        g_arrpPRRS.DeleteAll();

        //someone modified our settings, so we'd better reload them.
        hRes=PICSRulesGetNumSystems(&dwNumSystems);

        if(SUCCEEDED(hRes))
        {
            DWORD dwCounter;

            for(dwCounter=PICSRULES_FIRSTSYSTEMINDEX;
                dwCounter<(dwNumSystems+PICSRULES_FIRSTSYSTEMINDEX);
                dwCounter++)
            {
                hRes=PICSRulesReadFromRegistry(dwCounter,&pPRRS);

                if(FAILED(hRes))
                {
                    //we couldn't read in the systems, so don't inforce PICSRules,
                    //and notify the user
        
                    g_arrpPRRS.DeleteAll();

                    MyMessageBox(m_hWnd, IDS_PICSRULES_TAMPEREDREADMSG, IDS_PICSRULES_TAMPEREDREADTITLE, MB_OK|MB_ICONERROR );
                    break;
                }
                else
                {
                    g_arrpPRRS.Append(pPRRS);

                    pPRRS=NULL;
                }
            }
        }

        g_lGlobalCounterValue=SHGlobalCounterGetValue(g_HandleGlobalCounter);
    }

    CopyArrayPRRSStructures(&g_arrpPICSRulesPRRSPreApply,&g_arrpPRRS);

    //fill in the listbox with installed PICSRules systems
    for(iCounter=0;iCounter<g_arrpPICSRulesPRRSPreApply.Length();iCounter++)
    {
        PICSRulesRatingSystem * pPRRSToList;
        char                  * lpszName=NULL;

        pPRRSToList=g_arrpPICSRulesPRRSPreApply[iCounter];

        if((pPRRSToList->m_pPRName)!=NULL)
        {
            lpszName=pPRRSToList->m_pPRName->m_etstrRuleName.Get();
        }

        if(lpszName==NULL)
        {
            lpszName=pPRRSToList->m_etstrFile.Get();
        }

        // We should have a name in lpszName by now, but just in case, check for it.
        if (lpszName)
        {
            SendDlgItemMessage(IDC_PICSRULES_LIST,LB_ADDSTRING,(WPARAM) 0,(LPARAM) lpszName);
        }
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,LB_SETCURSEL,(WPARAM) -1,(LPARAM) 0);
    ::EnableWindow(GetDlgItem(IDC_PICSRULESEDIT),FALSE);

    if(SendDlgItemMessage( IDC_PICSRULES_LIST, LB_GETCOUNT, 0, 0) < 2)
    {
        // less than 2 elements in box - disable up and down buttons
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_UP), FALSE);
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_DOWN), FALSE);
    }

    PostMessage(WM_USER,(WPARAM) 0,(LPARAM) 0);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CAdvancedDialog::OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (gPRSI->lpszFileName!=NULL)
    {
        ::SetFocus(GetDlgItem(IDC_PICSRULESOPEN));

        SendMessage(WM_COMMAND,(WPARAM) IDC_PICSRULESOPEN,(LPARAM) 0);

        gPRSI->lpszFileName=NULL;
    }

    return 0L;
}

LRESULT CAdvancedDialog::OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MarkChanged();
    return 1L;
}

LRESULT CAdvancedDialog::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    ::EnableWindow(GetDlgItem(IDC_PICSRULESEDIT),TRUE);
    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                     iSelected;
    PICSRulesRatingSystem * pPRRSToMove;
    char                  * lpszName=NULL;

    iSelected= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCURSEL,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iSelected==LB_ERR)
    {
        return 1L;
    }

    if(iSelected==0)
    {
        //already at the top

        return 1L;
    }

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    g_arrpPICSRulesPRRSPreApply[iSelected]=
        g_arrpPICSRulesPRRSPreApply[iSelected-1];

    g_arrpPICSRulesPRRSPreApply[iSelected-1]=pPRRSToMove;

    //update the listbox
    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected,
                       (LPARAM) 0);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected-1,
                       (LPARAM) 0);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected-1];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected-1,
                       (LPARAM) lpszName);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected,
                       (LPARAM) lpszName);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_SETCURSEL,
                       (WPARAM) iSelected-1,
                       (LPARAM) 0);

    MarkChanged();

    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                     iSelected, iNumItems;
    PICSRulesRatingSystem * pPRRSToMove;
    char                  * lpszName=NULL;

    iSelected= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCURSEL,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iSelected==LB_ERR)
    {
        return 1L;
    }

    iNumItems= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCOUNT,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iNumItems==LB_ERR)
    {
        return 1L;
    }

    if(iSelected==(iNumItems-1))
    {
        //already at the bottom

        return 1L;
    }

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    g_arrpPICSRulesPRRSPreApply[iSelected]=
        g_arrpPICSRulesPRRSPreApply[iSelected+1];

    g_arrpPICSRulesPRRSPreApply[iSelected+1]=pPRRSToMove;

    //update the listbox
    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected+1,
                       (LPARAM) 0);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected,
                       (LPARAM) 0);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected,
                       (LPARAM) lpszName);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected+1];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected+1,
                       (LPARAM) lpszName);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_SETCURSEL,
                       (WPARAM) iSelected+1,
                       (LPARAM) 0);

    MarkChanged();

    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int     iSelected, iCounter;
    array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSNew;


    iSelected= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCURSEL,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iSelected==LB_ERR)
    {
        return 1L;
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected,
                       (LPARAM) 0);

    // If there's less than two left, turn off up and down buttons
    if(SendDlgItemMessage( IDC_PICSRULES_LIST, LB_GETCOUNT, 0, 0) < 2)
    {
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_UP), FALSE);
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_DOWN), FALSE);
    }

    delete (g_arrpPICSRulesPRRSPreApply[iSelected]);

    g_arrpPICSRulesPRRSPreApply[iSelected]=NULL;

    for(iCounter=0;iCounter<g_arrpPICSRulesPRRSPreApply.Length();iCounter++)
    {
        PICSRulesRatingSystem * pPRRSToMove;

        pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iCounter];

        if(pPRRSToMove!=NULL)
        {
            g_arrpPICSRulesPRRSNew.Append(pPRRSToMove);
        }
    }

    g_arrpPICSRulesPRRSPreApply.ClearAll();

    for(iCounter=0;iCounter<g_arrpPICSRulesPRRSNew.Length();iCounter++)
    {
        PICSRulesRatingSystem * pPRRSToMove;

        pPRRSToMove=g_arrpPICSRulesPRRSNew[iCounter];

        g_arrpPICSRulesPRRSPreApply.Append(pPRRSToMove);
    }

    g_arrpPICSRulesPRRSNew.ClearAll();

    ::EnableWindow(GetDlgItem(IDC_PICSRULESEDIT),FALSE);
    MarkChanged();
    ::SetFocus(GetDlgItem(IDC_PICSRULESOPEN));

    SendDlgItemMessage(IDC_PICSRULESOPEN,
                       BM_SETSTYLE,
                       (WPARAM) BS_DEFPUSHBUTTON,
                       (LPARAM) MAKELPARAM(TRUE,0));

    SendDlgItemMessage(IDC_PICSRULESEDIT,
                       BM_SETSTYLE,
                       (WPARAM) BS_PUSHBUTTON,
                       (LPARAM) MAKELPARAM(TRUE,0));
    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TCHAR szFile[MAX_PATH];

    szFile[0] = '\0';

    BOOL                    bExists=FALSE,fPICSRulesSaved=FALSE,fHaveFile=FALSE;
    PICSRulesRatingSystem   *pPRRS;

    PRSD *      pPRSD = m_pPRSD;

    if(!pPRSD)
    {
        MyMessageBox(m_hWnd, IDS_PICSRULES_SYSTEMERROR, IDS_ERROR, MB_OK|MB_ICONERROR);

        return 1L;
    }

    if (gPRSI->lpszFileName)
    {
        fHaveFile=TRUE;
        lstrcpy(szFile,gPRSI->lpszFileName);
    }
    else
    {
        TCHAR szDlgTitle[MAX_PATH];
        TCHAR szDlgFilter[MAX_PATH];

        LPTSTR pszDlgFilterPtr;

        memset( szDlgFilter, 0, sizeof( szDlgFilter ) );

        MLLoadString(IDS_OPENDIALOGFILTER,(LPTSTR) szDlgFilter,ARRAYSIZE(szDlgFilter));
        MLLoadString(IDS_OPENDIALOGTITLE,(LPTSTR) szDlgTitle,ARRAYSIZE(szDlgTitle));

        pszDlgFilterPtr = &szDlgFilter[lstrlen(szDlgFilter)+1];
        lstrcpy(pszDlgFilterPtr, TEXT("*.prf"));

        OPENFILENAME OpenFileName;

        memset( &OpenFileName, 0, sizeof(OpenFileName) );

        OpenFileName.lStructSize       =sizeof(OPENFILENAME); 
        OpenFileName.hwndOwner         =m_hWnd; 
        OpenFileName.hInstance         =NULL; 
        OpenFileName.lpstrFilter       =szDlgFilter; 
        OpenFileName.lpstrCustomFilter =(LPTSTR) NULL; 
        OpenFileName.nMaxCustFilter    =0L; 
        OpenFileName.nFilterIndex      =1L; 
        OpenFileName.lpstrFile         =szFile; 
        OpenFileName.nMaxFile          =ARRAYSIZE(szFile); 
        OpenFileName.lpstrInitialDir   =NULL; 
        OpenFileName.lpstrTitle        =szDlgTitle; 
        OpenFileName.nFileOffset       =0; 
        OpenFileName.nFileExtension    =0; 
        OpenFileName.lpstrDefExt       =NULL; 
        OpenFileName.lCustData         =0; 
        OpenFileName.Flags             =OFN_FILEMUSTEXIST
                                        | OFN_PATHMUSTEXIST
                                        | OFN_HIDEREADONLY;

        fHaveFile = ::GetOpenFileName( &OpenFileName );

#ifdef NEVER
        DWORD           dwFlags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_NONETWORKBUTTON
                            | OFN_HIDEREADONLY;

        CCustomFileDialog           cfd( TRUE,          // Local Files Only
                                         TRUE,          // Open File
                                         NULL,          // Default Extension
                                         NULL,          // Initial Filename
                                         dwFlags,       // Open File Flags
                                         szDlgFilter,   // Filter
                                         m_hWnd );      // Parent

        if ( cfd.DoModal( m_hWnd ) )
        {
            fHaveFile = TRUE;
            lstrcpy( szFile, cfd.m_szFileName );
        }
#endif

    }    

    if (fHaveFile) 
    {
        HRESULT hRes;

        //create PICSRulesRatingSystem class, and pass to the
        //import procedure with file name

        hRes=PICSRulesImport(szFile,&pPRRS);

        if(SUCCEEDED(hRes))
        {
            LPSTR   lpszPICSRulesSystemName = NULL,lpszNewSystemName = NULL;
            DWORD   dwSystemToSave,dwNumSystemsInstalled,dwCounter;
            BOOL    fPromptToOverwrite=FALSE;

            if((pPRRS->m_pPRName)!=NULL)
            {
                lpszNewSystemName=pPRRS->m_pPRName->m_etstrRuleName.Get();
            }

            if(lpszNewSystemName==NULL)
            {
                lpszNewSystemName=pPRRS->m_etstrFile.Get();
            }

            dwNumSystemsInstalled=g_arrpPICSRulesPRRSPreApply.Length();

            //Systems below PICSRULES_FIRSTSYSTEMINDEX are
            //reserved for the Approved Sites Rules, and
            //future expansion.
            for(dwCounter=0;dwCounter<dwNumSystemsInstalled;dwCounter++)
            {
                //check to see if the system we just processed
                //is already installed
                if ((g_arrpPICSRulesPRRSPreApply[dwCounter])->m_pPRName != NULL)
                {
                    lpszPICSRulesSystemName=(g_arrpPICSRulesPRRSPreApply[dwCounter])->m_pPRName->m_etstrRuleName.Get();
                }

                if (lpszPICSRulesSystemName == NULL)
                {
                    lpszPICSRulesSystemName=(g_arrpPICSRulesPRRSPreApply[dwCounter])->m_etstrFile.Get();
                }

                if(lstrcmp(lpszPICSRulesSystemName,lpszNewSystemName)==0)
                {
                    //We've found an identical system, so set dwSystemToSave
                    //to dwCounter and set fPromptToOverwrite to TRUE
                    fPromptToOverwrite=TRUE;

                    return 1L;
                }
            }

            dwSystemToSave=dwCounter+PICSRULES_FIRSTSYSTEMINDEX;

            if(fPromptToOverwrite)
            {
                if (IDNO == MyMessageBox(m_hWnd, IDS_PICSRULES_EXISTSMESSAGE, IDS_PICSRULES_EXISTSTITLE, MB_YESNO|MB_ICONERROR))
                {
                    delete pPRRS;

                    pPRRS=NULL;
                    g_pPRRS=NULL;

                    return 1L;
                }
            }

            if((dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX)<(DWORD) (g_arrpPICSRulesPRRSPreApply.Length()))
            {
                char * lpszName=NULL;

                delete g_arrpPICSRulesPRRSPreApply[dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX];
                g_arrpPICSRulesPRRSPreApply[dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX]=pPRRS;

                //update the listbox
                if((pPRRS->m_pPRName)!=NULL)
                {
                    lpszName=pPRRS->m_pPRName->m_etstrRuleName.Get();
                }

                if(lpszName==NULL)
                {
                    lpszName=pPRRS->m_etstrFile.Get();
                }

                SendDlgItemMessage(IDC_PICSRULES_LIST,
                                   LB_DELETESTRING,
                                   (WPARAM) dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX,
                                   (LPARAM) 0);

                SendDlgItemMessage(IDC_PICSRULES_LIST,
                                   LB_INSERTSTRING,
                                   (WPARAM) dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX,
                                   (LPARAM) lpszName);
            }
            else
            {
                char * lpszName=NULL;

                g_arrpPICSRulesPRRSPreApply.Append(pPRRS);

                //update the listbox
                if((pPRRS->m_pPRName)!=NULL)
                {
                    lpszName=pPRRS->m_pPRName->m_etstrRuleName.Get();
                }

                if(lpszName==NULL)
                {
                    lpszName=pPRRS->m_etstrFile.Get();
                }

                SendDlgItemMessage(IDC_PICSRULES_LIST,
                                   LB_ADDSTRING,
                                   (WPARAM) 0,
                                   (LPARAM) lpszName);

                // if there's now more than one element,
                // turn on up and down buttons
                if(SendDlgItemMessage( IDC_PICSRULES_LIST,
                                    LB_GETCOUNT, 0, 0) > 1)
                {
                    ::EnableWindow(GetDlgItem( IDC_PICSRULES_UP), TRUE);
                    ::EnableWindow(GetDlgItem( IDC_PICSRULES_DOWN), TRUE);
                }
            }

            fPICSRulesSaved=TRUE;

            MarkChanged();
        }
        else
        {
            pPRRS->ReportError(hRes);

            delete pPRRS;
            pPRRS=NULL;
        }

        if (!fPICSRulesSaved)
        {
            if (pPRRS)
            {
                //we successfully processed the PICSRules, but couldn't
                //save them

                MyMessageBox(m_hWnd, IDS_PICSRULES_ERRORSAVINGMSG, IDS_PICSRULES_ERRORSAVINGTITLE, MB_OK|MB_ICONERROR);

                delete pPRRS;
                pPRRS=NULL;
            }
        }
        else
        {
            //Success!  Notify the user.

            MyMessageBox(m_hWnd, IDS_PICSRULES_SUCCESSMESSAGE, IDS_PICSRULES_SUCCESSTITLE, MB_OK);
        }
    }

    g_pPRRS=NULL; //done processing the current system, so make sure it
                  //doesn't point to anything

    return 1L;
}

LRESULT CAdvancedDialog::OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    PRSD *          pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CAdvancedDialog::OnSetActive() - pPRSD is NULL!" );
        return 0L;
    }

    if(pPRSD->fNewProviders==TRUE)
    {
        FillBureauList( pPRSD->pPRSI);
    }

    bHandled = FALSE;
    return 0L;
}

LRESULT CAdvancedDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    /*do apply stuff*/
    PRSD *      pPRSD = m_pPRSD;

    DWORD dwNumExistingSystems,dwCounter;

    /*do apply stuff*/

    /* Get the text from the rating bureau combo box. */
    /* Default for etstrRatingBureau (the URL) will be this text. */
    NLS_STR nlsURL;

    int i;
    const char *p;

    if (nlsURL.realloc( ::GetWindowTextLength(GetDlgItem( IDC_3RD_COMBO)) + 1)) {
        CHAR *pszUrl = nlsURL.Party();
        if (pszUrl) {
            GetDlgItemText( IDC_3RD_COMBO, pszUrl, nlsURL.QueryAllocSize());
            nlsURL.DonePartying();
            p = (char *)nlsURL.QueryPch();

            INT_PTR temp = SendDlgItemMessage( IDC_3RD_COMBO, CB_GETCURSEL, 0, 0L);
            if (temp != CB_ERR) {
                /* Get the text of the selected item in the list. */
                UINT cbName = (UINT)SendDlgItemMessage( IDC_3RD_COMBO, CB_GETLBTEXTLEN, temp, 0);
                NLS_STR nlsName(cbName+1);
                if (nlsName.QueryError())
                    p = NULL;
                else {
                    /* If the text of the selected item in the list
                    * is what's in the edit field, then the user
                    * has selected one of those rating system names.
                    * The itemdata for the item is the URL.
                    */
                    SendDlgItemMessage( IDC_3RD_COMBO, CB_GETLBTEXT, temp, (LPARAM)(LPSTR)nlsName.Party());
                    nlsName.DonePartying();
                    if (nlsName == nlsURL)
                        p = (char *)SendDlgItemMessage( IDC_3RD_COMBO, CB_GETITEMDATA, temp, 0L);
                }
            }
        }
        else
        {
            p = NULL;
        }
    }
    else
    {
        p = NULL;
    }

    if (pPRSD->pPRSI->etstrRatingBureau.fIsInit() && (!p ||
        strcmpf(pPRSD->pPRSI->etstrRatingBureau.Get(),p)))
    {
        // check if old bureau is required
        for (i = 0; i <pPRSD->pPRSI->arrpPRS.Length(); ++i)
        {
            if (pPRSD->pPRSI->arrpPRS[i]->etstrRatingBureau.fIsInit() &&
                (!strcmpf(pPRSD->pPRSI->etstrRatingBureau.Get(),
                          pPRSD->pPRSI->arrpPRS[i]->etstrRatingBureau.Get())))
            {
                if (!(pPRSD->pPRSI->arrpPRS[i]->etbBureauRequired.Get()))
                {
                    break; // Not required.  We're done.
                }      
                      
                //We're removing a bureau that's required.  Warn user.
                char pszBuf[MAXPATHLEN];
                char szTemp[MAXPATHLEN];

                MLLoadStringA(IDS_NEEDBUREAU, pszBuf, sizeof(pszBuf));
                wsprintf(szTemp, pszBuf, pPRSD->pPRSI->arrpPRS[i]->etstrName.Get());
                if (MessageBox(szTemp, NULL, MB_YESNO) == IDNO)
                {
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
                else
                {
                    break;
                }
            }
        }
    }

    if (!p || !*p)
    {
        pPRSD->pPRSI->etstrRatingBureau.Set(NULL);
        DeinstallRatingBureauHelper();
    }
    else
    {
        pPRSD->pPRSI->etstrRatingBureau.Set((LPSTR)p);
        InstallRatingBureauHelper();
    }    

    /* Update the rating helper list to include or not include
     * the rating bureau helper.
     */
    CleanupRatingHelpers();
    InitRatingHelpers();

    //process PICSRules

    PICSRulesGetNumSystems(&dwNumExistingSystems);

    for(dwCounter=0;dwCounter<dwNumExistingSystems;dwCounter++)
    {
        //delete all existing systems from the registry
        PICSRulesDeleteSystem(dwCounter+PICSRULES_FIRSTSYSTEMINDEX);
    }

    g_arrpPRRS.DeleteAll();

    CopyArrayPRRSStructures(&g_arrpPRRS,&g_arrpPICSRulesPRRSPreApply);

    for(dwCounter=0;dwCounter<(DWORD) (g_arrpPRRS.Length());dwCounter++)
    {
        g_pPRRS=g_arrpPRRS[dwCounter];

        PICSRulesSaveToRegistry(dwCounter+PICSRULES_FIRSTSYSTEMINDEX,&g_arrpPRRS[dwCounter]);
    }

    PICSRulesSetNumSystems(g_arrpPICSRulesPRRSPreApply.Length());

    SHGlobalCounterIncrement(g_HandleGlobalCounter);

    if ( ! lpPSHNotify->lParam )
    {
        // Apply 
        return PSNRET_NOERROR;
    }

    // Return 1L for OK or Cancel
    return PSNRET_NOERROR;
}

LRESULT CAdvancedDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return 0L;
}

LRESULT CAdvancedDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CAdvancedDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

void CAdvancedDialog::InstallRatingBureauHelper( void )
{
    HKEY                hkey;

    hkey = CreateRegKeyNT( ::szRATINGHELPERS );

    if ( hkey != NULL )
    {
        CRegKey             key;

        key.Attach( hkey );

        key.SetValue( szRORSGUID, szNULL );
    }
    else
    {
        TraceMsg( TF_ERROR, "CAdvancedDialog::InstallRatingBureauHelper() - Failed to create key szRATINGHELPERS='%s'!", szRATINGHELPERS );
    }
}

void CAdvancedDialog::DeinstallRatingBureauHelper( void )
{
    CRegKey         key;

    if ( key.Open( HKEY_LOCAL_MACHINE, szRATINGHELPERS ) == ERROR_SUCCESS )
    {
        key.DeleteValue( szRORSGUID );
    }
}

UINT CAdvancedDialog::FillBureauList( PicsRatingSystemInfo *pPRSI )
{
    int i;
    INT_PTR z;
    BOOL fHaveBureau = pPRSI->etstrRatingBureau.fIsInit();
    BOOL fSelectedOne = FALSE;

    HWND hwndCombo = GetDlgItem( IDC_3RD_COMBO);
    LPCSTR pszCurrentBureau;
    BOOL fListBureau = FALSE;

    NLS_STR nlsURL;

    /* Save current selection if at all possible.  If an item in the listbox
     * is selected, get its item data, which is the rating bureau string.
     *
     * We remember if it was an item from the list that was selected before;
     * that indicates that the bureau belongs to a rating system, and if we
     * don't find it in the list after reinitializing, we know that rating
     * system has been removed and the bureau is probably useless now.
     */
    z = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (z != CB_ERR)
    {
        pszCurrentBureau = (LPCSTR)SendMessage(hwndCombo, CB_GETITEMDATA, z, 0);
        fListBureau = TRUE;
    }
    else
    {
        /* No item selected.  If there is text in the edit control, preserve
         * it;  otherwise, try to select the current rating bureau if any.
         */
        UINT cch = ::GetWindowTextLength(hwndCombo);
        if (cch > 0 && nlsURL.realloc(cch + 1)) {
            ::GetWindowText(hwndCombo, nlsURL.Party(), nlsURL.QueryAllocSize());
            nlsURL.DonePartying();
            pszCurrentBureau = nlsURL.QueryPch();
        }
        else
        {
            pszCurrentBureau = fHaveBureau ? pPRSI->etstrRatingBureau.Get() : szNULL;
        }
    }

    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
   
    for (i = 0; i < pPRSI->arrpPRS.Length(); ++i)
    {
        PicsRatingSystem *prs = pPRSI->arrpPRS[i];
        if (prs->etstrRatingBureau.fIsInit())
        {
            z = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)prs->etstrName.Get());
            SendMessage(hwndCombo, CB_SETITEMDATA, z,
                        (LPARAM)prs->etstrRatingBureau.Get());

            if (!fSelectedOne)
            {
                if (!strcmpf(pszCurrentBureau, prs->etstrRatingBureau.Get())) 
                {
                    SendMessage(hwndCombo, CB_SETCURSEL, z,0);
                    fSelectedOne = TRUE;
                }           
            }
        }
    }

    NLS_STR nlsNone(MAX_RES_STR_LEN);
    if (nlsNone.LoadString(IDS_NO_BUREAU) != ERROR_SUCCESS)
        nlsNone = NULL;

    z = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)nlsNone.QueryPch());

    SendMessage(hwndCombo, CB_SETITEMDATA, z, 0L);
       
    if (!fSelectedOne)
    {
        if (!fListBureau && *pszCurrentBureau != '\0')
            ::SetWindowText(hwndCombo, pszCurrentBureau);
        else
            SendMessage(hwndCombo, CB_SETCURSEL, z, 0L);
    }

    return 0;
}

HRESULT CAdvancedDialog::CopySubPolicyExpression(PICSRulesPolicyExpression * pPRSubPolicyExpression,
                                PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy,
                                PICSRulesRatingSystem * pPRRSLocal,
                                PICSRulesPolicy * pPRPolicy)
{
    BOOL fFlag;
    
    fFlag=pPRSubPolicyExpressionToCopy->m_prYesNoUseEmbedded.GetYesNo();
    pPRSubPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);

    pPRSubPolicyExpression->m_etstrServiceName.Set(pPRSubPolicyExpressionToCopy->m_etstrServiceName.Get());
    pPRSubPolicyExpression->m_etstrCategoryName.Set(pPRSubPolicyExpressionToCopy->m_etstrCategoryName.Get());
    pPRSubPolicyExpression->m_etstrFullServiceName.Set(pPRSubPolicyExpressionToCopy->m_etstrFullServiceName.Get());
    pPRSubPolicyExpression->m_etnValue.Set(pPRSubPolicyExpressionToCopy->m_etnValue.Get());

    pPRSubPolicyExpression->m_PROPolicyOperator=pPRSubPolicyExpressionToCopy->m_PROPolicyOperator;
    pPRSubPolicyExpression->m_PRPEPolicyEmbedded=pPRSubPolicyExpressionToCopy->m_PRPEPolicyEmbedded;

    if(pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionLeft!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpression2,* pPRSubPolicyExpressionToCopy2;

        pPRSubPolicyExpression2=new PICSRulesPolicyExpression;

        if(pPRSubPolicyExpression2==NULL)
        {
            PICSRulesOutOfMemory();

            delete pPRRSLocal;
            pPRRSLocal = NULL;

            delete pPRPolicy;
            pPRPolicy = NULL;

            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpressionToCopy2=pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionLeft;

        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression2,pPRSubPolicyExpressionToCopy2,pPRRSLocal,pPRPolicy)))
        {
            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpression->m_pPRPolicyExpressionLeft=pPRSubPolicyExpression2;
    }

    if(pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionRight!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpression2,* pPRSubPolicyExpressionToCopy2;

        pPRSubPolicyExpression2=new PICSRulesPolicyExpression;

        if(pPRSubPolicyExpression2==NULL)
        {
            PICSRulesOutOfMemory();

            delete pPRRSLocal;
            pPRRSLocal = NULL;

            delete pPRPolicy;
            pPRPolicy = NULL;

            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpressionToCopy2=pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionRight;

        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression2,pPRSubPolicyExpressionToCopy2,pPRRSLocal,pPRPolicy)))
        {
            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpression->m_pPRPolicyExpressionRight=pPRSubPolicyExpression2;
    }

    return(NOERROR);
}

HRESULT CAdvancedDialog::CopyArrayPRRSStructures(array<PICSRulesRatingSystem*> * parrpPRRSDest,array<PICSRulesRatingSystem*> * parrpPRRSSource)
{
    DWORD                       dwCounter;
    PICSRulesRatingSystem       * pPRRSLocal,* pPRRSBeingCopied;
    PICSRulesPolicy             * pPRPolicy,* pPRPolicyBeingCopied;
    PICSRulesPolicyExpression   * pPRPolicyExpression,* pPRPolicyExpressionBeingCopied;
    PICSRulesServiceInfo        * pPRServiceInfo,* pPRServiceInfoBeingCopied;
    PICSRulesOptExtension       * pPROptExtension,* pPROptExtensionBeingCopied;
    PICSRulesReqExtension       * pPRReqExtension,* pPRReqExtensionBeingCopied;
    PICSRulesName               * pPRName,* pPRNameBeingCopied;
    PICSRulesSource             * pPRSource,* pPRSourceBeingCopied;
    PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
    PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

    if(parrpPRRSDest->Length()>0)
    {
        parrpPRRSDest->DeleteAll();
    }

    for(dwCounter=0;dwCounter<(DWORD) (parrpPRRSSource->Length());dwCounter++)
    {
        pPRRSLocal=new PICSRulesRatingSystem;

        if(pPRRSLocal==NULL)
        {
            PICSRulesOutOfMemory();

            return(E_OUTOFMEMORY);
        }

        pPRRSBeingCopied=(*parrpPRRSSource)[dwCounter];

        pPRRSLocal->m_etstrFile.Set(pPRRSBeingCopied->m_etstrFile.Get());
        pPRRSLocal->m_etnPRVerMajor.Set(pPRRSBeingCopied->m_etnPRVerMajor.Get());
        pPRRSLocal->m_etnPRVerMinor.Set(pPRRSBeingCopied->m_etnPRVerMinor.Get());
        pPRRSLocal->m_dwFlags=pPRRSBeingCopied->m_dwFlags;
        pPRRSLocal->m_nErrLine=pPRRSBeingCopied->m_nErrLine;

        if((pPRRSBeingCopied->m_pPRName)!=NULL)
        {
            pPRName=new PICSRulesName;

            if(pPRName==NULL)
            {
                PICSRulesOutOfMemory();

                delete pPRRSLocal;
                pPRRSLocal = NULL;

                return(E_OUTOFMEMORY);
            }

            pPRNameBeingCopied=pPRRSBeingCopied->m_pPRName;

            pPRName->m_etstrRuleName.Set(pPRNameBeingCopied->m_etstrRuleName.Get());
            pPRName->m_etstrDescription.Set(pPRNameBeingCopied->m_etstrDescription.Get());
        
            pPRRSLocal->m_pPRName=pPRName;          
        }
        else
        {
            pPRRSLocal->m_pPRName=NULL;
        }

        if((pPRRSBeingCopied->m_pPRSource)!=NULL)
        {
            pPRSource=new PICSRulesSource;

            if(pPRSource==NULL)
            {
                PICSRulesOutOfMemory();

                delete pPRRSLocal;
                pPRRSLocal = NULL;

                return(E_OUTOFMEMORY);
            }

            pPRSourceBeingCopied=pPRRSBeingCopied->m_pPRSource;

            pPRSource->m_prURLSourceURL.Set(pPRSourceBeingCopied->m_prURLSourceURL.Get());
            pPRSource->m_etstrCreationTool.Set(pPRSourceBeingCopied->m_etstrCreationTool.Get());
            pPRSource->m_prEmailAuthor.Set(pPRSourceBeingCopied->m_prEmailAuthor.Get());
            pPRSource->m_prDateLastModified.Set(pPRSourceBeingCopied->m_prDateLastModified.Get());

            pPRRSLocal->m_pPRSource=pPRSource;
        }
        else
        {
            pPRRSLocal->m_pPRSource=NULL;
        }

        if(pPRRSBeingCopied->m_arrpPRPolicy.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRPolicy.Length());dwSubCounter++)
            {
                DWORD dwPolicyExpressionSubCounter;

                pPRPolicy=new PICSRulesPolicy;

                pPRPolicyBeingCopied=pPRRSBeingCopied->m_arrpPRPolicy[dwSubCounter];

                if(pPRPolicy==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPRPolicy->m_etstrExplanation.Set(pPRPolicyBeingCopied->m_etstrExplanation.Get());
                pPRPolicy->m_PRPolicyAttribute=pPRPolicyBeingCopied->m_PRPolicyAttribute;

                pPRByURLToCopy=NULL;
                pPRPolicyExpressionBeingCopied=NULL;

                switch(pPRPolicy->m_PRPolicyAttribute)
                {
                    case PR_POLICY_ACCEPTBYURL:
                    {
                        pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRAcceptByURL;
                    
                        pPRByURL=new PICSRulesByURL;
                
                        if(pPRByURL==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRAcceptByURL=pPRByURL;

                        break;
                    }
                    case PR_POLICY_REJECTBYURL:
                    {
                        pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRRejectByURL;

                        pPRByURL=new PICSRulesByURL;
                
                        if(pPRByURL==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRRejectByURL=pPRByURL;

                        break;
                    }
                    case PR_POLICY_REJECTIF:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectIf;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRRejectIf=pPRPolicyExpression;

                        break;
                    }
                    case PR_POLICY_ACCEPTIF:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptIf;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRAcceptIf=pPRPolicyExpression;

                        break;
                    }
                    case PR_POLICY_REJECTUNLESS:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectUnless;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRRejectUnless=pPRPolicyExpression;

                        break;
                    }
                    case PR_POLICY_ACCEPTUNLESS:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptUnless;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRAcceptUnless=pPRPolicyExpression;

                        break;
                    }
                }

                if(pPRByURLToCopy!=NULL)
                {
                    for(dwPolicyExpressionSubCounter=0;
                        dwPolicyExpressionSubCounter<(DWORD) (pPRByURLToCopy->m_arrpPRByURL.Length());
                        dwPolicyExpressionSubCounter++)
                    {
                        pPRByURLExpression=new PICSRulesByURLExpression;

                        if(pPRByURLExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;

                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[dwPolicyExpressionSubCounter];

                        pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
                        pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
                        pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
                        pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
                        pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
                        pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
                        pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
                        pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
                        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

                        pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);
                    }

                    pPRRSLocal->m_arrpPRPolicy.Append(pPRPolicy);
                }

                if(pPRPolicyExpressionBeingCopied!=NULL)
                {
                    BOOL fFlag;
                    
                    fFlag=pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.GetYesNo();
                    pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);

                    pPRPolicyExpression->m_etstrServiceName.Set(pPRPolicyExpressionBeingCopied->m_etstrServiceName.Get());
                    pPRPolicyExpression->m_etstrCategoryName.Set(pPRPolicyExpressionBeingCopied->m_etstrCategoryName.Get());
                    pPRPolicyExpression->m_etstrFullServiceName.Set(pPRPolicyExpressionBeingCopied->m_etstrFullServiceName.Get());
                    pPRPolicyExpression->m_etnValue.Set(pPRPolicyExpressionBeingCopied->m_etnValue.Get());

                    pPRPolicyExpression->m_PROPolicyOperator=pPRPolicyExpressionBeingCopied->m_PROPolicyOperator;
                    pPRPolicyExpression->m_PRPEPolicyEmbedded=pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded;

                    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft!=NULL)
                    {
                        PICSRulesPolicyExpression * pPRSubPolicyExpression,* pPRSubPolicyExpressionToCopy;

                        pPRSubPolicyExpression=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;

                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft;

                        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression,pPRSubPolicyExpressionToCopy,pPRRSLocal,pPRPolicy)))
                        {
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpression->m_pPRPolicyExpressionLeft=pPRSubPolicyExpression;
                    }

                    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight!=NULL)
                    {
                        PICSRulesPolicyExpression * pPRSubPolicyExpression,* pPRSubPolicyExpressionToCopy;

                        pPRSubPolicyExpression=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;

                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight;

                        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression,pPRSubPolicyExpressionToCopy,pPRRSLocal,pPRPolicy)))
                        {
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpression->m_pPRPolicyExpressionRight=pPRSubPolicyExpression;
                    }

                    pPRRSLocal->m_arrpPRPolicy.Append(pPRPolicy);
                }
            }
        }

        if(pPRRSBeingCopied->m_arrpPRServiceInfo.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRServiceInfo.Length());dwSubCounter++)
            {
                BOOL fFlag;

                pPRServiceInfo=new PICSRulesServiceInfo;

                if(pPRServiceInfo==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPRServiceInfoBeingCopied=pPRRSBeingCopied->m_arrpPRServiceInfo[dwSubCounter];

                pPRServiceInfo->m_prURLName.Set(pPRServiceInfoBeingCopied->m_prURLName.Get());
                pPRServiceInfo->m_prURLBureauURL.Set(pPRServiceInfoBeingCopied->m_prURLBureauURL.Get());
                pPRServiceInfo->m_etstrShortName.Set(pPRServiceInfoBeingCopied->m_etstrShortName.Get());
                pPRServiceInfo->m_etstrRatfile.Set(pPRServiceInfoBeingCopied->m_etstrRatfile.Get());

                fFlag=pPRServiceInfoBeingCopied->m_prYesNoUseEmbedded.GetYesNo();
                pPRServiceInfo->m_prYesNoUseEmbedded.Set(&fFlag);

                fFlag=pPRServiceInfoBeingCopied->m_prPassFailBureauUnavailable.GetPassFail();
                pPRServiceInfo->m_prPassFailBureauUnavailable.Set(&fFlag);

                pPRRSLocal->m_arrpPRServiceInfo.Append(pPRServiceInfo);
            }
        }

        if(pPRRSBeingCopied->m_arrpPROptExtension.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPROptExtension.Length());dwSubCounter++)
            {
                pPROptExtension=new PICSRulesOptExtension;

                if(pPROptExtension==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPROptExtensionBeingCopied=pPRRSBeingCopied->m_arrpPROptExtension[dwSubCounter];

                pPROptExtension->m_prURLExtensionName.Set(pPROptExtensionBeingCopied->m_prURLExtensionName.Get());
                pPROptExtension->m_etstrShortName.Set(pPROptExtensionBeingCopied->m_etstrShortName.Get());

                pPRRSLocal->m_arrpPROptExtension.Append(pPROptExtension);
            }
        }

        if(pPRRSBeingCopied->m_arrpPRReqExtension.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRReqExtension.Length());dwSubCounter++)
            {
                pPRReqExtension=new PICSRulesReqExtension;

                if(pPRReqExtension==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPRReqExtensionBeingCopied=pPRRSBeingCopied->m_arrpPRReqExtension[dwSubCounter];

                pPRReqExtension->m_prURLExtensionName.Set(pPRReqExtensionBeingCopied->m_prURLExtensionName.Get());
                pPRReqExtension->m_etstrShortName.Set(pPRReqExtensionBeingCopied->m_etstrShortName.Get());

                pPRRSLocal->m_arrpPRReqExtension.Append(pPRReqExtension);
            }
        }
    
        parrpPRRSDest->Append(pPRRSLocal);
    }

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\winnetwk.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    winnetwk.h

Abstract:

    Standard WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    08-Oct-1991     danl
        created from winnet 3.10.05 version.

    10-Dec-1991     Johnl
        Updated to conform to Win32 Net API Spec. vers 0.4

    01-Apr-1992     JohnL
        Changed CONNECTION_REMEMBERED flag to CONNECT_UPDATE_PROFILE
        Updated WNetCancelConnection2 to match spec.

    23-Apr-1992     Johnl
        Added error code mappings.  Changed byte counts to character counts.

    27-May-1992     ChuckC
        Made into .x file.

    12-22-93        Danl
        Added WNetAddConnection3

    18-Aug-1993     LenS
        Added Windows 95 Extensions

--*/

#ifndef _WINNETWK_
#define _WINNETWK_

#ifdef __cplusplus
extern "C" {
#endif

//
// Network types
//

#define     WNNC_NET_MSNET      0x00010000
#define     WNNC_NET_LANMAN     0x00020000
#define     WNNC_NET_NETWARE    0x00030000
#define     WNNC_NET_VINES      0x00040000
#define     WNNC_NET_10NET      0x00050000
#define     WNNC_NET_LOCUS      0x00060000
#define     WNNC_NET_SUN_PC_NFS 0x00070000
#define     WNNC_NET_LANSTEP    0x00080000
#define     WNNC_NET_9TILES     0x00090000
#define     WNNC_NET_LANTASTIC  0x000A0000
#define     WNNC_NET_AS400      0x000B0000
#define     WNNC_NET_FTP_NFS    0x000C0000
#define     WNNC_NET_PATHWORKS  0x000D0000
#define     WNNC_NET_LIFENET    0x000E0000
#define     WNNC_NET_POWERLAN   0x000F0000
#define     WNNC_NET_BWNFS      0x00100000
#define     WNNC_NET_COGENT     0x00110000
#define     WNNC_NET_FARALLON	0x00120000
#define     WNNC_NET_APPLETALK	0x00130000
#define     WNNC_NET_INTERGRAPH	0x00140000
#define     WNNC_NET_SYMFONET   0x00150000

//
//  Network Resources.
//

#define RESOURCE_CONNECTED      0x00000001
#define RESOURCE_GLOBALNET      0x00000002
#define RESOURCE_REMEMBERED     0x00000003
#if(WINVER >= 0x0400)
#define RESOURCE_RECENT         0x00000004
#define RESOURCE_CONTEXT        0x00000005
#endif /* WINVER >= 0x0400 */

#define RESOURCETYPE_ANY        0x00000000
#define RESOURCETYPE_DISK       0x00000001
#define RESOURCETYPE_PRINT      0x00000002
#if(WINVER >= 0x0400)
#define RESOURCETYPE_RESERVED   0x00000008
#endif /* WINVER >= 0x0400 */
#define RESOURCETYPE_UNKNOWN    0xFFFFFFFF

#define RESOURCEUSAGE_CONNECTABLE   0x00000001
#define RESOURCEUSAGE_CONTAINER     0x00000002
#if(WINVER >= 0x0400)
#define RESOURCEUSAGE_NOLOCALDEVICE 0x00000004
#define RESOURCEUSAGE_SIBLING       0x00000008
#define RESOURCEUSAGE_ALL           (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER)
#endif /* WINVER >= 0x0400 */
#define RESOURCEUSAGE_RESERVED      0x80000000

#define RESOURCEDISPLAYTYPE_GENERIC        0x00000000
#define RESOURCEDISPLAYTYPE_DOMAIN         0x00000001
#define RESOURCEDISPLAYTYPE_SERVER         0x00000002
#define RESOURCEDISPLAYTYPE_SHARE          0x00000003
#define RESOURCEDISPLAYTYPE_FILE           0x00000004
#define RESOURCEDISPLAYTYPE_GROUP          0x00000005
#if(WINVER >= 0x0400)
#define RESOURCEDISPLAYTYPE_NETWORK        0x00000006
#define RESOURCEDISPLAYTYPE_ROOT           0x00000007
#define RESOURCEDISPLAYTYPE_SHAREADMIN     0x00000008
#define RESOURCEDISPLAYTYPE_DIRECTORY      0x00000009
#endif /* WINVER >= 0x0400 */
#define RESOURCEDISPLAYTYPE_TREE           0x0000000A

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;
#ifdef UNICODE
typedef NETRESOURCEW NETRESOURCE;
typedef LPNETRESOURCEW LPNETRESOURCE;
#else
typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#endif // UNICODE

//
//  Network Connections.
// 

#define NETPROPERTY_PERSISTENT       1

#define CONNECT_UPDATE_PROFILE      0x00000001
#define CONNECT_UPDATE_RECENT       0x00000002
#define CONNECT_TEMPORARY           0x00000004
#define CONNECT_INTERACTIVE         0x00000008
#define CONNECT_PROMPT              0x00000010
#define CONNECT_NEED_DRIVE          0x00000020
#if(WINVER >= 0x0400)
#define CONNECT_REFCOUNT            0x00000040
#define CONNECT_REDIRECT            0x00000080
#define CONNECT_LOCALDRIVE          0x00000100
#define CONNECT_CURRENT_MEDIA       0x00000200
#endif /* WINVER >= 0x0400 */

DWORD APIENTRY
WNetAddConnectionA(
     LPCSTR   lpRemoteName,
     LPCSTR   lpPassword,
     LPCSTR   lpLocalName
    );
DWORD APIENTRY
WNetAddConnectionW(
     LPCWSTR   lpRemoteName,
     LPCWSTR   lpPassword,
     LPCWSTR   lpLocalName
    );
#ifdef UNICODE
#define WNetAddConnection  WNetAddConnectionW
#else
#define WNetAddConnection  WNetAddConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetAddConnection2A(
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection2W(
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection2  WNetAddConnection2W
#else
#define WNetAddConnection2  WNetAddConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetAddConnection3A(
     HWND           hwndOwner,
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection3W(
     HWND           hwndOwner,
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection3  WNetAddConnection3W
#else
#define WNetAddConnection3  WNetAddConnection3A
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnectionA(
     LPCSTR lpName,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnectionW(
     LPCWSTR lpName,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection  WNetCancelConnectionW
#else
#define WNetCancelConnection  WNetCancelConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnection2A(
     LPCSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnection2W(
     LPCWSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection2  WNetCancelConnection2W
#else
#define WNetCancelConnection2  WNetCancelConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetGetConnectionA(
     LPCSTR lpLocalName,
     LPSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
DWORD APIENTRY
WNetGetConnectionW(
     LPCWSTR lpLocalName,
     LPWSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
#ifdef UNICODE
#define WNetGetConnection  WNetGetConnectionW
#else
#define WNetGetConnection  WNetGetConnectionA
#endif // !UNICODE

#if(WINVER >= 0x0400)
DWORD APIENTRY
WNetUseConnectionA(
    HWND            hwndOwner,
    LPNETRESOURCEA  lpNetResource,
    LPCSTR        lpUserID,
    LPCSTR        lpPassword,
    DWORD           dwFlags,
    LPSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
DWORD APIENTRY
WNetUseConnectionW(
    HWND            hwndOwner,
    LPNETRESOURCEW  lpNetResource,
    LPCWSTR        lpUserID,
    LPCWSTR        lpPassword,
    DWORD           dwFlags,
    LPWSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
#ifdef UNICODE
#define WNetUseConnection  WNetUseConnectionW
#else
#define WNetUseConnection  WNetUseConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetSetConnectionA(
    LPCSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
DWORD APIENTRY
WNetSetConnectionW(
    LPCWSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
#ifdef UNICODE
#define WNetSetConnection  WNetSetConnectionW
#else
#define WNetSetConnection  WNetSetConnectionA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

//
//  Network Connection Dialogs.
// 

DWORD APIENTRY
WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD APIENTRY
WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    );

#if(WINVER >= 0x0400)
typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEA lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTA, FAR *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEW lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTW, FAR *LPCONNECTDLGSTRUCTW;
#ifdef UNICODE
typedef CONNECTDLGSTRUCTW CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTW LPCONNECTDLGSTRUCT;
#else
typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
#endif // UNICODE

#define CONNDLG_RO_PATH     0x00000001 /* Resource path should be read-only    */
#define CONNDLG_CONN_POINT  0x00000002 /* Netware -style movable connection point enabled */
#define CONNDLG_USE_MRU     0x00000004 /* Use MRU combobox  */
#define CONNDLG_HIDE_BOX    0x00000008 /* Hide persistent connect checkbox  */

/*
 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,
 *        then the persistence is set to whatever the user chose during
 *        a previous connection
 */
#define CONNDLG_PERSIST     0x00000010 /* Force persistent connection */
#define CONNDLG_NOT_PERSIST 0x00000020 /* Force connection NOT persistent */

DWORD APIENTRY
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
DWORD APIENTRY
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );
#ifdef UNICODE
#define WNetConnectionDialog1  WNetConnectionDialog1W
#else
#define WNetConnectionDialog1  WNetConnectionDialog1A
#endif // !UNICODE

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPSTR           lpLocalName;      /* local device name */
    LPSTR           lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTA, FAR *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPWSTR          lpLocalName;      /* local device name */
    LPWSTR          lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTW, FAR *LPDISCDLGSTRUCTW;
#ifdef UNICODE
typedef DISCDLGSTRUCTW DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTW LPDISCDLGSTRUCT;
#else
typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
#endif // UNICODE

#define DISC_UPDATE_PROFILE         0x00000001
#define DISC_NO_FORCE               0x00000040

DWORD APIENTRY
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpConnDlgStruct
    );
DWORD APIENTRY
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpConnDlgStruct
    );
#ifdef UNICODE
#define WNetDisconnectDialog1  WNetDisconnectDialog1W
#else
#define WNetDisconnectDialog1  WNetDisconnectDialog1A
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

//
//  Network Browsing.
//

DWORD APIENTRY
WNetOpenEnumA(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEA lpNetResource,
     LPHANDLE       lphEnum
    );
DWORD APIENTRY
WNetOpenEnumW(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEW lpNetResource,
     LPHANDLE       lphEnum
    );
#ifdef UNICODE
#define WNetOpenEnum  WNetOpenEnumW
#else
#define WNetOpenEnum  WNetOpenEnumA
#endif // !UNICODE

DWORD APIENTRY
WNetEnumResourceA(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
DWORD APIENTRY
WNetEnumResourceW(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
#ifdef UNICODE
#define WNetEnumResource  WNetEnumResourceW
#else
#define WNetEnumResource  WNetEnumResourceA
#endif // !UNICODE

DWORD APIENTRY
WNetCloseEnum(
    HANDLE   hEnum
    );

//
//  Universal Naming.
//

#define UNIVERSAL_NAME_INFO_LEVEL   0x00000001
#define REMOTE_NAME_INFO_LEVEL      0x00000002

typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;
#ifdef UNICODE
typedef UNIVERSAL_NAME_INFOW UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOW LPUNIVERSAL_NAME_INFO;
#else
typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
#endif // UNICODE

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;
#ifdef UNICODE
typedef REMOTE_NAME_INFOW REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOW LPREMOTE_NAME_INFO;
#else
typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
#endif // UNICODE

DWORD APIENTRY
WNetGetUniversalNameA(
     LPCSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
DWORD APIENTRY
WNetGetUniversalNameW(
     LPCWSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
#ifdef UNICODE
#define WNetGetUniversalName  WNetGetUniversalNameW
#else
#define WNetGetUniversalName  WNetGetUniversalNameA
#endif // !UNICODE

//
//  Authentication and Logon/Logoff.
//

DWORD APIENTRY
WNetGetUserA(
     LPCSTR  lpName,
     LPSTR   lpUserName,
     LPDWORD   lpnLength
    );
DWORD APIENTRY
WNetGetUserW(
     LPCWSTR  lpName,
     LPWSTR   lpUserName,
     LPDWORD   lpnLength
    );
#ifdef UNICODE
#define WNetGetUser  WNetGetUserW
#else
#define WNetGetUser  WNetGetUserA
#endif // !UNICODE

//
// Other.
//

#if(WINVER >= 0x0400)
#define WNFMT_MULTILINE         0x01
#define WNFMT_ABBREVIATED       0x02
#define WNFMT_INENUM            0x10
#define WNFMT_CONNECTION        0x20
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0400)
DWORD APIENTRY
WNetGetProviderNameA(
    DWORD   dwNetType,
    LPSTR lpProviderName,
    LPDWORD lpBufferSize
    );
DWORD APIENTRY
WNetGetProviderNameW(
    DWORD   dwNetType,
    LPWSTR lpProviderName,
    LPDWORD lpBufferSize
    );
#ifdef UNICODE
#define WNetGetProviderName  WNetGetProviderNameW
#else
#define WNetGetProviderName  WNetGetProviderNameA
#endif // !UNICODE

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    DWORD dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT, FAR *LPNETINFOSTRUCT;

#define NETINFO_DLL16       0x00000001  /* Provider running as 16 bit Winnet Driver */
#define NETINFO_DISKRED     0x00000004  /* Provider requires disk redirections to connect */
#define NETINFO_PRINTERRED  0x00000008  /* Provider requires printer redirections to connect */

DWORD APIENTRY
WNetGetNetworkInformationA(
    LPCSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
DWORD APIENTRY
WNetGetNetworkInformationW(
    LPCWSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
#ifdef UNICODE
#define WNetGetNetworkInformation  WNetGetNetworkInformationW
#else
#define WNetGetNetworkInformation  WNetGetNetworkInformationA
#endif // !UNICODE

//
//  User Profiles.
//

typedef UINT (FAR PASCAL *PFNGETPROFILEPATHA) (
    LPCSTR    pszUsername,
    LPSTR     pszBuffer,
    UINT        cbBuffer
    );
typedef UINT (FAR PASCAL *PFNGETPROFILEPATHW) (
    LPCWSTR    pszUsername,
    LPWSTR     pszBuffer,
    UINT        cbBuffer
    );
#ifdef UNICODE
#define PFNGETPROFILEPATH  PFNGETPROFILEPATHW
#else
#define PFNGETPROFILEPATH  PFNGETPROFILEPATHA
#endif // !UNICODE

typedef UINT (FAR PASCAL *PFNRECONCILEPROFILEA) (
    LPCSTR    pszCentralFile,
    LPCSTR    pszLocalFile,
    DWORD       dwFlags
    );
typedef UINT (FAR PASCAL *PFNRECONCILEPROFILEW) (
    LPCWSTR    pszCentralFile,
    LPCWSTR    pszLocalFile,
    DWORD       dwFlags
    );
#ifdef UNICODE
#define PFNRECONCILEPROFILE  PFNRECONCILEPROFILEW
#else
#define PFNRECONCILEPROFILE  PFNRECONCILEPROFILEA
#endif // !UNICODE

#define RP_LOGON    0x01        /* if set, do for logon, else for logoff */
#define RP_INIFILE  0x02        /* if set, reconcile .INI file, else reg. hive */

//
//  Policies.
//

typedef BOOL (FAR PASCAL *PFNPROCESSPOLICIESA) (
    HWND        hwnd,
    LPCSTR    pszPath,
    LPCSTR    pszUsername,
    LPCSTR    pszComputerName,
    DWORD       dwFlags
    );
typedef BOOL (FAR PASCAL *PFNPROCESSPOLICIESW) (
    HWND        hwnd,
    LPCWSTR    pszPath,
    LPCWSTR    pszUsername,
    LPCWSTR    pszComputerName,
    DWORD       dwFlags
    );
#ifdef UNICODE
#define PFNPROCESSPOLICIES  PFNPROCESSPOLICIESW
#else
#define PFNPROCESSPOLICIES  PFNPROCESSPOLICIESA
#endif // !UNICODE

#define PP_DISPLAYERRORS    0x01    /* if set, display error messages, else fail silently if error */
#endif /* WINVER >= 0x0400 */

//
//  Error handling.
// 

DWORD APIENTRY
WNetGetLastErrorA(
     LPDWORD    lpError,
     LPSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
DWORD APIENTRY
WNetGetLastErrorW(
     LPDWORD    lpError,
     LPWSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPWSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
#ifdef UNICODE
#define WNetGetLastError  WNetGetLastErrorW
#else
#define WNetGetLastError  WNetGetLastErrorA
#endif // !UNICODE

//
//  STATUS CODES
//

// General   

#define WN_SUCCESS                      NO_ERROR
#define WN_NO_ERROR                     NO_ERROR
#define WN_NOT_SUPPORTED                ERROR_NOT_SUPPORTED
#define WN_CANCEL                       ERROR_CANCELLED
#define WN_RETRY                        ERROR_RETRY
#define WN_NET_ERROR                    ERROR_UNEXP_NET_ERR
#define WN_MORE_DATA                    ERROR_MORE_DATA
#define WN_BAD_POINTER                  ERROR_INVALID_ADDRESS
#define WN_BAD_VALUE                    ERROR_INVALID_PARAMETER
#define WN_BAD_USER                     ERROR_BAD_USERNAME
#define WN_BAD_PASSWORD                 ERROR_INVALID_PASSWORD
#define WN_ACCESS_DENIED                ERROR_ACCESS_DENIED
#define WN_FUNCTION_BUSY                ERROR_BUSY
#define WN_WINDOWS_ERROR                ERROR_UNEXP_NET_ERR
#define WN_OUT_OF_MEMORY                ERROR_NOT_ENOUGH_MEMORY
#define WN_NO_NETWORK                   ERROR_NO_NETWORK
#define WN_EXTENDED_ERROR               ERROR_EXTENDED_ERROR
#define WN_BAD_LEVEL                    ERROR_INVALID_LEVEL
#define WN_BAD_HANDLE                   ERROR_INVALID_HANDLE
#if(WINVER >= 0x0400)
#define WN_NOT_INITIALIZING             ERROR_ALREADY_INITIALIZED
#define WN_NO_MORE_DEVICES              ERROR_NO_MORE_DEVICES
#endif /* WINVER >= 0x0400 */

// Connection

#define WN_NOT_CONNECTED                ERROR_NOT_CONNECTED
#define WN_OPEN_FILES                   ERROR_OPEN_FILES
#define WN_DEVICE_IN_USE                ERROR_DEVICE_IN_USE
#define WN_BAD_NETNAME                  ERROR_BAD_NET_NAME
#define WN_BAD_LOCALNAME                ERROR_BAD_DEVICE
#define WN_ALREADY_CONNECTED            ERROR_ALREADY_ASSIGNED
#define WN_DEVICE_ERROR                 ERROR_GEN_FAILURE
#define WN_CONNECTION_CLOSED            ERROR_CONNECTION_UNAVAIL
#define WN_NO_NET_OR_BAD_PATH           ERROR_NO_NET_OR_BAD_PATH
#define WN_BAD_PROVIDER                 ERROR_BAD_PROVIDER
#define WN_CANNOT_OPEN_PROFILE          ERROR_CANNOT_OPEN_PROFILE
#define WN_BAD_PROFILE                  ERROR_BAD_PROFILE
#define WN_BAD_DEV_TYPE                 ERROR_BAD_DEV_TYPE
#define WN_DEVICE_ALREADY_REMEMBERED    ERROR_DEVICE_ALREADY_REMEMBERED

// Enumeration

#define WN_NO_MORE_ENTRIES              ERROR_NO_MORE_ITEMS
#define WN_NOT_CONTAINER                ERROR_NOT_CONTAINER

#if(WINVER >= 0x0400)
// Authentication

#define WN_NOT_AUTHENTICATED            ERROR_NOT_AUTHENTICATED
#define WN_NOT_LOGGED_ON                ERROR_NOT_LOGGED_ON
#define WN_NOT_VALIDATED                ERROR_NO_LOGON_SERVERS
#endif /* WINVER >= 0x0400 */

//
//  For Shell
//

#if(WINVER >= 0x0400)
typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;

#define WNCON_FORNETCARD        0x00000001
#define WNCON_NOTROUTED         0x00000002
#define WNCON_SLOWLINK          0x00000004
#define WNCON_DYNAMIC           0x00000008

DWORD APIENTRY
MultinetGetConnectionPerformanceA(
        LPNETRESOURCEA lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
DWORD APIENTRY
MultinetGetConnectionPerformanceW(
        LPNETRESOURCEW lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
#ifdef UNICODE
#define MultinetGetConnectionPerformance  MultinetGetConnectionPerformanceW
#else
#define MultinetGetConnectionPerformance  MultinetGetConnectionPerformanceA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

#ifdef __cplusplus
}
#endif

#endif  // _WINNETWK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\mslocusr\superpw.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include <md5.h>

HRESULT VerifySupervisorPassword(LPCSTR pszPassword)
{
#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD
	if (!::fSupervisorKeyInit) {
		HKEY hkeyRating;
		LONG err;

		err = RegOpenKey(HKEY_LOCAL_MACHINE, ::szRATINGS, &hkeyRating);
		if (hkeyRating !=  NULL) {
			DWORD cbData = sizeof(::abSupervisorKey);
			DWORD dwType;
			err = ::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
									&dwType, (LPBYTE)::abSupervisorKey, &cbData);
            if (err != ERROR_SUCCESS)
    			err = ::RegQueryValueEx(hkeyRating, ::szUsersSupervisorKeyName, NULL,
	    								&dwType, (LPBYTE)::abSupervisorKey, &cbData);
			::RegCloseKey(hkeyRating);
			if (err == ERROR_SUCCESS) {
				if (dwType != REG_BINARY || cbData != sizeof(::abSupervisorKey)) {
					return E_UNEXPECTED;
				}
				::fSupervisorKeyInit = TRUE;
			}
		}
		else
			err = ERROR_FILE_NOT_FOUND;

		if (err != ERROR_SUCCESS) {
			return HRESULT_FROM_WIN32(err);
		}
	}

	if (pszPassword == NULL)
		return ResultFromScode(S_FALSE);

	MD5_CTX ctx;

	MD5Init(&ctx);
	MD5Update(&ctx, (const BYTE *)pszPassword, ::strlenf(pszPassword)+1);
	MD5Final(&ctx);

	return ResultFromScode(::memcmpf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey)) ? S_FALSE : S_OK);

#else

    return S_OK;        /* everybody's a supervisor */

#endif
}


HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
{
#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD
	HRESULT hres;

	hres = ::VerifySupervisorPassword(pszOldPassword);
	if (hres == S_FALSE) {
		return E_ACCESSDENIED;
	}

	MD5_CTX ctx;

	MD5Init(&ctx);
	MD5Update(&ctx, (const BYTE *)pszNewPassword, ::strlenf(pszNewPassword)+1);
	MD5Final(&ctx);

	::memcpyf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey));
	::fSupervisorKeyInit = TRUE;

	HKEY hkeyRating;

	LONG err = RegOpenKey(HKEY_LOCAL_MACHINE, ::szRATINGS, &hkeyRating);
	if (err == ERROR_SUCCESS) {
        char abTemp[sizeof(::abSupervisorKey)];
        LPCSTR pszValueToSet;
        DWORD dwType;
        DWORD cbData = sizeof(abTemp);
        if (::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
							  &dwType, (LPBYTE)abTemp, &cbData) == ERROR_SUCCESS)
            pszValueToSet = ::szRatingsSupervisorKeyName;
        else
            pszValueToSet = ::szUsersSupervisorKeyName;

		::RegSetValueEx(hkeyRating, pszValueToSet, NULL,
						REG_BINARY, (const BYTE *)::abSupervisorKey, sizeof(::abSupervisorKey));
		::RegCloseKey(hkeyRating);
	}
#endif

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_
EXTERN_C PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst);

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\advdlg.h ===
/****************************************************************************\
 *
 *   advdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Advanced Property Page
 *
\****************************************************************************/

#ifndef ADVANCED_DIALOG_H
#define ADVANCED_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

class CAdvancedDialog : public CBasePropertyPage<IDD_ADVANCED>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CAdvancedDialog( PRSD * p_pPRSD );

public:
    typedef CAdvancedDialog thisClass;
    typedef CBasePropertyPage<IDD_ADVANCED> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_USER, OnUser)

        COMMAND_HANDLER(IDC_3RD_COMBO, CBN_EDITCHANGE, OnMarkChanged)
        COMMAND_HANDLER(IDC_3RD_COMBO, CBN_SELENDOK, OnMarkChanged)
        COMMAND_HANDLER(IDC_PICSRULES_LIST, LBN_SELCHANGE, OnSelChange)

        COMMAND_ID_HANDLER(IDC_PICSRULES_UP, OnPicsRulesUp)
        COMMAND_ID_HANDLER(IDC_PICSRULES_DOWN, OnPicsRulesDown)
        COMMAND_ID_HANDLER(IDC_PICSRULESEDIT, OnPicsRulesEdit)
        COMMAND_ID_HANDLER(IDC_PICSRULESOPEN, OnPicsRulesOpen)

        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnSetActive)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPicsRulesUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    InstallRatingBureauHelper( void );
    void    DeinstallRatingBureauHelper( void );
    UINT    FillBureauList( PicsRatingSystemInfo *pPRSI );

    HRESULT CopySubPolicyExpression(PICSRulesPolicyExpression * pPRSubPolicyExpression,
                                PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy,
                                PICSRulesRatingSystem * pPRRSLocal,
                                PICSRulesPolicy * pPRPolicy);
    HRESULT CopyArrayPRRSStructures(array<PICSRulesRatingSystem*> * parrpPRRSDest,
                                array<PICSRulesRatingSystem*> * parrpPRRSSource);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\apprdlg.cpp ===
/****************************************************************************\
 *
 *   apprdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Approved Sites Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "apprdlg.h"        // CApprovedSitesDialog
#include "debug.h"          // TraceMsg()
#include "parselbl.h"
#include "picsrule.h"
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()
#include <wininet.h>
#include <comctrlp.h>


// $BUG - These should not be global variables but within CApprovedSitesDialog
int                                     g_iAllowAlways,g_iAllowNever;

// $KLUDGE begins -- These should not be a global set outside the class!!
extern PICSRulesRatingSystem * g_pApprovedPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRSPreApply;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

extern HMODULE                          g_hURLMON,g_hWININET;
// $KLUDGE ends -- These should not be a global set outside the class!!

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

// useful macro for getting rid of leaks.
#define SAFEDELETE(ptr)             \
            if(ptr)                 \
            {                       \
                delete ptr;         \
                ptr = NULL;         \
            }                       

DWORD CApprovedSitesDialog::aIds[] = {
    IDC_STATIC1,                    IDH_IGNORE,
    IDC_STATIC2,                    IDH_IGNORE,
    IDC_STATIC_ALLOW,               IDH_PICSRULES_APPROVEDEDIT,
    IDC_PICSRULESAPPROVEDEDIT,      IDH_PICSRULES_APPROVEDEDIT,
    IDC_PICSRULESAPPROVEDALWAYS,    IDH_PICSRULES_APPROVEDALWAYS,
    IDC_PICSRULESAPPROVEDNEVER,     IDH_PICSRULES_APPROVEDNEVER,
    IDC_STATIC_LIST,                IDH_PICSRULES_APPROVEDLIST,
    IDC_PICSRULESAPPROVEDLIST,      IDH_PICSRULES_APPROVEDLIST,
    IDC_PICSRULESAPPROVEDREMOVE,    IDH_PICSRULES_APPROVEDREMOVE,
    0,0
};

CApprovedSitesDialog::CApprovedSitesDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

void CApprovedSitesDialog::SetListImages( HIMAGELIST hImageList )
{
    HIMAGELIST hOldImageList;

    hOldImageList = ListView_SetImageList( GetDlgItem(IDC_PICSRULESAPPROVEDLIST), hImageList, LVSIL_SMALL );

    if ( hOldImageList != NULL )
    {
        ImageList_Destroy( hOldImageList );
    }
}

LRESULT CApprovedSitesDialog::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HICON      hIcon;
    HIMAGELIST  hImageList;
    UINT flags = 0;
    HWND hDlg = m_hWnd;

    ListView_SetBkColor(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                        GetSysColor(COLOR_WINDOW));
    if(IS_WINDOW_RTL_MIRRORED(hDlg))
    {
        flags |= ILC_MIRROR;
    }

    hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                  GetSystemMetrics(SM_CYSMICON),
                                  flags,
                                  2,
                                  0);

    if (hImageList)
    {
        hIcon=(HICON) LoadImage(g_hInstance,
                                MAKEINTRESOURCE(IDI_ACCEPTALWAYS),
                                IMAGE_ICON,
                                16,
                                16,
                                LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

        if (hIcon)
        {
            g_iAllowAlways=ImageList_AddIcon( hImageList, hIcon ); 
            DestroyIcon(hIcon); 
        }

        hIcon=(HICON) LoadImage(g_hInstance,
                                MAKEINTRESOURCE(IDI_ACCEPTNEVER),
                                IMAGE_ICON,
                                16,
                                16,
                                LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
        if (hIcon)
        {
            g_iAllowNever=ImageList_AddIcon( hImageList, hIcon );
            DestroyIcon(hIcon); 
        }

        SetListImages( hImageList );
    }

    return 0L;
}

LRESULT CApprovedSitesDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RECT        Rect;
    HDC         hDC;
    LV_COLUMN   lvColumn;
    TEXTMETRIC  tm;
    HICON       hIcon;
    HIMAGELIST  hImageList;
    int         iCounter;
    UINT flags = 0;
    HWND hDlg = m_hWnd;

//  if (m_pPRSD && m_pPRSD->pPU != NULL) {
        //set defaults for controls
//  }

    ::GetWindowRect(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),&Rect);

    tm.tmAveCharWidth=0;
    if(hDC=GetDC())
    {
        GetTextMetrics(hDC,&tm);
        ReleaseDC(hDC);
    }

    lvColumn.mask=LVCF_FMT|LVCF_WIDTH;
    lvColumn.fmt=LVCFMT_LEFT;
    lvColumn.cx=Rect.right-Rect.left
                -GetSystemMetrics(SM_CXVSCROLL)
                -GetSystemMetrics(SM_CXSMICON)
                -tm.tmAveCharWidth;

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                       LVM_INSERTCOLUMN,
                       (WPARAM) 0,
                       (LPARAM) &lvColumn);

    if(IS_WINDOW_RTL_MIRRORED(hDlg))
    {
        flags |= ILC_MIRROR;
    }

    hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                  GetSystemMetrics(SM_CYSMICON),
                                  flags,
                                  2,
                                  0);

    if (hImageList)
    {
        hIcon=(HICON) LoadImage(g_hInstance,
                                MAKEINTRESOURCE(IDI_ACCEPTALWAYS),
                                IMAGE_ICON,
                                16,
                                16,
                                LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

        g_iAllowAlways = ImageList_AddIcon( hImageList, hIcon );
        DestroyIcon(hIcon); 

        hIcon=(HICON) LoadImage(g_hInstance,
                                MAKEINTRESOURCE(IDI_ACCEPTNEVER),
                                IMAGE_ICON,
                                16,
                                16,
                                LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
        if (hIcon)
        {
            g_iAllowNever = ImageList_AddIcon( hImageList, hIcon );
            DestroyIcon(hIcon); 
        }

        SetListImages( hImageList );
    }

    //disable the remove button until someone selects something
    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDREMOVE),FALSE);
    
    //disable the always and never buttons until someone types something
    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDNEVER),FALSE);
    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDALWAYS),FALSE);

    if(g_pApprovedPRRSPreApply!=NULL)
    {
        delete g_pApprovedPRRSPreApply;

        g_pApprovedPRRSPreApply=NULL;
    }

    if(g_lApprovedSitesGlobalCounterValue!=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter))
    {
        PICSRulesRatingSystem * pPRRS=NULL;
        HRESULT               hRes;

        hRes=PICSRulesReadFromRegistry(PICSRULES_APPROVEDSITES,&pPRRS);

        if(SUCCEEDED(hRes))
        {
            if(g_pApprovedPRRS!=NULL)
            {
                delete g_pApprovedPRRS;
            }

            g_pApprovedPRRS=pPRRS;
        }

        g_lApprovedSitesGlobalCounterValue=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter);
    }

    if(g_pApprovedPRRS==NULL)
    {
        //nothing to do
        return 1L;
    }

    //copy master list to the PreApply list
    if(g_pApprovedPRRSPreApply!=NULL)
    {
        delete g_pApprovedPRRSPreApply;
    }

    g_pApprovedPRRSPreApply=new PICSRulesRatingSystem;

    if (g_pApprovedPRRSPreApply==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return 1L;
    }

    for(iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
    {
        PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
        PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
        PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

        pPRPolicy=new PICSRulesPolicy;
        
        if(pPRPolicy==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return 1L;
        }

        pPRPolicyToCopy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];
        
        pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

        pPRByURL=new PICSRulesByURL;
        
        if(pPRByURL==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return 1L;
        }

        if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            
            pPRPolicy->m_pPRAcceptByURL=pPRByURL;
        }
        else
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;

            pPRPolicy->m_pPRRejectByURL=pPRByURL;
        }

        pPRByURLExpression=new PICSRulesByURLExpression;

        if(pPRByURLExpression==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return 1L;
        }

        pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

        if(pPRByURLExpressionToCopy==NULL)
        {
            //we shouldn't ever get here

            MyMessageBox(m_hWnd, IDS_PICSRULES_NOAPPROVEDSAVE, IDS_ERROR, MB_OK|MB_ICONERROR);

            delete pPRPolicy;
            pPRPolicy = NULL;

            return 1L;
        }

        pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
        pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
        pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
        pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
        pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
        pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
        pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
        pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

        
        pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

        g_pApprovedPRRSPreApply->m_arrpPRPolicy.Append(pPRPolicy);
    }

    //fill in the listview with known items
    for(iCounter=0;iCounter<g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();iCounter++)
    {
        BOOL                        fAcceptReject;
        PICSRulesPolicy             * pPRPolicy;
        PICSRulesByURLExpression    * pPRByURLExpression;
        LV_ITEM                     lvItem;

        pPRPolicy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter];

        if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            fAcceptReject=PICSRULES_ALWAYS;

            pPRByURLExpression=pPRPolicy->m_pPRAcceptByURL->m_arrpPRByURL[0];
        }
        else
        {
            fAcceptReject=PICSRULES_NEVER;

            pPRByURLExpression=pPRPolicy->m_pPRRejectByURL->m_arrpPRByURL[0];
        }

        ZeroMemory(&lvItem,sizeof(lvItem));

        lvItem.mask=LVIF_TEXT|LVIF_IMAGE;
        lvItem.pszText=pPRByURLExpression->m_etstrURL.Get();

        if(fAcceptReject==PICSRULES_NEVER)
        {
            lvItem.iImage=g_iAllowNever;
        }
        else
        {
            lvItem.iImage=g_iAllowAlways;
        }

        if(SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                              LVM_INSERTITEM,
                              (WPARAM) 0,
                              (LPARAM) &lvItem)==-1)
        {
            return 1L;
        }

    }

    // Set the column width to satisfy longest element
    ListView_SetColumnWidth(
                    GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                    0,
                    LVSCW_AUTOSIZE);

    // set focus to first item in list
    ListView_SetItemState(
                    GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                    0,
                    LVIS_FOCUSED,
                    LVIS_FOCUSED);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CApprovedSitesDialog::OnPicsRulesEditUpdate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    INT_PTR iCount;

    iCount=SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                              WM_GETTEXTLENGTH,
                              (WPARAM) 0,
                              (LPARAM) 0);

    if(iCount>0)
    {
        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDNEVER),TRUE);
        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDALWAYS),TRUE);
    }
    else
    {
        ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                           EM_SETSEL,
                           (WPARAM) 0,
                           (LPARAM) -1);

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDNEVER,
                           BM_SETSTYLE,
                           (WPARAM) BS_PUSHBUTTON,
                           (LPARAM) MAKELPARAM(TRUE,0));

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDALWAYS,
                           BM_SETSTYLE,
                           (WPARAM) BS_PUSHBUTTON,
                           (LPARAM) MAKELPARAM(TRUE,0));

        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDNEVER),FALSE);
        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDALWAYS),FALSE);
    }

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesApprovedNever(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hRes;

    hRes=PICSRulesApprovedSites(PICSRULES_NEVER);

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesApprovedAlways(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hRes;

    hRes=PICSRulesApprovedSites(PICSRULES_ALWAYS);

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesApprovedRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                     iNumApproved,iCounter,iNumSelected,
                            iSubCounter,iItem=-1;
    LPTSTR                  lpszRemoveURL;
    LV_ITEM                 lvItem;
    PICSRulesRatingSystem   * pNewApprovedPRRS;

    if(g_pApprovedPRRSPreApply==NULL)
    {
        //nothing to do
        return 1L;
    }

    iNumApproved=g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();

    iNumSelected=ListView_GetSelectedCount(GetDlgItem(IDC_PICSRULESAPPROVEDLIST));

    if(iNumSelected==0)
    {
        //nothing to do
        return 1L;
    }

    lpszRemoveURL=new char[INTERNET_MAX_URL_LENGTH+1];

    if(lpszRemoveURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    for(iCounter=0;iCounter<iNumSelected;iCounter++)
    {
        ZeroMemory(&lvItem,sizeof(lvItem));

        iItem=ListView_GetNextItem(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),iItem,LVNI_SELECTED);
        
        lvItem.iItem=iItem;
        lvItem.pszText=lpszRemoveURL;
        lvItem.cchTextMax=INTERNET_MAX_URL_LENGTH;

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,LVM_GETITEMTEXT,(WPARAM) iItem,(LPARAM) &lvItem);

        for(iSubCounter=0;iSubCounter<iNumApproved;iSubCounter++)
        {
            PICSRulesPolicy *pPRPolicy;
            PICSRulesByURLExpression * pPRByURLExpression;

            pPRPolicy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iSubCounter];

            if(pPRPolicy==NULL)
            {
                continue;
            }

            if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_REJECTBYURL)
            {
                if(pPRPolicy->m_pPRRejectByURL==NULL)
                {
                    continue;
                }

                pPRByURLExpression=pPRPolicy->m_pPRRejectByURL->m_arrpPRByURL[0];
            }
            else
            {
                if(pPRPolicy->m_pPRAcceptByURL==NULL)
                {
                    continue;
                }

                pPRByURLExpression=pPRPolicy->m_pPRAcceptByURL->m_arrpPRByURL[0];
            }

            if(pPRByURLExpression==NULL)
            {
                continue;
            }
            
            if(pPRByURLExpression->m_etstrURL.Get()==NULL)
            {
                continue;
            }

            if(lstrcmp(pPRByURLExpression->m_etstrURL.Get(),lpszRemoveURL)==0)
            {
                //we found one to delete
                if(pPRPolicy!=NULL)
                {
                    delete pPRPolicy;
                    pPRPolicy = NULL;
                }

                g_pApprovedPRRSPreApply->m_arrpPRPolicy[iSubCounter]=0;
            }
        }
    }

    //delete them from the list view
    for(iCounter=0;iCounter<iNumSelected;iCounter++)
    {
        iItem=ListView_GetNextItem(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),-1,LVNI_SELECTED);
    
        ListView_DeleteItem(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),iItem);
    }

    //rebuild the approved PICSRules structure
    pNewApprovedPRRS=new PICSRulesRatingSystem;
    
    for(iCounter=0;iCounter<iNumApproved;iCounter++)
    {
        if(g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter]!=NULL)
        {
            pNewApprovedPRRS->m_arrpPRPolicy.Append(g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter]);
        }
    }

    g_pApprovedPRRSPreApply->m_arrpPRPolicy.ClearAll();

    delete g_pApprovedPRRSPreApply;

    g_pApprovedPRRSPreApply=pNewApprovedPRRS;

    MarkChanged();

    ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       EM_SETSEL,
                       (WPARAM) 0,
                       (LPARAM) -1);

    delete lpszRemoveURL;
    lpszRemoveURL = NULL;

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesListChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
//  NMLISTVIEW *pNMListView=(NMLISTVIEW *)pnmh;

    BOOL    fEnable = FALSE;

    if(ListView_GetSelectedCount(GetDlgItem(IDC_PICSRULESAPPROVEDLIST)) > 0)
    {
        fEnable = TRUE;
    }

    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDREMOVE),fEnable);

    return 0L;
}

LRESULT CApprovedSitesDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    PRSD *      pPRSD = m_pPRSD;
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    int iCounter,iLoopCounter;

    if(g_pApprovedPRRSPreApply==NULL)
    {
        //we don't have anything to set
        return PSNRET_NOERROR;
    }

    //make the Approved Sites Global
    if(g_pApprovedPRRS!=NULL)
    {
        delete g_pApprovedPRRS;
    }

    g_pApprovedPRRS=new PICSRulesRatingSystem;

    if(g_pApprovedPRRS==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    for(iLoopCounter=0;iLoopCounter<2;iLoopCounter++)
    {
        for(iCounter=0;iCounter<g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
            PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
            PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

            pPRPolicyToCopy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter];

            if(pPRPolicyToCopy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            }
            else
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;
            }

            pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

            if (!pPRByURLExpressionToCopy)
            {
                //we shouldn't ever get here

                MyMessageBox(m_hWnd, IDS_PICSRULES_NOAPPROVEDSAVE, IDS_ERROR, MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            //we want to put all of the non-sitewide approved sites first
            //so that a user can specify, allow all of xyz.com except for
            //xyz.com/foo.htm
            switch(iLoopCounter)
            {
                case 0:
                {
                    if((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH)
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
                case 1:
                {
                    if(!((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH))
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            pPRPolicy=new PICSRulesPolicy;
    
            if(pPRPolicy==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }
   
            pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

            pPRByURL=new PICSRulesByURL;
    
            if(pPRByURL==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {                       
                pPRPolicy->m_pPRAcceptByURL=pPRByURL;
            }
            else
            {
                pPRPolicy->m_pPRRejectByURL=pPRByURL;
            }

            pPRByURLExpression=new PICSRulesByURLExpression;

            if(pPRByURLExpression==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
            pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
            pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
            pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
            pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
            pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
            pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
            pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
            pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

    
            pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

            g_pApprovedPRRS->m_arrpPRPolicy.Append(pPRPolicy);
        }           
    }

    PICSRulesDeleteSystem(PICSRULES_APPROVEDSITES);
    PICSRulesSaveToRegistry(PICSRULES_APPROVEDSITES,&g_pApprovedPRRS);

    SHGlobalCounterIncrement(g_ApprovedSitesHandleGlobalCounter);

    if ( ! lpPSHNotify->lParam )
    {
        // Apply 
        return PSNRET_NOERROR;
    }

    // Do this if hit OK or Cancel, not Apply
    OnReset( idCtrl, pnmh, bHandled );

    return PSNRET_NOERROR;
}

LRESULT CApprovedSitesDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    // Do this if hit OK or Cancel, not Apply
    SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0L );
    SetListImages( NULL );
    SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0L );

    return 0L;
}

LRESULT CApprovedSitesDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CApprovedSitesDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

//
// ShowBadUrl
//
// Show some ui telling user URL is bad when adding an approved site
//
void CApprovedSitesDialog::ShowBadUrl( void )
{
    MyMessageBox(m_hWnd, IDS_PICSRULES_BADURLMSG, IDS_PICSRULES_BADURLTITLE, MB_OK|MB_ICONERROR);

    // set focus back to edit box and select all of it
    ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));
    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                    EM_SETSEL,
                    (WPARAM) 0,
                    (LPARAM) -1);
}

//Processes adding sites to the Approved Sites list.
//note, users will type in URLs _NOT_ in the form required
//in the PICSRules spec.  Thus, we will use InternetCrackURL
//and fill in the appropriate fields for them.
HRESULT CApprovedSitesDialog::PICSRulesApprovedSites(BOOL fAlwaysNever)
{
    PICSRulesPolicy             * pPRPolicy;
    PICSRulesByURL              * pPRByURL;
    PICSRulesByURLExpression    * pPRByURLExpression = NULL;
    LPSTR                       lpszSiteURL;
    HRESULT                     hr = NOERROR;
    URL_COMPONENTS              URLComponents;
    FN_INTERNETCRACKURL         pfnInternetCrackUrl;
    INTERNET_SCHEME             INetScheme=INTERNET_SCHEME_DEFAULT;
    INTERNET_PORT               INetPort=INTERNET_INVALID_PORT_NUMBER;
    LPSTR                       lpszScheme = NULL;
    LPSTR                       lpszHostName = NULL;
    LPSTR                       lpszUserName = NULL;
    LPSTR                       lpszPassword = NULL;
    LPSTR                       lpszUrlPath = NULL;
    LPSTR                       lpszExtraInfo = NULL;
    BOOL                        fAddedScheme=FALSE;
    LV_ITEM                     lvItem;
    LV_FINDINFO                 lvFindInfo;

    lpszSiteURL=new char[INTERNET_MAX_URL_LENGTH+1];
    if(lpszSiteURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    //have we already processed it?
    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       WM_GETTEXT,
                       (WPARAM) INTERNET_MAX_URL_LENGTH,
                       (LPARAM) lpszSiteURL);

    if(*lpszSiteURL=='\0')
    {
        //nothing to do
        delete lpszSiteURL;
        lpszSiteURL = NULL;

        return(E_INVALIDARG);
    }

    ZeroMemory(&lvFindInfo,sizeof(lvFindInfo));

    lvFindInfo.flags=LVFI_STRING;
    lvFindInfo.psz=lpszSiteURL;

    if(SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                          LVM_FINDITEM,
                          (WPARAM) -1,
                          (LPARAM) &lvFindInfo)!=-1)
    {
        //we already have settings for this URL
        MyMessageBox(m_hWnd, IDS_PICSRULES_DUPLICATEMSG, IDS_PICSRULES_DUPLICATETITLE, MB_OK|MB_ICONERROR);

        delete lpszSiteURL;
        lpszSiteURL = NULL;

        ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                           EM_SETSEL,
                           (WPARAM) 0,
                           (LPARAM) -1);

        return(E_INVALIDARG);
    }


    //
    // Add a scheme if user didn't type one
    //
    LPSTR lpszTemp = new char[INTERNET_MAX_URL_LENGTH+1];
    DWORD cbBuffer = INTERNET_MAX_URL_LENGTH;
    hr = UrlApplySchemeA(lpszSiteURL, lpszTemp, &cbBuffer, 0);
    if(S_OK == hr)
    {
        // actually added a scheme - switch to new buffer
        delete lpszSiteURL;
        lpszSiteURL = lpszTemp;
        fAddedScheme = TRUE;
    }
    else
    {
        // delete temp buffer
        delete lpszTemp;
        lpszTemp = NULL;
    }


    //
    // Allocate all the pics rules structures we need
    //
    if(g_pApprovedPRRSPreApply==NULL)
    {
        g_pApprovedPRRSPreApply=new PICSRulesRatingSystem;
        if(g_pApprovedPRRSPreApply==NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    pPRPolicy=new PICSRulesPolicy;
    if(pPRPolicy==NULL)
    {
        return(E_OUTOFMEMORY);
    }
    pPRByURL=new PICSRulesByURL;
    if(pPRByURL==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto clean;
    }
    pPRByURLExpression=new PICSRulesByURLExpression;
    if(pPRByURLExpression==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto clean;
    }

    //
    // Crack the URL
    //
    lpszScheme=new char[INTERNET_MAX_SCHEME_LENGTH+1];
    lpszHostName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUserName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszPassword=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUrlPath=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszExtraInfo=new char[INTERNET_MAX_PATH_LENGTH+1];

    if(lpszScheme==NULL ||
       lpszHostName==NULL ||
       lpszUserName==NULL ||
       lpszPassword==NULL ||
       lpszUrlPath==NULL ||
       lpszExtraInfo==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto clean;
    }

    URLComponents.dwStructSize=sizeof(URL_COMPONENTS);
    URLComponents.lpszScheme=lpszScheme;
    URLComponents.dwSchemeLength=INTERNET_MAX_SCHEME_LENGTH;
    URLComponents.nScheme=INetScheme;
    URLComponents.lpszHostName=lpszHostName;
    URLComponents.dwHostNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.nPort=INetPort;
    URLComponents.lpszUserName=lpszUserName;
    URLComponents.dwUserNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszPassword=lpszPassword;
    URLComponents.dwPasswordLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszUrlPath=lpszUrlPath;
    URLComponents.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszExtraInfo=lpszExtraInfo;
    URLComponents.dwExtraInfoLength=INTERNET_MAX_PATH_LENGTH;

    pfnInternetCrackUrl=(FN_INTERNETCRACKURL) GetProcAddress(g_hWININET,"InternetCrackUrlA");

    if(pfnInternetCrackUrl==NULL)
    {
        hr = E_UNEXPECTED;
        goto clean;
    }

    if(FALSE == pfnInternetCrackUrl(lpszSiteURL,0,ICU_DECODE,&URLComponents))
    {
        // failed to crack url
        ShowBadUrl();
        hr = E_INVALIDARG;
        goto clean;
    }


    //
    // Set up linkages of pics rules structures
    //
    hr=g_pApprovedPRRSPreApply->AddItem(PROID_POLICY,pPRPolicy);
    if(FAILED(hr))
    {
        goto clean;
    }

    if(fAlwaysNever==PICSRULES_NEVER)
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_REJECTBYURL;
        pPRPolicy->AddItem(PROID_REJECTBYURL,pPRByURL);
    }
    else
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_ACCEPTBYURL;
        pPRPolicy->AddItem(PROID_ACCEPTBYURL,pPRByURL);
    }

    pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);


    //
    // Use cracked URL components to fill in pics structs
    //
    pPRByURLExpression->m_fInternetPattern=TRUE;

    if((*lpszScheme!=NULL)&&(fAddedScheme==FALSE))
    {
        pPRByURLExpression->m_bNonWild|=BYURL_SCHEME;
        pPRByURLExpression->m_etstrScheme.SetTo(lpszScheme);   
    }
    else
    {
        delete lpszScheme;
        lpszScheme = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;

    if(*lpszUserName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_USER;           
        pPRByURLExpression->m_etstrUser.SetTo(lpszUserName);
    }
    else
    {
        delete lpszUserName;
        lpszUserName = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_USER;

    if(*lpszHostName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_HOST;           
        pPRByURLExpression->m_etstrHost.SetTo(lpszHostName);
    }
    else
    {
        delete lpszHostName;
        lpszHostName = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_HOST;

    if(*lpszUrlPath!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_PATH;           
        pPRByURLExpression->m_etstrPath.SetTo(lpszUrlPath);
    }
    else
    {
        delete lpszUrlPath;
        lpszUrlPath = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_PATH;

    if(URLComponents.nPort!=INTERNET_INVALID_PORT_NUMBER)
    {
        LPSTR lpszTemp;

        lpszTemp=new char[sizeof("65536")];

        wsprintf(lpszTemp,"%d",URLComponents.nPort);

        pPRByURLExpression->m_bNonWild|=BYURL_PORT;           
        pPRByURLExpression->m_etstrPort.SetTo(lpszTemp);
    }
    pPRByURLExpression->m_bSpecified|=BYURL_PORT;

    //
    // need to make sure we echo exactly what they typed in
    //

    // just UI stuff left so assume success - we don't want to delete pics
    // structs now that they're linked into other pics structs
    hr = NOERROR;

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       WM_GETTEXT,
                       (WPARAM) INTERNET_MAX_URL_LENGTH,
                       (LPARAM) lpszSiteURL);

    ZeroMemory(&lvItem,sizeof(lvItem));

    lvItem.mask=LVIF_TEXT|LVIF_IMAGE;
    lvItem.pszText=lpszSiteURL;

    if(fAlwaysNever==PICSRULES_NEVER)
    {
        lvItem.iImage=g_iAllowNever;
    }
    else
    {
        lvItem.iImage=g_iAllowAlways;
    }

    if(SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                          LVM_INSERTITEM,
                          (WPARAM) 0,
                          (LPARAM) &lvItem)==-1)
    {
        goto clean;
    }

    ListView_SetColumnWidth(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                            0,
                            LVSCW_AUTOSIZE);

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       WM_SETTEXT,
                       (WPARAM) 0,
                       (LPARAM) 0);

    MarkChanged();

    pPRByURLExpression->m_etstrURL.SetTo(lpszSiteURL);

clean:
    SAFEDELETE(lpszPassword);
    SAFEDELETE(lpszExtraInfo);

    if(FAILED(hr))
    {
        // failed means we didn't get chance to save or delete these
        SAFEDELETE(lpszScheme);
        SAFEDELETE(lpszHostName);
        SAFEDELETE(lpszUserName);
        SAFEDELETE(lpszUrlPath);

        // a failed hr means we didn't link these guys together so they need
        // to be deleted
        SAFEDELETE(lpszSiteURL);
        SAFEDELETE(pPRPolicy);
        SAFEDELETE(pPRByURL);
        SAFEDELETE(pPRByURLExpression);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\apprdlg.h ===
/****************************************************************************\
 *
 *   apprdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Approved Sites Property Page
 *
\****************************************************************************/

#ifndef APPROVED_SITES_DIALOG_H
#define APPROVED_SITES_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

class CApprovedSitesDialog : public CBasePropertyPage<IDD_APPROVEDSITES>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CApprovedSitesDialog( PRSD * p_pPRSD );

public:
    typedef CApprovedSitesDialog thisClass;
    typedef CBasePropertyPage<IDD_APPROVEDSITES> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_HANDLER(IDC_PICSRULESAPPROVEDEDIT, EN_UPDATE, OnPicsRulesEditUpdate)

        COMMAND_ID_HANDLER(IDC_PICSRULESAPPROVEDNEVER, OnPicsRulesApprovedNever)
        COMMAND_ID_HANDLER(IDC_PICSRULESAPPROVEDALWAYS, OnPicsRulesApprovedAlways)
        COMMAND_ID_HANDLER(IDC_PICSRULESAPPROVEDREMOVE, OnPicsRulesApprovedRemove)

        NOTIFY_HANDLER(IDC_PICSRULESAPPROVEDLIST, LVN_ITEMCHANGED, OnPicsRulesListChanged)

        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    void    SetListImages( HIMAGELIST hImageList );
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPicsRulesEditUpdate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesApprovedNever(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesApprovedAlways(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesApprovedRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPicsRulesListChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    ShowBadUrl( void );
    HRESULT PICSRulesApprovedSites( BOOL fAlwaysNever );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\array.h ===
/****************************************************************************\
 *
 *   ARRAY.H ---Class declaration for the array structure
 *     
\****************************************************************************/

#ifndef _ARRAY_H
#define _ARRAY_H

/*Interface-------------------------------------------------------------------*/
template <class T>
class array {
    private:
        int nLen, nMax;
        T   *pData;
        void Destruct();
    public:
        array();
        ~array();

        BOOL Append(T v);
        int  Length() const;
        void ClearAll();
        void DeleteAll();

        T& operator[](int index);
};

/*definitions of everything*/

#ifndef ARRAY_CXX
#define ARRAY_CXX

/*Implementation------------------------------------------------------------*/
template <class T>
array<T>::array(){
    nLen  = nMax = 0;
    pData = NULL;
}

template <class T>
inline array<T>::~array() {
    if (pData) ::MemFree(pData);
    pData = NULL;
    nMax  = nLen = 0;
}

template <class T>
inline int array<T>::Length() const{
    return nLen;
}

template <class T>
inline T& array<T>::operator[](int index){
    ASSERT(index<Length());
    ASSERT(index>=0);
    ASSERT(pData);
    return pData[index];
}

template <class T>
BOOL array<T>::Append(T v) {
    if (nLen == nMax){
        nMax  = nMax + 8;            /* grow by bigger chunks */
        T* pNew = (T*)::MemReAlloc(pData, sizeof(T)*nMax);
        if (pNew == NULL)
            return FALSE;
        pData = pNew;
    }
    ASSERT(pData);
    ASSERT(nMax);
    pData[nLen++] = v;
    return TRUE;
}

template <class T>
void array<T>::Destruct(){
    while (nLen){
        delete pData[--nLen];
    }
}

template <class T>
inline void array<T>::ClearAll() {
    nLen = 0;
}

template <class T>
inline void array<T>::DeleteAll() {
    Destruct();
}

#endif 
/* ARRAY_CXX */


#endif 
/* _ARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\basedlg.h ===
/****************************************************************************\
 *
 *   basedlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Base Property Page
 *
\****************************************************************************/

#ifndef BASE_DIALOG_H
#define BASE_DIALOG_H

#include "apithk.h"

class CCommonDialogRoutines
{
public:
    void ShowHideWindow( HWND hwndDlg, int iCtrl, BOOL fEnable )
    {
        HWND            hCtrl = ::GetDlgItem( hwndDlg, iCtrl );

        ASSERT( hCtrl );

        if ( hCtrl )
        {
            ::EnableWindow( hCtrl, fEnable );
            ::ShowWindow( hCtrl, fEnable ? SW_SHOW : SW_HIDE );
        }
    }

    void SetErrorFocus( HWND hwndDlg, int iCtrl )
    {
        HWND            hCtrl = ::GetDlgItem( hwndDlg, iCtrl );

        ASSERT( hCtrl );

        if ( hCtrl )
        {
            ::SetFocus( hCtrl );
            ::SendMessage( hCtrl, EM_SETSEL, 0, -1 );
        }
    }
};

template <WORD t_wDlgTemplateID>
class CBasePropertyPage : public CPropertyPage<t_wDlgTemplateID>
{
private:
    PROPSHEETPAGE   * m_ppsPage;

public:
    typedef CBasePropertyPage<t_wDlgTemplateID> thisClass;
    typedef CPropertyPage<t_wDlgTemplateID> baseClass;

    BEGIN_MSG_MAP(thisClass)
        CHAIN_MSG_MAP_ALT(baseClass, 0)
    END_MSG_MAP()

    CBasePropertyPage(_U_STRINGorID title = (LPCTSTR)NULL) : CPropertyPage<t_wDlgTemplateID>(title)
    {
        m_ppsPage = NULL;
    }

    ~CBasePropertyPage()
    {
        if ( m_ppsPage )
        {
            LocalFree( m_ppsPage );
            m_ppsPage = NULL;
        }
    }

    operator PROPSHEETPAGE*() { return m_ppsPage; }

    // Override to insure Luna works!
    HPROPSHEETPAGE Create()
    {
        HINSTANCE           hinst = _Module.GetResourceInstance();

        ASSERT( hinst );

        ASSERT( ! m_ppsPage );

        m_ppsPage = Whistler_CreatePropSheetPageStruct( hinst );

        if ( ! m_ppsPage )
        {
            TraceMsg( TF_ERROR, "CBasePropertyPage::Create() - m_ppsPage could not be created!" );
            return 0;
        }

        m_ppsPage->dwFlags = PSP_USECALLBACK;
        m_ppsPage->hInstance = hinst;
        baseClass * pT = static_cast<baseClass *>(this);
        pT;	// avoid level 4 warning
        m_ppsPage->pszTemplate = MAKEINTRESOURCE(pT->IDD);
        m_ppsPage->pfnDlgProc = baseClass::StartDialogProc;
        m_ppsPage->pfnCallback = baseClass::PropPageCallback;
        m_ppsPage->lParam = (LPARAM)this;

        return ::CreatePropertySheetPage( m_ppsPage );
    }

protected:
    void MarkChanged()
    {
        SendMessage( GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, 0 );
    }

    void ShowHideControl( int iCtrl, BOOL fEnable )
    {
        CCommonDialogRoutines       cdr;

        cdr.ShowHideWindow( m_hWnd, iCtrl, fEnable );
    }
};

template <class TDerived>
class CBaseDialog : public CDialogImpl<TDerived>
{
public:
    typedef CBaseDialog<TDerived> thisClass;
    typedef CDialogImpl<TDerived> baseClass;

    BEGIN_MSG_MAP(thisClass)
//      CHAIN_MSG_MAP_ALT(baseClass, 0)
    END_MSG_MAP()

protected:
    void ShowHideControl( int iCtrl, BOOL fEnable )
    {
        CCommonDialogRoutines       cdr;

        cdr.ShowHideWindow( m_hWnd, iCtrl, fEnable );
    }

    void SetErrorControl( int iCtrl )
    {
        CCommonDialogRoutines       cdr;

        cdr.SetErrorFocus( m_hWnd, iCtrl );
    }

    void ReduceDialogHeight( int iCtrl )
    {
        RECT            rectControlBox;

        ASSERT( GetDlgItem( iCtrl ) );

        ::GetWindowRect( GetDlgItem( iCtrl ), &rectControlBox );

        RECT            rectWindow;

        GetWindowRect( &rectWindow );

        int nNewHeight = ( rectControlBox.bottom - rectWindow.top ) + 8;

        RECT            rectSize;

        GetClientRect( &rectSize );

        rectSize.bottom = nNewHeight;

        SetWindowPos( NULL, &rectSize, SWP_NOMOVE | SWP_NOZORDER );
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\custfile.h ===
/****************************************************************************\
 *
 *   custfile.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Custom File Dialog
 *
\****************************************************************************/

#ifndef CUSTOM_FILE_H
#define CUSTOM_FILE_H

class CCustomFileDialog : public CFileDialog
{
private:
    BOOL    m_bLocalFileCheck;

public:
	CCustomFileDialog(
        BOOL bLocalFileCheck,
        BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT| OFN_PATHMUSTEXIST,
		LPCTSTR lpszFilter = NULL,
		HWND hWndParent = NULL)
		: CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent),
        m_bLocalFileCheck( bLocalFileCheck )
	{ }

	BEGIN_MSG_MAP(CCustomFileDialog)
	    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		NOTIFY_CODE_HANDLER(CDN_FILEOK, OnFileOk)
	END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnFileOk(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled);

public:
	int		DoModal(HWND hWndParent = ::GetActiveWindow( ));
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\custfile.cpp ===
/****************************************************************************\
 *
 *   custfile.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Custom File Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "custfile.h"       // CCustomFileDialog
#include <atlmisc.h>        // CString

// The reason this file is not currently added is the Ansi version of GetOpenFileName()
//      currently displays the Old version of the Open File Dialog when a Hook is required.

// If the msrating.dll is converted to Unicode, the CCustomFileDialog should be included
//      and should properly display the New version of the Open File Dialog.

// If this file is added to the Build the following needs to be added as a Resource:
//      IDS_LOCAL_FILE_REQUIRED "The file selected must be a local file for correct Content Advisor functionality.\r\n\r\n%s"

LRESULT CCustomFileDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = FALSE;
    return 1L;
}

// Insures the File is a Local File
LRESULT CCustomFileDialog::OnFileOk(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
{
	if ( m_bLocalFileCheck )
    {
        CString             strFile( m_szFileName );
        CString             strDrive = strFile.Left( 3 );
        UINT                uiDriveType;

        uiDriveType = ::GetDriveType( strDrive );

        if ( uiDriveType != DRIVE_FIXED )
        {
            CString             strMessage;

            strMessage.Format( IDS_LOCAL_FILE_REQUIRED, strFile );

            MyMessageBox( m_hWnd, strMessage, IDS_GENERIC, MB_OK | MB_ICONWARNING );

            return -1;
        }
    }

    bHandled = FALSE;
    return 0L;
}

// Insures if Open File Flags are changed the Dialog will be Properly Derived
int	CCustomFileDialog::DoModal(HWND hWndParent)
{
	m_ofn.Flags |= OFN_ENABLEHOOK | OFN_EXPLORER; // Please don't remove these flags

    return CFileDialog::DoModal(hWndParent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\comobj.cpp ===
#include "msrating.h"
#include "ratings.h"
#include "rors.h"

#include "msluglob.h"
#include "mslubase.h"

#include <advpub.h>
#include <atlmisc.h>        // CString

STDMETHODIMP CLUClassFactory::QueryInterface(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CLUClassFactory::AddRef(void)
{
    RefThisDLL(TRUE);

    return 1;
}


STDMETHODIMP_(ULONG) CLUClassFactory::Release(void)
{
    RefThisDLL(FALSE);

    return 1;
}


STDMETHODIMP CLUClassFactory::CreateInstance(
    /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL != pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    CRORemoteSite *pObj = new CRORemoteSite;

    if (NULL == pObj)
        return ResultFromScode(E_OUTOFMEMORY);

    HRESULT hr = pObj->QueryInterface(riid, ppvObject);

    if (FAILED(hr)) {
        delete pObj;
        pObj = NULL;
    }

    return hr;
}

        
STDMETHODIMP CLUClassFactory::LockServer( 
    /* [in] */ BOOL fLock)
{
    LockThisDLL(fLock);

    return NOERROR;
}

HRESULT CallRegInstall(LPSTR pszSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "MSIEXPLORE", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            lstrcpy(szIEPath,"iexplore.exe");

            if ( RunningOnNT() ) //are we on NT?
            {
                // If on NT, we want custom action for %25% %11%
                // so that it uses %SystemRoot% in writing the
                // path to the registry.
                stReg.cEntries += 2;
            }

            hr = pfnri(g_hInstance, pszSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

extern "C" {

STDAPI DllRegisterServer(void)
{
    HKEY hkeyCLSID;
    HKEY hkeyOurs;
    HKEY hkeyInproc;
    LONG err;

    err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
    if (err == ERROR_SUCCESS)
    {
        err = ::RegCreateKey(hkeyCLSID, ::szRORSGUID, &hkeyOurs);
        if (err == ERROR_SUCCESS)
        {
            err = ::RegCreateKey(hkeyOurs, ::szINPROCSERVER32, &hkeyInproc);
            if (err == ERROR_SUCCESS)
            {
                DWORD           dwType;
                CString         strDLL;
                int             cchNull;

                if ( RunningOnNT() )
                {
                    dwType = REG_EXPAND_SZ;
                    strDLL = CString( ::szNTRootDir ) + CString( ::szDLLNAME );
                    cchNull = 0;
                }
                else
                {
                    dwType = REG_SZ;

                    strDLL = CString( ::sz9XRootDir ) + CString( ::szDLLNAME );

                    TCHAR           tchDLL[ MAX_PATH + 1 ];
                    int             cchDLL;

                    tchDLL[0] = '\0';

                    cchDLL = ::ExpandEnvironmentStrings( strDLL, tchDLL, MAX_PATH + 1 );

                    if ( cchDLL == 0 || cchDLL > MAX_PATH || strDLL == tchDLL )
                    {
                        strDLL = ::szDLLNAME;
                    }
                    else
                    {
                        strDLL = tchDLL;
                    }

                    cchNull = 1;
                }

                err = ::RegSetValueEx(hkeyInproc, NULL, 0, dwType,
                                      (LPBYTE) (LPCTSTR) strDLL, strDLL.GetLength() + cchNull );
                if (err == ERROR_SUCCESS)
                {
                    err = ::RegSetValueEx(hkeyInproc, ::szTHREADINGMODEL, 0,
                                          REG_SZ, (LPBYTE)::szAPARTMENT,
                                          ::strlenf(::szAPARTMENT) + cchNull );
                }

                ::RegCloseKey(hkeyInproc);
            }

            ::RegCloseKey(hkeyOurs);
        }

        ::RegCloseKey(hkeyCLSID);
    }

    CallRegInstall("InstallAssociations");

    if (err == ERROR_SUCCESS)
        return S_OK;
    else
        return HRESULT_FROM_WIN32(err);
}


STDAPI DllUnregisterServer(void)
{
    HKEY hkeyCLSID;
    HKEY hkeyOurs;
    LONG err;

    err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
    if (err == ERROR_SUCCESS)
    {
        err = ::RegOpenKey(hkeyCLSID, ::szRORSGUID, &hkeyOurs);
        if (err == ERROR_SUCCESS)
        {
            err = ::RegDeleteKey(hkeyOurs, ::szINPROCSERVER32);

            ::RegCloseKey(hkeyOurs);

            if (err == ERROR_SUCCESS)
            {
                err = ::RegDeleteKey(hkeyCLSID, ::szRORSGUID);
            }
        }

        ::RegCloseKey(hkeyCLSID);
    }

    CallRegInstall("UnInstallAssociations");

    if (err == ERROR_SUCCESS)
        return S_OK;
    else
        return HRESULT_FROM_WIN32(err);
}


STDAPI DllCanUnloadNow(void)
{
    SCODE sc;

    sc = (0 == g_cRefThisDll && 0 == g_cLocks) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}


STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR *ppv)
{
    if (!IsEqualCLSID(rclsid, CLSID_RemoteSite)) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    static CLUClassFactory cf;

    *ppv = (LPVOID)&cf;

    cf.AddRef();

    return NOERROR;
}

};  /* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\chngdlg.h ===
/****************************************************************************\
 *
 *   chngdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Change Password Dialog
 *
\****************************************************************************/

#ifndef CHANGE_PASSWORD_DIALOG_H
#define CHANGE_PASSWORD_DIALOG_H

#include "basedlg.h"        // CBaseDialog
#include "hint.h"           // CHint
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

static DWORD aIdsChangePassword[] = {
    IDC_STATIC5,            IDH_IGNORE,
    IDC_STATIC1,            IDH_RATINGS_CHANGE_PASSWORD_OLD,
    IDC_OLD_PASSWORD,       IDH_RATINGS_CHANGE_PASSWORD_OLD,
    IDC_STATIC2,            IDH_RATINGS_CHANGE_PASSWORD_NEW,
    IDC_PASSWORD,           IDH_RATINGS_CHANGE_PASSWORD_NEW,
    IDC_STATIC4,            IDH_RATINGS_SUPERVISOR_CREATE_PASSWORD,
    IDC_CREATE_PASSWORD,    IDH_RATINGS_SUPERVISOR_CREATE_PASSWORD,
    IDC_STATIC3,            IDH_RATINGS_CHANGE_PASSWORD_CONFIRM,
    IDC_CONFIRM_PASSWORD,   IDH_RATINGS_CHANGE_PASSWORD_CONFIRM,
    IDC_OLD_HINT_LABEL,     IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_OLD_HINT_TEXT,      IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_HINT_TEXT,          IDH_IGNORE,
    IDC_HINT_LABEL,         IDH_RATINGS_ENTER_PW_HINT,
    IDC_HINT_EDIT,          IDH_RATINGS_ENTER_PW_HINT,
    0,0
};

template <WORD t_wDlgTemplateID>
class CChangePasswordDialog: public CBaseDialog<CChangePasswordDialog>
{
public:
    enum { IDD = t_wDlgTemplateID };

public:
    CChangePasswordDialog()     { /* Add Construction Here */ }

public:
    typedef CChangePasswordDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOK)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        if(GetDlgItem(IDC_OLD_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_OLD_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }
        if(GetDlgItem(IDC_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }
        if(GetDlgItem(IDC_CONFIRM_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_CONFIRM_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }
        if(GetDlgItem(IDC_CREATE_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_CREATE_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }

        // Display previously created hint (if one exists).
        {
            CHint       oldHint( m_hWnd, IDC_OLD_HINT_TEXT );

            oldHint.DisplayHint();
        }

        // Set the length of the new hint.
        {
            CHint       newHint( m_hWnd, IDC_HINT_EDIT );

            newHint.InitHint();
        }

        bHandled = FALSE;
        return 1L;  // Let the system set the focus
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(FALSE);
        return 0L;
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        CHAR pszPassword[MAXPATHLEN];
        CHAR pszTempPassword[MAXPATHLEN];
        CHAR *p = NULL;
        HRESULT hRet;
        HWND hwndPassword;
        int iPasswordCtrl;
        HWND hDlg = m_hWnd;

        iPasswordCtrl = IDC_PASSWORD;
        hwndPassword = ::GetDlgItem( hDlg, iPasswordCtrl );

        if (hwndPassword == NULL)
        {
            iPasswordCtrl = IDC_CREATE_PASSWORD;
            hwndPassword = ::GetDlgItem( hDlg, iPasswordCtrl );
        }

        ASSERT( hwndPassword );

        ::GetWindowText(hwndPassword, pszPassword, sizeof(pszPassword));
        GetDlgItemText(IDC_CONFIRM_PASSWORD, pszTempPassword, sizeof(pszTempPassword));

        /* if they've typed just the first password but not the
         * second, let Enter take them to the second field
         */
        if (*pszPassword && !*pszTempPassword && GetFocus() == hwndPassword)
        {
            SetErrorControl( IDC_CONFIRM_PASSWORD );
            return 0L;
        }

        if (strcmpf(pszPassword, pszTempPassword))
        {
            MyMessageBox(hDlg, IDS_NO_MATCH, IDS_GENERIC, MB_OK);
            SetErrorControl( IDC_CONFIRM_PASSWORD );
            return 0L;
        }

        if (*pszPassword=='\0')
        {
            MyMessageBox(hDlg, IDS_NO_NULL_PASSWORD, IDS_GENERIC, MB_OK);
            SetErrorControl( iPasswordCtrl );
            return 0L;
        }

        if ( SUCCEEDED( VerifySupervisorPassword() ) )
        {
            GetDlgItemText(IDC_OLD_PASSWORD, pszTempPassword, sizeof(pszTempPassword));
            p = pszTempPassword;
        }

        // Verify the Newly Added Hint.
        CHint       newHint( hDlg, IDC_HINT_EDIT );

        if ( ! newHint.VerifyHint() )
        {
            TraceMsg( TF_ALWAYS, "CChangePasswordDialog::OnOK() - User requested to fill in hint." );
            return 0L;
        }

        hRet = ChangeSupervisorPassword(p, pszPassword);
    
        if (SUCCEEDED(hRet))
        {
            // Save the Newly Added Hint.
            newHint.SaveHint();

            EndDialog(TRUE);
        }
        else
        {
            MyMessageBox(hDlg, IDS_BADPASSWORD, IDS_GENERIC, MB_OK|MB_ICONERROR);
            SetErrorControl( IDC_OLD_PASSWORD );
        }

        return 0L;
    }

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIdsChangePassword);

        return 0L;
    }

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)aIdsChangePassword);

        return 0L;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\debug.cpp ===
#include "msrating.h"
// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "msrating"
#define SZ_MODULE           "MSRATING"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\filedlg.h ===
/****************************************************************************\
 *
 *   provdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Ratings Provider Dialog
 *
\****************************************************************************/

#ifndef FILE_DIALOG_H
#define FILE_DIALOG_H

#include "basedlg.h"        // CBaseDialog

const UINT PASSCONFIRM_FAIL = 0;
const UINT PASSCONFIRM_OK = 1;
const UINT PASSCONFIRM_NEW = 2;

struct ProviderData
{
    PicsRatingSystem *pPRS;
    PicsRatingSystem *pprsNew;
    UINT nAction;
};

const UINT PROVIDER_KEEP = 0;
const UINT PROVIDER_ADD = 1;
const UINT PROVIDER_DEL = 2;

class CProviderDialog: public CBaseDialog<CProviderDialog>
{
private:
    static DWORD aIds[];
    PicsRatingSystemInfo * m_pPRSI;
    array<ProviderData> m_aPD;

public:
    enum { IDD = IDD_PROVIDERS };

public:
    CProviderDialog( PicsRatingSystemInfo * p_pPRSI );

public:
    typedef CProviderDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_HANDLER(IDC_PROVIDERLIST, LBN_SELCHANGE, OnSelChange)

        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDC_CLOSEPROVIDER, OnCloseProvider)
        COMMAND_ID_HANDLER(IDC_OPENPROVIDER, OnOpenProvider)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnCloseProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOpenProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    BOOL    OpenTemplateDlg( CHAR * szFilename,UINT cbFilename );
    void    SetHorizontalExtent(HWND hwndLB, LPCSTR pszString);
    void    AddProviderToList(UINT idx, LPCSTR pszFilename);
    BOOL    InitProviderDlg( void );
    void    EndProviderDlg(BOOL fRet);
    void    CommitProviderDlg( void );
    void    RemoveProvider( void );
    int     CompareProviderNames(PicsRatingSystem *pprsOld, PicsRatingSystem *pprsNew);
    void    AddProvider( PSTR szAddFileName=NULL );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\filedlg.cpp ===
/****************************************************************************\
 *
 *   FILEDLG.CPP - Code to manage the Rating Systems dialog.
 *
 *     gregj    06/27/96    Moved code here from msludlg.cpp and largely rewrote.
 *     
\****************************************************************************/

/*INCLUDES--------------------------------------------------------------------*/
#include "msrating.h"
#include "ratings.h"
#include "mslubase.h"
#include "commctrl.h"
#include "commdlg.h"
#include "buffer.h"
#include "filedlg.h"        // CProviderDialog
// #include "custfile.h"       // CCustomFileDialog
#include "debug.h"
#include <shellapi.h>

#include <contxids.h>

#include <mluisupp.h>

typedef BOOL (APIENTRY *PFNGETOPENFILENAME)(LPOPENFILENAME);

DWORD CProviderDialog::aIds[] = {
    IDC_STATIC1,            IDH_RATINGS_SYSTEM_RATSYS_LIST,
    IDC_PROVIDERLIST,       IDH_RATINGS_SYSTEM_RATSYS_LIST,
    IDC_OPENPROVIDER,       IDH_RATINGS_SYSTEM_RATSYS_ADD,
    IDC_CLOSEPROVIDER,      IDH_RATINGS_SYSTEM_RATSYS_REMOVE,
    IDC_STATIC2,            IDH_IGNORE,
    0,0
};

CProviderDialog::CProviderDialog( PicsRatingSystemInfo * p_pPRSI )
{
    m_pPRSI = p_pPRSI;
}

BOOL CProviderDialog::OpenTemplateDlg( CHAR * szFilename,UINT cbFilename )
{
    CHAR szFilter[MAXPATHLEN];
    CHAR szOpenInfTitle[MAXPATHLEN];
    CHAR szInitialDir[MAXPATHLEN];

    GetSystemDirectory(szInitialDir, sizeof(szInitialDir));
    strcpyf(szFilename,szNULL);
    MLLoadStringA(IDS_RAT_OPENFILE, szOpenInfTitle,sizeof(szOpenInfTitle));

    // have to load the openfile filter in 2 stages, because the string
    // contains a terminating character and MLLoadString won't load the
    // whole thing in one go
    memset(szFilter,0,sizeof(szFilter));
    MLLoadStringA(IDS_RAT_FILTER_DESC,szFilter,sizeof(szFilter) - 10); // save some room for the filespec
    MLLoadStringA(IDS_RAT_FILTER,szFilter+strlenf(szFilter)+1,sizeof(szFilter)-
        (strlenf(szFilter)+1));

    OPENFILENAME ofn;

    memset(&ofn,0,sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile =    szFilename;
    ofn.nMaxFile = cbFilename;
    ofn.lpstrTitle = szOpenInfTitle;
    ofn.lpstrInitialDir = szInitialDir;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST
                        | OFN_SHAREAWARE | OFN_HIDEREADONLY;

    BOOL fRet = ::GetOpenFileName( &ofn );

#ifdef NEVER
    DWORD           dwFlags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_NONETWORKBUTTON
                        | OFN_SHAREAWARE | OFN_HIDEREADONLY;

    BOOL fRet = FALSE;

    CCustomFileDialog           cfd( TRUE,          // Local Files Only
                                     TRUE,          // Open File
                                     NULL,          // Default Extension
                                     NULL,          // Initial Filename
                                     dwFlags,       // Open File Flags
                                     szFilter,      // Filter
                                     m_hWnd );      // Parent

    if ( cfd.DoModal( m_hWnd ) == IDOK )
    {
        fRet = TRUE;
        lstrcpy( szFilename, cfd.m_szFileName );
    }
#endif

    return fRet;
}


void CProviderDialog::SetHorizontalExtent(HWND hwndLB, LPCSTR pszString)
{
    HDC hDC = ::GetDC(hwndLB);
    HFONT hFont = (HFONT)::SendMessage(hwndLB, WM_GETFONT, 0, 0);
    HFONT hfontOld = (HFONT)::SelectObject(hDC, hFont);

    UINT cxSlop = ::GetSystemMetrics(SM_CXBORDER) * 4;    /* 2 for LB border, 2 for margin inside border */

    UINT cxNewMaxExtent = 0;
    SIZE s;
    if (pszString != NULL) {
        ::GetTextExtentPoint(hDC, pszString, ::strlenf(pszString), &s);
        UINT cxCurExtent = (UINT)::SendMessage(hwndLB, LB_GETHORIZONTALEXTENT, 0, 0);
        if ((UINT)s.cx > cxCurExtent)
            cxNewMaxExtent = s.cx + cxSlop;
    }
    else {
        UINT cItems = (UINT)::SendMessage(hwndLB, LB_GETCOUNT, 0, 0);
        for (UINT i=0; i<cItems; i++) {
            char szItem[MAXPATHLEN];    /* we know we have pathnames in the list */
            ::SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)(LPSTR)szItem);
            ::GetTextExtentPoint(hDC, szItem, ::strlenf(szItem), &s);
            if ((UINT)s.cx > cxNewMaxExtent)
                cxNewMaxExtent = s.cx;
        }
        cxNewMaxExtent += cxSlop;
    }

    if (cxNewMaxExtent > 0)
        ::SendMessage(hwndLB, LB_SETHORIZONTALEXTENT, (WPARAM)cxNewMaxExtent, 0);

    ::SelectObject(hDC, hfontOld);
    ::ReleaseDC(hwndLB, hDC);
}

void CProviderDialog::AddProviderToList(UINT idx, LPCSTR pszFilename)
{
    UINT_PTR iItem = SendDlgItemMessage(IDC_PROVIDERLIST, LB_ADDSTRING, 0,
                                        (LPARAM)pszFilename);
    if (iItem != LB_ERR)
    {
        SendDlgItemMessage(IDC_PROVIDERLIST, LB_SETITEMDATA, iItem, (LPARAM)idx);
    }
}


BOOL CProviderDialog::InitProviderDlg( void )
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::InitProviderDlg() - m_pPRSI is NULL!" );
        return FALSE;
    }

    for (UINT i = 0; i < (UINT)m_pPRSI->arrpPRS.Length(); ++i)
    {
        PicsRatingSystem *pPRS = m_pPRSI->arrpPRS[i];
        ProviderData pd;
        pd.pPRS = pPRS;
        pd.pprsNew = NULL;
        pd.nAction = PROVIDER_KEEP;
        if (!m_aPD.Append(pd))
            return FALSE;

        if(pPRS->etstrName.Get())
        {
            // add provider using name
            AddProviderToList(i, pPRS->etstrName.Get());
        }
        else if(pPRS->etstrFile.Get())
        {
            // no name - possibly missing file, use filespec instead
            AddProviderToList(i, pPRS->etstrFile.Get());
        }
    }

    SetHorizontalExtent(GetDlgItem(IDC_PROVIDERLIST), NULL);
            
    ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), FALSE);
    ::EnableWindow(GetDlgItem(IDC_OPENPROVIDER), TRUE);

    if (SendDlgItemMessage(IDC_PROVIDERLIST, LB_SETCURSEL, 0, 0) != LB_ERR)
    {
        ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), TRUE);
    }

    return TRUE;
}


void CProviderDialog::EndProviderDlg(BOOL fRet)
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::EndProviderDlg() - m_pPRSI is NULL!" );
        return;
    }

    /* Go through our auxiliary array and delete any provider structures which
     * we added in this dialog.  Note that if the user previously hit OK, the
     * providers which were added will be marked as KEEP when they're put back
     * in the main data structure, so we won't delete them here.
     */
    UINT cProviders = m_aPD.Length();
    for (UINT i=0; i<cProviders; i++)
    {
        if (m_aPD[i].nAction == PROVIDER_ADD)
        {
            delete m_aPD[i].pPRS;
            m_aPD[i].pPRS = NULL;
        }

        if (m_aPD[i].pprsNew != NULL)
        {
            delete m_aPD[i].pprsNew;
            m_aPD[i].pprsNew = NULL;
        }
    }

    EndDialog(fRet);
}


void CProviderDialog::CommitProviderDlg( void )
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::CommitProviderDlg() - m_pPRSI is NULL!" );
        return;
    }

    /* We check twice to see if there are any rating systems installed.
     * Up front, we see if there's anything in the list, before we commit
     * any changes;  this lets the user change their mind, cancel the dialog,
     * and not lose any settings.
     *
     * The second check is down at the end, seeing if there are any valid
     * rating systems left after we're done committing changes.  Note that
     * the results of that check could be different than this first one if
     * any rating systems fail to load for some reason.
     *
     * If we prompt the user the first time and he says he really doesn't
     * want any rating systems (i.e., wants to disable ratings completely),
     * we don't bother prompting the second time since he's already said no.
     * Hence the fPrompted flag.
     */
    BOOL fPrompted = FALSE;

    if (SendDlgItemMessage(IDC_PROVIDERLIST, LB_GETCOUNT, 0, 0) == 0) {
        MyMessageBox(m_hWnd, IDS_NO_PROVIDERS, IDS_GENERIC, MB_OK);
        return;
    }

    /* Go through the list and add the new ones.
     * Note that this does NOT destruct the pPRS objects themselves, it just
     * empties the array.  We have saved copies of all of them in our auxiliary
     * array.
     */

    m_pPRSI->arrpPRS.ClearAll();

    UINT cItems = m_aPD.Length();

    for (UINT i=0; i<cItems; i++) {
        switch (m_aPD[i].nAction) {
        case PROVIDER_DEL:
            DeleteUserSettings(m_aPD[i].pPRS);
            delete m_aPD[i].pPRS;
            m_aPD[i].pPRS = NULL;
            delete m_aPD[i].pprsNew;
            m_aPD[i].pprsNew = NULL;
            break;

        case PROVIDER_KEEP:
            if (m_aPD[i].pprsNew != NULL) {
                CheckUserSettings(m_aPD[i].pprsNew);
                m_pPRSI->arrpPRS.Append(m_aPD[i].pprsNew);
                delete m_aPD[i].pPRS;
                m_aPD[i].pPRS = NULL;
                m_aPD[i].pprsNew = NULL;    /* protect from cleanup code */
            }
            else if (!(m_aPD[i].pPRS->dwFlags & PRS_ISVALID)) {
                delete m_aPD[i].pPRS;
                m_aPD[i].pPRS = NULL;
            }
            else {
                CheckUserSettings(m_aPD[i].pPRS);
                m_pPRSI->arrpPRS.Append(m_aPD[i].pPRS);
            }
            break;

        case PROVIDER_ADD:
            if (m_aPD[i].pPRS != NULL) {
                CheckUserSettings(m_aPD[i].pPRS);
                m_pPRSI->arrpPRS.Append(m_aPD[i].pPRS);
                m_aPD[i].nAction = PROVIDER_KEEP;        /* keep this one now */
            }
            break;

        default:
            ASSERT(FALSE);
        }
    }

    if (m_pPRSI->arrpPRS.Length() == 0) {
        if (!fPrompted &&
            MyMessageBox(m_hWnd, IDS_NO_PROVIDERS, IDS_GENERIC, MB_YESNO) == IDYES)
        {
            return;
        }
        m_pPRSI->fRatingInstalled = FALSE;
    }
    else {
        m_pPRSI->fRatingInstalled = TRUE;
    }

    EndProviderDlg(TRUE);
}


void CProviderDialog::RemoveProvider( void )
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::AddProvider() - m_pPRSI is NULL!" );
        return;
    }

    UINT_PTR i = SendDlgItemMessage( IDC_PROVIDERLIST, LB_GETCURSEL,0,0);

    if (i != LB_ERR)
    {
        UINT idx = (UINT)SendDlgItemMessage( IDC_PROVIDERLIST,
                                            LB_GETITEMDATA, i, 0);
        if (idx < (UINT)m_aPD.Length()) {
            /* If the user added the provider in this dialog session, just
             * delete it from the array.  The null pPRS pointer will be
             * detected later, so it's OK to leave the array element itself.
             * (Yes, if the user adds and removes an item over and over, we
             * consume 12 bytes of memory each time. Oh well.)
             *
             * If the item was there before the user launched the dialog,
             * then just mark it for deletion on OK.
             */
            if (m_aPD[idx].nAction == PROVIDER_ADD) {
                delete m_aPD[idx].pPRS;
                m_aPD[idx].pPRS = NULL;
            }
            else
                m_aPD[idx].nAction = PROVIDER_DEL;
        }

        SendDlgItemMessage(IDC_PROVIDERLIST, LB_DELETESTRING, i, 0);
        ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), FALSE);
        SendDlgItemMessage(IDC_PROVIDERLIST, LB_SETCURSEL,0,0);
        ::SetFocus(GetDlgItem(IDOK));
        SetHorizontalExtent(GetDlgItem(IDC_PROVIDERLIST), NULL);
    }
}


/* Returns zero if the two PicsRatingSystems have the same RAT-filename,
 * non-zero otherwise.  Handles the '*' marker on the end for failed
 * loads.  It is assumed that only pprsOld may have that marker.
 */
int CProviderDialog::CompareProviderNames(PicsRatingSystem *pprsOld, PicsRatingSystem *pprsNew)
{
    if (!pprsOld->etstrFile.fIsInit())
        return 1;

    UINT cbNewName = ::strlenf(pprsNew->etstrFile.Get());

    LPSTR pszOld = pprsOld->etstrFile.Get();
    int nCmp = ::strnicmpf(pprsNew->etstrFile.Get(), pszOld, cbNewName);
    if (nCmp != 0)
        return nCmp;

    pszOld += cbNewName;
    if (*pszOld == '\0' || (*pszOld == '*' && *(pszOld+1) == '\0'))
        return 0;

    return 1;
}


void CProviderDialog::AddProvider( PSTR szAddFileName )
{
    BOOL fAdd=FALSE;
    char szFileName[MAXPATHLEN+1];

    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::AddProvider() - m_pPRSI is NULL!" );
        return;
    }

    if (szAddFileName!=NULL)
    {
        lstrcpy(szFileName,szAddFileName);
        fAdd=TRUE;
    }
    else
    {
        fAdd=OpenTemplateDlg(szFileName, sizeof(szFileName));
    }
    
    if (fAdd==TRUE)
    {
        PicsRatingSystem *pPRS;
        HRESULT hres = LoadRatingSystem(szFileName, &pPRS);

        if (FAILED(hres)) {
            if (pPRS != NULL) {
                pPRS->ReportError(hres);
                delete pPRS;
                pPRS = NULL;
            }
        }
        else {
            /* Check to see if this guy is already in the list.  If he is,
             * the user might have said to delete him;  in that case, put
             * him back.  Otherwise, the system is already installed, so
             * tell the user he doesn't have to install it again.
             */
            for (UINT i=0; i<(UINT)m_aPD.Length(); i++) {
                ProviderData *ppd = &m_aPD[i];
                if (ppd->pPRS==NULL) {
                    //This system was added and then removed during
                    //this dialog session.  It will be detected later,
                    //so just skip it and keep appending entries.
                    continue;
                }
                if (!CompareProviderNames(ppd->pPRS, pPRS)) {

                    if (!(ppd->pPRS->dwFlags & PRS_ISVALID) &&
                        (ppd->pprsNew == NULL))
                        ppd->pprsNew = pPRS;
                    else
                    {
                        delete pPRS;    /* don't need copy */
                        pPRS = NULL;
                    }

                    if (ppd->nAction == PROVIDER_DEL) {
                        ppd->nAction = PROVIDER_KEEP;
                        AddProviderToList(i, ppd->pPRS->etstrName.Get());
                    }
                    else {
                        MyMessageBox(m_hWnd, IDS_ALREADY_INSTALLED, IDS_GENERIC, MB_OK);
                    }
                    return;
                }
            }

            /* This guy isn't already in the list.  Add him to the listbox
             * and to the array.
             */
            ProviderData pd;
            pd.nAction = PROVIDER_ADD;
            pd.pPRS = pPRS;
            pd.pprsNew = NULL;

            if (!m_aPD.Append(pd)) {
                MyMessageBox(m_hWnd, IDS_LOADRAT_MEMORY, IDS_GENERIC, MB_OK | MB_ICONWARNING);
                delete pPRS;
                pPRS = NULL;
                return;
            }
            AddProviderToList(m_aPD.Length() - 1, pPRS->etstrName.Get());

            ::SetFocus(GetDlgItem(IDOK));
            SetHorizontalExtent(GetDlgItem(IDC_PROVIDERLIST), szFileName);
        }
    }
}


LRESULT CProviderDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::OnInitDialog() - m_pPRSI is NULL!" );
        return 0L;
    }

    if ( ! InitProviderDlg() )
    {
        MyMessageBox(m_hWnd, IDS_LOADRAT_MEMORY, IDS_GENERIC, MB_OK | MB_ICONSTOP);
        EndProviderDlg(FALSE);
    }

    if ( m_pPRSI->lpszFileName != NULL )
    {
        AddProvider( m_pPRSI->lpszFileName );
    }

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CProviderDialog::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (SendDlgItemMessage(IDC_PROVIDERLIST, LB_GETCURSEL, 0,0) >= 0)
    {
        ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), TRUE);
        bHandled = TRUE;
    }

    return 0L;
}

LRESULT CProviderDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CommitProviderDlg();
    return 0L;
}

LRESULT CProviderDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndProviderDlg(FALSE);
    return 0L;
}

LRESULT CProviderDialog::OnCloseProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    RemoveProvider();

    return 0L;
}

LRESULT CProviderDialog::OnOpenProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    AddProvider();

    return 0L;

}

LRESULT CProviderDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CProviderDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

INT_PTR DoProviderDialog(HWND hDlg, PicsRatingSystemInfo *pPRSI)
{
    CProviderDialog         provDialog( pPRSI );

    return provDialog.DoModal( hDlg );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\gendlg.h ===
/****************************************************************************\
 *
 *   gendlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings General Property Page
 *
\****************************************************************************/

#ifndef GENERAL_DIALOG_H
#define GENERAL_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

typedef HINSTANCE (APIENTRY *PFNSHELLEXECUTE)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);

class CGeneralDialog : public CBasePropertyPage<IDD_GENERAL>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CGeneralDialog( PRSD * p_pPRSD );

public:
    typedef CGeneralDialog thisClass;
    typedef CBasePropertyPage<IDD_GENERAL> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_USER, OnUser)

        COMMAND_ID_HANDLER(IDC_PROVIDER, OnProvider)
        COMMAND_ID_HANDLER(IDC_FINDRATINGS, OnFindRatings)

        COMMAND_ID_HANDLER(IDC_PLEASE_MOMMY, OnMarkChanged)
        COMMAND_ID_HANDLER(IDC_UNRATED, OnMarkChanged)

        COMMAND_ID_HANDLER(IDC_CHANGE_PASSWORD, OnChangePassword)

        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnFindRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnChangePassword(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    SetButtonText( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\introdlg.h ===
/****************************************************************************\
 *
 *   introdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Introduction Property Page
 *
\****************************************************************************/

#ifndef INTRO_DIALOG_H
#define INTRO_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

class CIntroDialog : public CBasePropertyPage<IDD_INTRO>
{
private:
    static DWORD aIds[];

public:
    CIntroDialog();

public:
    typedef CIntroDialog thisClass;
    typedef CBasePropertyPage<IDD_INTRO> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDC_SET_RATINGS, OnSetRatings)
        COMMAND_ID_HANDLER(IDC_TURN_ONOFF, OnTurnOnOff)

        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSetRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnTurnOnOff(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    EnableDlgItems( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\hint.cpp ===
/****************************************************************************\
 *
 *   hint.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Hint Handling Class
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "hint.h"           // CHint
#include "basedlg.h"        // CCommonDialogRoutines
#include "debug.h"          // TraceMsg()

const int cchHintLength_c = 127;
const TCHAR tchAmpersand_c[] = "&";
const TCHAR tchAmpersandReplacement_c[] = "&&";

// Default CHint Constructor
CHint::CHint()
{
    CHint( NULL, 0 );
}

// CHint Constructor with Dialog Window Handle and Hint Control Id.
CHint::CHint( HWND p_hWnd, int p_iId )
{
    m_hWnd = p_hWnd;
    m_iId = p_iId;
}

// Display the Hint Text on the Dialog Control.
void CHint::DisplayHint( void )
{
    HWND        hwndControl = ::GetDlgItem( m_hWnd, m_iId );

    if ( hwndControl != NULL )
    {
        CString         strHint;

        RetrieveHint( strHint );

        // Avoid display of "_" (accelerator) by replacing single "&" with "&&".
        strHint.Replace( tchAmpersand_c, tchAmpersandReplacement_c );

        ::SetWindowText( hwndControl, strHint );
    }
}

// Initialize the Hint Dialog Control by limiting the Number of Hint Characters.
void CHint::InitHint( void )
{
    HWND        hwndControl = ::GetDlgItem( m_hWnd, m_iId );

    if ( hwndControl != NULL )
    {
        ::SendMessage( hwndControl, EM_SETLIMITTEXT, (WPARAM) cchHintLength_c, (LPARAM) 0);
    }
}

// Check for a Blank Hint entered on the Dialog Control.
// Also, give the user the option to enter a non-blank hint.
bool CHint::VerifyHint( void )
{
    bool        fVerified = true;      // Default to true so we don't halt user if hint save fails.
    CString     strHint;

    GetHint( strHint );

    if ( strHint.IsEmpty() )
    {
        CString         strHintRecommended;
        CString         strCaption;

        strHintRecommended.LoadString( IDS_HINT_RECOMMENDED );
        strCaption.LoadString( IDS_GENERIC );

        if ( ::MessageBox( m_hWnd, strHintRecommended, strCaption, MB_YESNO | MB_DEFBUTTON1 ) == IDYES )
        {
            CCommonDialogRoutines       cdr;

            cdr.SetErrorFocus( m_hWnd, m_iId );

            fVerified = false;
        }
    }

    return fVerified;
}

// Save the Dialog Hint Text to the Registry (or Remove the Hint from the Registry if blank).
void CHint::SaveHint( void )
{
    CString     strHint;

    GetHint( strHint );

    if ( strHint.IsEmpty() )
    {
        RemoveHint();
    }
    else
    {
        StoreHint( strHint );
    }
}

// Remove the Hint from the Registry.
void CHint::RemoveHint( void )
{
    CRegKey         regKey;

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS ) == ERROR_SUCCESS )
    {
        if ( regKey.DeleteValue( szHINTVALUENAME ) != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CHint::RemoveHint() - Failed to delete the hint registry value." );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "CHint::RemoveHint() - Failed to open the ratings registry key." );
    }
}

// Get the Hint Text from the Dialog's Control (remove leading and trailing blanks).
void CHint::GetHint( CString & p_rstrHint )
{
    p_rstrHint.Empty();

    HWND        hwndControl = ::GetDlgItem( m_hWnd, m_iId );

    // We shouldn't be attempting to save a hint if the edit control does not exist.
    ASSERT( hwndControl );

    if ( hwndControl != NULL )
    {
        ::GetWindowText( hwndControl, (LPTSTR) (LPCTSTR) p_rstrHint.GetBufferSetLength( cchHintLength_c + 1 ), cchHintLength_c );
        p_rstrHint.ReleaseBuffer();
    }
}

// Retrieve a previous Hint from the Registry.
void CHint::RetrieveHint( CString & p_rstrHint )
{
    CRegKey         regKey;
    DWORD           dwCount;

    p_rstrHint.Empty();

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS, KEY_READ ) == ERROR_SUCCESS )
    {
        dwCount = cchHintLength_c;

        if ( regKey.QueryValue( (LPTSTR) (LPCTSTR) p_rstrHint.GetBufferSetLength( cchHintLength_c + 1 ),
                szHINTVALUENAME, &dwCount ) != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CHint::RetrieveHint() - Failed to query the hint registry value." );
        }

        p_rstrHint.ReleaseBuffer();
    }
    else
    {
        TraceMsg( TF_WARNING, "CHint::RetrieveHint() - Failed to open the ratings registry key." );
    }

    if ( p_rstrHint.IsEmpty() )
    {
        p_rstrHint.LoadString( IDS_NO_HINT );
    }
}

// Store Hint Text into the Registry.
void CHint::StoreHint( CString & p_rstrHint )
{
    CRegKey         regKey;

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS ) == ERROR_SUCCESS )
    {
        if ( regKey.SetValue( (LPTSTR) (LPCTSTR) p_rstrHint, szHINTVALUENAME ) != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CHint::StoreHint() - Failed to save the hint registry value." );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "CHint::StoreHint() - Failed to create the ratings registry key." );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\hint.h ===
/****************************************************************************\
 *
 *   hint.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Hint Handling Class
 *
\****************************************************************************/

#ifndef HINT_CLASS_H
#define HINT_CLASS_H

#include <atlmisc.h>        // CString

class CHint
{
private:
    HWND        m_hWnd;
    int         m_iId;

public:
    CHint();
    CHint( HWND p_hWnd, int p_iId );

    void    DisplayHint( void );
    void    InitHint( void );
    bool    VerifyHint( void );
    void    SaveHint( void );
    void    RemoveHint( void );

protected:
    void    GetHint( CString & p_rstrHint );
    void    RetrieveHint( CString & p_rstrHint );
    void    StoreHint( CString & p_rstrHint );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\introdlg.cpp ===
/****************************************************************************\
 *
 *   introdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Introduction Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "parselbl.h"
#include "picsrule.h"
#include "introdlg.h"       // CIntroDialog
#include "toffdlg.h"        // CTurnOffDialog
#include "hint.h"           // CHint
#include "debug.h"          // TraceMsg()
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

extern INT_PTR DoPasswordConfirm(HWND hDlg);
extern BOOL PicsOptionsDialog( HWND hwnd, PicsRatingSystemInfo * pPRSI, PicsUser * pPU );

const UINT PASSCONFIRM_FAIL = 0;
const UINT PASSCONFIRM_OK = 1;
const UINT PASSCONFIRM_NEW = 2;

DWORD CIntroDialog::aIds[] = {
    IDC_SET_RATINGS,    IDH_RATINGS_SET_RATINGS_BUTTON,
    IDC_STATIC1,        IDH_IGNORE,
    IDC_TURN_ONOFF,     IDH_RATINGS_TURNON_BUTTON,
    IDC_INTRO_TEXT,     IDH_IGNORE,
    0,0
};

CIntroDialog::CIntroDialog()
{
    // Add Construction Here...
}

LRESULT CIntroDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CheckGlobalInfoRev();
    EnableDlgItems();

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CIntroDialog::OnSetRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HWND        hDlg = m_hWnd;

    UINT_PTR passConfirm = DoPasswordConfirm(hDlg);
    if (passConfirm == PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "CIntroDialog::OnSetRatings() - DoPasswordConfirm() failed." );
        return 0L;
    }

    if (!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        if ( ! PicsOptionsDialog( hDlg, gPRSI, GetUserObject() ) )
        {
            if (passConfirm == PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }
        MarkChanged();
    }
    else
    {
        if ( PicsOptionsDialog( hDlg, gPRSI, GetUserObject() ) )
        {
            MarkChanged();
        }
    }

    EnableDlgItems();

    return 1L;
}

LRESULT CIntroDialog::OnTurnOnOff(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HWND        hDlg = m_hWnd;

    if ( DoPasswordConfirm( hDlg ) )
    {
        PicsUser *pUser = ::GetUserObject();
        if (pUser != NULL)
        {
            pUser->fEnabled = !pUser->fEnabled;
            if (pUser->fEnabled)
            {
                MyMessageBox(hDlg, IDS_NOW_ON, IDS_ENABLE_WARNING,
                             IDS_GENERIC, MB_OK);
            }
            else
            {
                CRegKey             keyRatings;

                if ( keyRatings.Open( HKEY_LOCAL_MACHINE, szRATINGS ) == ERROR_SUCCESS )
                {
                    DWORD         dwFlag;

                    // $REVIEW - Should we call RemoveSupervisorPassword() or not delete the Key at all?

                    // Delete the supervisor key so that we don't load
                    // ratings by other components and we "quick" know it is off.

                    keyRatings.DeleteValue( szRatingsSupervisorKeyName );

                    if ( keyRatings.QueryValue( dwFlag, szTURNOFF ) == ERROR_SUCCESS )
                    {
                        if ( dwFlag != 1 )
                        {
                            CTurnOffDialog          turnOffDialog;

                            turnOffDialog.DoModal( hDlg );
                        }
                    }
                    else
                    {
                        CTurnOffDialog          turnOffDialog;

                        turnOffDialog.DoModal( hDlg );
                    }
                }
            }

            EnableDlgItems();
        }
    }

    return 1L;
}

LRESULT CIntroDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    ASSERT( gPRSI );

    if ( gPRSI )
    {
        gPRSI->fSettingsValid = TRUE;
        gPRSI->SaveRatingSystemInfo();
    }

    return PSNRET_NOERROR;
}

LRESULT CIntroDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CIntroDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

void CIntroDialog::EnableDlgItems( void )
{
    CHAR pszBuf[MAXPATHLEN];
    PicsUser *pUser = ::GetUserObject();

    if (!gPRSI->fRatingInstalled)
    {
        MLLoadStringA(IDS_RATING_NEW, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_INTRO_TEXT, pszBuf);

        MLLoadStringA(IDS_TURN_ONOFF, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_TURN_ONOFF, pszBuf);
        ::EnableWindow(GetDlgItem( IDC_TURN_ONOFF), FALSE);
    }
    else if (pUser && pUser->fEnabled)
    {
        MLLoadStringA(IDS_RATING_ON, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_INTRO_TEXT, pszBuf);

        MLLoadStringA(IDS_TURN_OFF, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_TURN_ONOFF, pszBuf);
        ::EnableWindow(GetDlgItem( IDC_TURN_ONOFF), TRUE);
    }
    else
    {
        MLLoadStringA(IDS_RATING_OFF, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_INTRO_TEXT, pszBuf);

        MLLoadStringA(IDS_TURN_ON, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_TURN_ONOFF, pszBuf);
        ::EnableWindow(GetDlgItem( IDC_TURN_ONOFF), TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\gendlg.cpp ===
/****************************************************************************\
 *
 *   gendlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings General Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "gendlg.h"         // CGeneralDialog
#include "debug.h"          // TraceMsg()
#include "chngdlg.h"        // CChangePasswordDialog
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

DWORD CGeneralDialog::aIds[] = {
    IDC_STATIC7,            IDH_IGNORE,
    IDC_STATIC1,            IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    IDC_STATIC2,            IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    IDC_STATIC3,            IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    IDC_FINDRATINGS,        IDH_FIND_RATING_SYSTEM_BUTTON,
    IDC_PROVIDER,           IDH_RATINGS_RATING_SYSTEM_BUTTON,
    IDC_UNRATED,            IDH_RATINGS_UNRATED_CHECKBOX,
    IDC_PLEASE_MOMMY,       IDH_RATINGS_OVERRIDE_CHECKBOX,
    IDC_STATIC4,            IDH_RATINGS_RATING_SYSTEM_TEXT,
    IDC_STATIC5,            IDH_RATINGS_RATING_SYSTEM_TEXT,
    IDC_STATIC6,            IDH_RATINGS_RATING_SYSTEM_TEXT,
    IDC_CHANGE_PASSWORD,    IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    0,0
};

CGeneralDialog::CGeneralDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

LRESULT CGeneralDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CApprovedSitesDialog::OnInitDialog() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->pPU != NULL)
    {
        CheckDlgButton( IDC_UNRATED, pPRSD->pPU->fAllowUnknowns?BST_CHECKED:BST_UNCHECKED);
        CheckDlgButton( IDC_PLEASE_MOMMY, pPRSD->pPU->fPleaseMom?BST_CHECKED:BST_UNCHECKED);
    }

    SetButtonText();

    PostMessage( WM_USER,(WPARAM) 0,(LPARAM) 0);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CGeneralDialog::OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (gPRSI->lpszFileName!=NULL)
    {
        ::SetFocus(GetDlgItem(IDC_PROVIDER));

        DoProviderDialog( m_hWnd,gPRSI );
        gPRSI->lpszFileName=NULL;
    }

    return 0L;
}

LRESULT CGeneralDialog::OnProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CGeneralDialog::OnProvider() - pPRSD is NULL!" );
        return 0L;
    }

    if ( DoProviderDialog( m_hWnd, pPRSD->pPRSI ) )
    {            
        pPRSD->fNewProviders = TRUE;
        MarkChanged();

        // $BUG - $BUG - The Bureau List is on the Advanced Dialog so this seems incorrect!!
//        FillBureauList(hDlg, pPRSD->pPRSI);
    }    

    return 1L;
}

LRESULT CGeneralDialog::OnFindRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fSuccess=FALSE;

    HINSTANCE hShell32=::LoadLibrary(::szShell32);

    if(hShell32!=NULL)
    {
        PFNSHELLEXECUTE pfnShellExecute=(PFNSHELLEXECUTE)::GetProcAddress(hShell32,::szShellExecute);
    
        if(pfnShellExecute!=NULL)
        {
            fSuccess=(*pfnShellExecute)(m_hWnd,NULL,(char *) &szFINDSYSTEM,NULL,NULL,SW_SHOW)!=NULL;
        }
        ::FreeLibrary(hShell32);
    }
    if (!fSuccess)
    {
        NLS_STR nlsMessage(MAX_RES_STR_LEN);
        //Check for NULL; Otherwise, nlsMessage.QueryPch() will fault later.
        if(nlsMessage)
        {
            NLS_STR nlsTemp(STR_OWNERALLOC,(char *) &szFINDSYSTEM);
            const NLS_STR *apnls[] = { &nlsTemp, NULL };
            if ( WN_SUCCESS == (nlsMessage.LoadString(IDS_CANT_LAUNCH, apnls)) )
            {
                MyMessageBox(m_hWnd,nlsMessage.QueryPch(),IDS_GENERIC,MB_OK|MB_ICONSTOP);
            }
        }
    }

    return 1L;
}

LRESULT CGeneralDialog::OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MarkChanged();
    return 1L;
}

LRESULT CGeneralDialog::OnChangePassword(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int         idsMessage = 0;

    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        CChangePasswordDialog<IDD_CHANGE_PASSWORD>       changePasswordDlg;

        if ( changePasswordDlg.DoModal( m_hWnd ) )
        {
            idsMessage = IDS_PASSWORD_CHANGED;
        }
    }
    else
    {
        CChangePasswordDialog<IDD_CREATE_PASSWORD>   createPassDlg;

        if ( createPassDlg.DoModal( m_hWnd ) )
        {
            SetButtonText();

            idsMessage = IDS_PASSWORD_CREATED;
        }
    }

    if ( idsMessage )
    {
        MyMessageBox( m_hWnd, idsMessage, IDS_GENERIC, MB_OK | MB_ICONINFORMATION);
        MarkChanged();
    }

    return 1L;
}

LRESULT CGeneralDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    /*do apply stuff*/
    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CGeneralDialog::OnApply() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->pPU != NULL)
    {
        pPRSD->pPU->fAllowUnknowns = (IsDlgButtonChecked(IDC_UNRATED) & BST_CHECKED) ? TRUE: FALSE;
        pPRSD->pPU->fPleaseMom = (IsDlgButtonChecked(IDC_PLEASE_MOMMY) & BST_CHECKED) ? TRUE: FALSE;
    }

    return PSNRET_NOERROR;
}

LRESULT CGeneralDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return 0L;
}

LRESULT CGeneralDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CGeneralDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

void CGeneralDialog::SetButtonText( void )
{
    int         idsButton;

    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        idsButton = IDS_CHANGE_PASSWORD;
    }
    else
    {
        idsButton = IDS_CREATE_PASSWORD;
    }

    HWND        hwndControl = GetDlgItem( IDC_CHANGE_PASSWORD );

    ASSERT( hwndControl );

    if ( hwndControl != NULL )
    {
        CString             strButtonText;

        strButtonText.LoadString( idsButton );

        ::SetWindowText( hwndControl, strButtonText );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\mslubase.cpp ===
/****************************************************************************\
 *
 *   MSLUBASE.C --Structures for holding pics information
 *
 *     Created:      Jason Thomas
 *     Updated:    Ann McCurdy
 *     
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "reghive.h"        // CRegistryHive
#include "debug.h"

#include <buffer.h>
#include <regentry.h>

#include <mluisupp.h>

/*Helpers-------------------------------------------------------------------*/
char PicsDelimChar='/';

int MyMessageBox(HWND hwnd, LPCSTR pszText, UINT uTitle, UINT uType)
{
    CHAR szTitle[MAXPATHLEN];
    
    MLLoadStringA(uTitle, szTitle, sizeof(szTitle));

    return MessageBox(hwnd, pszText, szTitle, uType);
}

int MyMessageBox(HWND hwnd, UINT uText, UINT uTitle, UINT uType)
{
    CHAR szText[MAXPATHLEN];
    
    MLLoadStringA(uText, szText, sizeof(szText));

    return MyMessageBox(hwnd, szText, uTitle, uType);
}

/* Variant for long messages: uText2 message will be concatenated onto the end
 * of uText before display. Message text should contain \r\n or other desired
 * separators, this function won't add them.
 */
int MyMessageBox(HWND hwnd, UINT uText, UINT uText2, UINT uTitle, UINT uType)
{
    CHAR szText[MAXPATHLEN*2] = { 0 };

    MLLoadStringA(uText, szText, sizeof(szText));

    /* Using lstrlen in case MLLoadString really returns a count of CHARACTERS,
     * on a DBCS system...
     */
    UINT cbFirst = lstrlen(szText);
    MLLoadStringA(uText2, szText + cbFirst, sizeof(szText) - cbFirst);

    return MyMessageBox(hwnd, szText, uTitle, uType);
}

/*******************************************************************

    NAME:        MyRegDeleteKey

********************************************************************/
LONG MyRegDeleteKey(HKEY hkey,LPCSTR pszSubkey)
{
    DWORD           dwError;

    TraceMsg( TF_ALWAYS, "MyRegDeleteKey() - Deleting Subkey='%s'...", pszSubkey );

    dwError = SHDeleteKey( hkey, pszSubkey );

    if ( dwError != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "MyRegDeleteKey() - Failed to Delete Subkey='%s' dwError=%d!", pszSubkey, dwError );
    }

    return dwError;
}


BOOL MyAtoi(char *pIn, int *pi)
{
    char *pc;
    ASSERT(pIn);
   
    *pi = 0;

    pc = NonWhite(pIn);
    if (!pc)
        return FALSE;
     
    if (*pc < '0' || *pc > '9')
        return FALSE;

    int accum = 0;

    while (*pc >= '0' && *pc <= '9')
    {
        accum = accum * 10 + (*pc - '0');
        pc++;
    }

    *pi = accum;
    return TRUE;
}


/*Simple types--------------------------------------------------------------*/

/* ETN */
#ifdef DEBUG
void  ETN::Set(int rIn){
    Init();
    r = rIn;
}
int ETN::Get(){
    return r;
}
#endif

ETN* ETN::Duplicate(){
    ETN *pETN=new ETN;
    if (fIsInit()) pETN->Set(Get());
    return pETN;
}


/* ETB */
#ifdef DEBUG
BOOL ETB::Get()
{
    ASSERT(fIsInit());
    return m_nFlags & ETB_VALUE;
}

void ETB::Set(BOOL b)
{
    m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0);
}
#endif

ETB* ETB::Duplicate()
{
    ASSERT(fIsInit());

    ETB *pETB = new ETB;
    if (pETB != NULL)
        pETB->m_nFlags = m_nFlags;
    return pETB;
}

/* ETS */

ETS::~ETS()
{
    if (pc != NULL) {
        delete pc;
        pc = NULL;
    }
}

#ifdef DEBUG
char* ETS::Get()
{
//    ASSERT(fIsInit()); 
    return pc;
}
#endif

void ETS::Set(const char *pIn)
{
    if (pc != NULL)
        delete pc;

    if (pIn != NULL) {
        pc = new char[strlenf(pIn) + 1];
        if (pc != NULL) {
            strcpyf(pc, pIn);
        }
    }
    else {
        pc = NULL;
    }
}


void ETS::SetTo(char *pIn)
{
    if (pc != NULL)
        delete pc;

    pc = pIn;
}


ETS* ETS::Duplicate()
{
    ETS *pETS=new ETS;
    if (pETS != NULL)
        pETS->Set(Get());
    return pETS;
}


UINT EtBoolRegRead(ETB &etb, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtBoolRegRead() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwSize, dwValue, dwType;
    UINT uErr;

    etb.Set(FALSE);
    
    dwSize = sizeof(dwValue);

    uErr = RegQueryValueEx(hKey, pKeyWord, NULL, &dwType, 
                            (LPBYTE)&dwValue, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
       if ((dwType == REG_DWORD) && (dwValue != 0))
           etb.Set(TRUE);
    }
    else
    {
        TraceMsg( TF_WARNING, "EtBoolRegRead() - Failed to read pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}

UINT EtBoolRegWrite(ETB &etb, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtBoolRegWrite() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    UINT uErr;
    DWORD dwNum = (etb.fIsInit() && etb.Get());

    uErr = RegSetValueEx(hKey, pKeyWord, 0, REG_DWORD, (LPBYTE)&dwNum, sizeof(dwNum));

    if ( uErr != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "EtBoolRegWrite() - Failed to set pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}


UINT EtStringRegRead(ETS &ets, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtStringRegRead() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwSize;
    UINT uErr;
    char szTemp[80];        /* default size */

    dwSize = sizeof(szTemp);

    uErr = RegQueryValueEx(hKey, pKeyWord, NULL, NULL, 
                            (LPBYTE)szTemp, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
        ets.Set(szTemp);
    }
    else if (uErr == ERROR_MORE_DATA)
    {
        char *pszTemp = new char[dwSize];
        if (pszTemp == NULL)
        {
            TraceMsg( TF_WARNING, "EtStringRegRead() - Failed to allocate dwSize=%d memory!", dwSize );
            uErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            uErr = RegQueryValueEx(hKey, pKeyWord, NULL, NULL, (LPBYTE)pszTemp,
                                   &dwSize);
            if (uErr == ERROR_SUCCESS)
            {
                ets.SetTo(pszTemp);
                /* ets now owns pszTemp memory, don't delete it here */
            }
            else
            {
                TraceMsg( TF_WARNING, "EtStringRegRead() - Failed to read (dwSize %d) pKeyWord='%s'!", dwSize, pKeyWord );
                delete pszTemp;
                pszTemp = NULL;
            }
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "EtStringRegRead() - Failed to read pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}

UINT EtStringRegWrite(ETS &ets, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtStringRegWrite() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    UINT uErr = ERROR_SUCCESS;

    if (ets.fIsInit())
    {
        uErr = RegSetValueEx(hKey, pKeyWord, 0, REG_SZ, (LPBYTE)ets.Get(), strlenf(ets.Get())+1);

        if ( uErr != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "EtStringRegWrite() - Failed to set pKeyWord='%s' with ets='%s'!", pKeyWord, ets.Get() );
        }
    }
    else
    {
        TraceMsg( TF_ERROR, "EtStringRegWrite() - ETS is not initialized!" );
    }

    return uErr;
}
                     

UINT EtNumRegRead(ETN &etn, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtNumRegRead() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwSize, dwType;
    int nValue;
    UINT uErr;

    dwSize = sizeof(nValue);

    uErr = RegQueryValueEx(hKey, pKeyWord, NULL, &dwType, 
                            (LPBYTE)&nValue, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
        etn.Set(nValue);
    }
    else
    {
        TraceMsg( TF_WARNING, "EtNumRegRead() - Failed to read pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}

UINT EtNumRegWrite(ETN &etn, HKEY hKey, char *pKeyWord)
{
    UINT uErr = ERROR_SUCCESS;

    if (etn.fIsInit())
    {
        int nTemp;
        nTemp = etn.Get();
        uErr = RegSetValueEx(hKey, pKeyWord, 0, REG_DWORD, (LPBYTE)&nTemp, sizeof(nTemp));

        if ( uErr != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "EtNumRegWrite() - Failed to set pKeyWord='%s' with nTemp=%d!", pKeyWord, nTemp );
        }
    }
    else
    {
        TraceMsg( TF_ERROR, "EtNumRegWrite() - ETS is not initialized!" );
    }

    return uErr;
}


/*PicsDefault---------------------------------------------------------------*/

PicsDefault::PicsDefault()
{
    /* nothing to do but construct members */
}

PicsDefault::~PicsDefault()
{
    /* nothing to do but destruct members */
}

/*PicsEnum------------------------------------------------------------------*/

PicsEnum::PicsEnum()
{
    /* nothing to do but construct members */
}

PicsEnum::~PicsEnum()
{
    /* nothing to do but destruct members */
}

/*PicsCategory--------------------------------------------------------------*/

PicsCategory::PicsCategory()
{
    /* nothing to do but construct members */
}

PicsCategory::~PicsCategory()
{
    arrpPC.DeleteAll();
    arrpPE.DeleteAll();
}


/*PicsRatingSystem----------------------------------------------------------*/

PicsRatingSystem::PicsRatingSystem()
    : m_pDefaultOptions(NULL),
      dwFlags(0),
      nErrLine(0)
{
    /* nothing to do but construct members */
}

PicsRatingSystem::~PicsRatingSystem()
{
    arrpPC.DeleteAll();
    if (m_pDefaultOptions != NULL)
    {
        delete m_pDefaultOptions;
        m_pDefaultOptions = NULL;
    }
}

void PicsRatingSystem::ReportError(HRESULT hres)
{
    NLS_STR nls1(etstrFile.Get());
    if (!nls1.QueryError())
    {
        ISTR istrMarker(nls1);
        if (nls1.strchr(&istrMarker, '*'))
        {
            nls1.DelSubStr(istrMarker);
        }
    }
    else
    {
        nls1 = szNULL;
    }

    UINT idMsg, idTemplate;

    NLS_STR nlsBaseMessage(MAX_RES_STR_LEN);
    char szNumber[16];            /* big enough for a 32-bit (hex) number */

    if (hres == E_OUTOFMEMORY || (hres > RAT_E_BASE && hres <= RAT_E_BASE + 0xffff)) {
        idTemplate = IDS_LOADRAT_SYNTAX_TEMPLATE;    /* default is ratfile content error */
        switch (hres)
        {
        case E_OUTOFMEMORY:
            idMsg = IDS_LOADRAT_MEMORY;
            idTemplate = IDS_LOADRAT_GENERIC_TEMPLATE;
            break;
        case RAT_E_EXPECTEDLEFT:
            idMsg = IDS_LOADRAT_EXPECTEDLEFT;
            break;
        case RAT_E_EXPECTEDRIGHT:
            idMsg = IDS_LOADRAT_EXPECTEDRIGHT;
            break;
        case RAT_E_EXPECTEDTOKEN:
            idMsg = IDS_LOADRAT_EXPECTEDTOKEN;
            break;
        case RAT_E_EXPECTEDSTRING:
            idMsg = IDS_LOADRAT_EXPECTEDSTRING;
            break;
        case RAT_E_EXPECTEDNUMBER:
            idMsg = IDS_LOADRAT_EXPECTEDNUMBER;
            break;
        case RAT_E_EXPECTEDBOOL:
            idMsg = IDS_LOADRAT_EXPECTEDBOOL;
            break;
        case RAT_E_DUPLICATEITEM:
            idMsg = IDS_LOADRAT_DUPLICATEITEM;
            break;
        case RAT_E_MISSINGITEM:
            idMsg = IDS_LOADRAT_MISSINGITEM;
            break;
        case RAT_E_UNKNOWNITEM:
            idMsg = IDS_LOADRAT_UNKNOWNITEM;
            break;
        case RAT_E_UNKNOWNMANDATORY:
            idMsg = IDS_LOADRAT_UNKNOWNMANDATORY;
            break;
        case RAT_E_EXPECTEDEND:
            idMsg = IDS_LOADRAT_EXPECTEDEND;
            break;
        default:
            ASSERT(FALSE);        /* there aren't any other RAT_E_ errors  */
            idMsg = IDS_LOADRAT_UNKNOWNERROR;
            break;
        }

        wsprintf(szNumber, "%d", nErrLine);
        NLS_STR nlsNumber(STR_OWNERALLOC, szNumber);

        const NLS_STR *apnls[] = { &nlsNumber, NULL };
        nlsBaseMessage.LoadString((USHORT)idMsg, apnls);
    }
    else
    {
        idTemplate = IDS_LOADRAT_GENERIC_TEMPLATE;
        if (HRESULT_FACILITY(hres) == FACILITY_WIN32)
        {
            wsprintf(szNumber, "%d", HRESULT_CODE(hres));
            idMsg = IDS_LOADRAT_WINERROR;
        }
        else
        {
            wsprintf(szNumber, "0x%x", hres);
            idMsg = IDS_LOADRAT_MISCERROR;
        }
        NLS_STR nls1(STR_OWNERALLOC, szNumber);
        const NLS_STR *apnls[] = { &nls1, NULL };
        nlsBaseMessage.LoadString((USHORT)idMsg, apnls);
    }

    NLS_STR nlsMessage(MAX_RES_STR_LEN);
    const NLS_STR *apnls[] = { &nls1, &nlsBaseMessage, NULL };
    nlsMessage.LoadString((USHORT)idTemplate, apnls);
    if (!nlsMessage.QueryError())
    {
        MyMessageBox(NULL, nlsMessage.QueryPch(), IDS_GENERIC, MB_OK | MB_ICONWARNING);
    }
}


/*Rating Information--------------------------------------------------------*/
BOOL PicsRatingSystemInfo::LoadProviderFiles(HKEY hKey)
{
    char szFileName[8 + 7 + 1];    /* "Filename" + big number plus null byte */
    ETS  etstrFileName;
    int  index = 0;
   
    EtStringRegRead(etstrRatingBureau, hKey, (char *)szRATINGBUREAU);
   
    wsprintf(szFileName, szFilenameTemplate, index);
    while (EtStringRegRead(etstrFileName, hKey, szFileName) == ERROR_SUCCESS) 
    {
        PicsRatingSystem *pPRS;
        HRESULT hres = LoadRatingSystem(etstrFileName.Get(), &pPRS);
        if (pPRS != NULL)
        {
            arrpPRS.Append(pPRS);

            /* If the thing has a pathname, write it back out to the policy
             * file, in case loading the rating system marked it as invalid
             * (or it had been marked as invalid, but the user fixed things
             * and it's OK now).
             */
            if (pPRS->etstrFile.fIsInit())
            {
                /* If the rating system is not valid and was not previously
                 * marked invalid, then report the error to the user.
                 * LoadRatingSystem will have already marked the filename
                 * as invalid for us.
                 */
                if ((pPRS->dwFlags & (PRS_ISVALID | PRS_WASINVALID)) == 0)
                {
                    pPRS->ReportError(hres);    /* report error to user */
                }
                EtStringRegWrite(pPRS->etstrFile, hKey, szFileName);
            }
        }

        index++;
        wsprintf(szFileName, szFilenameTemplate, index);
    }

    return arrpPRS.Length() != 0;
}


BOOL RunningOnNT()
{
    return !(::GetVersion() & 0x80000000);
}


// Verify the Registry Key for the Ratings can be opened with full access.
// This is only useful if the Ratings registry key has been previously created.
bool IsRegistryModifiable( HWND p_hwndParent )
{
    bool            fReturn = false;
    CRegKey         regKey;

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS, KEY_ALL_ACCESS ) == ERROR_SUCCESS )
    {
        fReturn = true;
    }
    else
    {
        TraceMsg( TF_WARNING, "IsRegistryModifiable() - Failed to Create Registry Key Ratings for Full Access!" );

        MyMessageBox( p_hwndParent, IDS_REGISTRY_NOT_MODIFIABLE, IDS_GENERIC, MB_OK|MB_ICONERROR);
    }

    return fReturn;
}

SID_IDENTIFIER_AUTHORITY siaNTAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY siaWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

class CSecurityAttributes
{
private:
    SECURITY_ATTRIBUTES m_sa;
    LPSECURITY_ATTRIBUTES m_lpsa;
    PSECURITY_DESCRIPTOR m_psd;
    PACL m_pACL;
    PSID m_psidAdmins;
    PSID m_psidWorld;
    UINT m_cbACL;                /* default ACL size */

public:
    CSecurityAttributes()
    {
        m_lpsa = NULL;
        m_psd = NULL;
        m_pACL = NULL;
        m_psidAdmins = NULL;
        m_psidWorld = NULL;
        m_cbACL = 1024;
    }

    ~CSecurityAttributes()
    {
        if ( m_psidAdmins != NULL )
        {
            FreeSid(m_psidAdmins);
            m_psidAdmins = NULL;
        }

        if ( m_psidWorld )
        {
            FreeSid(m_psidWorld);
            m_psidWorld = NULL;
        }

        if ( m_psd )
        {
            MemFree(m_psd);
            m_psd = NULL;
        }

        if ( m_pACL )
        {
            MemFree(m_pACL);
            m_pACL = NULL;
        }
    }

    LPSECURITY_ATTRIBUTES GetSecurityAttributes( void )
    {
        return m_lpsa;
    }

    bool AllocateSecurityAttributes( void )
    {
        m_psd = (PSECURITY_DESCRIPTOR)MemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (m_psd == NULL ||
            !InitializeSecurityDescriptor(m_psd, SECURITY_DESCRIPTOR_REVISION))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed Security Descriptor Allocation!" );
            return false;
        }

        m_pACL = (PACL)MemAlloc(m_cbACL);
        if (m_pACL == NULL || !InitializeAcl(m_pACL, m_cbACL, ACL_REVISION2))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed ACL Initialization!" );
            return false;
        }

        if (!AllocateAndInitializeSid(&siaNTAuthority,
                2,                                /* number of subauthorities */
                SECURITY_BUILTIN_DOMAIN_RID,    /* first subauthority: this domain */
                DOMAIN_ALIAS_RID_ADMINS,        /* second: admins local group */
                0, 0, 0, 0, 0, 0,                /* unused subauthorities */
                &m_psidAdmins))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed NT Authority Initialization!" );
            return false;
        }

        if (!AllocateAndInitializeSid(&siaWorldAuthority,
                1,                                /* number of subauthorities */
                SECURITY_WORLD_RID,                /* first subauthority: all users */
                0, 0, 0, 0, 0, 0, 0,            /* unused subauthorities */
                &m_psidWorld))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed World Authority Initialization!" );
            return false;
        }

        if (!AddAccessAllowedAce(m_pACL, ACL_REVISION2, KEY_ALL_ACCESS, m_psidAdmins) ||
            !AddAccessAllowedAce(m_pACL, ACL_REVISION2, KEY_READ, m_psidWorld))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed Admins or World Access!" );
            return false;
        }

        ACE_HEADER *pAce;

        /* Make both ACEs inherited by subkeys created later */
        if (GetAce(m_pACL, 0, (LPVOID *)&pAce))
        {
            pAce->AceFlags |= CONTAINER_INHERIT_ACE;
        }

        if (GetAce(m_pACL, 1, (LPVOID *)&pAce))
        {
            pAce->AceFlags |= CONTAINER_INHERIT_ACE;
        }

        if (!SetSecurityDescriptorDacl(m_psd,
            TRUE,            /* fDaclPresent */
            m_pACL,
            FALSE))            /* not a default discretionary ACL */
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed Set of Security Descriptor!" );
            return false;
        }

        m_sa.nLength = sizeof(m_sa);
        m_sa.lpSecurityDescriptor = m_psd;
        m_sa.bInheritHandle = FALSE;

        m_lpsa = &m_sa;

        return true;
    }
};

// The following first attempts to open an existing registry key.
// If the key cannot be opened, the key is created.
// Under NT, the key is created with Admin read-write access and World read-only access.
// Under 9x, the key is created with no special security attributes.
HKEY CreateRegKeyNT(LPCSTR pszKey)
{
    HKEY hKey = NULL;
    LONG err = RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hKey);
    if (err == ERROR_SUCCESS)
    {
        TraceMsg( TF_ALWAYS, "CreateRegKeyNT() - Successfully Opened Ratings Registry Key." );
        return hKey;
    }

    CSecurityAttributes         sa;

    if (RunningOnNT())
    {
        if ( ! sa.AllocateSecurityAttributes() )
        {
            TraceMsg( TF_ERROR, "CreateRegKeyNT() - Failed to allocate security attributes()!" );
            return NULL;
        }
    }

    DWORD dwDisp;
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKey, NULL, "",
                       REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, sa.GetSecurityAttributes(),
                       &hKey, &dwDisp) != ERROR_SUCCESS)
    {
        TraceMsg( TF_ERROR, "CreateRegKeyNT() - Failed Registry Key Creation with %s Security Attributes!", sa.GetSecurityAttributes() ? "<sa>" : "<NULL>" );
        hKey = NULL;
    }

    return hKey;
}

HKEY PicsRatingSystemInfo::GetUserProfileKey( void )
{
    HKEY            hkeyUser = NULL;

    // HKLM\System\CurrentControlSet\Control\Update
    RegEntry re(szPOLICYKEY, HKEY_LOCAL_MACHINE);

    // UpdateMode
    if (re.GetNumber(szPOLICYVALUE) != 0)
    {
        // HKLM\Network\Logon
        RegEntry reLogon(szLogonKey, HKEY_LOCAL_MACHINE);

        // UserProfiles
        if (reLogon.GetNumber(szUserProfiles) != 0)
        {
            /* The ratings key has the supervisor password and maybe other
             * settings.  To see if there are other settings here, try to
             * find the user subkey (".Default").  If it's not there, we'll
             * try a policy file.
             */

            // HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Ratings
            if (RegOpenKey(HKEY_LOCAL_MACHINE, szRATINGS, &hkeyUser) == ERROR_SUCCESS)
            {
                HKEY hkeyTemp;

                // .Default
                if (RegOpenKey(hkeyUser, szDefaultUserName, &hkeyTemp) == ERROR_SUCCESS)
                {
                    RegCloseKey(hkeyTemp);
                    hkeyTemp = NULL;
                }
                else
                {
                    TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - Failed to Open key szDefaultUserName='%s'!", szDefaultUserName );
                    RegCloseKey(hkeyUser);
                    hkeyUser = NULL;
                }
            }
            else
            {
                TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - Failed to Open key szRATINGS='%s'!", szRATINGS );
            }
        }
        else
        {
            TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - No key szLogonKey='%s' szUserProfiles='%s'!", szLogonKey, szUserProfiles );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - No key szPOLICYKEY='%s' szPOLICYVALUE='%s'!", szPOLICYKEY, szPOLICYVALUE );
    }

    return hkeyUser;
}

BOOL PicsRatingSystemInfo::Init( void )
{
    PicsUser    *pPU = NULL;

    BOOL        fRet = TRUE;
    BOOL        fIsNT;
    HKEY        hkeyUser = NULL;
    CRegistryHive   rh;

    fRatingInstalled = FALSE;
    pUserObject = NULL;

    fIsNT = RunningOnNT();

    if (fIsNT)
    {
        hkeyUser = CreateRegKeyNT(::szRATINGS);
        fStoreInRegistry = TRUE;
    }
    else
    {
        hkeyUser = GetUserProfileKey();

        if (hkeyUser != NULL)
        {
            fStoreInRegistry = TRUE;
        }
        else
        {
            fStoreInRegistry = FALSE;

            if ( rh.OpenHiveFile( false ) )
            {
                hkeyUser = rh.GetHiveKey();
            }
        }
    }

    // read information from whatever key we opened
    if (hkeyUser != NULL)
    {
        //First load the rating files, then load the user names.
        fRatingInstalled = LoadProviderFiles(hkeyUser);

        if ( fRatingInstalled )
        {
            TraceMsg( TF_ALWAYS, "PicsRatingSystemInfo::Init() - Ratings Installed!" );
        }
        else
        {
            TraceMsg( TF_ALWAYS, "PicsRatingSystemInfo::Init() - Ratings Not Installed!" );
        }

        pPU = new PicsUser;
        if (pPU != NULL)
        {
            pPU->ReadFromRegistry(hkeyUser, (char *)szDefaultUserName);
            pUserObject = pPU;
        }
        else
        {
            fRet = FALSE;
        }

        RegCloseKey(hkeyUser);
        hkeyUser = NULL;

        /* Make sure the user settings have defaults for all installed
         * rating systems.
         */
        for (int i=0; i<arrpPRS.Length(); i++)
        {
            CheckUserSettings(arrpPRS[i]);
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "PicsRatingSystemInfo::Init() - hkeyUser is NULL!" );
    }

    rh.UnloadHive();

    /* Check to see if there is a supervisor password set.  If there is,
     * but we have no settings, then someone's been tampering.
     */
    if ( SUCCEEDED( VerifySupervisorPassword() ) && ! fRatingInstalled )
    {
        MyMessageBox(NULL, IDS_NO_SETTINGS, IDS_GENERIC, MB_OK | MB_ICONSTOP);

        // Clear out the password to allow the user to modify the ratings.
        RemoveSupervisorPassword();

        fSettingsValid = FALSE;
    }
    else
    {
        fSettingsValid = TRUE;
    }

    return fRet;
}

BOOL PicsRatingSystemInfo::FreshInstall()
{
    PicsUser    *pPU = NULL;

    pPU = new PicsUser;
    if (pPU != NULL)
    {
        pPU->NewInstall();

        pUserObject = pPU;

        fRatingInstalled = TRUE;    // we have settings now
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

extern HANDLE g_hsemStateCounter;   // created at process attatch time

long GetStateCounter()
{
    long count;

    if (ReleaseSemaphore(g_hsemStateCounter, 1, &count))    // poll and bump the count
    {
        WaitForSingleObject(g_hsemStateCounter, 0);         // reduce the count
    }
    else
    {
        count = -1;
    }

    return count;
}

void BumpStateCounter()
{
    ReleaseSemaphore(g_hsemStateCounter, 1, NULL);      // bump the count
}

// check the global semaphore count to see if we need to reconstruct our
// state. 

void CheckGlobalInfoRev(void)
{
    ENTERCRITICAL;

    if (gPRSI != NULL && !g_fIsRunningUnderCustom)
    { // do not reinit if under Custom

        if (gPRSI->nInfoRev != GetStateCounter())
        {
            delete gPRSI;
            gPRSI = new PicsRatingSystemInfo;
            if (gPRSI != NULL)
            {
                gPRSI->Init();
            }
            CleanupRatingHelpers();
            InitRatingHelpers();
        }
    }

    LEAVECRITICAL;
}

void PicsRatingSystemInfo::SaveRatingSystemInfo()
{
    int z;
    HKEY hkeyUser = NULL;
    CRegistryHive       rh;
    char szFileName[MAXPATHLEN];

    if (!fSettingsValid || !fRatingInstalled)
    {
        TraceMsg( TF_WARNING, "PicsRatingSystemInfo::SaveRatingSystemInfo() - Ratings are not installed!" );
        return;                /* ratings aren't installed, nothing to save */
    }

    // load the hive file
    if (fStoreInRegistry)
    {
        hkeyUser = CreateRegKeyNT(::szRATINGS);
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            hkeyUser = rh.GetHiveKey();
        }
    }

    // read information from local registry
    if (hkeyUser != NULL)
    {
        if (etstrRatingBureau.fIsInit())
        {
            EtStringRegWrite(etstrRatingBureau, hkeyUser, (char *)szRATINGBUREAU);
        }
        else
        {
            RegDeleteValue(hkeyUser, szRATINGBUREAU);
        }    

        for (z = 0; z < arrpPRS.Length(); ++z)
        {
            wsprintf(szFileName, szFilenameTemplate, z);
            EtStringRegWrite(arrpPRS[z]->etstrFile, hkeyUser, szFileName);
        }

        // Delete the next one, as a safety precaution
        wsprintf(szFileName, szFilenameTemplate, z);
        RegDeleteValue(hkeyUser, szFileName);

        pUserObject->WriteToRegistry(hkeyUser);

        RegCloseKey(hkeyUser);
        hkeyUser = NULL;
    }
    else
    {
        TraceMsg( TF_ERROR, "PicsRatingSystemInfo::SaveRatingSystemInfo() - hkeyUser is NULL!" );
    }

    BumpStateCounter();
    nInfoRev = GetStateCounter();
}


HRESULT LoadRatingSystem(LPCSTR pszFilename, PicsRatingSystem **pprsOut)
{
    TraceMsg( TF_ALWAYS, "LoadRatingSystem() - Loading Rating System '%s'...", pszFilename );

    PicsRatingSystem *pPRS = new PicsRatingSystem;

    *pprsOut = pPRS;
    if (pPRS == NULL)
    {
        TraceMsg( TF_ERROR, "LoadRatingSystem() - pPRS is NULL!" );
        return E_OUTOFMEMORY;
    }

    UINT cbFilename = strlenf(pszFilename) + 1 + 1;    /* room for marker character */
    LPSTR pszNameCopy = new char[cbFilename];
    if (pszNameCopy == NULL)
    {
        TraceMsg( TF_ERROR, "LoadRatingSystem() - pszNameCopy is NULL!" );
        return E_OUTOFMEMORY;
    }

    strcpyf(pszNameCopy, pszFilename);
    pPRS->etstrFile.SetTo(pszNameCopy);

    LPSTR pszMarker = strchrf(pszNameCopy, '*');
    if (pszMarker != NULL) {                /* ended in marker character... */
        ASSERT(*(pszMarker+1) == '\0');
        pPRS->dwFlags |= PRS_WASINVALID;    /* means it failed last time */
        *pszMarker = '\0';                    /* strip marker for loading */
    }

    HRESULT hres;

    HANDLE hFile = CreateFile(pszNameCopy, GENERIC_READ,
                              FILE_SHARE_READ, NULL, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbFile = ::GetFileSize(hFile, NULL);
        BUFFER bufData(cbFile + 1);
        if (bufData.QueryPtr() != NULL)
        {
            LPSTR pszData = (LPSTR)bufData.QueryPtr();
            DWORD cbRead;
            if (ReadFile(hFile, pszData, cbFile, &cbRead, NULL))
            {
                pszData[cbRead] = '\0';        /* null terminate whole file */

                hres = pPRS->Parse(pszFilename, pszData);
                if (SUCCEEDED(hres))
                {
                    pPRS->dwFlags |= PRS_ISVALID;
                }
                else
                {
                    TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed Parse with hres=0x%x!", hres );
                }
            }
            else
            {
                hres = HRESULT_FROM_WIN32(::GetLastError());
                TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed ReadFile() with hres=0x%x!", hres );
            }

            CloseHandle(hFile);
        }
        else
        {
            hres = E_OUTOFMEMORY;
            TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed Buffer Allocation with cbFile=%d!", cbFile );
        }
    }
    else
    {
        hres = HRESULT_FROM_WIN32(::GetLastError());
        TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed CreateFile() with hres=0x%x!", hres );
    }

    if (!(pPRS->dwFlags & PRS_ISVALID))
    {
        TraceMsg( TF_ALWAYS, "LoadRatingSystem() - Failed Loaded Rating System '%s' (hres=0x%x)!", pszFilename, hres );

        strcatf(pszNameCopy, "*");            /* mark filename as invalid */
    }
    else
    {
        TraceMsg( TF_ALWAYS, "LoadRatingSystem() - Successfully Loaded Rating System '%s'.", pszFilename );
    }

    return hres;
}

// constructor for CustomRatingHelper

CustomRatingHelper::CustomRatingHelper()
{
    hLibrary = NULL;
    pNextHelper = NULL;
    dwSort = 0;
}

CustomRatingHelper::~CustomRatingHelper()
{
    if (hLibrary)
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    pNextHelper = NULL;
}


// a little function to convert from ANSI to Unicode

HRESULT Ansi2Unicode(LPWSTR *pdest, LPCSTR src)
{
    UINT cbSize;

    cbSize = MultiByteToWideChar(CP_ACP, 0, src, -1, NULL, 0);
    if (cbSize > 0)
    {
        *pdest = new WCHAR[cbSize+1];
        cbSize = MultiByteToWideChar(CP_ACP, 0, src, -1, *pdest, cbSize+1);
    }
    return cbSize > 0 ? S_OK : E_FAIL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\mslubase.h ===
/****************************************************************************\
 *
 *   PICS.H --Structures for holding pics information
 *
 *   Created:   Jason Thomas
 *   Updated:   Ann McCurdy
 *   
\****************************************************************************/

#ifndef _PICS_H_
#define _PICS_H_

/*Includes---------------------------------------------------------*/
#include <npassert.h>
#include "array.h"
#include "resource.h"
#include "msluglob.h"
#include <ratings.h>

extern HKEY CreateRegKeyNT(LPCSTR pszKey);
extern BOOL RunningOnNT(void);

extern char PicsDelimChar;

#define PICS_FILE_BUF_LEN   20000
#define PICS_STRING_BUF_LEN  1000

#define P_INFINITY           9999
#define N_INFINITY          -9999

/*Simple PICS types------------------------------------------------*/

class ETN
{
    private:
        int r;
        BOOL m_fInit;
    public:
        ETN() { m_fInit = FALSE; }

        void Init() { m_fInit = TRUE; }
        void UnInit() { m_fInit = FALSE; }
        BOOL fIsInit() { return m_fInit; }

#ifdef DEBUG
        void  Set(int rIn);
        int Get();
#else
        void  Set(int rIn) { Init(); r = rIn; }
        int Get() { return r; }
#endif

        ETN*  Duplicate();
};

const UINT ETB_VALUE = 0x01;
const UINT ETB_ISINIT = 0x02;
class ETB
{
    private:
        UINT m_nFlags;
    public:
        ETB() { m_nFlags = 0; }

#ifdef DEBUG
        BOOL Get();
        void Set(BOOL b);
#else
        BOOL Get() { return m_nFlags & ETB_VALUE; }
        void Set(BOOL b) { m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0); }
#endif

        ETB   *Duplicate();
        BOOL fIsInit() { return m_nFlags & ETB_ISINIT; }
};

class ETS
{
    private:
        char *pc;
    public:
        ETS() { pc = NULL; }
        ~ETS();
#ifdef DEBUG
        char* Get();
#else
        char *Get() { return pc; }
#endif
        void  Set(const char *pIn);
        ETS*  Duplicate();
        void  SetTo(char *pIn);

        BOOL fIsInit() { return pc != NULL; }
};

extern UINT EtBoolRegRead(ETB &etb, HKEY hKey, char *pKeyWord);
extern UINT EtBoolRegWrite(ETB &etb, HKEY hKey, char *pKeyWord);
extern UINT EtStringRegRead(ETS &ets, HKEY hKey, char *pKeyWord);
extern UINT EtStringRegWrite(ETS &ets, HKEY hKey, char *pKeyWord);
extern UINT EtNumRegRead(ETN &etn, HKEY hKey, char *pKeyWord);
extern UINT EtNumRegWrite(ETN &etn, HKEY hKey, char *pKeyWord);


/*Complex PICS types-----------------------------------------------*/


enum RatObjectID
{
    ROID_INVALID,           /* dummy entry for terminating arrays */
    ROID_PICSDOCUMENT,      /* value representing the entire document (i.e., no token) */
    ROID_PICSVERSION,
    ROID_RATINGSYSTEM,
    ROID_RATINGSERVICE,
    ROID_RATINGBUREAU,
    ROID_BUREAUREQUIRED,
    ROID_CATEGORY,
    ROID_TRANSMITAS,
    ROID_LABEL,
    ROID_VALUE,
    ROID_DEFAULT,
    ROID_DESCRIPTION,
    ROID_EXTENSION,
    ROID_MANDATORY,
    ROID_OPTIONAL,
    ROID_ICON,
    ROID_INTEGER,
    ROID_LABELONLY,
    ROID_MAX,
    ROID_MIN,
    ROID_MULTIVALUE,
    ROID_NAME,
    ROID_UNORDERED
};

enum PICSRulesObjectID
{
    PROID_INVALID,                  /* dummy entry for terminating arrays */
    PROID_PICSVERSION,              /* for holding the PICSRules version ID */
    
    PROID_POLICY,                   /* for the Policy class */
        PROID_EXPLANATION,
        PROID_REJECTBYURL,
        PROID_ACCEPTBYURL,
        PROID_REJECTIF,
        PROID_ACCEPTIF,
        PROID_ACCEPTUNLESS,
        PROID_REJECTUNLESS,
    PROID_NAME,                     /* for the name class */
        PROID_RULENAME,
        PROID_DESCRIPTION,
    PROID_SOURCE,                   /* for the source class */
        PROID_SOURCEURL,
        PROID_CREATIONTOOL,
        PROID_AUTHOR,
        PROID_LASTMODIFIED,
    PROID_SERVICEINFO,              /* for the serviceinfo class */
        PROID_SINAME,
        PROID_SHORTNAME,
        PROID_BUREAUURL,
        PROID_USEEMBEDDED,
        PROID_RATFILE,
        PROID_BUREAUUNAVAILABLE,
    PROID_OPTEXTENSION,             /* for the optextension class */
        PROID_EXTENSIONNAME,
      //PROID_SHORTNAME,
    PROID_REQEXTENSION,
      //PROID_EXTENSIONNAME,
      //PROID_SHORTNAME,
    PROID_EXTENSION,

    PROID_POLICYDEFAULT,
    PROID_NAMEDEFAULT,
    PROID_SOURCEDEFAULT,
    PROID_SERVICEINFODEFAULT,
    PROID_OPTEXTENSIONDEFAULT,
    PROID_REQEXTENSIONDEFAULT
};

/* define some error codes */
const HRESULT RAT_E_BASE = 0x80050000;                  /* just a guess at a free area for internal use */
const HRESULT RAT_E_EXPECTEDLEFT    = RAT_E_BASE + 1;   /* expected left paren */
const HRESULT RAT_E_EXPECTEDRIGHT   = RAT_E_BASE + 2;   /* expected right paren */
const HRESULT RAT_E_EXPECTEDTOKEN   = RAT_E_BASE + 3;   /* expected unquoted token */
const HRESULT RAT_E_EXPECTEDSTRING  = RAT_E_BASE + 4;   /* expected quoted string */
const HRESULT RAT_E_EXPECTEDNUMBER  = RAT_E_BASE + 5;   /* expected number */
const HRESULT RAT_E_EXPECTEDBOOL    = RAT_E_BASE + 6;   /* expected boolean */
const HRESULT RAT_E_DUPLICATEITEM   = RAT_E_BASE + 7;   /* AO_SINGLE item appeared twice */
const HRESULT RAT_E_MISSINGITEM     = RAT_E_BASE + 8;   /* AO_MANDATORY item not found */
const HRESULT RAT_E_UNKNOWNITEM     = RAT_E_BASE + 9;   /* unrecognized token */
const HRESULT RAT_E_UNKNOWNMANDATORY= RAT_E_BASE + 10;  /* unrecognized mandatory extension */
const HRESULT RAT_E_EXPECTEDEND     = RAT_E_BASE + 11;  /* expected end of file */

/* echo for PICSRules with different names for clarity */
const HRESULT PICSRULES_E_BASE              = 0x80050000;       /* just a guess at a free area for internal use */
const HRESULT PICSRULES_E_EXPECTEDLEFT      = RAT_E_BASE + 1;   /* expected left paren */
const HRESULT PICSRULES_E_EXPECTEDRIGHT     = RAT_E_BASE + 2;   /* expected right paren */
const HRESULT PICSRULES_E_EXPECTEDTOKEN     = RAT_E_BASE + 3;   /* expected unquoted token */
const HRESULT PICSRULES_E_EXPECTEDSTRING    = RAT_E_BASE + 4;   /* expected quoted string */
const HRESULT PICSRULES_E_EXPECTEDNUMBER    = RAT_E_BASE + 5;   /* expected number */
const HRESULT PICSRULES_E_EXPECTEDBOOL      = RAT_E_BASE + 6;   /* expected boolean */
const HRESULT PICSRULES_E_DUPLICATEITEM     = RAT_E_BASE + 7;   /* AO_SINGLE item appeared twice */
const HRESULT PICSRULES_E_MISSINGITEM       = RAT_E_BASE + 8;   /* AO_MANDATORY item not found */
const HRESULT PICSRULES_E_UNKNOWNITEM       = RAT_E_BASE + 9;   /* unrecognized token */
const HRESULT PICSRULES_E_UNKNOWNMANDATORY  = RAT_E_BASE + 10;  /* unrecognized mandatory extension */
const HRESULT PICSRULES_E_EXPECTEDEND       = RAT_E_BASE + 11;  /* expected end of file */
const HRESULT PICSRULES_E_SERVICEUNDEFINED  = RAT_E_BASE + 12;  /* a service referenced is undefined */
const HRESULT PICSRULES_E_REQEXTENSIONUSED  = RAT_E_BASE + 13;  /* an unknown required extension was used */
const HRESULT PICSRULES_E_VERSION           = RAT_E_BASE + 14;  /* a non-support version was presented */

/* A RatObjectHandler parses the contents of a parenthesized object and
 * spits out a binary representation of that data, suitable for passing
 * to an object's AddItem function.  It does not consume the ')' which
 * closes the object.
 */
class RatFileParser;
typedef HRESULT (*RatObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser);

class PICSRulesFileParser;
typedef HRESULT (*PICSRulesObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);

class PicsCategory;

class PicsObjectBase
{
public:
    virtual HRESULT AddItem(RatObjectID roid, LPVOID pData) = 0;
    virtual HRESULT InitializeMyDefaults(PicsCategory *pCategory) = 0;
};

class PICSRulesObjectBase
{
public:
    virtual HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData) = 0;
    virtual HRESULT InitializeMyDefaults() = 0;
};

const DWORD AO_SINGLE = 0x01;
const DWORD AO_SEEN = 0x02;
const DWORD AO_MANDATORY = 0x04;

struct AllowableOption
{
    RatObjectID roid;
    DWORD fdwOptions;
};

struct PICSRulesAllowableOption
{
    PICSRulesObjectID roid;
    DWORD fdwOptions;
};

class PicsEnum : public PicsObjectBase
{
    private:
    public:
        ETS etstrName, etstrIcon, etstrDesc;
        ETN etnValue;

        PicsEnum();
        ~PicsEnum();
//        char* Parse(char *pStreamIn);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};

class PicsRatingSystem;

class PicsCategory : public PicsObjectBase
{
    private:
    public:
        array<PicsCategory*> arrpPC;
        array<PicsEnum*>     arrpPE;
        ETS   etstrTransmitAs, etstrName, etstrIcon, etstrDesc;
        ETN   etnMin,   etnMax;
        ETB   etfMulti, etfInteger, etfLabelled, etfUnordered;
        PicsRatingSystem *pPRS;

        PicsCategory();
        ~PicsCategory();
//        char* Parse(char *pStreamIn, char *pBaseName, PicsCategory *pPCparent);
        void FixupLimits();
        void SetParents(PicsRatingSystem *pOwner);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};


class PicsDefault : public PicsObjectBase
{
public:
    ETB etfInteger, etfLabelled, etfMulti, etfUnordered;
    ETN etnMax, etnMin;

    PicsDefault();
    ~PicsDefault();

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};


class PicsExtension : public PicsObjectBase
{
public:
    LPSTR m_pszRatingBureau;

    PicsExtension();
    ~PicsExtension();

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};


class PicsRatingSystem : public PicsObjectBase
{
    private:
    public:
        array<PicsCategory*> arrpPC;
        ETS                  etstrFile, etstrName, etstrIcon, etstrDesc, 
                             etstrRatingService, etstrRatingSystem, etstrRatingBureau;
        ETN                  etnPicsVersion;
        ETB                  etbBureauRequired;
        PicsDefault *        m_pDefaultOptions;
        DWORD                dwFlags;
        UINT                 nErrLine;

        PicsRatingSystem();
        ~PicsRatingSystem();
        HRESULT Parse(LPCSTR pszFile, LPSTR pStreamIn);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        void ReportError(HRESULT hres);
};

/* bit values for PicsRatingSystem::dwFlags */
const DWORD PRS_ISVALID = 0x01;         /* this rating system was loaded successfully */
const DWORD PRS_WASINVALID = 0x02;      /* was invalid last time we tried to load it */

/* echo for PICSRules with different names for clarity */
#define PRRS_ISVALID        PRS_ISVALID;
#define PRRS_WASINVALID     PRS_WASINVALID;

class UserRating : public NLS_STR
{
public:
    INT m_nValue;
    UserRating *m_pNext;
    PicsCategory *m_pPC;

    UserRating();
    UserRating(UserRating *pCopyFrom);
    ~UserRating();

    UserRating *Duplicate(void);
    void SetName(LPCSTR pszName) { *(NLS_STR *)this = pszName; }
};


class UserRatingSystem : public NLS_STR
{
public:
    UserRating *m_pRatingList;
    UserRatingSystem *m_pNext;
    PicsRatingSystem *m_pPRS;

    UserRatingSystem();
    UserRatingSystem(UserRatingSystem *pCopyFrom);
    ~UserRatingSystem();

    UserRating *FindRating(LPCSTR pszTransmitName);
    UINT AddRating(UserRating *pRating);
    UINT ReadFromRegistry(HKEY hkeyProvider);
    UINT WriteToRegistry(HKEY hkey);

    UserRatingSystem *Duplicate(void);
    void SetName(LPCSTR pszName) { *(NLS_STR *)this = pszName; }
};


UserRatingSystem *DuplicateRatingSystemList(UserRatingSystem *pOld);
void DestroyRatingSystemList(UserRatingSystem *pList);
UserRatingSystem *FindRatingSystem(UserRatingSystem *pList, LPCSTR pszName);


class PicsUser{
private:
public:
    NLS_STR nlsUsername; 
    BOOL fAllowUnknowns, fPleaseMom, fEnabled;
    UserRatingSystem *m_pRatingSystems;

    PicsUser();
    ~PicsUser();

    UserRatingSystem *FindRatingSystem(LPCSTR pszSystemName) { return ::FindRatingSystem(m_pRatingSystems, pszSystemName); }
    UINT AddRatingSystem(UserRatingSystem *pRatingSystem);
    BOOL NewInstall();
    UINT ReadFromRegistry(HKEY hkey, char *pszUserName);
    UINT WriteToRegistry(HKEY hkey);
};


PicsUser *GetUserObject(LPCSTR pszUsername=NULL);


extern long GetStateCounter();

class PicsRatingSystemInfo
{
    public:
        array<PicsRatingSystem*> arrpPRS;
        PicsUser *               pUserObject;
        BOOL                     fRatingInstalled;
        ETS                      etstrRatingBureau;
        long                     nInfoRev;
        BOOL                     fStoreInRegistry;
        BOOL                     fSettingsValid;
        PSTR                     lpszFileName;

        PicsRatingSystemInfo() { lpszFileName=NULL; nInfoRev = ::GetStateCounter(); };
        ~PicsRatingSystemInfo();

        BOOL Init();
        BOOL FreshInstall();
        void SaveRatingSystemInfo();
        BOOL LoadProviderFiles(HKEY hKey);

    protected:
        HKEY    GetUserProfileKey( void );
};

extern PicsRatingSystemInfo *gPRSI;

void CheckGlobalInfoRev(void);


char* EtStringParse(ETS &ets, char *pIn, const char *pKeyWord, BOOL fParen);
char* EtLabelParse(char *pIn, const char *pszLongName, const char *pszShortName);
char* EtRatingParse(ETN &etn, ETS &ets, char *pInStream);

int  MyMessageBox(HWND hwnd, UINT uText, UINT uTitle, UINT uType);
int  MyMessageBox(HWND hwnd, UINT uText, UINT uText2, UINT uTitle, UINT uType);
int  MyMessageBox(HWND hwnd, LPCSTR pszText, UINT uTitle, UINT uType);
char *NonWhite(char *pIn);
BOOL MyAtoi(char *pIn, int *i);
LONG MyRegDeleteKey(HKEY hkey,LPCSTR pszSubkey);
HRESULT LoadRatingSystem(LPCSTR pszFilename, PicsRatingSystem **pprsOut);
INT_PTR DoProviderDialog(HWND hDlg, PicsRatingSystemInfo *pPRSI);

void DeleteUserSettings(PicsRatingSystem *pPRS);
void CheckUserSettings(PicsRatingSystem *pPRS);

//
// Declarations for Custom
//
extern g_fIsRunningUnderCustom;

struct CustomRatingHelper
{
    CustomRatingHelper();
    ~CustomRatingHelper();

    HMODULE hLibrary;
    CLSID clsid;
    CustomRatingHelper* pNextHelper;
    DWORD dwSort;
};

/*Pics Tree Dialog Stuff------------------------------------------------------*/
struct PRSD
{
    PicsRatingSystemInfo *pPRSI;
    PicsUser             *pPU;
    UserRatingSystem     *pTempRatings;
    HWND                  hwndBitmapCategory;
    HWND                  hwndBitmapLabel;
    BOOL                  fNewProviders;
};

enum TreeNodeEnum{tneGeneral, tneAccessList, tneRatingSystemRoot, tneRatingSystemInfo, tneRatingSystemNode, tneNone};

struct TreeNode{
    TreeNodeEnum  tne;
    void         *pData;

    TreeNode(){}
    TreeNode(TreeNodeEnum tneInit, void* pDataInit){tne=tneInit;pData=pDataInit;}
};

PicsRatingSystem *FindInstalledRatingSystem(LPCSTR pszRatingService);
PicsCategory *FindInstalledCategory(array<PicsCategory *>&arrpPC, LPCSTR pszName);

HRESULT Ansi2Unicode(LPWSTR *pdest, LPCSTR src);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\msluprop.h ===
/****************************************************************************\
 *
 *   MSLUPROP.H
 *
 *   Created:   William Taylor (wtaylor) 12/14/00
 *
 *   MS Ratings Property Sheet Class
 *   
\****************************************************************************/

#ifndef MSLU_PROPSHEET_H
#define MSLU_PROPSHEET_H

struct PRSD;        // Forward Declaration

class PropSheet{
    private:
        PROPSHEETHEADER psHeader;

    public:
        PropSheet();
        ~PropSheet();

        BOOL Init(HWND hwnd, int nPages, char *szCaption, BOOL fApplyNow);
        int Run();

        void    MakePropPage( HPROPSHEETPAGE hPage );

        int     PropPageCount( void )               { return psHeader.nPages; }
        void    SetStartPage( int m_nStartPage )    { psHeader.nStartPage = m_nStartPage; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\msluprop.cpp ===
/****************************************************************************\
 *
 *   MSLUPROP.CPP
 *
 *   Created:   William Taylor (wtaylor) 12/14/00
 *
 *   MS Ratings Property Sheet Class
 *   
\****************************************************************************/

/*INCLUDES--------------------------------------------------------------------*/
#include "msrating.h"
#include "msluprop.h"
#include "debug.h"
#include "apithk.h"
#include <mluisupp.h>

/*Property Sheet Class--------------------------------------------------------*/
PropSheet::PropSheet()
{
    memset(&psHeader, 0,sizeof(psHeader));
    psHeader.dwSize = sizeof(psHeader);
}

PropSheet::~PropSheet()
{
    if ( psHeader.pszCaption )
    {
        delete (LPSTR)psHeader.pszCaption;
        psHeader.pszCaption = NULL;
    }

    if ( psHeader.phpage )
    {
        delete psHeader.phpage;
        psHeader.phpage = NULL;
    }
}

BOOL PropSheet::Init(HWND hwnd, int nPages, char *szCaption, BOOL fApplyNow)
{
    HINSTANCE           hinst = _Module.GetResourceInstance();

    char *p;

    psHeader.hwndParent = hwnd;
    psHeader.hInstance  = hinst;
    p = new char [strlenf(szCaption)+1];
    if (p == NULL)
        return FALSE;
    strcpyf(p, szCaption);
    psHeader.pszCaption = p;
    
    psHeader.phpage = new HPROPSHEETPAGE [nPages];
    if (psHeader.phpage == NULL)
    {
        delete p;
        p = NULL;
        psHeader.pszCaption = NULL;
        return FALSE;
    }

    if ( ! fApplyNow )
    {
        psHeader.dwFlags |= PSH_NOAPPLYNOW;
    }

    return (psHeader.pszCaption != NULL);
}

// We can safely cast down to (int) because we don't use modeless
// property sheets.
int PropSheet::Run()
{
    return (int)::PropertySheet(&psHeader);
}

void PropSheet::MakePropPage( HPROPSHEETPAGE hPage )
{
    ASSERT( hPage );

    if ( ! hPage )
    {
        TraceMsg( TF_ERROR, "PropSheet::MakePropPage() - hPage is NULL!" );
        return;
    }

    // Add newly created page handle to list of pages in Header.
    if ( psHeader.phpage )
    {
        psHeader.phpage[psHeader.nPages] = hPage;

        if ( hPage )
        {
            psHeader.nPages++;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\msludlg.cpp ===
/****************************************************************************\
 *
 *   MSLUDLG.C
 *
 *   Updated:   Ann McCurdy
 *   Updated:   Mark Hammond (t-markh) 8/98
 *   
\****************************************************************************/

/*INCLUDES--------------------------------------------------------------------*/
#include "msrating.h"
#include "ratings.h"
#include "mslubase.h"
#include "msluprop.h"
#include "commctrl.h"
#include "commdlg.h"
#include "debug.h"
#include "buffer.h"
#include "picsrule.h"
#include "picsdlg.h"    // CPicsDialog
#include "apprdlg.h"    // CApprovedSitesDialog
#include "gendlg.h"     // CGeneralDialog
#include "advdlg.h"     // CAdvancedDialog
#include "introdlg.h"   // CIntroDialog
#include "passdlg.h"    // CPasswordDialog
#include "chngdlg.h"    // CChangePasswordDialog
#include "toffdlg.h"    // CTurnOffDialog
#include <shlwapip.h>
#include <shellapi.h>
#include <wininet.h>
#include <contxids.h>

#include <mluisupp.h>

extern array<PICSRulesRatingSystem*>    g_arrpPRRS;
extern PICSRulesRatingSystem *          g_pPRRS;
extern PICSRulesRatingSystem *          g_pApprovedPRRS;

extern HMODULE                          g_hURLMON,g_hWININET;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

PICSRulesRatingSystem * g_pApprovedPRRSPreApply;
array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern bool IsRegistryModifiable( HWND p_hwndParent );

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

#define NUM_PAGES 4

// Initialize the Specialized Common Controls (tree controls, etc.)
void InitializeCommonControls( void )
{
    INITCOMMONCONTROLSEX ex;

    ex.dwSize = sizeof(ex);
    ex.dwICC = ICC_NATIVEFNTCTL_CLASS;

    InitCommonControlsEx(&ex);
}

BOOL PicsOptionsDialog( HWND hwnd, PicsRatingSystemInfo * pPRSI, PicsUser * pPU )
{
    PropSheet            ps;
    PRSD                 *pPRSD;
    char                 pszBuf[MAXPATHLEN];
    BOOL                 fRet = FALSE;

    InitializeCommonControls();

    MLLoadStringA(IDS_GENERIC, pszBuf, sizeof(pszBuf));

    ps.Init( hwnd, NUM_PAGES, pszBuf, TRUE );

    pPRSD = new PRSD;
    if (!pPRSD) return FALSE;

    pPRSD->pPU                = pPU;
    pPRSD->pTempRatings       = NULL;
    pPRSD->hwndBitmapCategory = NULL;
    pPRSD->hwndBitmapLabel    = NULL;
    pPRSD->pPRSI              = pPRSI;
    pPRSD->fNewProviders      = FALSE;

    HPROPSHEETPAGE          hPage;

    CPicsDialog             picsDialog( pPRSD );
    hPage = picsDialog.Create();
    ps.MakePropPage( hPage );

    CApprovedSitesDialog    approvedSitesDialog( pPRSD );
    hPage = approvedSitesDialog.Create();
    ps.MakePropPage( hPage );

    CGeneralDialog          generalDialog( pPRSD );
    hPage = generalDialog.Create();
    ps.MakePropPage( hPage );

    CAdvancedDialog         advancedDialog( pPRSD );
    hPage = advancedDialog.Create();
    ps.MakePropPage( hPage );

    if ( ps.PropPageCount() == NUM_PAGES )
    {
        fRet = ps.Run();
    }

    delete pPRSD;
    pPRSD = NULL;

    return fRet;
}

INT_PTR DoPasswordConfirm(HWND hDlg)
{
    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        CPasswordDialog         passDlg( IDS_PASSWORD_LABEL );

        return passDlg.DoModal( hDlg );
    }
    else
    {
        CChangePasswordDialog<IDD_CREATE_PASSWORD>   createPassDlg;

        return createPassDlg.DoModal( hDlg ) ? PASSCONFIRM_NEW : PASSCONFIRM_FAIL;
    }
}

#define NO_EXISTING_PASSWORD PASSCONFIRM_NEW

UINT_PTR DoExistingPasswordConfirm(HWND hDlg,BOOL * fExistingPassword)
{
    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        *fExistingPassword=TRUE;

        CPasswordDialog         passDlg( IDS_PASSWORD_LABEL );

        return passDlg.DoModal( hDlg );
    }
    else
    {
        *fExistingPassword=FALSE;

        return(NO_EXISTING_PASSWORD);
    }
}

STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername)
{
    BOOL fExistingPassword;

    UINT_PTR passConfirm = DoExistingPasswordConfirm(hDlg,&fExistingPassword);

    if (passConfirm == PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "RatingSetupUI() - Failed Existing Password Confirmation!" );
        return E_ACCESSDENIED;
    }

    HRESULT hres = NOERROR;

    BOOL fFreshInstall = FALSE;
    if (!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        fFreshInstall = TRUE;
    }

    if ( ! PicsOptionsDialog( hDlg, gPRSI, GetUserObject(pszUsername) ) )
    {
        /* If we have no saved settings and they cancelled the settings UI, and
         * they just entered a new supervisor password, then we need to remove
         * the supervisor password too, otherwise it looks like there's been
         * tampering.  The other option would be to actually commit the
         * settings in that case but disable enforcement, but the case we're
         * looking to treat here is the casual exploring user who goes past
         * entering the password but decides he doesn't want ratings after all.
         * If we leave the password and ratings settings there, then he's not
         * going to remember what the password was when he decides he does want
         * ratings a year from now.  Best to just remove the password and let
         * him enter and confirm a new one next time.
         */
        if (fFreshInstall)
        {
            if (passConfirm == PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }

        TraceMsg( TF_WARNING, "RatingSetupUI() - PicsOptionsDialog() Failed!" );
        return E_FAIL;
    }

    if ( ! IsRegistryModifiable( hDlg ) )
    {
        TraceMsg( TF_WARNING, "RatingSetupUI() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    if ( FAILED( VerifySupervisorPassword() ) )
    {
        passConfirm = DoPasswordConfirm(hDlg);

        if(passConfirm==PASSCONFIRM_FAIL)
        {
            TraceMsg( TF_WARNING, "RatingSetupUI() - PicsOptionsDialog() Failed Password Confirmation!" );
            gPRSI->fRatingInstalled = FALSE;
            return E_FAIL;
        }
    }

    gPRSI->fSettingsValid = TRUE;
    gPRSI->SaveRatingSystemInfo();

    return NOERROR;
}

CIntroDialog        g_introDialog;

STDAPI RatingAddPropertyPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam, DWORD dwPageFlags)
{
    HRESULT hr = NOERROR;

    ASSERT( pfnAddPage );

    if ( ! pfnAddPage )
    {
        TraceMsg( TF_ERROR, "RatingAddPropertyPages() - pfnAddPage is NULL!" );
        return E_INVALIDARG;
    }

    // Initialize the Property Page DLL Instance
    g_introDialog.m_psp.hInstance = MLGetHinst();

    HPROPSHEETPAGE      hPage;

    hPage = g_introDialog.Create();

    if ( hPage )
    {
        if ( ! pfnAddPage( hPage, lparam ) )
        {
            DestroyPropertySheetPage( hPage );

            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable)
{
    // Display the Ratings UI if the Ratings are not fully installed or settings are not valid.
    if (!gPRSI || !gPRSI->fRatingInstalled || !gPRSI->fSettingsValid)
    {
        if (!fEnable)
        {
            TraceMsg( TF_WARNING, "RatingEnable() - Ratings are disabled by not being installed!" );
            return NOERROR;         /* ratings are disabled by not being installed */
        }

        HRESULT hres = RatingSetupUI(hwndParent, pszUsername);

        /* User clicked "Turn On" but we installed and let him choose his
         * settings, so give him friendly confirmation that we set things
         * up for him and he can click Settings later to change things
         * (therefore implying that he doesn't need to click Settings now).
         */
        if (SUCCEEDED(hres))
        {
            MyMessageBox(hwndParent, IDS_NOWENABLED, IDS_ENABLE_WARNING,
                         IDS_GENERIC, MB_ICONINFORMATION | MB_OK);
        }

        return hres;
    }

    if ( ! IsRegistryModifiable( hwndParent ) )
    {
        TraceMsg( TF_WARNING, "RatingEnable() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    PicsUser *pUser = ::GetUserObject(pszUsername);
    if (pUser == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_BAD_USERNAME);
    }

    /* !a == !b to normalize non-zero values */
    if (!fEnable == !pUser->fEnabled)
    {
        return NOERROR;             /* already in state caller wants */
    }

    if (DoPasswordConfirm(hwndParent))
    {
        PicsUser *pUser = ::GetUserObject();
        if (pUser != NULL)
        {
            pUser->fEnabled = !pUser->fEnabled;
            gPRSI->SaveRatingSystemInfo();
            if (pUser->fEnabled)
            {
                MyMessageBox(hwndParent, IDS_NOW_ON, IDS_ENABLE_WARNING,
                             IDS_GENERIC, MB_OK);
            }
            else
            {
                CRegKey         keyRatings;

                if ( keyRatings.Open( HKEY_LOCAL_MACHINE, szRATINGS ) == ERROR_SUCCESS )
                {
                    DWORD         dwFlag;

                    if ( keyRatings.QueryValue( dwFlag, szTURNOFF ) == ERROR_SUCCESS )
                    {
                        if ( dwFlag != 1 )
                        {
                                CTurnOffDialog          turnOffDialog;

                                turnOffDialog.DoModal( hwndParent );
                        }
                    }
                    else
                    {
                        CTurnOffDialog          turnOffDialog;

                        turnOffDialog.DoModal( hwndParent );
                    }
                }
            }
        }
        return NOERROR;
    }
    else
    {
        return E_ACCESSDENIED;
    }
}

STDAPI_(int) ClickedOnPRF(HWND hWndOwner,HINSTANCE p_hInstance,PSTR lpszFileName,int nShow)
{
    BOOL                    bExists=FALSE,fPICSRulesSaved=FALSE,fExistingPassword;
    int                     iReplaceInstalled=IDYES;
    char                    szTitle[MAX_PATH],szMessage[MAX_PATH];
    PropSheet               ps;
    PRSD                    *pPRSD;
    char                    pszBuf[MAXPATHLEN];
    BOOL                    fRet=FALSE;
    UINT_PTR                passConfirm;

    if ( ! IsRegistryModifiable( hWndOwner ) )
    {
        TraceMsg( TF_WARNING, "ClickedOnPRF() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    InitializeCommonControls();

    //Make sure the user wants to do this
    if( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        fExistingPassword=TRUE;

        CPasswordDialog         passDlg( IDS_PICS_RULES_LABEL, true );

        passConfirm = passDlg.DoModal( hWndOwner );
    }
    else
    {
        fExistingPassword=FALSE;

        CPasswordDialog         passDlg( IDS_PICS_RULES_LABEL, false );

        passConfirm = passDlg.DoModal( hWndOwner );
    }

    if(passConfirm==PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "ClickedOnPRF() - Password Confirmation Failed!" );
        return E_ACCESSDENIED;
    }

    if(fExistingPassword==FALSE)
    {
        passConfirm=NO_EXISTING_PASSWORD;
    }

    BOOL fFreshInstall=FALSE;

    if(!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        fFreshInstall=TRUE;
    }

    gPRSI->lpszFileName=lpszFileName;

    MLLoadStringA(IDS_GENERIC,pszBuf,sizeof(pszBuf));

    ps.Init( hWndOwner, NUM_PAGES, pszBuf, TRUE );

    pPRSD=new PRSD;
    if (!pPRSD)
    {
        TraceMsg( TF_ERROR, "ClickedOnPRF() - Failed PRSD Creation!" );
        return FALSE;
    }

    pPRSD->pPU                =GetUserObject((LPCTSTR) NULL);
    pPRSD->pTempRatings       =NULL;
    pPRSD->hwndBitmapCategory =NULL;
    pPRSD->hwndBitmapLabel    =NULL;
    pPRSD->pPRSI              =gPRSI;
    pPRSD->fNewProviders      =FALSE;

    HPROPSHEETPAGE          hPage;

    CPicsDialog             picsDialog( pPRSD );
    hPage = picsDialog.Create();
    ps.MakePropPage( hPage );

    CApprovedSitesDialog    approvedSitesDialog( pPRSD );
    hPage = approvedSitesDialog.Create();
    ps.MakePropPage( hPage );

    CGeneralDialog          generalDialog( pPRSD );
    hPage = generalDialog.Create();
    ps.MakePropPage( hPage );

    CAdvancedDialog         advancedDialog( pPRSD );
    hPage = advancedDialog.Create();
    ps.MakePropPage( hPage );

    if ( ps.PropPageCount() == NUM_PAGES )
    {
        if(fExistingPassword==FALSE)
        {
            picsDialog.InstallDefaultProvider();
            picsDialog.PicsDlgSave();
        }

        ps.SetStartPage( ps.PropPageCount() - 1 );
        fRet=ps.Run();
    }

    delete pPRSD;
    pPRSD = NULL;

    if(!fRet)
    {
        // If we have no saved settings and they cancelled the settings UI, and
        // they just entered a new supervisor password, then we need to remove
        // the supervisor password too, otherwise it looks like there's been
        // tampering.  The other option would be to actually commit the
        // settings in that case but disable enforcement, but the case we're
        // looking to treat here is the casual exploring user who goes past
        // entering the password but decides he doesn't want ratings after all.
        // If we leave the password and ratings settings there, then he's not
        // going to remember what the password was when he decides he does want
        // ratings a year from now.  Best to just remove the password and let
        // him enter and confirm a new one next time.

        if(fFreshInstall)
        {
            if(passConfirm==PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }

        return(FALSE);
    }

    if ( FAILED( VerifySupervisorPassword() ) )
    {
        passConfirm=DoPasswordConfirm(hWndOwner);

        if(passConfirm==PASSCONFIRM_FAIL)
        {
            gPRSI->fRatingInstalled=FALSE;
            return(FALSE);
        }
    }

    gPRSI->fSettingsValid=TRUE;
    gPRSI->SaveRatingSystemInfo();

    MLLoadString(IDS_PICSRULES_CLICKIMPORTTITLE,(LPTSTR) szTitle,MAX_PATH);
    MLLoadString(IDS_PICSRULES_CLICKFINISHED,(LPTSTR) szMessage,MAX_PATH);

    MessageBox(hWndOwner,(LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK);

    return(TRUE);
}

STDAPI_(int) ClickedOnRAT(HWND hWndOwner,HINSTANCE p_hInstance,PSTR lpszFileName,int nShow)
{
    BOOL                    bExists=FALSE,fPICSRulesSaved=FALSE,fExistingPassword;
    int                     iReplaceInstalled=IDYES;
    char                    szTitle[MAX_PATH],szMessage[MAX_PATH],szNewFile[MAX_PATH];
    char                    *lpszFile,*lpszTemp;
    PropSheet               ps;
    PRSD                    *pPRSD;
    char                    pszBuf[MAXPATHLEN];
    BOOL                    fRet=FALSE;
    UINT_PTR                passConfirm;

    if ( ! IsRegistryModifiable( hWndOwner ) )
    {
        TraceMsg( TF_WARNING, "ClickedOnRAT() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    InitializeCommonControls();

    //Make sure the user wants to do this
    if ( SUCCEEDED ( VerifySupervisorPassword() ) )
    {
        fExistingPassword=TRUE;
    
        CPasswordDialog         passDlg( IDS_RATING_SYSTEM_LABEL, true );

        passConfirm = passDlg.DoModal( hWndOwner );
    }
    else
    {
        fExistingPassword=FALSE;

        CPasswordDialog         passDlg( IDS_RATING_SYSTEM_LABEL, false );

        passConfirm = passDlg.DoModal( hWndOwner );
    }

    if(passConfirm==PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "ClickedOnRAT() - Password Confirmation Failed!" );
        return E_ACCESSDENIED;
    }

    if(fExistingPassword==FALSE)
    {
        passConfirm=NO_EXISTING_PASSWORD;
    }

    //Copy the file to the windows system directory
    GetSystemDirectory(szNewFile,MAX_PATH);
    
    lpszTemp=lpszFileName;

    do{
        lpszFile=lpszTemp;
    }
    while((lpszTemp=strchrf(lpszTemp+1,'\\'))!=NULL);
    
    lstrcat(szNewFile,lpszFile);
    
    CopyFile(lpszFileName,szNewFile,FALSE);

    BOOL fFreshInstall = FALSE;
    if (!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        fFreshInstall = TRUE;
    }

    gPRSI->lpszFileName=szNewFile;

    MLLoadStringA(IDS_GENERIC,pszBuf,sizeof(pszBuf));

    ps.Init( hWndOwner, NUM_PAGES, pszBuf, TRUE );

    pPRSD=new PRSD;
    if (!pPRSD)
    {
        TraceMsg( TF_ERROR, "ClickedOnRAT() - Failed PRSD Creation!" );
        return FALSE;
    }

    pPRSD->pPU                =GetUserObject((LPCTSTR) NULL);
    pPRSD->pTempRatings       =NULL;
    pPRSD->hwndBitmapCategory =NULL;
    pPRSD->hwndBitmapLabel    =NULL;
    pPRSD->pPRSI              =gPRSI;
    pPRSD->fNewProviders      =FALSE;

    HPROPSHEETPAGE          hPage;

    CPicsDialog             picsDialog( pPRSD );
    hPage = picsDialog.Create();
    ps.MakePropPage( hPage );

    CApprovedSitesDialog    approvedSitesDialog( pPRSD );
    hPage = approvedSitesDialog.Create();
    ps.MakePropPage( hPage );

    CGeneralDialog          generalDialog( pPRSD );
    hPage = generalDialog.Create();
    ps.MakePropPage( hPage );

    CAdvancedDialog         advancedDialog( pPRSD );
    hPage = advancedDialog.Create();
    ps.MakePropPage( hPage );

    if ( ps.PropPageCount() == NUM_PAGES )
    {
        if(fExistingPassword==FALSE)
        {
            picsDialog.InstallDefaultProvider();
            picsDialog.PicsDlgSave();
        }

        ps.SetStartPage( ps.PropPageCount() - 2 );
        fRet=ps.Run();
    }

    delete pPRSD;
    pPRSD = NULL;

    if(!fRet)
    {
        // If we have no saved settings and they cancelled the settings UI, and
        // they just entered a new supervisor password, then we need to remove
        // the supervisor password too, otherwise it looks like there's been
        // tampering.  The other option would be to actually commit the
        // settings in that case but disable enforcement, but the case we're
        // looking to treat here is the casual exploring user who goes past
        // entering the password but decides he doesn't want ratings after all.
        // If we leave the password and ratings settings there, then he's not
        // going to remember what the password was when he decides he does want
        // ratings a year from now.  Best to just remove the password and let
        // him enter and confirm a new one next time.

        if(fFreshInstall)
        {
            if(passConfirm==PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }

        return(FALSE);
    }

    if ( FAILED( VerifySupervisorPassword() ) )
    {
        passConfirm=DoPasswordConfirm(hWndOwner);

        if(passConfirm==PASSCONFIRM_FAIL)
        {
            gPRSI->fRatingInstalled=FALSE;
            return(FALSE);
        }
    }

    gPRSI->fSettingsValid=TRUE;
    gPRSI->SaveRatingSystemInfo();

    MLLoadString(IDS_PICSRULES_CLICKIMPORTTITLE,(LPTSTR) szTitle,MAX_PATH);
    MLLoadString(IDS_PICSRULES_CLICKFINISHED,(LPTSTR) szMessage,MAX_PATH);

    MessageBox(hWndOwner,(LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\msrating.h ===
//#define DBCS

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <regstr.h>

#include <string.h>
#include <netlib.h>

#ifdef DEBUG
#define SAVE_DEBUG
#undef DEBUG
#endif

#include <npstring.h>
#include <npdefs.h>

#ifdef SAVE_DEBUG
#define DEBUG
#endif

#if DBG
#define DEBUG 1
#endif

#include <ole2.h>
#include "ratguid.h"
#include <ccstock.h>
#ifdef ENTERCRITICAL
#undef ENTERCRITICAL
#endif // ENTERCRITICAL
#ifdef LEAVECRITICAL
#undef LEAVECRITICAL
#endif // LEAVECRITICAL
#ifdef ASSERTCRITICAL
#undef ASSERTCRITICAL
#endif // ASSERTCRITICAL

#ifndef MAXPATHLEN
#define MAXPATHLEN MAX_PATH
#endif

void Netlib_EnterCriticalSection(void);
void Netlib_LeaveCriticalSection(void);
#ifdef DEBUG
extern BOOL g_fCritical;
#endif
#define ENTERCRITICAL   Netlib_EnterCriticalSection();
#define LEAVECRITICAL   Netlib_LeaveCriticalSection();
#define ASSERTCRITICAL  ASSERT(g_fCritical);

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT        DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

extern HINSTANCE g_hInstance;

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

extern "C" {
HRESULT VerifySupervisorPassword(LPCSTR pszPassword = NULL);
HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword);
HRESULT RemoveSupervisorPassword(void);
};

#define RATINGS_MAX_PASSWORD_LENGTH 256
const UINT cchMaxUsername = 128;

extern long g_cRefThisDll;
extern long g_cLocks;
extern void LockThisDLL(BOOL fLock);
extern void RefThisDLL(BOOL fRef);

extern void CleanupWinINet(void);
extern void CleanupOLE(void);
extern void InitRatingHelpers();
extern void CleanupRatingHelpers();

class CLUClassFactory : public IClassFactory
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance( 
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
    STDMETHODIMP LockServer( 
            /* [in] */ BOOL fLock);
};

#include <commctrl.h>
#include <shfusion.h>

// ATL
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

// WTL
#include <atlapp.h>
#include <atlwin.h>
#include <atldlgs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\msrating.cpp ===
#include "msrating.h"

/* the following defs will make msluglob.h actually define globals */
#define EXTERN
#define ASSIGN(value) = value
#include "msluglob.h"

#include "ratings.h"

#define DECL_CRTFREE
#include <crtfree.h>
#include <npassert.h>

HANDLE g_hmtxShell = 0;             // for critical sections
HANDLE g_hsemStateCounter = 0;      // 

#ifdef DEBUG
BOOL g_fCritical=FALSE;
#endif

HINSTANCE g_hInstance = NULL;

long g_cRefThisDll = 0;        // Reference count of this DLL.
long g_cLocks = 0;            // Number of locks on this server.

BOOL g_bMirroredOS = FALSE;

CComModule _Module;

// #define CLSID_MSRating szRORSGUID

// BEGIN_OBJECT_MAP(ObjectMap)
// OBJECT_ENTRY(CLSID_MSRating, CMSRating)
// END_OBJECT_MAP()

void LockThisDLL(BOOL fLock)
{
    if (fLock)
    {
        InterlockedIncrement(&g_cLocks);
    }
    else
    {
        ASSERT( 0 != g_cLocks );
        InterlockedDecrement(&g_cLocks);
    }
}


void RefThisDLL(BOOL fRef)
{
    if (fRef)
    {
        InterlockedIncrement(&g_cRefThisDll);
    }
    else
    {
        ASSERT( 0 != g_cLocks );
        InterlockedDecrement(&g_cRefThisDll);
    }
}


void Netlib_EnterCriticalSection(void)
{
    WaitForSingleObject(g_hmtxShell, INFINITE);
#ifdef DEBUG
    g_fCritical=TRUE;
#endif
}

void Netlib_LeaveCriticalSection(void)
{
#ifdef DEBUG
    g_fCritical=FALSE;
#endif
    ReleaseMutex(g_hmtxShell);
}


#include <shlwapip.h>
#include <mluisupp.h>

void _ProcessAttach()
{
    ::DisableThreadLibraryCalls(::g_hInstance);

    MLLoadResources(::g_hInstance, TEXT("msratelc.dll"));

    InitMUILanguage( MLGetUILanguage() );

    // Override the Module Resources Handle.
    _Module.m_hInstResource = MLGetHinst();

    g_hmtxShell = CreateMutex(NULL, FALSE, TEXT("MSRatingMutex"));  // per-instance
    g_hsemStateCounter = CreateSemaphore(NULL, 0, 0x7FFFFFFF, "MSRatingCounter");
    g_bMirroredOS = IS_MIRRORING_ENABLED();
    
    ::InitStringLibrary();

    RatingInit();
}

void _ProcessDetach()
{
    MLFreeResources(::g_hInstance);

    // Clear the Module Resources Handle.
    _Module.m_hInstResource = NULL;

    RatingTerm();

    CleanupWinINet();

    CleanupRatingHelpers();        /* important, must do this before CleanupOLE() */

    CleanupOLE();

    CloseHandle(g_hmtxShell);
    CloseHandle(g_hsemStateCounter);
}

STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
       _Module.Init( NULL, hInstDll );
        SHFusionInitializeFromModule(hInstDll);
        g_hInstance = hInstDll;
        _ProcessAttach();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        _ProcessDetach();
        SHFusionUninitialize();
        _Module.Term();
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\msluglob.h ===
#if !defined (EXTERN)
#define EXTERN extern
#endif

#if !defined (ASSIGN)
#define ASSIGN(value)
#endif

/* the 'extern' must be forced for constant arrays, because 'const'
 * in C++ implies 'static' otherwise.
 */
#define EXTTEXT(n) extern const CHAR n[]
#define TEXTCONST(name,text) EXTTEXT(name) ASSIGN(text)

TEXTCONST(szHelpFile,"ratings.hlp");
/*  TEXTCONST(szProfileList,REGSTR_PATH_SETUP "\\ProfileList"); */
/* TEXTCONST(szSupervisor,"Supervisor"); */
TEXTCONST(szDefaultUserName,".Default");
TEXTCONST(szRatingsSupervisorKeyName,"Key");
TEXTCONST(szLogonKey,"Network\\Logon");
TEXTCONST(szUserProfiles,"UserProfiles");
TEXTCONST(szPOLICYKEY,      "System\\CurrentControlSet\\Control\\Update");
TEXTCONST(szPOLICYVALUE,    "UpdateMode");

TEXTCONST(szComDlg32,"comdlg32.dll");
TEXTCONST(szShell32,"shell32.dll");
TEXTCONST(szGetOpenFileName,"GetOpenFileNameA");    // we're ANSI, even on NT
TEXTCONST(szShellExecute,"ShellExecuteA");

TEXTCONST(VAL_UNKNOWNS,"Allow_Unknowns");
TEXTCONST(VAL_PLEASEMOM,"PleaseMom");
TEXTCONST(VAL_ENABLED,"Enabled");

TEXTCONST(szPOLUSER,        "PolicyData\\Users");
TEXTCONST(szTMPDATA,        "PolicyData");
TEXTCONST(szUSERS,          "Users");
TEXTCONST(szRATINGS,        "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings");
TEXTCONST(szRATINGHELPERS,  "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Rating Helpers");
TEXTCONST(szRORSGUID,       "{20EDB660-7CDD-11CF-8DAB-00AA006C1A01}");
TEXTCONST(szCLSID,          "CLSID");
TEXTCONST(szINPROCSERVER32, "InProcServer32");
TEXTCONST(szDLLNAME,        "msrating.dll");
TEXTCONST(szNTRootDir,      "%SystemRoot%\\system32\\");
TEXTCONST(sz9XRootDir,      "%WinDir%\\system\\");
TEXTCONST(szTHREADINGMODEL, "ThreadingModel");
TEXTCONST(szAPARTMENT,      "Apartment");

TEXTCONST(szPOLFILE,        "ratings.pol");
TEXTCONST(szBACKSLASH,      "\\");
TEXTCONST(szDEFAULTRATFILE, "RSACi.rat");
TEXTCONST(szFilenameTemplate, "FileName%d");        /* note, mslubase.cpp knows the length of this string is 8 + number length */
TEXTCONST(szNULL,           "");
TEXTCONST(szRATINGBUREAU,   "Bureau");

/* t-markh 8/98 - Text strings used in parsing PICSRules */

TEXTCONST(szPRShortYes,"y");
TEXTCONST(szPRYes,"yes");
TEXTCONST(szPRShortNo,"n");
TEXTCONST(szPRNo,"no");
TEXTCONST(szPRPass,"pass");
TEXTCONST(szPRFail,"fail");

//t-markh, These are not in the official spec, but we should handle them anyway
TEXTCONST(szPRShortPass,"p");
TEXTCONST(szPRShortFail,"f");


/* Text strings used in parsing rating labels. */

TEXTCONST(szDoubleCRLF,"\r\n\r\n");
TEXTCONST(szPicsOpening,"(PICS-");
TEXTCONST(szWhitespace," \t\r\n");
TEXTCONST(szExtendedAlphaNum,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.,;:&=?!*~@#/");
TEXTCONST(szSingleCharTokens,"()\"");
TEXTCONST(szLeftParen,"(");
TEXTCONST(szRightParen,")");
TEXTCONST(szOptional,"optional");
TEXTCONST(szMandatory,"mandatory");
TEXTCONST(szAtOption,"at");
TEXTCONST(szByOption,"by");
TEXTCONST(szCommentOption,"comment");
TEXTCONST(szCompleteLabelOption,"complete-label");
TEXTCONST(szFullOption,"full");
TEXTCONST(szExtensionOption,"extension");
TEXTCONST(szGenericOption,"generic");
TEXTCONST(szShortGenericOption,"gen");
TEXTCONST(szForOption,"for");
TEXTCONST(szMICOption,"MIC-md5");
TEXTCONST(szMD5Option,"md5");
TEXTCONST(szOnOption,"on");
TEXTCONST(szSigOption,"signature-PKCS");
TEXTCONST(szUntilOption,"until");
TEXTCONST(szExpOption,"exp");
TEXTCONST(szRatings,"ratings");
/* TEXTCONST(szShortRatings,"r"); */
TEXTCONST(szError,"error");
TEXTCONST(szNoRatings,"no-ratings");
TEXTCONST(szLabelWord,"labels");
/* TEXTCONST(szShortLabelWord,"l"); */
TEXTCONST(szShortTrue,"t");
TEXTCONST(szTrue,"true");
TEXTCONST(szShortFalse,"f");
TEXTCONST(szFalse,"false");

/* TEXTCONST(szNegInf,"-INF"); */
/* TEXTCONST(szPosInf,"+INF"); */
TEXTCONST(szLabel,"label");
TEXTCONST(szName,"name");
TEXTCONST(szValue,"value");
TEXTCONST(szIcon,"icon");
TEXTCONST(szDescription, "description");
TEXTCONST(szCategory, "category");
TEXTCONST(szTransmitAs, "transmit-as");
TEXTCONST(szMin,"min");
TEXTCONST(szMax,"max");
/* TEXTCONST(szMultivalue,"multivalue"); */
TEXTCONST(szInteger,"integer");
TEXTCONST(szLabelOnly, "label-only");
TEXTCONST(szPicsVersion,"PICS-version");
TEXTCONST(szRatingSystem,"rating-system");
TEXTCONST(szRatingService,"rating-service");
TEXTCONST(szRatingBureau,"rating-bureau");
TEXTCONST(szBureauRequired,"bureau-required");
TEXTCONST(szDefault,"default");
TEXTCONST(szMultiValue,"multivalue");
TEXTCONST(szUnordered,"unordered");
TEXTCONST(szRatingBureauExtension,"www.w3.org/PICS/service-extensions/label-bureau");

EXTERN CHAR abSupervisorKey[16] ASSIGN({0});        /* supervisor password hash */
EXTERN CHAR fSupervisorKeyInit ASSIGN(FALSE);       /* whether abSupervisorKey has been initialized */

//t-markh 8/98
//The following TEXTCONST's are for PICSRules support.
//Dereferenced in picsrule.cpp
TEXTCONST(szPICSRulesVersion,"PicsRule");
TEXTCONST(szPICSRulesPolicy,"Policy");
TEXTCONST(szPICSRulesExplanation,"Explanation");
TEXTCONST(szPICSRulesRejectByURL,"RejectByURL");
TEXTCONST(szPICSRulesAcceptByURL,"AcceptByURL");
TEXTCONST(szPICSRulesRejectIf,"RejectIf");
TEXTCONST(szPICSRulesAcceptIf,"AcceptIf");
TEXTCONST(szPICSRulesAcceptUnless,"AcceptUnless");
TEXTCONST(szPICSRulesRejectUnless,"RejectUnless");
TEXTCONST(szPICSRulesName,"name");
TEXTCONST(szPICSRulesRuleName,"Rulename");
TEXTCONST(szPICSRulesDescription,"Description");
TEXTCONST(szPICSRulesSource,"source");
TEXTCONST(szPICSRulesSourceURL,"SourceURL");
TEXTCONST(szPICSRulesCreationTool,"CreationTool");
TEXTCONST(szPICSRulesAuthor,"author");
TEXTCONST(szPICSRulesLastModified,"LastModified");
TEXTCONST(szPICSRulesServiceInfo,"serviceinfo");
TEXTCONST(szPICSRulesSIName,"Name");
TEXTCONST(szPICSRulesShortName,"shortname");
TEXTCONST(szPICSRulesBureauURL,"BureauURL");
TEXTCONST(szPICSRulesUseEmbedded,"UseEmbedded");
TEXTCONST(szPICSRulesRATFile,"Ratfile");
TEXTCONST(szPICSRulesBureauUnavailable,"BureauUnavailable");
TEXTCONST(szPICSRulesOptExtension,"optextension");
TEXTCONST(szPICSRulesExtensionName,"extension-name");
TEXTCONST(szPICSRulesReqExtension,"reqextension");
TEXTCONST(szPICSRulesExtension,"Extension");
TEXTCONST(szPICSRulesOptionDefault,"OptionDefault");
TEXTCONST(szPICSRulesDegenerateExpression,"otherwise");
TEXTCONST(szPICSRulesOr,"or");
TEXTCONST(szPICSRulesAnd,"and");
TEXTCONST(szPICSRulesHTTP,"http");
TEXTCONST(szPICSRulesFTP,"ftp");
TEXTCONST(szPICSRulesGOPHER,"gopher");
TEXTCONST(szPICSRulesNNTP,"nntp");
TEXTCONST(szPICSRulesIRC,"irc");
TEXTCONST(szPICSRulesPROSPERO,"perospero");
TEXTCONST(szPICSRulesTELNET,"telnet");
TEXTCONST(szFINDSYSTEM,"http://www.microsoft.com/isapi/redir.dll?prd=ie&ar=ratings&pver=6");
TEXTCONST(szTURNOFF,"WarnOnOff");
TEXTCONST(szHINTVALUENAME, "Hint" );

//These TEXTCONSTS are purposly obfucated to discourage those who would
//from tampering with our settings in the registry
//t-markh - BUGBUG - need to obfuscate names after debugging
TEXTCONST(szPICSRULESSYSTEMNAME,"Name");
TEXTCONST(szPICSRULESFILENAME,"FileName");
TEXTCONST(szPICSRULESSYSTEMS,"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings\\PICSRules");
TEXTCONST(szPICSRULESNUMSYS,"NumSys");
TEXTCONST(szPICSRULESVERMAJOR,"MajorVer");
TEXTCONST(szPICSRULESVERMINOR,"MinorVer");
TEXTCONST(szPICSRULESDWFLAGS,"dwFlags");
TEXTCONST(szPICSRULESERRLINE,"errLine");
TEXTCONST(szPICSRULESPRNAME,"PRName");
TEXTCONST(szPICSRULESRULENAME,"RULEName");
TEXTCONST(szPICSRULESDESCRIPTION,"Description");
TEXTCONST(szPICSRULESPRSOURCE,"PRSource");
TEXTCONST(szPICSRULESSOURCEURL,"SourceURL");
TEXTCONST(szPICSRULESEXPRESSIONEMBEDDED,"PREEmbedded");
TEXTCONST(szPICSRULESEXPRESSIONSERVICENAME,"PREServiceName");
TEXTCONST(szPICSRULESEXPRESSIONCATEGORYNAME,"PRECategoryName");
TEXTCONST(szPICSRULESEXPRESSIONFULLSERVICENAME,"PREFullServiceName");
TEXTCONST(szPICSRULESEXPRESSIONVALUE,"PREValue");
TEXTCONST(szPICSRULESEXPRESSIONPOLICYOPERATOR,"PREOperator");
TEXTCONST(szPICSRULESEXPRESSIONOPPOLICYEMBEDDED,"PREPolEmbedded");
TEXTCONST(szPICSRULESEXPRESSIONLEFT,"PREEmbeddedLeft");
TEXTCONST(szPICSRULESEXPRESSIONRIGHT,"PREEmbeddedRight");
TEXTCONST(szPICSRULESCREATIONTOOL,"PRCreationTool");
TEXTCONST(szPICSRULESEMAILAUTHOR,"PREmailAuthor");
TEXTCONST(szPICSRULESLASTMODIFIED,"PRLastModified");
TEXTCONST(szPICSRULESPRPOLICY,"PRPolicy");
TEXTCONST(szPICSRULESNUMPOLICYS,"PRNumPolicy");
TEXTCONST(szPICSRULESPOLICYEXPLANATION,"PRPExplanation");
TEXTCONST(szPICSRULESPOLICYATTRIBUTE,"PRPPolicyAttribute");
TEXTCONST(szPICSRULESPOLICYSUB,"PRPPolicySub");
TEXTCONST(szPICSRULESBYURLINTERNETPATTERN,"PRBUInternetPattern");
TEXTCONST(szPICSRULESBYURLNONWILD,"PRBUNonWild");
TEXTCONST(szPICSRULESBYURLSPECIFIED,"PRBUSpecified");
TEXTCONST(szPICSRULESBYURLSCHEME,"PRBUScheme");
TEXTCONST(szPICSRULESBYURLUSER,"PRBUUser");
TEXTCONST(szPICSRULESBYURLHOST,"PRBUHost");
TEXTCONST(szPICSRULESBYURLPORT,"PRBUPort");
TEXTCONST(szPICSRULESBYURLPATH,"PRBUPath");
TEXTCONST(szPICSRULESBYURLURL,"PRBUUrl");
TEXTCONST(szPICSRULESSERVICEINFO,"PRServiceInfo");
TEXTCONST(szPICSRULESNUMSERVICEINFO,"PRNumSI");
TEXTCONST(szPICSRULESSIURLNAME,"PRSIURLName");
TEXTCONST(szPICSRULESSIBUREAUURL,"PRSIBureauURL");
TEXTCONST(szPICSRULESSISHORTNAME,"PRSIShortName");
TEXTCONST(szPICSRULESSIRATFILE,"PRSIRatFile");
TEXTCONST(szPICSRULESSIUSEEMBEDDED,"PRSIUseEmbedded");
TEXTCONST(szPICSRULESSIBUREAUUNAVAILABLE,"PRSIBureauUnavailable");
TEXTCONST(szPICSRULESNUMOPTEXTENSIONS,"PRNumOptExt");
TEXTCONST(szPICSRULESOPTEXTNAME,"PROEName");
TEXTCONST(szPICSRULESOPTEXTSHORTNAME,"PROEShortName");
TEXTCONST(szPICSRULESNUMREQEXTENSIONS,"PRNumReqExt");
TEXTCONST(szPICSRULESREQEXTNAME,"PRREName");
TEXTCONST(szPICSRULESREQEXTSHORTNAME,"PRREShortName");
TEXTCONST(szPICSRULESOPTEXTENSION,"PROptExt");
TEXTCONST(szPICSRULESREQEXTENSION,"PRReqExt");
TEXTCONST(szPICSRULESNUMBYURL,"PRNumURLExpressions");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\parselbl.cpp ===
#include "msrating.h"
#include <npassert.h>
#include "array.h"
#include "msluglob.h"
#include "parselbl.h"
#include "debug.h"
#include <convtime.h>
#include <wininet.h>

extern BOOL LoadWinINet();


COptionsBase::COptionsBase()
{
    m_cRef = 1;
    m_timeUntil = 0xffffffff;   /* as far in the future as possible */
    m_fdwFlags = 0;
    m_pszInvalidString = NULL;
    m_pszURL = NULL;
}


void COptionsBase::AddRef()
{
    m_cRef++;
}


void COptionsBase::Release()
{
    if (!--m_cRef)
        Delete();
}


void COptionsBase::Delete()
{
    /* default does nothing when deleting reference */
}


BOOL COptionsBase::CheckUntil(DWORD timeUntil)
{
    if (m_timeUntil <= timeUntil)
    {
        m_fdwFlags |= LBLOPT_EXPIRED;
        return FALSE;
    }
    return TRUE;
}


/* AppendSlash forces pszString to end in a single slash if it doesn't
 * already.  This may produce a technically invalid URL (for example,
 * "http://gregj/default.htm/", but we're only using the result for
 * comparisons against other paths similarly mangled.
 */
void AppendSlash(LPSTR pszString)
{
    LPSTR pszSlash = ::strrchrf(pszString, '/');

    if (pszSlash == NULL || *(pszSlash + 1) != '\0')
        ::strcatf(pszString, "/");
}


extern BOOL (WINAPI *pfnInternetCrackUrl)(
    IN LPCTSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    );
extern BOOL (WINAPI *pfnInternetCanonicalizeUrl)(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


BOOL DoURLsMatch(LPCSTR pszBaseURL, LPCSTR pszCheckURL, BOOL fGeneric)
{
    /* Buffers to canonicalize URLs into */
    LPSTR pszBaseCanon = new char[INTERNET_MAX_URL_LENGTH + 1];
    LPSTR pszCheckCanon = new char[INTERNET_MAX_URL_LENGTH + 1];

    if (pszBaseCanon != NULL && pszCheckCanon != NULL)
    {
        BOOL fCanonOK = FALSE;
        DWORD cbBuffer = INTERNET_MAX_URL_LENGTH + 1;
        if (pfnInternetCanonicalizeUrl(pszBaseURL, pszBaseCanon, &cbBuffer, ICU_ENCODE_SPACES_ONLY))
        {
            cbBuffer = INTERNET_MAX_URL_LENGTH + 1;
            if (pfnInternetCanonicalizeUrl(pszCheckURL, pszCheckCanon, &cbBuffer, ICU_ENCODE_SPACES_ONLY))
            {
                fCanonOK = TRUE;
            }
        }
        if (!fCanonOK)
        {
            delete pszBaseCanon;
            pszBaseCanon = NULL;
            delete pszCheckCanon;
            pszCheckCanon = NULL;
            return FALSE;
        }
    }

    UINT cbBaseURL = strlenf(pszBaseCanon) + 1;

    LPSTR pszBaseUrlPath = new char[cbBaseURL];
    LPSTR pszBaseExtra = new char[cbBaseURL];

    CHAR szBaseHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    CHAR szBaseUrlScheme[20];   // reasonable limit

    UINT cbCheckURL = strlenf(pszCheckCanon) + 1;

    LPSTR pszCheckUrlPath = new char[cbCheckURL];
    LPSTR pszCheckExtra = new char[cbCheckURL];

    CHAR szCheckHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    CHAR szCheckUrlScheme[20];   // reasonable limit

    BOOL fOK = FALSE;

    if (pszBaseUrlPath != NULL &&
        pszBaseExtra != NULL &&
        pszCheckUrlPath != NULL &&
        pszCheckExtra != NULL)
    {

        URL_COMPONENTS ucBase, ucCheck;

        memset(&ucBase, 0, sizeof(ucBase));
        ucBase.dwStructSize      = sizeof(ucBase);
        ucBase.lpszScheme        = szBaseUrlScheme;
        ucBase.dwSchemeLength    = sizeof(szBaseUrlScheme);
        ucBase.lpszHostName      = szBaseHostName;
        ucBase.dwHostNameLength  = sizeof(szBaseHostName);
        ucBase.lpszUrlPath       = pszBaseUrlPath;
        ucBase.dwUrlPathLength   = cbBaseURL;
        ucBase.lpszExtraInfo     = pszBaseExtra;
        ucBase.dwExtraInfoLength = cbBaseURL;

        memset(&ucCheck, 0, sizeof(ucCheck));
        ucCheck.dwStructSize      = sizeof(ucCheck);
        ucCheck.lpszScheme        = szCheckUrlScheme;
        ucCheck.dwSchemeLength    = sizeof(szCheckUrlScheme);
        ucCheck.lpszHostName      = szCheckHostName;
        ucCheck.dwHostNameLength  = sizeof(szCheckHostName);
        ucCheck.lpszUrlPath       = pszCheckUrlPath;
        ucCheck.dwUrlPathLength   = cbCheckURL;
        ucCheck.lpszExtraInfo     = pszCheckExtra;
        ucCheck.dwExtraInfoLength = cbCheckURL;

        if (pfnInternetCrackUrl(pszBaseCanon, 0, 0, &ucBase) &&
            pfnInternetCrackUrl(pszCheckCanon, 0, 0, &ucCheck))
        {
            /* Scheme and host name must always match */
            if (!stricmpf(ucBase.lpszScheme, ucCheck.lpszScheme) &&
                !stricmpf(ucBase.lpszHostName, ucCheck.lpszHostName))
            {
                /* For extra info, just has to match exactly, even for a generic URL. */
                if (!*ucBase.lpszExtraInfo ||
                    !stricmpf(ucBase.lpszExtraInfo, ucCheck.lpszExtraInfo))
                {
                    AppendSlash(ucBase.lpszUrlPath);
                    AppendSlash(ucCheck.lpszUrlPath);

                    /* If not a generic label, path must match exactly too */
                    if (!fGeneric)
                    {
                        if (!stricmpf(ucBase.lpszUrlPath, ucCheck.lpszUrlPath))
                        {
                            fOK = TRUE;
                        }
                    }
                    else
                    {
                        UINT cbBasePath = strlenf(ucBase.lpszUrlPath);
                        if (!strnicmpf(ucBase.lpszUrlPath, ucCheck.lpszUrlPath, cbBasePath))
                        {
                            fOK = TRUE;
                        }
                    }
                }
            }
        }
    }

    delete pszBaseUrlPath;
    pszBaseUrlPath = NULL;
    delete pszBaseExtra;
    pszBaseExtra = NULL;

    delete pszCheckUrlPath;
    pszCheckUrlPath = NULL;
    delete pszCheckExtra;
    pszCheckExtra = NULL;

    delete pszBaseCanon;
    pszBaseCanon = NULL;
    delete pszCheckCanon;
    pszCheckCanon = NULL;

    return fOK;
}


BOOL COptionsBase::CheckURL(LPCSTR pszURL)
{
    if (!(m_fdwFlags & LBLOPT_URLCHECKED))
    {
        m_fdwFlags |= LBLOPT_URLCHECKED;

        BOOL fInvalid = FALSE;

        if (pszURL != NULL && m_pszURL != NULL)
        {
            if (LoadWinINet())
            {
                fInvalid = !DoURLsMatch(m_pszURL, pszURL, m_fdwFlags & LBLOPT_GENERIC);
            }
        }

        if (fInvalid)
        {
            m_fdwFlags |= LBLOPT_WRONGURL;
        }
    }

    return !(m_fdwFlags & LBLOPT_WRONGURL);
}


void CDynamicOptions::Delete()
{
    delete this;
}


CParsedServiceInfo::CParsedServiceInfo()
{
    m_pNext = NULL;
    m_poptCurrent = &m_opt;
    m_poptList = NULL;
    m_pszServiceName = NULL;
    m_pszErrorString = NULL;
    m_fInstalled = TRUE;        /* assume the best */
    m_pszInvalidString = NULL;
    m_pszCurrent = NULL;
}


void FreeOptionsList(CDynamicOptions *pList)
{
    while (pList != NULL)
    {
        CDynamicOptions *pNext = pList->m_pNext;
        delete pList;
        pList = pNext;
    }
}


CParsedServiceInfo::~CParsedServiceInfo()
{
    FreeOptionsList(m_poptList);
}


void CParsedServiceInfo::Append(CParsedServiceInfo *pNew)
{
    CParsedServiceInfo **ppNext = &m_pNext;

    while (*ppNext != NULL)
    {
        ppNext = &((*ppNext)->m_pNext);
    }

    *ppNext = pNew;
    pNew->m_pNext = NULL;
}


CParsedLabelList::CParsedLabelList()
{
    m_pszList = NULL;
    m_fRated = FALSE;
    m_pszInvalidString = NULL;
    m_pszURL = NULL;
    m_pszOriginalLabel = NULL;
    m_fDenied = FALSE;
    m_fIsHelper = FALSE;
    m_fNoRating = FALSE;
    m_fIsCustomHelper = FALSE;
    m_pszRatingName = NULL;
    m_pszRatingReason = NULL;
}


CParsedLabelList::~CParsedLabelList()
{
    delete m_pszList;
    m_pszList = NULL;

    CParsedServiceInfo *pInfo = m_ServiceInfo.Next();

    while (pInfo != NULL)
    {
        CParsedServiceInfo *pNext = pInfo->Next();
        delete pInfo;
        pInfo = pNext;
    }

    delete m_pszURL;
    m_pszURL = NULL;
    delete m_pszOriginalLabel;
    m_pszOriginalLabel = NULL;

    delete [] m_pszRatingName;
    m_pszRatingName = NULL;
    delete [] m_pszRatingReason;
    m_pszRatingReason = NULL;
}


/* SkipWhitespace(&pszString)
 *
 * advances pszString past whitespace characters
 */
void SkipWhitespace(LPSTR *ppsz)
{
    UINT cchWhitespace = ::strspnf(*ppsz, szWhitespace);

    *ppsz += cchWhitespace;
}


/* FindTokenEnd(pszStart)
 *
 * Returns a pointer to the end of a contiguous range of similarly-typed
 * characters (whitespace, quote mark, punctuation, or alphanumerics).
 */
LPSTR FindTokenEnd(LPSTR pszStart)
{
    LPSTR pszEnd = pszStart;

    if (*pszEnd == '\0')
    {
        return pszEnd;
    }
    else if (strchrf(szSingleCharTokens, *pszEnd))
    {
        return ++pszEnd;
    }

    UINT cch;
    cch = ::strspnf(pszEnd, szWhitespace);
    if (cch > 0)
    {
        return pszEnd + cch;
    }

    cch = ::strspnf(pszEnd, szExtendedAlphaNum);
    if (cch > 0)
    {
        return pszEnd + cch;
    }

    return pszEnd;              /* unrecognized characters */
}


/* GetBool(LPSTR *ppszToken, BOOL *pfOut, PICSRulesBooleanSwitch PRBoolSwitch)
 *
 * t-markh 8/98 (
 * added default parameter PRBoolSwitch=PR_BOOLEAN_TRUEFALSE
 * this allows for no modification of existing code, and extension
 * of the GetBool function from true/false to include pass/fail and
 * yes/no.  The enumerated type PICSRulesBooleanSwitch is defined
 * in picsrule.h)
 *
 * Parses a boolean value at the given token and returns its value in *pfOut.
 * Legal values are 't', 'f', 'true', and 'false'.  If success, *ppszToken
 * is advanced past the boolean token and any following whitespace.  If failure,
 * *ppszToken is not modified.
 *
 * pfOut may be NULL if the caller just wants to eat the token and doesn't
 * care about its value.
 */
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut, PICSRulesBooleanSwitch PRBoolSwitch)
{
    BOOL bValue;

    LPSTR pszTokenEnd = FindTokenEnd(*ppszToken);

    switch(PRBoolSwitch)
    {
        case PR_BOOLEAN_TRUEFALSE:
        {
            if (IsEqualToken(*ppszToken, pszTokenEnd, szShortTrue) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szTrue))
            {
                bValue = TRUE;
            }
            else if (IsEqualToken(*ppszToken, pszTokenEnd, szShortFalse) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szFalse))
            {
                bValue = FALSE;
            }
            else
            {
                TraceMsg( TF_WARNING, "GetBool() - Failed True/False Token Parse at '%s'!", *ppszToken );
                return ResultFromScode(MK_E_SYNTAX);
            }

            break;
        }

        case PR_BOOLEAN_PASSFAIL:
        {
            //szPRShortPass and szPRShortfail are not supported in the
            //official PICSRules spec, but we'll catch them anyway

            if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortPass) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRPass))
            {
                bValue = PR_PASSFAIL_PASS;
            }
            else if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortFail) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRFail))
            {
                bValue = PR_PASSFAIL_FAIL;
            }
            else
            {
                TraceMsg( TF_WARNING, "GetBool() - Failed Pass/Fail Token Parse at '%s'!", *ppszToken );
                return ResultFromScode(MK_E_SYNTAX);
            }

            break;
        }

        case PR_BOOLEAN_YESNO:
        {
            if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortYes) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRYes))
            {
                bValue = PR_YESNO_YES;
            }
            else if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortNo) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRNo))
            {
                bValue = PR_YESNO_NO;
            }
            else
            {
                TraceMsg( TF_WARNING, "GetBool() - Failed Yes/No Token Parse at '%s'!", *ppszToken );
                return ResultFromScode(MK_E_SYNTAX);
            }

            break;
        }

        default:
        {
            return(MK_E_UNAVAILABLE);
        }
    }

    if (pfOut != NULL)
    {
        *pfOut = bValue;
    }

    *ppszToken = pszTokenEnd;
    SkipWhitespace(ppszToken);

    return NOERROR;
}


/* GetQuotedToken(&pszThisToken, &pszQuotedToken)
 *
 * Sets pszQuotedToken to point to the contents of the doublequotes.
 * pszQuotedToken may be NULL if the caller just wants to eat the token.
 * Sets pszThisToken to point to the first character after the closing
 *   doublequote.
 * Fails if pszThisToken doesn't start with a doublequote or doesn't
 *   contain a closing doublequote.
 * The closing doublequote is replaced with a null terminator, iff the
 *   function does not fail.
 */
HRESULT GetQuotedToken(LPSTR *ppszThisToken, LPSTR *ppszQuotedToken)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);

    LPSTR pszStart = *ppszThisToken;
    if (*pszStart != '\"')
    {
        TraceMsg( TF_WARNING, "GetQuotedToken() - Failed to Find Start Quote at '%s'!", pszStart );
        return hres;
    }

    pszStart++;
    LPSTR pszEndQuote = strchrf(pszStart, '\"');
    if (pszEndQuote == NULL)
    {
        TraceMsg( TF_WARNING, "GetQuotedToken() - Failed to Find End Quote at '%s'!", pszStart );
        return hres;
    }

    *pszEndQuote = '\0';
    if (ppszQuotedToken != NULL)
    {
        *ppszQuotedToken = pszStart;
    }

    *ppszThisToken = pszEndQuote+1;

    return NOERROR;
}


BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch)
{
    UINT cbToken = strlenf(pszTokenToMatch);

    if (cbToken != (UINT)(pszTokenEnd - pszTokenStart) || strnicmpf(pszTokenStart, pszTokenToMatch, cbToken))
    {
        return FALSE;
    }

    return TRUE;
}


/* ParseLiteralToken(ppsz, pszToken) tries to match *ppsz against pszToken.
 * If they don't match, an error is returned.  If they do match, then *ppsz
 * is advanced past the token and any following whitespace.
 *
 * If ppszInvalid is NULL, then the function is non-destructive in the error
 * path, so it's OK to call ParseLiteralToken just to see if a possible literal
 * token is what's next; if the token isn't found, whatever was there didn't
 * get eaten or anything.
 *
 * If ppszInvalid is not NULL, then if the token doesn't match, *ppszInvalid
 * will be set to *ppsz.
 */
HRESULT ParseLiteralToken(LPSTR *ppsz, LPCSTR pszToken, LPCSTR *ppszInvalid)
{
    LPSTR pszTokenEnd = FindTokenEnd(*ppsz);

    if (!IsEqualToken(*ppsz, pszTokenEnd, pszToken))
    {
        if (ppszInvalid != NULL)
        {
            *ppszInvalid = *ppsz;
        }

//      TraceMsg( TF_WARNING, "ParseLiteralToken() - Token '%s' Not Found at '%s'!", pszToken, *ppsz );

        return ResultFromScode(MK_E_SYNTAX);
    }

    *ppsz = pszTokenEnd;

    SkipWhitespace(ppsz);

    return NOERROR;
}


/* ParseServiceError parses a service-error construct, once it's been
 * determined that such is the case.  m_pszCurrent has been advanced past
 * the 'error' keyword that indicates a service-error.
 *
 * We're pretty flexible about the contents of this stuff.  We basically
 * accept anything of the form:
 *
 * 'error' '(' <error string> [quoted explanations] ')'     - or -
 * 'error' <error string>
 *
 * without caring too much about what the error string actually is.
 *
 * A format with quoted explanations but without the parens would not be
 * legal, we wouldn't be able to distinguish the explanations from the
 * serviceID of the next service-info.
 */
HRESULT CParsedServiceInfo::ParseServiceError()
{
    BOOL fParen = FALSE;
    HRESULT hres = NOERROR;

    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szLeftParen, NULL)))
    {
        fParen = TRUE;
    }

    LPSTR pszErrorEnd = FindTokenEnd(m_pszCurrent);     /* find end of error string */

    m_pszErrorString = m_pszCurrent;                /* remember start of error string */
    if (fParen)
    {                           /* need to eat explanations */
        m_pszCurrent = pszErrorEnd;         /* skip error string to get to explanations */
        SkipWhitespace();
        while (SUCCEEDED(hres))
        {
            hres = GetQuotedToken(&m_pszCurrent, NULL);
            SkipWhitespace();
        }
    }

    if (fParen)
    {
        hres = ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
    }
    else
    {
        hres = NOERROR;
    }

    if (SUCCEEDED(hres))
    {
        *pszErrorEnd = '\0';            /* null-terminate the error string */
    }

    return hres;
}


/* ParseNumber parses a numeric token at the specified position.  If the
 * number makes sense, the pointer is advanced to the end of the number
 * and past any following whitespace, and the numeric value is returned
 * in *pnOut.  Any non-numeric characters are considered to terminate the
 * number without error;  it is assumed that higher-level parsing code
 * will eventually reject such characters if they're not supposed to be
 * there.
 *
 * pnOut may be NULL if the caller doesn't care about the number being
 * returned and just wants to eat it.
 *
 * Floating point numbers of the form nnn.nnn are rounded to the next
 * higher integer and returned as such.
 */
//t-markh 8/98 - added fPICSRules for line counting support in PICSRules
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut,BOOL fPICSRules)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    BOOL fNegative = FALSE;
    INT nAccum = 0;
    BOOL fNonZeroDecimal = FALSE;
    BOOL fInDecimal = FALSE;
    BOOL fFoundDigits = FALSE;

    LPSTR pszCurrent = *ppszNumber;

    /* Handle one sign character. */
    if (*pszCurrent == '+')
    {
        pszCurrent++;
    }
    else if (*pszCurrent == '-')
    {
        pszCurrent++;
        fNegative = TRUE;
    }

    for (;;)
    {
        if (*pszCurrent == '.')
        {
            fInDecimal = TRUE;
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9')
        {
            fFoundDigits = TRUE;
            if (fInDecimal)
            {
                if (*pszCurrent > '0')
                {
                    fNonZeroDecimal = TRUE;
                }
            }
            else
            {
                nAccum = nAccum * 10 + (*pszCurrent - '0');
            }
        }
        else
        {
            break;
        }

        pszCurrent++;
    }

    if (fFoundDigits)
    {
        hres = NOERROR;
        if (fNonZeroDecimal)
        {
            nAccum++;           /* round away from zero if decimal present */
        }

        if (fNegative)
        {
            nAccum = -nAccum;
        }
    }

    if (SUCCEEDED(hres))
    {
        if (pnOut != NULL)
        {
            *pnOut = nAccum;
        }

        *ppszNumber = pszCurrent;
        if ( fPICSRules == FALSE )
        {
            SkipWhitespace(ppszNumber);
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "ParseNumber() - Failed with hres=0x%x at '%s'!", hres, pszCurrent );
    }

    return hres;
}


/* ParseExtensionData just needs to get past whatever data was supplied
 * for an extension.  The PICS spec implies that it can be recursive, which
 * complicates matters a bit:
 *
 * data :: quoted-ISO-date | quotedURL | number | quotedname | '(' data* ')'
 *
 * Use of recursion here is probably OK, we don't really expect complicated
 * nested extensions all that often, and this function doesn't use a lot of
 * stack or other resources...
 */
HRESULT CParsedServiceInfo::ParseExtensionData(COptionsBase *pOpt)
{
    HRESULT hres;

    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szLeftParen, NULL)))
    {
        hres = ParseExtensionData(pOpt);
        if (FAILED(hres))
        {
            return hres;
        }

        return ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
    }

    if (SUCCEEDED(GetQuotedToken(&m_pszCurrent, NULL)))
    {
        SkipWhitespace();
        return NOERROR;
    }

    hres = ParseNumber(&m_pszCurrent, NULL);
    if (FAILED(hres))
    {
        m_pszInvalidString = m_pszCurrent;
    }

    return hres;
}


/* ParseExtension parses an extension option.  Syntax is:
 *
 * extension ( mandatory|optional "identifyingURL" data )
 *
 * Currently all extensions are parsed but ignored, although a mandatory
 * extension causes the entire options structure and anything dependent
 * on it to be invalidated.
 */
HRESULT CParsedServiceInfo::ParseExtension(COptionsBase *pOpt)
{
    HRESULT hres;

    hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Missing '(' at '%s'!", m_pszInvalidString );
        return hres;
    }

    hres = ParseLiteralToken(&m_pszCurrent, szOptional, &m_pszInvalidString);
    if (FAILED(hres))
    {
        hres = ParseLiteralToken(&m_pszCurrent, szMandatory, &m_pszInvalidString);
        if (SUCCEEDED(hres))
        {
            pOpt->m_fdwFlags |= LBLOPT_INVALID;
        }
    }

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Failed ParseLiteralToken() with hres=0x%x at '%s'!", hres, m_pszInvalidString );
        return hres;            /* this causes us to lose our place -- OK? */
    }

    hres = GetQuotedToken(&m_pszCurrent, NULL);
    if (FAILED(hres))
    {
        m_pszInvalidString = m_pszCurrent;
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Missing Quote at '%s'!", m_pszInvalidString );
        return hres;
    }

    SkipWhitespace();

    while (*m_pszCurrent != ')' && *m_pszCurrent != '\0')
    {
        hres = ParseExtensionData(pOpt);
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Failed ParseExtensionData() with hres=0x%x!", hres );
            return hres;
        }
    }

    if (*m_pszCurrent != ')')
    {
        m_pszInvalidString = m_pszCurrent;
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Missing ')' at '%s'!", m_pszInvalidString );
        return ResultFromScode(MK_E_SYNTAX);
    }

    m_pszCurrent++;
    SkipWhitespace();

    return NOERROR;
}


/* ParseTime parses a "quoted-ISO-date" as found in a label.  This is required
 * to have the following form, as quoted from the PICS spec:
 *
 * quoted-ISO-date :: YYYY'.'MM'.'DD'T'hh':'mmStz
 *  YYYY :: four-digit year
 *  MM :: two-digit month (01=January, etc.)
 *  DD :: two-digit day of month (01-31)
 *  hh :: two digits of hour (00-23)
 *  mm :: two digits of minute (00-59)
 *  S :: sign of time zone offset from UTC (+ or -)
 *  tz :: four digit amount of offset from UTC (e.g., 1512 means 15 hours 12 minutes)
 *
 * Example: "1994.11.05T08:15-0500" means Nov. 5, 1994, 8:15am, US EST.
 *
 * Time is parsed into NET format -- seconds since 1970 (easiest to adjust for
 * time zones, and compare with).  Returns an error if string is invalid.
 */

/* Template describing the string format.  'n' means a digit, '+' means a
 * plus or minus sign, any other character must match that literal character.
 */
const char szTimeTemplate[] = "nnnn.nn.nnTnn:nn+nnnn";
const char szPICSRulesTimeTemplate[] = "nnnn-nn-nnTnn:nn+nnnn";

HRESULT ParseTime(LPSTR pszTime, DWORD *pOut, BOOL fPICSRules)
{
    /* Copy the time string into a temporary buffer, since we're going to
     * stomp on some separators.  We preserve the original in case it turns
     * out to be invalid and we have to show it to the user later.
     */
    LPCSTR pszCurrTemplate;
    
    char szTemp[sizeof(szTimeTemplate)];

    if (::strlenf(pszTime) >= sizeof(szTemp))
    {
        TraceMsg( TF_WARNING, "ParseTime() - Time String Too Long (pszTime='%s', %d chars expected)!", pszTime, sizeof(szTemp) );
        return ResultFromScode(MK_E_SYNTAX);
    }

    strcpyf(szTemp, pszTime);

    LPSTR pszCurrent = szTemp;

    if(fPICSRules)
    {
        pszCurrTemplate = szPICSRulesTimeTemplate;
    }
    else
    {
        pszCurrTemplate = szTimeTemplate;
    }

    /* First validate the format against the template.  If that succeeds, then
     * we get to make all sorts of assumptions later.
     *
     * We stomp all separators except the +/- for the timezone with spaces
     * so that ParseNumber will (a) skip them for us, and (b) not interpret
     * the '.' separators as decimal points.
     */
    BOOL fOK = TRUE;
    while (*pszCurrent && *pszCurrTemplate && fOK)
    {
        char chCurrent = *pszCurrent;

        switch (*pszCurrTemplate)
        {
        case 'n':
            if (chCurrent < '0' || chCurrent > '9')
            {
                fOK = FALSE;
            }

            break;

        case '+':
            if (chCurrent != '+' && chCurrent != '-')
            {
                fOK = FALSE;
            }

            break;

        default:
            if (chCurrent != *pszCurrTemplate)
            {
                fOK = FALSE;
            }
            else
            {
                *pszCurrent = ' ';
            }
            break;
        }

        pszCurrent++;
        pszCurrTemplate++;
    }

    /* If invalid character, or didn't reach the ends of both strings
     * simultaneously, fail.
     */
    if (!fOK || *pszCurrent || *pszCurrTemplate)
    {
        TraceMsg( TF_WARNING, "ParseTime() - Invalid Character or Strings Mismatch (fOK=%d, pszCurrent='%s', pszCurrTemplate='%s')!", fOK, pszCurrent, pszCurrTemplate );
        return ResultFromScode(MK_E_SYNTAX);
    }

    HRESULT hres;
    int n;
    SYSTEMTIME st;

    /* We parse into SYSTEMTIME structure because it has separate fields for
     * the different components.  We then convert to net time (seconds since
     * Jan 1 1970) to easily add the timezone bias and compare with other
     * times.
     *
     * The sense of the bias sign is inverted because it indicates the direction
     * of the bias FROM UTC.  We want to use it to convert the specified time
     * back TO UTC.
     */

    int nBiasSign = -1;
    int nBiasNumber;
    pszCurrent = szTemp;
    hres = ParseNumber(&pszCurrent, &n);
    if (SUCCEEDED(hres) && n >= 1980)
    {
        st.wYear = (WORD)n;
        hres = ParseNumber(&pszCurrent, &n);
        if (SUCCEEDED(hres) && n <= 12)
        {
            st.wMonth = (WORD)n;
            hres = ParseNumber(&pszCurrent, &n);
            if (SUCCEEDED(hres) && n < 32)
            {
                st.wDay = (WORD)n;
                hres = ParseNumber(&pszCurrent, &n);
                if (SUCCEEDED(hres) && n <= 23)
                {
                    st.wHour = (WORD)n;
                    hres = ParseNumber(&pszCurrent, &n);
                    if (SUCCEEDED(hres) && n <= 59)
                    {
                        st.wMinute = (WORD)n;
                        if (*(pszCurrent++) == '-')
                        {
                            nBiasSign = 1;
                        }

                        hres = ParseNumber(&pszCurrent, &nBiasNumber);
                    }
                }
            }
        }
    }

    /* Seconds are used by the time converter, but are not specified in
     * the label.
     */
    st.wSecond = 0;

    /* Other fields (wDayOfWeek, wMilliseconds) are ignored when converting
     * to net time.
     */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "ParseTime() - Failed to Parse Time where hres=0x%x!", hres );
        return hres;
    }

    DWORD dwTime = SystemToNetDate(&st);

    /* The bias number is 4 digits, but hours and minutes.  Convert to
     * a number of seconds.
     */
    nBiasNumber = (((nBiasNumber / 100) * 60) + (nBiasNumber % 100)) * 60;

    /* Adjust the time by the timezone bias, and return to the caller. */
    *pOut = dwTime + (nBiasNumber * nBiasSign);

    return hres;
}


/* ParseOptions parses through any label options that may be present at
 * m_pszCurrent.  pszTokenEnd initially points to the end of the token at
 * m_pszCurrent, a small perf win since the caller has already calculated
 * it.  If ParseOptions is filling in the static options structure embedded
 * in the serviceinfo, pOpt points to it and ppOptOut will be NULL.  If pOpt
 * is NULL, then ParseOptions will construct a new CDynamicOptions object
 * and return it in *ppOptOut, iff any new options are found at the current
 * token.  pszOptionEndToken indicates the token which ends the list of
 * options -- either "labels" or "ratings".  A token consisting of just the
 * first character of pszOptionEndToken will also terminate the list.
 *
 * ParseOptions fails iff it finds an option it doesn't recognize, or a
 * syntax error in an option it does recognize.  It succeeds if all options
 * are syntactically correct or if there are no options to parse.
 *
 * The token which terminates the list of options is also consumed.
 *
 * FEATURE - how should we flag mandatory extensions, 'until' options that
 * give an expired date, etc.?  set a flag in the CParsedServiceInfo and
 * keep parsing?
 */

enum OptionID {
    OID_AT,
    OID_BY,
    OID_COMMENT,
    OID_FULL,
    OID_EXTENSION,
    OID_GENERIC,
    OID_FOR,
    OID_MIC,
    OID_ON,
    OID_SIG,
    OID_UNTIL
};

enum OptionContents {
    OC_QUOTED,
    OC_BOOL,
    OC_SPECIAL
};

const struct {
    LPCSTR pszToken;
    OptionID oid;
    OptionContents oc;
} aKnownOptions[] = {
    { szAtOption, OID_AT, OC_QUOTED },
    { szByOption, OID_BY, OC_QUOTED },
    { szCommentOption, OID_COMMENT, OC_QUOTED },
    { szCompleteLabelOption, OID_FULL, OC_QUOTED },
    { szFullOption, OID_FULL, OC_QUOTED },
    { szExtensionOption, OID_EXTENSION, OC_SPECIAL },
    { szGenericOption, OID_GENERIC, OC_BOOL },
    { szShortGenericOption, OID_GENERIC, OC_BOOL },
    { szForOption, OID_FOR, OC_QUOTED },
    { szMICOption, OID_MIC, OC_QUOTED },
    { szMD5Option, OID_MIC, OC_QUOTED },
    { szOnOption, OID_ON, OC_QUOTED },
    { szSigOption, OID_SIG, OC_QUOTED },
    { szUntilOption, OID_UNTIL, OC_QUOTED },
    { szExpOption, OID_UNTIL, OC_QUOTED }
};

const UINT cKnownOptions = sizeof(aKnownOptions) / sizeof(aKnownOptions[0]);
    

HRESULT CParsedServiceInfo::ParseOptions(LPSTR pszTokenEnd, COptionsBase *pOpt,
                             CDynamicOptions **ppOptOut, LPCSTR pszOptionEndToken)
{
    HRESULT hres = NOERROR;
    char szShortOptionEndToken[2];

    szShortOptionEndToken[0] = *pszOptionEndToken;
    szShortOptionEndToken[1] = '\0';

    if (pszTokenEnd == NULL)
    {
        pszTokenEnd = FindTokenEnd(m_pszCurrent);
    }

    do
    {
        /* Have we hit the token that signals the end of the options? */
        if (IsEqualToken(m_pszCurrent, pszTokenEnd, pszOptionEndToken) ||
            IsEqualToken(m_pszCurrent, pszTokenEnd, szShortOptionEndToken))
        {
            m_pszCurrent = pszTokenEnd;
            SkipWhitespace();
            return NOERROR;
        }

        for (UINT i=0; i<cKnownOptions; i++)
        {
            if (IsEqualToken(m_pszCurrent, pszTokenEnd, aKnownOptions[i].pszToken))
            {
                break;
            }
        }

        if (i == cKnownOptions)
        {
            m_pszInvalidString = m_pszCurrent;

            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Unknown Token Encountered at '%s'!", m_pszInvalidString );

            return ResultFromScode(MK_E_SYNTAX);    /* unrecognized option */
        }

        m_pszCurrent = pszTokenEnd;
        SkipWhitespace();

        /* Now parse the stuff that comes after the option token. */
        LPSTR pszQuotedString = NULL;
        BOOL fBoolOpt = FALSE;
        switch (aKnownOptions[i].oc)
        {
        case OC_QUOTED:
            hres = GetQuotedToken(&m_pszCurrent, &pszQuotedString);
            break;

        case OC_BOOL:
            hres = GetBool(&m_pszCurrent, &fBoolOpt);
            break;

        case OC_SPECIAL:
            break;          /* we'll handle this specially */
        }

        if (FAILED(hres))
        { /* incorrect stuff after the option token */
            m_pszInvalidString = m_pszCurrent;

            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Failed Option Contents Parse at '%s'!", m_pszInvalidString );

            return hres;
        }

        if (pOpt == NULL)
        {     /* need to allocate a new options structure */
            CDynamicOptions *pNew = new CDynamicOptions;
            if (pNew == NULL)
            {
                TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Failed to Create CDynamicOptions Object!" );
                return ResultFromScode(E_OUTOFMEMORY);
            }

            pOpt = pNew;
            *ppOptOut = pNew;   /* return new structure to caller */
        }

        /* Now actually do useful stuff based on which option it is. */
        switch (aKnownOptions[i].oid)
        {
        case OID_UNTIL:
            hres = ParseTime(pszQuotedString, &pOpt->m_timeUntil);
            if (FAILED(hres))
            {
                m_pszInvalidString = pszQuotedString;
            }

            break;

        case OID_FOR:
            pOpt->m_pszURL = pszQuotedString;
            break;

        case OID_GENERIC:
            if (fBoolOpt)
            {
                pOpt->m_fdwFlags |= LBLOPT_GENERIC;
            }
            else
            {
                pOpt->m_fdwFlags &= ~LBLOPT_GENERIC;
            }
            break;

        case OID_EXTENSION:
            hres = ParseExtension(pOpt);
            break;
        }

        if ( FAILED(hres) )
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Failed Option ID Parse at '%s'!", m_pszCurrent );
        }

        SkipWhitespace();

        pszTokenEnd = FindTokenEnd(m_pszCurrent);
    } while (SUCCEEDED(hres));

    return hres;
}


/* CParsedServiceInfo::ParseRating parses a single rating -- a transmit-name
 * followed by either a number or a parenthesized list of multi-values.  The
 * corresponding rating is stored in the current list of ratings.
 */
HRESULT CParsedServiceInfo::ParseRating()
{
    LPSTR pszTokenEnd = FindTokenEnd(m_pszCurrent);
    if (*m_pszCurrent == '\0')
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseRating() - Empty String after FindTokenEnd()!" );
        return ResultFromScode(MK_E_SYNTAX);
    }

    *(pszTokenEnd++) = '\0';

    CParsedRating r;

    r.pszTransmitName = m_pszCurrent;
    m_pszCurrent = pszTokenEnd;
    SkipWhitespace();

    HRESULT hres = ParseNumber(&m_pszCurrent, &r.nValue);
    if (FAILED(hres))
    {
        m_pszInvalidString = m_pszCurrent;
        return hres;
    }

    r.pOptions = m_poptCurrent;
    r.fFound = FALSE;
    r.fFailed = FALSE;

    return (aRatings.Append(r) ? NOERROR : ResultFromScode(E_OUTOFMEMORY));
}


/* CParsedServiceInfo::ParseSingleLabel starts parsing where a single-label
 * should occur.  A single-label may contain options (in which case a new
 * options structure will be allocated), following by the keyword 'ratings'
 * (or 'r') and a parenthesized list of ratings.
 */
HRESULT CParsedServiceInfo::ParseSingleLabel()
{
    HRESULT hres;
    CDynamicOptions *pOpt = NULL;

    hres = ParseOptions(NULL, NULL, &pOpt, szRatings);
    if (FAILED(hres))
    {
        if (pOpt != NULL)
        {
            pOpt->Release();
        }

        return hres;
    }
    if (pOpt != NULL)
    {
        pOpt->m_pNext = m_poptList;
        m_poptList = pOpt;
        m_poptCurrent = pOpt;
    }

    hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseSingleLabel() - ParseLiteralToken() Failed with hres=0x%x!", hres );
        return hres;
    }

    do
    {
        hres = ParseRating();
    } while (SUCCEEDED(hres) && *m_pszCurrent != ')' && *m_pszCurrent != '\0');

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseSingleLabel() - ParseRating() Failed with hres=0x%x!", hres );
        return hres;
    }

    return ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
}


/* CParsedServiceInfo::ParseLabels starts parsing just past the keyword
 * 'labels' (or 'l').  It needs to handle a label-error, a single-label,
 * or a parenthesized list of single-labels.
 */
HRESULT CParsedServiceInfo::ParseLabels()
{
    HRESULT hres;

    /* First deal with a label-error.  It begins with the keyword 'error'. */
    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szError, NULL)))
    {
        hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseLabels() - ParseLiteralToken() Failed with hres=0x%x!", hres );
            return hres;
        }

        LPSTR pszTokenEnd = FindTokenEnd(m_pszCurrent);
        m_pszErrorString = m_pszCurrent;
        m_pszCurrent = pszTokenEnd;
        SkipWhitespace();

        while (*m_pszCurrent != ')')
        {
            hres = GetQuotedToken(&m_pszCurrent, NULL);
            if (FAILED(hres))
            {
                m_pszInvalidString = m_pszCurrent;
                TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseLabels() - GetQuotedToken() Failed with hres=0x%x!", hres );
                return hres;
            }
        }

        return NOERROR;
    }

    BOOL fParenthesized = FALSE;

    /* If we see a left paren, it's a parenthesized list of single-labels,
     * which basically means we'll have to eat an extra parenthesis later.
     */
    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szLeftParen, NULL)))
    {
        fParenthesized = TRUE;
    }

    for (;;)
    {
        /* Things which signify the end of the label list:
         * - the close parenthesis checked for above
         * - a quoted string, indicating the next service-info
         * - the end of the string
         * - a service-info saying "error (no-ratings <explanation>)"
         *
         * Check the easy ones first.
         */
        if (*m_pszCurrent == ')' || *m_pszCurrent == '\"' || *m_pszCurrent == '\0')
        {
            break;
        }

        /* Now look for that tricky error-state service-info. */
        LPSTR pszTemp = m_pszCurrent;
        if (SUCCEEDED(ParseLiteralToken(&pszTemp, szError, NULL)) &&
            SUCCEEDED(ParseLiteralToken(&pszTemp, szLeftParen, NULL)) &&
            SUCCEEDED(ParseLiteralToken(&pszTemp, szNoRatings, NULL)))
        {
            break;
        }

        hres = ParseSingleLabel();
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseLabels() - ParseSingleLabel() Failed with hres=0x%x!", hres );
            return hres;
        }
    }

    if (fParenthesized)
    {
        return ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
    }

    return NOERROR;
}


/* Parse is passed a pointer to a pointer to something which should
 * be a service-info string (i.e., not the close paren for the labellist, and
 * not the end of the string).  The caller's string pointer is advanced to the
 * end of the service-info string.
 */
HRESULT CParsedServiceInfo::Parse(LPSTR *ppszServiceInfo)
{
    /* NOTE: Do not return out of this function without copying m_pszCurrent
     * back into *ppszServiceInfo!  Always store your return code in hres and
     * exit out the bottom of the function.
     */
    HRESULT hres;

    m_pszCurrent = *ppszServiceInfo;

    hres = ParseLiteralToken(&m_pszCurrent, szError, NULL);
    if (SUCCEEDED(hres))
    {
        /* Keyword is 'error'.  Better be followed by '(', 'no-ratings',
         * explanations, and a close-paren.
         */
        hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
        if (SUCCEEDED(hres))
        {
            hres = ParseLiteralToken(&m_pszCurrent, szNoRatings, &m_pszInvalidString);
        }

        if (SUCCEEDED(hres))
        {
            m_pszErrorString = szNoRatings;

            while (*m_pszCurrent != ')' && *m_pszCurrent != '\0') 
            {
                hres = GetQuotedToken(&m_pszCurrent, NULL);
                if (FAILED(hres))
                {
                    m_pszInvalidString = m_pszCurrent;
                    break;
                }

                SkipWhitespace();
            }

            if (*m_pszCurrent == ')')
            {
                m_pszCurrent++;
                SkipWhitespace();
            }
        }
    }
    else
    {
        /* Keyword is not 'error'.  Better start with a serviceID --
         * a quoted URL.
         */
        LPSTR pszServiceID;
        hres = GetQuotedToken(&m_pszCurrent, &pszServiceID);
        if (SUCCEEDED(hres))
        {
            m_pszServiceName = pszServiceID;

            SkipWhitespace();

            /* Past the serviceID.  Next either 'error' indicating a service-error,
             * or we start options and then a labelword.
             */

            LPSTR pszTokenEnd = FindTokenEnd(m_pszCurrent);

            if (IsEqualToken(m_pszCurrent, pszTokenEnd, szError))
            {
                m_pszCurrent = pszTokenEnd;
                SkipWhitespace();
                hres = ParseServiceError();
            }
            else
            {
                hres = ParseOptions(pszTokenEnd, &m_opt, NULL, ::szLabelWord);
                if (SUCCEEDED(hres))
                {
                    hres = ParseLabels();
                }
            }
        }
        else
        {
            m_pszInvalidString = m_pszCurrent;
        }
    }

    *ppszServiceInfo = m_pszCurrent;
    return hres;
}


const char szPicsVersionLabel[] = "PICS-";
const UINT cchLabel = (sizeof(szPicsVersionLabel)-1) / sizeof(szPicsVersionLabel[0]);

HRESULT CParsedLabelList::Parse(LPSTR pszCopy)
{
    m_pszList = pszCopy;                /* we own the label list string now */

    /* Make another copy, which we won't carve up during parsing, so that the
     * access-denied dialog can compare literal labels.
     */
    m_pszOriginalLabel = new char[::strlenf(pszCopy)+1];
    if (m_pszOriginalLabel != NULL)
    {
        ::strcpyf(m_pszOriginalLabel, pszCopy);
    }

    m_pszCurrent = m_pszList;

    SkipWhitespace();

    HRESULT hres;

    hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - ParseLiteralToken() Failed with hres=0x%x!", hres );
        return hres;
    }

    if (strnicmpf(m_pszCurrent, szPicsVersionLabel, cchLabel))
    {
        TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - Pics Version Label Comparison Failed at '%s'!", m_pszCurrent );
        return ResultFromScode(MK_E_SYNTAX);
    }

    m_pszCurrent += cchLabel;
    INT nVersion;
    hres = ParseNumber(&m_pszCurrent, &nVersion);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - ParseNumber() Failed with hres=0x%x!", hres );
        return hres;
    }

    CParsedServiceInfo *psi = &m_ServiceInfo;

    do
    {
        hres = psi->Parse(&m_pszCurrent);
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - psi->Parse() Failed with hres=0x%x!", hres );
            return hres;
        }

        if (*m_pszCurrent != ')' && *m_pszCurrent != '\0')
        {
            CParsedServiceInfo *pNew = new CParsedServiceInfo;
            if (pNew == NULL)
            {
                TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - Failed to Create CParsedServiceInfo!" );
                return ResultFromScode(E_OUTOFMEMORY);
            }

            psi->Append(pNew);
            psi = pNew;
        }
    } while (*m_pszCurrent != ')' && *m_pszCurrent != '\0');

    return NOERROR;
}


HRESULT ParseLabelList(LPCSTR pszList, CParsedLabelList **ppParsed)
{
    LPSTR pszCopy = new char[strlenf(pszList)+1];
    if (pszCopy == NULL)
    {
        TraceMsg( TF_WARNING, "ParseLabelList() - Failed to Create pszCopy!" );
        return ResultFromScode(E_OUTOFMEMORY);
    }

    ::strcpyf(pszCopy, pszList);

    *ppParsed = new CParsedLabelList;
    if (*ppParsed == NULL)
    {
        TraceMsg( TF_WARNING, "ParseLabelList() - Failed to Create CParsedLabelList!" );
        delete pszCopy;
        pszCopy = NULL;
        return ResultFromScode(E_OUTOFMEMORY);
    }

    return (*ppParsed)->Parse(pszCopy);
}


void FreeParsedLabelList(CParsedLabelList *pList)
{
    delete pList;
    pList = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\passdlg.cpp ===
/****************************************************************************\
 *
 *   passdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Password Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "passdlg.h"        // CPasswordDialog
#include "hint.h"           // CHint
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

DWORD CPasswordDialog::aIds[] = {
    IDC_STATIC3,            IDH_IGNORE,
    IDC_STATIC2,            IDH_IGNORE,
    IDC_OLD_HINT_LABEL,     IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_OLD_HINT_TEXT,      IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_STATIC1,            IDH_RATINGS_SUPERVISOR_PASSWORD,
    IDC_PASSWORD,           IDH_RATINGS_SUPERVISOR_PASSWORD,
    0,0
};

CPasswordDialog::CPasswordDialog( int p_idsLabel, bool p_fCheckPassword )
{
    m_idsLabel = p_idsLabel;
    m_fCheckPassword = p_fCheckPassword;
}

LRESULT CPasswordDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Show or Hide the Hint and Password label/edit controls
    ShowHideControl( IDC_OLD_HINT_LABEL, m_fCheckPassword );
    ShowHideControl( IDC_OLD_HINT_TEXT, m_fCheckPassword );
    ShowHideControl( IDC_STATIC1, m_fCheckPassword );
    ShowHideControl( IDC_PASSWORD, m_fCheckPassword );

    // Reduce the height of the dialog.
    if ( ! m_fCheckPassword )
    {
        ReduceDialogHeight( IDC_STATIC2 );
    }

    // Set the text label displayed.
    if ( GetDlgItem( IDC_STATIC2 ) != NULL )
    {
        NLS_STR nlsLabel(MAX_RES_STR_LEN);

        if ( nlsLabel.LoadString( static_cast<USHORT>(m_idsLabel) ) == ERROR_SUCCESS )
        {
            ::SetWindowText( GetDlgItem(IDC_STATIC2), nlsLabel.QueryPch() );
        }
    }

    if ( GetDlgItem( IDC_PASSWORD ) != NULL )
    {
        SendDlgItemMessage(IDC_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
    }

    // Display previously created hint (if one exists).
    {
        CHint       oldHint( m_hWnd, IDC_OLD_HINT_TEXT );

        oldHint.DisplayHint();
    }

    ::SetFocus(GetDlgItem(IDC_PASSWORD));

    bHandled = FALSE;
    return 0L;  // Let the system set the focus
}

LRESULT CPasswordDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(PASSCONFIRM_FAIL);
    return 0L;
}

LRESULT CPasswordDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if ( m_fCheckPassword )
    {
        CHAR pszPassword[MAXPATHLEN];
        HRESULT hRet;

        pszPassword[0] = '\0';

        ASSERT( GetDlgItem( IDC_PASSWORD ) != NULL );

        GetDlgItemText( IDC_PASSWORD, pszPassword, sizeof(pszPassword) );

        hRet = VerifySupervisorPassword(pszPassword);

        if (hRet == (NOERROR))
        {
            EndDialog(PASSCONFIRM_OK);
        }
        else
        {
            HWND            hDlg = m_hWnd;
            MyMessageBox(hDlg, IDS_BADPASSWORD, IDS_GENERIC, MB_OK|MB_ICONERROR);    
            SetErrorControl( IDC_PASSWORD );
        }
    }
    else
    {
        EndDialog( PASSCONFIRM_NEW );
    }

    return 0L;
}

LRESULT CPasswordDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CPasswordDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\pch.cpp ===
#include "msrating.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\picsdlg.cpp ===
/****************************************************************************\
 *
 *   picsdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Pics Ratings Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "picsdlg.h"        // CPicsDialog
#include "debug.h"          // TraceMsg()
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

/*Helpers---------------------------------------------------------------------*/
int     g_nKeys, g_nLock; //         indexes of the images 

DWORD CPicsDialog::aIds[] = {
    IDC_STATIC1,        IDH_RATINGS_CATEGORY_LABEL,
    IDC_PT_TREE,        IDH_RATINGS_CATEGORY_LIST,
    IDC_RATING_LABEL,   IDH_RATINGS_RATING_LABEL,
    IDC_PT_TB_SELECT,   IDH_RATINGS_RATING_LABEL,
    IDC_PT_T_RSN_SDESC, IDH_RATINGS_RATING_TEXT,
    IDC_STATIC2,        IDH_RATINGS_DESCRIPTION_LABEL,
    IDC_PT_T_RSN_LDESC, IDH_RATINGS_DESCRIPTION_TEXT,
    IDC_STATIC3,        IDH_RATINGS_VIEW_PROVIDER_PAGE,
    IDC_DETAILSBUTTON,  IDH_RATINGS_VIEW_PROVIDER_PAGE,
    0,0
};

CPicsDialog::CPicsDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

LRESULT CPicsDialog::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TV_ITEM  tvm;
    TreeNode *pTN;

    InitTreeViewImageLists(GetDlgItem(IDC_PT_TREE));

    //force the trackbar to redraw its background with the new color
    PRSD *          pPRSD = m_pPRSD;

    ZeroMemory(&tvm,sizeof(tvm));

    tvm.hItem=TreeView_GetSelection(GetDlgItem(IDC_PT_TREE));
    tvm.mask=TVIF_PARAM;

    TreeView_GetItem(GetDlgItem(IDC_PT_TREE),&tvm);

    pTN=(TreeNode *) tvm.lParam;

    ASSERT( pTN );

    if ( ! pTN )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnSysColorChange() - pTN is NULL!" );
        return 0L;
    }

    ControlsShow( pTN->tne );
    
    switch(pTN->tne)
    {
        case tneRatingSystemInfo:
        {
            SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
            break;
        }
        case tneRatingSystemNode:
        {
            SelectRatingSystemNode( (PicsCategory*) pTN->pData );
            break;
        }
    }

    return 0L;
}

LRESULT CPicsDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PicsDlgInit();

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CPicsDialog::OnScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    switch (LOWORD(wParam)){
        case TB_THUMBTRACK:
        case TB_BOTTOM:
        case TB_ENDTRACK:
        case TB_LINEDOWN:
        case TB_LINEUP:
        case TB_PAGEDOWN:
        case TB_PAGEUP:
        case TB_THUMBPOSITION:
        case TB_TOP:
            NewTrackbarPosition();
            MarkChanged();
            break;
    }

    return 0L;
}

LRESULT CPicsDialog::OnDetails(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LaunchRatingSystemSite();
    return 0L;
}

LRESULT CPicsDialog::OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    PRSD *          pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnSetActive() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->fNewProviders)
    {
        //Means that user changed list of provider files
        HWND  hwndTree;
        hwndTree = GetDlgItem(IDC_PT_TREE);
        KillTree(hwndTree , TreeView_GetRoot(hwndTree));
        pPRSD->fNewProviders = FALSE;
        PicsDlgInit();
    }

    bHandled = FALSE;
    return 0L;
}

LRESULT CPicsDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    /*do apply stuff*/

    PicsDlgSave();

    if ( ! lpPSHNotify->lParam )
    {
        // Apply 
        return PSNRET_NOERROR;
    }

    // Do this if hit OK or Cancel, not Apply
    OnReset( idCtrl, pnmh, bHandled );

    return PSNRET_NOERROR;
}

LRESULT CPicsDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    // Do this if hit OK or Cancel, not Apply
    HWND hDlg = m_hWnd;
    ASSERT( hDlg );

    SendMessage(hDlg,WM_SETREDRAW, FALSE,0L);
    PicsDlgUninit();
    SendMessage(hDlg,WM_SETREDRAW, TRUE,0L);

    return 0L;
}

LRESULT CPicsDialog::OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMTREEVIEW pNMTreeView = (LPNMTREEVIEW)pnmh;

    if ( ! pNMTreeView )
    {
        return 0L;
    }

    if (pNMTreeView->action == TVE_COLLAPSE)
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, TRUE);
        return 1L; //Suppress expanding tree.
    }

    return 0L;
}

LRESULT CPicsDialog::OnTreeSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMTREEVIEW pNMTreeView = (LPNMTREEVIEW)pnmh;
    TreeNode    *pTN = pNMTreeView ? ((TreeNode*) pNMTreeView->itemNew.lParam) : NULL;

    if ( ! pTN )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnTreeSelChanged() - pTN is NULL!" );
        return 0L;
    }

    PRSD *      pPRSD = m_pPRSD;

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnTreeSelChanged() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->fNewProviders)
    {
        return 1L;    /* tree is being cleaned up, ignore sel changes */
    }

    ControlsShow( pTN->tne );

    switch(pTN->tne)
    {
        case tneRatingSystemInfo:
            SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
            break;
        case tneRatingSystemNode:
            SelectRatingSystemNode( (PicsCategory*) pTN->pData );
            break;
    }

    return 1L;
}

LRESULT CPicsDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CPicsDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

// InitTreeViewImageLists - creates an image list, adds three bitmaps to 
// it, and associates the image list with a tree-view control. 
// Returns TRUE if successful or FALSE otherwise. 
// hwndTV - handle of the tree-view control 
//
#define NUM_BITMAPS  2
#define CX_BITMAP   16
#define CY_BITMAP   16

void CPicsDialog::SetTreeImages( HWND hwndTV, HIMAGELIST himl )
{
    HIMAGELIST oldHiml;  // handle of image list

    // Associate the image list with the tree-view control.
    oldHiml = TreeView_SetImageList( hwndTV, himl, TVSIL_NORMAL );

    if ( oldHiml != NULL )
    {
        ImageList_Destroy( oldHiml );
    }
}

BOOL CPicsDialog::InitTreeViewImageLists(HWND hwndTV) 
{ 
    HIMAGELIST himl;  // handle of image list 
    HBITMAP hbmp;     // handle of bitmap 

    // Create the image list. 
    if ((himl = ImageList_Create(CX_BITMAP, CY_BITMAP, 
            FALSE, NUM_BITMAPS, 0)) == NULL)
    {
        TraceMsg( TF_WARNING, "CPicsDialog::InitTreeViewImageLists() - himl Image List Creation Failed!" );
        return FALSE;
    }

    // Add the open file, closed file, and document bitmaps. 
    hbmp=(HBITMAP) LoadImage(g_hInstance,
                             MAKEINTRESOURCE(IDB_KEYS),
                             IMAGE_BITMAP,
                             0,
                             0,
                             LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    g_nKeys = ImageList_Add(himl, hbmp, (HBITMAP) NULL); 
    DeleteObject(hbmp); 

    hbmp=(HBITMAP) LoadImage(g_hInstance,
                             MAKEINTRESOURCE(IDB_LOCK),
                             IMAGE_BITMAP,
                             0,
                             0,
                             LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    g_nLock = ImageList_Add(himl, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp);

    // Fail if not all of the images were added. 
    if (ImageList_GetImageCount(himl) < NUM_BITMAPS)
    {
        TraceMsg( TF_WARNING, "CPicsDialog::InitTreeViewImageLists() - Not all images were added!" );
        return FALSE;
    }

    // Associate the image list with the tree-view control. 
    SetTreeImages( hwndTV, himl );

    return TRUE; 
} 

void CPicsDialog::LaunchRatingSystemSite( void )
{
    HWND        hDlg = m_hWnd;

    TreeNode *pTN = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));
    if (pTN == NULL)
        return;

    PicsRatingSystem *pPRS = NULL;

    if (pTN->tne == tneRatingSystemInfo)
        pPRS = (PicsRatingSystem *)pTN->pData;
    else if (pTN->tne == tneRatingSystemNode) {
        if ((PicsCategory *)pTN->pData != NULL)
            pPRS = ((PicsCategory *)pTN->pData)->pPRS;
    }

    if (pPRS != NULL) {
        BOOL fSuccess = FALSE;
        HINSTANCE hShell32 = ::LoadLibrary(::szShell32);
        if (hShell32 != NULL) {
            PFNSHELLEXECUTE pfnShellExecute = (PFNSHELLEXECUTE)::GetProcAddress(hShell32, ::szShellExecute);
            if (pfnShellExecute != NULL) {
                fSuccess = (*pfnShellExecute)(hDlg, NULL, pPRS->etstrRatingService.Get(),
                                              NULL, NULL, SW_SHOW) != NULL;
            }
            ::FreeLibrary(hShell32);
        }
        if (!fSuccess) {
            NLS_STR nlsMessage(MAX_RES_STR_LEN);
            if(nlsMessage)
            {
                NLS_STR nlsTemp(STR_OWNERALLOC, pPRS->etstrRatingSystem.Get());
                const NLS_STR *apnls[] = { &nlsTemp, NULL };
                if ( WN_SUCCESS == (nlsMessage.LoadString(IDS_CANT_LAUNCH, apnls)) )
                {
                    MyMessageBox(hDlg, nlsMessage.QueryPch(), IDS_GENERIC, MB_OK | MB_ICONSTOP);
                }
            }
        }
    }
}

void CPicsDialog::PicsDlgInit( void )
{
    HTREEITEM  hTree;
    TreeNode  *pTN;
    HWND       hwndTree;
    int        x,z;

    HWND hDlg = m_hWnd;

    ASSERT( hDlg );

    if ( ! hDlg )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::PicsDlgInit() - hDlg is NULL!" );
        return;
    }

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::PicsDlgInit() - pPRSD is NULL!" );
        return;
    }

    hwndTree = GetDlgItem(IDC_PT_TREE);

    /* Note, if there are installed providers but they all failed, there
     * will be dummy entries for them in the array.  So we will not attempt
     * to install RSACi automatically unless there really are no providers
     * installed at all.
     */
    if (!pPRSD->pPRSI->arrpPRS.Length())
    {
        // There are no providers.
        if ( ! InstallDefaultProvider() )
        {
            MyMessageBox(hDlg, IDS_INSTALL_INFO, IDS_GENERIC, MB_OK);
            ControlsShow( tneNone );
            return;
        }
    }
    /*make the tree listing*/
    /*Individual Rating Systems*/
    InitTreeViewImageLists(hwndTree);

    BOOL fAnyInvalid = FALSE;
    BOOL fAnyValid = FALSE;
    for (z = 0; z < pPRSD->pPRSI->arrpPRS.Length(); ++z)
    {
        PicsRatingSystem *pPRS = pPRSD->pPRSI->arrpPRS[z];

        if (!(pPRS->dwFlags & PRS_ISVALID))
        {
            fAnyInvalid = TRUE;
            continue;
        }
        fAnyValid = TRUE;

        pTN  = new TreeNode(tneRatingSystemInfo, pPRS);
        ASSERT(pTN);    
        hTree = AddOneItem(hwndTree, NULL, (char*) pPRS->etstrName.Get(), TVI_SORT, (LPARAM) pTN, g_nLock);
        for (x = 0; x < pPRS->arrpPC.Length(); ++x)
        {
            AddCategory(pPRS->arrpPC[x], hwndTree, hTree);
        }
        TreeView_Expand(hwndTree, hTree, TVE_EXPAND);
    }

    if (fAnyInvalid)
    {
        MyMessageBox(hDlg, IDS_INVALID_PROVIDERS, IDS_GENERIC, MB_OK | MB_ICONWARNING);
    }

    if (fAnyValid)
    {
        HTREEITEM hTreeItem;

        hTreeItem=TreeView_GetNextItem(hwndTree, TreeView_GetRoot(hwndTree),TVGN_CHILD);

        if(hTreeItem!=NULL)
        {
            TreeView_SelectItem(hwndTree, hTreeItem);       
            pTN   = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));
            if (pTN)
            {
                ControlsShow( pTN->tne );

                switch(pTN->tne)
                {
                    case tneRatingSystemInfo:
                        SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
                        break;
                    case tneRatingSystemNode:
                        SelectRatingSystemNode( (PicsCategory*) pTN->pData );
                        break;
                }
            }
        }
        else
        {
            TreeView_SelectItem(hwndTree, TreeView_GetRoot(hwndTree));

            pTN   = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));

            ControlsShow( tneRatingSystemInfo );

            if ( pTN )
            {
                SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
            }
        }
    }
    else
    {
        ControlsShow( tneNone );
    }
}


void CPicsDialog::KillTree(HWND hwndTree, HTREEITEM hTree)
{
    ASSERT( hwndTree );

    while (hTree != NULL)
    {
        /* If this node has any items under it, delete them as well. */
        HTREEITEM hChild = TreeView_GetChild( hwndTree, hTree );
        if (hChild != NULL)
        {
            KillTree( hwndTree, hChild );
        }

        HTREEITEM hNext = TreeView_GetNextSibling( hwndTree, hTree );

        TreeView_SelectItem( hwndTree, hTree );
        delete TreeView_GetSelectionLParam( hwndTree );
        TreeView_DeleteItem( hwndTree, hTree );
        hTree = hNext;
    }
}


void CPicsDialog::PicsDlgUninit( void )
{
    HWND hwndTree;

    hwndTree = GetDlgItem(IDC_PT_TREE);
    KillTree( hwndTree, TreeView_GetRoot(hwndTree) );

    // Remove the image list from the tree-view control. 
    SetTreeImages( hwndTree, NULL );

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    /* If we have a temporary copy of the user's ratings list, destroy it. */
    if ( pPRSD && pPRSD->pTempRatings != NULL )
    {
        DestroyRatingSystemList(pPRSD->pTempRatings);
        pPRSD->pTempRatings = NULL;
    }

    ControlsShow( tneNone );
}


void CPicsDialog::PicsDlgSave( void )
{
    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::PicsDlgSave() - pPRSD is NULL!" );
        return;
    }

    /* To save changes, throw away the user's ratings list and steal the
     * temporary copy we're using in the dialog.  As an optimization, we
     * don't copy it here, because in the case of OK, we'd just be destroying
     * the original immediately after this.  If the user hit Apply, we'll
     * re-clone a new temp ratings list for the dialog's purpose the next
     * time we need one.
     *
     * If there is no temporary copy, then PicsDlgSave is a nop.
     */
    if (pPRSD->pTempRatings != NULL)
    {
        DestroyRatingSystemList(pPRSD->pPU->m_pRatingSystems);
        pPRSD->pPU->m_pRatingSystems = pPRSD->pTempRatings;
        pPRSD->pTempRatings = NULL;
    }
}

#ifdef RATING_LOAD_GRAPHICS /* loading icon out of msrating.dll?  completely bogus. */
POINT CPicsDialog::BitmapWindowCoord( int nID )
{
    POINT pt;
    RECT  rD, rI;

    pt.x = ::GetWindowRect(GetDlgItem(nID), &rI);
    pt.y = GetWindowRect(&rD);
    pt.x = rI.left - rD.left;
    pt.y = rI.top  - rD.top;
    return pt;
}

void CPicsDialog::LoadGraphic( char *pIcon, POINT pt )
{
    HICON hIcon;
    int i;

    MyAtoi(pIcon, &i);

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::LoadGraphic() - pPRSD is NULL!" );
        return;
    }

    // No need to pull from msratelc.dll for non-localized icons.
    hIcon = pIcon ? LoadIcon( g_hInstance, MAKEINTRESOURCE(i) ) : NULL;
    if (hIcon)
    {
        HWND            hwndBitmapCategory;

        HWND hDlg = m_hWnd;

        ASSERT( hDlg );

        if ( ! hDlg )
        {
            TraceMsg( TF_ERROR, "CPicsDialog::LoadGraphic() - hDlg is NULL!" );
            return;
        }

        hwndBitmapCategory = CreateWindow("Static",NULL,SS_ICON|WS_CHILD, pt.x, pt.y,0,0,hDlg, NULL,NULL,0);
        ::ShowWindow( hwndBitmapCategory, SW_SHOW );
        DeleteObject( (HGDIOBJ) SendMessage( hwndBitmapCategory, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon) );

        pPRSD->hwndBitmapCategory = hwndBitmapCategory;
    }
}
#endif  /* RATING_LOAD_GRAPHICS */

PicsEnum* CPicsDialog::PosToEnum(PicsCategory *pPC, LPARAM lPos)
{
    int z, diff=-1, temp;
    PicsEnum *pPE=NULL;

    for (z=0;z<pPC->arrpPE.Length();++z){
        temp = (int) (lPos-pPC->arrpPE[z]->etnValue.Get());
        if (temp>=0){
            if (temp<diff || diff==-1){
                diff = temp;
                pPE  = pPC->arrpPE[z];
            }
        }
    }

    return pPE;
}

void CPicsDialog::NewTrackbarPosition( void )
{
    signed long   lPos;
    TreeNode     *pTN;
    PicsEnum     *pPE;
    PicsCategory *pPC;

    PRSD *          pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::NewTrackbarPosition() - pPRSD is NULL!" );
        return;
    }

    DeleteBitmapWindow( pPRSD->hwndBitmapLabel );

    pTN = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));
    if (pTN == NULL)
        return;

    pPC = (PicsCategory*) pTN->pData;
    BOOL fLabelled = pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get();

    lPos = (long) SendMessage(GetDlgItem(IDC_PT_TB_SELECT), TBM_GETPOS, 0, 0);
    pPE  = PosToEnum(pPC, fLabelled ? (LPARAM) pPC->arrpPE[lPos]->etnValue.Get() : lPos);
    if (pPE)
    {
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_SDESC), pPE->etstrName.Get());
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_LDESC), 
                      pPE->etstrDesc.fIsInit() ? pPE->etstrDesc.Get() : szNULL);

    }
    else
    {
        char pszBuf[MAXPATHLEN];
        char rgBuf[sizeof(pszBuf) + 12];    // big enough to insert a number

        MLLoadStringA(IDS_VALUE, pszBuf, sizeof(pszBuf));
        
        wsprintf(rgBuf, pszBuf, lPos);
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_SDESC), rgBuf);    
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_LDESC),
                      pPC->etstrDesc.fIsInit() ? pPC->etstrDesc.Get() : szNULL);
    }

    /* save the selected value into the temporary ratings list */
    UserRating *pRating = GetTempRating( pPC );
    if (pRating != NULL)
    {
        pRating->m_nValue = (int) (fLabelled ? pPC->arrpPE[lPos]->etnValue.Get() : lPos);
    }
}

void CPicsDialog::SelectRatingSystemNode( PicsCategory *pPC )
{
    HWND      hwnd;
    BOOL      fLabelOnly;
    LPARAM    lValue;
    int       z;

    ASSERT( pPC );

    if ( ! pPC )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::SelectRatingSystemNode() - pPC is NULL!" );
        return;
    }

#ifdef RATING_LOAD_GRAPHICS
    /*Category Icon*/
    if (pPC->etstrIcon.fIsInit())
    {
        // Load Graphic to m_pPRSD->hwndBitmapCategory
        LoadGraphic( pPC->etstrIcon.Get(), BitmapWindowCoord( IDC_PT_T_BITMAP_LABEL ) );
    }
#endif

    /*Setup Trackbar*/
    if ((pPC->etnMax.fIsInit() && P_INFINITY==pPC->etnMax.Get())
        ||
        (pPC->etnMin.fIsInit() && N_INFINITY==pPC->etnMin.Get())
        ||
        (!(pPC->etnMin.fIsInit() && pPC->etnMax.fIsInit()))
    )
    {
        ShowHideControl( IDC_PT_T_RSN_SDESC, FALSE );
        ShowHideControl( IDC_PT_T_RSN_LDESC, FALSE );
        ShowHideControl( IDC_PT_TB_SELECT,   FALSE );
    }
    else
    {
        hwnd = GetDlgItem(IDC_PT_TB_SELECT);
        SendMessage(hwnd, TBM_CLEARTICS, TRUE, 0);

        fLabelOnly = pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get();            
        /*Ranges*/
        if (pPC->etnMax.fIsInit())
        {
            lValue = (LPARAM) ( fLabelOnly ? pPC->arrpPE.Length()-1 : pPC->etnMax.Get() );
            SendMessage(hwnd, TBM_SETRANGEMAX, TRUE, lValue);
            ASSERT(lValue == SendMessage(hwnd, TBM_GETRANGEMAX, 0,0));
        }
        if (pPC->etnMin.fIsInit())
        {
            lValue = (LPARAM) ( fLabelOnly ? 0 : pPC->etnMin.Get() );
            SendMessage(hwnd, TBM_SETRANGEMIN, TRUE, lValue);
            ASSERT(lValue == SendMessage(hwnd, TBM_GETRANGEMIN, 0,0));
        }

        /*Ticks*/
        for (z=0;z<pPC->arrpPE.Length();++z)
        {
            lValue = (LPARAM) ( fLabelOnly ? z : pPC->arrpPE[z]->etnValue.Get());
            SendMessage(hwnd, TBM_SETTIC, 0, lValue);
        }

        /*Initial Position of trackbar*/
        UserRating *pRating = GetTempRating( pPC );

        if (pRating != NULL)
        {
            if (fLabelOnly)
            {
                for (z=0;z<pPC->arrpPE.Length();++z)
                {
                    if (pPC->arrpPE[z]->etnValue.Get() == pRating->m_nValue)
                    {
                        lValue=z;
                        break;
                    }
                }
            }
            else
            {
                lValue = (LPARAM) pRating->m_nValue;
            }
        }
        else
        {
            lValue = (LPARAM) ( fLabelOnly ? 0 : pPC->etnMin.Get());
        }

        SendMessage(hwnd, TBM_SETPOS, TRUE, lValue);

        // On dialog close, setting the trackbar position fails.
//      ASSERT(lValue == SendMessage(hwnd, TBM_GETPOS, 0,0));

        NewTrackbarPosition();
    }
}

void CPicsDialog::SelectRatingSystemInfo( PicsRatingSystem *pPRS )
{
    ASSERT( pPRS );

    if ( ! pPRS )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::SelectRatingSystemInfo() - pPRS is NULL!" );
        return;
    }

    ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_LDESC), pPRS->etstrDesc.Get());

#ifdef RATING_LOAD_GRAPHICS
    if (pPRS->etstrIcon.fIsInit())
    {
        // Load Graphic to m_pPRSD->hwndBitmapCategory
        LoadGraphic( pPRS->etstrIcon.Get(), BitmapWindowCoord( IDC_PT_T_BITMAP_LABEL ) );
    }
#endif
}

void CPicsDialog::DeleteBitmapWindow( HWND & p_rhwnd )
{
    if (p_rhwnd)
    {
        DeleteObject( (HGDIOBJ) SendMessage(p_rhwnd, STM_GETIMAGE, IMAGE_BITMAP, 0));
        ::DestroyWindow(p_rhwnd);
        p_rhwnd = 0;
    }
}


void CPicsDialog::ControlsShow( TreeNodeEnum tne )
{
    BOOL fEnable;

    /*Bitmap placeholders never need to be seen*/
    ShowHideControl( IDC_PT_T_BITMAP_CATEGORY, FALSE );
    ShowHideControl( IDC_PT_T_BITMAP_LABEL,    FALSE );

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    /*Kill old graphic windows*/
    if ( pPRSD )
    {
        DeleteBitmapWindow( pPRSD->hwndBitmapCategory );
        DeleteBitmapWindow( pPRSD->hwndBitmapLabel );
    }

    /*RatingSystemNode Controls*/
    fEnable = (tne == tneRatingSystemNode);

    ShowHideControl( IDC_PT_T_RSN_SDESC, fEnable );
    ShowHideControl( IDC_PT_TB_SELECT,   fEnable );
    ShowHideControl( IDC_RATING_LABEL,   fEnable );

    /*RatingSystemInfo Controls*/
    fEnable = (tne==tneRatingSystemInfo || tne==tneRatingSystemNode);

    ShowHideControl( IDC_PT_T_RSN_LDESC, fEnable);
    ShowHideControl( IDC_DETAILSBUTTON,  fEnable);
}

TreeNode* CPicsDialog::TreeView_GetSelectionLParam(HWND hwndTree){
    TV_ITEM tv;

    tv.mask  = TVIF_HANDLE | TVIF_PARAM;
    tv.hItem = TreeView_GetSelection(hwndTree);
    if (SendMessage(hwndTree, TVM_GETITEM, 0, (LPARAM) &tv)) return (TreeNode*) tv.lParam;
    else return 0;
}

HTREEITEM CPicsDialog::AddOneItem(HWND hwndTree, HTREEITEM hParent, LPSTR szText, HTREEITEM hInsAfter, LPARAM lpData, int iImage){
    HTREEITEM hItem;
    TV_ITEM tvI;
    TV_INSERTSTRUCT tvIns;

    // The .pszText is filled in.
    tvI.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvI.iSelectedImage = iImage;
    tvI.iImage = iImage;
    tvI.pszText = szText;
    tvI.cchTextMax = strlenf(szText);
    tvI.lParam = lpData;

    tvIns.item = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;

    // Insert the item into the tree.
    hItem = (HTREEITEM)SendMessage(hwndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)&tvIns);

    return (hItem);
}

void CPicsDialog::AddCategory(PicsCategory *pPC, HWND hwndTree, HTREEITEM hParent){
    int        z;
    char      *pc;
    TreeNode  *pTN;

    /*if we have a real name, us it, else use transmission name*/
    if (pPC->etstrName.fIsInit())
    {
        pc = pPC->etstrName.Get();
    }
    else if (pPC->etstrDesc.fIsInit())
    {
        pc = pPC->etstrDesc.Get();
    }
    else
    {
        pc = (char*) pPC->etstrTransmitAs.Get();
    }

    /*Category Tab*/
    pTN  = new TreeNode(tneRatingSystemNode, pPC);
    ASSERT(pTN);    

    /*insert self*/
    hParent = AddOneItem(hwndTree, hParent, pc, TVI_SORT, (LPARAM) pTN, g_nKeys);

    /*insert children*/
    int cChildren = pPC->arrpPC.Length();

    if (cChildren > 0) {
        for (z = 0; z < cChildren; ++z)
            AddCategory(pPC->arrpPC[z], hwndTree, hParent);
        TreeView_Expand(hwndTree, hParent, TVE_EXPAND);
    }
}


BOOL CPicsDialog::InstallDefaultProvider( void )
{
    NLS_STR nlsFilename(MAXPATHLEN);
    BOOL fRet = FALSE;

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::InstallDefaultProvider() - pPRSD is NULL!" );
        return fRet;
    }

    if (nlsFilename.QueryError() != ERROR_SUCCESS)
    {
        TraceMsg( TF_ERROR, "CPicsDialog::InstallDefaultProvider() - nlsFilename Allocation Failed!" );
        return fRet;
    }

    CHAR * pszFileName = nlsFilename.Party();

    if (pszFileName)
    {
        GetSystemDirectory(pszFileName, nlsFilename.QueryAllocSize());
        nlsFilename.DonePartying();
        LPSTR pszBackslash = ::strrchrf(nlsFilename.QueryPch(), '\\');
        if (pszBackslash == NULL || *(pszBackslash+1) != '\0')
            nlsFilename.strcat(szBACKSLASH);
        nlsFilename.strcat(szDEFAULTRATFILE);

        PicsRatingSystem *pPRS;
        HRESULT hres = LoadRatingSystem(nlsFilename.QueryPch(), &pPRS);
        if (pPRS != NULL)
        {
            pPRSD->pPRSI->arrpPRS.Append(pPRS);
            fRet = TRUE;
        }

        pPRSD->pPRSI->fRatingInstalled = fRet;

        CheckUserSettings(pPRS);    /* give user default settings for all categories */
    }
    else
    {
        nlsFilename.DonePartying();
    }

    return fRet;
}

/* GetTempRatingList returns the dialog's temporary copy of the user's rating
 * system list.  If we don't have any such temporary copy yet, we make one.
 */
UserRatingSystem * CPicsDialog::GetTempRatingList( void )
{
    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::GetTempRatingList() - pPRSD is NULL!" );
        return NULL;
    }

    if (pPRSD->pTempRatings == NULL)
    {
        pPRSD->pTempRatings = DuplicateRatingSystemList(pPRSD->pPU->m_pRatingSystems);
    }

    return pPRSD->pTempRatings;
}


UserRating * CPicsDialog::GetTempRating( PicsCategory *pPC )
{
    UserRating *pRating = NULL;

    /* save the selected value into the temporary ratings list */
    UserRatingSystem *pURS = GetTempRatingList();
    LPSTR pszRatingService = pPC->pPRS->etstrRatingService.Get();
    if (pURS != NULL)
    {
        pURS = FindRatingSystem(pURS, pszRatingService);
    }

    if (pURS == NULL)
    {
        pURS = new UserRatingSystem;
        if (pURS == NULL)
        {
            TraceMsg( TF_ERROR, "CPicsDialog::GetTempRating() - pURS is NULL!" );
            return NULL;
        }

        PRSD * pPRSD = m_pPRSD;

        ASSERT( pPRSD );

        pURS->SetName(pszRatingService);
        pURS->m_pNext = pPRSD ? pPRSD->pTempRatings : NULL;
        pURS->m_pPRS = pPC->pPRS;
        if ( pPRSD )
        {
            pPRSD->pTempRatings = pURS;
        }
    }

    LPSTR pszRatingName = pPC->etstrTransmitAs.Get();

    pRating = pURS->FindRating(pszRatingName);
    if (pRating == NULL)
    {
        pRating = new UserRating;
        if (pRating == NULL)
        {
            TraceMsg( TF_ERROR, "CPicsDialog::GetTempRating() - pRating is NULL!" );
            return NULL;
        }

        pRating->SetName(pszRatingName);
        pRating->m_pPC = pPC;
        if (!pPC->etnMin.fIsInit() || (pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get()))
        {
            pRating->m_nValue = 0;
        }
        else
        {
            pRating->m_nValue = pPC->etnMin.Get();
        }

        pURS->AddRating(pRating);
    }

    return pRating;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\parselbl.h ===
#ifndef PARSE_LABEL_H
#define PARSE_LABEL_H

#include "ratings.h"

//t-markh 8/98
//extends GetBool() to true/false, yes/no, pass/fail for
//PICSRules support
enum PICSRulesBooleanSwitch
{
    PR_BOOLEAN_TRUEFALSE,
    PR_BOOLEAN_PASSFAIL,
    PR_BOOLEAN_YESNO
};

//t-markh 8/98
//Definitions used by GetBool for PICSRules types
#define PR_YESNO_YES    1
#define PR_YESNO_NO     0

#define PR_PASSFAIL_PASS    1
#define PR_PASSFAIL_FAIL    0

void SkipWhitespace(LPSTR *ppsz);
BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch);
LPSTR FindTokenEnd(LPSTR pszStart);
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut, PICSRulesBooleanSwitch PRBoolSwitch=PR_BOOLEAN_TRUEFALSE);
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut, BOOL fPICSRules=FALSE);
HRESULT ParseTime(LPSTR pszTime, DWORD *pOut, BOOL fPICSRules=FALSE);

class COptionsBase
{
protected:
    COptionsBase();
    UINT m_cRef;

public:
    void AddRef();
    void Release();
    virtual void Delete();

    DWORD m_timeUntil;          /* 'until' time, in UTC net format (secs since 1/1/1970) */

    DWORD m_fdwFlags;           /* see LBLOPT_XXX below */

    LPSTR m_pszInvalidString;   /* ptr to invalid or unrecognized string */
    LPSTR m_pszURL;             /* value of "for" option, may be NULL */

    BOOL CheckUntil(DWORD timeCurrent); /* returns TRUE if 'until' option checks out */
    BOOL CheckURL(LPCSTR pszURL);       /* returns TRUE if 'for' option checks out */
};

const DWORD LBLOPT_GENERIC = 0x01;
const DWORD LBLOPT_INVALID = 0x02;
const DWORD LBLOPT_EXPIRED = 0x04;
const DWORD LBLOPT_WRONGURL = 0x08;
const DWORD LBLOPT_URLCHECKED = 0x10;


class CStaticOptions : public COptionsBase
{
public:
    CStaticOptions() { }
};


class CDynamicOptions : public COptionsBase
{
public:
    CDynamicOptions *m_pNext;

    CDynamicOptions() { m_pNext = NULL; }
    virtual void Delete();
};


class CParsedRating
{
public:
    LPSTR pszTransmitName;
    INT nValue;
    COptionsBase *pOptions;
    BOOL fFound;                /* TRUE if matches a rating in the installed system */
    BOOL fFailed;               /* TRUE if exceeded user's limit */
};


class CParsedServiceInfo
{
private:
    CParsedServiceInfo *m_pNext;
    COptionsBase *m_poptCurrent;
    CDynamicOptions *m_poptList;
    LPSTR m_pszCurrent;             /* for parsing routines */
    void SkipWhitespace() { ::SkipWhitespace(&m_pszCurrent); }

public:
    LPCSTR m_pszServiceName;        /* service name URL, may be NULL if not reported */
    LPCSTR m_pszErrorString;        /* points to error string if error reported by site */
    LPCSTR m_pszInvalidString;      /* pointer to invalid or unrecognized string found */
    BOOL m_fInstalled;              /* TRUE if this rating system is installed on this machine */
    CStaticOptions m_opt;
    array<CParsedRating> aRatings;

    CParsedServiceInfo();
    ~CParsedServiceInfo();

    CParsedServiceInfo *Next() { return m_pNext; }
    void Append(CParsedServiceInfo *pNew);
    HRESULT Parse(LPSTR *ppszServiceInfo);
    HRESULT ParseServiceError();
    HRESULT ParseOptions(LPSTR pszTokenEnd, COptionsBase *pOpt,
                     CDynamicOptions **ppOptOut, LPCSTR pszOptionEndToken);
    HRESULT ParseExtension(COptionsBase *pOpt);
    HRESULT ParseExtensionData(COptionsBase *pOpt);
    HRESULT ParseRating();
    HRESULT ParseSingleLabel();
    HRESULT ParseLabels();
};


class CParsedLabelList
{
private:
    LPSTR m_pszList;
    LPSTR m_pszCurrent;
    HRESULT ParseServiceInfo();
    void SkipWhitespace() { ::SkipWhitespace(&m_pszCurrent); }

public:
    CParsedServiceInfo m_ServiceInfo;
    LPCSTR m_pszInvalidString;      /* pointer to invalid or unrecognized string found */
    LPSTR m_pszURL;                 /* copy of URL we were originally given */
    LPSTR m_pszOriginalLabel;      /* copy of original, raw rating label */

    BOOL m_fRated;                      /* TRUE if site is considered rated */

    BOOL m_fDenied;                 /* TRUE if site is denied by a helper */
    BOOL m_fIsHelper;               /* TRUE if site is judged by a helper */
    BOOL m_fNoRating;               /* TRUE if site contains no ratings */
    
    BOOL m_fIsCustomHelper;
    LPSTR m_pszRatingName;
    LPSTR m_pszRatingReason;

    CParsedLabelList();
    ~CParsedLabelList();

    HRESULT Parse(LPSTR pszCopy);
};


extern "C" {
HRESULT ParseLabelList(LPCSTR pszList, CParsedLabelList **ppParsed);
void FreeParsedLabelList(CParsedLabelList *pList);
};  /* extern "C" */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\parserat.cpp ===
/****************************************************************************\
 *
 *   PARSERAT.C -- Code to parse .RAT files
 *
 *   Created:   Greg Jones
 *   
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "parselbl.h"       /* we use a couple of this guy's subroutines */
#include "msluglob.h"
#include "debug.h"

// Sundown: pointer to boolean conversion
#pragma warning (disable: 4800)

/****************************************************************************
Some design notes on how this parser works:

A ParenThing is:

'(' identifier [stuff] ')'

where [stuff] could be:
    a quoted string
    a number
    a boolean
    a series of ParenThings
    in the case of extensions:
        a quoted string, followed by
        one or more quoted strings and/or ParenThings

The entire .RAT file is a ParenThing, except that it has no identifier, just
a list of ParenThings inside it.


**********************************************************************
We pass the parser a schema for what things it expects -- we have
a big array listing identifiers for each different possible keyword, and
each parser call receives a smaller array containing only those indices
that are valid to occur within that object.

We make PicsRatingSystem, PicsCategory, and PicsEnum derive from a common
base class which supports a virtual function AddItem(ID,data).  So at the
top level, we construct an (empty) PicsRatingSystem.  We call the parser,
giving it a pointer to that guy, and a structure describing what to parse --
the ParenObject's token is a null string (since the global structure is the
one that doesn't start with a token before its first embedded ParenThing),
and we give a list saying the allowable things in a PicsRatingSystem are
PICS-version, rating-system, rating-service, default, description, extension,
icon, name, category.  There is a global table indicating a handler function
for every type of ParenThing, which knows how to create a data structure
completely describing that ParenThing.  (That data structure could be as
simple as a number or as complex as allocating and parsing a complete
PicsCategory object.)

The parser walks along, and for each ParenThing he finds, he identifies it
by looking up its token in the list provided by the caller. Each entry in
that list should include a field which indicates whether multiple things
of that identity are allowed (e.g., 'category') or not (e.g., rating-system).
If only one is allowed, then when the parser finds one he marks it as having
been found.

When the parser identifies the ParenThing, he calls its handler function to
completely parse the data in the ParenThing and return that object into an
LPVOID provided by the parser.  If that is successful, the parser then calls
its object's AddItem(ID,data) virtual function to add the specified item to
the object, relying on the object itself to know what type "data" points to --
a number, a pointer to a heap string which can be given to ETS::SetTo, a
pointer to a PicsCategory object which can be appended to an array, etc.

The RatFileParser class exists solely to provide a line number shared by
all the parsing routines.  This line number is updated as the parser walks
through the file, and is frozen as soon as an error is found.  This line
number can later be reported to the user to help localize errors in RAT files.

*****************************************************************************/

class RatFileParser
{
public:
    UINT m_nLine;

    RatFileParser() { m_nLine = 1; }

    LPSTR EatQuotedString(LPSTR pIn);
    HRESULT ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                           AllowableOption **ppFound);
    HRESULT ParseParenthesizedObject(
        LPSTR *ppIn,                    /* where we are in the text stream */
        AllowableOption aao[],          /* allowable things inside this object */
        PicsObjectBase *pObject         /* object to set parameters into */
    );
    char* FindNonWhite(char *pc);
};



/* White returns a pointer to the first whitespace character starting at pc.
 */
char* White(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc == '\0' ||
            *pc ==' ' ||
            *pc == '\t' ||
            *pc == '\r' ||
            *pc == '\n')
        {
            return pc;
        }
        pc++;
    }
}


/* NonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* NonWhite(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        pc++;
    }
}


/* FindNonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* RatFileParser::FindNonWhite(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        if (*pc == '\n')
            m_nLine++;
        pc++;
    }
}


/* Returns a pointer to the closing doublequote of a quoted string, counting
 * linefeeds as we go.  Returns NULL if no closing doublequote found.
 */
LPSTR RatFileParser::EatQuotedString(LPSTR pIn)
{
    LPSTR pszQuote = strchrf(pIn, '\"');
    if (pszQuote == NULL)
    {
        TraceMsg( TF_WARNING, "RatFileParser::EatQuotedString() - No closing doublequote found!" );
        return NULL;
    }

    pIn = strchrf(pIn, '\n');
    while (pIn != NULL && pIn < pszQuote)
    {
        m_nLine++;
        pIn = strchrf(pIn+1, '\n');
    }

    return pszQuote;
}



/***************************************************************************
    Worker functions for inheriting category properties and other
    miscellaneous category stuff.
***************************************************************************/

HRESULT PicsCategory::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
}


HRESULT PicsRatingSystem::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (m_pDefaultOptions != NULL)
        return m_pDefaultOptions->InitializeMyDefaults(pCategory);

    return NOERROR;             /* no defaults to initialize */
}


HRESULT PicsDefault::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
}


HRESULT PicsEnum::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an enum */
}


PicsExtension::PicsExtension()
    : m_pszRatingBureau(NULL)
{
    /* nothing else */
}


PicsExtension::~PicsExtension()
{
    delete m_pszRatingBureau;
    m_pszRatingBureau = NULL;
}


HRESULT PicsExtension::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an extension */
}


void PicsCategory::FixupLimits()
{
    BOOL fLabelled = (etfLabelled.fIsInit() && etfLabelled.Get());
    
    /*fix up max and min values*/
    if (fLabelled ||
        (arrpPE.Length()>0 && (!etnMax.fIsInit() || !etnMax.fIsInit())))
    {                
        if (arrpPE.Length() > 0)
        {
            if (!etnMax.fIsInit())
                etnMax.Set(N_INFINITY);
            if (!etnMin.fIsInit())
                etnMin.Set(P_INFINITY);
            for (int z=0;z<arrpPE.Length();++z)
            {
                if (arrpPE[z]->etnValue.Get() > etnMax.Get()) etnMax.Set(arrpPE[z]->etnValue.Get());
                if (arrpPE[z]->etnValue.Get() < etnMin.Get()) etnMin.Set(arrpPE[z]->etnValue.Get());
            }
        }
        else
        {
            etfLabelled.Set(FALSE); /* no enum labels?  better not have labelled flag then */
            fLabelled = FALSE;
        }
    }

    /*sort labels by value*/
    if (fLabelled)
    {
        int x,y;
        PicsEnum *pPE;
        for (x=0;x<arrpPE.Length()-1;++x)
        {
            for (y=x+1;y<arrpPE.Length();++y)
            {
                if (arrpPE[y]->etnValue.Get() < arrpPE[x]->etnValue.Get())
                {
                    pPE = arrpPE[x];
                    arrpPE[x] = arrpPE[y];
                    arrpPE[y] = pPE;
                }
            }
        }
    }
}


void PicsCategory::SetParents(PicsRatingSystem *pOwner)
{
    pPRS = pOwner;
    UINT cSubCategories = arrpPC.Length();
    for (UINT i = 0; i < cSubCategories; i++)
    {
        InitializeMyDefaults(arrpPC[i]);    /* subcategory inherits our defaults */
        arrpPC[i]->SetParents(pOwner);      /* process all subcategories */
    }
    FixupLimits();      /* inheritance is done, make sure limits make sense */
}


/***************************************************************************
    Handler functions which know how to parse the various kinds of content
    which can occur within a parenthesized object.
***************************************************************************/

HRESULT RatParseString(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    *ppOut = NULL;

    LPSTR pszCurrent = *ppszIn;

    if (*pszCurrent != '\"')
    {
        TraceMsg( TF_WARNING, "RatParseString() - Start string expected!" );
        return RAT_E_EXPECTEDSTRING;
    }

    pszCurrent++;

    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszEnd == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseString() - End string expected!" );
        return RAT_E_EXPECTEDSTRING;
    }

    UINT cbString = (unsigned int) (pszEnd-pszCurrent);
    LPSTR pszNew = new char[cbString + 1];
    if (pszNew == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseString() - pszNew is NULL!" );
        return E_OUTOFMEMORY;
    }

    memcpyf(pszNew, pszCurrent, cbString);
    pszNew[cbString] = '\0';

    *ppOut = (LPVOID)pszNew;
    *ppszIn = pParser->FindNonWhite(pszEnd + 1);

    return NOERROR;
}


HRESULT RatParseNumber(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    int n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParseNumber(&pszCurrent, &n);

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseNumber() - Number Expected!" );
        return RAT_E_EXPECTEDNUMBER;
    }

    *(int *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent)
    {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}


HRESULT RatParseBool(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    BOOL b;

    /* PICS spec allows a terse way of specifying a TRUE boolean -- leaving
     * out the value entirely.  In a .RAT file, the result looks like
     *
     * (unordered)
     * (multivalue)
     *
     * and so on.  Called has pointed us at non-whitespace, so if we see
     * a closing paren, we know the .RAT file author used this syntax.
     */
    if (**ppszIn == ')')
    {
        b = TRUE;
    }
    else
    {
        LPSTR pszCurrent = *ppszIn;
        HRESULT hres = ::GetBool(&pszCurrent, &b);

        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "RatParseBool() - Boolean Expected!" );
            return RAT_E_EXPECTEDBOOL;
        }

        LPSTR pszNewline = strchrf(*ppszIn, '\n');
        while (pszNewline != NULL && pszNewline < pszCurrent)
        {
            pParser->m_nLine++;
            pszNewline = strchrf(pszNewline+1, '\n');
        }
        *ppszIn = pszCurrent;
    }

    *(LPBOOL)ppOut = b;

    return NOERROR;
}


AllowableOption aaoPicsCategory[] = {
    { ROID_TRANSMITAS, AO_SINGLE | AO_MANDATORY },
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_ICON, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_LABEL, 0 },
    { ROID_CATEGORY, 0 },
    { ROID_INVALID, 0 }
};
const UINT caoPicsCategory = sizeof(aaoPicsCategory) / sizeof(aaoPicsCategory[0]);

HRESULT RatParseCategory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsCategory];

    ::memcpyf(aao, ::aaoPicsCategory, sizeof(aao));

    PicsCategory *pCategory = new PicsCategory;
    if (pCategory == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseCategory() - pCategory is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pCategory);             /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseCategory() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pCategory;
        pCategory = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pCategory;
    return NOERROR;
}


AllowableOption aaoPicsEnum[] = {
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_VALUE, AO_SINGLE | AO_MANDATORY },
    { ROID_ICON, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsEnum = sizeof(aaoPicsEnum) / sizeof(aaoPicsEnum[0]);

HRESULT RatParseLabel(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsEnum];

    ::memcpyf(aao, ::aaoPicsEnum, sizeof(aao));

    PicsEnum *pEnum = new PicsEnum;
    if (pEnum == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseCategory() - pEnum is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pEnum);                 /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseLabel() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pEnum;
        pEnum = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pEnum;
    return NOERROR;
}


AllowableOption aaoPicsDefault[] = {
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsDefault = sizeof(aaoPicsDefault) / sizeof(aaoPicsDefault[0]);

HRESULT RatParseDefault(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsDefault];

    ::memcpyf(aao, ::aaoPicsDefault, sizeof(aao));

    PicsDefault *pDefault = new PicsDefault;
    if (pDefault == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseDefault() - pDefault is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pDefault);              /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseDefault() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pDefault;
        pDefault = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pDefault;
    return NOERROR;
}


AllowableOption aaoPicsExtension[] = {
    { ROID_MANDATORY, AO_SINGLE },
    { ROID_OPTIONAL, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsExtension = sizeof(aaoPicsExtension) / sizeof(aaoPicsExtension[0]);

HRESULT RatParseExtension(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsExtension];

    ::memcpyf(aao, ::aaoPicsExtension, sizeof(aao));

    PicsExtension *pExtension = new PicsExtension;
    if (pExtension == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseExtension() - pExtension is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pExtension);            /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseExtension() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pExtension;
        pExtension = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pExtension;
    return NOERROR;
}


/* Since the only extension we support right now is the one for a label
 * bureau, we just return the first quoted string we find if the caller
 * wants it.  If ppOut is NULL, then it's some other extension and the
 * caller doesn't care about the data, he just wants it eaten.
 */
HRESULT ParseRatExtensionData(LPSTR *ppszIn, RatFileParser *pParser, LPSTR *ppOut)
{
    HRESULT hres = NOERROR;

    LPSTR pszCurrent = *ppszIn;

    /* Must look for closing ')' ourselves to terminate */
    while (*pszCurrent != ')')
    {
        if (*pszCurrent == '(')
        {
            pszCurrent = pParser->FindNonWhite(pszCurrent+1);       /* skip paren and whitespace */
            hres = ParseRatExtensionData(&pszCurrent, pParser, ppOut);  /* parentheses contain data */
            if (FAILED(hres))
            {
                TraceMsg( TF_WARNING, "ParseRatExtensionData() - ParseRatExtensionData() Failed with hres=0x%x!", hres );
                return hres;
            }

            if (*pszCurrent != ')')
            {
                TraceMsg( TF_WARNING, "ParseRatExtensionData() - Right Parenthesis Expected!" );
                return RAT_E_EXPECTEDRIGHT;
            }

            pszCurrent = pParser->FindNonWhite(pszCurrent+1);   /* skip close ) and whitespace */
        }
        else if (*pszCurrent == '\"')
        {             /* should be just a quoted string */
            if (ppOut != NULL && *ppOut == NULL)
            {
                hres = RatParseString(&pszCurrent, (LPVOID *)ppOut, pParser);

                // $REVIEW - Should we return for FAILED(hres)?
            }
            else
            {
                ++pszCurrent;
                LPSTR pszEndQuote = pParser->EatQuotedString(pszCurrent);
                if (pszEndQuote == NULL)
                {
                    TraceMsg( TF_WARNING, "ParseRatExtensionData() - String Expected!" );
                    return RAT_E_EXPECTEDSTRING;
                }
                pszCurrent = pParser->FindNonWhite(pszEndQuote+1);  /* skip close " and whitespace */
            }
        }
        else
        {
            TraceMsg( TF_WARNING, "ParseRatExtensionData() - General Bad Syntax!" );
            return RAT_E_UNKNOWNITEM;               /* general bad syntax */
        }
    }

    /* Caller will skip over final ')' for us. */

    *ppszIn = pszCurrent;

    return NOERROR;
}


HRESULT RatParseMandatory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    LPSTR pszCurrent = *ppszIn;

    /* First thing better be a quoted URL identifying the extension. */
    if (*pszCurrent != '\"')
    {
        TraceMsg( TF_WARNING, "RatParseMandatory() - Start String Expected!" );
        return RAT_E_EXPECTEDSTRING;
    }

    pszCurrent++;
    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszCurrent == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseMandatory() - End String Expected!" );
        return RAT_E_EXPECTEDSTRING;            /* missing closing " */
    }

    /* See if it's the extension for a label bureau. */

    LPSTR pszBureau = NULL;
    LPSTR *ppData = NULL;
    if (IsEqualToken(pszCurrent, pszEnd, ::szRatingBureauExtension))
    {
        ppData = &pszBureau;
    }

    pszCurrent = pParser->FindNonWhite(pszEnd+1);       /* skip closing " and whitespace */

    HRESULT hres = ParseRatExtensionData(&pszCurrent, pParser, ppData);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseMandatory() - ParseRatExtensionData() Failed with hres=0x%x!", hres );
        return hres;
    }

    *ppOut = pszBureau;     /* return label bureau string if that's what we found */
    *ppszIn = pszCurrent;

    if (ppData == NULL)
        return RAT_E_UNKNOWNMANDATORY;      /* we didn't recognize it */
    else
        return NOERROR;
}


/* RatParseOptional uses the code in RatParseMandatory to parse the extension
 * data, in case an extension that should be optional comes in as mandatory.
 * We then detect RatParseMandatory rejecting the thing as unrecognized and
 * allow it through, since here it's optional.
 */
HRESULT RatParseOptional(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    HRESULT hres = RatParseMandatory(ppszIn, ppOut, pParser);
    if (hres == RAT_E_UNKNOWNMANDATORY)
        hres = S_OK;

    return hres;
}


/***************************************************************************
    Code to identify the opening keyword of a parenthesized object and
    associate it with content.
***************************************************************************/

/* The following array is indexed by RatObjectID values. */
struct {
    LPCSTR pszToken;            /* token by which we identify it */
    RatObjectHandler pHandler;  /* function which parses the object's contents */
} aObjectDescriptions[] = {
    { szNULL, NULL },
    { NULL, NULL },             /* placeholder for comparing against no token */
    { szPicsVersion, RatParseNumber },
    { szRatingSystem, RatParseString },
    { szRatingService, RatParseString },
    { szRatingBureau, RatParseString },
    { szBureauRequired, RatParseBool },
    { szCategory, RatParseCategory },
    { szTransmitAs, RatParseString },
    { szLabel, RatParseLabel },
    { szValue, RatParseNumber },
    { szDefault, RatParseDefault },
    { szDescription, RatParseString },
    { szExtensionOption, RatParseExtension },
    { szMandatory, RatParseMandatory },
    { szOptional, RatParseOptional },
    { szIcon, RatParseString },
    { szInteger, RatParseBool },
    { szLabelOnly, RatParseBool },
    { szMax, RatParseNumber },
    { szMin, RatParseNumber },
    { szMultiValue, RatParseBool },
    { szName, RatParseString },
    { szUnordered, RatParseBool }
};


/* ParseToOpening eats the opening '(' of a parenthesized object, and
 * verifies that the token just inside it is one of the expected ones.
 * If so, *ppIn is advanced past that token to the next non-whitespace
 * character;  otherwise, an error is returned.
 *
 * For example, if *ppIn is pointing at "(PICS-version 1.1)", and
 * ROID_PICSVERSION is in the allowable option table supplied, then
 * NOERROR is returned and *ppIn will point at "1.1)".
 *
 * If the function is successful, *ppFound is set to point to the element
 * in the allowable-options table which matches the type of thing this
 * object actually is.
 */
HRESULT RatFileParser::ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                                      AllowableOption **ppFound)
{
    LPSTR pszCurrent = *ppIn;

    pszCurrent = FindNonWhite(pszCurrent);
    if (*pszCurrent != '(')
    {
        TraceMsg( TF_WARNING, "RatFileParser::ParseToOpening() - Left Parenthesis Expected!" );
        return RAT_E_EXPECTEDLEFT;
    }

    pszCurrent = FindNonWhite(pszCurrent+1);    /* skip '(' and whitespace */
    LPSTR pszTokenEnd = FindTokenEnd(pszCurrent);

    for (; paoExpected->roid != ROID_INVALID; paoExpected++)
    {
        LPCSTR pszThisToken = aObjectDescriptions[paoExpected->roid].pszToken;

        /* Special case for beginning of RAT file structure: no token at all. */
        if (pszThisToken == NULL)
        {
            if (*pszCurrent == '(')
            {
                *ppIn = pszCurrent;
                *ppFound = paoExpected;
                return NOERROR;
            }
            else
            {
                TraceMsg( TF_WARNING, "RatFileParser::ParseToOpening() - Token Left Parenthesis Expected!" );
                return RAT_E_EXPECTEDLEFT;
            }
        }
        else if (IsEqualToken(pszCurrent, pszTokenEnd, pszThisToken))
            break;

    }

    if (paoExpected->roid != ROID_INVALID)
    {
        *ppIn = FindNonWhite(pszTokenEnd);  /* skip token and whitespace */
        *ppFound = paoExpected;
        return NOERROR;
    }
    else
    {
        TraceMsg( TF_WARNING, "RatFileParser::ParseToOpening() - Unknown Rat Object!" );
        return RAT_E_UNKNOWNITEM;
    }
}


/***************************************************************************
    The top-level entrypoint for parsing out a whole rating system.
***************************************************************************/

AllowableOption aaoPicsRatingSystem[] = {
    { ROID_PICSVERSION, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSYSTEM, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSERVICE, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGBUREAU, AO_SINGLE },
    { ROID_BUREAUREQUIRED, AO_SINGLE },
    { ROID_DEFAULT, 0 },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_ICON, AO_SINGLE },
    { ROID_NAME, AO_SINGLE },
    { ROID_CATEGORY, AO_MANDATORY },
    { ROID_INVALID, 0 }
};
const UINT caoPicsRatingSystem = sizeof(aaoPicsRatingSystem) / sizeof(aaoPicsRatingSystem[0]);

HRESULT PicsRatingSystem::Parse(LPCSTR pszFilename, LPSTR pIn)
{
    /* This guy is small enough to just init directly on the stack */
    AllowableOption aaoRoot[] = { { ROID_PICSDOCUMENT, 0 }, { ROID_INVALID, 0 } };
    AllowableOption aao[caoPicsRatingSystem];

    ::memcpyf(aao, ::aaoPicsRatingSystem, sizeof(aao));

    AllowableOption *pFound;

    RatFileParser parser;

    HRESULT hres = parser.ParseToOpening(&pIn, aaoRoot, &pFound);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "PicsRatingSystem::Parse() - Failed ParseToOpening() with hres=0x%x!", hres );
        return hres;                        /* some error early on */
    }

    hres = parser.ParseParenthesizedObject(
                        &pIn,                   /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        this);                  /* object to add items back to */

    if(SUCCEEDED(hres))
    {
        if(*pIn!=')') //check for a closing parenthesis
        {
            hres=RAT_E_EXPECTEDRIGHT;
        }
        else
        {
            LPTSTR lpszEnd=NonWhite(pIn+1);

            if(*lpszEnd!='\0') // make sure we're at the end of the file
            {
                hres=RAT_E_EXPECTEDEND;
            }
        }
    }

    if(FAILED(hres))
    {
        nErrLine=parser.m_nLine;
        TraceMsg( TF_WARNING, "PicsRatingSystem::Parse() - Failed ParseParenthesizedObject() at nErrLine=%d with hres=0x%x!", nErrLine, hres );
    }

    return hres;
}


/***************************************************************************
    Callbacks into the various class objects to add parsed properties.
***************************************************************************/

HRESULT PicsRatingSystem::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_PICSVERSION:
        etnPicsVersion.Set(PtrToLong(pData));
        break;

    case ROID_RATINGSYSTEM:
        etstrRatingSystem.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGSERVICE:
        etstrRatingService.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGBUREAU:
        etstrRatingBureau.SetTo((LPSTR)pData);
        break;

    case ROID_BUREAUREQUIRED:
        etbBureauRequired.Set((bool)pData);
        break;

    case ROID_DEFAULT:
        m_pDefaultOptions = (PicsDefault *)pData;
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {
            /* just eat extensions for now */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
            {
                /* If this is a rating bureau extension, take his bureau
                 * string and store it in this PicsRatingSystem.  We now
                 * own the memory, so NULL out the extension's pointer to
                 * it so he won't delete it.
                 */
                if (pExtension->m_pszRatingBureau != NULL)
                {
                    etstrRatingBureau.SetTo(pExtension->m_pszRatingBureau);
                    pExtension->m_pszRatingBureau = NULL;
                }
                delete pExtension;
                pExtension = NULL;
            }
        }
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;
            hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres))
            {
                delete pCategory;
                pCategory = NULL;
            }
            else
            {
                InitializeMyDefaults(pCategory);    /* category inherits default settings */
                pCategory->SetParents(this);    /* set pPRS fields in whole tree */
            }
        }
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsCategory::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
    case ROID_TRANSMITAS:
        etstrTransmitAs.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
            {
                delete pExtension;
                pExtension = NULL;
            }
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((bool) pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((bool) pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((bool)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((bool)pData);
        break;

    case ROID_MIN:
        etnMin.Set(PtrToLong(pData));
        break;

    case ROID_MAX:
        etnMax.Set(PtrToLong(pData));
        break;

    case ROID_LABEL:
        {
            PicsEnum *pEnum = (PicsEnum *)pData;
            hres = arrpPE.Append(pEnum) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres))
            {
                delete pEnum;
                pEnum = NULL;
            }
        }
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;

            /* For a nested category, synthesize the transmit-name from
             * ours and the child's (e.g., parent category 'color' plus
             * child category 'hue' becomes 'color/hue'.
             *
             * Note that the memory we allocate for the new name will be
             * owned by pCategory->etstrTransmitAs.  There is no memory
             * leak there.
             */
            UINT cbCombined = strlenf(etstrTransmitAs.Get()) +
                              strlenf(pCategory->etstrTransmitAs.Get()) +
                              2;        /* for PicsDelimChar + null */
            LPSTR pszTemp = new char[cbCombined];
            if (pszTemp == NULL)
                hres = E_OUTOFMEMORY;
            else {
                wsprintf(pszTemp, "%s%c%s", etstrTransmitAs.Get(),
                         PicsDelimChar, pCategory->etstrTransmitAs.Get());
                pCategory->etstrTransmitAs.SetTo(pszTemp);
                hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            }

            if (FAILED(hres))
            {
                delete pCategory;
                pCategory = NULL;
            }
        }
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsEnum::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_VALUE:
        etnValue.Set(PtrToLong(pData));
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsDefault::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
            {
                delete pExtension;
                pExtension = NULL;
            }
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((bool)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((bool)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((bool)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((bool)pData);
        break;

    case ROID_MIN:
        etnMin.Set(PtrToLong(pData));
        break;

    case ROID_MAX:
        etnMax.Set(PtrToLong(pData));
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsExtension::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_OPTIONAL:
    case ROID_MANDATORY:
        /* Only data we should get is a label bureau string. */
        if (pData != NULL)
            m_pszRatingBureau = (LPSTR)pData;
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


/***************************************************************************
    The main loop of the parser.
***************************************************************************/

/* ParseParenthesizedObjectContents is called with a text pointer pointing at
 * the first non-whitespace thing following the token identifying the type of
 * object.  It parses the rest of the contents of the object, up to and
 * including the ')' which closes it.  The array of AllowableOption structures
 * specifies which understood options are allowed to occur within this object.
 */
HRESULT RatFileParser::ParseParenthesizedObject(
    LPSTR *ppIn,                    /* where we are in the text stream */
    AllowableOption aao[],          /* allowable things inside this object */
    PicsObjectBase *pObject         /* object to set parameters into */
)
{
    HRESULT hres = S_OK;

    LPSTR pszCurrent = *ppIn;
    AllowableOption *pFound;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++)
    {
        pFound->fdwOptions &= ~AO_SEEN;
    }

    pFound = NULL;

    while (*pszCurrent != ')' && *pszCurrent != '\0' && SUCCEEDED(hres))
    {
        hres = ParseToOpening(&pszCurrent, aao, &pFound);
        if (SUCCEEDED(hres))
        {
            LPVOID pData;
            hres = (*(aObjectDescriptions[pFound->roid].pHandler))(&pszCurrent, &pData, this);
            if (SUCCEEDED(hres))
            {
                if ((pFound->fdwOptions & (AO_SINGLE | AO_SEEN)) == (AO_SINGLE | AO_SEEN))
                {
                    hres = RAT_E_DUPLICATEITEM;
                }
                else
                {
                    pFound->fdwOptions |= AO_SEEN;
                    hres = pObject->AddItem(pFound->roid, pData);
                    if (SUCCEEDED(hres))
                    {
                        if (*pszCurrent != ')')
                            hres = RAT_E_EXPECTEDRIGHT;
                        else
                            pszCurrent = FindNonWhite(pszCurrent+1);
                    }
                }
            }
        }
    }

    if (FAILED(hres))
    {
        return hres;
    }

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++)
    {
        if ((pFound->fdwOptions & (AO_MANDATORY | AO_SEEN)) == AO_MANDATORY)
        {
            return RAT_E_MISSINGITEM;       /* mandatory item not found */
        }
    }

    *ppIn = pszCurrent;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\passdlg.h ===
/****************************************************************************\
 *
 *   passdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Password Dialog
 *
\****************************************************************************/

#ifndef PASSWORD_DIALOG_H
#define PASSWORD_DIALOG_H

#include "basedlg.h"        // CBaseDialog

const UINT PASSCONFIRM_FAIL = 0;
const UINT PASSCONFIRM_OK = 1;
const UINT PASSCONFIRM_NEW = 2;

class CPasswordDialog: public CBaseDialog<CPasswordDialog>
{
private:
    static DWORD aIds[];
    int m_idsLabel;
    bool m_fCheckPassword;

public:
    enum { IDD = IDD_PASSWORD };

public:
    CPasswordDialog( int p_idsLabel, bool p_fCheckPassword = true );

public:
    typedef CPasswordDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\picsdlg.h ===
/****************************************************************************\
 *
 *   picsdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Pics Ratings Property Page
 *
\****************************************************************************/

#ifndef PICS_DIALOG_H
#define PICS_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

// #define RATING_LOAD_GRAPHICS

typedef HINSTANCE (APIENTRY *PFNSHELLEXECUTE)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);

class CPicsDialog : public CBasePropertyPage<IDD_RATINGS>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CPicsDialog( PRSD * p_pPRSD );

    void        PicsDlgSave( void );
    BOOL        InstallDefaultProvider( void );

public:
    typedef CPicsDialog thisClass;
    typedef CBasePropertyPage<IDD_RATINGS> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
        MESSAGE_HANDLER(WM_VSCROLL, OnScroll)

        COMMAND_ID_HANDLER(IDC_DETAILSBUTTON, OnDetails)

        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnSetActive)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)
        NOTIFY_CODE_HANDLER(TVN_ITEMEXPANDING, OnTreeItemExpanding)
        NOTIFY_CODE_HANDLER(TVN_SELCHANGED, OnTreeSelChanged)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDetails(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnTreeSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void        SetTreeImages( HWND hwndTV, HIMAGELIST himl );
    BOOL        InitTreeViewImageLists(HWND hwndTV);
    void        LaunchRatingSystemSite( void );
    void        PicsDlgInit( void );
    void        KillTree(HWND hwndTree, HTREEITEM hTree);
    void        PicsDlgUninit( void );

#ifdef RATING_LOAD_GRAPHICS
    POINT       BitmapWindowCoord( int nID );
    void        LoadGraphic( char *pIcon, POINT pt );
#endif

    PicsEnum *  PosToEnum(PicsCategory *pPC, LPARAM lPos);
    void        NewTrackbarPosition( void );
    void        SelectRatingSystemNode( PicsCategory *pPC );
    void        SelectRatingSystemInfo( PicsRatingSystem *pPRS );
    void        DeleteBitmapWindow( HWND & p_rhwnd );
    void        ControlsShow( TreeNodeEnum tne );
    TreeNode*   TreeView_GetSelectionLParam(HWND hwndTree);
    HTREEITEM   AddOneItem(HWND hwndTree, HTREEITEM hParent, LPSTR szText, HTREEITEM hInsAfter, LPARAM lpData, int iImage);
    void        AddCategory(PicsCategory *pPC, HWND hwndTree, HTREEITEM hParent);
    UserRatingSystem *  GetTempRatingList( void );
    UserRating *    GetTempRating( PicsCategory *pPC );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\ratguid.cpp ===
#include "msrating.h"

// declaring the GUIDs inline avoids having to use INITGUID
// avoiding unneeded GUIDs being pulled in. these will eventually
// need to go in a public header/lib so other people can implement
// these interfaces and use our COM object

// 20EDB660-7CDD-11CF-8DAB-00AA006C1A01
const GUID CLSID_RemoteSite = {0x20EDB660L, 0x7CDD, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01};
// 19427BA0-826C-11CF-8DAB-00AA006C1A01
const GUID IID_IObtainRating = {0x19427BA0L, 0x826C, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\pleasdlg.cpp ===
/****************************************************************************\
 *
 *   pleasdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Access Denied Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "debug.h"
#include "parselbl.h"
#include "picsrule.h"
#include "pleasdlg.h"       // CPleaseDialog
#include "hint.h"           // CHint
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()
#include <wininet.h>        // URL_COMPONENTS

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

// $KLUDGE begins -- These should not be a global set outside the class!!
extern BOOL  g_fInvalid;
extern DWORD g_dwDataSource;

extern PICSRulesRatingSystem * g_pPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRSPreApply;
extern array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern BOOL g_fPICSRulesEnforced,g_fApprovedSitesEnforced;
extern HMODULE g_hURLMON,g_hWININET;
extern char g_szLastURL[INTERNET_MAX_URL_LENGTH];
// $KLUDGE ends -- These should not be a global set outside the class!!

DWORD CPleaseDialog::aIds[] = {
    IDC_STATIC2,                IDH_IGNORE,
    IDC_CONTENTLABEL,           IDH_IGNORE,
    IDC_CONTENTERROR,           IDH_RATINGS_DESCRIBE_RESTRICTED,
    IDC_CONTENTDESCRIPTION,     IDH_RATINGS_DESCRIBE_RESTRICTED,
    IDC_STATIC4,                IDH_IGNORE,
    IDC_STATIC5,                IDH_IGNORE,
    IDC_STATIC3,                IDH_IGNORE,
    IDC_BLOCKING_SITE,          IDH_RATINGS_VIEW_RESTRICTED,
    IDC_BLOCKING_PAGE,          IDH_RATINGS_VIEW_RESTRICTED,
    IDC_BLOCKING_ONCE,          IDH_RATINGS_VIEW_RESTRICTED,
    IDC_OLD_HINT_LABEL,         IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_OLD_HINT_TEXT,          IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_STATIC1,                IDH_RATINGS_SUPERVISOR_PASSWORD,
    IDC_PASSWORD,               IDH_RATINGS_SUPERVISOR_PASSWORD,
    0,0
};

// Array of Dialog Ids which are displayed for Please dialog and not for Deny dialog.
DWORD CPleaseDialog::aPleaseIds[] = {
    IDC_STATIC4,
    IDC_STATIC3,
    IDC_STATIC5,
    IDC_BLOCKING_SITE,
    IDC_BLOCKING_PAGE,
    IDC_BLOCKING_ONCE,
    IDC_OLD_HINT_LABEL,
    IDC_OLD_HINT_TEXT,
    IDC_STATIC1,
    IDC_PASSWORD
};

CPleaseDialog::CPleaseDialog( PleaseDlgData * p_ppdd )
{
    ASSERT( p_ppdd );

    m_ppdd = p_ppdd;
}

LRESULT CPleaseDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ASSERT( m_ppdd );

    if ( m_ppdd )
    {
        ASSERT( m_ppdd->hwndDlg == NULL );

        if ( m_ppdd->hwndDlg == NULL )
        {
            m_ppdd->hwndDlg = m_hWnd;

            /* Attach our data structure to the dialog so we can find it when the
             * dialog is dismissed, and on the owner window passed to the API so
             * we can find it on subsequent API calls.
             */

            SetProp( m_ppdd->hwndOwner, szRatingsProp, (HANDLE)m_ppdd );
        }
    }

    // Display the Please dialog controls or hide them all.
    for ( int iIndex=0; iIndex<sizeof(aPleaseIds)/sizeof(DWORD); iIndex++ )
    {
        ShowHideControl( aPleaseIds[iIndex], IsPleaseDialog() );
    }

    // Reduce the height of the dialog.
    if ( IsDenyDialog() )
    {
        ReduceDialogHeight( IDC_CONTENTDESCRIPTION );
    }

    InitPleaseDialog( m_ppdd );

    if ( IsPleaseDialog() )
    {
        if ( GetDlgItem(IDC_PASSWORD) != NULL )
        {
            SendDlgItemMessage(IDC_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }

        // Display previously created hint (if one exists).
        {
            CHint       oldHint( m_hWnd, IDC_OLD_HINT_TEXT );

            oldHint.DisplayHint();
        }

        // set focus to password field
        ::SetFocus( GetDlgItem(IDC_PASSWORD) );
    }

    bHandled = FALSE;
    return 0L;      // The focus was set to the password field.
}

LRESULT CPleaseDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndPleaseDialog(FALSE);
    return 0L;
}

LRESULT CPleaseDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // For Deny dialog there is no password so the code below checks for a non-existance password?
    if ( IsDenyDialog() )
    {
        EndPleaseDialog(FALSE);
        return 0L;
    }

    char    szPassword[MAXPATHLEN];
    HRESULT hRet;

    szPassword[0] = '\0';

    ASSERT( GetDlgItem( IDC_PASSWORD ) != NULL );

    GetDlgItemText(IDC_PASSWORD, szPassword, sizeof(szPassword));

    hRet = VerifySupervisorPassword(szPassword);

    if (hRet == ResultFromScode(S_OK))
    {
        if (SendDlgItemMessage(IDC_BLOCKING_PAGE,
                              BM_GETCHECK,
                              (WPARAM) 0,
                              (LPARAM) 0)==BST_CHECKED)
        {
            HRESULT hRes;

            hRes=AddToApprovedSites(PICSRULES_ALWAYS,PICSRULES_PAGE);

            if (FAILED(hRes))
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_APPROVED_CANTSAVE,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
        }
        else if (SendDlgItemMessage(IDC_BLOCKING_SITE,
                                   BM_GETCHECK,
                                   (WPARAM) 0,
                                   (LPARAM) 0)==BST_CHECKED)
        {
            HRESULT hRes;

            hRes=AddToApprovedSites(PICSRULES_ALWAYS,PICSRULES_SITE);

            if (FAILED(hRes))
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_APPROVED_CANTSAVE,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
        }

        EndPleaseDialog(TRUE);
    }
    else
    {
        MyMessageBox(m_hWnd, IDS_BADPASSWORD, IDS_GENERIC, MB_OK|MB_ICONERROR);
        ::SetFocus(GetDlgItem(IDC_PASSWORD));
        SetDlgItemText(IDC_PASSWORD, szNULL);
    }

    return 0L;
}

LRESULT CPleaseDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CPleaseDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

LRESULT CPleaseDialog::OnNewDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    InitPleaseDialog( (PleaseDlgData *) lParam );

    return 0L;
}

void CPleaseDialog::AppendString(HWND hwndEC, LPCSTR pszString)
{
    int cchEdit = ::GetWindowTextLength(hwndEC);
    ::SendMessage(hwndEC, EM_SETSEL, (WPARAM)cchEdit, (LPARAM)cchEdit);
    ::SendMessage(hwndEC, EM_REPLACESEL, 0, (LPARAM)pszString);
}

void CPleaseDialog::AddSeparator(HWND hwndEC, BOOL fAppendToEnd)
{
    NLS_STR nlsTemp(MAX_RES_STR_LEN);
    if (nlsTemp.QueryError() != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "PleaseDialog::AddSeparator() - Failed to allocate nlsTemp!" );
        return;
    }

    if (fAppendToEnd)
    {
        nlsTemp.LoadString(IDS_DESCRIPTION_SEPARATOR);
        AppendString(hwndEC, nlsTemp.QueryPch());
    }

    nlsTemp.LoadString(IDS_FRAME);
    if (fAppendToEnd)
    {
        AppendString(hwndEC, nlsTemp.QueryPch());
    }
    else
    {
        ::SendMessage(hwndEC, EM_SETSEL, 0, 0);
        ::SendMessage(hwndEC, EM_REPLACESEL, 0, (LPARAM)(LPCSTR)nlsTemp.QueryPch());
    }
}

void CPleaseDialog::InitPleaseDialog( PleaseDlgData * pdd )
{
    CComAutoCriticalSection         critSec;

/****
    rated:
        for each URS with m_fInstalled = TRUE:
            for each UR with m_fFailed = TRUE:
                add line to EC
        
    not rated:
        no label list? --> report not rated
        invalid string in label list? --> report invalid rating
        any URS's with invalid strings? --> report invalid rating
        any URS's with error strings? --> report label error
        no URS's marked installed? --> report unknown rating system
        for installed URS's:
            for each UR:
                options has invalid string? --> report invalid rating
                options expired? --> report expired
                not fFound? --> report unknown rating
****/
    ASSERT( pdd );

    if ( ! pdd )
    {
        TraceMsg( TF_ERROR, "CPleaseDialog::InitPleaseDialog() - pdd is NULL!" );
        return;
    }

    ASSERT( pdd == m_ppdd );

    CParsedLabelList *pLabelList = pdd->pLabelList;

    for (UINT i=0; i<pdd->cLabels && i<ARRAYSIZE(pdd->apLabelStrings); i++)
    {
        if (pdd->apLabelStrings[i] == NULL)
        {
            if (pLabelList == NULL || pLabelList->m_pszOriginalLabel == NULL)
            {
                TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - pLabelList is NULL or m_pszOriginalLabel is NULL!" );
                return;
            }
        }
        else
        {
            if (pLabelList != NULL &&
                pLabelList->m_pszOriginalLabel != NULL &&
                ! ::strcmpf( pdd->apLabelStrings[i], pLabelList->m_pszOriginalLabel ) )
            {
                TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - apLabelStrings[%d]='%s' does not match m_pszOriginalLabel='%s'!", i, pdd->apLabelStrings[i], pLabelList->m_pszOriginalLabel );
                return;
            }
        }
    }

    if (pdd->cLabels < ARRAYSIZE(pdd->apLabelStrings))
    {
        if (pLabelList == NULL || pLabelList->m_pszOriginalLabel == NULL)
        {
            pdd->apLabelStrings[pdd->cLabels] = NULL;
        }
        else
        {
            pdd->apLabelStrings[pdd->cLabels] = new char[::strlenf(pLabelList->m_pszOriginalLabel)+1];

            if (pdd->apLabelStrings[pdd->cLabels] != NULL)
            {
                ::strcpyf(pdd->apLabelStrings[pdd->cLabels], pLabelList->m_pszOriginalLabel);
            }
        }
    }

    CString             strTitle;

    if ( pLabelList && pLabelList->m_pszURL && pLabelList->m_pszURL[0] != '\0' )
    {
        strTitle.Format( IDS_CONTENT_ADVISOR_HTTP_TITLE, pLabelList->m_pszURL );
    }
    else
    {
        strTitle.LoadString( IDS_CONTENT_ADVISOR_TITLE );
    }

    SetWindowText( strTitle );

    HWND hwndDescription = GetDlgItem(IDC_CONTENTDESCRIPTION);
    HWND hwndError = GetDlgItem(IDC_CONTENTERROR);
    HWND hwndPrevEC = pdd->hwndEC;

    /* There are two edit controls in the dialog.  One, the "description"
     * control, has a horizontal scrollbar, because we don't want word wrap
     * for the category names (cleaner presentation).  The other EC has no
     * scrollbar so that the lengthy error strings will wordwrap.
     *
     * If we've been using the description control and we add error-type
     * information, we need to copy the text out of the description control
     * into the error control and show it.
     */
    BOOL fRatedPage = ( pLabelList != NULL && pLabelList->m_fRated );
    if ( ! fRatedPage && pdd->hwndEC == hwndDescription )
    {
        NLS_STR nlsTemp(::GetWindowTextLength(hwndDescription));
        if (nlsTemp.QueryError() == ERROR_SUCCESS)
        {
            CHAR * tempStr = nlsTemp.Party();
            if (tempStr)
            {
                ::GetWindowText(hwndDescription, tempStr, nlsTemp.QueryAllocSize());
                nlsTemp.DonePartying();
                ::SetWindowText(hwndError, nlsTemp.QueryPch());
            }
            else
            {
                nlsTemp.DonePartying();
            }
        }

        pdd->hwndEC = hwndError;
    }
    else if (pdd->hwndEC == NULL)
    {
        pdd->hwndEC = fRatedPage ? hwndDescription : hwndError;
    }

    if (pdd->hwndEC != hwndPrevEC)
    {
        BOOL fShowErrorCtl = (pdd->hwndEC == hwndError);
        if (::GetFocus() == hwndPrevEC)
        {
            ::SetFocus(pdd->hwndEC);
        }

        ShowHideControl( IDC_CONTENTERROR, fShowErrorCtl );
        ShowHideControl( IDC_CONTENTDESCRIPTION, ! fShowErrorCtl );
    }

    /* If there's already just one label in the list, prefix it with a
     * label "Frame:" since there will now be two.
     */
    if (pdd->cLabels == 1)
    {
        AddSeparator(pdd->hwndEC, FALSE);
    }

    /* If this is not the first label we're adding, we need a full separator
     * appended before we add new descriptive text.
     */
    if (pdd->cLabels > 0)
    {
        AddSeparator(pdd->hwndEC, TRUE);
    }

    if (g_fInvalid)
    {
        char szSourceMessage[MAX_PATH];

        MLLoadString(IDS_TAMPEREDRATING1,(char *) szSourceMessage,MAX_PATH);

        AppendString(pdd->hwndEC, szSourceMessage);
        AppendString(pdd->hwndEC, "\x0D\x0A");

        MLLoadString(IDS_TAMPEREDRATING2,(char *) szSourceMessage,MAX_PATH);
        AppendString(pdd->hwndEC, szSourceMessage);
    }
    else if (fRatedPage)
    {
        NLS_STR nlsTemplate(MAX_RES_STR_LEN);
        nlsTemplate.LoadString(IDS_RATINGTEMPLATE);
        NLS_STR nlsTmp;
        if (nlsTemplate.QueryError() || nlsTmp.QueryError())
        {
            TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - fRatedPage => nlsTemplate or nlsTmp Error!" );
            return;
        }

        for (CParsedServiceInfo *ppsi = &pLabelList->m_ServiceInfo;
             ppsi != NULL;
             ppsi = ppsi->Next())
        {
            if (!ppsi->m_fInstalled)
                continue;

            UserRatingSystem *pURS = pdd->pPU->FindRatingSystem(ppsi->m_pszServiceName);
            if (pURS == NULL || pURS->m_pPRS == NULL)
                continue;

            NLS_STR nlsSystemName(STR_OWNERALLOC, pURS->m_pPRS->etstrName.Get());
            UINT cRatings = ppsi->aRatings.Length();
            for (UINT i=0; i<cRatings; i++)
            {
                CParsedRating *pRating = &ppsi->aRatings[i];
                if (pRating->fFailed)
                {
                    nlsTmp = nlsTemplate;
                    UserRating *pUR = pURS->FindRating(pRating->pszTransmitName);
                    if (pUR == NULL)
                        continue;

                    PicsCategory *pPC = pUR->m_pPC;
                    if (pPC == NULL)
                        continue;

                    LPCSTR pszCategory;
                    if (pPC->etstrName.fIsInit())
                    {
                        pszCategory = pPC->etstrName.Get();
                    }
                    else if (pPC->etstrDesc.fIsInit())
                    {
                        pszCategory = pPC->etstrDesc.Get();
                    }
                    else
                    {
                        pszCategory = pRating->pszTransmitName;
                    }

                    NLS_STR nlsCategoryName(STR_OWNERALLOC, (LPSTR)pszCategory);
                    UINT cValues = pPC->arrpPE.Length();
                    PicsEnum *pPE;
                    for (UINT iValue=0; iValue<cValues; iValue++)
                    {
                        pPE = pPC->arrpPE[iValue];
                        if (pPE->etnValue.Get() == pRating->nValue)
                            break;
                    }

                    LPCSTR pszValue = szNULL;
                    char szNumBuf[20];
                    if (iValue < cValues)
                    {
                        if (pPE->etstrName.fIsInit())
                        {
                            pszValue = pPE->etstrName.Get();
                        }
                        else if (pPE->etstrDesc.fIsInit())
                        {
                            pszValue = pPE->etstrDesc.Get();
                        }
                        else
                        {
                            wsprintf(szNumBuf, "%d", pRating->nValue);
                            pszValue = szNumBuf;
                        }
                    }

                    NLS_STR nlsValueName(STR_OWNERALLOC, (LPSTR)pszValue);
                    const NLS_STR *apnls[] = { &nlsSystemName, &nlsCategoryName, &nlsValueName, NULL };
                    nlsTmp.InsertParams(apnls);
                    if (!nlsTmp.QueryError())
                    {
                        AppendString(pdd->hwndEC, nlsTmp.QueryPch());
                    }
                }
            }
        }

        if ((g_fPICSRulesEnforced!=TRUE)&&(g_fApprovedSitesEnforced!=TRUE))
        {
            UINT idSourceMsg;
            char szSourceMessage[MAX_PATH];

            switch(g_dwDataSource)
            {
                case PICS_LABEL_FROM_HEADER:
                {
                    idSourceMsg=IDS_SOURCE_SERVER;
                    break;
                }
                case PICS_LABEL_FROM_PAGE:
                {
                    idSourceMsg=IDS_SOURCE_EMBEDDED;
                    break;
                }
                case PICS_LABEL_FROM_BUREAU:
                {
                    idSourceMsg=IDS_SOURCE_BUREAU;
                    break;
                }
            }

            MLLoadString(idSourceMsg,(char *) szSourceMessage,MAX_PATH);

            AppendString(pdd->hwndEC, "\x0D\x0A");
            AppendString(pdd->hwndEC, szSourceMessage);
        }
    }
    else
    {
        UINT idMsg = 0;
        LPCSTR psz1=szNULL, psz2=szNULL;
        if ( pLabelList == NULL || pLabelList->m_fNoRating )
        {
            idMsg = IDS_UNRATED;
        }
        else if (pLabelList->m_pszInvalidString)
        {
            idMsg = IDS_INVALIDRATING;
            psz1 = pLabelList->m_pszInvalidString;
        }
        else
        {
            BOOL fErrorFound = FALSE;
            BOOL fAnyInstalled = FALSE;
            CParsedServiceInfo *ppsi = &pLabelList->m_ServiceInfo;
            while (ppsi != NULL)
            {
                if (ppsi->m_pszInvalidString)
                {
                    idMsg = IDS_INVALIDRATING;
                    psz1 = ppsi->m_pszInvalidString;
                    fErrorFound = TRUE;
                }
                else if (ppsi->m_pszErrorString)
                {
                    idMsg = IDS_LABELERROR;
                    psz1 = ppsi->m_pszErrorString;
                    fErrorFound = TRUE;
                }
                else if (ppsi->m_fInstalled)
                {
                    fAnyInstalled = TRUE;
                }

                ppsi = ppsi->Next();
            }
            if (!fErrorFound)
            {
                if (!fAnyInstalled)
                {
                    idMsg = IDS_UNKNOWNSYSTEM;
                    psz1 = pLabelList->m_ServiceInfo.m_pszServiceName;
                }
                else
                {
                    for (ppsi = &pLabelList->m_ServiceInfo;
                         ppsi != NULL;
                         ppsi = ppsi->Next())
                    {
                        if ( ! ppsi->m_fInstalled )
                            continue;

                        UINT cRatings = ppsi->aRatings.Length();
                        for (UINT i=0; i<cRatings; i++)
                        {
                            CParsedRating *ppr = &ppsi->aRatings[i];
                            COptionsBase *pOpt = ppr->pOptions;
                            if (pOpt->m_pszInvalidString)
                            {
                                idMsg = IDS_INVALIDRATING;
                                psz1 = pOpt->m_pszInvalidString;
                                break;
                            }
                            else if (pOpt->m_fdwFlags & LBLOPT_WRONGURL)
                            {
                                idMsg = IDS_WRONGURL;
                                psz1 = pLabelList->m_pszURL;
                                psz2 = pOpt->m_pszURL;
                            }
                            else if (pOpt->m_fdwFlags & LBLOPT_EXPIRED)
                            {
                                idMsg = IDS_EXPIRED;
                                break;
                            }
                            else if (!ppr->fFound)
                            {
                                idMsg = IDS_UNKNOWNRATING;
                                psz1 = ppr->pszTransmitName;
                                UserRatingSystem *pURS = pdd->pPU->FindRatingSystem(ppsi->m_pszServiceName);
                                if (pURS != NULL && pURS->m_pPRS != NULL)
                                {
                                    if (pURS->m_pPRS->etstrName.fIsInit())
                                    {
                                        psz2 = pURS->m_pPRS->etstrName.Get();
                                    }
                                }
                                break;
                            }
                        }
                        if (idMsg != 0)
                            break;
                    }
                }
            }
        }

        if (g_fPICSRulesEnforced==TRUE)
        {
            idMsg=IDS_PICSRULES_ENFORCED;
        }
        else if (g_fApprovedSitesEnforced==TRUE)
        {
            idMsg=IDS_APPROVEDSITES_ENFORCED;
        }

        /* It's theoretically possible that we got through all that and
         * didn't find anything explicitly wrong, yet the site was considered
         * unrated (perhaps it was a valid label with no actual ratings in it).
         * So if we didn't decide what error to display, just don't stick
         * anything in the edit control, and the dialog will just say "Sorry"
         * at the top.
         */
        if (idMsg != 0)
        {
            NLS_STR nls1(STR_OWNERALLOC, (LPSTR)psz1);
            NLS_STR nls2(STR_OWNERALLOC, (LPSTR)psz2);
            const NLS_STR *apnls[] = { &nls1, &nls2, NULL };
            NLS_STR nlsMessage(MAX_RES_STR_LEN);
            nlsMessage.LoadString((USHORT)idMsg, apnls);
            AppendString(pdd->hwndEC, nlsMessage.QueryPch());
        }

        if (idMsg == IDS_UNKNOWNSYSTEM)
        {
            NLS_STR nlsTemplate(MAX_RES_STR_LEN);
            nlsTemplate.LoadString(IDS_UNKNOWNRATINGTEMPLATE);
            NLS_STR nlsTmp;
            if (nlsTemplate.QueryError() || nlsTmp.QueryError())
            {
                TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - IDS_UNKNOWNSYSTEM => nlsTemplate or nlsTmp Error!" );
                return;
            }
            
            UINT cRatings = pLabelList->m_ServiceInfo.aRatings.Length();
            for (UINT i=0; i<cRatings; i++)
            {
                CParsedRating *ppr = &pLabelList->m_ServiceInfo.aRatings[i];

                char szNumBuf[20];
                wsprintf(szNumBuf, "%d", ppr->nValue);

                NLS_STR nlsCategoryName(STR_OWNERALLOC, ppr->pszTransmitName);
                NLS_STR nlsValueName(STR_OWNERALLOC, szNumBuf);
                const NLS_STR *apnls[] = { &nlsCategoryName, &nlsValueName, NULL };
                nlsTmp = nlsTemplate;
                nlsTmp.InsertParams(apnls);
                if (!nlsTmp.QueryError())
                {
                    AppendString(pdd->hwndEC, nlsTmp.QueryPch());
                }
            }
        }
    }

    if ( IsPleaseDialog() )
    {
        SendDlgItemMessage(IDC_BLOCKING_ONCE,
                           BM_SETCHECK,
                           (WPARAM) BST_CHECKED,
                           (LPARAM) 0);

        SendDlgItemMessage(IDC_BLOCKING_PAGE,
                           BM_SETCHECK,
                           (WPARAM) BST_UNCHECKED,
                           (LPARAM) 0);

        SendDlgItemMessage(IDC_BLOCKING_SITE,
                           BM_SETCHECK,
                           (WPARAM) BST_UNCHECKED,
                           (LPARAM) 0);
    }

    pdd->cLabels++;       /* now one more label description in the box */
}

void CPleaseDialog::EndPleaseDialog( BOOL fRet)
{
    PleaseDlgData *ppdd = m_ppdd;

    ASSERT( m_ppdd );

    if (ppdd != NULL)
    {
        ppdd->dwFlags = PDD_DONE | (fRet ? PDD_ALLOW : 0);
        ppdd->hwndDlg = NULL;

        SetProp( m_ppdd->hwndOwner, szRatingsValue, UlongToPtr( ppdd->dwFlags ) );
        RemoveProp(ppdd->hwndOwner, szRatingsProp);
    }

    EndDialog(fRet);
}

HRESULT CPleaseDialog::AddToApprovedSites(BOOL fAlwaysNever,BOOL fSitePage)
{
    PICSRulesPolicy             * pPRPolicy;
    PICSRulesByURL              * pPRByURL;
    PICSRulesByURLExpression    * pPRByURLExpression;
    char                        * lpszSiteURL;
    HRESULT                     hRes;
    URL_COMPONENTS              URLComponents;
    FN_INTERNETCRACKURL         pfnInternetCrackUrl;
    INTERNET_SCHEME             INetScheme=INTERNET_SCHEME_DEFAULT;
    INTERNET_PORT               INetPort=INTERNET_INVALID_PORT_NUMBER;
    LPSTR                       lpszScheme,lpszHostName,lpszUserName,
                                lpszPassword,lpszUrlPath,lpszExtraInfo;
    BOOL                        fAddedScheme=FALSE;
    int                         iCounter,iLoopCounter;

    lpszSiteURL=new char[INTERNET_MAX_URL_LENGTH];

    if (lpszSiteURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    strcpy(lpszSiteURL,g_szLastURL);

    if (g_pApprovedPRRS==NULL)
    {
        g_pApprovedPRRS=new PICSRulesRatingSystem;

        if (g_pApprovedPRRS==NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    pPRPolicy=new PICSRulesPolicy;

    if (pPRPolicy==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pPRByURL=new PICSRulesByURL;

    if (pPRByURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    if (fAlwaysNever==PICSRULES_NEVER)
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_REJECTBYURL;
        pPRPolicy->AddItem(PROID_REJECTBYURL,pPRByURL);
    }
    else
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_ACCEPTBYURL;
        pPRPolicy->AddItem(PROID_ACCEPTBYURL,pPRByURL);
    }

    pPRByURLExpression=new PICSRulesByURLExpression;
    
    if (pPRByURLExpression==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

    //if we made it through all that, then we have a
    //PICSRulesByURLExpression to fill out, and need
    //to update the list box.

    lpszScheme=new char[INTERNET_MAX_SCHEME_LENGTH+1];
    lpszHostName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUserName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszPassword=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUrlPath=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszExtraInfo=new char[INTERNET_MAX_PATH_LENGTH+1];

    if (lpszScheme==NULL ||
       lpszHostName==NULL ||
       lpszUserName==NULL ||
       lpszPassword==NULL ||
       lpszUrlPath==NULL ||
       lpszExtraInfo==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    URLComponents.dwStructSize=sizeof(URL_COMPONENTS);
    URLComponents.lpszScheme=lpszScheme;
    URLComponents.dwSchemeLength=INTERNET_MAX_SCHEME_LENGTH;
    URLComponents.nScheme=INetScheme;
    URLComponents.lpszHostName=lpszHostName;
    URLComponents.dwHostNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.nPort=INetPort;
    URLComponents.lpszUserName=lpszUserName;
    URLComponents.dwUserNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszPassword=lpszPassword;
    URLComponents.dwPasswordLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszUrlPath=lpszUrlPath;
    URLComponents.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszExtraInfo=lpszExtraInfo;
    URLComponents.dwExtraInfoLength=INTERNET_MAX_PATH_LENGTH;

    pfnInternetCrackUrl=(FN_INTERNETCRACKURL) GetProcAddress(g_hWININET,"InternetCrackUrlA");

    if (pfnInternetCrackUrl==NULL)
    {
        return(E_UNEXPECTED);
    }

    pfnInternetCrackUrl(lpszSiteURL,0,ICU_DECODE,&URLComponents);

    delete lpszExtraInfo; //we don't do anything with this for now
    lpszExtraInfo = NULL;

    delete lpszPassword; //not supported by PICSRules
    lpszPassword = NULL;

    if (g_fApprovedSitesEnforced==TRUE)
    {
        int             iCounter;
        PICSRulesPolicy * pPRFindPolicy;
        BOOL            fFound=FALSE,fDeleted=FALSE;
        
        //we've already got an Approved Sites setting enforcing this
        //so check for an exact match, and if it exists, change it
        //instead of adding another
        
        for (iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesByURLExpression * pPRFindByURLExpression;
            PICSRulesByURL           * pPRFindByURL;
            char                     * lpszTest;

            pPRFindPolicy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];

            switch(pPRFindPolicy->m_PRPolicyAttribute)
            {
                case PR_POLICY_REJECTBYURL:
                {
                    pPRFindByURL=pPRFindPolicy->m_pPRRejectByURL;

                    break;
                }
                case PR_POLICY_ACCEPTBYURL:
                {
                    pPRFindByURL=pPRFindPolicy->m_pPRAcceptByURL;

                    break;
                }
            }

            pPRFindByURLExpression=pPRFindByURL->m_arrpPRByURL[0];

            if ((pPRFindByURLExpression->m_bNonWild)&BYURL_SCHEME)
            {
                if (lpszScheme==NULL)
                {
                    fFound=FALSE;

                    continue;
                }

                lpszTest=pPRFindByURLExpression->m_etstrScheme.Get();

                if (lstrcmpi(lpszScheme,lpszTest)==0)
                {
                    fFound=TRUE;
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }
            else
            {
                fFound=TRUE;
            }

            if ((pPRFindByURLExpression->m_bNonWild)&BYURL_USER)
            {
                if (lpszUserName==NULL)
                {
                    fFound=FALSE;

                    continue;
                }

                lpszTest=pPRFindByURLExpression->m_etstrUser.Get();

                if (lstrcmpi(lpszUserName,lpszTest)==0)
                {
                    fFound=TRUE;
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }
            else
            {
                fFound=TRUE;
            }

            if ((pPRFindByURLExpression->m_bNonWild)&BYURL_HOST)
            {
                if (lpszHostName==NULL)
                {
                    fFound=FALSE;

                    continue;
                }

                lpszTest=pPRFindByURLExpression->m_etstrHost.Get();

                if (lstrcmp(lpszHostName,lpszTest)==0)
                {
                    fFound=TRUE;
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }
            else
            {
                fFound=TRUE;
            }

            if (fSitePage!=PICSRULES_SITE)
            {
                if ((pPRFindByURLExpression->m_bNonWild)&BYURL_PATH)
                {
                    int iLen;

                    if (lpszUrlPath==NULL)
                    {
                        fFound=FALSE;

                        continue;
                    }

                    lpszTest=pPRFindByURLExpression->m_etstrPath.Get();

                    //kill trailing slashes
                    iLen=lstrlen(lpszTest);

                    if (lpszTest[iLen-1]=='/')
                    {
                        lpszTest[iLen-1]='\0';
                    }

                    iLen=lstrlen(lpszUrlPath);

                    if (lpszUrlPath[iLen-1]=='/')
                    {
                        lpszUrlPath[iLen-1]='\0';
                    }
                    
                    if (lstrcmp(lpszUrlPath,lpszTest)==0)
                    {
                        fFound=TRUE;
                    }
                    else
                    {
                        fFound=FALSE;

                        continue;
                    }
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }

            if (fFound==TRUE)
            {
                if (fSitePage==PICSRULES_PAGE)
                {
                    break;
                }
                else
                {
                    delete pPRFindPolicy;
                    pPRFindPolicy = NULL;

                    g_pApprovedPRRS->m_arrpPRPolicy[iCounter]=NULL;

                    fDeleted=TRUE;
                }
            }
        }

        if (fDeleted==TRUE)
        {
            PICSRulesRatingSystem * pPRRSNew;

            pPRRSNew=new PICSRulesRatingSystem;

            if (pPRRSNew==NULL)
            {
                return(E_OUTOFMEMORY);
            }

            for (iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
            {
                if ((g_pApprovedPRRS->m_arrpPRPolicy[iCounter])!=NULL)
                {
                    pPRRSNew->m_arrpPRPolicy.Append((g_pApprovedPRRS->m_arrpPRPolicy[iCounter]));
                }
            }

            g_pApprovedPRRS->m_arrpPRPolicy.ClearAll();

            delete g_pApprovedPRRS;

            g_pApprovedPRRS=pPRRSNew;

            fFound=FALSE;
        }

        if (fFound==TRUE)
        {
            delete pPRFindPolicy;
            pPRFindPolicy= NULL;

            g_pApprovedPRRS->m_arrpPRPolicy[iCounter]=pPRPolicy;
        }
        else
        {
            hRes=g_pApprovedPRRS->AddItem(PROID_POLICY,pPRPolicy);

            if (FAILED(hRes))
            {
                return(hRes);
            }
        }
    }
    else
    {
        hRes=g_pApprovedPRRS->AddItem(PROID_POLICY,pPRPolicy);

        if (FAILED(hRes))
        {
            return(hRes);
        }
    }

    pPRByURLExpression->m_fInternetPattern=TRUE;

    if ((*lpszScheme!=NULL)&&(fAddedScheme==FALSE))
    {
        pPRByURLExpression->m_bNonWild|=BYURL_SCHEME;
        pPRByURLExpression->m_etstrScheme.SetTo(lpszScheme);   
    }
    else
    {
        delete lpszScheme;
        lpszScheme = NULL;
    }
    pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;

    if (*lpszUserName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_USER;           
        pPRByURLExpression->m_etstrUser.SetTo(lpszUserName);
    }
    else
    {
        delete lpszUserName;
        lpszUserName = NULL;
    }
    pPRByURLExpression->m_bSpecified|=BYURL_USER;

    if (*lpszHostName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_HOST;           
        pPRByURLExpression->m_etstrHost.SetTo(lpszHostName);
    }
    else
    {
        delete lpszHostName;
        lpszHostName = NULL;
    }
    pPRByURLExpression->m_bSpecified|=BYURL_HOST;

    if (*lpszUrlPath!=NULL)
    {
        if (lstrcmp(lpszUrlPath,"/")!=0)
        {
            if (fSitePage==PICSRULES_PAGE)
            {
                pPRByURLExpression->m_bNonWild|=BYURL_PATH;           
                pPRByURLExpression->m_etstrPath.SetTo(lpszUrlPath);
            }
        }
    }
    else
    {
        delete lpszUrlPath;
        lpszUrlPath = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_PATH;

    if (URLComponents.nPort!=INTERNET_INVALID_PORT_NUMBER)
    {
        LPSTR lpszTemp;

        lpszTemp=new char[MAX_PATH];

            if (lpszTemp==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
        wsprintf(lpszTemp,"%d",URLComponents.nPort);

        pPRByURLExpression->m_bNonWild|=BYURL_PORT;           
        pPRByURLExpression->m_etstrPort.SetTo(lpszTemp);
    }
    pPRByURLExpression->m_bSpecified|=BYURL_PORT;

    if (fSitePage==PICSRULES_PAGE)
    {
        pPRByURLExpression->m_etstrURL.SetTo(lpszSiteURL);
    }
    else
    {
        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpression->m_etstrHost.Get());
    }

    //copy master list to the PreApply list so we can reorder the entries
    //to obtain the appropriate logic.

    if (g_pApprovedPRRSPreApply!=NULL)
    {
        delete g_pApprovedPRRSPreApply;
    }

    g_pApprovedPRRSPreApply=new PICSRulesRatingSystem;

    if (g_pApprovedPRRSPreApply==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return(E_OUTOFMEMORY);
    }

    for (iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
    {
        PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
        PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
        PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

        pPRPolicy=new PICSRulesPolicy;
        
        if (pPRPolicy==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return(E_OUTOFMEMORY);
        }

        pPRPolicyToCopy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];
        
        pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

        pPRByURL=new PICSRulesByURL;
        
        if (pPRByURL==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return(E_OUTOFMEMORY);
        }

        if (pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            
            pPRPolicy->m_pPRAcceptByURL=pPRByURL;
        }
        else
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;

            pPRPolicy->m_pPRRejectByURL=pPRByURL;
        }

        pPRByURLExpression=new PICSRulesByURLExpression;

        if (pPRByURLExpression==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return(E_OUTOFMEMORY);
        }

        pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

        if (pPRByURLExpressionToCopy==NULL)
        {
            char    *lpszTitle,*lpszMessage;

            //we shouldn't ever get here

            lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
            lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

            MLLoadString(IDS_ERROR,(LPTSTR) lpszTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_NOAPPROVEDSAVE,(LPTSTR) lpszMessage,MAX_PATH);

            MessageBox((LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

            GlobalFree(lpszTitle);
            lpszTitle = NULL;
            GlobalFree(lpszMessage);
            lpszMessage = NULL;

            delete pPRPolicy;
            pPRPolicy = NULL;

            return(E_UNEXPECTED);
        }

        pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
        pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
        pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
        pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
        pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
        pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
        pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
        pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

        
        pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

        g_pApprovedPRRSPreApply->m_arrpPRPolicy.Append(pPRPolicy);
    }

    if (g_pApprovedPRRS!=NULL)
    {
        delete g_pApprovedPRRS;
    }

    g_pApprovedPRRS=new PICSRulesRatingSystem;

    if (g_pApprovedPRRS==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return(E_OUTOFMEMORY);
    }

    for (iLoopCounter=0;iLoopCounter<2;iLoopCounter++)
    {
        for (iCounter=0;iCounter<g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
            PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
            PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

            pPRPolicyToCopy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter];

            if (pPRPolicyToCopy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            }
            else
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;
            }

            pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

            if (pPRByURLExpressionToCopy==NULL)
            {
                char    *lpszTitle,*lpszMessage;

                //we shouldn't ever get here

                lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
                lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

                MLLoadString(IDS_ERROR,(LPTSTR) lpszTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_NOAPPROVEDSAVE,(LPTSTR) lpszMessage,MAX_PATH);

                MessageBox((LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

                GlobalFree(lpszTitle);
                lpszTitle = NULL;
                GlobalFree(lpszMessage);
                lpszMessage = NULL;

                return(E_UNEXPECTED);
            }

            //we want to put all of the non-sitewide approved sites first
            //so that a user can specify, allow all of xyz.com except for
            //xyz.com/foo.htm
            switch(iLoopCounter)
            {
                case 0:
                {
                    if ((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH)
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
                case 1:
                {
                    if (!((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH))
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            pPRPolicy=new PICSRulesPolicy;
    
            if (pPRPolicy==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
   
            pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

            pPRByURL=new PICSRulesByURL;
    
            if (pPRByURL==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }

            if (pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {                       
                pPRPolicy->m_pPRAcceptByURL=pPRByURL;
            }
            else
            {
                pPRPolicy->m_pPRRejectByURL=pPRByURL;
            }

            pPRByURLExpression=new PICSRulesByURLExpression;

            if (pPRByURLExpression==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }

            pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
            pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
            pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
            pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
            pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
            pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
            pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
            pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
            pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

    
            pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

            g_pApprovedPRRS->m_arrpPRPolicy.Append(pPRPolicy);
        }           
    }

    PICSRulesDeleteSystem(PICSRULES_APPROVEDSITES);
    PICSRulesSaveToRegistry(PICSRULES_APPROVEDSITES,&g_pApprovedPRRS);

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\picsrule.h ===
//*******************************************************************
//*
//* PICSRule.h
//*
//* Revision History:
//*     Created 7/98 - Mark Hammond (t-markh)
//*
//* Contains classes and function prototypes
//* used for processing PICSRules files.
//*
//*******************************************************************

#ifndef PICS_RULE_H
#define PICS_RULE_H

//*******************************************************************
//*
//* Function Prototypes / class declarations
//*
//*******************************************************************

//Forward class declarations
class PICSRulesQuotedURL;
class PICSRulesQuotedEmail;
class PICSRulesQuotedDate;
class PICSRulesYesNo;
class PICSRulesPassFail;
class PICSRulesPolicyExpression;
class PICSRulesByURL;
class PICSRulesPolicy;
class PICSRulesName;
class PICSRulesSource;
class PICSRulesServiceInfo;
class PICSRulesOptExtension;
class PICSRulesReqExtension;
class PICSRulesFileParser;
class PICSRulesRatingSystem;
class CParsedLabelList;

//This function is called by ApprovedSitesDlgProc while processing
//WM_COMMOND with LOWORD(wParam)==IDC_PICSRULESOPEN in msludlg.cpp
//The argument lpszFileName is the name of the PICSRules file
//selected by the user to import.
//
//This begins the PICSRules Import process.
HRESULT PICSRulesImport(char *lpszFileName, PICSRulesRatingSystem **pprrsOut);

//For reading and saving processed PICSRules from the registry
HRESULT PICSRulesSaveToRegistry(DWORD dwSystemToSave, PICSRulesRatingSystem **ppPRRS);
HRESULT PICSRulesReadFromRegistry(DWORD dwSystemToRead, PICSRulesRatingSystem **ppPRRS);
HRESULT PICSRulesDeleteSystem(DWORD dwSystemToDelete);
HRESULT PICSRulesSetNumSystems(DWORD dwNumSystems);
HRESULT PICSRulesGetNumSystems(DWORD * pdwNumSystems);
HRESULT PICSRulesCheckApprovedSitesAccess(LPCSTR lpszUrl,BOOL *fPassFail);
HRESULT PICSRulesCheckAccess(LPCSTR lpszUrl,LPCSTR lpszRatingInfo,BOOL *fPassFail,CParsedLabelList **ppParsed);
void PICSRulesOutOfMemory();

//The following are handler functions which parse the various
//kinds of content which can occur within a parenthesized object.
//
//ppszIn is always advanced to the next non-white space token
//ppszOut returns the processed data
HRESULT PICSRulesParseString(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
HRESULT PICSRulesParseNumber(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
HRESULT PICSRulesParseYesNo(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
HRESULT PICSRulesParsePassFail(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);

BOOL IsURLValid(WCHAR wcszURL[]);

//*******************************************************************
//*
//* Definitions used by the PICSRules code
//*
//*******************************************************************
#define PR_QUOTE_DOUBLE     1
#define PR_QUOTE_SINGLE     0

#define BYURL_SCHEME    1
#define BYURL_USER      2
#define BYURL_HOST      4
#define BYURL_PORT      8
#define BYURL_PATH      16

#define PICSRULES_FIRSTSYSTEMINDEX  100
#define PICSRULES_MAXSYSTEM         1000000
#define PICSRULES_APPROVEDSITES     0

#define PICSRULES_ALWAYS            1
#define PICSRULES_NEVER             0

#define PICSRULES_PAGE              1
#define PICSRULES_SITE              0

#define PICS_LABEL_FROM_HEADER      0
#define PICS_LABEL_FROM_PAGE        1
#define PICS_LABEL_FROM_BUREAU      2

struct PICSRULES_VERSION
{
    int iPICSRulesVerMajor,iPICSRulesVerMinor;
};

//Data types for the necessary logic in evaluating
//the rules.
enum PICSRulesOperators
{
    PR_OPERATOR_INVALID,
    PR_OPERATOR_GREATEROREQUAL,
    PR_OPERATOR_GREATER,
    PR_OPERATOR_EQUAL,
    PR_OPERATOR_LESSOREQUAL,
    PR_OPERATOR_LESS,
    PR_OPERATOR_DEGENERATE,
    PR_OPERATOR_SERVICEONLY,
    PR_OPERATOR_SERVICEANDCATEGORY,
    PR_OPERATOR_RESULT
};

enum PICSRulesEvaluation
{
    PR_EVALUATION_DOESAPPLY,
    PR_EVALUATION_DOESNOTAPPLY
};

//This indicates which member is valid in a PICSRulesPolicy
//Class
enum PICSRulesPolicyAttribute
{
    PR_POLICY_NONEVALID,
    PR_POLICY_REJECTBYURL,
    PR_POLICY_ACCEPTBYURL,
    PR_POLICY_REJECTIF,
    PR_POLICY_ACCEPTIF,
    PR_POLICY_REJECTUNLESS,
    PR_POLICY_ACCEPTUNLESS
};

//This indicates if a PolicyExpression is embedded in another
//PolicyExpression, and if so, what logic to use.
enum PICSRulesPolicyEmbedded
{
    PR_POLICYEMBEDDED_NONE,
    PR_POLICYEMBEDDED_OR,
    PR_POLICYEMBEDDED_AND
};

//*******************************************************************
//*
//* Classes to handle possible value types... all derive from
//* ETS (the encapsulated string type) since the are found as
//* strings during processing.
//*
//* The Set() and SetTo() member functions are overloaded on the
//* types which convert from a string.  We want to keep the original
//* string in case the data is invalid.
//*
//* Additional member functions are provided to assure that the
//* data is what it says it is, and to return the non-string type.
//*
//*******************************************************************
class PICSRulesByURLExpression
{
    public:
        PICSRulesByURLExpression();
        ~PICSRulesByURLExpression();

        BOOL    m_fInternetPattern;
        BYTE    m_bNonWild,m_bSpecified;
        ETS     m_etstrScheme,m_etstrUser,m_etstrHost,m_etstrPort,m_etstrPath,m_etstrURL;
};

class PICSRulesQuotedURL : public ETS
{
    public:
        PICSRulesQuotedURL();
        ~PICSRulesQuotedURL();

        BOOL IsURLValid();
        BOOL IsURLValid(char * lpszURL);
        BOOL IsURLValid(ETS etstrURL);
};

class PICSRulesQuotedEmail : public ETS
{
    public:
        PICSRulesQuotedEmail();
        ~PICSRulesQuotedEmail();

        BOOL IsEmailValid();
        BOOL IsEmailValid(char * lpszEmail);
        BOOL IsEmailValid(ETS etstrEmail);
};

class PICSRulesQuotedDate : public ETS
{
    public:
        PICSRulesQuotedDate();
        ~PICSRulesQuotedDate();

        BOOL IsDateValid();
        BOOL IsDateValid(char * lpszDate);
        BOOL IsDateValid(ETS etstrDate);

        HRESULT Set(const char *pIn);
        HRESULT SetTo(char *pIn);

        DWORD GetDate()
        {
            return m_dwDate;
        };

    private:
        DWORD m_dwDate;
};

class PICSRulesYesNo : public ETS
{
    public:
        PICSRulesYesNo();
        ~PICSRulesYesNo();

        void Set(const BOOL *pIn);
        void SetTo(BOOL *pIn);

        BOOL GetYesNo()
        {
            return m_fYesOrNo;
        };

    private:
        BOOL m_fYesOrNo;
};
        
class PICSRulesPassFail : public ETS
{
    public:
        PICSRulesPassFail();
        ~PICSRulesPassFail();

        void Set(const BOOL *pIn);
        void SetTo(BOOL *pIn);

        BOOL GetPassFail()
        {
            return m_fPassOrFail;
        };

    private:
        BOOL m_fPassOrFail;
};

//*******************************************************************
//*
//* The PICSRulesPolicy class handles the "Policy" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     Policy (
//*         [Explanation]   quoted
//*         RejectByURL     URL | ( [patterns]  URL )
//*         AcceptByURL     URL | ( [patterns]  URL )
//*         RejectIf        PolicyExpression
//*         RejectUnless    PolicyExpression
//*         AcceptIf        PolicyExpression
//*         AcceptUnless    PolicyExpression
//*         *Extension* )
//*
//*******************************************************************

class PICSRulesPolicyExpression
{
    public:
        PICSRulesPolicyExpression       * m_pPRPolicyExpressionLeft,
                                        * m_pPRPolicyExpressionRight;
        ETS                             m_etstrServiceName,m_etstrCategoryName,
                                        m_etstrFullServiceName;
        ETN                             m_etnValue;
        PICSRulesYesNo                  m_prYesNoUseEmbedded;
        enum PICSRulesOperators         m_PROPolicyOperator;
        enum PICSRulesPolicyEmbedded    m_PRPEPolicyEmbedded;

        PICSRulesPolicyExpression();
        ~PICSRulesPolicyExpression();

        PICSRulesEvaluation EvaluateRule(CParsedLabelList *pParsed);
};

class PICSRulesByURL
{
    public:
        array<PICSRulesByURLExpression*> m_arrpPRByURL;

        PICSRulesByURL();
        ~PICSRulesByURL();

        PICSRulesEvaluation EvaluateRule(PICSRulesQuotedURL *pprurlComparisonURL);
};

class PICSRulesPolicy : public PICSRulesObjectBase
{
    public:
        ETS                                 m_etstrExplanation;
        PICSRulesPolicyExpression           * m_pPRRejectIf,* m_pPRRejectUnless,
                                            * m_pPRAcceptIf,* m_pPRAcceptUnless;
        PICSRulesByURL                      * m_pPRRejectByURL,* m_pPRAcceptByURL;
        PICSRulesPolicyAttribute            m_PRPolicyAttribute;
        
        PICSRulesPolicy();
        ~PICSRulesPolicy();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesName class handles the "name" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     name (
//*         [Rulename]  quoted
//*         Description quoted
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesName : public PICSRulesObjectBase
{
    public:
        ETS m_etstrRuleName,m_etstrDescription;

        PICSRulesName();
        ~PICSRulesName();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesSource class handles the "source" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     source (
//*         [SourceURL]     URL
//*         CreationTool    quoted (has format toolname/version)
//*         author          email
//*         LastModified    ISO Date
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesSource : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLSourceURL;
        ETS                     m_etstrCreationTool;
        PICSRulesQuotedEmail    m_prEmailAuthor;
        PICSRulesQuotedDate     m_prDateLastModified;
        
        PICSRulesSource();
        ~PICSRulesSource();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();

        char * GetToolName();
};

//*******************************************************************
//*
//* The PICSRulesServiceInfo class handles the "serviceinfo" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//* The Ratfile attribute is either an entire machine readable .RAT
//* file, or the URL where the .RAT file can be obtained.
//*
//*     serviceinfo (
//*         [Name]              URL
//*         shortname           quoted
//*         BureauURL           URL
//*         UseEmbedded         Y|N
//*         Ratfile             quoted
//*         BureauUnavailable   PASS|FAIL
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesServiceInfo : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLName,m_prURLBureauURL;
        ETS                     m_etstrShortName,m_etstrRatfile;
        PICSRulesYesNo          m_prYesNoUseEmbedded;
        PICSRulesPassFail       m_prPassFailBureauUnavailable;

        PICSRulesServiceInfo();
        ~PICSRulesServiceInfo();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesOptExtension class handles the "optextension" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     optextension (
//*         [extension-name]    URL
//*         shortname           quoted
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesOptExtension : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLExtensionName;
        ETS                     m_etstrShortName;

        PICSRulesOptExtension();
        ~PICSRulesOptExtension();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesReqExtension class handles the "reqextension" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     reqextension (
//*         [extension-name]    URL
//*         shortname           quoted
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesReqExtension : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLExtensionName;
        ETS                     m_etstrShortName;

        PICSRulesReqExtension();
        ~PICSRulesReqExtension();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesRatingSystem class encapsulates all of the
//* information from a give PICSRules source.  Multiple
//* instantiations are created in the PicsRatingSystemInfo class,
//* created at startup and stored in gPRSI.
//*
//*******************************************************************
class PICSRulesRatingSystem : public PICSRulesObjectBase
{
    public:
        array<PICSRulesPolicy*>         m_arrpPRPolicy;
        array<PICSRulesServiceInfo*>    m_arrpPRServiceInfo;
        array<PICSRulesOptExtension*>   m_arrpPROptExtension;
        array<PICSRulesReqExtension*>   m_arrpPRReqExtension;
        PICSRulesName                   * m_pPRName;
        PICSRulesSource                 * m_pPRSource;
        ETS                             m_etstrFile;
        ETN                             m_etnPRVerMajor,m_etnPRVerMinor;
        DWORD                           m_dwFlags;
        UINT                            m_nErrLine;

        PICSRulesRatingSystem();
        ~PICSRulesRatingSystem();
        HRESULT Parse(LPCSTR pszFile, LPSTR pStreamIn);

        HRESULT AddItem(PICSRulesObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults();
        void ReportError(HRESULT hres);
};

//*******************************************************************
//*
//* The PICSRulesFileParser class exists to provide a line number
//* shared by all the parsing routines.  This line number is updated
//* as the parser walks through the stream, and is frozen as soon as
//* an error is found.  This line number can later be reported to the
//* user to help localize errors.
//*
//*******************************************************************
class PICSRulesFileParser
{
public:
    UINT m_nLine;

    PICSRulesFileParser() { m_nLine = 1; }

    LPSTR EatQuotedString(LPSTR pIn,BOOL fQuote=PR_QUOTE_DOUBLE);
    HRESULT ParseToOpening(LPSTR *ppIn, PICSRulesAllowableOption  *paoExpected,
                           PICSRulesAllowableOption  **ppFound);
    HRESULT ParseParenthesizedObject(
        LPSTR *ppIn,                    //where we are in the text stream
        PICSRulesAllowableOption aao[], //allowable things inside this object
        PICSRulesObjectBase *pObject    //object to set parameters into
    );
    char* FindNonWhite(char *pc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\ratguid.h ===
// 20EDB660-7CDD-11CF-8DAB-00AA006C1A01
extern const GUID CLSID_RemoteSite;

// 19427BA0-826C-11CF-8DAB-00AA006C1A01
extern const GUID IID_IObtainRating;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\pleasdlg.h ===
/****************************************************************************\
 *
 *   pleasdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Access Denied Dialog
 *
\****************************************************************************/

#ifndef PLEASE_DIALOG_H
#define PLEASE_DIALOG_H

#include "basedlg.h"        // CBaseDialog

const UINT MAX_CACHED_LABELS = 16;
const UINT WM_NEWDIALOG = WM_USER + 1000;

const DWORD PDD_DONE = 0x1;
const DWORD PDD_ALLOW = 0x2;

// $BUG - This should be placed in pleasdlg.cpp.
const char szRatingsProp[] = "RatingsDialogHandleProp";
const char szRatingsValue[] = "RatingsDialogHandleValue";

struct PleaseDlgData
{
    LPCSTR pszUsername;
    LPCSTR pszContentDescription;
    PicsUser *pPU;
    CParsedLabelList *pLabelList;
    HWND hwndDlg;
    HWND hwndOwner;
    DWORD dwFlags;
    HWND hwndEC;
    UINT cLabels;
    LPSTR apLabelStrings[MAX_CACHED_LABELS];
};

class CPleaseDialog: public CBaseDialog<CPleaseDialog>
{
private:
    static DWORD aIds[];
    static DWORD aPleaseIds[];
    PleaseDlgData * m_ppdd;

public:
    enum { IDD = IDD_PLEASE };

public:
    CPleaseDialog( PleaseDlgData * p_ppdd );

public:
    typedef CPleaseDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOK)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        MESSAGE_HANDLER(WM_NEWDIALOG, OnNewDialog)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNewDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    AppendString(HWND hwndEC, LPCSTR pszString);
    void    AddSeparator(HWND hwndEC, BOOL fAppendToEnd);
    void    InitPleaseDialog( PleaseDlgData * pdd );
    void    EndPleaseDialog( BOOL fRet);
    HRESULT AddToApprovedSites( BOOL fAlwaysNever, BOOL fSitePage );

protected:
    BOOL    IsPleaseDialog( void )      { ASSERT( m_ppdd ); return ( m_ppdd ? m_ppdd->pPU->fPleaseMom : TRUE ); }
    BOOL    IsDenyDialog( void )        { return ! IsPleaseDialog(); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\picsuser.cpp ===
/****************************************************************************\
 *
 *   PICSUSER.C -- Structure for holding user information
 *
 *     Created:      02/29/96 gregj
 *                from original sources by t-jasont
 *     
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "debug.h"

BOOL GetRegBool(HKEY hKey, LPCSTR pszValueName, BOOL fDefault)
{
    BOOL fRet = fDefault;
    DWORD dwSize, dwValue, dwType;
    UINT uErr;

    dwSize = sizeof(dwValue);

    uErr = RegQueryValueEx(hKey, pszValueName, NULL, &dwType, 
                            (LPBYTE)&dwValue, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
        if ((dwType == REG_DWORD) || (dwType == REG_BINARY && dwSize >= sizeof(fRet)))
            fRet = dwValue;
    }

    return fRet;
}


void SetRegBool(HKEY hkey, LPCSTR pszValueName, BOOL fValue)
{
    RegSetValueEx(hkey, pszValueName, 0, REG_DWORD, (LPBYTE)&fValue, sizeof(fValue));
}


PicsRatingSystem *FindInstalledRatingSystem(LPCSTR pszRatingService)
{
    UINT cServices = gPRSI->arrpPRS.Length();

    for (UINT i=0; i<cServices; i++) {
        PicsRatingSystem *pPRS = gPRSI->arrpPRS[i];
        if (!(pPRS->dwFlags & PRS_ISVALID) || !pPRS->etstrRatingService.fIsInit())
            continue;
        if (!::strcmpf(pPRS->etstrRatingService.Get(), pszRatingService))
            return pPRS;
    }
    return NULL;
}


PicsCategory *FindInstalledCategory(array<PicsCategory *>&arrpPC, LPCSTR pszName)
{
    UINT cCategories = arrpPC.Length();

    for (UINT i=0; i<cCategories; i++) {
        LPSTR pszThisName = arrpPC[i]->etstrTransmitAs.Get();
        if (!::strcmpf(pszThisName, pszName))
            return arrpPC[i];
        if (!::strncmpf(pszThisName, pszName, strlenf(pszThisName)) &&
            arrpPC[i]->arrpPC.Length() > 0) {
            PicsCategory *pCategory = FindInstalledCategory(arrpPC[i]->arrpPC, pszName);
            if (pCategory != NULL)
                return pCategory;
        }
    }
    return NULL;
}


UserRating::UserRating()
    : NLS_STR(NULL),
      m_nValue(0),
      m_pNext(NULL),
      m_pPC(NULL)
{
}


UserRating::UserRating(UserRating *pCopyFrom)
    : NLS_STR(*pCopyFrom),
      m_nValue(pCopyFrom->m_nValue),
      m_pNext(NULL),
      m_pPC(pCopyFrom->m_pPC)
{
}


UserRating::~UserRating()
{
    // needed to destruct name string
}


UserRating *UserRating::Duplicate(void)
{
    UserRating *pNew = new UserRating(this);
    return pNew;
}


UserRatingSystem::UserRatingSystem()
    : NLS_STR(NULL),
      m_pRatingList(NULL),
      m_pNext(NULL),
      m_pPRS(NULL)
{

}


UserRatingSystem::UserRatingSystem(UserRatingSystem *pCopyFrom)
    : NLS_STR(*pCopyFrom),
      m_pRatingList(NULL),
      m_pNext(NULL),
      m_pPRS(pCopyFrom->m_pPRS)
{

}


UserRatingSystem *UserRatingSystem::Duplicate(void)
{
    UserRatingSystem *pNew = new UserRatingSystem(this);
    if (pNew != NULL) {
        UserRating *pRating;

        for (pRating = m_pRatingList; pRating != NULL; pRating = pRating->m_pNext) {
            UserRating *pNewRating = pRating->Duplicate();
            if (pNewRating != NULL) {
                if (pNew->AddRating(pNewRating) != ERROR_SUCCESS) {
                    delete pNewRating;
                    pNewRating = NULL;
                }
            }

            if (pNewRating == NULL)
                break;
        }
    }

    return pNew;
}


UserRatingSystem *DuplicateRatingSystemList(UserRatingSystem *pOld)
{
    UserRatingSystem *pNewList = NULL;

    while (pOld != NULL) {
        UserRatingSystem *pNewEntry = pOld->Duplicate();
        if (pNewEntry == NULL)
            break;

        pNewEntry->m_pNext = pNewList;
        pNewList = pNewEntry;

        pOld = pOld->m_pNext;
    }

    return pNewList;
}


UserRatingSystem::~UserRatingSystem()
{
    UserRating *pRating, *pNext;

    for (pRating = m_pRatingList; pRating != NULL; )
    {
        pNext = pRating->m_pNext;
        delete pRating;
        pRating = pNext;
    }

#ifdef DEBUG
    m_pRatingList = NULL;
#endif
}


UserRating *UserRatingSystem::FindRating(LPCSTR pszTransmitName)
{
    UserRating *p;

    for (p = m_pRatingList; p != NULL; p = p->m_pNext)
    {
        if (!::stricmpf(p->QueryPch(), pszTransmitName))
            break;
    }

    return p;
}


UINT UserRatingSystem::AddRating(UserRating *pRating)
{
    pRating->m_pNext = m_pRatingList;
    m_pRatingList = pRating;
    return ERROR_SUCCESS;
}


UINT UserRatingSystem::ReadFromRegistry(HKEY hkeyProvider)
{
    UINT err;
    DWORD iValue = 0;
    char szValueName[MAXPATHLEN];
    DWORD cchValue;
    DWORD dwValue;
    DWORD cbData;

    do {
        cchValue = sizeof(szValueName);
        cbData = sizeof(dwValue);
        err = RegEnumValue(hkeyProvider, iValue, szValueName, &cchValue,
                           NULL, NULL, (LPBYTE)&dwValue, &cbData);
        if (err == ERROR_SUCCESS && cbData >= sizeof(dwValue)) {
            UserRating *pRating = new UserRating;
            if (pRating != NULL) {
                if (pRating->QueryError()) {
                    err = pRating->QueryError();
                }
                else {
                    pRating->SetName(szValueName);
                    pRating->m_nValue = (INT)dwValue;
                    if (m_pPRS != NULL)
                        pRating->m_pPC = FindInstalledCategory(m_pPRS->arrpPC, szValueName);
                    err = AddRating(pRating);
                }
                if (err != ERROR_SUCCESS)
                {
                    delete pRating;
                    pRating = NULL;
                }
            }
            else
                err = ERROR_NOT_ENOUGH_MEMORY;
        }
        iValue++;
    } while (err == ERROR_SUCCESS);

    if (err == ERROR_NO_MORE_ITEMS)
        err = ERROR_SUCCESS;

    return err;
}


UINT UserRatingSystem::WriteToRegistry(HKEY hkeyRatings)
{
    UserRating *pRating;
    UINT err = ERROR_SUCCESS;
    CRegKey         key;

    err = key.Create( hkeyRatings, QueryPch() );
    if (err != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "UserRatingSystem::WriteToRegistry() - Failed to create Ratings Key QueryPch()='%s'!", QueryPch() );
        return err;
    }

    for (pRating = m_pRatingList; pRating != NULL; pRating = pRating->m_pNext)
    {
        err = key.SetValue( pRating->m_nValue, pRating->QueryPch() );
        if (err != ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "UserRatingSystem::WriteToRegistry() - Failed to set Ratings Value pRating->QueryPch()='%s'!", pRating->QueryPch() );
            break;
        }
    }

    return err;
}


PicsUser::PicsUser()
    : nlsUsername(NULL),
      fAllowUnknowns(FALSE),
      fPleaseMom(TRUE),
      fEnabled(TRUE),
      m_pRatingSystems(NULL)
{
}


PicsRatingSystemInfo::~PicsRatingSystemInfo()
{
    arrpPRS.DeleteAll();

    if ( pUserObject )
    {
        delete pUserObject;
        pUserObject = NULL;
    }
}


void DestroyRatingSystemList(UserRatingSystem *pList)
{
    UserRatingSystem *pSystem, *pNext;

    for (pSystem = pList; pSystem != NULL; )
    {
        pNext = pSystem->m_pNext;
        delete pSystem;
        pSystem = pNext;
    }
}


PicsUser::~PicsUser()
{
    DestroyRatingSystemList(m_pRatingSystems);
#ifdef DEBUG
    m_pRatingSystems = NULL;
#endif
}


UserRatingSystem *FindRatingSystem(UserRatingSystem *pList, LPCSTR pszSystemName)
{
    UserRatingSystem *p;

    for (p = pList; p != NULL; p = p->m_pNext)
    {
        if (!::strcmpf(p->QueryPch(), pszSystemName))
            break;
    }

    return p;
}


UINT PicsUser::AddRatingSystem(UserRatingSystem *pRatingSystem)
{
    pRatingSystem->m_pNext = m_pRatingSystems;
    m_pRatingSystems = pRatingSystem;
    return ERROR_SUCCESS;
}


UINT PicsUser::ReadFromRegistry(HKEY hkey, char *pszUserName)
{
    CRegKey             keyUser;

    nlsUsername = pszUserName;

    UINT err = keyUser.Open( hkey, pszUserName, KEY_READ );
    if (err != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "PicsUser::ReadFromRegistry() - Failed keyUser Open to pszUserName='%s'!", pszUserName );
        return err;
    }

    fAllowUnknowns = GetRegBool( keyUser.m_hKey, VAL_UNKNOWNS, FALSE);
    fPleaseMom = GetRegBool( keyUser.m_hKey, VAL_PLEASEMOM, TRUE);
    fEnabled = GetRegBool( keyUser.m_hKey, VAL_ENABLED, TRUE);

    {
        char szKeyName[MAXPATHLEN];
        int j = 0;
        // enumerate the subkeys, which are rating systems
        while ( ( err = RegEnumKey( keyUser.m_hKey, j, szKeyName, sizeof(szKeyName) ) ) == ERROR_SUCCESS )
        {
            CRegKey             keyProvider;

            if ( ( err = keyProvider.Open( keyUser.m_hKey, szKeyName, KEY_READ ) != ERROR_SUCCESS ) )
            {
                TraceMsg( TF_WARNING, "PicsUser::ReadFromRegistry() - Failed keyProvider Open to szKeyName='%s'!", szKeyName );
                break;
            }

            UserRatingSystem *pRatingSystem = new UserRatingSystem;
            if (pRatingSystem == NULL)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (pRatingSystem->QueryError())
            {
                err = pRatingSystem->QueryError();
            }
            else
            {
                pRatingSystem->SetName(szKeyName);
                pRatingSystem->m_pPRS = FindInstalledRatingSystem(szKeyName);
                err = pRatingSystem->ReadFromRegistry( keyProvider.m_hKey );
                if (err == ERROR_SUCCESS)
                {
                    err = AddRatingSystem(pRatingSystem);
                }
            }

            if (err != ERROR_SUCCESS)
            {
                delete pRatingSystem;
                pRatingSystem = NULL;
            }

            j++;
        }
    }

    // end of enum will report ERROR_NO_MORE_ITEMS, don't report this as error
    if (err == ERROR_NO_MORE_ITEMS)
    {
        err = ERROR_SUCCESS;
    }

    return err;
}

BOOL PicsUser::NewInstall()
{
    nlsUsername = szDefaultUserName;
    fAllowUnknowns = FALSE;
    fPleaseMom = TRUE;
    fEnabled = TRUE;
    
    return TRUE;
}


UINT PicsUser::WriteToRegistry(HKEY hkey)
{
    UINT err;

    //Delete it to clean out registry
    MyRegDeleteKey(hkey, nlsUsername.QueryPch());

    CRegKey             keyUser;

    err = keyUser.Create( hkey, nlsUsername.QueryPch() );
    if (err != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "PicsUser::WriteToRegistry() - Failed to Create User Key nlsUsername='%s'!", nlsUsername.QueryPch() );
        return err;
    }

    SetRegBool( keyUser.m_hKey, VAL_UNKNOWNS, fAllowUnknowns);
    SetRegBool( keyUser.m_hKey, VAL_PLEASEMOM, fPleaseMom);
    SetRegBool( keyUser.m_hKey, VAL_ENABLED, fEnabled);

    {
        UserRatingSystem *pSystem;

        /* Note, if any user settings correspond to invalid or unknown
         * rating systems, we still save them here.  That way, the user
         * settings don't get lost if the supervisor later fixes a problem
         * with a .RAT file.
         *
         * We clean up user settings to match the installed rating systems
         * in the add/remove rating systems dialog code.
         */
        for (pSystem = m_pRatingSystems; pSystem != NULL; pSystem = pSystem->m_pNext)
        {
            err = pSystem->WriteToRegistry( keyUser.m_hKey );
            if (err != ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "PicsUser::WriteToRegistry() - Failed pSystem->WriteToRegistry()!" );
                break;
            }
        }
    }

    return err;
}


PicsUser *GetUserObject(LPCSTR pszUsername /* = NULL */ )
{
    ASSERT( gPRSI );

    return gPRSI ? gPRSI->pUserObject : NULL;
}


void DeleteUserSettings(PicsRatingSystem *pPRS)
{
    if (!pPRS->etstrRatingService.fIsInit())
        return;        /* can't recognize user settings without this */

    PicsUser *pPU = GetUserObject();

    UserRatingSystem **ppLast = &pPU->m_pRatingSystems;

    while (*ppLast != NULL)
    {
        if (!stricmpf((*ppLast)->QueryPch(), pPRS->etstrRatingService.Get()))
        {
            UserRatingSystem *pCurrent = *ppLast;
            *ppLast = pCurrent->m_pNext;    /* remove from list */
            delete pCurrent;
            pCurrent = NULL;
            break;
        }
        else
        {
            ppLast = &((*ppLast)->m_pNext);
        }
    }
}


void CheckUserCategory(UserRatingSystem *pURS, PicsCategory *pPC)
{
    for (UserRating *pRating = pURS->m_pRatingList;
         pRating != NULL;
         pRating = pRating->m_pNext)
    {
        if (!::strcmpf(pRating->QueryPch(), pPC->etstrTransmitAs.Get()))
            break;
    }

    if (pRating == NULL) {
        /* User setting not found for this category.  Add one. */

        pRating = new UserRating;
        if (pRating != NULL) {
            pRating->SetName(pPC->etstrTransmitAs.Get());
            pRating->m_pPC = pPC;
            pRating->m_pNext = pURS->m_pRatingList;
            pURS->m_pRatingList = pRating;
            if ((pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get()) ||
                !pPC->etnMin.fIsInit())
                pRating->m_nValue = 0;
            else
                pRating->m_nValue = pPC->etnMin.Get();
        }
    }

    /* Check all subcategories in this category as well.
     */
    UINT cCategories = pPC->arrpPC.Length();
    for (UINT i=0; i<cCategories; i++)
        CheckUserCategory(pURS, pPC->arrpPC[i]);
}


void CheckUserSettings(PicsRatingSystem *pPRS)
{
    if (pPRS == NULL || !(pPRS->dwFlags & PRS_ISVALID) ||
        !pPRS->etstrRatingService.fIsInit())
        return;

    PicsUser *pPU = GetUserObject();

    UserRatingSystem **ppLast = &pPU->m_pRatingSystems;

    while (*ppLast != NULL) {
        if (!stricmpf((*ppLast)->QueryPch(), pPRS->etstrRatingService.Get())) {
            break;
        }
        ppLast = &((*ppLast)->m_pNext);
    }

    if (*ppLast == NULL) {
        *ppLast = new UserRatingSystem;
        if (*ppLast == NULL)
            return;
        (*ppLast)->SetName(pPRS->etstrRatingService.Get());
    }

    UserRatingSystem *pCurrent = *ppLast;

    pCurrent->m_pPRS = pPRS;

    /* First go through all the settings for the user and make sure the
     * categories are valid.  If not, delete them.
     */
    UserRating **ppRating = &pCurrent->m_pRatingList;
    while (*ppRating != NULL)
    {
        UserRating *pRating = *ppRating;
        pRating->m_pPC = FindInstalledCategory(pPRS->arrpPC, pRating->QueryPch());
        if (pRating->m_pPC == NULL)
        {
            *ppRating = pRating->m_pNext;        /* remove from list */
            delete pRating;
            pRating = NULL;
        }
        else
        {
            ppRating = &pRating->m_pNext;
        }
    }

    /* Now go through all the categories in the rating system and make
     * sure the user has settings for them.  If any are missing, add
     * settings for the default values (minimums).
     */
    UINT cCategories = pPRS->arrpPC.Length();
    for (UINT i=0; i<cCategories; i++)
        CheckUserCategory(pCurrent, pPRS->arrpPC[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\picsrule.cpp ===
//*******************************************************************
//*
//* PICSRule.cpp
//*
//* Revision History:
//*     Created 7/98 - Mark Hammond (t-markh)
//*
//* Implements PICSRules parsing, decision making,
//* exporting, and editing.
//*
//*******************************************************************

//*******************************************************************
//*
//* A brief rundown on PICSRules files:
//*    (The official spec is at: http://www.w3.org/TR/REC-PICSRules)
//*
//* PICSRules files have MIME type: application/pics-rules and
//* consist of a sequence of parenthesis encapsulated attribute
//* value pairs.  Values consist of quoted strings or parenthesized
//* lists of further attribute value pairs.  Every subsection of a
//* PICSRules file has a primary attribute (denoted in the outline
//* below by square brackets); if any value is not paired with an
//* attribute, it is assigned to the primary attribute.
//*
//* Whitespace consists of the characters ' ', '\t', '\r', and '\n'
//* and is ignored except between attribute value pairs.
//*
//* Quoted strings can be encapsulated in either single ticks ('')
//* or double ticks (""), but may not use mixed notation ('" or "').
//*
//* The following escape sequences are observed in the quoted strings:
//*     " = %22
//*     ' = %27
//*     % = %25
//* Any other escape sequence is invalid.
//*
//* Both attributes and values are case sensitive.
//*
//* Curly brackets denote comments.
//*
//* --- Code Requirements ---
//*
//* The rule evaluator needs to return yes (accept) or no (reject)
//* AS WELL AS the policy clause that determined the answer.
//*
//* The rule evaluator stops when it hits the first policy clause
//* which is applicable.
//*
//* If no clause is satisfied, the default clause is:
//* AcceptIf "otherwise".  In this implementation, if no clause is
//* satisfied, evaluation is passed to our non-PICSRule evaluator.
//*
//* PICSRules 1.1 does NOT support Internationalization of the name
//* section (i.e. each language needs its own PICSRules file).
//* The AddItem function of the PICSRulesName class can easily be
//* extended if this behavior changes in a future revision of the
//* PICSRules spec.
//*
//* The Ratfile attribute is either an entire machine readable .RAT
//* file, or the URL where the .RAT file can be obtained.
//*
//* --- Attribute Value specifications ---
//*
//*
//* The main body of a PICSRules has the form:
//*
//* (PicsRule-%verMajor%.%verMinor%
//*     (
//*         Attribute Value
//*         ...
//*         Tag (
//*                 Attribute Value
//*                 ...
//*         )
//*     )
//* )
//*
//* The current %verMajor% is 1
//* The current %verMinor% is 1
//*
//* Possible Tags and their Attribute Value pairs are:
//*
//* Policy (
//*     [Explanation]       quoted
//*     RejectByURL         URL | ( [patterns]  URL )
//*     AcceptByURL         URL | ( [patterns]  URL )
//*     RejectIf            PolicyExpression
//*     RejectUnless        PolicyExpression
//*     AcceptIf            PolicyExpression
//*     AcceptUnless        PolicyExpression
//*     *Extension* )
//*
//* name (
//*     [Rulename]          quoted
//*     Description         quoted
//*     *Extension* )
//*
//* source (
//*     [SourceURL]         URL
//*     CreationTool        quoted (has format application/version)
//*     author              email
//*     LastModified        ISO Date
//*     *Extension* )
//*
//* serviceinfo (
//*     [Name]              URL
//*     shortname           quoted
//*     BureauURL           URL
//*     UseEmbedded         Y|N
//*     Ratfile             quoted
//*     BureauUnavailable   PASS|FAIL
//*     *Extension* )
//*
//* optextension (
//*     [extension-name]    URL
//*         shortname       quoted
//*         *Extension* )
//*
//* reqextension (
//*     [extension-name]    URL
//*         shortname       quoted
//*         *Extension* )
//*
//* *Extension*
//*
//* Further comments are given below
//*
//*******************************************************************


//*******************************************************************
//*
//* #Includes
//*
//*******************************************************************
#include "msrating.h"
#include "mslubase.h"
#include "debug.h"
#include "parselbl.h"       /* we use a couple of this guy's subroutines */
#include "msluglob.h"
#include "reghive.h"        // CRegistryHive
#include "buffer.h"
#include "resource.h"
#include <wininet.h>
#include "picsrule.h"

#include <mluisupp.h>
#include <winsock2.h>
#include <shlwapip.h>

//*******************************************************************
//*
//* Globals
//*
//*******************************************************************
array<PICSRulesRatingSystem*>   g_arrpPRRS;         //this is the array of PICSRules systems
                                                    //which are inforced while ie is running
PICSRulesRatingSystem *         g_pApprovedPRRS;    //this is the Approved Sites PICSRules
                                                    //system
PICSRulesRatingSystem *         g_pPRRS=NULL;       //this is a temporary pointer used while
                                                    //parsing a PICSRules file
HMODULE                         g_hURLMON,g_hWININET;

BOOL                            g_fPICSRulesEnforced,g_fApprovedSitesEnforced;

char                            g_szLastURL[INTERNET_MAX_URL_LENGTH];

extern DWORD                    g_dwDataSource;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

//*******************************************************************
//*
//* Function Prototypes
//*
//*******************************************************************
HRESULT PICSRulesParseSubPolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser);
HRESULT PICSRulesParseSimplePolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser);
BOOL IsServiceDefined(LPSTR lpszService,LPSTR lpszFullService,PICSRulesServiceInfo **ppServiceInfo);
BOOL IsOptExtensionDefined(LPSTR lpszExtension);
BOOL IsReqExtensionDefined(LPSTR lpszExtension);
HRESULT PICSRulesParseSingleByURL(LPSTR lpszByURL, PICSRulesByURLExpression *pPRByURLExpression, PICSRulesFileParser *pParser);

//*******************************************************************
//*
//* Some definitions specific to this file
//*
//*******************************************************************
PICSRulesAllowableOption aaoPICSRules[] = {
    { PROID_PICSVERSION, 0 },
    
    { PROID_POLICY, AO_MANDATORY },
        { PROID_EXPLANATION, AO_SINGLE },
        { PROID_REJECTBYURL, AO_SINGLE },
        { PROID_ACCEPTBYURL, AO_SINGLE },
        { PROID_REJECTIF, AO_SINGLE },
        { PROID_ACCEPTIF, AO_SINGLE },
        { PROID_ACCEPTUNLESS, AO_SINGLE },
        { PROID_REJECTUNLESS, AO_SINGLE },
    { PROID_NAME, AO_SINGLE },
        { PROID_RULENAME, 0 },
        { PROID_DESCRIPTION, 0 },
    { PROID_SOURCE, AO_SINGLE },
        { PROID_SOURCEURL, 0 },
        { PROID_CREATIONTOOL, 0 },
        { PROID_AUTHOR, 0 },
        { PROID_LASTMODIFIED, 0 },
    { PROID_SERVICEINFO, 0 },
        { PROID_SINAME, AO_SINGLE },
        { PROID_SHORTNAME, AO_SINGLE },
        { PROID_BUREAUURL, 0 },
        { PROID_USEEMBEDDED, AO_SINGLE },
        { PROID_RATFILE, AO_SINGLE },
        { PROID_BUREAUUNAVAILABLE, AO_SINGLE },
    { PROID_OPTEXTENSION, 0 },
        { PROID_EXTENSIONNAME, AO_SINGLE },
      //{ PROID_SHORTNAME, AO_SINGLE },
    { PROID_REQEXTENSION, 0 },
      //{ PROID_EXTENSIONNAME, AO_SINGLE },
      //{ PROID_SHORTNAME, AO_SINGLE },
    { PROID_EXTENSION, 0 },

    { PROID_POLICYDEFAULT, AO_SINGLE },
    { PROID_NAMEDEFAULT, AO_SINGLE },
    { PROID_SOURCEDEFAULT, AO_SINGLE },
    { PROID_SERVICEINFODEFAULT, AO_SINGLE },
    { PROID_OPTEXTENSIONDEFAULT, AO_SINGLE },
    { PROID_REQEXTENSIONDEFAULT, AO_SINGLE },

    { PROID_INVALID, 0 }
};
const UINT caoPICSRules=sizeof(aaoPICSRules)/sizeof(aaoPICSRules[0]);

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

//The FN_ISVALIDURL type describes the URLMON function IsValidURL
//and is called by the three IsURLValid methods of PICSRulesQuotedURL
typedef HRESULT (*FN_ISVALIDURL)(LPBC pBC,LPCWSTR szURL,DWORD dwReserved);

//*******************************************************************
//*
//* This function is called by AdvancedDlgProc while processing
//* WM_COMMOND with LOWORD(wParam)==IDC_PICSRULESOPEN in msludlg.cpp
//* The argument lpszFileName is the name of the PICSRules file
//* selected by the user to import.
//*
//* This begins the PICSRules Import process.
//*
//*******************************************************************
HRESULT PICSRulesImport(char *lpszFileName, PICSRulesRatingSystem **pprrsOut)
{
    PICSRulesRatingSystem *pPRRS=new PICSRulesRatingSystem;

    *pprrsOut=pPRRS;
    
    if(pPRRS==NULL)
    {
        return E_OUTOFMEMORY;
    }

    UINT cbFilename=strlenf(lpszFileName)+1+1;      //room for marker character
    LPSTR lpszNameCopy=new char[cbFilename];
    
    if(lpszNameCopy==NULL)
    {
        return E_OUTOFMEMORY;
    }

    strcpyf(lpszNameCopy,lpszFileName);
    pPRRS->m_etstrFile.SetTo(lpszNameCopy);

    HRESULT hRes;

    HANDLE hFile=CreateFile(lpszNameCopy,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,NULL);

    if(hFile!=INVALID_HANDLE_VALUE)
    {
        DWORD cbFile=::GetFileSize(hFile,NULL);

        BUFFER bufData(cbFile+1);

        if(bufData.QueryPtr()!=NULL)
        {
            LPSTR lpszData=(LPSTR)bufData.QueryPtr();
            DWORD cbRead;

            if(ReadFile(hFile,lpszData,cbFile,&cbRead,NULL))
            {
                lpszData[cbRead]='\0';              //null terminate whole file

                g_pPRRS=pPRRS;                      //make data available to
                                                    //parsing functions during
                                                    //parsing

                hRes=pPRRS->Parse(lpszFileName,lpszData);

                if(SUCCEEDED(hRes))
                {
                    pPRRS->m_dwFlags|=PRRS_ISVALID;
                }
                else
                {
                    g_pPRRS=NULL;
                }
            }
            else
            {
                hRes=HRESULT_FROM_WIN32(::GetLastError());
            }
            
        }
        else
        {
            hRes=E_OUTOFMEMORY;
        }

        CloseHandle(hFile);
    }
    else
    {
        hRes=HRESULT_FROM_WIN32(::GetLastError());
    }

    if(!(pPRRS->m_dwFlags&PRS_ISVALID))
    {
        //file is invalid
    }

    return hRes;
}

/* White returns a pointer to the first whitespace character starting at pc.*/
extern char* White(char *);

/* NonWhite returns a pointer to the first non-whitespace character starting at pc.*/
extern char* NonWhite(char *);

//*******************************************************************
//*
//* The following are handler functions which parse the various
//* kinds of content which can occur within a parenthesized object.
//*
//* ppszIn is always advanced to the next non-white space token
//* ppszOut returns the processed data
//*
//*******************************************************************

//The following escape sequences are observed:
//  "   =%22
//  '   =%27
//  %   =%25
//any other escape sequence is invalid
HRESULT PICSRulesParseString(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    BOOL fQuote;
    LPSTR lpszEscapeSequence,lpszNewEnd;

    *ppOut=NULL;
    
    LPSTR pszCurrent=*ppszIn;

    if(*pszCurrent=='\"')
    {
        fQuote=PR_QUOTE_DOUBLE;
    }
    else if(*pszCurrent=='\'')
    {
        fQuote=PR_QUOTE_SINGLE;
    }
    else
    {
        return(PICSRULES_E_EXPECTEDSTRING);
    }

    pszCurrent++;

    LPSTR pszEnd=pParser->EatQuotedString(pszCurrent,fQuote);
    
    if(pszEnd==NULL)
    {
        return(PICSRULES_E_EXPECTEDSTRING);
    }

    lpszNewEnd=pszEnd;

    do
    {
        lpszEscapeSequence=strstrf(pszCurrent,"%22");

        if(lpszEscapeSequence>lpszNewEnd)
        {
            lpszEscapeSequence=NULL;
        }

        if(lpszEscapeSequence!=NULL)
        {
            *lpszEscapeSequence='\"';

            memcpyf(lpszEscapeSequence+1,lpszEscapeSequence+3,(int)(lpszNewEnd-lpszEscapeSequence-3));

            lpszNewEnd-=2;
        }

    } while(lpszEscapeSequence!=NULL);

    do
    {
        lpszEscapeSequence=strstrf(pszCurrent,"%27");

        if(lpszEscapeSequence>lpszNewEnd)
        {
            lpszEscapeSequence=NULL;
        }

        if(lpszEscapeSequence!=NULL)
        {
            *lpszEscapeSequence='\'';

            memcpyf(lpszEscapeSequence+1,lpszEscapeSequence+3,(int)(lpszNewEnd-lpszEscapeSequence-3));

            lpszNewEnd-=2;
        }

    } while(lpszEscapeSequence!=NULL);

    do
    {
        lpszEscapeSequence=strstrf(pszCurrent,"%25");

        if(lpszEscapeSequence>lpszNewEnd)
        {
            lpszEscapeSequence=NULL;
        }

        if(lpszEscapeSequence!=NULL)
        {
            *lpszEscapeSequence='%';

            memcpyf(lpszEscapeSequence+1,lpszEscapeSequence+3,(int)(lpszNewEnd-lpszEscapeSequence-3));

            lpszNewEnd-=2;
        }

    } while(lpszEscapeSequence!=NULL);

    UINT cbString= (unsigned int) (lpszNewEnd-pszCurrent);
    LPSTR pszNew = new char[cbString + 1];  //This memory gets assigned to an ET derived
                                            //type via the AddItem call for the class handling
                                            //the parenthesized object.  The memory is
                                            //deallocated when the handling class, and hence
                                            //the ET derived type, goes out of scope.
    if (pszNew==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    memcpyf(pszNew, pszCurrent, cbString);
    pszNew[cbString]='\0';

    *ppOut=(LPVOID) pszNew;
    *ppszIn=pParser->FindNonWhite(pszEnd+1);

    return(NOERROR);
}

HRESULT PICSRulesParseNumber(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    int n;

    LPSTR pszCurrent=*ppszIn;
    HRESULT hres=::ParseNumber(&pszCurrent,&n,TRUE);

    if(FAILED(hres))
    {
        return(PICSRULES_E_EXPECTEDNUMBER);
    }

    *(int *)ppOut=n;

    LPSTR pszNewline=strchrf(*ppszIn, '\n');

    while((pszNewline!=NULL)&&(pszNewline<pszCurrent))
    {
        pParser->m_nLine++;
        pszNewline=strchrf(pszNewline+1,'\n');
    }
    
    *ppszIn=pszCurrent;

    return(NOERROR);
}


HRESULT PICSRulesParseYesNo(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    BOOL b;

    //The PICSRules spec allows the following:
    //
    //            "y" == Yes
    //          "yes" == Yes
    //            "n" == no
    //           "no" == no
    //
    //  string comparison is not case sensitive
    //

    LPSTR pszCurrent=*ppszIn;

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    HRESULT hres=::GetBool(&pszCurrent,&b,PR_BOOLEAN_YESNO);

    if (FAILED(hres))
    {
        return(PICSRULES_E_EXPECTEDBOOL);
    }

    LPSTR pszNewline=strchrf(*ppszIn,'\n');
    while((pszNewline!=NULL)&&(pszNewline<pszCurrent))
    {
        pParser->m_nLine++;
        pszNewline=strchrf(pszNewline+1,'\n');
    }

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    *ppszIn=pszCurrent;

    *(LPBOOL)ppOut=b;

    return(NOERROR);
}

HRESULT PICSRulesParsePassFail(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    BOOL b;

    //The PICSRules spec allows the following:
    //
    //         "pass" == pass
    //         "fail" == fail
    //
    //  for completeness we add:
    //
    //            "p" == pass
    //            "f" == fail
    //
    //  string comparison is not case sensitive
    //

    LPSTR pszCurrent=*ppszIn;

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    HRESULT hres=::GetBool(&pszCurrent,&b,PR_BOOLEAN_PASSFAIL);

    if (FAILED(hres))
    {
        return(PICSRULES_E_EXPECTEDBOOL);
    }

    LPSTR pszNewline=strchrf(*ppszIn,'\n');
    while((pszNewline!=NULL)&&(pszNewline<pszCurrent))
    {
        pParser->m_nLine++;
        pszNewline=strchrf(pszNewline+1,'\n');
    }

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    *ppszIn=pszCurrent;

    *(LPBOOL)ppOut=b;

    return(NOERROR);
}

HRESULT PICSRulesParseVersion(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //t-markh - 8/98 - This shouldn't get called, version info should be filled
    //                 out before processing begins

    return(E_UNEXPECTED);
}

PICSRulesAllowableOption aaoPICSRulesPolicy[] = {
    { PROID_EXPLANATION, AO_SINGLE },
    { PROID_REJECTBYURL, AO_SINGLE },
    { PROID_ACCEPTBYURL, AO_SINGLE },
    { PROID_REJECTIF, AO_SINGLE },
    { PROID_ACCEPTIF, AO_SINGLE },
    { PROID_ACCEPTUNLESS, AO_SINGLE },
    { PROID_REJECTUNLESS, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesPolicy=sizeof(aaoPICSRulesPolicy)/sizeof(aaoPICSRulesPolicy[0]);

HRESULT PICSRulesParsePolicy(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesPolicy];

    ::memcpyf(aao,::aaoPICSRulesPolicy,sizeof(aao));

    PICSRulesPolicy *pPolicy=new PICSRulesPolicy;
    
    if(pPolicy==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pPolicy);               //object to add items back to

    if (FAILED(hres))
    {
        delete pPolicy;
        pPolicy = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pPolicy;

    return NOERROR;
}

//PICSRules URLpatterns can be presented to ParseByURL as either a single
//pattern, or a parenthesized list of multiple patterns. i.e.
//
//  Policy (RejectByURL "http://*@*.badsite.com:*/*" )
//  Policy (AcceptByURL (
//              "http://*@www.goodsite.com:*/*"
//              "ftp://*@www.goodsite.com:*/*" ) )
//
//The general form of an URLpattern is:
//
// internet pattern         -   internetscheme://user@hostoraddr:port/pathmatch
// other pattern            -   otherscheme:nonquotedcharacters
//
// in all cases, an ommitted section only matches to a URL if that section
// was omitted in the URL being navigated to.
//
// the wild card character '*' may be used to match any pattern as specified
// on a per section basis below.  To encode the actual character '*' the escape
// sequence '%*' is recognized.
//
// recognized internet schemes are:
//      ftp, http, gopher, nntp, irc, prospero, telnet, and *
//
// the user section consists of '*' nonquotedcharacters '*', in other words, an
// alphanumeric user name with optional wild card sections before and after the
// name.  A single * matches all names.
//
// the hostoraddr section can be in one of two forms, either:
//      '*' hostname, or ipnum.ipnum.ipnum.ipnum!bitlength
// hostname must be a substring of a fully qualified domain name
// bitlength is an integer between 0 and 32 inclusive, and
// ipnum is an integer between 0 and 255 inclusive.
// the bitlength parameter masks out the last n bits of the 32 bit ip address
// specified (i.e. treats them as a wild card)
//
// the port section can have one of four forms:
//      *
//      *-portnum
//      portnum-*
//      portnum-portnum
//
// a single * matches against all port numbers, *-portnum matches all ports
// lessthan or equal to portnum, portnum-* matches all aports greaterthan or
// equal to portnum, and portnum-portnum matches all ports between the two
// portnums, inclusive.
//
// the pathmatch section has the form:
//      '*' nonquotedchars '*'
// i.e. *foo* would match any pathname containing the word foo.  A single *
// matches all pathnames.
HRESULT PICSRulesParseByURL(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    PICSRulesByURLExpression    *pPRByURLExpression;
    PICSRulesByURL              *pPRByURL;
    HRESULT                     hRes;
    LPSTR                       lpszCurrent;

    pPRByURL=new PICSRulesByURL;

    //first, we need to find out if we have a list of URLpatterns or a single
    //URLpattern

    if(**ppszIn=='(') //we have a list of patterns
    {
        lpszCurrent=pParser->FindNonWhite(*ppszIn+1);
        
        while(*lpszCurrent!=')')
        {
            LPSTR lpszSubString;

            if(*lpszCurrent=='\0')
            {
                delete pPRByURL;
                pPRByURL = NULL;

                return(E_INVALIDARG);
            }

            hRes=PICSRulesParseString(&lpszCurrent,ppOut,pParser); //get the string

            if(FAILED(hRes))
            {
                //we couldn't get the string, so lets fail
                delete pPRByURL;
                pPRByURL = NULL;

                return(hRes);
            }

            lpszSubString=(char *) *ppOut;

            //we've got it, so lets instantiate the classes to fill out;

            pPRByURLExpression=new PICSRulesByURLExpression;

            hRes=pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression) ? S_OK : E_OUTOFMEMORY;
        
            if(FAILED(hRes))
            {
                delete lpszSubString;
                lpszSubString = NULL;
                delete pPRByURLExpression;
                pPRByURLExpression = NULL;
                delete pPRByURL;
                pPRByURL = NULL;

                return(hRes);
            }

            hRes=PICSRulesParseSingleByURL(lpszSubString,pPRByURLExpression,pParser);
        
            if(FAILED(hRes))
            {
                delete lpszSubString;
                lpszSubString = NULL;
                delete pPRByURL; //deleting the array deletes the embeeded expression
                pPRByURL = NULL;

                return(hRes);
            }

            delete lpszSubString;
            lpszSubString = NULL;
        }

        if(*lpszCurrent==')')
        {
            *ppszIn=pParser->FindNonWhite(lpszCurrent+1);
        }
    }
    else //we have a single pattern
    {
        hRes=PICSRulesParseString(ppszIn,ppOut,pParser); //get the string

        if(FAILED(hRes))
        {
            //we couldn't get the string, so lets fail
            delete pPRByURL;
            pPRByURL = NULL;

            return(hRes);
        }

        lpszCurrent=(char *) *ppOut;

        //we've got it, so lets instantiate the classes to fill out;

        pPRByURLExpression=new PICSRulesByURLExpression;

        hRes=pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression) ? S_OK : E_OUTOFMEMORY;
        
        if(FAILED(hRes))
        {
            delete lpszCurrent;
            lpszCurrent = NULL;
            delete pPRByURLExpression;
            pPRByURLExpression = NULL;
            delete pPRByURL;
            pPRByURL = NULL;

            return(hRes);
        }

        hRes=PICSRulesParseSingleByURL(lpszCurrent,pPRByURLExpression,pParser);
    
        if(FAILED(hRes))
        {
            delete lpszCurrent;
            lpszCurrent = NULL;
            delete pPRByURL; //deleting the array deletes the embeeded expression
            pPRByURL = NULL;

            return(hRes);
        }

        delete lpszCurrent;
        lpszCurrent= NULL;
    }

    *ppOut=(void *) pPRByURL;

    return(NOERROR);
}

HRESULT PICSRulesParseSingleByURL(LPSTR lpszByURL, PICSRulesByURLExpression *pPRByURLExpression, PICSRulesFileParser *pParser)
{
    LPSTR lpszMarker;

    lpszMarker=strchrf(lpszByURL,':'); //find the marker '://' for an internet
                                       //pattern or ':' for a non-internet pattern

    if(lpszMarker==NULL) //no marker, i.e. our string is invalid
    {
        return(E_INVALIDARG);
    }

    //check the scheme for a wild card
    if(*lpszByURL=='*')
    {
        if((lpszByURL+1)!=lpszMarker) //we have a non-internet scheme
        {
            pPRByURLExpression->m_fInternetPattern=FALSE;

            *lpszMarker='\0';

            pPRByURLExpression->m_etstrScheme.Set(lpszByURL);

            lpszByURL=lpszMarker+1;

            pPRByURLExpression->m_etstrPath.Set(lpszByURL);

            return(S_OK);
        }

        //no need to set a NonWild flag, just move
        //on to the user name
        pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;
    }
    else
    {
        *lpszMarker='\0';

        //check for an internet pattern

        if((lstrcmpi(lpszByURL,szPICSRulesFTP)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesHTTP)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesGOPHER)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesNNTP)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesIRC)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesPROSPERO)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesTELNET)!=0)) //we've got a non-internet pattern
        {
            pPRByURLExpression->m_fInternetPattern=FALSE;
            pPRByURLExpression->m_bNonWild=BYURL_SCHEME|BYURL_PATH;
            pPRByURLExpression->m_bSpecified=BYURL_SCHEME|BYURL_PATH;
            pPRByURLExpression->m_etstrScheme.Set(lpszByURL);

            lpszByURL=lpszMarker+1;

            pPRByURLExpression->m_etstrPath.Set(lpszByURL);

            return(S_OK);
        }

        pPRByURLExpression->m_bNonWild|=BYURL_SCHEME;
        pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;
        pPRByURLExpression->m_etstrScheme.Set(lpszByURL);   
    }

    if((*(lpszMarker+1)=='/')&&(*(lpszMarker+2)=='/'))
    {
        pPRByURLExpression->m_fInternetPattern=TRUE;
        lpszByURL=lpszMarker+3;
    }
    else
    {
        return(E_INVALIDARG);
    }

    //we've got an internet pattern, and lpszURL now points
    //to the user field

    lpszMarker=strchrf(lpszByURL,'@'); //find the marker between user and host
    
    if(lpszMarker!=NULL) //a user name was specified
    {
        pPRByURLExpression->m_bSpecified|=BYURL_USER;

        //check for a wild card
        if(!((*lpszByURL=='*')&&((lpszByURL+1)==lpszMarker)))
        {
            pPRByURLExpression->m_bNonWild|=BYURL_USER;
            
            *lpszMarker='\0';

            pPRByURLExpression->m_etstrUser.Set(lpszByURL);
        }

        lpszByURL=lpszMarker+1;
    }

    //lpszByURL now points to host

    lpszMarker=strchrf(lpszByURL,':');

    if(lpszMarker==NULL) //the port was omitted
    {
        lpszMarker=strchrf(lpszByURL,'/');

        if(lpszMarker!=NULL) //there is a pathmatch
        {
            pPRByURLExpression->m_bSpecified|=BYURL_PATH;       
        }
    }
    else //we have a host and port
    {
        pPRByURLExpression->m_bSpecified|=BYURL_PORT;
    }
    
    pPRByURLExpression->m_bSpecified|=BYURL_HOST;

    if(lpszMarker!=NULL)
    {
        *lpszMarker='\0';
    }

    if(lstrcmp(lpszByURL,"*")!=0)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_HOST;
    }

    pPRByURLExpression->m_etstrHost.Set(lpszByURL);

    if(lpszMarker==NULL)
    {
        return(S_OK);
    }

    lpszByURL=lpszMarker+1;

    if(pPRByURLExpression->m_bSpecified&BYURL_PORT)
    {
        lpszMarker=strchrf(lpszByURL,'/');

        if(lpszMarker!=NULL) //there is a pathmatch
        {
            pPRByURLExpression->m_bSpecified|=BYURL_PATH;       
            *lpszMarker='\0';   
        }

        if(!((*lpszByURL=='*')&&(lpszByURL+1==lpszMarker)))
        {
            pPRByURLExpression->m_bNonWild|=BYURL_PORT;

            pPRByURLExpression->m_etstrPort.Set(lpszByURL);
        }

        if(pPRByURLExpression->m_bSpecified&BYURL_PATH)
        {
            lpszByURL=lpszMarker+1;
        }
    }

    if(pPRByURLExpression->m_bSpecified&BYURL_PATH)
    {
        if(!((*lpszByURL=='*')&&(*(lpszByURL+1)==NULL)))
        {
            pPRByURLExpression->m_bNonWild|=BYURL_PATH;

            pPRByURLExpression->m_etstrPath.Set(lpszByURL);
        }
    }

    return(S_OK);
}

//PICSRules PolicyExpressions have 6 possible expressions:
//
// simple-expression        -   ( Service.Category [Operator] [Constant] )
// or-expression            -   ( PolicyExpression or PolicyExpression )
// and-expression           -   ( PolicyExpression and PolicyExpression )
// service & category       -   ( Service.Category )
// service only             -   ( Service )
// degenerate-expression    -   "otherwise"
//
// thus, for example, embedded expressions can take the form:
//
// "((Cool.Coolness < 3) or (Cool.Graphics < 3))"
// 
// or
//
// "(((Cool.Coolness < 3) or (Cool.Graphics < 3)) and (Cool.Fun < 2))"
//
// ad infinitum
//
// thus, existing pics labels can be encoded as:
//
// "((((RSACi.s <= 0) and (RSACi.v <= 0)) and (RSACi.n <= 0)) and RSACi.l <=0)"
//
// allowable operators are: '<', '<=', '=', '>=', '>'
//
// the service only expression evaluates to TRUE iff a label from that
// service is found.
//
// the service & category expression evaluates to TRUE iff a label from
// that service is found, and it contains at least one value for the
// indicated category.
//
// the degenerate-expression always evaluates to TRUE
HRESULT PICSRulesParsePolicyExpression(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    PICSRulesPolicyExpression   *pPRPolicyExpression;
    HRESULT                     hRes;
    LPSTR                       lpszPolicyExpression,lpszCurrent;

    //first lets get the string
    hRes=PICSRulesParseString(ppszIn,ppOut,pParser);

    if(FAILED(hRes))
    {
        //we couldn't get the string, so lets fail
        return(hRes);
    }
    lpszPolicyExpression=(char *) *ppOut;

    //we've got it, so lets instantiate a PICSRulesPolicyExpression to fill out
    pPRPolicyExpression=new PICSRulesPolicyExpression;

    if(pPRPolicyExpression==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_RESULT; //set as the topmost node
                                                                 //of the binary tree

    if(lstrcmpi(lpszPolicyExpression,szPICSRulesDegenerateExpression)==0)
    {
        //we have a degenerate expression, so delete lpszPolicyExpresion

        delete lpszPolicyExpression;
        lpszPolicyExpression = NULL;

        pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_DEGENERATE;

        *ppOut=(LPVOID) pPRPolicyExpression;

        return(NOERROR);
    }

    //make sure we have a parenthesized object
    if(*lpszPolicyExpression!='(')
    {
        delete lpszPolicyExpression;
        lpszPolicyExpression = NULL;
        delete pPRPolicyExpression;
        pPRPolicyExpression= NULL;
        
        return(E_INVALIDARG);
    }
    
    lpszCurrent=NonWhite(lpszPolicyExpression+1);

    //check for an or-expression or an and-expression
    if(*lpszCurrent=='(')
    {
        hRes=PICSRulesParseSubPolicyExpression(lpszCurrent,pPRPolicyExpression,pParser);

        if(FAILED(hRes))
        {
            delete lpszPolicyExpression;
            lpszPolicyExpression = NULL;
            delete pPRPolicyExpression;
            pPRPolicyExpression = NULL;
            
            return(hRes);
        }
        else
        {
            if((pPRPolicyExpression->m_pPRPolicyExpressionLeft)!=NULL)
            {
                BOOL fFlag;
                
                fFlag=pPRPolicyExpression->m_pPRPolicyExpressionLeft->m_prYesNoUseEmbedded.GetYesNo();

                pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
            }
        }
    }
    else //we've got a simple-expression
    {
        hRes=PICSRulesParseSimplePolicyExpression(lpszCurrent,pPRPolicyExpression,pParser);

        if(FAILED(hRes))
        {
            delete lpszPolicyExpression;
            lpszPolicyExpression = NULL;
            delete pPRPolicyExpression;
            pPRPolicyExpression= NULL;

            return(hRes);
        }
    }

    delete lpszPolicyExpression;
    lpszPolicyExpression= NULL;

    *ppOut=(void *) pPRPolicyExpression;

    return(NOERROR);
}

//Our PolicyExpression is either an or-expression or an and-expression
//so pPRPolicyExpression need to have another PICSRulesPolicyExpression
//embedded in it, with all the details filled out.
HRESULT PICSRulesParseSubPolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser)
{
    HRESULT hRes;
    PICSRulesPolicyExpression   * pPRPolicyExpressionEmbeddedLeft,
                                * pPRPolicyExpressionEmbeddedRight;
    LPSTR                       lpszNextPolicyExpression,
                                lpszOrAnd,lpszOrAndEnd;
    int                         iStringLen;
    BOOL                        fFlag;

    lpszCurrent=NonWhite(lpszCurrent+1);

    //check for nested or-expressions and and-expressions
    if(*lpszCurrent=='(')
    {
        pPRPolicyExpressionEmbeddedLeft=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedLeft==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        pPRPolicyExpressionEmbeddedLeft->m_PROPolicyOperator=PR_OPERATOR_RESULT;

        hRes=PICSRulesParseSubPolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedLeft,pParser);

        if(FAILED(hRes))
        {
            delete pPRPolicyExpressionEmbeddedLeft;
            pPRPolicyExpressionEmbeddedLeft = NULL;

            return(hRes);
        }

        pPRPolicyExpression->m_pPRPolicyExpressionLeft=pPRPolicyExpressionEmbeddedLeft;
        
        fFlag=pPRPolicyExpressionEmbeddedLeft->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
    }
    else //only one level deep
    {
        pPRPolicyExpressionEmbeddedLeft=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedLeft==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        hRes=PICSRulesParseSimplePolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedLeft,pParser);

        if(FAILED(hRes))
        {
            delete pPRPolicyExpressionEmbeddedLeft;
            pPRPolicyExpressionEmbeddedLeft= NULL;

            return(hRes);
        }

        pPRPolicyExpression->m_pPRPolicyExpressionLeft=pPRPolicyExpressionEmbeddedLeft;

        fFlag=pPRPolicyExpressionEmbeddedLeft->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);

        lpszCurrent=strchrf(lpszCurrent,')');
        lpszCurrent=NonWhite(lpszCurrent+1);
    }

    lpszNextPolicyExpression=strchrf(lpszCurrent,'(');
    
    if(lpszNextPolicyExpression==NULL) //invalid policy expression
    {
        return(E_INVALIDARG);
    }

    lpszOrAndEnd=White(lpszCurrent);

    if(lpszOrAndEnd>lpszNextPolicyExpression) //no white space
    {
        lpszOrAndEnd=lpszNextPolicyExpression;
    }

    iStringLen=(int) (lpszOrAndEnd-lpszCurrent);

    lpszOrAnd=new char[iStringLen+1];

    if(lpszOrAnd==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    memcpyf(lpszOrAnd,lpszCurrent,iStringLen);
    lpszOrAnd[iStringLen]='\0';

    if(lstrcmpi(lpszOrAnd,szPICSRulesAnd)==0)
    {
        pPRPolicyExpression->m_PRPEPolicyEmbedded=PR_POLICYEMBEDDED_AND;
    }
    else if(lstrcmpi(lpszOrAnd,szPICSRulesOr)==0)
    {
        pPRPolicyExpression->m_PRPEPolicyEmbedded=PR_POLICYEMBEDDED_OR;
    }
    else
    {
        delete lpszOrAnd;
        lpszOrAnd = NULL;

        return(E_INVALIDARG);
    }

    delete lpszOrAnd;
    lpszOrAnd= NULL;

    lpszCurrent=NonWhite(lpszOrAndEnd+1);

    if(lpszCurrent!=lpszNextPolicyExpression)
    {
        return(E_INVALIDARG);
    }

    lpszCurrent=NonWhite(lpszCurrent+1);

    //do we have more embedded objects, or another simple-expression?
    if(*lpszCurrent=='(') //more embedded
    {
        pPRPolicyExpressionEmbeddedRight=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedRight==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        pPRPolicyExpressionEmbeddedRight->m_PROPolicyOperator=PR_OPERATOR_RESULT;
        
        hRes=PICSRulesParseSubPolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedRight,pParser);

        if(FAILED(hRes))
        {
            return(hRes);
        }

        if(*lpszCurrent!=')')
        {
            delete pPRPolicyExpressionEmbeddedRight;
            pPRPolicyExpressionEmbeddedRight= NULL;

            return(E_INVALIDARG);
        }

        lpszCurrent=NonWhite(lpszCurrent+1);

        pPRPolicyExpression->m_pPRPolicyExpressionRight=pPRPolicyExpressionEmbeddedRight;

        fFlag=pPRPolicyExpressionEmbeddedRight->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
    }
    else //simple expression
    {
        pPRPolicyExpressionEmbeddedRight=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedRight==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        hRes=PICSRulesParseSimplePolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedRight,pParser);

        if(FAILED(hRes))
        {
            delete pPRPolicyExpressionEmbeddedRight;
            pPRPolicyExpressionEmbeddedRight = NULL;

            return(hRes);
        }

        lpszCurrent=strchrf(lpszCurrent,')');
        lpszCurrent=NonWhite(lpszCurrent+1);

        if(*lpszCurrent!=')')
        {
            delete pPRPolicyExpressionEmbeddedRight;
            pPRPolicyExpressionEmbeddedRight= NULL;

            return(E_INVALIDARG);
        }

        lpszCurrent=NonWhite(lpszCurrent+1);

        pPRPolicyExpression->m_pPRPolicyExpressionRight=pPRPolicyExpressionEmbeddedRight;

        fFlag=pPRPolicyExpressionEmbeddedRight->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
    }

    return(S_OK);
}

HRESULT PICSRulesParseSimplePolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser)
{
    LPSTR                lpszEnd,lpszDot;
    PICSRulesServiceInfo *pPRServiceInfo=NULL;
    
    lpszEnd=strchrf(lpszCurrent,')');

    if(lpszEnd==NULL) //we don't have a valid expression
    {
        return(E_INVALIDARG);
    }

    lpszDot=strchrf(lpszCurrent,'.');

    if(lpszDot==NULL) //we have a service only expression
    {
        LPSTR   lpszService,lpszServiceEnd,lpszFullService;
        int     iStringLen;

        lpszServiceEnd=White(lpszCurrent);
        
        if(lpszServiceEnd>lpszEnd) //there isn't any white space between
                                   //the service name and the closing
                                   //parenthesis
        {
            lpszServiceEnd=lpszEnd;
        }

        iStringLen=(int)(lpszServiceEnd-lpszCurrent);

        lpszService=new char[iStringLen+1];

        if(lpszService==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        memcpyf(lpszService,lpszCurrent,iStringLen);
        lpszService[iStringLen]='\0';

        lpszFullService=new char[INTERNET_MAX_URL_LENGTH+1];

        if(IsServiceDefined(lpszService,lpszFullService,&pPRServiceInfo)==FALSE)
        {
            delete lpszService;
            lpszService = NULL;

            delete lpszFullService;
            lpszFullService = NULL;
            
            return(PICSRULES_E_SERVICEUNDEFINED);
        }

        //we have a valid service only expression
        if(pPRServiceInfo!=NULL)
        {
            BOOL fFlag;

            fFlag=pPRServiceInfo->m_prYesNoUseEmbedded.GetYesNo();
            pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
        }

        pPRPolicyExpression->m_etstrServiceName.SetTo(lpszService);
        pPRPolicyExpression->m_etstrFullServiceName.SetTo(lpszFullService);
        pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_SERVICEONLY;
    }
    else //could be service and category or a full simple-expression
    {
        LPSTR   lpszService,lpszCategory,lpszCategoryEnd,lpszOperator,lpszFullService;
        int     iStringLen;

        lpszCategoryEnd=White(lpszCurrent);
        
        if(lpszCategoryEnd>lpszEnd) //there isn't any white space between
                                    //the category name and the closing
                                    //parenthesis
        { 
            lpszCategoryEnd=lpszEnd;
        }

        lpszOperator=strchrf(lpszCurrent,'<');

        if(lpszOperator!=NULL)
        {
            if(lpszOperator<lpszCategoryEnd) //there was an operator with
                                             //no white space
            {
                lpszCategoryEnd=lpszOperator;
            }
        }

        lpszOperator=strchrf(lpszCurrent,'>');

        if(lpszOperator!=NULL)
        {
            if(lpszOperator<lpszCategoryEnd) //there was an operator with
                                             //no white space
            {
                lpszCategoryEnd=lpszOperator;
            }
        }

        lpszOperator=strchrf(lpszCurrent,'=');

        if(lpszOperator!=NULL)
        {
            if(lpszOperator<lpszCategoryEnd) //there was an operator with
                                             //no white space
            {
                lpszCategoryEnd=lpszOperator;
            }
        }

        iStringLen=(int)(lpszDot-lpszCurrent);

        lpszService=new char[iStringLen+1];

        if(lpszService==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        memcpyf(lpszService,lpszCurrent,iStringLen);
        lpszService[iStringLen]='\0';

        lpszFullService=new char[INTERNET_MAX_URL_LENGTH+1];

        if(IsServiceDefined(lpszService,lpszFullService,&pPRServiceInfo)==FALSE)
        {
            delete lpszService;
            lpszService = NULL;

            delete lpszFullService;
            lpszFullService= NULL;
            
            return(PICSRULES_E_SERVICEUNDEFINED);
        }

        iStringLen=(int)(lpszCategoryEnd-lpszDot-1);
        
        lpszCategory=new char[iStringLen+1];

        if(lpszCategory==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        memcpyf(lpszCategory,lpszDot+1,iStringLen);
        lpszCategory[iStringLen]='\0';

        lpszCurrent=NonWhite(lpszCategoryEnd);

        if(*lpszCurrent==')') //we have a valid service and category expression
        {
            if(pPRServiceInfo!=NULL)
            {
                BOOL fFlag;

                fFlag=pPRServiceInfo->m_prYesNoUseEmbedded.GetYesNo();
                pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
            }

            pPRPolicyExpression->m_etstrServiceName.SetTo(lpszService);
            pPRPolicyExpression->m_etstrFullServiceName.SetTo(lpszFullService);
            pPRPolicyExpression->m_etstrCategoryName.SetTo(lpszCategory);
            pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_SERVICEANDCATEGORY;
        }
        else //we have a full simple-expression
        {
            //lpszCurrent should be pointing to an operator
            enum PICSRulesOperators PROPolicyOperator;
            int                     iValue;

            switch(*lpszCurrent)
            {
                case '>':
                {
                    if(*(lpszCurrent+1)=='=')
                    {
                        PROPolicyOperator=PR_OPERATOR_GREATEROREQUAL;
                        lpszCurrent=NonWhite(lpszCurrent+2);
                    }
                    else
                    {
                        PROPolicyOperator=PR_OPERATOR_GREATER;
                        lpszCurrent=NonWhite(lpszCurrent+1);
                    }

                    break;
                }
                case '<':
                {
                    if(*(lpszCurrent+1)=='=')
                    {
                        PROPolicyOperator=PR_OPERATOR_LESSOREQUAL;
                        lpszCurrent=NonWhite(lpszCurrent+2);
                    }
                    else
                    {
                        PROPolicyOperator=PR_OPERATOR_LESS;
                        lpszCurrent=NonWhite(lpszCurrent+1);
                    }

                    break;
                }
                case '=':
                {
                    PROPolicyOperator=PR_OPERATOR_EQUAL;
                    lpszCurrent=NonWhite(lpszCurrent+1);

                    break;
                }
                default: //we didn't get a valid operator
                {
                    delete lpszService;
                    lpszService = NULL;

                    delete lpszCategory;
                    lpszCategory = NULL;
                    
                    return(E_INVALIDARG);
                }
            }

            //lpszCurrent now points at the Value
            if(FAILED(ParseNumber(&lpszCurrent,&iValue,FALSE)))
            {
                delete lpszService;
                lpszService = NULL;

                delete lpszCategory;
                lpszCategory = NULL;

                return(E_INVALIDARG);
            }

            if(*lpszCurrent!=')') //we should be done, so the argument is invalid
            {
                delete lpszService;
                lpszService = NULL;

                delete lpszCategory;
                lpszCategory = NULL;

                return(E_INVALIDARG);           
            }

            //we now have a complete simple-expression
            if(pPRServiceInfo!=NULL)
            {
                BOOL fFlag;

                fFlag=pPRServiceInfo->m_prYesNoUseEmbedded.GetYesNo();
                pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
            }

            pPRPolicyExpression->m_etstrServiceName.SetTo(lpszService);
            pPRPolicyExpression->m_etstrFullServiceName.SetTo(lpszFullService);
            pPRPolicyExpression->m_etstrCategoryName.SetTo(lpszCategory);
            pPRPolicyExpression->m_etnValue.Set(iValue);
            pPRPolicyExpression->m_PROPolicyOperator=PROPolicyOperator;
        }
    }

    return(S_OK);
}

//Determines if the service name in lpszService has been read in a
//ServiceInfo section of the PICSRules file
BOOL IsServiceDefined(LPSTR lpszService,LPSTR lpszFullService,PICSRulesServiceInfo **ppServiceInfo)
{
    array<PICSRulesServiceInfo*>    *arrpPRServiceInfo;
    LPSTR                           lpszShortName;
    int                             iNumServices,iCounter;
    BOOL                            fDefined=FALSE;

    if(g_pPRRS==NULL)
    {
        return(FALSE);
    }

    arrpPRServiceInfo=(array<PICSRulesServiceInfo*> *) &(g_pPRRS->m_arrpPRServiceInfo);

    iNumServices=arrpPRServiceInfo->Length();

    for(iCounter=0;iCounter<iNumServices;iCounter++)
    {
        PICSRulesServiceInfo * pPRServiceInfo;
        
        pPRServiceInfo=(*arrpPRServiceInfo)[iCounter];

        lpszShortName=pPRServiceInfo->m_etstrShortName.Get();

        if(lstrcmp(lpszService,lpszShortName)==0)
        {
            fDefined=TRUE;

            if(ppServiceInfo!=NULL)
            {
                *ppServiceInfo=pPRServiceInfo;
            }

            lstrcpy(lpszFullService,pPRServiceInfo->m_prURLName.Get());

            break;
        }
    }

    return(fDefined);
}

//Determines if the extension name in lpszExtension has been read in a
//OptExtension of the PICSRules file
BOOL IsOptExtensionDefined(LPSTR lpszExtension)
{
    array<PICSRulesOptExtension*>   *arrpPROptExtension;
    LPSTR                           lpszShortName;
    int                             iNumExtensions,iCounter;
    BOOL                            fDefined=FALSE;

    if(g_pPRRS==NULL)
    {
        return(FALSE);
    }

    arrpPROptExtension=(array<PICSRulesOptExtension*> *) &(g_pPRRS->m_arrpPROptExtension);

    iNumExtensions=arrpPROptExtension->Length();

    for(iCounter=0;iCounter<iNumExtensions;iCounter++)
    {
        PICSRulesOptExtension * pPROptExtension;
        
        pPROptExtension=(*arrpPROptExtension)[iCounter];

        lpszShortName=pPROptExtension->m_etstrShortName.Get();

        if(lstrcmp(lpszExtension,lpszShortName)==0)
        {
            fDefined=TRUE;
            
            break;
        }
    }

    return(fDefined);
}

//Deteremines is the extension name in lpszExtension has been read in a
//ReqExtension of the PICSRules file
BOOL IsReqExtensionDefined(LPSTR lpszExtension)
{
    array<PICSRulesReqExtension*>   *arrpPRReqExtension;
    LPSTR                           lpszShortName;
    int                             iNumExtensions,iCounter;
    BOOL                            fDefined=FALSE;

    if(g_pPRRS==NULL)
    {
        return(FALSE);
    }

    arrpPRReqExtension=(array<PICSRulesReqExtension*> *) &(g_pPRRS->m_arrpPRReqExtension);

    iNumExtensions=arrpPRReqExtension->Length();

    for(iCounter=0;iCounter<iNumExtensions;iCounter++)
    {
        PICSRulesReqExtension * pPRReqExtension;
        
        pPRReqExtension=(*arrpPRReqExtension)[iCounter];

        lpszShortName=pPRReqExtension->m_etstrShortName.Get();

        if(lstrcmp(lpszExtension,lpszShortName)==0)
        {
            fDefined=TRUE;
            
            break;
        }
    }

    return(fDefined);
}

PICSRulesAllowableOption aaoPICSRulesName[] = {
    { PROID_RULENAME, 0 },
    { PROID_DESCRIPTION, 0 },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesName=sizeof(aaoPICSRulesName)/sizeof(aaoPICSRulesName[0]);

HRESULT PICSRulesParseName(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesName];

    ::memcpyf(aao,::aaoPICSRulesName,sizeof(aao));

    PICSRulesName *pName=new PICSRulesName;
    
    if(pName==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pName);                 //object to add items back to

    if (FAILED(hres))
    {
        delete pName;
        pName = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pName;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesSource[] = {
    { PROID_SOURCEURL, 0 },
    { PROID_CREATIONTOOL, 0 },
    { PROID_AUTHOR, 0 },
    { PROID_LASTMODIFIED, 0 },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesSource=sizeof(aaoPICSRulesSource)/sizeof(aaoPICSRulesSource[0]);

HRESULT PICSRulesParseSource(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesSource];

    ::memcpyf(aao,::aaoPICSRulesSource,sizeof(aao));

    PICSRulesSource *pSource=new PICSRulesSource;
    
    if(pSource==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pSource);               //object to add items back to

    if (FAILED(hres))
    {
        delete pSource;
        pSource = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pSource;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesServiceInfo[] = {
    { PROID_SINAME, AO_SINGLE },
    { PROID_SHORTNAME, AO_SINGLE },
    { PROID_BUREAUURL, 0 },
    { PROID_USEEMBEDDED, AO_SINGLE },
    { PROID_RATFILE, AO_SINGLE },
    { PROID_BUREAUUNAVAILABLE, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesServiceInfo=sizeof(aaoPICSRulesServiceInfo)/sizeof(aaoPICSRulesServiceInfo[0]);

HRESULT PICSRulesParseServiceInfo(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesServiceInfo];

    ::memcpyf(aao,::aaoPICSRulesServiceInfo,sizeof(aao));

    PICSRulesServiceInfo *pServiceInfo=new PICSRulesServiceInfo;
    
    if(pServiceInfo==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pServiceInfo);          //object to add items back to

    if (FAILED(hres))
    {
        delete pServiceInfo;
        pServiceInfo = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pServiceInfo;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesOptExtension[] = {
    { PROID_EXTENSIONNAME, AO_SINGLE },
    { PROID_SHORTNAME, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesOptExtension=sizeof(aaoPICSRulesOptExtension)/sizeof(aaoPICSRulesOptExtension[0]);

HRESULT PICSRulesParseOptExtension(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesOptExtension];

    ::memcpyf(aao,::aaoPICSRulesOptExtension,sizeof(aao));

    PICSRulesOptExtension *pOptExtension=new PICSRulesOptExtension;
    
    if(pOptExtension==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pOptExtension);         //object to add items back to

    if (FAILED(hres))
    {
        delete pOptExtension;
        pOptExtension = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pOptExtension;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesReqExtension[] = {
    { PROID_EXTENSIONNAME, AO_SINGLE },
    { PROID_SHORTNAME, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesReqExtension=sizeof(aaoPICSRulesReqExtension)/sizeof(aaoPICSRulesReqExtension[0]);

HRESULT PICSRulesParseReqExtension(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesReqExtension];

    ::memcpyf(aao,::aaoPICSRulesReqExtension,sizeof(aao));

    PICSRulesReqExtension *pReqExtension=new PICSRulesReqExtension;
    
    if(pReqExtension==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pReqExtension);         //object to add items back to

    if (FAILED(hres))
    {
        delete pReqExtension;
        pReqExtension = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pReqExtension;

    return NOERROR;
}

//Currently, we acknowledge no extensions.  If support for an extension
//needs to be added in the future, a PICSRulesParseExtensionName function
//should be added, similar to the other PICSRulesParseSection functions.
//This function should be called after confirming the extension string
//here.
//
//For now, we just eat the extensions
HRESULT PICSRulesParseExtension(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    LPTSTR lpszExtension,lpszEnd;

    lpszEnd=strchrf(*ppszIn,'.');
    
    if(lpszEnd==NULL)
    {
        return(PICSRULES_E_UNKNOWNITEM);
    }

    *lpszEnd='\0';

    //*ppszIn now points to the extension name
    //if we ever implement support for extensions, we'll need to do a comparison
    //here.  After the comparison is completed, the following code will point
    //to the extension's method.

    *ppszIn=lpszEnd+1;

    lpszEnd=strchrf(*ppszIn,'(');
    
    if(lpszEnd==NULL)
    {
        return(PICSRULES_E_EXPECTEDLEFT);
    }

    lpszExtension=White(*ppszIn);

    if((lpszExtension!=NULL)&&(lpszExtension<lpszEnd))
    {
        *lpszExtension='\0';
    }
    else
    {
        *lpszEnd='\0';
    }

    lpszExtension=*ppszIn;

    //lpszExtension now points to the clause on the given extension name
    //if we ever implement support for extensions, we'll need to do a comparison
    //here.  Using both this comparison and the one above, a callback needs
    //to be implemented to support the extension, for now we'll just parse to
    //the closing parenthesis and eat the extension.

    *ppszIn=lpszEnd+1;

    int iOpenParenthesis=1;

    do
    {
        if(**ppszIn=='(')
        {
            iOpenParenthesis++;
        }
        else if (**ppszIn==')')
        {
            iOpenParenthesis--;

            if(iOpenParenthesis==0)
            {
                break;
            }
        }

        *ppszIn=pParser->FindNonWhite(*ppszIn+1);

    } while (**ppszIn!='\0');

    if(**ppszIn=='\0')
    {
        return(PICSRULES_E_EXPECTEDRIGHT);
    }
    else
    {
        *ppszIn=pParser->FindNonWhite(*ppszIn+1);
    }

    *ppOut=(LPVOID) NULL;

    return NOERROR;
}

//*******************************************************************
//*
//* Code for the PICSRulesRatingSystem class
//*
//*******************************************************************
PICSRulesRatingSystem::PICSRulesRatingSystem()
    : m_dwFlags(0),
      m_nErrLine(0)
{
    // nothing to do but construct members
}

PICSRulesRatingSystem::~PICSRulesRatingSystem()
{
    m_arrpPRPolicy.DeleteAll();
    m_arrpPRServiceInfo.DeleteAll();
    m_arrpPROptExtension.DeleteAll();
    m_arrpPRReqExtension.DeleteAll();
}

HRESULT PICSRulesRatingSystem::InitializeMyDefaults()
{
    return NOERROR;     //no defaults to initialize
}

//Allowable options from within PICSRulesRaginSystem's scope include only the
//first teer of aaoPICSRules[] defined in picsrule.h
PICSRulesAllowableOption aaoPICSRulesRatingSystem[] = {
    { PROID_PICSVERSION, 0 },
    
    { PROID_POLICY, AO_MANDATORY },
    { PROID_NAME, AO_SINGLE },
    { PROID_SOURCE, AO_SINGLE },
    { PROID_SERVICEINFO, 0 },
    { PROID_OPTEXTENSION, 0 },
    { PROID_REQEXTENSION, 0 },
    { PROID_EXTENSION, 0 },

    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesRatingSystem=sizeof(aaoPICSRulesRatingSystem)/sizeof(aaoPICSRulesRatingSystem[0]);

//The following array is indexed by PICSRulesObjectID values.
//PICSRulesObjectHandler is defined in mslubase.h as:
//typedef HRESULT (*PICSRulesObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
struct {
    LPCSTR lpszToken;                       //token by which we identify it
    PICSRulesObjectHandler pHandler;        //function which parses the object's contents
} aPRObjectDescriptions[] = {
    { szNULL, NULL },
    { szPICSRulesVersion, PICSRulesParseVersion },
    { szPICSRulesPolicy, PICSRulesParsePolicy },
    { szPICSRulesExplanation, PICSRulesParseString },
    { szPICSRulesRejectByURL, PICSRulesParseByURL },
    { szPICSRulesAcceptByURL, PICSRulesParseByURL },
    { szPICSRulesRejectIf, PICSRulesParsePolicyExpression },
    { szPICSRulesAcceptIf, PICSRulesParsePolicyExpression },
    { szPICSRulesAcceptUnless, PICSRulesParsePolicyExpression },
    { szPICSRulesRejectUnless, PICSRulesParsePolicyExpression },
    { szPICSRulesName, PICSRulesParseName },
    { szPICSRulesRuleName, PICSRulesParseString },
    { szPICSRulesDescription, PICSRulesParseString },
    { szPICSRulesSource, PICSRulesParseSource },
    { szPICSRulesSourceURL, PICSRulesParseString },
    { szPICSRulesCreationTool, PICSRulesParseString },
    { szPICSRulesAuthor, PICSRulesParseString },
    { szPICSRulesLastModified, PICSRulesParseString },
    { szPICSRulesServiceInfo, PICSRulesParseServiceInfo },
    { szPICSRulesSIName, PICSRulesParseString },
    { szPICSRulesShortName, PICSRulesParseString },
    { szPICSRulesBureauURL, PICSRulesParseString },
    { szPICSRulesUseEmbedded, PICSRulesParseYesNo },
    { szPICSRulesRATFile, PICSRulesParseString },
    { szPICSRulesBureauUnavailable, PICSRulesParsePassFail },
    { szPICSRulesOptExtension, PICSRulesParseOptExtension },
    { szPICSRulesExtensionName, PICSRulesParseString },
  //{ szPICSRulesShortName, PICSRulesParseString },
    { szPICSRulesReqExtension, PICSRulesParseReqExtension },
  //{ szPICSRulesExtensionName, PICSRulesParseString },
  //{ szPICSRulesShortName, PICSRulesParseString },
    { szPICSRulesExtension, PICSRulesParseExtension },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString }
};

HRESULT PICSRulesRatingSystem::Parse(LPCSTR pszFilename, LPSTR pIn)
{
    //This guy is small enough to just init directly on the stack
    PICSRulesAllowableOption aaoRoot[] = { { PROID_PICSVERSION, 0 }, { PROID_INVALID, 0 } };
    PICSRulesAllowableOption aao[caoPICSRulesRatingSystem];

    ::memcpyf(aao,::aaoPICSRulesRatingSystem,sizeof(aao));

    PICSRulesAllowableOption *pFound;

    PICSRulesFileParser parser;

    LPSTR lpszVersionDash=strchrf(pIn,'-');     //since this is the first
                                                //time through, we need to
                                                //prepare the PicsRule
                                                //token for the parser

    if(lpszVersionDash!=NULL)                   //check for no dash we'll
                                                //fail in ParseToOpening
                                                //if this is the case
    {
        *lpszVersionDash=' ';                   //set it up for the parser
    }

    HRESULT hres=parser.ParseToOpening(&pIn,aaoRoot,&pFound);

    if (FAILED(hres))
    {
        return hres;                            //some error early on
    }
    else                                        //we got the PicsRule tag
                                                //now we need to check
                                                //the version number
    {
        LPSTR   lpszDot=strchrf(pIn,'.');
        
        if(lpszDot!=NULL)                       //continue on and fail
                                                //in ParseParenthesizedObject
        {
            int iVersion;

            *lpszDot=' ';

            ParseNumber(&pIn,&iVersion,TRUE);
            m_etnPRVerMajor.Set(iVersion);

            pIn=parser.FindNonWhite(pIn);

            ParseNumber(&pIn,&iVersion,TRUE);
            m_etnPRVerMinor.Set(iVersion);

            pIn=parser.FindNonWhite(pIn);
        }
    }

    //we'll fail if the version is 1.0, or 2.0 or higher
    //versions 1.1 - 2.0 (not including 2.0) will pass

    int iVerNumber=m_etnPRVerMajor.Get();

    if(iVerNumber!=1)
    {
        hres=PICSRULES_E_VERSION;
        m_nErrLine=parser.m_nLine;

        return(hres);
    }
    else //check the minor version number
    {
        iVerNumber=m_etnPRVerMinor.Get();

        if(iVerNumber==0)
        {
            hres=PICSRULES_E_VERSION;
            m_nErrLine=parser.m_nLine;

            return(hres);
        }
    }

    hres=parser.ParseParenthesizedObject(
                        &pIn,                   //var containing current ptr
                        aao,                    //what's legal in this object
                        this);                  //object to add items back to

    if(SUCCEEDED(hres))
    {
        if(*pIn!=')') //check for a closing parenthesis
        {
            hres=PICSRULES_E_EXPECTEDRIGHT;
        }
        else
        {
            LPTSTR lpszEnd=NonWhite(pIn+1);

            if(*lpszEnd!='\0') // make sure we're at the end of the file
            {
                hres=PICSRULES_E_EXPECTEDEND;
            }
        }
    }

    if(FAILED(hres))
    {
        m_nErrLine=parser.m_nLine;
    }

    return hres;
}

HRESULT PICSRulesRatingSystem::AddItem(PICSRulesObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
        case PROID_PICSVERSION:
        {
            //Takes a pointer to a PICSRULES_VERSION struct (defined in picsrule.h)
            PICSRULES_VERSION * PRVer;

            if(PRVer=((PICSRULES_VERSION *) pData))
            {
                m_etnPRVerMajor.Set(PRVer->iPICSRulesVerMajor);     
                m_etnPRVerMinor.Set(PRVer->iPICSRulesVerMinor);     
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_OPTEXTENSION:
        {
            PICSRulesOptExtension *pOptExtension;

            if(pOptExtension=((PICSRulesOptExtension *) pData))
            {
                hres=m_arrpPROptExtension.Append(pOptExtension) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pOptExtension;
                    pOptExtension = NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_REQEXTENSION:
        {
            PICSRulesReqExtension *pReqExtension;

            if(pReqExtension=((PICSRulesReqExtension *) pData))
            {
                hres=m_arrpPRReqExtension.Append(pReqExtension) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pReqExtension;
                    pReqExtension= NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_POLICY:
        {
            PICSRulesPolicy *pPolicy;
                
            if(pPolicy=((PICSRulesPolicy *) pData))
            {
                hres=m_arrpPRPolicy.Append(pPolicy) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pPolicy;
                    pPolicy = NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_NAME:
        {
            PICSRulesName *pName;
                
            if(pName=((PICSRulesName *) pData))
            {
                m_pPRName=pName;
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_SOURCE:
        {
            PICSRulesSource *pSource;
                
            if(pSource=((PICSRulesSource *) pData))
            {
                m_pPRSource=pSource;
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_SERVICEINFO:
        {
            PICSRulesServiceInfo *pServiceInfo;
                
            if(pServiceInfo=((PICSRulesServiceInfo *) pData))
            {
                hres=m_arrpPRServiceInfo.Append(pServiceInfo) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pServiceInfo;
                    pServiceInfo = NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hres=E_UNEXPECTED;
            break;
        }
    }
    return hres;
}

void PICSRulesRatingSystem::ReportError(HRESULT hres)
{
    UINT    idMsg,idTemplate;
    WCHAR   szErrorMessage[MAX_PATH],szErrorTitle[MAX_PATH],
            szLoadStringTemp[MAX_PATH];
    //we may be reporting E_OUTOFMEMORY, so we'll keep our string memory
    //on the stack so that its gauranteed to be there

    if((hres==E_OUTOFMEMORY)||((hres>PICSRULES_E_BASE)&&(hres<=PICSRULES_E_BASE+0xffff)))
    {
        idTemplate=IDS_PICSRULES_SYNTAX_TEMPLATE;   //default is PICSRules content error
        switch(hres)
        {
            case E_OUTOFMEMORY:
            {
                idMsg=IDS_PICSRULES_MEMORY;
                idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;
                break;
            }
            case PICSRULES_E_EXPECTEDLEFT:
            {
                idMsg=IDS_PICSRULES_EXPECTEDLEFT;
                break;
            }
            case PICSRULES_E_EXPECTEDRIGHT:
            {
                idMsg=IDS_PICSRULES_EXPECTEDRIGHT;
                break;
            }
            case PICSRULES_E_EXPECTEDTOKEN:
            {
                idMsg=IDS_PICSRULES_EXPECTEDTOKEN;
                break;
            }
            case PICSRULES_E_EXPECTEDSTRING:
            {
                idMsg=IDS_PICSRULES_EXPECTEDSTRING;
                break;
            }
            case PICSRULES_E_EXPECTEDNUMBER:
            {
                idMsg=IDS_PICSRULES_EXPECTEDNUMBER;
                break;
            }
            case PICSRULES_E_EXPECTEDBOOL:
            {
                idMsg=IDS_PICSRULES_EXPECTEDBOOL;
                break;
            }
            case PICSRULES_E_DUPLICATEITEM:
            {
                idMsg=IDS_PICSRULES_DUPLICATEITEM;
                break;
            }
            case PICSRULES_E_MISSINGITEM:
            {
                idMsg=IDS_PICSRULES_MISSINGITEM;
                break;
            }
            case PICSRULES_E_UNKNOWNITEM:
            {
                idMsg=IDS_PICSRULES_UNKNOWNITEM;
                break;
            }
            case PICSRULES_E_UNKNOWNMANDATORY:
            {
                idMsg=IDS_PICSRULES_UNKNOWNMANDATORY;
                break;
            }
            case PICSRULES_E_SERVICEUNDEFINED:
            {
                idMsg=IDS_PICSRULES_SERVICEUNDEFINED;
                break;
            }
            case PICSRULES_E_EXPECTEDEND:
            {
                idMsg=IDS_PICSRULES_EXPECTEDEND;

                break;
            }
            case PICSRULES_E_REQEXTENSIONUSED:
            {
                idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;
                idMsg=IDS_PICSRULES_REQEXTENSIONUSED;

                break;
            }
            case PICSRULES_E_VERSION:
            {
                idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;
                idMsg=IDS_PICSRULES_BADVERSION;

                break;
            }
            default:
            {
                ASSERT(FALSE);  //there aren't any other PICSRULES_E_ errors
                idMsg=IDS_PICSRULES_UNKNOWNERROR;
                break;
            }
        }

        MLLoadString(idTemplate,(LPTSTR) szLoadStringTemp,MAX_PATH);
        wsprintf((LPTSTR) szErrorMessage,(LPTSTR) szLoadStringTemp,m_etstrFile.Get());

        MLLoadString(idMsg,(LPTSTR) szLoadStringTemp,MAX_PATH);
        wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,m_nErrLine);

        lstrcat((LPTSTR) szErrorMessage,(LPTSTR) szErrorTitle);
    }
    else
    {
        idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;

        if(HRESULT_FACILITY(hres)==FACILITY_WIN32)
        {
            switch(hres)
            {
                case E_OUTOFMEMORY:
                {
                    idMsg=IDS_PICSRULES_MEMORY;
                    break;
                }
                case E_INVALIDARG:
                {
                    idMsg=IDS_PICSRULES_INVALID;
                    break;
                }
                default:
                {
                    idMsg=IDS_PICSRULES_WINERROR;
                    break;
                }
            }
            
            MLLoadString(idTemplate,(LPTSTR) szLoadStringTemp,MAX_PATH);
            wsprintf((LPTSTR) szErrorMessage,(LPTSTR) szLoadStringTemp,m_etstrFile.Get());

            MLLoadString(idMsg,(LPTSTR) szLoadStringTemp,MAX_PATH);
            
            if(idMsg==IDS_PICSRULES_WINERROR)
            {
                wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,HRESULT_CODE(hres));
            }
            else
            {
                wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,m_nErrLine);
            }

            lstrcat((LPTSTR) szErrorMessage,(LPTSTR) szErrorTitle);
        }
        else
        {
            idMsg=IDS_PICSRULES_MISCERROR;

            MLLoadString(idTemplate,(LPTSTR) szLoadStringTemp,MAX_PATH);
            wsprintf((LPTSTR) szErrorMessage,(LPTSTR) szLoadStringTemp,m_etstrFile.Get());

            MLLoadString(idMsg,(LPTSTR) szLoadStringTemp,MAX_PATH);
            wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,HRESULT_CODE(hres));

            lstrcat((LPTSTR) szErrorMessage,(LPTSTR) szErrorTitle);
        }
    }

    MLLoadString(IDS_ERROR,(LPTSTR) szErrorTitle,MAX_PATH);
    MessageBox(NULL,(LPCTSTR) szErrorMessage,(LPCTSTR) szErrorTitle,MB_OK|MB_ICONERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesByURL class
//*
//*******************************************************************

PICSRulesByURL::PICSRulesByURL()
{
    //nothing to do
}

PICSRulesByURL::~PICSRulesByURL()
{
    m_arrpPRByURL.DeleteAll();
}

PICSRulesEvaluation PICSRulesByURL::EvaluateRule(PICSRulesQuotedURL *pprurlComparisonURL)
{
    int                         iCounter;
    URL_COMPONENTS              URLComponents;
    FN_INTERNETCRACKURL         pfnInternetCrackUrl;
    INTERNET_SCHEME             INetScheme=INTERNET_SCHEME_DEFAULT;
    INTERNET_PORT               INetPort=INTERNET_INVALID_PORT_NUMBER;
    LPSTR                       lpszScheme,lpszHostName,lpszUserName,
                                lpszPassword,lpszUrlPath,lpszExtraInfo;
    BOOL                        fApplies=FALSE;

    lpszScheme=new char[INTERNET_MAX_SCHEME_LENGTH+1];
    lpszHostName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUserName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszPassword=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUrlPath=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszExtraInfo=new char[INTERNET_MAX_PATH_LENGTH+1];

    if(lpszScheme==NULL ||
       lpszHostName==NULL ||
       lpszUserName==NULL ||
       lpszPassword==NULL ||
       lpszUrlPath==NULL ||
       lpszExtraInfo==NULL)
    {
        if (lpszScheme)
        {
            delete [] lpszScheme;
            lpszScheme = NULL;
        }

        if (lpszHostName)
        {
            delete [] lpszHostName;
            lpszHostName = NULL;
        }

        if (lpszUserName)
        {
            delete [] lpszUserName;
            lpszUserName = NULL;
        }

        if (lpszPassword)
        {
            delete [] lpszPassword;
            lpszPassword = NULL;
        }

        if (lpszUrlPath)
        {
            delete [] lpszUrlPath;
            lpszUrlPath = NULL;
        }

        if (lpszExtraInfo)
        {
            delete [] lpszExtraInfo;
            lpszExtraInfo = NULL;
        }

        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    URLComponents.dwStructSize=sizeof(URL_COMPONENTS);
    URLComponents.lpszScheme=lpszScheme;
    URLComponents.dwSchemeLength=INTERNET_MAX_SCHEME_LENGTH;
    URLComponents.nScheme=INetScheme;
    URLComponents.lpszHostName=lpszHostName;
    URLComponents.dwHostNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.nPort=INetPort;
    URLComponents.lpszUserName=lpszUserName;
    URLComponents.dwUserNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszPassword=lpszPassword;
    URLComponents.dwPasswordLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszUrlPath=lpszUrlPath;
    URLComponents.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszExtraInfo=lpszExtraInfo;
    URLComponents.dwExtraInfoLength=INTERNET_MAX_PATH_LENGTH;

    pfnInternetCrackUrl=(FN_INTERNETCRACKURL) GetProcAddress(g_hWININET,"InternetCrackUrlA");

    if(pfnInternetCrackUrl==NULL)
    {
        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    pfnInternetCrackUrl(pprurlComparisonURL->Get(),0,ICU_DECODE,&URLComponents);

    for(iCounter=0;iCounter<m_arrpPRByURL.Length();iCounter++)
    {
        PICSRulesByURLExpression * pPRByURLExpression;

        pPRByURLExpression=m_arrpPRByURL[iCounter];

        //schemes must be specified as per the spec, so there is no need to check
        //the m_bSpecified flag against BYURL_SCHEME

        //if the scheme is non-wild then we match against exact strings only, the
        //match is case insensitive as per the spec
        if(pPRByURLExpression->m_bNonWild&BYURL_SCHEME)
        {
            if(lstrcmp(lpszScheme,pPRByURLExpression->m_etstrScheme.Get())!=0)
            {
                continue;
            }
        }

        //if the user name is omitted we only match if the url navigated to also
        //had the user name omitted
        if(!(pPRByURLExpression->m_bSpecified&BYURL_USER))
        {
            if(*lpszUserName!=NULL)
            {
                continue;
            }
        }
        else if(pPRByURLExpression->m_bNonWild&BYURL_USER)
        {
            int     iLength;
            char    * lpszCurrent,lpszCompare[INTERNET_MAX_URL_LENGTH+1],
                    lpszCopy[INTERNET_MAX_URL_LENGTH+1];
            BOOL    fFrontWild=0,fBackWild=0,fFrontEscaped=0,fBackEscaped=0;

            //if the user was specified we match a '*' at the beginning as wild, a '*'
            //at the end as wild, and '%*' matches aginst the character '*', this
            //comparison is case sensitive

            lstrcpy(lpszCompare,pPRByURLExpression->m_etstrUser.Get());
            
            iLength=lstrlen(lpszCompare);

            if(lpszCompare[0]=='*')
            {
                fFrontWild=1;
            }
            
            if(lpszCompare[iLength-1]=='*')
            {
                fBackWild=1;
                
                lpszCompare[iLength-1]='\0';
            }

            if((lpszCompare[0]=='%')&&(lpszCompare[1]=='*'))
            {
                fFrontEscaped=1;
            }

            if((lpszCompare[iLength-2]=='%')&&fBackWild)
            {
                fBackWild=0;
                fBackEscaped=1;

                lpszCompare[iLength-2]='*';
            }

            lpszCurrent=lpszCompare+fFrontWild+fFrontEscaped;

            lstrcpy(lpszCopy,lpszCurrent);

            if(fFrontWild==1)
            {
                lpszCurrent=strstrf(lpszUserName,lpszCopy);
                
                if(lpszCurrent!=NULL)
                {
                    if(fBackWild==0)
                    {
                        if(lstrcmp(lpszCurrent,lpszUserName)!=0)
                        {
                            continue;
                        }
                    }
                }
                else
                {
                    continue;
                }
            }
            else
            {
                if(fBackWild==1)
                {
                    lpszUserName[lstrlen(lpszCopy)]='\0';
                }

                if(lstrcmp(lpszUserName,lpszCopy)!=0)
                {
                    continue;
                }
            }
        }

        //the host (or ipwild) must always be specified, so there is no need to
        //check against m_bSpecified

        //the host is either an ipwild (i.e. #.#.#.#!#) or a URL substring.  If
        //we have an ipwild, then we have to first resolve the site being browsed
        //to to a set of IP addresses.  We consider it a match if we match any
        //of those IPs.  If the host is an URL substring, then the first character
        //being a '*' matches any number of characters, and being '%*' matches '*'
        //itself.  Everything further must match exactly.  The compare is case-
        //insensitive.
        if(pPRByURLExpression->m_bNonWild&BYURL_HOST)
        {
            BOOL        fFrontWild=0,fWasIpWild=FALSE,fNoneMatched=TRUE;
            DWORD       dwIpRules=0;
            char        * lpszCurrent;

            lpszCurrent=pPRByURLExpression->m_etstrHost.Get();

            if((lpszCurrent[0]>='0')&&(lpszCurrent[0]<='9'))
            {
                //make a copy of the string since we are going to delete the masking '!'
                //to test for an ipwild
                char * lpszMask;
                char lpszIpWild[INTERNET_MAX_PATH_LENGTH+1];
                int  iBitMask=(sizeof(DWORD)*8);
                
                lstrcpy(lpszIpWild,lpszCurrent);

                lpszMask=strchrf(lpszIpWild,'!');

                if(lpszMask!=NULL)
                {
                    *lpszMask='\0';
                    lpszMask++;

                    ParseNumber(&lpszMask,&iBitMask,TRUE);
                }

                //test for an ipwild case
                dwIpRules = inet_addr(lpszIpWild);
                if(dwIpRules != INADDR_NONE)
                {
                    //we definately have an ipwild
                    array<DWORD*>      arrpIpCompare;
                    HOSTENT            * pHostEnt;
                    int                iCounter;

                    fWasIpWild=TRUE;

                    pHostEnt=gethostbyname(lpszHostName);

                    if(pHostEnt!=NULL)
                    {
                        char *lpszHosts;

                        lpszHosts=pHostEnt->h_addr_list[0];

                        iCounter=0;

                        while(lpszHosts!=NULL)
                        {
                            DWORD *pdwIP;
    
                            pdwIP=new DWORD;

                            *pdwIP=*((DWORD *) lpszHosts);

                            arrpIpCompare.Append(pdwIP);

                            iCounter++;

                            lpszHosts=pHostEnt->h_addr_list[iCounter];
                        }
                    }

                    //we've got all the IPs to test against, so lets do it
                    for(iCounter=0;iCounter<arrpIpCompare.Length();iCounter++)
                    {
                        DWORD dwIpCompare;
                        int   iBitCounter;
                        BOOL  fMatched;
                        
                        dwIpCompare=*(arrpIpCompare[iCounter]);
                        fMatched=TRUE;

                        //compare the first iBitMask bits as per the spec
                        for(iBitCounter=0;
                            iBitCounter<iBitMask;
                            iBitCounter++)
                        {
                            int iPower;
                            DWORD dwMask=1;

                            for(iPower=0;iPower<iBitCounter;iPower++)
                            {
                                dwMask*=2;
                            }

                            if((dwIpRules&dwMask)!=(dwIpCompare&dwMask))
                            {
                                //they don't match
                                fMatched=FALSE;

                                break;
                            }
                        }

                        if(fMatched==TRUE)
                        {
                            fNoneMatched=FALSE;

                            break;
                        }
                    }
                }
            }

            if(fWasIpWild)
            {
                if(fNoneMatched)
                {
                    //if none matched, we don't apply, so continue to the next
                    //iteration of the loop
                    continue;
                }
            }
            else
            {
                if((lpszCurrent[0]=='%')&&(lpszCurrent[1]=='*'))
                {
                    lpszCurrent++;
                }
                else if (lpszCurrent[0]=='*')
                {
                    fFrontWild=1;
                    lpszCurrent++;
                }
        
                if(fFrontWild==1)
                {
                    char * lpszTest;

                    lpszTest=strstrf(lpszHostName,lpszCurrent);

                    if(lstrcmpi(lpszTest,lpszCurrent)!=0)
                    {
                        continue;
                    }
                }
                else
                {
                    if(lstrcmpi(lpszHostName,lpszCurrent)!=0)
                    {
                        continue;
                    }
                }
            }
        }
        
        //if the port is ommitted, we only match if the port was also ommitted in
        //the URL being browsed to.
        if(!(pPRByURLExpression->m_bSpecified&BYURL_PORT))
        {
            if(URLComponents.nPort!=INTERNET_INVALID_PORT_NUMBER)
            {
                char * lpszCheck;

                //URLComponents.nPort gets filled in anyway due to the scheme, so
                //check it against the string itself

                lpszCheck=strstrf(pprurlComparisonURL->Get(),lpszHostName);

                if(lpszCheck!=NULL)
                {
                    lpszCheck+=lstrlen(lpszHostName);

                    if(*lpszCheck==':')
                    {
                        continue;
                    }
                }
            }
        }
        else if(pPRByURLExpression->m_bNonWild&BYURL_PORT)
        {
            char * lpszPort,* lpszRange;

            //the port can be a single number or a range, with wild cards at both ends
            //of the range

            lpszPort=pPRByURLExpression->m_etstrPort.Get();

            lpszRange=strchrf(lpszPort,'-');
            
            if(lpszRange==NULL)
            {
                int iPort;

                //we've got a single port

                ParseNumber(&lpszPort,&iPort,TRUE);

                if(iPort!=URLComponents.nPort)
                {
                    continue;
                }
            }
            else
            {
                int iLow,iHigh;

                *lpszRange='\0';
                lpszRange++;

                if(*lpszPort=='*')
                {
                    iLow=0;
                }
                else
                {
                    ParseNumber(&lpszPort,&iLow,TRUE);
                }

                if(*lpszRange=='*')
                {
                    iHigh=INTERNET_MAX_PORT_NUMBER_VALUE;
                }
                else
                {
                    ParseNumber(&lpszRange,&iHigh,TRUE);
                }

                if((URLComponents.nPort>iHigh)||URLComponents.nPort<iLow)
                {
                    continue;
                }
            }
        }

        //if the path is ommitted, we only match if the path was also ommitted in
        //the URL being browsed to.
        if(!(pPRByURLExpression->m_bSpecified&BYURL_PATH))
        {
            if(*lpszUrlPath!=NULL)
            {
                if(!((*lpszUrlPath=='/')&&(*(lpszUrlPath+1)==NULL)))
                {
                    continue;
                }
            }
        }
        else if(pPRByURLExpression->m_bNonWild&BYURL_PATH)
        {
            int     iLength;
            char    * lpszCurrent,lpszCompare[INTERNET_MAX_URL_LENGTH+1],
                    lpszCopy[INTERNET_MAX_URL_LENGTH+1],* lpszUrlCheck,
                    * lpszPreCompare;
            BOOL    fFrontWild=0,fBackWild=0,fFrontEscaped=0,fBackEscaped=0;

            //if the path was specified we match a '*' at the beginning as wild, a '*'
            //at the end as wild, and '%*' matches aginst the character '*', this
            //comparison is case sensitive

            //kill leading slashes
            if(*lpszUrlPath=='/')
            {
                lpszUrlCheck=lpszUrlPath+1;
            }
            else
            {
                lpszUrlCheck=lpszUrlPath;
            }

            iLength=lstrlen(lpszUrlCheck);

            //kill trailing slashes
            if(lpszUrlCheck[iLength-1]=='/')
            {
                lpszUrlCheck[iLength-1]='\0';
            }

            lpszPreCompare=pPRByURLExpression->m_etstrPath.Get();

            //kill leading slashes
            if(*lpszPreCompare=='/')
            {
                lstrcpy(lpszCompare,lpszPreCompare+1);
            }
            else
            {
                lstrcpy(lpszCompare,lpszPreCompare);
            }
            
            iLength=lstrlen(lpszCompare);

            //kill trailing slashes
            if(lpszCompare[iLength-1]=='/')
            {
                lpszCompare[iLength-1]='\0';
            }

            if(lpszCompare[0]=='*')
            {
                fFrontWild=1;
            }
            
            if(lpszCompare[iLength-1]=='*')
            {
                fBackWild=1;
                
                lpszCompare[iLength-1]='\0';
            }

            if((lpszCompare[0]=='%')&&(lpszCompare[1]=='*'))
            {
                fFrontEscaped=1;
            }

            if((lpszCompare[iLength-2]=='%')&&fBackWild)
            {
                fBackWild=0;
                fBackEscaped=1;

                lpszCompare[iLength-2]='*';
            }

            lpszCurrent=lpszCompare+fFrontWild+fFrontEscaped;

            lstrcpy(lpszCopy,lpszCurrent);

            if(fFrontWild==1)
            {
                lpszCurrent=strstrf(lpszUrlCheck,lpszCopy);
                
                if(lpszCurrent!=NULL)
                {
                    if(fBackWild==0)
                    {
                        if(lstrcmp(lpszCurrent,lpszUrlCheck)!=0)
                        {
                            continue;
                        }
                    }
                }
                else
                {
                    continue;
                }
            }
            else
            {
                if(fBackWild==1)
                {
                    lpszUrlCheck[lstrlen(lpszCopy)]='\0';
                }

                if(lstrcmp(lpszUrlCheck,lpszCopy)!=0)
                {
                    continue;
                }
            }
        }

        //if we made it this far we do apply!
        fApplies=TRUE;
        
        break;
    }

    delete lpszScheme;
    lpszScheme = NULL;
    delete lpszHostName;
    lpszHostName = NULL;
    delete lpszUserName;
    lpszUserName = NULL;
    delete lpszPassword;
    lpszPassword = NULL;
    delete lpszUrlPath;
    lpszUrlPath = NULL;
    delete lpszExtraInfo;
    lpszExtraInfo = NULL;
    
    if(fApplies==TRUE)
    {
        return(PR_EVALUATION_DOESAPPLY);
    }
    else
    {
        return(PR_EVALUATION_DOESNOTAPPLY);
    }
}

//*******************************************************************
//*
//* Code for the PICSRulesFileParser class
//*
//*******************************************************************

//FindNonWhite returns a pointer to the first non-whitespace
//character starting at pc.
char* PICSRulesFileParser::FindNonWhite(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        if (*pc == '\n')

        m_nLine++;
        pc++;
    }
}

//Returns a pointer to the closing quotation mark of a quoted
//string, counting linefeeds as we go.  Returns NULL if no closing
//quotation mark is found.
//
//fQuote can be either PR_QUOTE_DOUBLE or PR_QUOTE_SINGLE
//defaults to PR_QUOTE_DOUBLE.
LPSTR PICSRulesFileParser::EatQuotedString(LPSTR pIn,BOOL fQuote)
{
    LPSTR pszQuote;

    if(fQuote==PR_QUOTE_DOUBLE)
    {
        pszQuote=strchrf(pIn,'\"');
    }
    else
    {
        pszQuote=strchrf(pIn,'\'');
    }

    if (pszQuote == NULL)
    {
        return NULL;
    }

    pIn=strchrf(pIn,'\n');
    while ((pIn!=NULL)&&(pIn<pszQuote))
    {
        m_nLine++;
        pIn=strchrf(pIn+1,'\n');
    }

    return pszQuote;
}

//ParseToOpening eats the opening '(' of a parenthesized object, and
//verifies that the token just inside it is one of the expected ones.
//If so, *ppIn is advanced past that token to the next non-whitespace
//character;  otherwise, an error is returned.
//
//For example, if *ppIn is pointing at "(PicsRule-1.1)", and
//PROID_PICSVERSION is in the allowable option table supplied, then
//NOERROR is returned and *ppIn will point at "1.1)".
//
//If the function is successful, *ppFound is set to point to the element
//in the allowable-options table which matches the type of thing this
//object actually is.
HRESULT PICSRulesFileParser::ParseToOpening(LPSTR *ppIn,
                                            PICSRulesAllowableOption *paoExpected,
                                            PICSRulesAllowableOption **ppFound)
{
    LPSTR lpszCurrent=*ppIn;

    lpszCurrent=FindNonWhite(lpszCurrent);
    
    if(*lpszCurrent=='(')
    {
        lpszCurrent=FindNonWhite(lpszCurrent+1);    //skip ( and whitespace
    }

    if((*lpszCurrent=='\"')||(*lpszCurrent=='\''))
    {
        //we found a default option section, treat it as a string and return
        //ppFound set to PROID_NAMEDEFAULT

        paoExpected->roid=PROID_NAMEDEFAULT;
        *ppFound=paoExpected;
        *ppIn=lpszCurrent;

        return NOERROR;
    }

    LPSTR lpszTokenEnd=FindTokenEnd(lpszCurrent);

    for(;paoExpected->roid!=PROID_INVALID;paoExpected++)
    {
        LPCSTR lpszThisToken=aPRObjectDescriptions[paoExpected->roid].lpszToken;

        if(paoExpected->roid==PROID_EXTENSION)
        {
            LPTSTR lpszDot;

            lpszDot=strchrf(lpszCurrent,'.');

            if(lpszDot!=NULL)
            {
                *lpszDot='\0';

                if(IsOptExtensionDefined(lpszCurrent)==TRUE)
                {
                    *lpszDot='.';

                    lpszTokenEnd=lpszCurrent;

                    break;
                }

                if(IsReqExtensionDefined(lpszCurrent)==TRUE)
                {
                    //currently no extensions are supported so we return
                    //an error on a required extension.
                    //if support for extensions is implemented
                    //this should be identical to above with a different
                    //callback for reqextensions defined.

                    return(PICSRULES_E_REQEXTENSIONUSED);
                }
            }
        }

        if(IsEqualToken(lpszCurrent,lpszTokenEnd,lpszThisToken))
        {
            break;
        }
    }

    if(paoExpected->roid!=PROID_INVALID)
    {
        *ppIn=FindNonWhite(lpszTokenEnd);       //skip token and whitespace
        *ppFound=paoExpected;
        
        return NOERROR;
    }
    else
    {
        return PICSRULES_E_UNKNOWNITEM;
    }
}

//ParseParenthesizedObjectContents is called with a text pointer pointing at
//the first non-whitespace thing following the token identifying the type of
//object.  It parses the rest of the contents of the object, up to and
//including the ')' which closes it.  The array of PICSRulesAllowableOption
//structures specifies which understood options are allowed to occur within
//this object.
HRESULT PICSRulesFileParser::ParseParenthesizedObject(LPSTR *ppIn,
                                                      PICSRulesAllowableOption aao[],
                                                      PICSRulesObjectBase *pObject)
{
    PICSRulesAllowableOption *pFound;

    HRESULT hres=S_OK;
    LPSTR pszCurrent=*ppIn;

    for(pFound=aao;pFound->roid!=PROID_INVALID;pFound++)
    {
        pFound->fdwOptions&=~AO_SEEN;
    }

    pFound=NULL;

    while((*pszCurrent!=')')&&(*pszCurrent!='\0')&&(SUCCEEDED(hres)))
    {
        hres=ParseToOpening(&pszCurrent,aao,&pFound);

        if(SUCCEEDED(hres))
        {
            LPVOID pData;

            hres=(*(aPRObjectDescriptions[pFound->roid].pHandler))(&pszCurrent,&pData,this);
            
            if(SUCCEEDED(hres))
            {
                if((pFound->fdwOptions&(AO_SINGLE|AO_SEEN))==(AO_SINGLE|AO_SEEN))
                {
                    hres=PICSRULES_E_DUPLICATEITEM;
                }
                else
                {
                    pFound->fdwOptions|=AO_SEEN;
                    
                    hres=pObject->AddItem(pFound->roid,pData);
                    
                    if(SUCCEEDED(hres))
                    {
                        pszCurrent=FindNonWhite(pszCurrent);
                    }
                }
            }
        }
    }

    if(FAILED(hres))
    {
        return hres;
    }

    for(pFound=aao;pFound->roid!=PROID_INVALID;pFound++)
    {
        if((pFound->fdwOptions&(AO_MANDATORY|AO_SEEN))==AO_MANDATORY)
        {
            return(PICSRULES_E_MISSINGITEM);        //mandatory item not found
        }
    }

    pszCurrent=FindNonWhite(pszCurrent+1);  //skip the closing parenthesis
    *ppIn=pszCurrent;

    return(hres);
}

//*******************************************************************
//*
//* Code for the PICSRulesName class
//*
//*******************************************************************

PICSRulesName::PICSRulesName()
{
    //just need to construct members
}

PICSRulesName::~PICSRulesName()
{
    //nothing to do
}

HRESULT PICSRulesName::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_RULENAME:
        {
            m_etstrRuleName.SetTo((char *) pData);
            
            break;
        }
        case PROID_DESCRIPTION:
        {
            m_etstrDescription.SetTo((char *) pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesName::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesOptExtension class
//*
//*******************************************************************

PICSRulesOptExtension::PICSRulesOptExtension()
{
    //nothing to do
}

PICSRulesOptExtension::~PICSRulesOptExtension()
{
    //nothing to do
}

HRESULT PICSRulesOptExtension::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_EXTENSIONNAME:
        {
            m_prURLExtensionName.SetTo((char *) pData);
            
            if(m_prURLExtensionName.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_SHORTNAME:
        {
            m_etstrShortName.SetTo((char *) pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesOptExtension::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesPassFail class
//*
//*******************************************************************

PICSRulesPassFail::PICSRulesPassFail()
{
    m_fPassOrFail=PR_PASSFAIL_PASS;
}

PICSRulesPassFail::~PICSRulesPassFail()
{
    //nothing to do
}

void PICSRulesPassFail::Set(const BOOL *pIn)
{
    switch(*pIn)
    {
        case PR_PASSFAIL_PASS:
        {
            ETS::Set(szPRPass);
            m_fPassOrFail=PR_PASSFAIL_PASS;

            break;
        }
        case PR_PASSFAIL_FAIL:
        {
            ETS::Set(szPRFail);
            m_fPassOrFail=PR_PASSFAIL_FAIL;

            break;
        }
    }
}

void PICSRulesPassFail::SetTo(BOOL *pIn)
{
    Set(pIn);
}

//*******************************************************************
//*
//* Code for the PICSRulesPolicy class
//*
//*******************************************************************

PICSRulesPolicy::PICSRulesPolicy()
{
    m_PRPolicyAttribute=PR_POLICY_NONEVALID;
}

PICSRulesPolicy::~PICSRulesPolicy()
{
    switch(m_PRPolicyAttribute)
    {
        case PR_POLICY_REJECTBYURL:
        {
            if(m_pPRRejectByURL!=NULL)
            {
                delete m_pPRRejectByURL;
                m_pPRRejectByURL = NULL;
            }
            break;
        }
        case PR_POLICY_ACCEPTBYURL:
        {
            if(m_pPRAcceptByURL!=NULL)
            {
                delete m_pPRAcceptByURL;
                m_pPRAcceptByURL = NULL;
            }
            break;
        }
        case PR_POLICY_REJECTIF:
        {
            if(m_pPRRejectIf!=NULL)
            {
                delete m_pPRRejectIf;
                m_pPRRejectIf = NULL;
            }
            break;
        }
        case PR_POLICY_ACCEPTIF:
        {
            if(m_pPRAcceptIf!=NULL)
            {
                delete m_pPRAcceptIf;
                m_pPRAcceptIf = NULL;
            }
            break;
        }
        case PR_POLICY_REJECTUNLESS:
        {
            if(m_pPRRejectUnless!=NULL)
            {
                delete m_pPRRejectUnless;
                m_pPRRejectUnless = NULL;
            }
            break;
        }
        case PR_POLICY_ACCEPTUNLESS:
        {
            if(m_pPRAcceptUnless!=NULL)
            {
                delete m_pPRAcceptUnless;
                m_pPRAcceptUnless = NULL;
            }
            break;
        }
        case PR_POLICY_NONEVALID:
        default:
        {
            break;
        }
    }
}

HRESULT PICSRulesPolicy::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_EXPLANATION:
        {
            m_etstrExplanation.SetTo((char *) pData);
            
            break;
        }
        case PROID_REJECTBYURL:
        {
            m_pPRRejectByURL=((PICSRulesByURL *) pData);
            m_PRPolicyAttribute=PR_POLICY_REJECTBYURL;

            break;
        }
        case PROID_ACCEPTBYURL:
        {
            m_pPRAcceptByURL=((PICSRulesByURL *) pData);
            m_PRPolicyAttribute=PR_POLICY_ACCEPTBYURL;

            break;
        }
        case PROID_REJECTIF:
        {
            m_pPRRejectIf=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_REJECTIF;

            break;
        }
        case PROID_ACCEPTIF:
        {
            m_pPRAcceptIf=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_ACCEPTIF;

            break;
        }
        case PROID_REJECTUNLESS:
        {
            m_pPRRejectUnless=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_REJECTUNLESS;

            break;
        }
        case PROID_ACCEPTUNLESS:
        {
            m_pPRAcceptUnless=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_ACCEPTUNLESS;

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesPolicy::InitializeMyDefaults()
{
    return(NOERROR);    //no defaults to initialize
}

//*******************************************************************
//*
//* Code for the PICSRulesPolicyExpression class
//*
//*******************************************************************

PICSRulesPolicyExpression::PICSRulesPolicyExpression()
{
    m_PRPEPolicyEmbedded=       PR_POLICYEMBEDDED_NONE;
    m_PROPolicyOperator=        PR_OPERATOR_INVALID;
    m_pPRPolicyExpressionLeft=  NULL;
    m_pPRPolicyExpressionRight= NULL;
}

PICSRulesPolicyExpression::~PICSRulesPolicyExpression()
{
    if(m_PRPEPolicyEmbedded!=PR_POLICYEMBEDDED_NONE)    //do we need to delete an
                                                        //embedded PolicyExpression?
    {
        if(m_pPRPolicyExpressionLeft!=NULL)             //double check, just to make sure
        {
            delete m_pPRPolicyExpressionLeft;
            m_pPRPolicyExpressionLeft = NULL;
        }
        if(m_pPRPolicyExpressionRight!=NULL)            //double check, just to make sure
        {
            delete m_pPRPolicyExpressionRight;
            m_pPRPolicyExpressionRight = NULL;
        }
    }
}

PICSRulesEvaluation PICSRulesPolicyExpression::EvaluateRule(CParsedLabelList *pParsed)
{
    PICSRulesEvaluation PREvaluationResult;

    if((pParsed==NULL)||(m_PROPolicyOperator==PR_OPERATOR_DEGENERATE))
    {
        //we can't apply if there is no label, and we
        //don't handle the degenerate case since we have
        //to pass on to the PICS handler

        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    if((m_prYesNoUseEmbedded.GetYesNo()==PR_YESNO_NO)&&(g_dwDataSource==PICS_LABEL_FROM_PAGE))
    {
        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    switch(m_PRPEPolicyEmbedded)
    {
        case PR_POLICYEMBEDDED_NONE:
        {
            switch(m_PROPolicyOperator)
            {
                case PR_OPERATOR_GREATEROREQUAL:
                case PR_OPERATOR_GREATER:
                case PR_OPERATOR_EQUAL:
                case PR_OPERATOR_LESSOREQUAL:
                case PR_OPERATOR_LESS:
                {
                    LPCSTR             lpszTest;
                    CParsedServiceInfo * pCParsedServiceInfo;
                    CParsedRating      * pCParsedRating;
                    
                    PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                    pCParsedServiceInfo=&(pParsed->m_ServiceInfo);
                    
                    do
                    {
                        lpszTest=pCParsedServiceInfo->m_pszServiceName;

                        if(lstrcmp(lpszTest,m_etstrFullServiceName.Get())==0)
                        {
                            PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                            
                            break;
                        }

                        pCParsedServiceInfo=pCParsedServiceInfo->Next();
                    } while (pCParsedServiceInfo!=NULL);

                    if(PREvaluationResult==PR_EVALUATION_DOESAPPLY)
                    {
                        int iCounter;

                        PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                        //we've got the service, now check for the category

                        for(iCounter=0;iCounter<pCParsedServiceInfo->aRatings.Length();iCounter++)
                        {
                            pCParsedRating=&(pCParsedServiceInfo->aRatings[iCounter]);

                            if(lstrcmp(pCParsedRating->pszTransmitName,m_etstrCategoryName.Get())==0)
                            {
                                PREvaluationResult=PR_EVALUATION_DOESAPPLY;

                                break;
                            }
                        }
                    }

                    if(PREvaluationResult==PR_EVALUATION_DOESAPPLY)
                    {
                        int iLabelValue;
                        
                        iLabelValue=pCParsedRating->nValue;

                        //now check the values
                        PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                        switch(m_PROPolicyOperator)
                        {
                            case PR_OPERATOR_GREATEROREQUAL:
                            {
                                if(iLabelValue>=m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_GREATER:
                            {
                                if(iLabelValue>m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_EQUAL:
                            {
                                if(iLabelValue==m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_LESSOREQUAL:
                            {
                                if(iLabelValue<=m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_LESS:
                            {
                                if(iLabelValue<m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                        }
                    }

                    break;
                }
                case PR_OPERATOR_SERVICEONLY:
                {
                    LPCSTR             lpszTest;
                    CParsedServiceInfo * pCParsedServiceInfo;
                    
                    PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                    pCParsedServiceInfo=&(pParsed->m_ServiceInfo);
                    
                    do
                    {
                        lpszTest=pCParsedServiceInfo->m_pszServiceName;

                        if(lstrcmp(lpszTest,m_etstrFullServiceName.Get())==0)
                        {
                            PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                            
                            break;
                        }

                        pCParsedServiceInfo=pCParsedServiceInfo->Next();
                    } while (pCParsedServiceInfo!=NULL);

                    break;
                }
                case PR_OPERATOR_SERVICEANDCATEGORY:
                {
                    LPCSTR             lpszTest;
                    CParsedServiceInfo * pCParsedServiceInfo;
                    
                    PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                    pCParsedServiceInfo=&(pParsed->m_ServiceInfo);
                    
                    do
                    {
                        lpszTest=pCParsedServiceInfo->m_pszServiceName;

                        if(lstrcmp(lpszTest,m_etstrFullServiceName.Get())==0)
                        {
                            PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                            
                            break;
                        }

                        pCParsedServiceInfo=pCParsedServiceInfo->Next();
                    } while (pCParsedServiceInfo!=NULL);

                    if(PREvaluationResult==PR_EVALUATION_DOESAPPLY)
                    {
                        int iCounter;

                        PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                        //we've got the service, now check for the category

                        for(iCounter=0;iCounter<pCParsedServiceInfo->aRatings.Length();iCounter++)
                        {
                            CParsedRating * pCParsedRating;

                            pCParsedRating=&(pCParsedServiceInfo->aRatings[iCounter]);

                            if(lstrcmp(pCParsedRating->pszTransmitName,m_etstrCategoryName.Get())==0)
                            {
                                PREvaluationResult=PR_EVALUATION_DOESAPPLY;

                                break;
                            }
                        }
                    }

                    break;
                }
            }

            break;
        }
        case PR_POLICYEMBEDDED_OR:
        {
            PICSRulesEvaluation PREvaluationIntermediate;

            PREvaluationIntermediate=m_pPRPolicyExpressionLeft->EvaluateRule(pParsed);

            if(PREvaluationIntermediate==PR_EVALUATION_DOESAPPLY)
            {
                PREvaluationResult=PR_EVALUATION_DOESAPPLY;

                break;
            }
            else
            {
                PREvaluationResult=m_pPRPolicyExpressionRight->EvaluateRule(pParsed);
            }
            
            break;
        }
        case PR_POLICYEMBEDDED_AND:
        {
            PICSRulesEvaluation PREvaluationIntermediate;

            PREvaluationIntermediate=m_pPRPolicyExpressionLeft->EvaluateRule(pParsed);

            PREvaluationResult=m_pPRPolicyExpressionRight->EvaluateRule(pParsed);

            if((PREvaluationIntermediate==PR_EVALUATION_DOESAPPLY)&&
               (PREvaluationResult==PR_EVALUATION_DOESAPPLY))
            {
                break;
            }
            else
            {
                PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;
            }

            break;
        }
    }

    return(PREvaluationResult);
}

//*******************************************************************
//*
//* Code for the PICSRulesQuotedDate class
//*
//*******************************************************************

PICSRulesQuotedDate::PICSRulesQuotedDate()
{
    m_dwDate=0;
}

PICSRulesQuotedDate::~PICSRulesQuotedDate()
{
    //nothing to do
}

HRESULT PICSRulesQuotedDate::Set(const char *pIn)
{
    HRESULT hRes;
    DWORD   dwDate;

    hRes=ParseTime((char *) pIn,&dwDate);

    if(FAILED(hRes))
    {
        return(E_INVALIDARG);
    }

    m_dwDate=dwDate;

    ETS::Set(pIn);

    return(S_OK);
}

HRESULT PICSRulesQuotedDate::SetTo(char *pIn)
{
    HRESULT hRes;
    DWORD   dwDate;

    hRes=ParseTime(pIn,&dwDate,TRUE);

    if(FAILED(hRes))
    {
        return(E_INVALIDARG);
    }

    m_dwDate=dwDate;

    ETS::SetTo(pIn);

    return(S_OK);
}

BOOL PICSRulesQuotedDate::IsDateValid()
{
    if(m_dwDate)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOL PICSRulesQuotedDate::IsDateValid(char * lpszDate)
{
    HRESULT hRes;
    DWORD   dwDate;

    hRes=ParseTime(lpszDate,&dwDate);

    if(SUCCEEDED(hRes))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOL PICSRulesQuotedDate::IsDateValid(ETS etstrDate)
{
    HRESULT hRes;
    DWORD   dwDate;
    LPTSTR  lpszDate;

    lpszDate=etstrDate.Get();

    hRes=ParseTime(lpszDate,&dwDate);

    if(SUCCEEDED(hRes))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

//*******************************************************************
//*
//* Code for the PICSRulesQuotedEmail class
//*
//*******************************************************************

PICSRulesQuotedEmail::PICSRulesQuotedEmail()
{
    //nothing to do
}

PICSRulesQuotedEmail::~PICSRulesQuotedEmail()
{
    //nothing to do
}

BOOL PICSRulesQuotedEmail::IsEmailValid()
{
    //We don't use this internally, so as far as we are concerned
    //its always valid.
    //If we ever add UI that displays this, we can defer verification
    //of the email address to the mail client by sticking a mailto://
    //in front of our string

    return(TRUE);
}

BOOL PICSRulesQuotedEmail::IsEmailValid(char * lpszEmail)
{
    //We don't use this internally, so as far as we are concerned
    //its always valid.
    //If we ever add UI that displays this, we can defer verification
    //of the email address to the mail client by sticking a mailto://
    //in front of our string

    return(TRUE);
}

BOOL PICSRulesQuotedEmail::IsEmailValid(ETS etstrEmail)
{
    //We don't use this internally, so as far as we are concerned
    //its always valid.
    //If we ever add UI that displays this, we can defer verification
    //of the email address to the mail client by sticking a mailto://
    //in front of our string

    return(TRUE);
}

//*******************************************************************
//*
//* Code for the PICSRulesQuotedURL class
//*
//*******************************************************************

PICSRulesQuotedURL::PICSRulesQuotedURL()
{
    //nothing to do
}

PICSRulesQuotedURL::~PICSRulesQuotedURL()
{
    //nothing to do
}

BOOL IsURLValid(WCHAR wcszURL[INTERNET_MAX_URL_LENGTH])
{
    FN_ISVALIDURL   pfnIsValidURL;

    pfnIsValidURL=(FN_ISVALIDURL) GetProcAddress(g_hURLMON,"IsValidURL");

    if(pfnIsValidURL==NULL)
    {
        return(FALSE);
    }

    if(pfnIsValidURL(NULL,wcszURL,0)==S_OK)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOL PICSRulesQuotedURL::IsURLValid()
{
    char            * lpszURL;
    WCHAR           wcszURL[INTERNET_MAX_URL_LENGTH];

    lpszURL=Get();

    MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,lpszURL,-1,wcszURL,INTERNET_MAX_URL_LENGTH);
    
    return(::IsURLValid(wcszURL));
}

BOOL PICSRulesQuotedURL::IsURLValid(char * lpszURL)
{
    WCHAR           wcszURL[INTERNET_MAX_URL_LENGTH];

    MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,lpszURL,-1,wcszURL,INTERNET_MAX_URL_LENGTH);

    return(::IsURLValid(wcszURL));
}

BOOL PICSRulesQuotedURL::IsURLValid(ETS etstrURL)
{
    char            * lpszURL;
    WCHAR           wcszURL[INTERNET_MAX_URL_LENGTH];

    lpszURL=etstrURL.Get();

    MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,lpszURL,-1,wcszURL,INTERNET_MAX_URL_LENGTH);

    return(::IsURLValid(wcszURL));
}

//*******************************************************************
//*
//* Code for the PICSRulesReqExtension class
//*
//*******************************************************************

PICSRulesReqExtension::PICSRulesReqExtension()
{
    //nothing to do
}

PICSRulesReqExtension::~PICSRulesReqExtension()
{
    //nothing to do
}

HRESULT PICSRulesReqExtension::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_EXTENSIONNAME:
        {
            m_prURLExtensionName.SetTo((char *) pData);
            
            if(m_prURLExtensionName.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_SHORTNAME:
        {
            m_etstrShortName.SetTo((char *) pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesReqExtension::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesServiceInfo class
//*
//*******************************************************************

PICSRulesServiceInfo::PICSRulesServiceInfo()
{
    const BOOL fYes=PR_YESNO_YES;
    const BOOL fPass=PR_PASSFAIL_PASS;

    m_prPassFailBureauUnavailable.Set(&fPass);
    m_prYesNoUseEmbedded.Set(&fYes);
}

PICSRulesServiceInfo::~PICSRulesServiceInfo()
{
    //nothing to do
}

HRESULT PICSRulesServiceInfo::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_NAME:
        case PROID_SINAME:
        {
            m_prURLName.SetTo((char *) pData);
            
            if(m_prURLName.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_SHORTNAME:
        {
            m_etstrShortName.SetTo((char *) pData);

            break;
        }
        case PROID_BUREAUURL:
        {
            m_prURLBureauURL.SetTo((char *) pData);

            if(m_prURLBureauURL.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_USEEMBEDDED:
        {
            m_prYesNoUseEmbedded.SetTo((BOOL *) &pData);

            break;
        }
        case PROID_RATFILE:
        {
            m_etstrRatfile.SetTo((char *) pData);

            break;
        }
        case PROID_BUREAUUNAVAILABLE:
        {
            m_prPassFailBureauUnavailable.SetTo((BOOL *) &pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesServiceInfo::InitializeMyDefaults()
{
    //nothing to do
    return(S_OK);
}

//*******************************************************************
//*
//* Code for the PICSRulesSource class
//*
//*******************************************************************

PICSRulesSource::PICSRulesSource()
{
    //nothing to do but construct members
}

PICSRulesSource::~PICSRulesSource()
{
    //nothing to do
}

HRESULT PICSRulesSource::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_SOURCEURL:
        {
            m_prURLSourceURL.SetTo((char *) pData);
            
            if(m_prURLSourceURL.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_AUTHOR:
        {
            m_prEmailAuthor.SetTo((char *) pData);

            if(m_prEmailAuthor.IsEmailValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_CREATIONTOOL:
        {
            m_etstrCreationTool.SetTo((char *) pData);

            break;
        }
        case PROID_LASTMODIFIED:
        {
            m_prDateLastModified.SetTo((char *) pData);

            if(m_prDateLastModified.IsDateValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesSource::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

char * PICSRulesSource::GetToolName()
{
    return m_etstrCreationTool.Get();
}

//*******************************************************************
//*
//* Code for the PICSRulesYesNo class
//*
//*******************************************************************

PICSRulesYesNo::PICSRulesYesNo()
{
    m_fYesOrNo=PR_YESNO_YES;
}

PICSRulesYesNo::~PICSRulesYesNo()
{
}

void PICSRulesYesNo::Set(const BOOL *pIn)
{
    switch(*pIn)
    {
        case PR_YESNO_YES:
        {
            ETS::Set(szPRYes);
            m_fYesOrNo=PR_YESNO_YES;

            break;
        }
        case PR_YESNO_NO:
        {
            ETS::Set(szPRNo);
            m_fYesOrNo=PR_YESNO_NO;

            break;
        }
    }
}

void PICSRulesYesNo::SetTo(BOOL *pIn)
{
    Set(pIn);
}

//*******************************************************************
//*
//* Code for the PICSRulesByURLExpression class
//*
//*******************************************************************
PICSRulesByURLExpression::PICSRulesByURLExpression()
{
    m_bNonWild=0;
    m_bSpecified=0;
}

PICSRulesByURLExpression::~PICSRulesByURLExpression()
{
    //nothing to do
}

HRESULT EtStringRegWriteCipher(ETS &ets,HKEY hKey,char *pKeyWord)
{
    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    if(ets.fIsInit())
    {
        return(RegSetValueEx(hKey,pKeyWord,0,REG_SZ,(LPBYTE)ets.Get(),strlenf(ets.Get())+1));
    }

    return(NOERROR);
}

HRESULT EtNumRegWriteCipher(ETN &etn,HKEY hKey,char *pKeyWord)
{
    int iTemp;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    if(etn.fIsInit())
    {
        iTemp=etn.Get();

        return(RegSetValueEx(hKey,pKeyWord,0,REG_DWORD,(LPBYTE)&iTemp,sizeof(iTemp)));
    }

    return(NOERROR);
}

HRESULT EtBoolRegWriteCipher(ETB &etb,HKEY hKey,char *pKeyWord)
{
    DWORD dwNum;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    if(etb.fIsInit())
    {
        dwNum=etb.Get();

        return(RegSetValueEx(hKey,pKeyWord,0,REG_DWORD,(LPBYTE)&dwNum,sizeof(dwNum)));
    }

    return(NOERROR);
}

HRESULT EtStringRegReadCipher(ETS &ets,HKEY hKey,char *pKeyWord)
{
    unsigned long lType;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    char * lpszString=new char[INTERNET_MAX_URL_LENGTH + 1];
    DWORD dwSizeOfString=INTERNET_MAX_URL_LENGTH + 1;
    
    if(lpszString==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    if(RegQueryValueEx(hKey,pKeyWord,NULL,&lType,(LPBYTE) lpszString,&dwSizeOfString)!=ERROR_SUCCESS)
    {
        ets.SetTo(NULL);

        delete lpszString;
        lpszString = NULL;

        return(E_UNEXPECTED);
    }
    else
    {
        ets.SetTo(lpszString);
    }

    return(NOERROR);
}

HRESULT EtNumRegReadCipher(ETN &etn,HKEY hKey,char *pKeyWord)
{
    unsigned long lType;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    DWORD dwNum;
    DWORD dwSizeOfNum=sizeof(DWORD);
    
    if(RegQueryValueEx(hKey,pKeyWord,NULL,&lType,(LPBYTE) &dwNum,&dwSizeOfNum)!=ERROR_SUCCESS)
    {
        etn.Set(0);

        return(E_UNEXPECTED);
    }
    else
    {
        etn.Set(dwNum);
    }

    return(NOERROR);
}

HRESULT EtBoolRegReadCipher(ETB &etb,HKEY hKey,char *pKeyWord)
{
    unsigned long lType;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    BOOL fFlag;
    DWORD dwSizeOfFlag=sizeof(BOOL);
    
    if(RegQueryValueEx(hKey,pKeyWord,NULL,&lType,(LPBYTE) &fFlag,&dwSizeOfFlag)!=ERROR_SUCCESS)
    {
        etb.Set(0);

        return(E_UNEXPECTED);
    }
    else
    {
        etb.Set(fFlag);
    }

    return(NOERROR);
}

void PICSRulesOutOfMemory()
{
    char szTitle[MAX_PATH],szMessage[MAX_PATH];

    MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
    MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

    MessageBox(NULL,(LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);
}

HRESULT CopySubPolicyExpressionFromRegistry(PICSRulesPolicyExpression * pPRPolicyExpressionBeingCopied,HKEY hKeyExpression)
{
    PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
    ETB                       etb;
    ETN                       etn;
    int                       iTemp;
    long                      lError;

    EtBoolRegReadCipher(etb,hKeyExpression,(char *) szPICSRULESEXPRESSIONEMBEDDED);
    iTemp=(int) etb.Get();
    pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.Set(&iTemp);

    EtStringRegReadCipher(pPRPolicyExpressionBeingCopied->m_etstrServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONSERVICENAME);
    EtStringRegReadCipher(pPRPolicyExpressionBeingCopied->m_etstrCategoryName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONCATEGORYNAME);
    EtStringRegReadCipher(pPRPolicyExpressionBeingCopied->m_etstrFullServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONFULLSERVICENAME);

    EtNumRegReadCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONVALUE);
    pPRPolicyExpressionBeingCopied->m_etnValue.Set(etn.Get());

    EtNumRegReadCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR);
    pPRPolicyExpressionBeingCopied->m_PROPolicyOperator=(PICSRulesOperators) etn.Get();

    EtNumRegReadCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED);
    pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded=(PICSRulesPolicyEmbedded) etn.Get();

    // Handle Left Expression
    {
        CRegKey                   keyExpressionSubKey;

        lError = keyExpressionSubKey.Open( hKeyExpression, szPICSRULESEXPRESSIONLEFT, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=NULL;
        }
        else
        {
            pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

            if(pPRSubPolicyExpressionToCopy==NULL)
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed PICSRulesPolicyExpression Creation LEFT '%s' Expression!", szPICSRULESEXPRESSIONLEFT );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }

            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=pPRSubPolicyExpressionToCopy;

            if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey )))
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed Copy LEFT '%s' Expression!", szPICSRULESEXPRESSIONLEFT );
                return(E_OUTOFMEMORY);
            }
        }
    }

    // Handle Right Expression
    {
        CRegKey                   keyExpressionSubKey;

        lError = keyExpressionSubKey.Open( hKeyExpression, szPICSRULESEXPRESSIONRIGHT, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=NULL;
        }
        else
        {
            pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

            if(pPRSubPolicyExpressionToCopy==NULL)
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed PICSRulesPolicyExpression Creation RIGHT '%s' Expression!", szPICSRULESEXPRESSIONRIGHT );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }

            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=pPRSubPolicyExpressionToCopy;

            if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed Copy RIGHT '%s' Expression!", szPICSRULESEXPRESSIONRIGHT );
                return(E_OUTOFMEMORY);
            }
        }
    }

    return(NOERROR);
}

class CReadRatingSystem
{
private:
    PICSRulesRatingSystem ** m_ppPRRS;

public:
    CReadRatingSystem( PICSRulesRatingSystem ** p_ppPRRS )
    {
        m_ppPRRS = p_ppPRRS;
    }

    ~CReadRatingSystem()
    {
        if ( m_ppPRRS )
        {
            if ( *m_ppPRRS )
            {
                delete *m_ppPRRS;
                *m_ppPRRS = NULL;
            }

            m_ppPRRS = NULL;
        }
    }

    void ValidRatingSystem( void )      { m_ppPRRS = NULL; }
};

HRESULT ReadSystemFromRegistry(HKEY hKey,PICSRulesRatingSystem **ppPRRS)
{
    PICSRulesRatingSystem       * pPRRSBeingCopied;
    PICSRulesPolicy             * pPRPolicyBeingCopied;
    PICSRulesPolicyExpression   * pPRPolicyExpressionBeingCopied;
    PICSRulesServiceInfo        * pPRServiceInfoBeingCopied;
    PICSRulesOptExtension       * pPROptExtensionBeingCopied;
    PICSRulesReqExtension       * pPRReqExtensionBeingCopied;
    PICSRulesName               * pPRNameBeingCopied;
    PICSRulesSource             * pPRSourceBeingCopied;
    PICSRulesByURL              * pPRByURLToCopy;
    PICSRulesByURLExpression    * pPRByURLExpressionToCopy;
    ETN                         etn;
    ETB                         etb;
    long                        lError;
    char                        szNumber[MAX_PATH];
    DWORD                       dwNumSystems,dwSubCounter,dwNumServiceInfo,dwNumExtensions;

    pPRRSBeingCopied=*ppPRRS;

    if(pPRRSBeingCopied!=NULL)
    {
        delete pPRRSBeingCopied;
        pPRRSBeingCopied = NULL;
    }

    pPRRSBeingCopied=new PICSRulesRatingSystem;

    if(pPRRSBeingCopied==NULL)
    {
        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesRatingSystem Creation!" );

        PICSRulesOutOfMemory();

        return(E_OUTOFMEMORY);
    }

    *ppPRRS=pPRRSBeingCopied;

    CReadRatingSystem           readRatingSystem( ppPRRS );

    EtStringRegReadCipher(pPRRSBeingCopied->m_etstrFile,hKey,(char *) &szPICSRULESFILENAME);
    EtNumRegReadCipher(pPRRSBeingCopied->m_etnPRVerMajor,hKey,(char *) &szPICSRULESVERMAJOR);
    EtNumRegReadCipher(pPRRSBeingCopied->m_etnPRVerMinor,hKey,(char *) &szPICSRULESVERMINOR);

    EtNumRegReadCipher(etn,hKey,(char *) &szPICSRULESDWFLAGS);
    pPRRSBeingCopied->m_dwFlags=etn.Get();

    EtNumRegReadCipher(etn,hKey,(char *) &szPICSRULESERRLINE);
    pPRRSBeingCopied->m_nErrLine=etn.Get();

    {
        CRegKey             keySubKey;

        //Read in the PICSRulesName Structure
        lError = keySubKey.Open( hKey, szPICSRULESPRNAME, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRRSBeingCopied->m_pPRName=NULL;
        }
        else
        {
            pPRNameBeingCopied=new PICSRulesName;

            if(pPRNameBeingCopied==NULL)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesName Creation!" );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }
            else
            {
                pPRRSBeingCopied->m_pPRName=pPRNameBeingCopied;
            }
        }

        if((pPRRSBeingCopied->m_pPRName)!=NULL)
        {
            EtStringRegReadCipher( pPRNameBeingCopied->m_etstrRuleName, keySubKey.m_hKey, (char *) &szPICSRULESRULENAME );
            EtStringRegReadCipher( pPRNameBeingCopied->m_etstrDescription, keySubKey.m_hKey ,(char *) &szPICSRULESDESCRIPTION );
        }
    }

    {
        CRegKey             keySubKey;

        //Read in the PICSRulesSource Structure
        lError = keySubKey.Open( hKey, szPICSRULESPRSOURCE, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRRSBeingCopied->m_pPRSource=NULL;
        }
        else
        {
            pPRSourceBeingCopied=new PICSRulesSource;

            if(pPRSourceBeingCopied==NULL)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesSource Creation!" );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }
            else
            {
                pPRRSBeingCopied->m_pPRSource=pPRSourceBeingCopied;
            }
        }

        if((pPRRSBeingCopied->m_pPRSource)!=NULL)
        {
            EtStringRegReadCipher( pPRSourceBeingCopied->m_prURLSourceURL, keySubKey.m_hKey, (char *) &szPICSRULESSOURCEURL );
            EtStringRegReadCipher( pPRSourceBeingCopied->m_etstrCreationTool, keySubKey.m_hKey, (char *) &szPICSRULESCREATIONTOOL );
            EtStringRegReadCipher( pPRSourceBeingCopied->m_prEmailAuthor, keySubKey.m_hKey, (char *) &szPICSRULESEMAILAUTHOR );
            EtStringRegReadCipher( pPRSourceBeingCopied->m_prDateLastModified, keySubKey.m_hKey, (char *) &szPICSRULESLASTMODIFIED );
        }
    }

    {
        CRegKey             keySubKey;

        //Read in the PICSRulesPolicy structure    
        lError = keySubKey.Open( hKey, szPICSRULESPRPOLICY, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumSystems=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMPOLICYS );

            dwNumSystems=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<dwNumSystems;dwSubCounter++)
        {
            DWORD dwPolicyExpressionSubCounter;
            wsprintf(szNumber,"%d",dwSubCounter);

            CRegKey             keyCopy;

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPRPolicyBeingCopied=new PICSRulesPolicy;

                if(pPRPolicyBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesPolicy Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPRPolicy.Append(pPRPolicyBeingCopied);

            EtStringRegReadCipher( pPRPolicyBeingCopied->m_etstrExplanation, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYEXPLANATION );

            EtNumRegReadCipher( etn, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYATTRIBUTE );

            pPRPolicyBeingCopied->m_PRPolicyAttribute=(PICSRulesPolicyAttribute) etn.Get();

            CRegKey             keyExpression;

            lError = keyExpression.Open( keyCopy.m_hKey, szPICSRULESPOLICYSUB, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed keyExpression Open szPICSRULESPOLICYSUB='%s'!", szPICSRULESPOLICYSUB );
                return(E_FAIL);
            }

            pPRByURLToCopy=NULL;
            pPRPolicyExpressionBeingCopied=NULL;

            switch(pPRPolicyBeingCopied->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                case PR_POLICY_REJECTBYURL:
                {
                    pPRByURLToCopy=new PICSRulesByURL;

                    if(pPRByURLToCopy==NULL)
                    {
                        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesByURL Creation!" );
                        PICSRulesOutOfMemory();
                        return(E_OUTOFMEMORY);
                    }

                    break;
                }
                case PR_POLICY_REJECTIF:
                case PR_POLICY_ACCEPTIF:
                case PR_POLICY_REJECTUNLESS:
                case PR_POLICY_ACCEPTUNLESS:
                {
                    pPRPolicyExpressionBeingCopied=new PICSRulesPolicyExpression;

                    if(pPRPolicyExpressionBeingCopied==NULL)
                    {
                        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesPolicyExpression Creation!" );
                        PICSRulesOutOfMemory();
                        return(E_OUTOFMEMORY);
                    }

                    break;
                }
            }

            switch(pPRPolicyBeingCopied->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                {
                    pPRPolicyBeingCopied->m_pPRAcceptByURL=pPRByURLToCopy;
            
                    break;
                }
                case PR_POLICY_REJECTBYURL:
                {
                    pPRPolicyBeingCopied->m_pPRRejectByURL=pPRByURLToCopy;

                    break;
                }
                case PR_POLICY_REJECTIF:
                {
                    pPRPolicyBeingCopied->m_pPRRejectIf=pPRPolicyExpressionBeingCopied;

                    break;
                }
                case PR_POLICY_ACCEPTIF:
                {
                    pPRPolicyBeingCopied->m_pPRAcceptIf=pPRPolicyExpressionBeingCopied;

                    break;
                }
                case PR_POLICY_REJECTUNLESS:
                {
                    pPRPolicyBeingCopied->m_pPRRejectUnless=pPRPolicyExpressionBeingCopied;

                    break;
                }
                case PR_POLICY_ACCEPTUNLESS:
                {
                    pPRPolicyBeingCopied->m_pPRAcceptUnless=pPRPolicyExpressionBeingCopied;

                    break;
                }
            }

            if(pPRByURLToCopy!=NULL)
            {
                DWORD dwNumExpressions;

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESNUMBYURL );
                dwNumExpressions=etn.Get();

                for(dwPolicyExpressionSubCounter=0;
                    dwPolicyExpressionSubCounter<dwNumExpressions;
                    dwPolicyExpressionSubCounter++)
                {
                    CRegKey             keyByURL;

                    wsprintf(szNumber,"%d",dwPolicyExpressionSubCounter);

                    lError = keyByURL.Open( keyExpression.m_hKey, szNumber, KEY_READ );

                    if(lError!=ERROR_SUCCESS)
                    {
                        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed keyByURL Open szNumber='%s'!", szNumber );
                        return(E_FAIL);
                    }
                    else
                    {
                        pPRByURLExpressionToCopy=new PICSRulesByURLExpression;

                        if(pPRByURLExpressionToCopy==NULL)
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesByURLExpression Creation!" );
                            PICSRulesOutOfMemory();
                            return(E_FAIL);
                        }
                    }

                    pPRByURLToCopy->m_arrpPRByURL.Append(pPRByURLExpressionToCopy);

                    EtBoolRegReadCipher( etb, keyByURL.m_hKey, (char *) szPICSRULESBYURLINTERNETPATTERN );
                    pPRByURLExpressionToCopy->m_fInternetPattern=etb.Get();

                    EtNumRegReadCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLNONWILD );
                    pPRByURLExpressionToCopy->m_bNonWild = (unsigned char) etn.Get();

                    EtNumRegReadCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLSPECIFIED );
                    pPRByURLExpressionToCopy->m_bSpecified = (unsigned char) etn.Get();

                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrScheme, keyByURL.m_hKey, (char *) &szPICSRULESBYURLSCHEME );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrUser, keyByURL.m_hKey, (char *) &szPICSRULESBYURLUSER );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrHost, keyByURL.m_hKey, (char *) &szPICSRULESBYURLHOST );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrPort, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPORT );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrPath, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPATH );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrURL, keyByURL.m_hKey, (char *) &szPICSRULESBYURLURL );
                }
            }

            if(pPRPolicyExpressionBeingCopied!=NULL)
            {
                PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
                int                       iTemp;

                EtBoolRegReadCipher( etb, keyExpression.m_hKey,(char *) szPICSRULESEXPRESSIONEMBEDDED );
                iTemp=(int) etb.Get();
                pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.Set(&iTemp);

                EtStringRegReadCipher( pPRPolicyExpressionBeingCopied->m_etstrServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONSERVICENAME );
                EtStringRegReadCipher( pPRPolicyExpressionBeingCopied->m_etstrCategoryName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONCATEGORYNAME );
                EtStringRegReadCipher( pPRPolicyExpressionBeingCopied->m_etstrFullServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONFULLSERVICENAME );

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONVALUE );
                pPRPolicyExpressionBeingCopied->m_etnValue.Set(etn.Get());

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR );
                pPRPolicyExpressionBeingCopied->m_PROPolicyOperator=(PICSRulesOperators) etn.Get();

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED );
                pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded=(PICSRulesPolicyEmbedded) etn.Get();

                {
                    CRegKey                 keyExpressionSubKey;

                    lError = keyExpressionSubKey.Open( keyExpression.m_hKey, szPICSRULESEXPRESSIONLEFT, KEY_READ );

                    if(lError!=ERROR_SUCCESS)
                    {
                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=NULL;
                    }
                    else
                    {
                        pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpressionToCopy==NULL)
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed LEFT PICSRulesPolicyExpression Creation!" );
                            PICSRulesOutOfMemory();
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=pPRSubPolicyExpressionToCopy;

                        if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed LEFT CopySubPolicyExpressionFromRegistry()!" );
                            return(E_FAIL);
                        }
                    }
                }

                {
                    CRegKey                 keyExpressionSubKey;

                    lError = keyExpressionSubKey.Open( keyExpression.m_hKey, szPICSRULESEXPRESSIONRIGHT, KEY_READ );

                    if(lError!=ERROR_SUCCESS)
                    {
                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=NULL;
                    }
                    else
                    {
                        pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpressionToCopy==NULL)
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed RIGHT PICSRulesPolicyExpression Creation!" );
                            PICSRulesOutOfMemory();
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=pPRSubPolicyExpressionToCopy;

                        if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed RIGHT CopySubPolicyExpressionFromRegistry()!" );
                            return(E_FAIL);
                        }
                    }
                }
            }
        }
    }

    {
        CRegKey             keySubKey;

        //Read In PICSRulesServiceInfo Structure
        lError = keySubKey.Open( hKey, szPICSRULESSERVICEINFO, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumServiceInfo=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey ,(char *) &szPICSRULESNUMSERVICEINFO );
            dwNumServiceInfo=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<dwNumServiceInfo;dwSubCounter++)
        {
            CRegKey         keyCopy;
            int  iTemp;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed szPICSRULESSERVICEINFO keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPRServiceInfoBeingCopied=new PICSRulesServiceInfo;

                if(pPRServiceInfoBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesServiceInfo Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPRServiceInfo.Append(pPRServiceInfoBeingCopied);

            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_prURLName, keyCopy.m_hKey, (char *) &szPICSRULESSIURLNAME );
            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_prURLBureauURL, keyCopy.m_hKey, (char *) &szPICSRULESSIBUREAUURL );
            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESSISHORTNAME );
            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_etstrRatfile, keyCopy.m_hKey, (char *) &szPICSRULESSIRATFILE );

            EtBoolRegReadCipher( etb, keyCopy.m_hKey, (char *) &szPICSRULESSIUSEEMBEDDED );
            iTemp=(int) etb.Get();
            pPRServiceInfoBeingCopied->m_prYesNoUseEmbedded.Set(&iTemp);

            EtBoolRegReadCipher( etb, keyCopy.m_hKey, (char *) &szPICSRULESSIBUREAUUNAVAILABLE );
            iTemp=(int) etb.Get();
            pPRServiceInfoBeingCopied->m_prPassFailBureauUnavailable.Set(&iTemp);
        }
    }

    {
        CRegKey             keySubKey;

        //Read in OptExtension Structures
        lError = keySubKey.Open( hKey, szPICSRULESOPTEXTENSION, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumExtensions=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMOPTEXTENSIONS );
            dwNumExtensions=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPROptExtension.Length());dwSubCounter++)
        {
            CRegKey         keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed szPICSRULESOPTEXTENSION keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPROptExtensionBeingCopied=new PICSRulesOptExtension;

                if(pPROptExtensionBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesOptExtension Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPROptExtension.Append(pPROptExtensionBeingCopied);

            EtStringRegReadCipher( pPROptExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTNAME );
            EtStringRegReadCipher( pPROptExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTSHORTNAME );
        }
    }

    {
        CRegKey             keySubKey;

        //Read in ReqExtension Structures
        lError = keySubKey.Open( hKey, szPICSRULESREQEXTENSION, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumExtensions=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMREQEXTENSIONS );
            dwNumExtensions=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRReqExtension.Length());dwSubCounter++)
        {
            CRegKey         keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed szPICSRULESREQEXTENSION keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPRReqExtensionBeingCopied=new PICSRulesReqExtension;

                if(pPRReqExtensionBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesReqExtension Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPRReqExtension.Append(pPRReqExtensionBeingCopied);

            EtStringRegReadCipher( pPRReqExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTNAME );
            EtStringRegReadCipher( pPRReqExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTSHORTNAME );
        }
    }

    // Insure the Copied Rating System is not deleted.
    readRatingSystem.ValidRatingSystem();

    TraceMsg( TF_ALWAYS, "ReadSystemFromRegistry() - Successfully Read PICS Rules from Registry!" );

    return(NOERROR);
}

HRESULT CopySubPolicyExpressionToRegistry(PICSRulesPolicyExpression * pPRPolicyExpressionBeingCopied,HKEY hKeyExpression)
{
    ETB  etb;
    ETN  etn;
    long lError;

    etb.Set(pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.GetYesNo());
    EtBoolRegWriteCipher(etb,hKeyExpression,(char *) szPICSRULESEXPRESSIONEMBEDDED);

    EtStringRegWriteCipher(pPRPolicyExpressionBeingCopied->m_etstrServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONSERVICENAME);
    EtStringRegWriteCipher(pPRPolicyExpressionBeingCopied->m_etstrCategoryName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONCATEGORYNAME);
    EtStringRegWriteCipher(pPRPolicyExpressionBeingCopied->m_etstrFullServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONFULLSERVICENAME);

    etn.Set(pPRPolicyExpressionBeingCopied->m_etnValue.Get());
    EtNumRegWriteCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONVALUE);

    etn.Set(pPRPolicyExpressionBeingCopied->m_PROPolicyOperator);
    EtNumRegWriteCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR);

    etn.Set(pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded);
    EtNumRegWriteCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED);

    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
        CRegKey                     keyExpressionSubKey;

        lError = keyExpressionSubKey.Create( hKeyExpression, szPICSRULESEXPRESSIONLEFT );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed Registry Key Creation LEFT '%s' Expression!", szPICSRULESEXPRESSIONLEFT );
            return(E_FAIL);
        }

        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft;

        if ( FAILED( CopySubPolicyExpressionToRegistry(pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed LEFT CopySubPolicyExpressionToRegistry() Recursive Call!" );
            return(E_FAIL);
        }
    }

    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
        CRegKey                     keyExpressionSubKey;

        lError = keyExpressionSubKey.Create( hKeyExpression, szPICSRULESEXPRESSIONRIGHT );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed Registry Key Creation RIGHT '%s' Expression!", szPICSRULESEXPRESSIONRIGHT );
            return(E_FAIL);
        }

        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight;

        if ( FAILED( CopySubPolicyExpressionToRegistry(pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed RIGHT CopySubPolicyExpressionToRegistry() Recursive Call!" );
            return(E_FAIL);
        }
    }

    return(NOERROR);
}

HRESULT WriteSystemToRegistry(HKEY hKey,PICSRulesRatingSystem **ppPRRS)
{
    PICSRulesRatingSystem       * pPRRSBeingCopied;
    PICSRulesPolicy             * pPRPolicyBeingCopied;
    PICSRulesPolicyExpression   * pPRPolicyExpressionBeingCopied;
    PICSRulesServiceInfo        * pPRServiceInfoBeingCopied;
    PICSRulesOptExtension       * pPROptExtensionBeingCopied;
    PICSRulesReqExtension       * pPRReqExtensionBeingCopied;
    PICSRulesName               * pPRNameBeingCopied;
    PICSRulesSource             * pPRSourceBeingCopied;
    PICSRulesByURL              * pPRByURLToCopy;
    PICSRulesByURLExpression    * pPRByURLExpressionToCopy;
    ETN                         etn;
    ETB                         etb;
    long                        lError;
    char                        szNumber[MAX_PATH];

    pPRRSBeingCopied=*ppPRRS;

    if(pPRRSBeingCopied==NULL)
    {
        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - pPRRSBeingCopied is NULL!" );
        return(E_INVALIDARG);
    }

    EtStringRegWriteCipher( pPRRSBeingCopied->m_etstrFile, hKey, (char *) &szPICSRULESFILENAME );
    EtNumRegWriteCipher( pPRRSBeingCopied->m_etnPRVerMajor, hKey, (char *) &szPICSRULESVERMAJOR );
    EtNumRegWriteCipher( pPRRSBeingCopied->m_etnPRVerMinor, hKey, (char *) &szPICSRULESVERMINOR );

    etn.Set(pPRRSBeingCopied->m_dwFlags);
    EtNumRegWriteCipher( etn, hKey, (char *) &szPICSRULESDWFLAGS );

    etn.Set(pPRRSBeingCopied->m_nErrLine);
    EtNumRegWriteCipher( etn, hKey, (char *) &szPICSRULESERRLINE );

    if((pPRRSBeingCopied->m_pPRName)!=NULL)
    {
        CRegKey             keySubKey;

        lError = keySubKey.Create( hKey, szPICSRULESPRNAME );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPRNAME='%s' Key!", szPICSRULESPRNAME );
            return(E_FAIL);
        }

        pPRNameBeingCopied=pPRRSBeingCopied->m_pPRName;

        EtStringRegWriteCipher( pPRNameBeingCopied->m_etstrRuleName, hKey, (char *) &szPICSRULESSYSTEMNAME );
        EtStringRegWriteCipher( pPRNameBeingCopied->m_etstrRuleName, keySubKey.m_hKey, (char *) &szPICSRULESRULENAME );
        EtStringRegWriteCipher( pPRNameBeingCopied->m_etstrDescription, keySubKey.m_hKey, (char *) &szPICSRULESDESCRIPTION );
    }

    if((pPRRSBeingCopied->m_pPRSource)!=NULL)
    {
        CRegKey             keySubKey;

        lError = keySubKey.Create( hKey, szPICSRULESPRSOURCE );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPRSOURCE='%s' Key!", szPICSRULESPRSOURCE );
            return(E_FAIL);
        }

        pPRSourceBeingCopied=pPRRSBeingCopied->m_pPRSource;

        EtStringRegWriteCipher( pPRSourceBeingCopied->m_prURLSourceURL, keySubKey.m_hKey, (char *) &szPICSRULESSOURCEURL );
        EtStringRegWriteCipher( pPRSourceBeingCopied->m_etstrCreationTool, keySubKey.m_hKey, (char *) &szPICSRULESCREATIONTOOL );
        EtStringRegWriteCipher( pPRSourceBeingCopied->m_prEmailAuthor, keySubKey.m_hKey, (char *) &szPICSRULESEMAILAUTHOR );
        EtStringRegWriteCipher( pPRSourceBeingCopied->m_prDateLastModified, keySubKey.m_hKey, (char *) &szPICSRULESLASTMODIFIED );
    }

    if(pPRRSBeingCopied->m_arrpPRPolicy.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESPRPOLICY );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPRPOLICY='%s' Key!", szPICSRULESPRPOLICY );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPRPolicy.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMPOLICYS );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRPolicy.Length());dwSubCounter++)
        {
            DWORD dwPolicyExpressionSubCounter;

            wsprintf(szNumber,"%d",dwSubCounter);

            CRegKey                 keyCopy;

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRPolicy szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPRPolicyBeingCopied=pPRRSBeingCopied->m_arrpPRPolicy[dwSubCounter];

            EtStringRegWriteCipher( pPRPolicyBeingCopied->m_etstrExplanation, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYEXPLANATION );

            etn.Set(pPRPolicyBeingCopied->m_PRPolicyAttribute);
            EtNumRegWriteCipher( etn, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYATTRIBUTE );

            CRegKey                 keyExpression;

            lError = keyExpression.Create( keyCopy.m_hKey, szPICSRULESPOLICYSUB );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPOLICYSUB='%s' Key!", szPICSRULESPOLICYSUB );
                return(E_FAIL);
            }

            pPRByURLToCopy=NULL;
            pPRPolicyExpressionBeingCopied=NULL;

            switch(pPRPolicyBeingCopied->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                {
                    pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRAcceptByURL;
                
                    break;
                }
                case PR_POLICY_REJECTBYURL:
                {
                    pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRRejectByURL;

                    break;
                }
                case PR_POLICY_REJECTIF:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectIf;

                    break;
                }
                case PR_POLICY_ACCEPTIF:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptIf;

                    break;
                }
                case PR_POLICY_REJECTUNLESS:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectUnless;

                    break;
                }
                case PR_POLICY_ACCEPTUNLESS:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptUnless;

                    break;
                }
            }

            if(pPRByURLToCopy!=NULL)
            {
                etn.Set(pPRByURLToCopy->m_arrpPRByURL.Length());
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESNUMBYURL );

                for(dwPolicyExpressionSubCounter=0;
                    dwPolicyExpressionSubCounter<(DWORD) (pPRByURLToCopy->m_arrpPRByURL.Length());
                    dwPolicyExpressionSubCounter++)
                {
                    CRegKey         keyByURL;

                    wsprintf(szNumber,"%d",dwPolicyExpressionSubCounter);

                    lError = keyByURL.Create( keyExpression.m_hKey, szNumber );
                    if ( lError != ERROR_SUCCESS )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRByURL szNumber='%s' Key!", szNumber );
                        return(E_FAIL);
                    }

                    pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[dwPolicyExpressionSubCounter];

                    etb.Set(pPRByURLExpressionToCopy->m_fInternetPattern);
                    EtBoolRegWriteCipher( etb, keyByURL.m_hKey, (char *) szPICSRULESBYURLINTERNETPATTERN );

                    etn.Set(pPRByURLExpressionToCopy->m_bNonWild);
                    EtNumRegWriteCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLNONWILD );

                    etn.Set(pPRByURLExpressionToCopy->m_bSpecified);
                    EtNumRegWriteCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLSPECIFIED );

                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrScheme, keyByURL.m_hKey, (char *) &szPICSRULESBYURLSCHEME );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrUser, keyByURL.m_hKey, (char *) &szPICSRULESBYURLUSER );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrHost, keyByURL.m_hKey, (char *) &szPICSRULESBYURLHOST );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrPort, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPORT );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrPath, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPATH );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrURL, keyByURL.m_hKey, (char *) &szPICSRULESBYURLURL );
                }
            }

            if(pPRPolicyExpressionBeingCopied!=NULL)
            {
                etb.Set(pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.GetYesNo());
                EtBoolRegWriteCipher( etb, keyExpression.m_hKey, (char *) szPICSRULESEXPRESSIONEMBEDDED );

                EtStringRegWriteCipher( pPRPolicyExpressionBeingCopied->m_etstrServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONSERVICENAME );
                EtStringRegWriteCipher( pPRPolicyExpressionBeingCopied->m_etstrCategoryName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONCATEGORYNAME );
                EtStringRegWriteCipher( pPRPolicyExpressionBeingCopied->m_etstrFullServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONFULLSERVICENAME );

                etn.Set(pPRPolicyExpressionBeingCopied->m_etnValue.Get());
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONVALUE );

                etn.Set(pPRPolicyExpressionBeingCopied->m_PROPolicyOperator);
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR );

                etn.Set(pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded);
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED );

                if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft!=NULL)
                {
                    PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
                    CRegKey                     keyExpressionSubKey;

                    lError = keyExpressionSubKey.Create( keyExpression.m_hKey, szPICSRULESEXPRESSIONLEFT );
                    if ( lError != ERROR_SUCCESS )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESEXPRESSIONLEFT='%s' Key!", szPICSRULESEXPRESSIONLEFT );
                        return(E_FAIL);
                    }

                    pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft;

                    if ( FAILED( CopySubPolicyExpressionToRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed LEFT CopySubPolicyExpressionToRegistry() Call!" );
                        return(E_FAIL);
                    }
                }

                if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight!=NULL)
                {
                    PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
                    CRegKey                     keyExpressionSubKey;

                    lError = keyExpressionSubKey.Create( keyExpression.m_hKey, szPICSRULESEXPRESSIONRIGHT );
                    if ( lError != ERROR_SUCCESS )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESEXPRESSIONRIGHT='%s' Key!", szPICSRULESEXPRESSIONRIGHT );
                        return(E_FAIL);
                    }

                    pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight;

                    if(FAILED(CopySubPolicyExpressionToRegistry(pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey )))
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed RIGHT CopySubPolicyExpressionToRegistry() Call!" );
                        return(E_FAIL);
                    }
                }
            }
        }
    }

    if(pPRRSBeingCopied->m_arrpPRServiceInfo.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESSERVICEINFO );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESSERVICEINFO='%s' Key!", szPICSRULESSERVICEINFO );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPRServiceInfo.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMSERVICEINFO );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRServiceInfo.Length());dwSubCounter++)
        {
            CRegKey             keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRServiceInfo szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPRServiceInfoBeingCopied=pPRRSBeingCopied->m_arrpPRServiceInfo[dwSubCounter];

            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_prURLName, keyCopy.m_hKey, (char *) &szPICSRULESSIURLNAME );
            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_prURLBureauURL, keyCopy.m_hKey, (char *) &szPICSRULESSIBUREAUURL );
            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESSISHORTNAME );
            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_etstrRatfile, keyCopy.m_hKey, (char *) &szPICSRULESSIRATFILE );

            etb.Set(pPRServiceInfoBeingCopied->m_prYesNoUseEmbedded.GetYesNo());
            EtBoolRegWriteCipher( etb, keyCopy.m_hKey,(char *) &szPICSRULESSIUSEEMBEDDED );

            etb.Set(pPRServiceInfoBeingCopied->m_prPassFailBureauUnavailable.GetPassFail());
            EtBoolRegWriteCipher( etb, keyCopy.m_hKey,(char *) &szPICSRULESSIBUREAUUNAVAILABLE );
        }
    }

    if(pPRRSBeingCopied->m_arrpPROptExtension.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESOPTEXTENSION );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESOPTEXTENSION='%s' Key!", szPICSRULESOPTEXTENSION );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPROptExtension.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMOPTEXTENSIONS );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPROptExtension.Length());dwSubCounter++)
        {
            CRegKey         keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPROptExtension szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPROptExtensionBeingCopied=pPRRSBeingCopied->m_arrpPROptExtension[dwSubCounter];

            EtStringRegWriteCipher( pPROptExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTNAME );
            EtStringRegWriteCipher( pPROptExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTSHORTNAME );
        }
    }

    if(pPRRSBeingCopied->m_arrpPRReqExtension.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESREQEXTENSION );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESREQEXTENSION='%s' Key!", szPICSRULESREQEXTENSION );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPRReqExtension.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMREQEXTENSIONS );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRReqExtension.Length());dwSubCounter++)
        {
            CRegKey             keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRReqExtension szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPRReqExtensionBeingCopied=pPRRSBeingCopied->m_arrpPRReqExtension[dwSubCounter];

            EtStringRegWriteCipher( pPRReqExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTNAME );
            EtStringRegWriteCipher( pPRReqExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTSHORTNAME );
        }
    }

    TraceMsg( TF_ALWAYS, "WriteSystemToRegistry() - Successfully Created PICS Rules in Registry!" );

    return(NOERROR);
}

//*******************************************************************
//*
//* Code for saving and reading processed PICSRules from the registry
//*
//*******************************************************************
HRESULT WritePICSRulesToRegistry(LPCTSTR lpszUserName,HKEY hkeyUser,DWORD dwSystemToSave,PICSRulesRatingSystem **ppPRRS)
{
    long    lError;
    char    *lpszSystemNumber;
    HRESULT hRes;

    lpszSystemNumber=(char *) GlobalAlloc(GPTR,MAX_PATH);

    if(lpszSystemNumber==NULL)
    {
        TraceMsg( TF_WARNING, "WritePICSRulesToRegistry() - lpszSystemNumber is NULL!" );
        return(E_OUTOFMEMORY);
    }

    CRegKey             keyWrite;

    lError = keyWrite.Create( hkeyUser, lpszUserName );
    if ( lError != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "WritePICSRulesToRegistry() - Failed to Create lpszUserName='%s' Key!", lpszUserName );
        return(E_FAIL);
    }

    wsprintf(lpszSystemNumber,"%d",dwSystemToSave);

    CRegKey             keyNumbered;

    lError = keyNumbered.Create( keyWrite.m_hKey, lpszSystemNumber );
    if ( lError != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "WritePICSRulesToRegistry() - Failed to Create lpszSystemNumber='%s' Key!", lpszSystemNumber );
        return(E_FAIL);
    }

    hRes = WriteSystemToRegistry( keyNumbered.m_hKey, ppPRRS );

    GlobalFree(lpszSystemNumber);
    lpszSystemNumber = NULL;

    return(hRes);
}

HRESULT PICSRulesSaveToRegistry(DWORD dwSystemToSave,PICSRulesRatingSystem **ppPRRS)
{
    HRESULT hRes;
    CRegistryHive       rh;
    CRegKey             keyUser;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to save to
    }

    //load the hive file
    if ( gPRSI->fStoreInRegistry )
    {
        keyUser.Create( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS );
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            keyUser.Create( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS );
        }
    }

    //write information to the registry
    if ( keyUser.m_hKey != NULL )
    {
        LPCTSTR lpszUsername; 

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        hRes = WritePICSRulesToRegistry( lpszUsername, keyUser.m_hKey, dwSystemToSave, ppPRRS );

        keyUser.Close();

        if ( FAILED(hRes) )
        {
            TraceMsg( TF_WARNING, "PICSRulesSaveToRegistry() - WritePICSRulesToRegistry Failed with hRes=0x%x!", hRes );
            return(hRes);
        }
    }
    else
    {
        // failed to create the registry key
        hRes = E_FAIL;
    }

    return(hRes);
}

HRESULT PICSRulesReadFromRegistry(DWORD dwSystemToRead, PICSRulesRatingSystem **ppPRRS)
{
    long            lError;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to read from
    }

    CRegistryHive   rh;
    CRegKey         keyUser;

    //load the hive file
    if(gPRSI->fStoreInRegistry)
    {
        lError = keyUser.Open( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS, KEY_READ );
    }
    else
    {
        if ( rh.OpenHiveFile( false ) )
        {
            ASSERT( rh.GetHiveKey().m_hKey != NULL );

            lError = keyUser.Open( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS, KEY_READ );
        }
    }

    //read information from the registry
    if ( keyUser.m_hKey != NULL )
    {
        LPCTSTR lpszUsername; 
        TCHAR szSystem[20];

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        CRegKey         keyWrite;

        lError = keyWrite.Open( keyUser.m_hKey, lpszUsername, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "PICSRulesReadFromRegistry() - Failed keyWrite lpszUsername='%s' Key Open!", lpszUsername );
            keyUser.Close();
            return(E_FAIL);
        }

        wnsprintf(szSystem,ARRAYSIZE(szSystem),"%d",dwSystemToRead);

        CRegKey         keySystem;

        lError = keySystem.Open( keyWrite.m_hKey, szSystem, KEY_READ );

        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "PICSRulesReadFromRegistry() - Failed keySystem lpszSystem='%s' Key Open!", szSystem );
        }

        if( lError != ERROR_SUCCESS )
        {
            keyWrite.Close();
            keyUser.Close();
            return(E_FAIL);
        }

        HRESULT     hr = ReadSystemFromRegistry( keySystem.m_hKey, ppPRRS );

        keySystem.Close();
        keyWrite.Close();
        keyUser.Close();

        if ( FAILED( hr ) )
        {
            TraceMsg( TF_WARNING, "PICSRulesReadFromRegistry() - Failed ReadSystemFromRegistry()!" );
            return(E_FAIL);
        }
    }

    return(S_OK);
}

HRESULT PICSRulesDeleteSystem(DWORD dwSystemToDelete)
{
    long            lError;
    char            * lpszSystem;
    CRegistryHive   rh;
    CRegKey         keyUser;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to read from
    }

    //load the hive file
    if ( gPRSI->fStoreInRegistry )
    {
        keyUser.Create( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS );
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            keyUser.Create( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS );
        }
    }

    //delete information from the registry
    if ( keyUser.m_hKey != NULL )
    {
        CRegKey         keyWrite;
        LPCTSTR         lpszUsername;

        lpszUsername = gPRSI->pUserObject->nlsUsername.QueryPch();

        lError = keyWrite.Create( keyUser.m_hKey, lpszUsername );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "PICSRulesDeleteSystem() - Failed to Create lpszUsername='%s' Key!", lpszUsername );
            keyUser.Close();
            return(E_FAIL);
        }

        lpszSystem=(char *) GlobalAlloc(GPTR,MAX_PATH);

        wsprintf(lpszSystem,"%d",dwSystemToDelete);

        MyRegDeleteKey( keyWrite.m_hKey, lpszSystem );

        GlobalFree(lpszSystem);
        lpszSystem = NULL;

        keyWrite.Close();
        keyUser.Close();
    }

    return(NOERROR);
}

HRESULT PICSRulesGetNumSystems(DWORD * pdwNumSystems)
{
    long            lError;

    if (pdwNumSystems)
    {
        *pdwNumSystems = 0;
    }

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to read from
    }

    CRegistryHive   rh;
    CRegKey         keyUser;

    //load the hive file
    if(gPRSI->fStoreInRegistry)
    {
        keyUser.Open( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS, KEY_READ );
    }
    else
    {
        if ( rh.OpenHiveFile( false ) )
        {
            ASSERT( rh.GetHiveKey().m_hKey != NULL );

            keyUser.Open( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS, KEY_READ );
        }
    }

    //read information from the registry
    if ( keyUser.m_hKey != NULL )
    {
        LPCTSTR lpszUsername; 

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        CRegKey         keyWrite;

        lError = keyWrite.Open( keyUser.m_hKey, lpszUsername, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "PICSRulesGetNumSystems() - Failed keyWrite lpszUsername='%s' Key Open!", lpszUsername );
            return(E_FAIL);
        }

        DWORD           dwNumSystems;

        if ( keyWrite.QueryValue( dwNumSystems, szPICSRULESNUMSYS ) != ERROR_SUCCESS )
        {
            //no value set, so we have zero systems installed
            *pdwNumSystems = 0;
        }
        else
        {
            *pdwNumSystems = dwNumSystems;
        }

        keyWrite.Close();
        keyUser.Close();
    }

    return(NOERROR);
}

HRESULT PICSRulesSetNumSystems(DWORD dwNumSystems)
{
    long        lError;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to save to
    }

    CRegistryHive   rh;
    CRegKey         keyUser;

    //load the hive file
    if(gPRSI->fStoreInRegistry)
    {
        keyUser.Create( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS );
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            ASSERT( rh.GetHiveKey().m_hKey != NULL );

            keyUser.Create( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS );
        }
    }

    //write information to the registry
    if ( keyUser.m_hKey != NULL )
    {
        CRegKey     keyWrite;
        LPCTSTR lpszUsername; 

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        lError = keyWrite.Create( keyUser.m_hKey, lpszUsername );
        if(lError!=ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "PICSRulesSetNumSystems() - Failed to Create keyWrite lpszUsername='%s' Key!", lpszUsername );
            keyUser.Close();
            return(E_FAIL);
        }

        lError = keyWrite.SetValue( dwNumSystems, szPICSRULESNUMSYS );

        keyWrite.Close();
        keyUser.Close();

        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "PICSRulesSetNumSystems() - Failed to Set keyWrite dwNumSystems='%d' Value!", dwNumSystems );
            return(E_FAIL);
        }
    }

    return(NOERROR);
}

HRESULT PICSRulesCheckApprovedSitesAccess(LPCSTR lpszUrl,BOOL *fPassFail)
{
    int                     iCounter;
    PICSRulesEvaluation     PREvaluation = PR_EVALUATION_DOESNOTAPPLY;

    if(g_pApprovedPRRS==NULL)
    {
        return(E_FAIL);
    }

    if(g_lApprovedSitesGlobalCounterValue!=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter))
    {
        PICSRulesRatingSystem * pPRRS=NULL;
        HRESULT               hRes;

        hRes=PICSRulesReadFromRegistry(PICSRULES_APPROVEDSITES,&pPRRS);

        if(SUCCEEDED(hRes))
        {
            if(g_pApprovedPRRS!=NULL)
            {
                delete g_pApprovedPRRS;
            }

            g_pApprovedPRRS=pPRRS;
        }

        g_lApprovedSitesGlobalCounterValue=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter);
    }

    for(iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
    {
        PICSRulesPolicy     * pPRPolicy;
        PICSRulesByURL      * pPRByURL;
        PICSRulesQuotedURL  PRQuotedURL;

        pPRPolicy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];

        if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            *fPassFail=PR_PASSFAIL_PASS;

            pPRByURL=pPRPolicy->m_pPRAcceptByURL;
        }
        else
        {
            *fPassFail=PR_PASSFAIL_FAIL;

            pPRByURL=pPRPolicy->m_pPRRejectByURL;
        }

        PRQuotedURL.Set(lpszUrl);

        PREvaluation=pPRByURL->EvaluateRule(&PRQuotedURL);

        if(PREvaluation!=PR_EVALUATION_DOESNOTAPPLY)
        {
            break;
        }
    }
    
    if(PREvaluation==PR_EVALUATION_DOESAPPLY)
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}

HRESULT PICSRulesCheckAccess(LPCSTR lpszUrl,LPCSTR lpszRatingInfo,BOOL *fPassFail,CParsedLabelList **ppParsed)
{
    int                     iCounter,iSystemCounter;
    PICSRulesEvaluation     PREvaluation;
    CParsedLabelList        *pParsed=NULL;
    
    if(g_arrpPRRS.Length()==0)
    {
        return(E_FAIL);
    }

    if(g_lGlobalCounterValue!=SHGlobalCounterGetValue(g_HandleGlobalCounter))
    {
        HRESULT                 hRes;
        DWORD                   dwNumSystems;
        PICSRulesRatingSystem   * pPRRS=NULL;

        g_arrpPRRS.DeleteAll();

        //someone modified our settings, so we'd better reload them.
        hRes=PICSRulesGetNumSystems(&dwNumSystems);

        if(SUCCEEDED(hRes))
        {
            DWORD dwCounter;

            for(dwCounter=PICSRULES_FIRSTSYSTEMINDEX;
                dwCounter<(dwNumSystems+PICSRULES_FIRSTSYSTEMINDEX);
                dwCounter++)
            {
                hRes=PICSRulesReadFromRegistry(dwCounter,&pPRRS);

                if(FAILED(hRes))
                {
                    char    *lpszTitle,*lpszMessage;

                    //we couldn't read in the systems, so don't inforce PICSRules,
                    //and notify the user
        
                    g_arrpPRRS.DeleteAll();

                    lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
                    lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

                    MLLoadString(IDS_PICSRULES_TAMPEREDREADTITLE,(LPTSTR) lpszTitle,MAX_PATH);
                    MLLoadString(IDS_PICSRULES_TAMPEREDREADMSG,(LPTSTR) lpszMessage,MAX_PATH);

                    MessageBox(NULL,(LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

                    GlobalFree(lpszTitle);
                    lpszTitle = NULL;
                    GlobalFree(lpszMessage);
                    lpszMessage = NULL;

                    break;
                }
                else
                {
                    g_arrpPRRS.Append(pPRRS);

                    pPRRS=NULL;
                }
            }
        }

        g_lGlobalCounterValue=SHGlobalCounterGetValue(g_HandleGlobalCounter);
    }

    if(lpszRatingInfo!=NULL)
    {
        ParseLabelList(lpszRatingInfo,ppParsed);
        pParsed=*ppParsed;
    }

    for(iSystemCounter=0;iSystemCounter<g_arrpPRRS.Length();iSystemCounter++)
    {
        PICSRulesRatingSystem * pPRRSCheck;

        pPRRSCheck=g_arrpPRRS[iSystemCounter];

        for(iCounter=0;iCounter<pPRRSCheck->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesPolicy           * pPRPolicy;
            PICSRulesPolicyExpression * pPRPolicyExpression;
            PICSRulesByURL            * pPRByURL;
            PICSRulesQuotedURL        PRQuotedURL;

            pPRPolicy=pPRRSCheck->m_arrpPRPolicy[iCounter];

            switch(pPRPolicy->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                {
                    *fPassFail=PR_PASSFAIL_PASS;

                    pPRByURL=pPRPolicy->m_pPRAcceptByURL;

                    PRQuotedURL.Set(lpszUrl);

                    PREvaluation=pPRByURL->EvaluateRule(&PRQuotedURL);

                    break;
                }
                case PR_POLICY_REJECTBYURL:
                {
                    *fPassFail=PR_PASSFAIL_FAIL;

                    pPRByURL=pPRPolicy->m_pPRRejectByURL;

                    PRQuotedURL.Set(lpszUrl);

                    PREvaluation=pPRByURL->EvaluateRule(&PRQuotedURL);

                    break;
                }
                case PR_POLICY_REJECTIF:
                {
                    *fPassFail=PR_PASSFAIL_FAIL;

                    pPRPolicyExpression=pPRPolicy->m_pPRRejectIf;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    break;
                }
                case PR_POLICY_ACCEPTIF:
                {
                    *fPassFail=PR_PASSFAIL_PASS;

                    pPRPolicyExpression=pPRPolicy->m_pPRAcceptIf;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    break;
                }
                case PR_POLICY_REJECTUNLESS:
                {
                    *fPassFail=PR_PASSFAIL_FAIL;

                    pPRPolicyExpression=pPRPolicy->m_pPRRejectUnless;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    if(PREvaluation==PR_EVALUATION_DOESNOTAPPLY)
                    {
                        PREvaluation=PR_EVALUATION_DOESAPPLY;
                    }
                    else
                    {
                        PREvaluation=PR_EVALUATION_DOESNOTAPPLY;
                    }

                    break;
                }
                case PR_POLICY_ACCEPTUNLESS:
                {
                    *fPassFail=PR_PASSFAIL_PASS;

                    pPRPolicyExpression=pPRPolicy->m_pPRAcceptUnless;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    if(PREvaluation==PR_EVALUATION_DOESNOTAPPLY)
                    {
                        PREvaluation=PR_EVALUATION_DOESAPPLY;
                    }
                    else
                    {
                        PREvaluation=PR_EVALUATION_DOESNOTAPPLY;
                    }

                    break;
                }
                case PR_POLICY_NONEVALID:
                default:
                {
                    PREvaluation=PR_EVALUATION_DOESNOTAPPLY;

                    continue;
                }
            }

            if(PREvaluation!=PR_EVALUATION_DOESNOTAPPLY)
            {
                break;
            }
        }

        if(PREvaluation!=PR_EVALUATION_DOESNOTAPPLY)
        {
            break;
        }
    }
    
    if(PREvaluation==PR_EVALUATION_DOESAPPLY)
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\reghive.cpp ===
/****************************************************************************\
 *
 *   reghive.cpp
 *
 *   Created:   William Taylor (wtaylor) 02/13/01
 *
 *   MS Ratings Registry Hive Handling
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "reghive.h"         // CRegistryHive
#include "debug.h"

const int c_iHiveFile1 = 0x1;
const int c_iHiveFile2 = 0x2;

CRegistryHive::CRegistryHive()
{
    m_fHiveLoaded = false;
    ClearHivePath();
}

CRegistryHive::~CRegistryHive()
{
    UnloadHive();
}

void CRegistryHive::UnloadHive( void )
{
    if ( m_keyHive.m_hKey != NULL )
    {
        ::RegFlushKey( m_keyHive.m_hKey );
        m_keyHive.Close();
        ::RegFlushKey( HKEY_LOCAL_MACHINE );
    }

    if ( m_fHiveLoaded )
    {
        LONG            err;

        err = ::RegUnLoadKey( HKEY_LOCAL_MACHINE, szTMPDATA );

        if ( err == ERROR_SUCCESS )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::UnloadHive() - Succesfully Unloaded Hive '%s' from szTMPDATA='%s'!", m_szPath, szTMPDATA );
            m_fHiveLoaded = false;
            ClearHivePath();
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::UnloadHive() - Failed RegUnLoadKey 0x%x with szTMPDATA='%s'!", err, szTMPDATA );
        }
    }

    ASSERT( ! m_fHiveLoaded );
}

bool CRegistryHive::OpenHiveFile( bool p_fCreate )
{
    UnloadHive();

    ASSERT( ! m_fHiveLoaded );

    LoadHiveFile( c_iHiveFile1 );

    if ( ! m_fHiveLoaded )
    {
        LoadHiveFile( c_iHiveFile2 );
    }

    if ( m_fHiveLoaded )
    {
#ifdef DEBUG
        EnumerateRegistryKeys( HKEY_LOCAL_MACHINE, (LPSTR) szTMPDATA, 0 );
#endif

        if ( OpenHiveKey() )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::OpenHiveFile() - OpenHiveKey() succeeeded." );
            return true;
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - OpenHiveKey() failed!" );
        }
    }

    UnloadHive();

    if ( ! p_fCreate )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - Failed to Open Existing Hive File!" );
        return false;
    }

    DeleteRegistryHive();

    int         iHiveFile;

    // Returns the iHiveFile set to the hive file created (c_iHiveFile1 or c_iHiveFile2).
    if ( ! CreateNewHive( iHiveFile ) )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - Failed to Create Hive File!" );
        return false;
    }

    DeleteRegistryHive();

    LoadHiveFile( iHiveFile );

    if ( m_fHiveLoaded )
    {
        if ( OpenHiveKey() )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::OpenHiveFile() - OpenHiveKey() succeeeded." );
            return true;
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - OpenHiveKey() failed!" );
        }
    }

    UnloadHive();

    return false;
}

bool CRegistryHive::OpenHiveKey( void )
{
    LONG            err;

    err = m_keyHive.Open( HKEY_LOCAL_MACHINE, szPOLUSER );

    if (err == ERROR_SUCCESS)
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::OpenHiveKey() - Successful m_keyHive Open with szPOLUSER='%s'", szPOLUSER );
        return true;
    }
    else
    {
        TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveKey() - Failed m_keyHive Open with szPOLUSER='%s'!", szPOLUSER );
    }

    return false;
}

void CRegistryHive::DeleteRegistryHive( void )
{
    MyRegDeleteKey( HKEY_LOCAL_MACHINE, szTMPDATA );

    RegFlushKey( HKEY_LOCAL_MACHINE );
}

bool CRegistryHive::CreateNewHive( int & p_riHiveFile )
{
    CRegKey     keyHive;

    if ( keyHive.Create( HKEY_LOCAL_MACHINE, szTMPDATA ) != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::CreateNewHive() - Failed to Create Hive Key szTMPDATA='%s'!", szTMPDATA );
        return false;
    }

    CRegKey     keyUser;

    if ( keyUser.Create( keyHive.m_hKey, szUSERS ) != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::CreateNewHive() - Failed to Create User Key szUSERS='%s'!", szUSERS );
        return false;
    }

    if ( SaveHiveKey( keyHive, c_iHiveFile1 ) )
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::CreateNewHive() - Saved Hive Key to Hive File 1!" );
        p_riHiveFile  = c_iHiveFile1;
        return true;
    }

    if ( SaveHiveKey( keyHive, c_iHiveFile2 ) )
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::CreateNewHive() - Saved Hive Key to Hive File 2!" );
        p_riHiveFile  = c_iHiveFile2;
        return true;
    }

    TraceMsg( TF_WARNING, "CRegistryHive::CreateNewHive() - Failed to Save Hive Key to Registry!" );
    return false;
}

bool CRegistryHive::SaveHiveKey( CRegKey & p_keyHive, int p_iFile )
{
    bool            fReturn = false;

    ASSERT( p_keyHive.m_hKey != NULL );

    SetHiveName( p_iFile );

    LONG            err;

    err = ::RegSaveKey( p_keyHive.m_hKey, m_szPath, 0 );

    if ( err == ERROR_SUCCESS )
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::SaveHiveKey() - Saved Hive Key to m_szPath='%s'!", m_szPath );
        fReturn = true;
    }
    else
    {
        TraceMsg( TF_WARNING, "CRegistryHive::SaveHiveKey() - Failed to Save Hive Key 0x%x to m_szPath='%s'!", err, m_szPath );
    }

    return fReturn;
}

BOOL CRegistryHive::BuildPolName(LPSTR pBuffer, UINT cbBuffer, UINT (WINAPI *PathProvider)(LPTSTR, UINT))
{
    if ((*PathProvider)(pBuffer, cbBuffer) + strlenf(szPOLFILE) + 2 > cbBuffer)
        return FALSE;

    LPSTR pchBackslash = strrchrf(pBuffer, '\\');
    if (pchBackslash == NULL || *(pchBackslash+1) != '\0')
        strcatf(pBuffer, "\\");

    strcatf(pBuffer, szPOLFILE);

    return TRUE;
}

void CRegistryHive::SetHiveName( int p_iFile )
{
    ASSERT( p_iFile == c_iHiveFile1 || p_iFile == c_iHiveFile2 );

    ClearHivePath();

    if ( p_iFile == c_iHiveFile1 )
    {
        BuildPolName( m_szPath, sizeof(m_szPath), GetSystemDirectory );
    }
    else
    {
        BuildPolName( m_szPath, sizeof(m_szPath), GetWindowsDirectory );
    }
}

void CRegistryHive::LoadHiveFile( int p_iFile )
{
    LONG            err;
    
    err = ERROR_FILE_NOT_FOUND;

    ASSERT( ! m_fHiveLoaded );

    if ( m_fHiveLoaded )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::LoadHiveFile() - Hive File Already Loaded!" );
        return;
    }

    SetHiveName( p_iFile );

    if ( ::GetFileAttributes( m_szPath ) != 0xFFFFFFFF )
    {
        err = ::RegLoadKey( HKEY_LOCAL_MACHINE, szTMPDATA, m_szPath );

        if ( err == ERROR_SUCCESS )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::LoadHiveFile() - Loaded Hive File szTMPDATA='%s' m_szPath='%s'!", szTMPDATA, m_szPath );
            m_fHiveLoaded = true;
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::LoadHiveFile() - Failed RegLoadKey szTMPDATA='%s' m_szPath='%s'!", szTMPDATA, m_szPath );
        }
    }

    if ( ! m_fHiveLoaded )
    {
        ClearHivePath();
    }

    return;
}

#ifdef DEBUG
void CRegistryHive::EnumerateRegistryKeys( HKEY hkeyTop, LPSTR pszKeyName, int iLevel )
{
    if ( ! hkeyTop )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - hkeyTop is NULL!" );
        return;
    }

    if ( ! pszKeyName )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - pszKeyName is NULL!" );
        return;
    }

    CRegKey         keyHive;

    if ( keyHive.Open( hkeyTop, pszKeyName ) == ERROR_SUCCESS )
    {
        // Enumerate Open Key's Values.
        {
            char szKeyValue[MAXPATHLEN];
            int j = 0;
            DWORD       cchValueSize = sizeof(szKeyValue);
            DWORD       dwType;

            // enumerate the subkeys, which are rating systems
            while ( RegEnumValue( keyHive.m_hKey, j, szKeyValue, &cchValueSize,
                        NULL, &dwType, NULL, NULL ) == ERROR_SUCCESS )
            {
                switch ( dwType )
                {
                case REG_DWORD:
                    {
                        ETN         etn;

                        EtNumRegRead( etn, keyHive.m_hKey, szKeyValue );

                        TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: etn=0x%x for %d pszKeyName='%s' szKeyValue='%s'", iLevel, etn.Get(), j, pszKeyName, szKeyValue );
                    }
                    break;

                case REG_BINARY:
                    {
                        ETB         etb;

                        EtBoolRegRead( etb, keyHive.m_hKey, szKeyValue );

                        TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: etb=0x%x for %d pszKeyName='%s' szKeyValue='%s'", iLevel, etb.Get(), j, pszKeyName, szKeyValue );
                    }
                    break;

                case REG_SZ:
                    {
                        ETS         ets;

                        EtStringRegRead( ets, keyHive.m_hKey, szKeyValue );

                        TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: ets='%s' for %d pszKeyName='%s' szKeyValue='%s'", iLevel, ets.Get(), j, pszKeyName, szKeyValue );
                    }
                    break;

                default:
                    TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Unhandled Enumeration Type %d for szKeyValue='%s'!", iLevel, dwType, szKeyValue );
                    break;
                }

                cchValueSize = sizeof(szKeyValue);
                j++;
            }

            TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Completed Enumeration of %d values in pszKeyName='%s'", iLevel, j, pszKeyName );
        }

        // Enumerate Open Key's Subkeys.
        {
            char szKeyName[MAXPATHLEN];
            int j = 0;

            // enumerate the subkeys, which are rating systems
            while ( RegEnumKey( keyHive.m_hKey, j, szKeyName, sizeof(szKeyName) ) == ERROR_SUCCESS )
            {
                EnumerateRegistryKeys( keyHive.m_hKey, szKeyName, iLevel+1 );
                j++;
            }

            TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Completed Enumeration of %d keys in pszKeyName='%s'", iLevel, j, pszKeyName );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Failed to Open key pszKeyName='%s' for Enumeration!", iLevel, pszKeyName );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\reghive.h ===
/****************************************************************************\
 *
 *   reghive.h
 *
 *   Created:   William Taylor (wtaylor) 02/13/01
 *
 *   MS Ratings Registry Hive Handling
 *
\****************************************************************************/

#ifndef REGISTRY_HIVE_H
#define REGISTRY_HIVE_H

class CRegistryHive
{
private:
    bool        m_fHiveLoaded;              // Hive Loaded?
    char        m_szPath[MAXPATHLEN+1];     // Hive File Path
    CRegKey     m_keyHive;                  // Registry Key to Hive

public:
    CRegistryHive();
    ~CRegistryHive();

    const CRegKey &     GetHiveKey( void )      { return m_keyHive; }

    void    UnloadHive( void );
    bool    OpenHiveFile( bool p_fCreate );

protected:
    bool    OpenHiveKey( void );
    void    DeleteRegistryHive( void );
    bool    CreateNewHive( int & p_riHiveFile );
    bool    SaveHiveKey( CRegKey & p_keyHive, int p_iFile );
    void    ClearHivePath( void )               { m_szPath[0] = '\0'; }
    BOOL    BuildPolName(LPSTR pBuffer, UINT cbBuffer, UINT (WINAPI *PathProvider)(LPTSTR, UINT));
    void    SetHiveName( int p_iFile );
    void    LoadHiveFile( int p_iFile );

#ifdef DEBUG
    void    EnumerateRegistryKeys( HKEY hkeyTop, LPSTR pszKeyName, int iLevel );
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\resource.h ===
#define IDB_KEYS                         99
#define IDB_LOCK                         100
#define IDB_BITMAP1                      101
#define IDI_SECURITY                     102
#define IDI_MAIN                         104
#define IDI_UNRATED                      105
#define IDI_KEYS                         106
#define IDI_MASTER_KEY                   107
#define IDD_LOGON                        108
#define IDI_RATING_CATEGORIES            109
#define IDI_RATED_SITES                  110
#define IDD_PLEASE                       111
#define IDI_RATING_SYSTEMS               112
#define IDD_GENERAL                      113
#define IDI_INTERNET_RATINGS             114
#define IDC_UNRATED                      115
#define IDC_PLEASE_MOMMY                 116
#define IDD_PICSRULES                    117
#define IDD_APPROVEDSITES                118
#define IDC_CHANGE_PASSWORD              119
#define IDI_APPROVED                     120
#define IDC_MASTER_USER                  121
#define IDC_CONTROL_PANEL                122
#define IDC_NEW_APPS                     123
#define IDD_PROVIDERS                    124
#define IDC_PROVIDERLIST                 125
#define IDC_OPENPROVIDER                 126
#define IDC_CLOSEPROVIDER                127
#define IDD_ADVANCED                     128
#define IDD_CREATE_PASSWORD              129
#define IDD_PASSWORD                     130
#define IDC_PASSWORD                     131
#define IDC_CONFIRM_PASSWORD             132
#define IDD_INTRO                        133
#define IDC_SET_RATINGS                  134
#define IDC_TURN_ONOFF                   135
#define IDC_INTRO_TEXT                   136
#define IDD_CHANGE_PASSWORD              137
#define IDC_OLD_PASSWORD                 138
#define IDD_RATINGS                      139
#define IDC_RATING_LABEL                 140
#define IDD_USER_LIST                    141
#define IDC_PG_A_EDIT                    142
#define IDC_L_COMBO                      143
#define IDC_PT_TREE                      144
#define IDC_PT_T_RSN_LDESC               145
#define IDC_PT_TB_SELECT                 146
#define IDC_PT_T_RSN_SDESC               147
#define IDC_PT_T_BITMAP_CATEGORY         148
#define IDC_PT_T_BITMAP_LABEL            149
#define IDC_ADD                          150
#define IDC_REMOVE                       151
#define IDC_PROPERTIES                   152
#define IDC_USERNAME                     153
#define IDC_APPLY                        154
#define IDC_PROVIDER                     155
#define IDB_ICON_PROVIDER                156
#define IDC_3RD_COMBO                    157
#define IDC_TEXT1                        158
#define IDC_TEXT2                        159
#define IDC_TEXT3                        160
#define IDC_STATIC1                      161
#define IDC_STATIC2                      162
#define IDC_STATIC3                      163
#define IDC_STATIC4                      164
#define IDC_STATIC5                      165
#define IDC_STATIC6                      166
#define IDC_STATIC7                      167
#define IDC_STATIC8                      168
#define IDC_STATIC9                      169
#define IDC_CREATE_PASSWORD              170
#define IDS_RAT_OPENFILE                 225
#define IDS_RAT_FILTER_DESC              226
#define IDS_RAT_FILTER                   227
#define IDS_NOCANDO_TITLE                228
#define IDS_NOCANDO                      229
#define IDS_RATING_OFF                   230
#define IDS_RATING_ON                    231
#define IDS_TURN_ON                      232
#define IDS_TURN_OFF                     233
#define IDS_GENERIC                      234
#define IDS_NOW_ON                       235
#define IDS_NOW_OFF                      236
#define IDS_NO_PASSWORD                  237
#define IDS_NO_CONFIRM                   238
#define IDS_NO_MATCH                     239
#define IDS_BADPASSWORD                  240
#define IDS_NO_OLD                       241
#define IDS_NO_PROVIDERS                 242
#define IDS_INSTALL_INFO                 243
#define IDS_TURN_ONOFF                   244
#define IDS_RATING_NEW                   245
#define IDS_BADBUREAU                    246
#define IDS_VALUE                        247
#define IDS_NEEDBUREAU                   248
#define IDS_CANT_LAUNCH                  249
#define IDS_PASSWORD_CHANGED             250
#define IDS_RATINGTEMPLATE               251
#define IDS_UNRATED                      252
#define IDS_UNKNOWNSYSTEM                253
#define IDS_INVALIDRATING                254
#define IDS_EXPIRED                      255
#define IDS_WRONGURL                     256
#define IDS_LABELERROR                   257
#define IDS_UNKNOWNRATING                258
#define IDS_UNKNOWNRATINGTEMPLATE        259
#define IDS_NOWENABLED                   260
#define IDS_LOADRAT_MEMORY               261
#define IDS_LOADRAT_EXPECTEDLEFT         262
#define IDS_LOADRAT_EXPECTEDRIGHT        263
#define IDS_LOADRAT_EXPECTEDTOKEN        264
#define IDS_LOADRAT_EXPECTEDSTRING       265
#define IDS_LOADRAT_EXPECTEDNUMBER       266
#define IDS_LOADRAT_EXPECTEDBOOL         267
#define IDS_LOADRAT_DUPLICATEITEM        268
#define IDS_LOADRAT_MISSINGITEM          269
#define IDS_LOADRAT_UNKNOWNITEM          270
#define IDS_LOADRAT_UNKNOWNMANDATORY     271
#define IDS_LOADRAT_UNKNOWNERROR         272
#define IDS_LOADRAT_WINERROR             273
#define IDS_LOADRAT_MISCERROR            274
#define IDS_LOADRAT_SYNTAX_TEMPLATE      275
#define IDS_LOADRAT_GENERIC_TEMPLATE     276
#define IDS_INVALID_PROVIDERS            277
#define IDS_ALREADY_INSTALLED            278
#define IDS_NO_BUREAU                    279
#define IDS_NO_SETTINGS                  280
#define IDS_DESCRIPTION_SEPARATOR        281
#define IDS_FRAME                        282
#define IDS_ENABLE_WARNING               283
#define IDS_PICSRULES_SYNTAX_TEMPLATE    284
#define IDS_PICSRULES_GENERIC_TEMPLATE   285
#define IDS_PICSRULES_MEMORY             286
#define IDS_PICSRULES_EXPECTEDLEFT       287
#define IDS_PICSRULES_EXPECTEDRIGHT      288
#define IDS_PICSRULES_EXPECTEDTOKEN      289
#define IDS_PICSRULES_EXPECTEDSTRING     290
#define IDS_PICSRULES_EXPECTEDNUMBER     291
#define IDS_PICSRULES_EXPECTEDBOOL       292
#define IDS_PICSRULES_DUPLICATEITEM      293
#define IDS_PICSRULES_MISSINGITEM        294
#define IDS_PICSRULES_UNKNOWNITEM        295
#define IDS_PICSRULES_UNKNOWNMANDATORY   296
#define IDS_PICSRULES_UNKNOWNERROR       297
#define IDS_PICSRULES_WINERROR           298
#define IDS_PICSRULES_MISCERROR          299
#define IDS_ERROR                        300
#define IDS_PICSRULES_INVALID            301
#define IDS_PICSRULES_SERVICEUNDEFINED   302
#define IDS_OPENDIALOGFILTER             303
#define IDS_OPENDIALOGTITLE              304
#define IDS_PICSRULES_REQEXTENSIONUSED   305
#define IDS_PICSRULES_BADVERSION         306
#define IDS_PICSRULES_EXPECTEDEND        307
#define IDS_PICSRULES_SYSTEMERROR        308
#define IDS_PICSRULES_TAMPEREDTITLE      309
#define IDS_PICSRULES_TAMPEREDMESSAGE    310
#define IDS_PICSRULES_EXISTSTITLE        311
#define IDS_PICSRULES_EXISTSMESSAGE      312
#define IDS_PICSRULES_ERRORSAVINGTITLE   313
#define IDS_PICSRULES_ERRORSAVINGMSG     314
#define IDS_PICSRULES_SUCCESSTITLE       315
#define IDS_PICSRULES_SUCCESSMESSAGE     316
#define IDS_PICSRULES_TAMPEREDREADTITLE  317
#define IDS_PICSRULES_TAMPEREDREADMSG    318
#define IDI_ACCEPTALWAYS                 319
#define IDI_ACCEPTNEVER                  320
#define IDS_PICSRULES_DUPLICATETITLE     321
#define IDS_PICSRULES_DUPLICATEMSG       322
#define IDS_PICSRULES_BADURLTITLE        323
#define IDS_PICSRULES_BADURLMSG          324
#define IDS_PICSRULES_OUTOFMEMORY        325
#define IDS_PICSRULES_NOAPPROVEDSAVE     326
#define IDS_APPROVEDSITES_ENFORCED       327
#define IDS_PICSRULES_ENFORCED           328
#define IDC_BLOCKING_SITE                329
#define IDC_BLOCKING_PAGE                330
#define IDC_BLOCKING_ONCE                331
#define IDS_APPROVED_CANTSAVE            332
#define IDS_LOADRAT_EXPECTEDEND          333
#define IDS_NO_NULL_PASSWORD             334
#define IDC_PICSRULES_DOWN               335
#define IDI_PICSRULES_UP                 336
#define IDI_PICSRULES_DOWN               337
#define IDB_SYSTEMS                      338
#define IDB_CATEGORIES                   339
#define IDC_ADVISOR_OFF_CHECK            340
#define IDD_TURNOFF                      341
#define IDS_SOURCE_SERVER                342
#define IDS_SOURCE_EMBEDDED              343
#define IDS_SOURCE_BUREAU                344
#define IDS_TAMPEREDRATING1              345
#define IDS_TAMPEREDRATING2              346
#define IDS_PICSRULES_CLICKIMPORTTITLE   347
#define IDS_PICSRULES_CLICKIMPORTMESSAGE 348
#define IDS_PICSRULES_CLICKIMPORTON      349
#define IDS_PICSRULES_CLICKFINISHED      350
#define IDS_PICSRULES_CLICKRATON         351
#define IDS_PICSRULES_CLICKRATMESSAGE    352
#define IDD_PRFPASSWORDNOEXIST           353
#define IDD_PRFPASSWORDEXISTS            354
#define IDC_PRFPASSWORD                  355
#define IDC_RATPASSWORD                  356
#define IDD_RATPASSWORDEXISTS            357
#define IDD_RATPASSWORDNOEXIST           358
#define IDS_PASSWORD_LABEL              500
#define IDS_PICS_RULES_LABEL            501
#define IDS_RATING_SYSTEM_LABEL         502
#define IDS_NO_HINT                     503
#define IDS_HINT_RECOMMENDED            504
#define IDS_REGISTRY_NOT_MODIFIABLE     505
#define IDS_PASSWORD_CREATED            506
#define IDS_CREATE_PASSWORD             507
#define IDS_CHANGE_PASSWORD             508
#define IDC_FINDRATINGS                  1000
#define IDC_PICSRULES_SPIN               1002
#define IDC_PICSRULES_LIST               1004
#define IDC_DETAILSBUTTON                1005
#define IDC_PICSRULES_UP                 1005
#define IDC_CONTENTLABEL                 1006
#define IDC_CONTENTDESCRIPTION           1007
#define IDC_CONTENTERROR                 1008
#define IDC_PICSRULESOPEN                1009
#define IDC_PICSRULESEDIT                1010
#define IDC_PICSRULESAPPROVEDEDIT        1011
#define IDC_PICSRULESAPPROVEDALWAYS      1012
#define IDC_PICSRULESAPPROVEDLIST        1014
#define IDC_PICSRULESAPPROVEDREMOVE      1015
#define IDC_STATIC_ALLOW                 1017
#define IDC_PICSRULESAPPROVEDNEVER       1018
#define IDC_STATIC_LIST                  1019
#define IDC_PICSRULESAPPROVEDCOMMBAND    1020
#define IDC_STATIC_COMMBAND1             1021
#define IDC_STATIC_COMMBAND2             1022
#define IDC_STATIC_PICSRULES             1023
#define IDC_STATIC_PICSRULES2            1024
#define IDC_HINT_EDIT                   1001
#define IDC_HINT_TEXT                   1002
#define IDC_HINT_LABEL                  1003
#define IDC_OLD_HINT_LABEL              1004
#define IDC_OLD_HINT_TEXT               1005
#define IDS_RATING_SYSTEM_FILE           3000
#define IDS_PICS_RULES_FILE              3001
#define IDS_CONTENT_ADVISOR_TITLE        3002
#define IDS_CONTENT_ADVISOR_HTTP_TITLE   3003
#define IDC_STATIC                       (-1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\ratings.cpp ===
/****************************************************************************\
 *
 *   RATINGS.CPP --Parses out the actual ratings from a site.
 *
 *   Created:   Ann McCurdy
 *     
\****************************************************************************/

/*Includes---------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "debug.h"
#include <ratings.h>
#include <ratingsp.h>
#include "parselbl.h"
#include "picsrule.h"
#include "pleasdlg.h"       // CPleaseDialog
#include <convtime.h>
#include <contxids.h>
#include <shlwapip.h>


#include <wininet.h>

#include <mluisupp.h>

extern PICSRulesRatingSystem * g_pPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRSPreApply;
extern array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern BOOL g_fPICSRulesEnforced,g_fApprovedSitesEnforced;

extern HMODULE g_hURLMON,g_hWININET;

extern char g_szLastURL[INTERNET_MAX_URL_LENGTH];

extern HINSTANCE g_hInstance;

HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

DWORD g_dwDataSource;
BOOL  g_fInvalid;

PicsRatingSystemInfo *gPRSI = NULL;


//7c9c1e2a-4dcd-11d2-b972-0060b0c4834d
const GUID GUID_Ratings = { 0x7c9c1e2aL, 0x4dcd, 0x11d2, { 0xb9, 0x72, 0x00, 0x60, 0xb0, 0xc4, 0x83, 0x4d } };

//7c9c1e2b-4dcd-11d2-b972-0060b0c4834d
const GUID GUID_ApprovedSites = { 0x7c9c1e2bL, 0x4dcd, 0x11d2, { 0xb9, 0x72, 0x00, 0x60, 0xb0, 0xc4, 0x83, 0x4d } };


extern CustomRatingHelper *g_pCustomRatingHelperList;
BOOL g_fIsRunningUnderCustom = FALSE;

void TerminateRatings(BOOL bProcessDetach);

//+-----------------------------------------------------------------------
//
//  Function:  RatingsCustomInit
//
//  Synopsis:  Initialize the msrating dll for Custom
//
//  Arguments: bInit (Default TRUE) - TRUE: change into Custom Mode
//                                    FALSE: change out of Custom Mode
//
//  Returns:   S_OK if properly initialized, E_OUTOFMEMORY otherwise
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomInit(BOOL bInit)
{
    HRESULT hres = E_OUTOFMEMORY;

    ENTERCRITICAL;

    if (bInit)
    {
        if (NULL != gPRSI)
        {
            delete gPRSI;
        }
        gPRSI = new PicsRatingSystemInfo;
        if (gPRSI)
        {
            g_fIsRunningUnderCustom = TRUE;
            hres = S_OK;
        }
    }
    else
    {
        TerminateRatings(FALSE);
        RatingInit();
        g_fIsRunningUnderCustom = FALSE;
        hres = S_OK;
    }
    LEAVECRITICAL;

    return hres;
    
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomAddRatingSystem
//
//  Synopsis:  Hand the description of a PICS rating system file to msrating.
//             The description is simply the contents of an RAT file.
//
//  Arguments: pszRatingSystemBuffer : buffer containing the description
//             nBufferSize : the size of pszRatingSystemBuffer
//
//  Returns:   Success if rating system added
//             This function will not succeed if RatingCustomInit has
//             not been called.
//
//------------------------------------------------------------------------
STDAPI RatingCustomAddRatingSystem(LPSTR pszRatingSystemBuffer, UINT nBufferSize)
{
    HRESULT hres = E_OUTOFMEMORY;

    if(!pszRatingSystemBuffer || nBufferSize == 0)
    {
        return E_INVALIDARG;
    }

    if (g_fIsRunningUnderCustom)
    {
        PicsRatingSystem* pPRS = new PicsRatingSystem;
 
        if (pPRS)
        {
            hres = pPRS->Parse(NULL, pszRatingSystemBuffer);
            if (SUCCEEDED(hres))
            {
                pPRS->dwFlags |= PRS_ISVALID;
            }
        }
        
        if (SUCCEEDED(hres))
        {
            ENTERCRITICAL;
        
            gPRSI->arrpPRS.Append(pPRS);
            gPRSI->fRatingInstalled = TRUE;

            LEAVECRITICAL;
        }
        else
        {
            if(pPRS)
            {
                delete pPRS;
                pPRS = NULL;
            }
        }
    }
    else
    {
        hres = E_FAIL;
    }
    return hres;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomSetUserOptions
//
//  Synopsis:  Set the user options for the msrating dll for this process
//
//  Arguments: pRSSetings : pointer to an array of rating system settings
//             cSettings : number of rating systems
//
//  Returns:   Success if user properly set
//             This function will not succeed if RatingCustomInit has
//             not been called.
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomSetUserOptions(RATINGSYSTEMSETTING* pRSSettings, UINT cSettings) {

    if (!pRSSettings || cSettings == 0)
    {
        return E_INVALIDARG;
    }
    ENTERCRITICAL;

    HRESULT hres = E_OUTOFMEMORY;
    UINT err, errTemp;

    if (g_fIsRunningUnderCustom)
    {
        if (gPRSI)
        {
            PicsUser* puser = new PicsUser;

            if (puser)
            {
                for (UINT i=0; i<cSettings; i++)
                {
                    UserRatingSystem* pURS = new UserRatingSystem;
                    if (!pURS)
                    {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    if (errTemp = pURS->QueryError())
                    {
                        err = errTemp;
                        break;
                    }
                    RATINGSYSTEMSETTING* parss = &pRSSettings[i];
                    
                    pURS->SetName(parss->pszRatingSystemName);
                    pURS->m_pPRS = FindInstalledRatingSystem(parss->pszRatingSystemName);
                    
                    for (UINT j=0; j<parss->cCategories; j++)
                    {
                        UserRating* pUR = new UserRating;
                        if (pUR)
                        {
                            if (errTemp = pUR->QueryError())
                            {
                                err = errTemp;
                            }
                            else
                            {
                                RATINGCATEGORYSETTING* parcs = &parss->paRCS[j];
                                pUR->SetName(parcs->pszValueName);
                                pUR->m_nValue = parcs->nValue;
                                if (pURS->m_pPRS)
                                {
                                    pUR->m_pPC = FindInstalledCategory(pURS->m_pPRS->arrpPC, parcs->pszValueName);
                                }
                                err = pURS->AddRating(pUR);
                            }
                        }
                        else
                        {
                            err = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        if (ERROR_SUCCESS != err)
                        {
                            if (pUR)
                            {
                                delete pUR;
                                pUR = NULL;
                            }
                            break;
                        }
                    }
                    if (ERROR_SUCCESS == err)
                    {
                        err = puser->AddRatingSystem(pURS);
                    }
                    if (ERROR_SUCCESS != err)
                    {
                        if (pURS)
                        {
                            delete pURS;
                            pURS = NULL;
                        }
                        break;
                    }
                }
                if (ERROR_SUCCESS == err)
                {
                    hres = NOERROR;
                    gPRSI->fSettingsValid = TRUE;
                    if (gPRSI->pUserObject)
                    {
                        delete gPRSI->pUserObject;
                    }
                    gPRSI->pUserObject = puser;
                }
            }
        }
        else
        {
            hres = E_UNEXPECTED;
        }
    }
    else
    {
        hres = E_FAIL;
    }
    LEAVECRITICAL;
    
    return hres;

}


//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomAddRatingHelper
//
//  Synopsis:  Add a Custom ratings helper object
//
//  Arguments: pszLibraryName : name of the library to load the helper from
//             clsid : CLSID of the rating helper
//             dwSort : Sort order or priority of the helper
//
//  Returns:   Success if rating helper added properly set
//             This function will not succeed if RatingCustomInit has
//             not been called.
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomAddRatingHelper(LPCSTR pszLibraryName, CLSID clsid, DWORD dwSort)
{ 
    HRESULT hr = E_UNEXPECTED;

    if (g_fIsRunningUnderCustom)
    {
        CustomRatingHelper* pmrh = new CustomRatingHelper;

        if(NULL == pmrh)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pmrh->hLibrary = LoadLibrary(pszLibraryName);
            if (pmrh->hLibrary)
            {
                pmrh->clsid = clsid;
                pmrh->dwSort = dwSort;

                ENTERCRITICAL;

                CustomRatingHelper* pmrhCurrent = g_pCustomRatingHelperList;
                CustomRatingHelper* pmrhPrev = NULL;

                while (pmrhCurrent && pmrhCurrent->dwSort < pmrh->dwSort)
                {
                    pmrhPrev = pmrhCurrent;
                    pmrhCurrent = pmrhCurrent->pNextHelper;
                }

                if (pmrhPrev)
                {
                    ASSERT(pmrhPrev->pNextHelper == pmrhCurrent);

                    pmrh->pNextHelper = pmrhCurrent;
                    pmrhPrev->pNextHelper = pmrh;
                }
                else
                {
                    ASSERT(pmrhCurrent == g_pCustomRatingHelperList);

                    pmrh->pNextHelper = g_pCustomRatingHelperList;
                    g_pCustomRatingHelperList = pmrh;
                }


                hr = S_OK;

                LEAVECRITICAL;
            
            } // if (pmrh->hLibrary)
            else
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomRemoveRatingHelper
//
//  Synopsis:  Remove Custom rating helpers
//
//  Arguments: CLSID : CLSID of the helper to remove
//
//  Returns:   S_OK if rating helper removed, S_FALSE if not found
//             E_UNEXPECTED if the global custom helper list is corrupted.
//             This function will not succeed if RatingCustomInit has
//             not been called and will return E_FAIL
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomRemoveRatingHelper(CLSID clsid)
{
    CustomRatingHelper* pmrhCurrent = NULL;
    CustomRatingHelper* pmrhTemp = NULL;
    CustomRatingHelper* pmrhPrev = NULL;

    HRESULT hr = E_UNEXPECTED;

    if (g_fIsRunningUnderCustom)
    {
        if (NULL != g_pCustomRatingHelperList)
        {
            hr = S_FALSE;

            ENTERCRITICAL;
        
            pmrhCurrent = g_pCustomRatingHelperList;

            while (pmrhCurrent && pmrhCurrent->clsid != clsid)
            {
                pmrhPrev = pmrhCurrent;
                pmrhCurrent = pmrhCurrent->pNextHelper;
            }

            if (pmrhCurrent)
            {
                //
                // Snag copy of the node
                //
                pmrhTemp = pmrhCurrent;

                if (pmrhPrev)   // Not on first node
                {
                    //
                    // Unlink the deleted node
                    //
                    pmrhPrev->pNextHelper = pmrhCurrent->pNextHelper;
                }
                else            // First node -- adjust head pointer
                {
                    ASSERT(pmrhCurrent == g_pCustomRatingHelperList);

                    g_pCustomRatingHelperList = g_pCustomRatingHelperList->pNextHelper;
                }

                //
                // Wipe out the node
                //
                delete pmrhTemp;
                pmrhTemp = NULL;

                hr = S_OK;
            }

            LEAVECRITICAL;
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomSetDefaultBureau
//
//  Synopsis:  Set the URL of the default rating bureau
//
//  Arguments: pszRatingBureau - URL of the rating bureau
//
//  Returns:   S_OK if success, E_FAIL if RatingCustomInit has not been
//             called, E_OUTOFMEMORY if unable to allocate memory
//             E_INVALIDARG if pszRatingBureau is NULL
//             This function will not succeed if RatingCustomInit has
//             not been called and return E_FAIL.
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomSetDefaultBureau(LPCSTR pszRatingBureau)
{
    HRESULT hr;

    if (pszRatingBureau)
    {
        if (g_fIsRunningUnderCustom)
        {
            LPSTR pszTemp = new char[strlenf(pszRatingBureau)+1];
            if (pszTemp)
            {
                strcpy(pszTemp, pszRatingBureau);
                gPRSI->etstrRatingBureau.SetTo(pszTemp);
                hr = S_OK;
            } // if (pszTemp)
            else
            {
                hr = E_OUTOFMEMORY;
            }
        } // if(g_fIsRunningUnderCustom)
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT WINAPI RatingInit()
{
    DWORD                   dwNumSystems,dwCounter;
    HRESULT                 hRes;
    PICSRulesRatingSystem   * pPRRS=NULL;

    g_hURLMON=LoadLibrary("URLMON.DLL");

    if (g_hURLMON==NULL)
    {
        TraceMsg( TF_ERROR, "RatingInit() - Failed to Load URLMON!" );

        g_pPRRS=NULL;                   //we couldn't load URLMON

        hRes=E_UNEXPECTED;
    }

    g_hWININET=LoadLibrary("WININET.DLL");

    if (g_hWININET==NULL)
    {
        TraceMsg( TF_ERROR, "RatingInit() - Failed to Load WININET!" );

        g_pPRRS=NULL;                   //we couldn't load WININET

        hRes=E_UNEXPECTED;
    }

    g_HandleGlobalCounter=SHGlobalCounterCreate(GUID_Ratings);
    g_lGlobalCounterValue=SHGlobalCounterGetValue(g_HandleGlobalCounter);

    g_ApprovedSitesHandleGlobalCounter=SHGlobalCounterCreate(GUID_ApprovedSites);
    g_lApprovedSitesGlobalCounterValue=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter);

    gPRSI = new PicsRatingSystemInfo;
    if(gPRSI == NULL)
    {
        TraceMsg( TF_ERROR, "RatingInit() - gPRSI is NULL!" );
        return E_OUTOFMEMORY;
    }

    gPRSI->Init();

    hRes=PICSRulesReadFromRegistry(PICSRULES_APPROVEDSITES,&g_pApprovedPRRS);

    if (FAILED(hRes))
    {
        g_pApprovedPRRS=NULL;
    }

    hRes=PICSRulesGetNumSystems(&dwNumSystems);

    if (SUCCEEDED(hRes)) //we have PICSRules systems to inforce
    {
        for (dwCounter=PICSRULES_FIRSTSYSTEMINDEX;
            dwCounter<(dwNumSystems+PICSRULES_FIRSTSYSTEMINDEX);
            dwCounter++)
        {
            hRes=PICSRulesReadFromRegistry(dwCounter,&pPRRS);

            if (FAILED(hRes))
            {
                char    *lpszTitle,*lpszMessage;

                //we couldn't read in the systems, so don't inforce PICSRules,
                //and notify the user
                
                g_arrpPRRS.DeleteAll();

                lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
                lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

                MLLoadString(IDS_PICSRULES_TAMPEREDREADTITLE,(LPTSTR) lpszTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_TAMPEREDREADMSG,(LPTSTR) lpszMessage,MAX_PATH);

                MessageBox(NULL,(LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

                GlobalFree(lpszTitle);
                lpszTitle = NULL;
                GlobalFree(lpszMessage);
                lpszMessage = NULL;

                break;
            }
            else
            {
                g_arrpPRRS.Append(pPRRS);

                pPRRS=NULL;
            }
        }
    }

    return NOERROR; 
}

// YANGXU: 11/16/1999
// Actual rating term function that does the work
// bProcessDetach: pass in as true if terminating during
// ProcessDetach so libraries are not freed

void TerminateRatings(BOOL bProcessDetach)
{
    delete gPRSI;
    gPRSI = NULL;

    if (g_pApprovedPRRS != NULL)
    {
        delete g_pApprovedPRRS;
        g_pApprovedPRRS = NULL;
    }

    if (g_pApprovedPRRSPreApply != NULL)
    {
        delete g_pApprovedPRRSPreApply;
        g_pApprovedPRRSPreApply = NULL;
    }

    g_arrpPRRS.DeleteAll();
    g_arrpPICSRulesPRRSPreApply.DeleteAll();

    CloseHandle(g_HandleGlobalCounter);
    CloseHandle(g_ApprovedSitesHandleGlobalCounter);

    CustomRatingHelper  *pTemp;
    
    while (g_pCustomRatingHelperList)
    {
        pTemp = g_pCustomRatingHelperList;

        if (bProcessDetach)
        {
            // TRICKY: Can't FreeLibrary() during DLL_PROCESS_DETACH, so leak the HMODULE...
            //         (setting to NULL prevents the destructor from doing FreeLibrary()).
            //
            g_pCustomRatingHelperList->hLibrary = NULL;
        }
        
        g_pCustomRatingHelperList = g_pCustomRatingHelperList->pNextHelper;

        delete pTemp;
        pTemp = NULL;
    }

    if (bProcessDetach)
    {
        if ( g_hURLMON )
        {
            FreeLibrary(g_hURLMON);
            g_hURLMON = NULL;
        }

        if ( g_hWININET )
        {
            FreeLibrary(g_hWININET);
            g_hWININET = NULL;
        }
    }
}

void RatingTerm()
{
    TerminateRatings(TRUE);
}


HRESULT WINAPI RatingEnabledQuery()
{
    CheckGlobalInfoRev();

    // $BUG - If the Settings are not valid should we return E_FAIL?
    if (gPRSI && !gPRSI->fSettingsValid)
        return S_OK;

    if (gPRSI && gPRSI->fRatingInstalled) {
        PicsUser *pUser = ::GetUserObject();
        return (pUser && pUser->fEnabled) ? S_OK : S_FALSE;
    }
    else {
        return E_FAIL;
    }
}

// Store the Parsed Label List of Ratings Information to ppRatingDetails.
void StoreRatingDetails( CParsedLabelList * pParsed, LPVOID * ppRatingDetails )
{
    if (ppRatingDetails != NULL)
    {
        *ppRatingDetails = pParsed;
    }
    else
    {
        if ( pParsed )
        {
            FreeParsedLabelList(pParsed);
            pParsed = NULL;
        }
    }
}

HRESULT WINAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                                     LPCSTR pszRatingInfo, LPBYTE pData,
                                     DWORD cbData, LPVOID *ppRatingDetails)
{
    HRESULT hRes;
    BOOL    fPassFail;

    g_fInvalid=FALSE;
    g_dwDataSource=cbData;
    g_fPICSRulesEnforced=FALSE;
    g_fApprovedSitesEnforced=FALSE;
    if (pszURL)
        lstrcpy(g_szLastURL,pszURL);

    CheckGlobalInfoRev();

    if (ppRatingDetails != NULL)
        *ppRatingDetails = NULL;

    if (!gPRSI->fSettingsValid)
        return ResultFromScode(S_FALSE);

    if (!gPRSI->fRatingInstalled)
        return ResultFromScode(S_OK);

    PicsUser *pUser = GetUserObject(pszUsername);
    if (pUser == NULL) {
        return HRESULT_FROM_WIN32(ERROR_BAD_USERNAME);
    }

    if (!pUser->fEnabled)
        return ResultFromScode(S_OK);

    //check Approved Sites list
    hRes=PICSRulesCheckApprovedSitesAccess(pszURL,&fPassFail);

    if (SUCCEEDED(hRes)&&!g_fIsRunningUnderCustom) //the list made a determination, skip if Custom
    {
        g_fApprovedSitesEnforced=TRUE;

        if (fPassFail==PR_PASSFAIL_PASS)
        {
            return ResultFromScode(S_OK);
        }
        else
        {
            return ResultFromScode(S_FALSE);
        }
    }

    CParsedLabelList *pParsed=NULL;

    //check PICSRules systems
    hRes=PICSRulesCheckAccess(pszURL,pszRatingInfo,&fPassFail,&pParsed);

    if (SUCCEEDED(hRes)&&!g_fIsRunningUnderCustom) //the list made a determination, skip if Custom
    {
        g_fPICSRulesEnforced=TRUE;

        if (ppRatingDetails != NULL)
            *ppRatingDetails = pParsed;
        else
            FreeParsedLabelList(pParsed);

        if (fPassFail==PR_PASSFAIL_PASS)
        {
            return ResultFromScode(S_OK);
        }
        else
        {
            return ResultFromScode(S_FALSE);
        }
    }

    if (pszRatingInfo == NULL)
    {
        if (pUser->fAllowUnknowns)
        {
            hRes = ResultFromScode(S_OK);
        }
        else
        {
            hRes = ResultFromScode(S_FALSE);
        }

        //Site is unrated.  Check if user can see unrated sites.
        /** Custom **/
        // if notification interface exists, put in the URL
        if ( ( g_fIsRunningUnderCustom || ( hRes != S_OK ) )
                && ( ppRatingDetails != NULL ) )
        {
            if (!pParsed)
            {
                pParsed = new CParsedLabelList;
            }
            if (pParsed)
            {
                ASSERT(!pParsed->m_pszURL);
                pParsed->m_pszURL = new char[strlenf(pszURL) + 1];
                if (pParsed->m_pszURL != NULL)
                {
                    strcpyf(pParsed->m_pszURL, pszURL);
                }

                pParsed->m_fNoRating = TRUE;
                *ppRatingDetails = pParsed;
            }
        }

        return hRes;
    }    
    else
    {
        if (pParsed!=NULL)
        {
            hRes = S_OK;
        }
        else
        {
            hRes = ParseLabelList(pszRatingInfo, &pParsed);
        }
    }

    if (SUCCEEDED(hRes))
    {
        BOOL fRated = FALSE;
        BOOL fDenied = FALSE;

        ASSERT(pParsed != NULL);
        /** Custom **/
        // if notification interface exists, put in the URL
        if (g_fIsRunningUnderCustom)
        {
            ASSERT(!pParsed->m_pszURL);
            pParsed->m_pszURL = new char[strlenf(pszURL) + 1];
            if (pParsed->m_pszURL != NULL)
            {
                strcpyf(pParsed->m_pszURL, pszURL);
            }
        }

        DWORD timeCurrent = GetCurrentNetDate();

        CParsedServiceInfo *psi = &pParsed->m_ServiceInfo;

        while (psi != NULL && !fDenied)
        {
            UserRatingSystem *pURS = pUser->FindRatingSystem(psi->m_pszServiceName);
            if (pURS != NULL && pURS->m_pPRS != NULL)
            {
                psi->m_fInstalled = TRUE;
                UINT cRatings = psi->aRatings.Length();
                for (UINT i=0; i<cRatings; i++)
                {
                    CParsedRating *pRating = &psi->aRatings[i];
                    // YANGXU: 11/17/1999
                    // Do not check the URL if under Custom mode
                    // Checking the URL causes inaccuracies
                    // when a label is returned for an URL on
                    // a page whose server can have two different
                    // DNS entries. We can't just not check because
                    // passing in the URL is part of the published API
                    if (!g_fIsRunningUnderCustom)
                    {
                        if (!pRating->pOptions->CheckURL(pszURL))
                        {
                            pParsed->m_pszURL = new char[strlenf(pszURL) + 1];
                            if (pParsed->m_pszURL != NULL)
                            {
                                strcpyf(pParsed->m_pszURL, pszURL);
                            }

                            continue;    /* this rating has expired or is for
                                         * another URL, ignore it
                                         */
                        }
                    }
                    if (!pRating->pOptions->CheckUntil(timeCurrent))
                        continue;

                    UserRating *pUR = pURS->FindRating(pRating->pszTransmitName);
                    if (pUR != NULL)
                    {
                        fRated = TRUE;
                        pRating->fFound = TRUE;
                        if ((*pUR).m_pPC!=NULL)
                        {
                            if ((pRating->nValue > (*((*pUR).m_pPC)).etnMax.Get())||
                                (pRating->nValue < (*((*pUR).m_pPC)).etnMin.Get()))
                            {
                                g_fInvalid = TRUE;
                                fDenied = TRUE;
                                pRating->fFailed = TRUE;
                            }
                        }
                        if (pRating->nValue > pUR->m_nValue)
                        {
                            fDenied = TRUE;
                            pRating->fFailed = TRUE;
                        }
                        else
                            pRating->fFailed = FALSE;
                    }
                    else
                    {
                        g_fInvalid = TRUE;
                        fDenied = TRUE;
                        pRating->fFailed = TRUE;
                    }
                }
            }
            else
            {
                psi->m_fInstalled = FALSE;
            }

            psi = psi->Next();
        }

        if (!fRated)
        {
            pParsed->m_fRated = FALSE;
            hRes = E_RATING_NOT_FOUND;
        }
        else
        {
            pParsed->m_fRated = TRUE;
            if (fDenied)
                hRes = ResultFromScode(S_FALSE);
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "RatingCheckUserAccess() - ParseLabelList() Failed with hres=0x%x!", hRes );

        // Although the site has invalid PICS rules, the site should still be considered rated.
        hRes = ResultFromScode(S_FALSE);
    }

    StoreRatingDetails( pParsed, ppRatingDetails );

    return hRes;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomDeleteCrackedData
//
//  Synopsis:  frees the memory of structure returned by RatingCustomCrackData
//
//  Arguments: prbInfo : pointer to RATINGBLOCKINGINFO to be deleted
//
//  Returns:   S_OK if delete successful, E_FAIL otherwise
//
//------------------------------------------------------------------------
HRESULT RatingCustomDeleteCrackedData(RATINGBLOCKINGINFO* prbInfo)
{
    HRESULT hres = E_FAIL;
    RATINGBLOCKINGLABELLIST* prblTemp = NULL;
    
    if (NULL != prbInfo)
    {
        if (prbInfo->pwszDeniedURL)
        {
            delete [] prbInfo->pwszDeniedURL;
            prbInfo->pwszDeniedURL = NULL;
        }
        if (prbInfo->prbLabelList)
        {
            for (UINT j = 0; j < prbInfo->cLabels; j++)
            {
                prblTemp = &prbInfo->prbLabelList[j];
                if (prblTemp->pwszRatingSystemName)
                {
                    delete [] prblTemp->pwszRatingSystemName;
                    prblTemp->pwszRatingSystemName = NULL;
                }
                if (prblTemp->paRBLS)
                {
                    for (UINT i = 0; i < prblTemp->cBlockingLabels; i++)
                    {
                        if (prblTemp->paRBLS[i].pwszCategoryName)
                        {
                            delete [] prblTemp->paRBLS[i].pwszCategoryName;
                            prblTemp->paRBLS[i].pwszCategoryName = NULL;
                        }
                        if (prblTemp->paRBLS[i].pwszTransmitName)
                        {
                            delete [] prblTemp->paRBLS[i].pwszTransmitName;
                            prblTemp->paRBLS[i].pwszTransmitName = NULL;
                        }
                        if (prblTemp->paRBLS[i].pwszValueName)
                        {
                            delete [] prblTemp->paRBLS[i].pwszValueName;
                            prblTemp->paRBLS[i].pwszValueName = NULL;
                        }
                    }

                    delete [] prblTemp->paRBLS;
                    prblTemp->paRBLS = NULL;
                }
            }

            delete [] prbInfo->prbLabelList;
            prbInfo->prbLabelList = NULL;
        }
        if (prbInfo->pwszRatingHelperName)
        {
            delete [] prbInfo->pwszRatingHelperName;
            prbInfo->pwszRatingHelperName = NULL;
        }

        hres = S_OK;
        if (prbInfo->pwszRatingHelperReason)
        {
            delete [] prbInfo->pwszRatingHelperReason;
            prbInfo->pwszRatingHelperReason = NULL;
        }

        delete prbInfo;
        prbInfo = NULL;
    }

    return hres;
}

HRESULT _CrackCategory(CParsedRating *pRating,
                       RATINGBLOCKINGCATEGORY *pRBLS,
                       UserRatingSystem* pURS)
{
    UserRating *pUR = pURS->FindRating(pRating->pszTransmitName);
    if (pUR)
    {
        //
        //  Mutated code from InitPleaseDialog, hope it works
        //
        PicsCategory* pPC = pUR->m_pPC;
        if (pPC)
        {
            pRBLS->nValue = pRating->nValue;

            Ansi2Unicode(&pRBLS->pwszTransmitName, pRating->pszTransmitName);
        
            LPCSTR pszCategory = NULL;

            if (pPC->etstrName.fIsInit())
            {
                pszCategory = pPC->etstrName.Get();
            }
            else if (pPC->etstrDesc.fIsInit())
            {
                pszCategory = pPC->etstrDesc.Get();
            }
            else
            {
                pszCategory = pRating->pszTransmitName;
            }

            Ansi2Unicode(&pRBLS->pwszCategoryName, pszCategory);

            UINT cValues = pPC->arrpPE.Length();
            PicsEnum *pPE;

            for (UINT iValue=0; iValue < cValues; iValue++)
            {
                pPE = pPC->arrpPE[iValue];
                if (pPE->etnValue.Get() == pRating->nValue)
                {
                    break;
                }
            }

            LPCSTR pszValue = NULL;
            if (iValue < cValues)
            {
                if (pPE->etstrName.fIsInit())
                {
                    pszValue = pPE->etstrName.Get();
                }
                else if (pPE->etstrDesc.fIsInit())
                {
                    pszValue = pPE->etstrDesc.Get();
                }

                Ansi2Unicode(&pRBLS->pwszValueName, pszValue);
            }
        }
    }
    
    return S_OK;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomCrackData
//
//  Synopsis:  packages the persistent, opaque data describing why a site
//             was denied into readable form
//
//  Arguments: pszUsername : name of the user
//             pRatingDetails : pointer to the opaque data
//             pprbInfo : a RATINGBLOCKINGINFO representation of the data
//
//  Returns:   Success if data packaged
//
//------------------------------------------------------------------------
HRESULT RatingCustomCrackData(LPCSTR pszUsername, void* pvRatingDetails, RATINGBLOCKINGINFO** pprbInfo) {

    if(NULL != *pprbInfo)
    {
        return E_INVALIDARG;
    }

    RATINGBLOCKINGINFO* prbInfo = new RATINGBLOCKINGINFO;
    CParsedLabelList *pRatingDetails = (CParsedLabelList*)pvRatingDetails;
    if (!prbInfo)
    {
        return E_OUTOFMEMORY;
    }
    prbInfo->pwszDeniedURL = NULL;
    prbInfo->rbSource = RBS_ERROR;
    prbInfo->rbMethod = RBM_UNINIT;
    prbInfo->cLabels = 0;
    prbInfo->prbLabelList = NULL;
    prbInfo->pwszRatingHelperName = NULL;
    prbInfo->pwszRatingHelperReason = NULL;
    
    RATINGBLOCKINGLABELLIST* prblTemp = NULL;
    RATINGBLOCKINGLABELLIST* prblPrev = NULL;


    if (!g_fInvalid)
    {
        if (g_fIsRunningUnderCustom)
        {
            // pRatingDetails should not be NULL unless
            // we ran out of memory
            ASSERT(pRatingDetails);
            
            if (pRatingDetails->m_pszURL)
            {
                Ansi2Unicode(&prbInfo->pwszDeniedURL, pRatingDetails->m_pszURL);
            }
            if (pRatingDetails->m_fRated)
            {
                // The page can be rated or denied, but not both
                ASSERT(!pRatingDetails->m_fDenied);
                ASSERT(!pRatingDetails->m_fNoRating);
                
                prbInfo->rbMethod = RBM_LABEL;
                PicsUser* pPU = GetUserObject(pszUsername);
                if (pPU)
                {
                    // first find out how many systems there are
                    UINT cLabels =  0;
                    CParsedServiceInfo *ppsi = &pRatingDetails->m_ServiceInfo;
                    while (ppsi)
                    {
                        cLabels++;
                        ppsi = ppsi->Next();
                    }
                    // should have at least one label
                    ASSERT(cLabels > 0);
                    prbInfo->prbLabelList = new RATINGBLOCKINGLABELLIST[cLabels];

                    if (prbInfo->prbLabelList)
                    {
                        UINT iLabel = 0;
                        for (ppsi = &pRatingDetails->m_ServiceInfo;ppsi;ppsi = ppsi->Next())
                        {
                            if (!ppsi->m_fInstalled)
                            {
                                continue;
                            }
                            UserRatingSystem* pURS = pPU->FindRatingSystem(ppsi->m_pszServiceName);
                            if (NULL == pURS || NULL == pURS->m_pPRS)
                            {
                                continue;
                            }

                            prblTemp = &(prbInfo->prbLabelList[iLabel]);
                            
                            Ansi2Unicode(&prblTemp->pwszRatingSystemName, pURS->m_pPRS->etstrName.Get());
                            
                            UINT cRatings = ppsi->aRatings.Length();
                            prblTemp->paRBLS = new RATINGBLOCKINGCATEGORY[cRatings];
                            if (prblTemp->paRBLS == NULL)
                            {
                                RatingCustomDeleteCrackedData(prbInfo);
                                return E_OUTOFMEMORY;
                            } // if (prblTemp->paRBLS == NULL)
                            prblTemp->cBlockingLabels = cRatings;
                            
                            for (UINT i=0; i < cRatings; i++)
                            {
                                CParsedRating *pRating = &ppsi->aRatings[i];
                                RATINGBLOCKINGCATEGORY* pRBLS = &prblTemp->paRBLS[i];
                                _CrackCategory(pRating, pRBLS, pURS);
                            } // for (UINT i=0; i < cRatings; i++)

                            // at this point, we should have valid ratings for
                            // a system
                            iLabel++;
                        } // for (ppsi = &pRatingDetails->m_ServiceInfo;ppsi;ppsi = ppsi->Next())
                        prbInfo->cLabels = iLabel;
                    } // if (prbInfo->prbLabelList)
                    else
                    {
                        RatingCustomDeleteCrackedData(prbInfo);
                        return E_OUTOFMEMORY;
                    }
                    if (!pRatingDetails->m_fIsHelper)
                    {
                       prbInfo->rbSource = RBS_PAGE;
                    }
                    else
                    {
                        if (pRatingDetails->m_fIsCustomHelper)
                        {
                            prbInfo->rbSource = RBS_CUSTOM_RATING_HELPER;
                            if (pRatingDetails->m_pszRatingName)
                            {
                                Ansi2Unicode(&prbInfo->pwszRatingHelperName, pRatingDetails->m_pszRatingName);
                            }
                            if (pRatingDetails->m_pszRatingReason)
                            {
                                Ansi2Unicode(&prbInfo->pwszRatingHelperReason, pRatingDetails->m_pszRatingReason);
                            }
                        }
                        else
                        {
                            prbInfo->rbSource = RBS_RATING_HELPER;
                        }
                    }
                }
            } // if (pRatingDetails->m_fRated)
            else
            {
                if (pRatingDetails->m_fDenied)
                {
                    prbInfo->rbMethod = RBM_DENY;
                    if (!pRatingDetails->m_fIsHelper)
                    {
                       prbInfo->rbSource = RBS_PAGE;
                    }
                    else
                    {
                        if (pRatingDetails->m_fIsCustomHelper)
                        {
                            prbInfo->rbSource = RBS_CUSTOM_RATING_HELPER;
                        }
                        else
                        {
                            prbInfo->rbSource = RBS_RATING_HELPER;
                        }
                    }
                }
                else
                {
                    if (pRatingDetails->m_fNoRating)
                    {
                        prbInfo->rbSource = RBS_NO_RATINGS;
                    }
                }
            }
        } // if (g_fIsRunningUnderCustom)
        else
        {
            prbInfo->rbMethod = RBM_ERROR_NOT_IN_CUSTOM_MODE;
        }
    } // (!g_fInvalid)
    *pprbInfo = prbInfo;
    return S_OK;
}

HRESULT WINAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, LPVOID pRatingDetails)
{
    HRESULT hres;

    PleaseDlgData pdd;

    pdd.pszUsername = pszUsername;
    pdd.pPU = GetUserObject(pszUsername);
    if (pdd.pPU == NULL)
    {
        TraceMsg( TF_WARNING, "RatingAccessDeniedDialog() - Username is not valid!" );
        return HRESULT_FROM_WIN32(ERROR_BAD_USERNAME);
    }

    pdd.pszContentDescription = pszContentDescription;
    pdd.pLabelList = (CParsedLabelList *)pRatingDetails;
    pdd.hwndEC = NULL;
    pdd.dwFlags = 0;
    pdd.hwndDlg = NULL;
    pdd.hwndOwner = hDlg;
    pdd.cLabels = 0;

    CPleaseDialog           pleaseDialog( &pdd );

    if ( pleaseDialog.DoModal( hDlg ) )
    {
        hres = ResultFromScode(S_OK);
    }
    else
    {
        hres = ResultFromScode(S_FALSE);
    }

    for (UINT i=0; i<pdd.cLabels; i++)
    {
        delete pdd.apLabelStrings[i];
        pdd.apLabelStrings[i] = NULL;
    }
    
    return hres;
}

HRESULT WINAPI RatingAccessDeniedDialog2(HWND hwndParent, LPCSTR pszUsername, LPVOID pRatingDetails)
{
    PleaseDlgData *ppdd = (PleaseDlgData *)GetProp( hwndParent, szRatingsProp );
    if (ppdd == NULL)
    {
        return RatingAccessDeniedDialog( hwndParent, pszUsername, NULL, pRatingDetails );
    }

    HWND            hwndDialog = ppdd->hwndDlg;

    ASSERT( hwndDialog );

    ppdd->pLabelList = (CParsedLabelList *)pRatingDetails;

    SendMessage( hwndDialog, WM_NEWDIALOG, 0, (LPARAM)ppdd );

    // The ppdd is only valid during the RatingAccessDeniedDialog() scope!!
    ppdd = NULL;

    // $REVIEW - Should we use a Windows Hook instead of looping to wait for the
    //      modal dialog box to complete?
    // $CLEANUP - Use a CMessageLoop instead.

    // Property is removed once the modal dialog is toasted.
    while ( ::IsWindow( hwndParent ) && ::GetProp( hwndParent, szRatingsProp ) )
    {
        MSG msg;

        if ( PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ) )
        {
            if ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
//              && !IsDialogMessage(ppdd->hwndDlg, &msg)) {
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else
        {
            ::Sleep( 100 );     // Empty message queue means check again in 100 msecs
        }
    }

    DWORD           dwFlags;

    dwFlags = ::IsWindow( hwndParent ) ? PtrToUlong( GetProp( hwndParent, szRatingsValue ) ) : PDD_DONE;

    TraceMsg( TF_ALWAYS, "RatingAccessDeniedDialog2() - Message Loop exited with dwFlags=%d", dwFlags );

    return ( dwFlags & PDD_ALLOW ) ? S_OK : S_FALSE;
}

HRESULT WINAPI RatingFreeDetails(LPVOID pRatingDetails)
{
    if (pRatingDetails)
    {
        FreeParsedLabelList((CParsedLabelList *)pRatingDetails);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\rocycle.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

/*Included Files------------------------------------------------------------*/
#include "msrating.h"
#include "ratings.h"
#include <ratingsp.h>
#include <npassert.h>
#include <npstring.h>

#include "mslubase.h"
#include "roll.h"
#include "rors.h"
#include "picsrule.h"
#include "parselbl.h"
#include "debug.h"

typedef HRESULT (STDAPICALLTYPE *PFNCoInitialize)(LPVOID pvReserved);
typedef void (STDAPICALLTYPE *PFNCoUninitialize)(void);
typedef HRESULT (STDAPICALLTYPE *PFNCoGetMalloc)(
    DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
typedef HRESULT (STDAPICALLTYPE *PFNCoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);
typedef HRESULT (STDAPICALLTYPE *PFNCLSIDFromString)(LPOLESTR lpsz, LPCLSID pclsid);

PFNCoInitialize pfnCoInitialize = NULL;
PFNCoUninitialize pfnCoUninitialize = NULL;
PFNCoGetMalloc pfnCoGetMalloc = NULL;
PFNCoCreateInstance pfnCoCreateInstance = NULL;
PFNCLSIDFromString pfnCLSIDFromString = NULL;

#undef CoInitialize
#undef CoUninitialize
#undef CoGetMalloc
#undef CoCreateInstance
#undef CLSIDFromString

#define CoInitialize pfnCoInitialize
#define CoUninitialize pfnCoUninitialize
#define CoGetMalloc pfnCoGetMalloc
#define CoCreateInstance pfnCoCreateInstance
#define CLSIDFromString pfnCLSIDFromString

struct {
    FARPROC *ppfn;
    LPCSTR pszName;
} aOLEImports[] = {
    { (FARPROC *)&pfnCoInitialize, "CoInitialize" },
    { (FARPROC *)&pfnCoUninitialize, "CoUninitialize" },
    { (FARPROC *)&pfnCoGetMalloc, "CoGetMalloc" },
    { (FARPROC *)&pfnCoCreateInstance, "CoCreateInstance" },
    { (FARPROC *)&pfnCLSIDFromString, "CLSIDFromString" },
};

const UINT cOLEImports = sizeof(aOLEImports) / sizeof(aOLEImports[0]);

HINSTANCE hOLE32 = NULL;
BOOL fTriedOLELoad = FALSE;

BOOL LoadOLE(void)
{
    if (fTriedOLELoad)
        return (hOLE32 != NULL);

    fTriedOLELoad = TRUE;

    hOLE32 = ::LoadLibrary("OLE32.DLL");
    if (hOLE32 == NULL)
        return FALSE;

    for (UINT i=0; i<cOLEImports; i++) {
        *(aOLEImports[i].ppfn) = ::GetProcAddress(hOLE32, aOLEImports[i].pszName);
        if (*(aOLEImports[i].ppfn) == NULL) {
            CleanupOLE();
            return FALSE;
        }
    }

    return TRUE;
}


void CleanupOLE(void)
{
    if (hOLE32 != NULL) {
        for (UINT i=0; i<cOLEImports; i++) {
            *(aOLEImports[i].ppfn) = NULL;
        }
        ::FreeLibrary(hOLE32);
        hOLE32 = NULL;
    }
}


/*Obtain Rating Data--------------------------------------------------------*/
class RatingObtainData
{
    public:
        NLS_STR  nlsTargetUrl;
        HANDLE   hAbortEvent;
        DWORD    dwUserData;
        void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCTSTR pszRating, LPVOID lpvRatingDetails) ;

        RatingObtainData(LPCTSTR pszTargetUrl);
        ~RatingObtainData();
};

RatingObtainData::RatingObtainData(LPCTSTR pszTargetUrl)
    : nlsTargetUrl(pszTargetUrl)
{
    hAbortEvent  = NULL;
    dwUserData   = 0;
    fCallback    = NULL;
}
RatingObtainData::~RatingObtainData()
{
    if (hAbortEvent) CloseHandle(hAbortEvent);
}


struct RatingHelper {
    CLSID clsid;
    DWORD dwSort;
};

array<RatingHelper> *paRatingHelpers = NULL;
CustomRatingHelper *g_pCustomRatingHelperList;

BOOL fTriedLoadingHelpers = FALSE;


void InitRatingHelpers()
{
    BOOL fCOMInitialized = FALSE;
    RatingHelper helper;

    if (fTriedLoadingHelpers || !LoadOLE())
    {
        TraceMsg( TF_WARNING, "InitRatingHelpers() - Tried Loading Helpers or OLE Load Failed!");
        return;
    }

    fTriedLoadingHelpers = TRUE;

    paRatingHelpers = new array<RatingHelper>;
    if (paRatingHelpers == NULL)
    {
        TraceMsg( TF_ERROR, "InitRatingHelpers() - Failed to Create paRatingHelpers!");
        return;
    }

    CRegKey         key;

    /* REARCHITECT - should this be in the policy file?  it shouldn't be per-user, that's for sure. */
    if ( key.Open( HKEY_LOCAL_MACHINE, szRATINGHELPERS, KEY_READ ) != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "InitRatingHelpers() - Failed to Open key szRATINGHELPERS='%s'!", szRATINGHELPERS );
        return;
    }

    UINT iValue = 0;
    LONG err = ERROR_SUCCESS;
    char szValue[39];       /* just big enough for a null-terminated GUID string */
    WCHAR wszValue[39];     /* unicode version */

    // YANGXU : 11/15/1999
    // under custom mode, if we have a bureau string, load the bureau
    // rating helper, but do not load any other rating helpers
    if (g_fIsRunningUnderCustom)
    {
        if (gPRSI->etstrRatingBureau.fIsInit())
        {
            ASSERT(FALSE == fCOMInitialized);
            if (SUCCEEDED(CoInitialize(NULL)))
            {
                fCOMInitialized = TRUE;
                IObtainRating *pHelper;
                helper.clsid = CLSID_RemoteSite;

                if (SUCCEEDED(CoCreateInstance(helper.clsid, NULL,
                                               CLSCTX_INPROC_SERVER,
                                               IID_IObtainRating,
                                               (LPVOID *)&pHelper)))
                {
                    helper.dwSort = pHelper->GetSortOrder();
                    if (!paRatingHelpers->Append(helper))
                    {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                    }

                    pHelper->Release();
#ifdef DEBUG
                    pHelper = NULL;
#endif
                }
            }
        }
    }
    else
    {
        /* Note, special care is taken to make sure that we only CoInitialize for
         * as long as we need to, and CoUninitialize when we're done.  We cannot
         * CoUninitialize on a different thread than we initialized on, nor do we
         * want to call CoUninitialize at thread-detach time (would require using
         * TLS).  This is done here and in the asynchronous thread that actually
         * calls into the rating helpers to get ratings.
         */

        do
        {
            DWORD cchValue = sizeof(szValue);
            err = RegEnumValue( key.m_hKey, iValue, szValue, &cchValue, NULL, NULL, NULL, NULL);
            if (err == ERROR_SUCCESS)
            {
                if (!fCOMInitialized)
                {
                    if (FAILED(CoInitialize(NULL)))
                    {
                        break;
                    }
                    fCOMInitialized = TRUE;
                }

                if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szValue, -1, wszValue, ARRAYSIZE(wszValue))) {
                    if (SUCCEEDED(CLSIDFromString(wszValue, &helper.clsid)))
                    {
                        IObtainRating *pHelper;

                        if (SUCCEEDED(CoCreateInstance(helper.clsid, NULL,
                                                       CLSCTX_INPROC_SERVER,
                                                       IID_IObtainRating,
                                                       (LPVOID *)&pHelper)))
                        {
                            helper.dwSort = pHelper->GetSortOrder();
                            if (!paRatingHelpers->Append(helper))
                            {
                                err = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            pHelper->Release();
#ifdef DEBUG
                            pHelper = NULL;
#endif
                        }
                    }
                }
            }
            iValue++;
        } while (ERROR_SUCCESS == err);
    }

    if (fCOMInitialized)
    {
        CoUninitialize();
    }

    /* If more than one helper, sort them by their reported sort orders.
     * We will rarely have more than two or three of these guys, and this
     * is one time code, so we don't need a super-slick sort algorithm.
     *
     * CODEWORK: could modify array<> template to support an Insert()
     * method which reallocates the buffer like Append() does, but inserts
     * at a specific location.
     */
    if (paRatingHelpers->Length() > 1)
    {
        for (INT i=0; i < paRatingHelpers->Length() - 1; i++)
        {
            for (INT j=i+1; j < paRatingHelpers->Length(); j++)
            {
                if ((*paRatingHelpers)[i].dwSort > (*paRatingHelpers)[j].dwSort)
                {
                    RatingHelper temp = (*paRatingHelpers)[i];
                    (*paRatingHelpers)[i] = (*paRatingHelpers)[j];
                    (*paRatingHelpers)[j] = temp;
                }
            }
        }
    }
}


void CleanupRatingHelpers(void)
{
    if (paRatingHelpers != NULL) {
        delete paRatingHelpers;
        paRatingHelpers = NULL;
    }
    fTriedLoadingHelpers = FALSE;
}


/*
    This procedure runs on its own thread (1 per request).
    This cycles through all the helper DLLs looking for a ratings.
    It goes on down the list one at a time until either a rating 
    is found, or the this is aborted by the programmer.
*/
DWORD __stdcall RatingCycleThread(LPVOID pData)
{
    RatingObtainData *pOrd = (RatingObtainData*) pData;
    LPVOID            lpvRatingDetails = NULL;
    HRESULT           hrRet = E_FAIL;
    int               nProc;
    BOOL              fAbort = FALSE;
    BOOL              fFoundWithCustomHelper = FALSE;
    IMalloc *pAllocator = NULL;
    LPSTR pszRating = NULL;
    LPSTR pszRatingName = NULL;
    LPSTR pszRatingReason = NULL;
    BOOL fCOMInitialized = FALSE;
    CustomRatingHelper* pmrhCurrent = NULL;

    ASSERT(pOrd);

    //
    // Check the Custom Helpers first
    //
    if(g_pCustomRatingHelperList)
    {
        // we should only have custom rating helpers under custom mode
        ASSERT(g_fIsRunningUnderCustom);
        if(SUCCEEDED(CoInitialize(NULL)))
        {
            fCOMInitialized = TRUE;
            // get a cotaskmem allocator
            hrRet = CoGetMalloc(MEMCTX_TASK, &pAllocator);
            if (SUCCEEDED(hrRet))
            {
                pmrhCurrent = g_pCustomRatingHelperList;
                while(pmrhCurrent)
                {
                    HRESULT (* pfn)(REFCLSID, REFIID, LPVOID *) = NULL;
                    ICustomRatingHelper* pCustomHelper = NULL;
                    IClassFactory* pFactory = NULL;

                    ASSERT(pmrhCurrent->hLibrary);

                    *(FARPROC *) &pfn = GetProcAddress(pmrhCurrent->hLibrary, "DllGetClassObject");
                    if (pfn)
                    {
                        hrRet = pfn(pmrhCurrent->clsid, IID_IClassFactory, (void**)&pFactory);
                        if (SUCCEEDED(hrRet))
                        {
                            hrRet = pFactory->CreateInstance(NULL, IID_ICustomRatingHelper, (void**)&pCustomHelper);
                            if (SUCCEEDED(hrRet))
                            {
                                hrRet = pCustomHelper->ObtainCustomRating(pOrd->nlsTargetUrl.QueryPch(),
                                                                  pOrd->hAbortEvent,
                                                                  pAllocator,
                                                                  &pszRating,
                                                                  &pszRatingName,
                                                                  &pszRatingReason);
                                pCustomHelper->Release();
                                pCustomHelper = NULL;
                                fAbort = (WAIT_OBJECT_0 == WaitForSingleObject(pOrd->hAbortEvent, 0));
                                if (fAbort || SUCCEEDED(hrRet))
                                    break;
                            }
                            pFactory->Release();
                        } // if (SUCCEEDED(pfn(pmrhCurrent->clsid, IID_ICustomRatingHelper, (void**)&pCustomHelper)))
                    } // if (pfn)
                    else
                    {
                        hrRet = E_UNEXPECTED;
                    }

                    pmrhCurrent = pmrhCurrent->pNextHelper;
                }
            }
        }
    }

    if(SUCCEEDED(hrRet))
    {
        fFoundWithCustomHelper = TRUE;
    }

    if(paRatingHelpers && paRatingHelpers->Length()>0 && !SUCCEEDED(hrRet) && !fAbort)
    {
        /* Note that CoInitialize and CoUninitialize must be done once per thread. */
        if(!fCOMInitialized)
        {
            if(SUCCEEDED(CoInitialize(NULL)))
            {
                fCOMInitialized = TRUE;
            }
        }
        if (fCOMInitialized) {
            if (!pAllocator)
            {
                hrRet = CoGetMalloc(MEMCTX_TASK, &pAllocator);
            }
            if (pAllocator) {

                //Cycle through list of rating procs till one gives us the answer, we abort, or there are no more
                int nRatingHelperProcs = ::paRatingHelpers->Length();
                for (nProc = 0; nProc < nRatingHelperProcs; ++nProc)
                {
                    IObtainRating *pHelper;
                    if (SUCCEEDED(CoCreateInstance((*paRatingHelpers)[nProc].clsid, NULL,
                                                   CLSCTX_INPROC_SERVER,
                                                   IID_IObtainRating,
                                                   (LPVOID *)&pHelper))) {
                        hrRet  = pHelper->ObtainRating(pOrd->nlsTargetUrl.QueryPch(),
                                        pOrd->hAbortEvent, pAllocator, &pszRating);
                        pHelper->Release();
#ifdef DEBUG
                        pHelper = NULL;
#endif
                    }
                    fAbort = (WAIT_OBJECT_0 == WaitForSingleObject(pOrd->hAbortEvent, 0));
                    if (fAbort || SUCCEEDED(hrRet)) break;
                }
            }
        }
        else
            hrRet = E_RATING_NOT_FOUND;
    }

    /*return results to user*/
    if (!fAbort)
    {
        /*
         * If one of the providers found a rating, we must call CheckUserAccess
         * and tell the client whether the user has access or not.  If we did
         * not find a rating, then we tell the client that, by passing the
         * callback a code of E_RATING_NOT_FOUND.
         *
         * The provider may also return S_RATING_ALLOW or S_RATING_DENY, which
         * means that it has already checked the user's access (for example,
         * against a system-wide exclusion list).
         */
        if (hrRet == S_RATING_FOUND)
        {
            hrRet = RatingCheckUserAccess(NULL, pOrd->nlsTargetUrl.QueryPch(),
                                          pszRating, NULL, PICS_LABEL_FROM_BUREAU,
                                          &lpvRatingDetails);
        }
        else
        {
            if(S_RATING_DENY == hrRet && g_fIsRunningUnderCustom)
            {
                lpvRatingDetails = (LPVOID)(new CParsedLabelList);
                if (lpvRatingDetails)
                {
                    ((CParsedLabelList*)lpvRatingDetails)->m_fDenied = TRUE;
                    ((CParsedLabelList*)lpvRatingDetails)->m_pszURL = StrDup(pOrd->nlsTargetUrl.QueryPch());
                }
                else
                {
                    hrRet = E_OUTOFMEMORY;
                }
            }
        }

        if (S_RATING_DENY == hrRet && g_fIsRunningUnderCustom)
        {
            // lpvRatingDetails should be non NULL at this point
            ASSERT(lpvRatingDetails);

            ((CParsedLabelList*)lpvRatingDetails)->m_fIsHelper = TRUE;
            if(fFoundWithCustomHelper)
            {
                ((CParsedLabelList*)lpvRatingDetails)->m_fIsCustomHelper = TRUE;
                if (pszRatingName)
                {
                    if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingName = new char[strlen(pszRatingName)+1])
                    {
                        strcpyf(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingName,pszRatingName);
                    } // if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingName = new char[strlen(pszRatingName)+1])

                }
                if (pszRatingReason)
                {
                    if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingReason = new char[strlen(pszRatingReason)+1])
                    {
                        strcpyf(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingReason, pszRatingReason);
                    } // if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingReason = new char[strlen(pszRatingReason)+1])
                }
            }
        }

        /* Range-check other success codes to make sure they're not anything
         * that the browser callback isn't expecting.
         */
        if (SUCCEEDED(hrRet) && (hrRet != S_RATING_ALLOW && hrRet != S_RATING_DENY))
            hrRet = E_RATING_NOT_FOUND;
        (*pOrd->fCallback)(pOrd->dwUserData, hrRet, pszRating, (LPVOID) lpvRatingDetails);
    }

    /*cleanup*/
    delete pOrd;
    pOrd = NULL;

    if (pAllocator != NULL) {
        pAllocator->Free(pszRating);
        if(pszRatingName)
        {
            pAllocator->Free(pszRatingName);
        }
        if(pszRatingReason)
        {
            pAllocator->Free(pszRatingReason);
        }
        pAllocator->Release();
    }

    if (fCOMInitialized)
        CoUninitialize();

    return (DWORD) fAbort;
}




/*Public Functions----------------------------------------------------------*/

//Startup thread that finds rating, return immediately
HRESULT WINAPI RatingObtainQuery(LPCTSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCTSTR pszRating, LPVOID lpvRatingDetails), HANDLE *phRatingObtainQuery)
{
    RatingObtainData *pOrd;
    HANDLE hThread;
    DWORD dwThid;

    CheckGlobalInfoRev();

    if (!g_fIsRunningUnderCustom)
    {
        if (::RatingEnabledQuery() != S_OK ||
            !gPRSI->fSettingsValid)         /* ratings not enabled? fail immediately. */
            return E_RATING_NOT_FOUND;
    }

    InitRatingHelpers();

    if (NULL == g_pCustomRatingHelperList
            && (::paRatingHelpers == NULL || ::paRatingHelpers->Length() < 1)) {

        return E_RATING_NOT_FOUND;
    }

    if (fCallback && pszTargetUrl)
    {
        pOrd = new RatingObtainData(pszTargetUrl);
        if (pOrd)
        {
            if (pOrd->nlsTargetUrl.QueryError() == ERROR_SUCCESS) {
                pOrd->dwUserData   = dwUserData;
                pOrd->fCallback    = fCallback;
                pOrd->hAbortEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);

                if (pOrd->hAbortEvent)
                {
                    hThread = CreateThread(NULL, 0, RatingCycleThread, (LPVOID) pOrd, 0, &dwThid);
                    if (hThread)
                    {
                        CloseHandle(hThread);
                        if (phRatingObtainQuery) *phRatingObtainQuery = pOrd->hAbortEvent;
                        return NOERROR;
                    }
                    CloseHandle(pOrd->hAbortEvent);
                }
            }

            delete pOrd;
            pOrd = NULL;
        }
    }

    return E_FAIL;
}

//Cancel an existing query
HRESULT WINAPI RatingObtainCancel(HANDLE hRatingObtainQuery)
{
    //what happens if hRatingObtainQuery has already been closed?!?!
    if (hRatingObtainQuery)
    {
        if (SetEvent(hRatingObtainQuery)) return NOERROR;
    }
    return E_HANDLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\roll.cpp ===
/*Includes-----------------------------------------------------------*/
#include "msrating.h"
#pragma hdrstop

#include <npassert.h>
#include "ratings.h"

#include "roll.h"




/*IsUrlInFile---------------------------------------------------------------*/
/*
    Return VAlue length of Best Match
*/
static HRESULT IsUrlInFile(LPCTSTR pszTargetUrl, char **ppRating, const char* pFile, DWORD dwFile, HANDLE hAbortEvent, void* (WINAPI *MemAlloc)(long size))
{
    LocalListRecordHeader *pllrh;
    DWORD dwBytesRead;
    HRESULT hrRet = S_OK;
    int nBest, nActual, nCmp;
    const char *pBest = NULL;
    BOOL fAbort;

    dwBytesRead = 0;
    nBest   = 0;
    nActual = strlenf(pszTargetUrl);
    fAbort  = FALSE;

    //Go through each recored until there is a match good enough or an abort
    while (!fAbort && nActual != nBest && dwBytesRead <= dwFile)
    {
        pllrh = (LocalListRecordHeader*) pFile;
        if (pllrh->nUrl > nBest && 
                (
                    (pllrh->nUrl == nActual)
                    ||            
                    (
                        pllrh->nUrl < nActual && 
                        (
                            (pszTargetUrl[pllrh->nUrl] == '\\') 
                            || 
                            (pszTargetUrl[pllrh->nUrl] == '/')
                            || 
                            (pszTargetUrl[pllrh->nUrl] == ':')
                        )
                    )
                )                
            )
        {
            nCmp = strnicmpf(pFile+sizeof(LocalListRecordHeader), pszTargetUrl, pllrh->nUrl);
            if (0==nCmp)
            {
                nBest = pllrh->nUrl;
                pBest = pFile;
                hrRet = pllrh->hrRet;
            }
            //the local list is alphabetized
            else if (1==nCmp) break;

        }
        dwBytesRead += pllrh->nUrl + pllrh->nRating + sizeof(LocalListRecordHeader);
        pFile       += pllrh->nUrl + pllrh->nRating + sizeof(LocalListRecordHeader);
        fAbort       = (WAIT_OBJECT_0 == WaitForSingleObject(hAbortEvent, 0));
    }

     //was the match close enough??!?!?
    if (!fAbort && nBest && pBest)
    {
        //yes, now try to copy rating
        pllrh = (LocalListRecordHeader*) pBest;
        if (pllrh->nRating)
        {
            *ppRating = (char*) MemAlloc(pllrh->nRating+1);
            if (*ppRating)
            {
                CopyMemory(*ppRating, pBest + sizeof(LocalListRecordHeader) + pllrh->nUrl, pllrh->nRating);
                (*ppRating)[pllrh->nRating] = 0;
            }
        }
    }
    else
    {
        //no... oh well
        hrRet = E_RATING_NOT_FOUND;
    }

    return hrRet;
}



/*RatingObtainFromLocalList-------------------------------------------------*/
/*
    Grab rating information from local file.
    Should operate synchronously and take small amount of time.
    Doesn't check pOrd->fAbort too often.
*/



HRESULT RatingHelperProcLocalList(LPCTSTR pszTargetUrl, HANDLE hAbortEvent, void* (WINAPI *MemAlloc)(long size), char **ppRatingOut)
{
    DWORD dwFile;
    HRESULT hrRet = E_RATING_NOT_FOUND;
    HANDLE hFile, hMap;
    BOOL fAbort;
    const char *pFile;

    ASSERT(ppRatingOut);
    //Open and check from approved list
    hFile = CreateFile(
        FILE_NAME_LIST, GENERIC_READ, 
        FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwFile = GetFileSize(hFile, NULL);
        hMap   = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (hMap)
        {
            pFile = (const char*) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
            if (pFile) 
            {
                //check for correct file type
        if (BATCAVE_LOCAL_LIST_MAGIC_COOKIE == *((DWORD*) pFile))
        {
          pFile  += sizeof(DWORD);
          dwFile -= sizeof(DWORD);
          fAbort  = (WAIT_OBJECT_0 == WaitForSingleObject(hAbortEvent, 0));
          if (!fAbort) hrRet = IsUrlInFile(pszTargetUrl, ppRatingOut, pFile, dwFile, hAbortEvent, MemAlloc);
          pFile  -= sizeof(DWORD);
        }
            }
            dwFile = (DWORD) UnmapViewOfFile((LPVOID)pFile);
            CloseHandle(hMap);
        }
        CloseHandle(hFile);
    }
    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\roll.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _ROLL_H_
#define _ROLL_H_


/*Includes-----------------------------------------------------------*/

/*Classes------------------------------------------------------------*/
/*
The format of the local list file is as follows:

    BATCAVE_LOCAL_LIST_MAGIC_COOKIE
    LocalListRecordHeader_1 pUrl_1 pRating_1
    .
    .
    .
    .
    LocalListRecordHeader_n pUrl_n pRating_n

The file is binary.

Entries should be sorted based on pUrl

pUrl and pRating are both strings whose size is determined
by the record header.  They are NOT null terminated!
*/

#define BATCAVE_LOCAL_LIST_MAGIC_COOKIE 0x4e4f5845

//BUG BUG should either be inside of registry or user profile
#define FILE_NAME_LIST  "ratings.lst"

struct LocalListRecordHeader{
    int     nUrl;
    int     nRating;
    HRESULT hrRet;
};

/*Prototypes---------------------------------------------------------*/
HRESULT RatingHelperProcLocalList(LPCTSTR pszTargetUrl, HANDLE hAbortEvent, void* (WINAPI *MemAlloc)(long size), char **ppRatingOut);

#endif 
//_ROLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\dll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\rors.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _RORS_H_
#define _RORS_H_


/*Includes-----------------------------------------------------------*/


/*Prototypes---------------------------------------------------------*/

class CRORemoteSite : public IObtainRating
{
private:
    UINT m_cRef;

public:
    CRORemoteSite() { m_cRef = 1; }
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    STDMETHOD(ObtainRating) (THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
                             IMalloc *pAllocator, LPSTR *ppRatingOut);

    STDMETHOD_(ULONG,GetSortOrder) (THIS);
};

#endif 
//_RORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\superpw.cpp ===
#include "msrating.h"
#include "msluglob.h"
#include "mslubase.h"
#include "hint.h"
#include "debug.h"
#include <md5.h>

extern PicsRatingSystemInfo *gPRSI;

HRESULT VerifySupervisorPassword(LPCSTR pszPassword)
{
    if ( ! ::fSupervisorKeyInit )
    {
        HKEY hkeyRating;
        LONG err;

        hkeyRating = CreateRegKeyNT(::szRATINGS);
        if (hkeyRating !=  NULL)
        {
            DWORD cbData = sizeof(::abSupervisorKey);
            DWORD dwType;

            // Attempt to look for "Key"
            err = ::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
                                    &dwType, (LPBYTE)::abSupervisorKey, &cbData);

            ::RegCloseKey(hkeyRating);
            hkeyRating = NULL;

            if (err == ERROR_SUCCESS)
            {
                if (dwType != REG_BINARY || cbData != sizeof(::abSupervisorKey))
                {
                    TraceMsg( TF_WARNING, "VerifySupervisorPassword() - Unexpected Error dwType=%d, cbData=%d!", dwType, cbData );
                    return E_UNEXPECTED;
                }

                ::fSupervisorKeyInit = TRUE;
            }
            else
            {
                if (pszPassword == NULL)
                {
                    TraceMsg( TF_WARNING, "VerifySupervisorPassword() - Supervisor Key '%s' not found!", ::szRatingsSupervisorKeyName );
                    return E_FAIL;
                }
            }
        }
        else
        {
            TraceMsg( TF_ERROR, "VerifySupervisorPassword() - Failed to Create Ratings Registry Key!" );
            err = ERROR_FILE_NOT_FOUND;
        }

        if (err != ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "VerifySupervisorPassword() - Error=0x%x!", err );
            return HRESULT_FROM_WIN32(err);
        }
    }

    if (pszPassword == NULL)
    {
        TraceMsg( TF_ALWAYS, "VerifySupervisorPassword() - Comparing to NULL pszPassword returning S_FALSE." );
        return ResultFromScode(S_FALSE);
    }

    // We should probably not be comparing to a blank password.
//  ASSERT( pszPassword[0] != '\0' );

    if ( pszPassword[0] == '\0' )
    {
        TraceMsg( TF_ALWAYS, "VerifySupervisorPassword() - Comparing to blank pszPassword." );
    }

    MD5_CTX ctx;

    MD5Init(&ctx);
    MD5Update(&ctx, (const BYTE *)pszPassword, ::strlenf(pszPassword)+1);
    MD5Final(&ctx);

    return ResultFromScode(::memcmpf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey)) ? S_FALSE : S_OK);
}


HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
{
    HRESULT hres;

    hres = ::VerifySupervisorPassword(pszOldPassword);
    if (hres == S_FALSE)
    {
        TraceMsg( TF_WARNING, "ChangeSupervisorPassword() - VerifySupervisorPassword() false!" );
        return E_ACCESSDENIED;
    }

    // If pszNewPassword is NULL or "" (blank password) we call RemoveSupervisorPassword().
    if ( ! pszNewPassword )
    {
        TraceMsg( TF_ALWAYS, "ChangeSupervisorPassword() - pszNewPassword is NULL - Removing Supervisor Password!" );
        return RemoveSupervisorPassword();
    }

    // Attempting to set a blank password should remove the Key from the Registry.
    if ( pszNewPassword[0] == '\0' )
    {
        TraceMsg( TF_ALWAYS, "ChangeSupervisorPassword() - pszNewPassword is an empty string - Removing Supervisor Password!" );
        return RemoveSupervisorPassword();
    }

    MD5_CTX ctx;

    MD5Init(&ctx);
    MD5Update(&ctx, (const BYTE *)pszNewPassword, ::strlenf(pszNewPassword)+1);
    MD5Final(&ctx);

    ::memcpyf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey));
    ::fSupervisorKeyInit = TRUE;

    hres = NOERROR;

    HKEY hkeyRating;

    hkeyRating = CreateRegKeyNT(::szRATINGS);
    if (hkeyRating != NULL)
    {
        BYTE abTemp[sizeof(::abSupervisorKey)];
        DWORD cbData = sizeof(::abSupervisorKey);
        DWORD dwType;
        if (::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
                              &dwType, abTemp, &cbData) != ERROR_SUCCESS)
        {
            hres = S_FALSE; /* tell caller we're creating the new key */
        }

        ::RegSetValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
                        REG_BINARY, (const BYTE *)::abSupervisorKey, sizeof(::abSupervisorKey));
        ::RegCloseKey(hkeyRating);
    }
    else
    {
        TraceMsg( TF_ERROR, "ChangeSupervisorPassword() - Failed to Create Ratings Registry Key!" );
        hres = E_FAIL;
    }

    return hres;
}


HRESULT RemoveSupervisorPassword(void)
{
    HKEY hkeyRating;
    LONG err = E_FAIL;

    hkeyRating = CreateRegKeyNT(::szRATINGS);
    if (hkeyRating !=  NULL)
    {
        err = ::RegDeleteValue(hkeyRating, ::szRatingsSupervisorKeyName);

        if ( err == ERROR_SUCCESS )
        {
            CHint           hint;

            hint.RemoveHint();

            TraceMsg( TF_ALWAYS, "RemoveSupervisorPassword() - Removed supervisor password and hint." );
        }

        ::RegCloseKey(hkeyRating);
        hkeyRating = NULL;
    }
    else
    {
        TraceMsg( TF_ERROR, "RemoveSupervisorPassword() - Failed to Create Ratings Registry Key!" );
    }

    if ( gPRSI )
    {
        gPRSI->fRatingInstalled = FALSE;
    }

    ::fSupervisorKeyInit = FALSE;
    return HRESULT_FROM_WIN32(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\resdll\makefile.inc ===
..\msratelc.rc : $(MSRATING_DEP)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\toffdlg.h ===
/****************************************************************************\
 *
 *   toffdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Turn Off Ratings Dialog
 *
\****************************************************************************/

#ifndef TURN_OFF_DIALOG_H
#define TURN_OFF_DIALOG_H

#include "basedlg.h"        // CBaseDialog

class CTurnOffDialog: public CBaseDialog<CTurnOffDialog>
{
public:
    enum { IDD = IDD_TURNOFF };

public:
    CTurnOffDialog();

public:
    typedef CTurnOffDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDOK, OnOK)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\npstub\nphook.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NPHOOK.H -- Internal header for hooking calls into network providers.
 *
 *
 * History:
 *  05/17/94    lens   Created.
 *
 */

#include <npdefs.h>
#include <netspi.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define ORD_NPSHookMPR               222
#define ORD_NPSUnHookMPR             223
#define ORD_NPSUnHookMe              224
#define ORD_NPSGetHandleFromInstance 225

#define NPSHookMPR NPSHookMPRA
#define NPSUnHookMPR NPSUnHookMPRA
#define NPSUnHookMe NPSUnHookMeA
#define NPSGetHandleFromInstance NPSGetHandleFromInstanceA

typedef HMODULE F_LoadLibrary(
    LPCTSTR  lpszLibFile
    );
typedef F_LoadLibrary *PF_LoadLibrary;

typedef BOOL F_FreeLibrary(
    HMODULE hLibModule
    );
typedef F_FreeLibrary *PF_FreeLibrary;

typedef FARPROC F_GetProcAddress(
    HMODULE hModule,
    LPCSTR  lpszProc
    );
typedef F_GetProcAddress *PF_GetProcAddress;

typedef HANDLE16 F_LoadLibrary16(
    LPCTSTR  lpszLibFile
    );
typedef F_LoadLibrary16 *PF_LoadLibrary16;

typedef VOID F_FreeLibrary16(
    HANDLE16 hLibModule
    );
typedef F_FreeLibrary16 *PF_FreeLibrary16;

typedef DWORD WINAPI F_GetProcAddressByName16(
    LPCSTR   lpszProc,
    HANDLE16 hModule
    );
typedef F_GetProcAddressByName16 *PF_GetProcAddressByName16;

typedef DWORD WINAPI F_GetProcAddressByOrdinal16(
    WORD     wOrdinal,
    HANDLE16 hModule
    );
typedef F_GetProcAddressByOrdinal16 *PF_GetProcAddressByOrdinal16;

typedef DWORD NPSERVICE F_NPSHookMPR(
    struct _MPRCALLS *pMPRCalls
    );
typedef F_NPSHookMPR *PF_NPSHookMPR;

F_NPSHookMPR NPSHookMPR;

typedef DWORD NPSERVICE F_UnHookMPR(
    PF_NPSHookMPR pfNPSHookMPR, 
    struct _MPRCALLS *pMPRCalls
    );
typedef F_UnHookMPR *PF_UnHookMPR;

typedef DWORD NPSERVICE F_NPSUnHookMPR(
    PF_NPSHookMPR pfReqNPSHookMPR, 
    struct _MPRCALLS *pReqMPRCalls,
    struct _MPRCALLS *pChainedMPRCalls
    );
typedef F_NPSUnHookMPR *PF_NPSUnHookMPR;

F_NPSUnHookMPR NPSUnHookMPR;

typedef DWORD NPSERVICE F_NPSUnHookMe(
    PF_NPSHookMPR pfMyNPSHookMPR, 
    struct _MPRCALLS *pChainedMPRCalls
    );
typedef F_NPSUnHookMe *PF_NPSUnHookMe;

F_NPSUnHookMe NPSUnHookMe;

typedef struct _MPRCALLS {
    PF_NPSHookMPR       pfNPSHookMPR;       /* NPSHookMPR call */
    PF_UnHookMPR        pfUnHookMPR;        /* UnHookMPR call */
    PF_LoadLibrary      pfLoadLibrary;      /* LoadLibrary call */
    PF_FreeLibrary      pfFreeLibrary;      /* FreeLibrary call */
    PF_GetProcAddress   pfGetProcAddress;   /* GetProcAddress call */
    PF_LoadLibrary16    pfLoadLibrary16;    /* LoadLibrary call */
    PF_FreeLibrary16    pfFreeLibrary16;    /* FreeLibrary call */
    PF_GetProcAddressByName16 pfGetProcAddressByName16; /* GetProcAddress call */
    PF_GetProcAddressByOrdinal16 pfGetProcAddressByOrdinal16; /* GetProcAddress call */
} MPRCALLS, *PMPRCALLS;

typedef HPROVIDER NPSERVICE F_NPSGetHandleFromInstance(
    BOOL    bWinnet16, 
	LPVOID  phInstance
	);
typedef F_NPSGetHandleFromInstance *PF_NPSGetHandleFromInstance;

F_NPSGetHandleFromInstance NPSGetHandleFromInstance;

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\toffdlg.cpp ===
/****************************************************************************\
 *
 *   toffdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Turn Off Ratings Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "toffdlg.h"        // CTurnOffDialog
#include "debug.h"

CTurnOffDialog::CTurnOffDialog()
{
    // Add construction here...
}

LRESULT CTurnOffDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SendDlgItemMessage(IDC_ADVISOR_OFF_CHECK,BM_SETCHECK,(WPARAM) BST_UNCHECKED,(LPARAM) 0);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CTurnOffDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(BST_CHECKED==SendDlgItemMessage(IDC_ADVISOR_OFF_CHECK,
                                       BM_GETCHECK,
                                       (WPARAM) 0,
                                       (LPARAM) 0))
    {
        HKEY            hkeyRating;

        hkeyRating = CreateRegKeyNT(::szRATINGS);

        if ( hkeyRating != NULL )
        {
            CRegKey         key;

            key.Attach( hkeyRating );

            DWORD dwTurnOff=1;

            key.SetValue( dwTurnOff, szTURNOFF );
        }
        else
        {
            TraceMsg( TF_ERROR, "CTurnOffDialog::OnOK() - Failed to Create Ratings Registry Key!" );
        }
    }

    EndDialog(TRUE);

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\msrating\rors.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

/*Included Files------------------------------------------------------------*/
#include "msrating.h"
#pragma hdrstop

#include <npassert.h>
#include <buffer.h>
#include "ratings.h"
#include "mslubase.h"
#include "parselbl.h"

#include "rors.h"
#include "wininet.h"


typedef HINTERNET (WINAPI *PFNInternetOpen)(
    IN LPCTSTR lpszCallerName,
    IN DWORD dwAccessType,
    IN LPCTSTR lpszServerName OPTIONAL,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );
typedef BOOL (WINAPI *PFNInternetCloseHandle)(
    IN HINTERNET hInternet
    );
typedef HINTERNET (WINAPI *PFNInternetConnect)(
    IN HINTERNET hInternet,
    IN LPCTSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCTSTR lpszUsername OPTIONAL,
    IN LPCTSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
typedef BOOL (WINAPI *PFNInternetReadFile)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );
typedef INTERNET_STATUS_CALLBACK (WINAPI *PFNInternetSetStatusCallback)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );
typedef HINTERNET (WINAPI *PFNHttpOpenRequest)(
    IN HINTERNET hHttpSession,
    IN LPCTSTR lpszVerb,
    IN LPCTSTR lpszObjectName,
    IN LPCTSTR lpszVersion,
    IN LPCTSTR lpszReferrer OPTIONAL,
    IN LPCTSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
typedef BOOL (WINAPI *PFNHttpSendRequest)(
    IN HINTERNET hHttpRequest,
    IN LPCTSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
typedef BOOL (WINAPI *PFNInternetCrackUrl)(
    IN LPCTSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    );
typedef BOOL (WINAPI *PFNInternetCanonicalizeUrl)(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


PFNInternetReadFile pfnInternetReadFile = NULL;
PFNHttpSendRequest pfnHttpSendRequest = NULL;
PFNInternetOpen pfnInternetOpen = NULL;
PFNInternetSetStatusCallback pfnInternetSetStatusCallback = NULL;
PFNInternetConnect pfnInternetConnect = NULL;
PFNHttpOpenRequest pfnHttpOpenRequest = NULL;
PFNInternetCloseHandle pfnInternetCloseHandle = NULL;
PFNInternetCrackUrl pfnInternetCrackUrl = NULL;
PFNInternetCanonicalizeUrl pfnInternetCanonicalizeUrl = NULL;

#undef InternetReadFile
#undef HttpSendRequest
#undef InternetOpen
#undef InternetSetStatusCallback
#undef InternetConnect
#undef HttpOpenRequest
#undef InternetCloseHandle
#undef InternetCrackUrl
#undef InternetCanonicalizeUrl

#define InternetReadFile pfnInternetReadFile
#define HttpSendRequest pfnHttpSendRequest
#define InternetOpen pfnInternetOpen
#define InternetSetStatusCallback pfnInternetSetStatusCallback
#define InternetConnect pfnInternetConnect
#define HttpOpenRequest pfnHttpOpenRequest
#define InternetCloseHandle pfnInternetCloseHandle
#define InternetCrackUrl pfnInternetCrackUrl
#define InternetCanonicalizeUrl pfnInternetCanonicalizeUrl

struct {
    FARPROC *ppfn;
    LPCSTR pszName;
} aImports[] = {
#ifndef UNICODE
    { (FARPROC *)&pfnInternetReadFile, "InternetReadFile" },
    { (FARPROC *)&pfnHttpSendRequest, "HttpSendRequestA" },
    { (FARPROC *)&pfnInternetOpen, "InternetOpenA" },
    { (FARPROC *)&pfnInternetSetStatusCallback, "InternetSetStatusCallback" },
    { (FARPROC *)&pfnInternetConnect, "InternetConnectA" },
    { (FARPROC *)&pfnHttpOpenRequest, "HttpOpenRequestA" },
    { (FARPROC *)&pfnInternetCloseHandle, "InternetCloseHandle" },
    { (FARPROC *)&pfnInternetCrackUrl, "InternetCrackUrlA" },
    { (FARPROC *)&pfnInternetCanonicalizeUrl, "InternetCanonicalizeUrlA" },
#else
    { (FARPROC *)&pfnInternetReadFile, "InternetReadFile" },
    { (FARPROC *)&pfnHttpSendRequest, "HttpSendRequestW" },
    { (FARPROC *)&pfnInternetOpen, "InternetOpenW" },
    { (FARPROC *)&pfnInternetSetStatusCallback, "InternetSetStatusCallback" },
    { (FARPROC *)&pfnInternetConnect, "InternetConnectW" },
    { (FARPROC *)&pfnHttpOpenRequest, "HttpOpenRequestW" },
    { (FARPROC *)&pfnInternetCloseHandle, "InternetCloseHandle" },
    { (FARPROC *)&pfnInternetCrackUrl, "InternetCrackUrlW" },
    { (FARPROC *)&pfnInternetCanonicalizeUrl, "InternetCanonicalizeUrlW" },
#endif
};

const UINT cImports = sizeof(aImports) / sizeof(aImports[0]);

HINSTANCE hWinINet = NULL;
BOOL fTriedLoad = FALSE;
HINTERNET hI = NULL;

void _stdcall WinInetCallbackProc(HINTERNET hInternet, DWORD_PTR Context, DWORD Status, LPVOID Info, DWORD Length);
#define USER_AGENT_STRING "Batcave(bcrs)"


BOOL LoadWinINet(void)
{
    if (fTriedLoad)
    {
        return (hWinINet != NULL);
    }

    fTriedLoad = TRUE;

    hWinINet = ::LoadLibrary("WININET.DLL");
    if (hWinINet == NULL)
    {
        return FALSE;
    }

    for (UINT i=0; i<cImports; i++)
    {
        *(aImports[i].ppfn) = ::GetProcAddress(hWinINet, aImports[i].pszName);
        if (*(aImports[i].ppfn) == NULL)
        {
            CleanupWinINet();
            return FALSE;
        }
    }

    hI = InternetOpen(USER_AGENT_STRING, PRE_CONFIG_INTERNET_ACCESS, NULL, 0, INTERNET_FLAG_ASYNC);
    if (hI == NULL)
    {
        CleanupWinINet();
        return FALSE;
    }

    InternetSetStatusCallback(hI, WinInetCallbackProc);

    return TRUE;
}


void CleanupWinINet(void)
{
    if (hI != NULL)
    {
        InternetCloseHandle(hI);
        hI = NULL;
    }

    if (hWinINet != NULL)
    {
        for (UINT i=0; i<cImports; i++)
        {
            *(aImports[i].ppfn) = NULL;
        }

        ::FreeLibrary(hWinINet);
        hWinINet = NULL;
    }
}


void _stdcall WinInetCallbackProc(HINTERNET hInternet, DWORD_PTR Context, DWORD Status, LPVOID Info, DWORD Length)
{
    BOOL unknown = FALSE;
    HANDLE  hAsyncEvent = (HANDLE) Context;

    char *type$;
    switch (Status)
    {
        case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

        case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

        case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

        case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

        case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

        case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

        case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

        case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

        case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

        case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

        case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        SetEvent(hAsyncEvent);
        break;

        default:
        type$ = "???";
        unknown = TRUE;
        break;
    }

/*
    printf("callback: handle %x [context %x ] %s \n",
        hInternet,
        Context,
        type$
        );
*/
}

#define ABORT_EVENT 0
#define ASYNC_EVENT 1


BOOL ShouldAbort(HANDLE hAbort)
{
    return (WAIT_OBJECT_0 == WaitForSingleObject(hAbort, 0));
}

BOOL WaitForAsync(HANDLE rgEvents[])
{
    BOOL fAbort;

//  if (ERROR_IO_PENDING != GetLastError()) return FALSE;       

    fAbort = (WAIT_OBJECT_0 == WaitForMultipleObjects(2, rgEvents, FALSE, INFINITE));
//  fAbort = (WAIT_OBJECT_0 == WaitForSingleObject(rgEvents[ABORT_EVENT], 0));

    return !fAbort;
}


void EncodeUrl(LPCTSTR pszTargetUrl, char *pBuf)
{
    while (*pszTargetUrl)
    {
        switch (*pszTargetUrl)
        {
        case ':':
            *pBuf++ = '%';
            *pBuf++ = '3';
            *pBuf++ = 'A';
            break;
        case '/':
            *pBuf++ = '%';
            *pBuf++ = '2';
            *pBuf++ = 'F';
            break;      
        default:
            *pBuf++ = *pszTargetUrl;
            break;
        }

        ++pszTargetUrl; 
    }

    *pBuf = 0;
}


STDMETHODIMP CRORemoteSite::QueryInterface(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IObtainRating))
    {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CRORemoteSite::AddRef(void)
{
    RefThisDLL(TRUE);

    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CRORemoteSite::Release(void)
{
    RefThisDLL(FALSE);

    if (!--m_cRef)
    {
        delete this;
        return 0;
    }
    else
    {
        return m_cRef;
    }
}


LPSTR FindRatingLabel(LPSTR pszResponse)
{
    /* pszResponse is the complete response message from the HTTP server.
     * It could be a simple response (just the PICS label we want) or it
     * could be a full response including headers.  In the former case we
     * just return the label, in the latter we have to skip the headers
     * to the message body.
     *
     * To be extra tolerant of poorly written label bureaus, we start by
     * looking at the start of the data to see if it's a left paren.  If
     * it isn't, we assume we've got some headers, so we skip to the
     * double CRLF which HTTP requires to terminate headers.  We don't
     * require a Status-Line (such as "HTTP/1.1 200 OK") even though
     * technically HTTP does.  If we don't find the double CRLF, then
     * we look for the string "(PICS-" which is usually what begins a
     * PICS label list.  If they've done everything else wrong and they're
     * also perverse enough to insert whitespace there (such as "( PICS-"),
     * tough.
     */

    SkipWhitespace(&pszResponse);       /* skip leading whitespace just in case */
    if (*pszResponse != '(')
    {          /* doesn't seem to start with a label */
        LPSTR pszBody = ::strstrf(pszResponse, ::szDoubleCRLF);
        if (pszBody != NULL)
        {          /* found double CRLF, end of HTTP headers */
            pszResponse = pszBody + 4;  /* length of CRLFCRLF */
        }
        else
        {                          /* no double CRLF, hunt for PICS label */
            pszBody = ::strstrf(pszResponse, ::szPicsOpening);
            if (pszBody != NULL)
            {
                pszResponse = pszBody;  /* beginning of PICS label */
            }
        }
    }

    return pszResponse;
}


const char szRequestTemplate[] = "?opt=normal&u=\"";
const UINT cchRequestTemplate = sizeof(szRequestTemplate) + 1;

STDMETHODIMP CRORemoteSite::ObtainRating(THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
                             IMalloc *pAllocator, LPSTR *ppRatingOut)
{
    HINTERNET hIC, hH;
    HANDLE  rgEvents[2];
    BOOL fRet;
    HRESULT hrRet = E_RATING_NOT_FOUND;
    char rgBuf[10000], *pBuf;   // PERF - way too much stack!
    DWORD  nRead, nBuf = sizeof(rgBuf) - 1;
    LPSTR pszRatingServer;

    if (!gPRSI->etstrRatingBureau.fIsInit())
    {
        return hrRet;
    }

    if (!LoadWinINet())
    {
        return hrRet;
    }

    pszRatingServer = gPRSI->etstrRatingBureau.Get();

    BUFFER bufBureauHostName(INTERNET_MAX_HOST_NAME_LENGTH);
    BUFFER bufBureauPath(INTERNET_MAX_PATH_LENGTH);

    if (!bufBureauHostName.QueryPtr() || !bufBureauPath.QueryPtr())
    {
        return E_OUTOFMEMORY;
    }

    URL_COMPONENTS uc;

    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = NULL;
    uc.dwSchemeLength = 0;
    uc.lpszHostName = (LPSTR)bufBureauHostName.QueryPtr();
    uc.dwHostNameLength = bufBureauHostName.QuerySize();
    uc.lpszUserName = NULL;
    uc.dwUserNameLength = 0;
    uc.lpszPassword = NULL;
    uc.dwPasswordLength = 0;
    uc.lpszUrlPath = (LPSTR)bufBureauPath.QueryPtr();
    uc.dwUrlPathLength = bufBureauPath.QuerySize();
    uc.lpszExtraInfo = NULL;
    uc.dwExtraInfoLength = 0;

    if (!InternetCrackUrl(pszRatingServer, 0, 0, &uc))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BUFFER bufRequest(INTERNET_MAX_URL_LENGTH + uc.dwUrlPathLength + cchRequestTemplate);

    LPSTR pszRequest = (LPSTR)bufRequest.QueryPtr();
    if (pszRequest == NULL)
    {
        return E_OUTOFMEMORY;
    }

    LPSTR pszCurrent = pszRequest;
    ::strcpyf(pszCurrent, uc.lpszUrlPath);
    pszCurrent += uc.dwUrlPathLength;

    ::strcpyf(pszCurrent, szRequestTemplate);
    pszCurrent += ::strlenf(pszCurrent);

    /* Encode the target URL. */
    EncodeUrl(pszTargetUrl, pszCurrent);

    ::strcatf(pszCurrent, "\"");

    hIC = hH = NULL;
    
    rgEvents[ABORT_EVENT] = hAbortEvent;
    rgEvents[ASYNC_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!rgEvents[ASYNC_EVENT])
    {
        goto STATE_CLEANUP;
    }

    hIC = InternetConnect(hI, uc.lpszHostName, uc.nPort, NULL, NULL,
                          INTERNET_SERVICE_HTTP, 0, (DWORD_PTR) rgEvents[ASYNC_EVENT]);
    if (hIC == NULL || ShouldAbort(hAbortEvent))
    {
        goto STATE_CLEANUP;
    }

    hH = HttpOpenRequest(hIC, "GET", pszRequest, NULL, NULL, NULL,
                         INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RELOAD,
                         (DWORD_PTR) rgEvents[ASYNC_EVENT]);
    if (hH == NULL || ShouldAbort(hAbortEvent))
    {
        goto STATE_CLEANUP;
    }

    fRet = HttpSendRequest(hH, NULL, (DWORD) 0, NULL, 0);
    if (!fRet && !WaitForAsync(rgEvents))
    {
        goto STATE_CLEANUP;
    }

    pBuf  = rgBuf;
    nRead = 0;
    do
    {
        fRet = InternetReadFile(hH, pBuf, nBuf-nRead, &nRead);
        if (!fRet && !WaitForAsync(rgEvents))
        {
            goto STATE_CLEANUP;
        }

        if (nRead)
        {
            pBuf += nRead;
            hrRet = NOERROR;
        }

    } while (nRead);
        

STATE_CLEANUP:
    if (hH)  InternetCloseHandle(hH);
    if (hIC) InternetCloseHandle(hIC);
    if (rgEvents[ASYNC_EVENT])
    {
        CloseHandle(rgEvents[ASYNC_EVENT]);
    }

    if (hrRet == NOERROR)
    {
        (*ppRatingOut) = (char*) pAllocator->Alloc((int)(pBuf - rgBuf + 1));
        if (*ppRatingOut != NULL)
        {
            *pBuf = '\0';
            LPSTR pszLabel = FindRatingLabel(rgBuf);
            strcpyf(*ppRatingOut, pszLabel);
        }
        else
        {
            hrRet = ResultFromScode(E_OUTOFMEMORY);
        }
    }

    if (hrRet == NOERROR)
    {
        hrRet = S_RATING_FOUND;
    }

    return hrRet;
}



STDMETHODIMP_(ULONG) CRORemoteSite::GetSortOrder(THIS)
{
    return RATING_ORDER_REMOTESITE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\npstub\npord.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NPORD.H -- Network service provider ordinal definitions.
 *
 * This is a PRIVATE header file.  Nobody but the MNR needs to call
 * a network provider directly.
 *
 * History:
 *  03/29/93    gregj   Created
 *  05/27/97    gregj   Taken from WNET source to implement NP delay load stub
 *
 */

#ifndef _INC_NPORD
#define _INC_NPORD

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define ORD_GETCONNECTIONS      12
#define ORD_GETCAPS             13
//#define ORD_DEVICEMODE          14      /* no longer supported */
#define ORD_GETUSER             16
#define ORD_ADDCONNECTION       17
#define ORD_CANCELCONNECTION    18
//#define ORD_PROPERTYDIALOG      29      /* no longer supported */
//#define ORD_GETDIRECTORYTYPE    30      /* no longer supported */      
//#define ORD_DIRECTORYNOTIFY     31      /* no longer supported */     
//#define ORD_GETPROPERTYTEXT     32      /* no longer supported */
#define ORD_OPENENUM            33
#define ORD_ENUMRESOURCE        34
#define ORD_CLOSEENUM           35
#define ORD_GETUNIVERSALNAME    36
//#define ORD_SEARCHDIALOG        38      /* no longer supported */
#define ORD_GETRESOURCEPARENT   41
#define ORD_VALIDDEVICE         42
#define ORD_LOGON               43
#define ORD_LOGOFF              44
#define ORD_GETHOMEDIRECTORY    45
#define ORD_FORMATNETWORKNAME   46
#define ORD_GETCONNPERFORMANCE  49
#define ORD_GETPOLICYPATH    	50
#define ORD_GETRESOURCEINFORMATION   52

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_NPORD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\npstub\npstub.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1997			**/
/*****************************************************************/ 

/* NPSTUB.H -- Definitions for example hooking network provider DLL.
 *
 * History:
 *	06/02/94	lens	Created
 */

#include <windows.h>
#include <netspi.h>

// Macros to define process local storage:

#define PROCESS_LOCAL_BEGIN data_seg(".PrcLcl","INSTANCE")
#define PROCESS_LOCAL_END data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\sample\defguid.cpp ===
#include "project.h"


// declaring the GUIDs inline avoids having to use INITGUID
// avoiding unneeded GUIDs being pulled in.

/* IMPORTANT: Run GUIDGEN and insert your own GUID for CLSID_SAMPLE */
/* ALSO insert the registry format equivalent for szOurGUID */
// {E9489DE0-B311-11cf-83B1-00C04FD705B2}
const GUID CLSID_Sample = 
{ 0xe9489de0, 0xb311, 0x11cf, { 0x83, 0xb1, 0x0, 0xc0, 0x4f, 0xd7, 0x5, 0xb2 } };
const char szOurGUID[] = "{E9489DE0-B311-11cf-83B1-00C04FD705B2}";

/* Interface ID for the IObtainRating interface. Leave this the way it is. */
// 19427BA0-826C-11CF-8DAB-00AA006C1A01
const GUID IID_IObtainRating = {0x19427BA0L, 0x826C, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\sample\defguid.h ===
// GUID for this server
extern const GUID CLSID_Sample;
extern const char szOurGUID[];

// 19427BA0-826C-11CF-8DAB-00AA006C1A01
extern const GUID IID_IObtainRating;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\sample\project.h ===
#include <windows.h>
#include "ratings.h"
#include "classes.h"
#include "defguid.h"

STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\sample\comobj.cpp ===
// 
// standard inprocserver DLL code, you should not need to mess with this
//

#include "project.h"


HANDLE g_hInst = NULL;
LONG g_cRefDll = 0;     // Number of locks on this DLL



STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    ASSERT( 0 != g_cRefDll );
    InterlockedDecrement(&g_cRefDll);
}


STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hInstDll;
    }
    return TRUE;
}

STDMETHODIMP CSampleClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IClassFactory)) {
		*ppvObject = (void *)this;
		AddRef();
		return NOERROR;
	}

	*ppvObject = NULL;
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSampleClassFactory::AddRef(void)
{
	DllAddRef();
	return 2;
}

STDMETHODIMP_(ULONG) CSampleClassFactory::Release(void)
{
	DllRelease();
	return 1;
}

STDMETHODIMP CSampleClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;

	if (NULL != pUnkOuter)
		return CLASS_E_NOAGGREGATION;

	CSampleObtainRating *pObj = new CSampleObtainRating;	/* doing this does implicit AddRef() */

	if (NULL == pObj)
		return E_OUTOFMEMORY;

	HRESULT hr = pObj->QueryInterface(riid, ppvObject);
    pObj->Release();

	return hr;
}
        
STDMETHODIMP CSampleClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return NOERROR;
}

//
// standard COM DLL self registering entry point
//

STDAPI DllRegisterServer(void)
{
	HKEY hkeyCLSID;
	LONG err;
    TCHAR szPath[MAX_PATH];

    // get path to this DLL

    GetModuleFileName(g_hInst, szPath, MAX_PATH);

	/* First register our CLSID under HKEY_CLASSES_ROOT. */
	err = ::RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
    	HKEY hkeyOurs;
		err = ::RegCreateKey(hkeyCLSID, ::szOurGUID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
        	HKEY hkeyInproc;
			err = ::RegCreateKey(hkeyOurs, "InProcServer32", &hkeyInproc);
			if (err == ERROR_SUCCESS) {
				err = ::RegSetValueEx(hkeyInproc, NULL, 0, REG_SZ,
					(LPBYTE)szPath, lstrlen(szPath) + 1);
				if (err == ERROR_SUCCESS) {
					err = ::RegSetValueEx(hkeyInproc, "ThreadingModel", 0,
										  REG_SZ, (LPBYTE)"Apartment", 10);
				}
				::RegCloseKey(hkeyInproc);
			}

			::RegCloseKey(hkeyOurs);
		}

		::RegCloseKey(hkeyCLSID);

		/* Now install ourselves as a ratings helper. */
		if (err == ERROR_SUCCESS) {
			err = ::RegCreateKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Rating Helpers", &hkeyCLSID);
			if (err == ERROR_SUCCESS) {
				err = ::RegSetValueEx(hkeyCLSID, ::szOurGUID, 0, REG_SZ, (LPBYTE)"", 2);
				::RegCloseKey(hkeyCLSID);
			}
		}
	}

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}

//
// standard COM DLL self registering entry point
//

STDAPI DllUnregisterServer(void)
{
	HKEY hkeyCLSID;
	LONG err;

	err = ::RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
    	HKEY hkeyOurs;
		err = ::RegOpenKey(hkeyCLSID, ::szOurGUID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
			err = ::RegDeleteKey(hkeyOurs, "InProcServer32");

			::RegCloseKey(hkeyOurs);

			if (err == ERROR_SUCCESS)
				err = ::RegDeleteKey(hkeyCLSID, ::szOurGUID);
		}

		::RegCloseKey(hkeyCLSID);

		if (err == ERROR_SUCCESS) {
			err = ::RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Rating Helpers", &hkeyCLSID);
			if (err == ERROR_SUCCESS) {
				err = ::RegDeleteValue(hkeyCLSID, ::szOurGUID);
				::RegCloseKey(hkeyCLSID);
			}
		}
	}

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}

//
// standard COM DLL entry point
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
	if (IsEqualCLSID(rclsid, CLSID_Sample)) 
    {
	    static CSampleClassFactory cf;	/* note, declaring this doesn't constitute a reference */

	    return cf.QueryInterface(riid, ppv);	/* will AddRef() if successful */
	}
    // to make this support more com objects add them here

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

//
// standard COM DLL entry point
//

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\sample\getlabel.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#include "project.h"


CSampleObtainRating::CSampleObtainRating()
{
    m_cRef = 1; 
    DllAddRef();
}

CSampleObtainRating::~CSampleObtainRating()
{
    DllRelease();
}


STDMETHODIMP CSampleObtainRating::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IObtainRating)) {
		*ppvObject = (void *)this;
		AddRef();
		return NOERROR;
	}
	*ppvObject = NULL;
	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CSampleObtainRating::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CSampleObtainRating::Release(void)
{
	if (!--m_cRef) {
		delete this;
		return 0;
	}
	else
		return m_cRef;
}


/* The sample rating obtainer reads the rating for the site from
 * a .INI file (ratings.ini) which looks like this:
 *
 * [Ratings]
 * http://www.msn.com=l 0 s 0 n 0 v 0
 * http://www.playboy.com=l 3 s 4 n 4 v 0
 *
 * For this sample implementation, the URL must match exactly with
 * an entry in the file.
 */
const TCHAR szRatingTemplate[] =
    "(PICS-1.0 \"http://www.rsac.org/ratingsv01.html\" l by \"Sample Rating Obtainer\" for \"%s\" on \"1996.04.16T08:15-0500\" exp \"1997.03.04T08:15-0500\" r (%s))";


STDMETHODIMP CSampleObtainRating::ObtainRating(THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut)
{
	TCHAR szRating[18];	/* big enough for "l 0 s 0 n 0 v 0" */
	UINT cchCopied;
	
	cchCopied = GetPrivateProfileString("Allow", pszTargetUrl, "", szRating, sizeof(szRating), "ratings.ini");
	if (cchCopied > 0) {
		return S_RATING_ALLOW;		/* explicitly allow access */
	}

	cchCopied = GetPrivateProfileString("Deny", pszTargetUrl, "", szRating, sizeof(szRating), "ratings.ini");
	if (cchCopied > 0) {
		return S_RATING_DENY;		/* explicitly deny access */
	}

	cchCopied = GetPrivateProfileString("Ratings", pszTargetUrl, "", szRating, sizeof(szRating), "ratings.ini");
	if (cchCopied == 0) {
		return E_RATING_NOT_FOUND;		/* rating not found */
	}

	LPSTR pBuffer = (LPSTR)pAllocator->Alloc(sizeof(szRatingTemplate) + lstrlen(pszTargetUrl) + lstrlen(szRating));
	if (pBuffer == NULL)
		return E_OUTOFMEMORY;

	::wsprintf(pBuffer, szRatingTemplate, pszTargetUrl, szRating);

	*ppRatingOut = pBuffer;

	return S_RATING_FOUND;
}


/* We want the sample provider to override any HTTP rating bureau
 * which might be installed, so we return a sort order value which
 * is less than the one used by that provider (0x80000000).
 */
STDMETHODIMP_(ULONG) CSampleObtainRating::GetSortOrder(THIS)
{
	return 0x40000000;	/* before rating bureau */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\sample\classes.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

class CSampleObtainRating : public IObtainRating
{
private:
	UINT m_cRef;

public:
	CSampleObtainRating();
	~CSampleObtainRating();
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

	STDMETHOD(ObtainRating) (THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut);

	STDMETHOD_(ULONG,GetSortOrder) (THIS);
};


class CSampleClassFactory : public IClassFactory
{
public:
	STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
	STDMETHODIMP LockServer(BOOL fLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\npstub\npstub.cpp ===
#include "npstub.h"
#include <netspi.h>
#include <npord.h>
#include <nphook.h>
#include <npstubx.h>    /* message defs, class name */

#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))

HINSTANCE hInstance = NULL;
HWND hwndMonitor = NULL;
CRITICAL_SECTION critsec;
ATOM aClass = NULL;

#define ENTERCRITICAL EnterCriticalSection(&::critsec);
#define LEAVECRITICAL LeaveCriticalSection(&::critsec);

UINT cCallsInProgress = 0;
BOOL fShouldUnload = FALSE;


/* This chunk of code invokes the entrypoint hooking feature of MPR.  We hook
 * things and immediately unhook ourselves.  We don't really want to hook
 * any functionality, this is just a way to kick MPR so he'll redetermine
 * the capabilities (via NPGetCaps) of all the net providers, including
 * ours.
 */
F_NPSHookMPR HookHookMPR;
F_UnHookMPR HookUnHookMPR;
F_LoadLibrary HookLoadLibrary;
F_FreeLibrary HookFreeLibrary;
F_GetProcAddress HookGetProcAddress;
F_LoadLibrary16 HookWMLoadWinnet16;
F_FreeLibrary16 HookWMFreeWinnet16;
F_GetProcAddressByName16 HookWMGetProcAddressByName;
F_GetProcAddressByOrdinal16 HookWMGetProcAddressByOrdinal;

MPRCALLS        MPRCalls = { HookHookMPR,
                             HookUnHookMPR,
                             HookLoadLibrary,
                             HookFreeLibrary,
                             HookGetProcAddress,
                             HookWMLoadWinnet16,
                             HookWMFreeWinnet16,
                             HookWMGetProcAddressByName,
                             HookWMGetProcAddressByOrdinal };


DWORD NPSERVICE HookHookMPR ( PMPRCALLS pMPRCalls )
{
    return ((PF_NPSHookMPR)(MPRCalls.pfNPSHookMPR))(pMPRCalls);
}

DWORD NPSERVICE HookUnHookMPR ( PF_NPSHookMPR pfReqNPSHookMPR, 
    PMPRCALLS pReqMPRCalls )
{
    if (pfReqNPSHookMPR == HookHookMPR) {
    
        // The unhook request has reached the hooker that issued
        // the NPSUnHookMe call (us).
        // In other words we are now sucessfully unhooked
        // and may do our unhooking cleanup.
        // In particular, we can release our tables that
        // manage LoadLibrary/GetProcAddress.
        // Note that this code may be executing on a different
        // thread to the NPSUnHookMe call which may have returned
        // a while ago.

        return WN_SUCCESS;
    }
    else {

        // Another hooker has requested to unhook by calling
        // NPSUnHookMe which causes us to be called here.
        // Pass the request on to the MPR service NPSUnHookMPR to
        // process the request, giving it our MPRCALLS
        // data structure so that it can figure out if
        // we are the right hooker to update and otherwise
        // MPR will pass the request on to the next hooker.

        return NPSUnHookMPR ( pfReqNPSHookMPR,
                              pReqMPRCalls,
                              (PMPRCALLS)&MPRCalls );
    }    
}

HINSTANCE HookLoadLibrary(
    LPCTSTR  lpszLibFile
    )
{
    return MPRCalls.pfLoadLibrary(lpszLibFile);
}

BOOL HookFreeLibrary(
    HMODULE hLibModule
    )
{
    return MPRCalls.pfFreeLibrary(hLibModule);
}

FARPROC HookGetProcAddress(
    HMODULE hModule,
    LPCSTR  lpszProc
    )
{
    return MPRCalls.pfGetProcAddress(hModule, lpszProc);
}

HANDLE16 HookWMLoadWinnet16(
    LPCTSTR  lpszLibFile
    )
{
    return MPRCalls.pfLoadLibrary16(lpszLibFile);
}

VOID HookWMFreeWinnet16(
    HANDLE16 hLibModule
    )
{
    MPRCalls.pfFreeLibrary16(hLibModule);
}

DWORD WINAPI HookWMGetProcAddressByName(
    LPCSTR   lpszProc,
    HANDLE16 hModule
    )
{
    return MPRCalls.pfGetProcAddressByName16(lpszProc, hModule);
}

DWORD WINAPI HookWMGetProcAddressByOrdinal(
    WORD     wOrdinal,
    HANDLE16 hModule
    )
{
    return MPRCalls.pfGetProcAddressByOrdinal16(wOrdinal, hModule);
}

void KickMPR(void)
{
    if (NPSHookMPR((PMPRCALLS)&MPRCalls) == WN_SUCCESS) {
        NPSUnHookMe(HookHookMPR, (PMPRCALLS)&MPRCalls);
    }
}
/***** End MPR hooking code *****/


/***** Begin code to delay-load the real net provider DLL *****/
HMODULE hmodRealNP = NULL;

PF_NPGetCaps pfnNPGetCaps = NULL;
PF_NPGetUniversalName pfnNPGetUniversalName = NULL;
PF_NPGetUser pfnNPGetUser = NULL;
PF_NPValidLocalDevice pfnNPValidLocalDevice = NULL;
PF_NPAddConnection pfnNPAddConnection = NULL;
PF_NPCancelConnection pfnNPCancelConnection = NULL;
PF_NPGetConnection pfnNPGetConnection = NULL;
PF_NPGetConnectionPerformance pfnNPGetConnectionPerformance = NULL;
PF_NPFormatNetworkName pfnNPFormatNetworkName = NULL;
PF_NPOpenEnum pfnNPOpenEnum = NULL;
PF_NPEnumResource pfnNPEnumResource = NULL;
PF_NPCloseEnum pfnNPCloseEnum = NULL;
PF_NPGetResourceParent pfnNPGetResourceParent = NULL;
PF_NPGetResourceInformation pfnNPGetResourceInformation = NULL;
PF_NPLogon pfnNPLogon = NULL;
PF_NPLogoff pfnNPLogoff = NULL;
PF_NPGetHomeDirectory pfnNPGetHomeDirectory = NULL;
PF_NPGetPolicyPath pfnNPGetPolicyPath = NULL;


struct {
    UINT nOrd;
    FARPROC *ppfn;
} aProcs[] = {
    { ORD_GETCAPS, (FARPROC *)&pfnNPGetCaps },
    { ORD_GETUNIVERSALNAME, (FARPROC *)&pfnNPGetUniversalName },
    { ORD_GETUSER, (FARPROC *)&pfnNPGetUser },
    { ORD_VALIDDEVICE, (FARPROC *)&pfnNPValidLocalDevice },
    { ORD_ADDCONNECTION, (FARPROC *)&pfnNPAddConnection },
    { ORD_CANCELCONNECTION, (FARPROC *)&pfnNPCancelConnection },
    { ORD_GETCONNECTIONS, (FARPROC *)&pfnNPGetConnection },
    { ORD_GETCONNPERFORMANCE, (FARPROC *)&pfnNPGetConnectionPerformance },
    { ORD_FORMATNETWORKNAME, (FARPROC *)&pfnNPFormatNetworkName },
    { ORD_OPENENUM, (FARPROC *)&pfnNPOpenEnum },
    { ORD_ENUMRESOURCE, (FARPROC *)&pfnNPEnumResource },
    { ORD_CLOSEENUM, (FARPROC *)&pfnNPCloseEnum },
    { ORD_GETRESOURCEPARENT, (FARPROC *)&pfnNPGetResourceParent },
    { ORD_GETRESOURCEINFORMATION, (FARPROC *)&pfnNPGetResourceInformation },
    { ORD_LOGON, (FARPROC *)&pfnNPLogon },
    { ORD_LOGOFF, (FARPROC *)&pfnNPLogoff },
    { ORD_GETHOMEDIRECTORY, (FARPROC *)&pfnNPGetHomeDirectory },
    { ORD_GETPOLICYPATH, (FARPROC *)&pfnNPGetPolicyPath },
};


void LoadRealNP(void)
{
    ENTERCRITICAL

    if (::hmodRealNP == NULL) {
        char szDLLName[MAX_PATH];

        szDLLName[0] = '\0';
        HKEY hkeySection;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB\\NetworkProvider",
                         0, KEY_QUERY_VALUE, &hkeySection) == ERROR_SUCCESS) {
            DWORD dwType;
            DWORD cbData = sizeof(szDLLName);
            RegQueryValueEx(hkeySection, "RealDLL", NULL, &dwType, (LPBYTE)szDLLName, &cbData);
            RegCloseKey(hkeySection);
        }

        if (szDLLName[0] == '\0')
            lstrcpy(szDLLName, "mslocusr.dll");

        ::hmodRealNP = LoadLibrary(szDLLName);

        if (::hmodRealNP != NULL) {
            for (UINT i=0; i<ARRAYSIZE(::aProcs); i++) {
                *(aProcs[i].ppfn) = GetProcAddress(::hmodRealNP, (LPCSTR)aProcs[i].nOrd);
            }
        }
    }
    LEAVECRITICAL
}


void UnloadRealNP(void)
{
    ENTERCRITICAL
    {
        if (cCallsInProgress > 0) {
            fShouldUnload = TRUE;
        }
        else {
            for (UINT i=0; i<ARRAYSIZE(::aProcs); i++) {
                *(aProcs[i].ppfn) = NULL;
            }

            FreeLibrary(hmodRealNP);
            hmodRealNP = NULL;
            fShouldUnload = FALSE;
            KickMPR();
        }
    }
    LEAVECRITICAL
}


LRESULT MonitorWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_NPSTUB_LOADDLL:
        LoadRealNP();
        KickMPR();
        break;

    case WM_NPSTUB_UNLOADDLL:
        UnloadRealNP();
        break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

void _ProcessAttach()
{
    //
    // All the per-instance initialization code should come here.
    //
	::DisableThreadLibraryCalls(::hInstance);

    InitializeCriticalSection(&::critsec);

    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = MonitorWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ::hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szNPSTUBClassName;

    ::aClass = RegisterClass(&wc);

    if (::aClass != NULL) {
        ::hwndMonitor = CreateWindow(szNPSTUBClassName, "",
                                     WS_POPUP | WS_DISABLED,
                                     0, 0, 0, 0,
                                     NULL, NULL,
                                     ::hInstance, NULL);
    }

    LoadRealNP();
}


void _ProcessDetach()
{
    if (::hwndMonitor != NULL)
        DestroyWindow(::hwndMonitor);
    if (::aClass != NULL)
        UnregisterClass((LPSTR)(WORD)::aClass, ::hInstance);

    DeleteCriticalSection(&::critsec);
}


extern "C" STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ::hInstance = hInstDll;
        _ProcessAttach();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        _ProcessDetach();
    }

    return TRUE;
}


void EnterSPI(void)
{
    ENTERCRITICAL
    {
        ::cCallsInProgress++;
    }
    LEAVECRITICAL
}


void LeaveSPI(void)
{
    ENTERCRITICAL
    {
        ::cCallsInProgress--;

        if (::fShouldUnload && !::cCallsInProgress)
            PostMessage(::hwndMonitor, WM_NPSTUB_UNLOADDLL, 0, 0);
    }
    LEAVECRITICAL
}


#define CALLNP(name,err,params)         \
    {                                   \
        if (pfn##name == NULL)          \
            return err;                 \
        DWORD dwRet = err;              \
        EnterSPI();                     \
        if (pfn##name != NULL)          \
            dwRet = (*pfn##name)params; \
        LeaveSPI();                     \
        return dwRet;                   \
    }                                   //last line doesn't need a backslash


SPIENTRY NPGetCaps(
    DWORD nIndex
    )
{
    CALLNP(NPGetCaps,0,(nIndex));
}


SPIENTRY NPGetUniversalName(
	LPTSTR  lpLocalPath,
	DWORD   dwInfoLevel,
	LPVOID  lpBuffer,
	LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetUniversalName,WN_NOT_SUPPORTED,
           (lpLocalPath,dwInfoLevel,lpBuffer,lpBufferSize));
}


SPIENTRY NPGetUser(
    LPTSTR  lpName,
    LPTSTR  lpAuthenticationID,
    LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetUser,WN_NOT_SUPPORTED,
           (lpName,lpAuthenticationID,lpBufferSize));
}


SPIENTRY NPValidLocalDevice(
    DWORD dwType,
    DWORD dwNumber
    )
{
    CALLNP(NPValidLocalDevice,WN_NOT_SUPPORTED,(dwType,dwNumber));
}


SPIENTRY NPAddConnection(
    HWND hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword,
    LPTSTR lpUserID,
    DWORD dwFlags,
	LPTSTR lpAccessName,
	LPDWORD lpBufferSize,
	LPDWORD lpResult
    )
{
    CALLNP(NPAddConnection,WN_NOT_SUPPORTED,
           (hwndOwner,lpNetResource,lpPassword,lpUserID,dwFlags,lpAccessName,lpBufferSize,lpResult));
}


SPIENTRY NPCancelConnection(
    LPTSTR lpName,
    BOOL fForce,
 	DWORD dwFlags
    )
{
    CALLNP(NPCancelConnection,WN_NOT_SUPPORTED,
           (lpName,fForce,dwFlags));
}


SPIENTRY NPGetConnection(
    LPTSTR lpLocalName,
    LPTSTR lpRemoteName,
    LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetConnection,WN_NOT_SUPPORTED,
           (lpLocalName,lpRemoteName,lpBufferSize));
}


SPIENTRY NPGetConnectionPerformance(
    LPTSTR lpRemoteName, 
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    )
{
    CALLNP(NPGetConnectionPerformance,WN_NOT_SUPPORTED,
           (lpRemoteName,lpNetConnectInfoStruct));
}


SPIENTRY NPFormatNetworkName(
    LPTSTR lpRemoteName,
    LPTSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    )
{
    CALLNP(NPFormatNetworkName,WN_NOT_SUPPORTED,
           (lpRemoteName,lpFormattedName,lpnLength,dwFlags,dwAveCharPerLine));
}


SPIENTRY NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCE lpNetResource,
    LPHANDLE lphEnum
    )
{
    CALLNP(NPOpenEnum,WN_NOT_SUPPORTED,
           (dwScope,dwType,dwUsage,lpNetResource,lphEnum));
}


SPIENTRY NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbFree
    )
{
    CALLNP(NPEnumResource,WN_NOT_SUPPORTED,
           (hEnum,lpcCount,lpBuffer,cbBuffer,lpcbFree));
}


SPIENTRY NPCloseEnum(
    HANDLE hEnum
    )
{
    CALLNP(NPCloseEnum,WN_NOT_SUPPORTED,
           (hEnum));
}


SPIENTRY NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    )
{
    CALLNP(NPGetResourceParent,WN_NOT_SUPPORTED,
           (lpNetResource,lpBuffer,cbBuffer));
}


SPIENTRY NPGetResourceInformation(
	LPNETRESOURCE lpNetResource,
	LPVOID lpBuffer,
	LPDWORD cbBuffer,
	LPSTR *lplpSystem
    )
{
    CALLNP(NPGetResourceInformation,WN_NOT_SUPPORTED,
           (lpNetResource,lpBuffer,cbBuffer,lplpSystem));
}


SPIENTRY NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    )
{
    CALLNP(NPLogon,WN_NOT_SUPPORTED,
           (hwndOwner,lpAuthentInfo,lpPreviousAuthentInfo,lpLogonScript,dwBufferSize,dwFlags));
}


SPIENTRY NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    )
{
    CALLNP(NPLogoff,WN_NOT_SUPPORTED,
           (hwndOwner,lpAuthentInfo,dwReason));
}


SPIENTRY NPGetHomeDirectory(
    LPTSTR lpDirectory,
    LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetHomeDirectory,WN_NOT_SUPPORTED,
           (lpDirectory,lpBufferSize));
}


SPIENTRY NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
	DWORD dwFlags
    )
{
    CALLNP(NPGetPolicyPath,WN_NOT_SUPPORTED,
           (lpPath,lpBufferSize,dwFlags));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\ratings\sample\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>

STDAPI RatingEnable(BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCTSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCTSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();


#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\comdll.cpp ===
#include "precomp.h"       // pch file
#include "cfdefs.h"        // CClassFactory, LPOBJECTINFO
#pragma hdrstop

STDAPI MailRecipient_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule);
STDAPI MailRecipient_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

STDAPI DesktopShortcut_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule);
STDAPI DesktopShortcut_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

// tables for object construction and registration 

CF_TABLE_BEGIN( g_ObjectInfo )

    CF_TABLE_ENTRY(&CLSID_MailRecipient, MailRecipient_CreateInstance, COCREATEONLY), 
    CF_TABLE_ENTRY(&CLSID_DesktopShortcut, DesktopShortcut_CreateInstance, COCREATEONLY), 

CF_TABLE_END( g_ObjectInfo )

typedef struct
{
    const CLSID *pclsid;
    HRESULT (STDMETHODCALLTYPE *pfnRegUnReg)(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule);
} REGISTRATIONINFO;

const REGISTRATIONINFO c_ri[] =
{
    { &CLSID_MailRecipient, MailRecipient_RegUnReg },
    { &CLSID_DesktopShortcut, DesktopShortcut_RegUnReg },
    { NULL },
};

LONG g_cRefDll = 0;         // reference count for this DLL
HINSTANCE g_hinst = NULL;   // HMODULE for this DLL


// life-time manangement and registration

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    ASSERT( 0 != g_cRefDll );
    InterlockedDecrement(&g_cRefDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hDll;
        SHFusionInitializeFromModule(hDll);
        DisableThreadLibraryCalls(hDll);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
    }
    return TRUE;
}

#define INPROCSERVER32  TEXT("InProcServer32")
#define CLSID           TEXT("CLSID")
#define THREADINGMODEL  TEXT("ThreadingModel")
#define APARTMENT       TEXT("Apartment")
#define APPROVED        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")
#define DESC            TEXT("Sendmail service")

STDAPI DllRegisterServer(void)
{
    const REGISTRATIONINFO *pcls;
    TCHAR szPath[MAX_PATH];

    GetModuleFileName(g_hinst, szPath, ARRAYSIZE(szPath));  // get path to this DLL

    for (pcls = c_ri; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, CLSID, 0, KEY_CREATE_SUB_KEY, &hkCLSID) == ERROR_SUCCESS) 
        {
            HKEY hkOurs;
            LONG err;
            TCHAR szGUID[80];

            SHStringFromGUID(*pcls->pclsid, szGUID, ARRAYSIZE(szGUID));

            err = RegCreateKeyEx(hkCLSID, szGUID, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hkOurs, NULL);
            if (err == ERROR_SUCCESS) 
            {
                HKEY hkInproc;
                err = RegCreateKeyEx(hkOurs, INPROCSERVER32, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkInproc, NULL);
                if (err == ERROR_SUCCESS) 
                {
                    err = RegSetValueEx(hkInproc, NULL, 0, REG_SZ, (LPBYTE)szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
                    if (err == ERROR_SUCCESS) 
                    {
                        err = RegSetValueEx(hkInproc, THREADINGMODEL, 0, REG_SZ, (LPBYTE)APARTMENT, sizeof(APARTMENT));
                    }
                    RegCloseKey(hkInproc);
                }

                if (pcls->pfnRegUnReg)
                    pcls->pfnRegUnReg(TRUE, hkOurs, szGUID, szPath);

                if (err == ERROR_SUCCESS)
                {   
                    HKEY hkApproved;
                    
                    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, APPROVED, 0, KEY_SET_VALUE, &hkApproved);
                    if (err == ERROR_SUCCESS)
                    {
                        err = RegSetValueEx(hkApproved, szGUID, 0, REG_SZ, (LPBYTE)DESC, sizeof(DESC));
                        RegCloseKey(hkApproved);
                    }
                }
                RegCloseKey(hkOurs);
            }
            RegCloseKey(hkCLSID);

            if (err != ERROR_SUCCESS)
                return HRESULT_FROM_WIN32(err);
        }
    }
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    const REGISTRATIONINFO *pcls;
    for (pcls = c_ri; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, CLSID, 0, KEY_CREATE_SUB_KEY, &hkCLSID) == ERROR_SUCCESS) 
        {
            TCHAR szGUID[80];
            HKEY  hkApproved;

            SHStringFromGUID(*pcls->pclsid, szGUID, ARRAYSIZE(szGUID));

            SHDeleteKey(hkCLSID, szGUID);
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, APPROVED, 0, KEY_SET_VALUE, &hkApproved) == ERROR_SUCCESS)
            {
                RegDeleteValue(hkApproved, szGUID);
                RegCloseKey(hkApproved);
            }

            RegCloseKey(hkCLSID);

            if (pcls->pfnRegUnReg)
                pcls->pfnRegUnReg(FALSE, NULL, szGUID, NULL);

        }
    }
    return S_OK;
}


// class factory stuff

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid,void**ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid,void**ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        if (punkOuter) // && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid,void**ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\debug.cpp ===
#include "precomp.h"
#pragma hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "sendmail"
#define SZ_MODULE           "SENDMAIL"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\precomp.h ===
#pragma warning(disable:4001)

#define STRICT
#define CONST_VTABLE

//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  CWindowImplBase__DefWindowProcWrapW when you expected to see
//  CWindowImplBase__DefWindowProc.
//

#include <windows.h>
#include <windowsx.h>

#include <intshcut.h>
#include <wininet.h> 
#include <shellapi.h>
#include <commctrl.h>
#include "shfusion.h"
#include <shlobj.h>
#include <ieguidp.h>
#include <shlwapi.h>
#include <varutil.h>
#include <ccstock.h>
#include <crtfree.h>
#include <cfdefs.h>
#include <port32.h>
#include <strsafe.h>

#include "debug.h"
#include "resource.h"


// constants and DLL life time manangement

extern HINSTANCE g_hinst;

STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();


// stuff for COM objects. every object needs to have a CLSID and Create function

extern const GUID CLSID_DesktopShortcut;

extern CLIPFORMAT g_cfHIDA;           // from sendmail.cpp

#define DEFAULTICON TEXT("DefaultIcon")


// in util.cpp
HRESULT ShellLinkSetPath(IUnknown *punk, LPCTSTR pszPath);
HRESULT ShellLinkGetPath(IUnknown *punk, LPTSTR pszPath, UINT cch);
BOOL IsShortcut(LPCTSTR pszFile);
HRESULT CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid);
HRESULT GetShortcutTarget(LPCTSTR pszPath, LPTSTR pszTarget, UINT cch);
HRESULT GetDropTargetPath(LPTSTR pszPath, int cchPath, int id, LPCTSTR pszExt);
void CommonRegister(HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszExtension, int idFileName);
BOOL SHPathToAnsi(LPCTSTR pszSrc, LPSTR pszDest, int cbDest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\mail.cpp ===
#include "precomp.h"       // pch file
#include "mapi.h"
#include "sendto.h"
#pragma hdrstop


// class that implement the MAPI send mail handler

typedef struct 
{
    TCHAR szTempShortcut[MAX_PATH];
    MapiMessage mm;
    MapiFileDesc mfd[0];
} MAPIFILES;

class CMailRecipient : public CSendTo
{
public:
    CMailRecipient();

private:    
    BOOL _GetDefaultMailHandler(LPTSTR pszMAPIDLL, DWORD cchMAPIDLL, BOOL *pbWantsCodePageInfo);
    HMODULE _LoadMailProvider(BOOL *pbWantsCodePageInfo);
    MAPIFILES *_AllocMAPIFiles(MRPARAM *pmp);
    void _FreeMAPIFiles(MAPIFILES *pmf);

    DWORD _grfKeyState;
    IStream *_pstrmDataObj;             // marshalled IDataObject

    static DWORD CALLBACK s_MAPISendMailThread(void *pv);
    DWORD _MAPISendMailThread();

protected:
    HRESULT v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect);
};


// construct the sendto object with the appropriate CLSID.

CMailRecipient::CMailRecipient() :
    CSendTo(CLSID_MailRecipient)
{
}


// read the default mail handler from the regstiry

#define MAIL_HANDLER    TEXT("Software\\Clients\\Mail")
#define MAIL_ATHENA_V1  TEXT("Internet Mail and News")
#define MAIL_ATHENA_V2  TEXT("Outlook Express")

BOOL CMailRecipient::_GetDefaultMailHandler(LPTSTR pszMAPIDLL, DWORD cchMAPIDLL, BOOL *pbWantsCodePageInfo)
{
    TCHAR szDefaultProg[80];
    DWORD cb = SIZEOF(szDefaultProg);

    *pbWantsCodePageInfo = FALSE;

    *pszMAPIDLL = 0;
    if (ERROR_SUCCESS == SHRegGetUSValue(MAIL_HANDLER, TEXT(""), NULL, szDefaultProg, &cb, FALSE, NULL, 0))
    {
        HKEY hkey;
        TCHAR szProgKey[128];

        StrCpyN(szProgKey, MAIL_HANDLER TEXT("\\"), ARRAYSIZE(szProgKey));
        StrCpyN(szProgKey, szDefaultProg, ARRAYSIZE(szProgKey));

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szProgKey, 0,  KEY_QUERY_VALUE,  &hkey))
        {
            // ugly, hard code this for OE
            *pbWantsCodePageInfo = (StrCmpI(szDefaultProg, MAIL_ATHENA_V2) == 0);

            cb = sizeof(*pszMAPIDLL)*cchMAPIDLL;
            if (ERROR_SUCCESS != SHQueryValueEx(hkey, TEXT("DLLPath"), 0, NULL, (LPBYTE)pszMAPIDLL, &cb))
            {
                if (StrCmpI(szDefaultProg, MAIL_ATHENA_V1) == 0)
                {
                    StrCpyN(pszMAPIDLL, TEXT("mailnews.dll"), cchMAPIDLL);
                }
            }
            RegCloseKey(hkey);
        }
    }
    return *pszMAPIDLL;
}


// load the mail provider, returning a suitable default if we can't read it from the registry

HMODULE CMailRecipient::_LoadMailProvider(BOOL *pbWantsCodePageInfo)
{
    TCHAR szMAPIDLL[MAX_PATH];
    if (!_GetDefaultMailHandler(szMAPIDLL, ARRAYSIZE(szMAPIDLL), pbWantsCodePageInfo))
    {
        // read win.ini (bogus hu!) for mapi dll provider
        if (GetProfileString(TEXT("Mail"), TEXT("CMCDLLName32"), TEXT(""), szMAPIDLL, ARRAYSIZE(szMAPIDLL)) <= 0)
        {
            StrCpyN(szMAPIDLL, TEXT("mapi32.dll"), ARRAYSIZE(szMAPIDLL));
        }
    }
    return LoadLibrary(szMAPIDLL);
}


// allocate a list of MAPI files

MAPIFILES* CMailRecipient::_AllocMAPIFiles(MRPARAM *pmp)
{
    MAPIFILES *pmf;
    int n = SIZEOF(*pmf) + (pmp->nFiles * SIZEOF(pmf->mfd[0]));;

    pmf = (MAPIFILES*)GlobalAlloc(GPTR, n + (pmp->nFiles * pmp->cchFile * 2)); 
    if (pmf)
    {
        pmf->mm.nFileCount = pmp->nFiles;
        if (pmp->nFiles)
        {
            int i;
            LPSTR pszA = (CHAR *)pmf + n;   // thunk buffer

            pmf->mm.lpFiles = pmf->mfd;

            CFileEnum MREnum(pmp, NULL);
            MRFILEENTRY *pFile;

            i = 0;
            while (pFile = MREnum.Next())
            {
                // if the first item is a folder, we will create a shortcut to
                // that instead of trying to mail the folder (that MAPI does not support)

                SHPathToAnsi(pFile->pszFileName, pszA, pmp->cchFile);

                pmf->mfd[i].lpszPathName = pszA;
                pmf->mfd[i].lpszFileName = PathFindFileNameA(pszA);
                pmf->mfd[i].nPosition = (UINT)-1;

                pszA += lstrlenA(pszA) + 1;
                ++i;
            }

        }
    }
    return pmf;
}


// free the list of mapi files

void CMailRecipient::_FreeMAPIFiles(MAPIFILES *pmf)
{
    if (pmf->szTempShortcut[0])
        DeleteFile(pmf->szTempShortcut);
    GlobalFree(pmf);
}


// package up the parameters and then kick off a background thread which will do
// the processing for the send mail.

HRESULT CMailRecipient::v_DropHandler(IDataObject *pdo, DWORD grfKeyState, DWORD dwEffect)
{
    _grfKeyState = grfKeyState;
    _pstrmDataObj = NULL;

    HRESULT hr = S_OK;
    if (pdo)
        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdo, &_pstrmDataObj);

    if (SUCCEEDED(hr))
    {   
        AddRef();
        if (!SHCreateThread(s_MAPISendMailThread, this,  CTF_PROCESS_REF|CTF_FREELIBANDEXIT|CTF_COINIT, NULL))
        {
            Release();
            hr = E_FAIL;
        }
    }

    if (FAILED(hr) && _pstrmDataObj)
    {
        _pstrmDataObj->Release();
        _pstrmDataObj = NULL;
    }

    return hr;
}
        
DWORD CALLBACK CMailRecipient::s_MAPISendMailThread(void *pv)
{
    CMailRecipient *pmr = (CMailRecipient *)pv;
    return pmr->_MAPISendMailThread();
}


// handler for the drop.  this creates a list of files and then passes the object to
// another thread which inturn releases it.

DWORD CMailRecipient::_MAPISendMailThread()
{
    HRESULT hr = S_OK;
    MRPARAM *pmp = (MRPARAM*)GlobalAlloc(GPTR, SIZEOF(*pmp));
    if (pmp)
    {
        // if we have an IDataObject stream then lets unmarshall it and 
        // create the file list from it.

        if (_pstrmDataObj)
        {
            IDataObject *pdo;
            hr = CoGetInterfaceAndReleaseStream(_pstrmDataObj, IID_PPV_ARG(IDataObject, &pdo));
            if (SUCCEEDED(hr))
            {
                hr = CreateSendToFilesFromDataObj(pdo, _grfKeyState, pmp);
                pdo->Release();
            }
            _pstrmDataObj = NULL;

        }

        // lets build the MAPI information so that we can send the files.

        if (SUCCEEDED(hr))
        {
            MAPIFILES *pmf = _AllocMAPIFiles(pmp);
            if (pmf)
            {
                TCHAR szText[4096+512] ={0};            // body text (with enough room for prefix/postfix)
                TCHAR szTemp[4096] = {0};           
                TCHAR szTitle[256] = {0};
                CHAR szTextA[ARRAYSIZE(szText)], szTitleA[ARRAYSIZE(szTitle)];   
    
                if (pmf->mm.nFileCount)
                {
                    CFileEnum MREnum(pmp, NULL);
                    MRFILEENTRY *pFile;

                    LoadString(g_hinst, IDS_SENDMAIL_MSGTITLE, szTitle, ARRAYSIZE(szTitle));

                    // release our stream objects
                    for (int iFile = 0; (NULL != (pFile = MREnum.Next())); iFile++)
                    {
                        if (iFile>0)
                        {
                            StrCatBuff(szTitle, TEXT(", "), ARRAYSIZE(szTitle));
                            StrCatBuff(szTemp, TEXT("\n\r"), ARRAYSIZE(szTemp));
                        }
                                                                            
                        TCHAR szTarget[MAX_PATH];
                        hr = GetShortcutTarget(pFile->pszFileName, szTarget, ARRAYSIZE(szTarget));
                        if (SUCCEEDED(hr))
                        {
                            TCHAR szFmt[128], szString[MAX_PATH+ARRAYSIZE(szFmt)];
                            LoadString(g_hinst, IDS_SENDMAIL_SHORTCUTTO, szFmt, ARRAYSIZE(szFmt));
                            StringCchPrintf(szString, ARRAYSIZE(szString), szFmt, szTarget);
                            StrCatBuff(szTemp, szString, ARRAYSIZE(szTemp));
                        }
                        else
                        {
                            StrCatBuff(szTemp, pFile->pszTitle, ARRAYSIZE(szTemp));
                        }

                        StrCatBuff(szTitle, pFile->pszTitle, ARRAYSIZE(szTitle));

// can change this logic once CFileStream supports STGM_DELETE_ON_RELEASE
                        ATOMICRELEASE(pFile->pStream);
                    }
                    
                    LoadString(g_hinst, IDS_SENDMAIL_MSGBODY, szText, ARRAYSIZE(szText));       // prefix
                    StrCatBuff(szText, szTemp, ARRAYSIZE(szText));                              // file list
                    LoadString(g_hinst, IDS_SENDMAIL_MSGPOSTFIX, szTemp, ARRAYSIZE(szTemp));
                    StrCatBuff(szText, szTemp, ARRAYSIZE(szText));                              // postfix
                    
                    // Don't fill in lpszNoteText if we know we are sending documents because OE will puke on it 

                    SHTCharToAnsi(szText, szTextA, ARRAYSIZE(szTextA));
                    if (!(pmp->dwFlags & MRPARAM_DOC)) 
                    {
                        pmf->mm.lpszNoteText = szTextA;
                    }
                    else
                    {
                        Assert(pmf->mm.lpszNoteText == NULL);  
                    }

                    SHTCharToAnsi(szTitle, szTitleA, ARRAYSIZE(szTitleA));
                    pmf->mm.lpszSubject = szTitleA;
                }

                BOOL bWantsCodePageInfo = FALSE;
                HMODULE hmodMail = _LoadMailProvider(&bWantsCodePageInfo);
                if (bWantsCodePageInfo && (pmp->dwFlags & MRPARAM_USECODEPAGE))
                {
                    // When this flag is set, we know that we have just one file to send and we have a code page
                    // Athena will then look at ulReserved for the code page
                    // Will the other MAPI handlers puke on this?  -- dli
                    ASSERT(pmf->mm.nFileCount == 1);
                    pmf->mfd[0].ulReserved = ((MRPARAM *)pmp)->uiCodePage;
                }

                if (hmodMail)
                {
                    LPMAPISENDMAIL pfnSendMail = (LPMAPISENDMAIL)GetProcAddress(hmodMail, "MAPISendMail");
                    if (pfnSendMail)
                    {
                        pfnSendMail(0, 0, &pmf->mm, MAPI_LOGON_UI | MAPI_DIALOG, 0);
                    }
                    FreeLibrary(hmodMail);
                }
                _FreeMAPIFiles(pmf);
            }
        }
        CleanupPMP(pmp);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    Release();
    return 0;
}


// construct the send to mail recipient object

STDAPI MailRecipient_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;          // assume failure

    if ( punkOuter )
        return CLASS_E_NOAGGREGATION;

    CMailRecipient *psm = new CMailRecipient;
    if ( !psm )
        return E_OUTOFMEMORY;

    HRESULT hr = psm->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    psm->Release();
    return hr;
}


// handle registration / link creation for the send mail verb

#define SENDMAIL_EXTENSION  TEXT("MAPIMail")
#define EXCHANGE_EXTENSION  TEXT("lnk")

STDAPI MailRecipient_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule)
{
    TCHAR szFile[MAX_PATH];
    if (bReg)
    {
        HKEY hk;
        CommonRegister(hkCLSID, pszCLSID, SENDMAIL_EXTENSION, IDS_MAIL_FILENAME);

        if (RegCreateKeyEx(hkCLSID, DEFAULTICON, 0, NULL, 0, KEY_SET_VALUE,NULL, &hk, NULL) == ERROR_SUCCESS) 
        {
            TCHAR szIcon[MAX_PATH + 10];
            StringCchPrintf(szIcon, ARRAYSIZE(szIcon), TEXT("%s,-%d"), pszModule, IDI_MAIL);
            RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)szIcon, (lstrlen(szIcon) + 1) * SIZEOF(TCHAR));
            RegCloseKey(hk);
        }

        // hide the exchange shortcut
        if (SUCCEEDED(GetDropTargetPath(szFile, ARRAYSIZE(szFile), IDS_MAIL_FILENAME, EXCHANGE_EXTENSION)))
        {
            SetFileAttributes(szFile, FILE_ATTRIBUTE_HIDDEN);
        }            
    }
    else
    {
        if (SUCCEEDED(GetDropTargetPath(szFile, ARRAYSIZE(szFile), IDS_MAIL_FILENAME, SENDMAIL_EXTENSION)))
        {
            DeleteFile(szFile);
        }

        // unhide the exchange shortcut
        if (SUCCEEDED(GetDropTargetPath(szFile, ARRAYSIZE(szFile), IDS_MAIL_FILENAME, EXCHANGE_EXTENSION)))
        {
            SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL);
        }            
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\desklink.cpp ===
#include "precomp.h"               // pch file
#include "sendto.h"
#pragma hdrstop


// class that implements the send to desktop (as shortcut)

const GUID CLSID_DesktopShortcut = { 0x9E56BE61L, 0xC50F, 0x11CF, 0x9A, 0x2C, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xCE };

class CDesktopShortcut : public CSendTo
{
private:    
    LPIDA _GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium);
    LPCITEMIDLIST _GetIDListPtr(LPIDA pida, UINT i);
    void _ReleaseStgMedium(void *pv, STGMEDIUM *pmedium);
    HRESULT _BindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut);
    HRESULT _InvokeVerbOnItems(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IShellFolder *psf, UINT cidl, LPCITEMIDLIST *apidl, LPCTSTR pszDirectory);
    HRESULT _InvokeVerbOnDataObj(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IDataObject *pdtobj, LPCTSTR pszDirectory);

protected:
    HRESULT v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect);

public:
    CDesktopShortcut();
};


// construct the sendto object with the appropriate CLSID.

CDesktopShortcut::CDesktopShortcut() :
    CSendTo(CLSID_DesktopShortcut)
{
}


// helper methods

LPIDA CDesktopShortcut::_GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pmedium)
    {
        pmedium->pUnkForRelease = NULL;
        pmedium->hGlobal = NULL;
    }

    if (!pmedium)
    {
        if (SUCCEEDED(pdtobj->QueryGetData(&fmte)))
            return (LPIDA)TRUE;
        else
            return (LPIDA)FALSE;
    }
    else if (SUCCEEDED(pdtobj->GetData(&fmte, pmedium)))
    {
        return (LPIDA)GlobalLock(pmedium->hGlobal);
    }

    return NULL;
}

LPCITEMIDLIST CDesktopShortcut::_GetIDListPtr(LPIDA pida, UINT i)
{
    if (NULL == pida)
    {
        return NULL;
    }

    if (i == (UINT)-1 || i < pida->cidl)
    {
        return (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1]);
    }

    return NULL;
}

// release a storage medium (doing a Global unlock as required).

void CDesktopShortcut::_ReleaseStgMedium(void *pv, STGMEDIUM *pmedium)
{
    if (pmedium->hGlobal && (pmedium->tymed == TYMED_HGLOBAL))
    {
        GlobalUnlock(pmedium->hGlobal);
    }
    ReleaseStgMedium(pmedium);
}

// dupe of shell\lib SHBindToObject() to avoid link dependancies... (OLEAUT32 gets pulled in by 
// stuff that does VARIANT goo in that lib)

HRESULT CDesktopShortcut::_BindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut)
{
    HRESULT hr;
    IShellFolder *psfRelease;

    *ppvOut = NULL;

    if (!psf)
    {
        hr = SHGetDesktopFolder(&psf);
        psfRelease = psf;
    }
    else
    {
        psfRelease = NULL;
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        // leave error code in hr
    }
    else if (!pidl || ILIsEmpty(pidl))
    {
        hr = psf->QueryInterface(riid, ppvOut);
    }
    else
    {
        hr = psf->BindToObject(pidl, NULL, riid, ppvOut);
    }

    if (psfRelease)
        psfRelease->Release();

    if (SUCCEEDED(hr) && (*ppvOut == NULL))
    {
        hr = E_FAIL;
    }

    return hr;
}

// invoke a verb on an array of items in the folder.

HRESULT CDesktopShortcut::_InvokeVerbOnItems(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IShellFolder *psf, UINT cidl, LPCITEMIDLIST *apidl, LPCTSTR pszDirectory)
{
    IContextMenu *pcm;
    HRESULT hr = psf->GetUIObjectOf(hwnd, cidl, apidl, IID_IContextMenu, NULL, (void **)&pcm);
    if (SUCCEEDED(hr))
    {
        CHAR szVerbA[128];
        WCHAR szVerbW[128];
        CHAR szDirA[MAX_PATH];
        WCHAR szDirW[MAX_PATH];
        CMINVOKECOMMANDINFOEX ici =
        {
            SIZEOF(CMINVOKECOMMANDINFOEX),
            uFlags | CMIC_MASK_UNICODE | CMIC_MASK_FLAG_NO_UI,
            hwnd,
            NULL,
            NULL,
            NULL,
            SW_NORMAL,
        };

        SHTCharToAnsi(pszVerb, szVerbA, ARRAYSIZE(szVerbA));
        SHTCharToUnicode(pszVerb, szVerbW, ARRAYSIZE(szVerbW));

        if (pszDirectory)
        {
            SHTCharToAnsi(pszDirectory, szDirA, ARRAYSIZE(szDirA));
            SHTCharToUnicode(pszDirectory, szDirW, ARRAYSIZE(szDirW));
            ici.lpDirectory = szDirA;
            ici.lpDirectoryW = szDirW;
        }

        ici.lpVerb = szVerbA;
        ici.lpVerbW = szVerbW;

        hr = pcm->InvokeCommand((CMINVOKECOMMANDINFO*)&ici);
        pcm->Release();
    }
    return hr;
}

// invoke a verb on the data object item

HRESULT CDesktopShortcut::_InvokeVerbOnDataObj(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IDataObject *pdtobj, LPCTSTR pszDirectory)
{
    HRESULT hr;
    STGMEDIUM medium;
    LPIDA pida = _GetHIDA(pdtobj, &medium);
    if (pida)
    {
        LPCITEMIDLIST pidlParent = _GetIDListPtr(pida, (UINT)-1);
        IShellFolder *psf;
        hr = _BindToObject(NULL, IID_IShellFolder, pidlParent, (void **)&psf);
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, pida->cidl * sizeof(LPCITEMIDLIST));
            if (ppidl)
            {
                UINT i;
                for (i = 0; i < pida->cidl; i++) 
                {
                    ppidl[i] = _GetIDListPtr(pida, i);
                }
                hr = _InvokeVerbOnItems(hwnd, pszVerb, uFlags, psf, pida->cidl, ppidl, pszDirectory);
                LocalFree((LPVOID)ppidl);
            }
            psf->Release();
        }
        _ReleaseStgMedium(pida, &medium);
    }
    else
        hr = E_FAIL;
    return hr;
}

// handle the drop on the object, so for each item in the HIDA invoke the create
// link verb on them.

HRESULT CDesktopShortcut::v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect)
{
    TCHAR szDesktop[MAX_PATH];
    if (SHGetSpecialFolderPath(NULL, szDesktop, CSIDL_DESKTOPDIRECTORY, FALSE))
    {
        if (g_cfHIDA == 0)
        {
            g_cfHIDA = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        }
        return _InvokeVerbOnDataObj (NULL, TEXT("link"), 0, pdtobj, szDesktop);
    }
    return E_OUTOFMEMORY;
}

// create an instance of desktop link object

STDAPI DesktopShortcut_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;          // assume failure

    if ( punkOuter )
        return CLASS_E_NOAGGREGATION;

    CDesktopShortcut *pds = new CDesktopShortcut;
    if ( !pds )
        return E_OUTOFMEMORY;

    HRESULT hr = pds->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pds->Release();
    return hr;
}

// handler registration of the desktop link verb

#define DESKLINK_EXTENSION  TEXT("DeskLink")

STDAPI DesktopShortcut_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule)
{
    TCHAR szFile[MAX_PATH];
    if (bReg)
    {
        HKEY hk;

        // get rid of old name "Desktop as Shortcut" link from IE4

        if (SUCCEEDED(GetDropTargetPath(szFile, ARRAYSIZE(szFile), IDS_DESKTOPLINK_FILENAME, DESKLINK_EXTENSION)))
            DeleteFile(szFile);

        if (RegCreateKeyEx(hkCLSID, DEFAULTICON, 0, NULL, 0, KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS) 
        {
            TCHAR szExplorer[MAX_PATH];
            TCHAR szIcon[MAX_PATH+10];
            GetWindowsDirectory(szExplorer, ARRAYSIZE(szExplorer));
            StringCchPrintf(szIcon, ARRAYSIZE(szIcon), TEXT("%s\\explorer.exe,-103"), szExplorer);    // ICO_DESKTOP res ID
            RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)szIcon, (lstrlen(szIcon) + 1) * SIZEOF(TCHAR));
            RegCloseKey(hk);
        }
        
        CommonRegister(hkCLSID, pszCLSID, DESKLINK_EXTENSION, IDS_DESKTOPLINK_FILENAME_NEW);
    }
    else
    {
        if (SUCCEEDED(GetDropTargetPath(szFile, ARRAYSIZE(szFile), IDS_DESKTOPLINK_FILENAME, DESKLINK_EXTENSION)))
        {
            DeleteFile(szFile);
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendmail.rc
//
#define IDS_SUREUNINST                  1
#define IDS_THISDLL                     2
#define IDS_OTHERFLD_FILENAME           3
#define IDS_MAIL_FILENAME               4

#define IDS_SENDMAIL_URL_FILENAME       5
#define IDS_SENDMAIL_FAILUREMSG         9
#define IDS_SENDMAIL_TITLE              10
#define IDS_SENDMAIL_RECOMPRESS         11
#define IDS_SENDMAIL_MSGBODY            12
#define IDS_SENDMAIL_MSGTITLE           13
#define IDS_SENDMAIL_SHOWMORE           14
#define IDS_SENDMAIL_SHOWLESS           15
#define IDS_SENDMAIL_SHORTCUTTO         17
#define IDS_SENDMAIL_MSGPOSTFIX         18

#define IDS_DESKTOPLINK_FILENAME        20
#define IDS_DESKTOPLINK_FILENAME_NEW    21

#define IDD_RECOMPRESS                  352

#define IDC_RECOMPORIGINAL              910
#define IDC_RECOMPALL                   911
#define IDC_RECOMPMAKETHEM              912
#define IDC_RECOMPSMALL                 913
#define IDC_RECOMPMEDIUM                914
#define IDC_RECOMPLARGE                 915
#define IDC_RECOMPSHOWHIDE              916
#define IDC_RECOMPTHUMBNAIL             917

#define IDC_FROM                        1000
#define IDC_TO                          1001
#define IDC_MOVE                        1002
#define IDC_COPY                        1003
#define IDC_LINK                        1004
#define IDC_COMBO2                      1006
#define IDC_BROWSE                      1008

#define IDI_OTHERFLD                    2000
#define IDI_MAIL                        2001

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\sendto.cpp ===
#include "precomp.h"       // pch file
#include "sendto.h"
#pragma hdrstop

CLIPFORMAT g_cfShellURL = 0;
CLIPFORMAT g_cfFileContents = 0;
CLIPFORMAT g_cfFileDescA = 0;
CLIPFORMAT g_cfFileDescW = 0;
CLIPFORMAT g_cfHIDA = 0;


// registry key for recompressing settings

struct
{
    int cx;
    int cy;
    int iQuality;
} 
_aQuality[] = 
{
    { 640,  480, 80 },          // low quality
    { 800,  600, 80 },          // medium quality
    { 1024, 768, 80 },          // high quality
};

#define QUALITY_LOW 0
#define QUALITY_MEDIUM 1
#define QUALITY_HIGH 2

#define RESPONSE_UNKNOWN 0
#define RESPONSE_CANCEL 1
#define RESPONSE_ORIGINAL 2
#define RESPONSE_RECOMPRESS 3

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)


// these bits are set by the user (holding down the keys) durring drag drop,
// but more importantly, they are set in the SimulateDragDrop() call that the
// browser implements to get the "Send Page..." vs "Send Link..." feature

#define IS_FORCE_LINK(grfKeyState)   ((grfKeyState == (MK_LBUTTON | MK_CONTROL | MK_SHIFT)) || \
                                      (grfKeyState == (MK_LBUTTON | MK_ALT)))

#define IS_FORCE_COPY(grfKeyState)   (grfKeyState == (MK_LBUTTON | MK_CONTROL))



// constructor / destructor

CSendTo::CSendTo(CLSID clsid) :
    _clsid(clsid), _cRef(1), _iRecompSetting(QUALITY_LOW)
{
    
    DllAddRef();    
}

CSendTo::~CSendTo()
{
    if (_pStorageTemp)
        _pStorageTemp->Release();
        
    DllRelease();
}

STDMETHODIMP CSendTo::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSendTo, IShellExtInit),
        QITABENT(CSendTo, IDropTarget),
        QITABENT(CSendTo, IPersistFile),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}    

STDMETHODIMP_(ULONG) CSendTo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSendTo::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CSendTo::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    TraceMsg(DM_TRACE, "CSendTo::DragEnter");
    _grfKeyStateLast = grfKeyState;
    _dwEffectLast = *pdwEffect;

    return S_OK;
}

STDMETHODIMP CSendTo::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;

    if (IS_FORCE_COPY(grfKeyState))
        *pdwEffect &= DROPEFFECT_COPY;
    else if (IS_FORCE_LINK(grfKeyState))
        *pdwEffect &= DROPEFFECT_LINK;

    _grfKeyStateLast = grfKeyState;
    _dwEffectLast = *pdwEffect;

    return S_OK;
}

STDMETHODIMP CSendTo::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = v_DropHandler(pdtobj, _grfKeyStateLast, _dwEffectLast);
    *pdwEffect = DROPEFFECT_COPY;                       // don't let source delete data
    return hr;
}

//
// helper methods
// 

int CSendTo::_PathCleanupSpec(/*IN OPTIONAL*/ LPCTSTR pszDir, /*IN OUT*/ LPTSTR pszSpec)
{
    WCHAR wzDir[MAX_PATH];
    WCHAR wzSpec[MAX_PATH];
    LPWSTR pwszDir = wzDir;
    int iRet;

    if (pszDir)
        SHTCharToUnicode(pszDir, wzDir, ARRAYSIZE(wzDir));
    else
        pwszDir = NULL;

    SHTCharToUnicode(pszSpec, wzSpec, ARRAYSIZE(wzSpec));
    iRet = PathCleanupSpec((LPTSTR)pwszDir, (LPTSTR)wzSpec);

    SHUnicodeToTChar(wzSpec, pszSpec, MAX_PATH);
    return iRet;
}

HRESULT CSendTo::_CreateShortcutToPath(LPCTSTR pszPath, LPCTSTR pszTarget)
{
    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        ShellLinkSetPath(punk, pszTarget);

        IPersistFile *ppf;
        hr = punk->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            WCHAR wszPath[MAX_PATH];
            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));

            hr = ppf->Save(wszPath, TRUE);
            ppf->Release();
        }
        punk->Release();
    }
    return hr;
}


// thunk A/W funciton to access A/W FILEGROUPDESCRIPTOR
// this relies on the fact that the first part of the A/W structures are
// identical. only the string buffer part is different. so all accesses to the
// cFileName field need to go through this function.

FILEDESCRIPTOR* CSendTo::_GetFileDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, int nIndex, LPTSTR pszName)
{
    if (fUnicode)
    {
        // Yes, so grab the data because it matches.
        FILEGROUPDESCRIPTORW * pfgdW = (FILEGROUPDESCRIPTORW *)pfgd;    // cast to what this really is
        if (pszName)
            SHUnicodeToTChar(pfgdW->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdW->fgd[nIndex];   // cast assume the non string parts are the same!
    }
    else
    {
        FILEGROUPDESCRIPTORA *pfgdA = (FILEGROUPDESCRIPTORA *)pfgd;     // cast to what this really is

        if (pszName)
            SHAnsiToTChar(pfgdA->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdA->fgd[nIndex];   // cast assume the non string parts are the same!
    }
}


// our own impl since URLMON IStream::CopyTo is busted, danpoz will be fixing this
HRESULT CSendTo::_StreamCopyTo(IStream *pstmFrom, IStream *pstmTo, LARGE_INTEGER cb, LARGE_INTEGER *pcbRead, LARGE_INTEGER *pcbWritten)
{
    BYTE buf[512];
    ULONG cbRead;
    HRESULT hr = S_OK;

    if (pcbRead)
    {
        pcbRead->LowPart = 0;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten)
    {
        pcbWritten->LowPart = 0;
        pcbWritten->HighPart = 0;
    }

    ASSERT(cb.HighPart == 0);

    while (cb.LowPart)
    {
        hr = pstmFrom->Read(buf, min(cb.LowPart, SIZEOF(buf)), &cbRead);

        if (pcbRead)
            pcbRead->LowPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;

        cb.LowPart -= cbRead;

        hr = pstmTo->Write(buf, cbRead, &cbRead);

        if (pcbWritten)
            pcbWritten->LowPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;
    }

    return hr;
}


// create a temporary shortcut to a file
// FEATURE: Colision is not handled here

BOOL CSendTo::_CreateTempFileShortcut(LPCTSTR pszTarget, LPTSTR pszShortcut, int cchShortcut)
{
    TCHAR szShortcutPath[MAX_PATH + 1];
    BOOL bSuccess = FALSE;
    
    if (GetTempPath(ARRAYSIZE(szShortcutPath), szShortcutPath))
    {
        PathAppend(szShortcutPath, PathFindFileName(pszTarget));

        if (IsShortcut(pszTarget))
        {
            TCHAR szTarget[MAX_PATH + 1];
            SHFILEOPSTRUCT shop = {0};
            shop.wFunc = FO_COPY;
            shop.pFrom = szTarget;
            shop.pTo = szShortcutPath;
            shop.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            StrCpyN(szTarget, pszTarget, ARRAYSIZE(szTarget));
            szTarget[lstrlen(szTarget) + 1] = TEXT('\0');

            szShortcutPath[lstrlen(szShortcutPath) + 1] = TEXT('\0');

            bSuccess = (0 ==  SHFileOperation(&shop));
        }
        else
        {
            PathRenameExtension(szShortcutPath, TEXT(".lnk"));
            bSuccess = SUCCEEDED(_CreateShortcutToPath(szShortcutPath, pszTarget));
        }

        if (bSuccess)
            StrCpyN(pszShortcut, szShortcutPath, cchShortcut);
    }
    return bSuccess;
} 


HRESULT CSendTo::_GetFileNameFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, LPTSTR pszDescription, int cchDescription)
{
    STGMEDIUM medium;
    HRESULT hr = pdtobj->GetData(pfmtetc, &medium);
    if (SUCCEEDED(hr))
    {
        // NOTE: this is a TCHAR format, we depend on how we are compiled, we really
        // should test both the A and W formats
        FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(medium.hGlobal);
        if (pfgd)
        {
            TCHAR szFdName[MAX_PATH];       // pfd->cFileName
            FILEDESCRIPTOR *pfd;

            // &pfgd->fgd[0], w/ thunk
            ASSERT(pfmtetc->cfFormat == g_cfFileDescW
              || pfmtetc->cfFormat == g_cfFileDescA);
            // for now, all callers are ANSI (other untested)
            //ASSERT(pfmtetc->cfFormat == g_cfFileDescA);
            pfd = _GetFileDescriptor(pfgd, pfmtetc->cfFormat == g_cfFileDescW, 0, szFdName);

            StrCpyN(pszDescription, szFdName, cchDescription);      // pfd->cFileName

            GlobalUnlock(medium.hGlobal);
            hr = S_OK;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}


// construct a nice title "<File Name> (<File Type>)"

void CSendTo::_GetFileAndTypeDescFromPath(LPCTSTR pszPath, LPTSTR pszDesc, int cchDesc)
{
    SHFILEINFO sfi;
    if (!SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME | SHGFI_DISPLAYNAME))
    {
        StrCpyN(sfi.szDisplayName, PathFindFileName(pszPath), ARRAYSIZE(sfi.szDisplayName));
        sfi.szTypeName[0] = 0;
    }
    StrCpyN(pszDesc, sfi.szDisplayName, cchDesc);
}


// pcszURL -> "ftp://ftp.microsoft.com"
// pcszPath -> "c:\windows\desktop\internet\Microsoft FTP.url"

HRESULT CSendTo::_CreateNewURLShortcut(LPCTSTR pcszURL, LPCTSTR pcszURLFile)
{
    IUniformResourceLocator *purl;
    HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUniformResourceLocator, &purl));
    if (SUCCEEDED(hr))
    {
        hr = purl->SetURL(pcszURL, 0);
        if (SUCCEEDED(hr))
        {
            IPersistFile *ppf;
            hr = purl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                WCHAR wszFile[INTERNET_MAX_URL_LENGTH];
                SHTCharToUnicode(pcszURLFile, wszFile, ARRAYSIZE(wszFile));

                hr = ppf->Save(wszFile, TRUE);
                ppf->Release();
            }
        }
        purl->Release();
    }
    return hr;
}


HRESULT CSendTo::_CreateURLFileToSend(IDataObject *pdtobj, MRPARAM *pmp)
{
    MRFILEENTRY *pFile = pmp->pFiles;
    HRESULT hr = CSendTo::_CreateNewURLShortcut(pFile->pszTitle, pFile->pszFileName);
    if (SUCCEEDED(hr))
    {
        _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle, pmp->cchTitle);
        pFile->dwFlags |= MRFILE_DELETE;
    }    
    return hr;
}


HRESULT CSendTo::_GetHDROPFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr = E_FAIL;
    HDROP hDrop = (HDROP)pmedium->hGlobal;

    pmp->nFiles = DragQueryFile(hDrop, -1, NULL, 0);

    if (pmp->nFiles && AllocatePMP(pmp, MAX_PATH, MAX_PATH))
    {
        int i;
        CFileEnum MREnum(pmp, NULL);
        MRFILEENTRY *pFile;

        for (i = 0; (pFile = MREnum.Next()) && DragQueryFile(hDrop, i, pFile->pszFileName, pmp->cchFile); ++i)
        {
            if (IS_FORCE_LINK(grfKeyState) || PathIsDirectory(pFile->pszFileName))
            {
                // Want to send a link even for the real file, we will create links to the real files
                // and send it.
                _CreateTempFileShortcut(pFile->pszFileName, pFile->pszFileName, pmp->cchFile);
                pFile->dwFlags |= MRFILE_DELETE;
            }

            _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle, pmp->cchTitle);
        }

        // If loop terminates early update our item count
        pmp->nFiles = i;

        hr = S_OK;
    }
    return hr;
}


// "Uniform Resource Locator" format

HRESULT CSendTo::_GetURLFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr = E_FAIL;

    // This DataObj is from the internet
    // NOTE: We only allow to send one file here.
    pmp->nFiles = 1;
    if (AllocatePMP(pmp, INTERNET_MAX_URL_LENGTH, MAX_PATH))
    {
        // n.b. STR not TSTR!  since URLs only support ansi
        //lstrcpyn(pmp->pszTitle, (LPSTR)GlobalLock(pmedium->hGlobal), INTERNET_MAX_URL_LENGTH);
        MRFILEENTRY *pFile = pmp->pFiles;
        SHAnsiToTChar((LPSTR)GlobalLock(pmedium->hGlobal), pFile->pszTitle, INTERNET_MAX_URL_LENGTH);
        GlobalUnlock(pmedium->hGlobal);
        
        if (pFile->pszTitle[0])
        {
            // Note some of these functions depend on which OS we
            // are running on to know if we should pass ansi or unicode strings
            // to it Windows 95

            if (GetTempPath(MAX_PATH, pFile->pszFileName))
            {
                TCHAR szFileName[MAX_PATH];

                // it's an URL, which is always ANSI, but the filename
                // can still be wide (?)
                FORMATETC fmteW = {g_cfFileDescW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                FORMATETC fmteA = {g_cfFileDescA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                
                if (FAILED(_GetFileNameFromData(pdtobj, &fmteW, szFileName, ARRAYSIZE(szFileName))))
                {
                    if (FAILED(_GetFileNameFromData(pdtobj, &fmteA, szFileName, ARRAYSIZE(szFileName))))
                    {
                        LoadString(g_hinst, IDS_SENDMAIL_URL_FILENAME, szFileName, ARRAYSIZE(szFileName));
                    }
                }

                _PathCleanupSpec(pFile->pszFileName, szFileName);
                hr = _CreateURLFileToSend(pdtobj, pmp);
            }
        }
    }
    return hr;
}


// transfer FILECONTENTS/FILEGROUPDESCRIPTOR data to a temp file then send that in mail

HRESULT CSendTo::_GetFileContentsFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr = E_FAIL;
    MRFILEENTRY *pFile = NULL;

    // NOTE: We only allow to send one file here.
    pmp->nFiles = 1;
    if (AllocatePMP(pmp, INTERNET_MAX_URL_LENGTH, MAX_PATH))
    {
        pFile = pmp->pFiles;
        
        FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(pmedium->hGlobal);
        if (pfgd)
        {
            TCHAR szFdName[MAX_PATH];       // pfd->cFileName
            FILEDESCRIPTOR *pfd;

            // &pfgd->fgd[0], w/ thunk
            ASSERT((pfmtetc->cfFormat == g_cfFileDescW) || (pfmtetc->cfFormat == g_cfFileDescA));
            pfd = _GetFileDescriptor(pfgd, pfmtetc->cfFormat == g_cfFileDescW, 0, szFdName);

            // the file we're about to create has contents from the internet.
            // use the internet cache to mark it as "unsafe" so other pages that might know
            // the filename can't refer to it and elevate their privileges.
            // createurlcacheentry says first param has to be a unique string so just use this GUID.
            if (CreateUrlCacheEntry(L"67a3caff-bedc-4090-a21e-492dd8935102", 0, NULL, pFile->pszFileName, 0))
            {
                PathRemoveFileSpec(pFile->pszFileName); // only interested in the dir that it sits in.
                DeleteUrlCacheEntry(L"67a3caff-bedc-4090-a21e-492dd8935102");

                STGMEDIUM medium;
                FORMATETC fmte = {g_cfFileContents, NULL, pfmtetc->dwAspect, 0, TYMED_ISTREAM | TYMED_HGLOBAL};
                hr = pdtobj->GetData(&fmte, &medium);
                if (SUCCEEDED(hr))
                {
                    PathAppend(pFile->pszFileName, szFdName);    // pfd->cFileName
                    _PathCleanupSpec(pFile->pszFileName, PathFindFileName(pFile->pszFileName));
                    PathYetAnotherMakeUniqueName(pFile->pszFileName, pFile->pszFileName, NULL, NULL);

                    IStream *pstmFile;
                    hr = SHCreateStreamOnFile(pFile->pszFileName, STGM_WRITE | STGM_CREATE, &pstmFile);
                    if (SUCCEEDED(hr))
                    {
                        switch (medium.tymed) 
                        {
                            case TYMED_ISTREAM:
                            {
                                const LARGE_INTEGER li = {-1, 0};   // the whole thing
                                hr = _StreamCopyTo(medium.pstm, pstmFile, li, NULL, NULL);
                                break;
                            }

                            case TYMED_HGLOBAL:
                                hr = pstmFile->Write(GlobalLock(medium.hGlobal), 
                                                       pfd->dwFlags & FD_FILESIZE ? pfd->nFileSizeLow:(DWORD)GlobalSize(medium.hGlobal),
                                                       NULL);
                                GlobalUnlock(medium.hGlobal);
                                break;

                            default:
                                hr = E_FAIL;
                        }

                        pstmFile->Release();
                        if (FAILED(hr))
                            DeleteFile(pFile->pszFileName);
                    }
                    ReleaseStgMedium(&medium);
                }
            }
            GlobalUnlock(pmedium->hGlobal);
        }
    }

    if (SUCCEEDED(hr))
    {
        _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle, pmp->cchTitle);
        pFile->dwFlags |= MRFILE_DELETE;
        
        if (pfmtetc->dwAspect == DVASPECT_COPY)
        {
            pmp->dwFlags |= MRPARAM_DOC;    // we are sending the document

            // get the code page if there is one
            IQueryCodePage *pqcp;
            if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IQueryCodePage, &pqcp))))
            {
                if (SUCCEEDED(pqcp->GetCodePage(&pmp->uiCodePage)))
                    pmp->dwFlags |= MRPARAM_USECODEPAGE;
                pqcp->Release();
            }
        }
    }
    else if (pfmtetc->dwAspect == DVASPECT_COPY)
    {
        TCHAR szFailureMsg[MAX_PATH], szFailureMsgTitle[40];
        LoadString(g_hinst, IDS_SENDMAIL_FAILUREMSG, szFailureMsg, ARRAYSIZE(szFailureMsg));
        LoadString(g_hinst, IDS_SENDMAIL_TITLE, szFailureMsgTitle, ARRAYSIZE(szFailureMsgTitle));
                    
        int iRet = MessageBox(NULL, szFailureMsg, szFailureMsgTitle, MB_YESNO);
        if (iRet == IDNO)
            hr = S_FALSE;     // convert to success to we don't try DVASPECT_LINK
    }

    return hr;
}


// generate a set of files from the data object

typedef struct 
{
    INT format;
    FORMATETC fmte;
} DATA_HANDLER;

#define GET_FILECONTENT 0
#define GET_HDROP       1
#define GET_URL         2

// Note: If this function returns E_CANCELLED that tells the caller that the user requested us to cancel the
//       sendmail operation.
HRESULT CSendTo::CreateSendToFilesFromDataObj(IDataObject *pdtobj, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr;
    DWORD dwAspectPrefered;
    IEnumFORMATETC *penum;

    if (g_cfShellURL == 0)
    {
        g_cfShellURL = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLURL);                     // URL is always ANSI
        g_cfFileContents = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_cfFileDescA = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_cfFileDescW = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
    }

    if (IS_FORCE_COPY(grfKeyState))
        dwAspectPrefered = DVASPECT_COPY;
    else if (IS_FORCE_LINK(grfKeyState))
        dwAspectPrefered = DVASPECT_LINK;
    else
        dwAspectPrefered = DVASPECT_CONTENT;

    hr = pdtobj->EnumFormatEtc(DATADIR_GET, &penum);
    if (SUCCEEDED(hr))
    {
        DATA_HANDLER rg_data_handlers[] = {
            GET_FILECONTENT, {g_cfFileDescW, NULL, dwAspectPrefered, -1, TYMED_HGLOBAL},
            GET_FILECONTENT, {g_cfFileDescW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
            GET_FILECONTENT, {g_cfFileDescA, NULL, dwAspectPrefered, -1, TYMED_HGLOBAL},
            GET_FILECONTENT, {g_cfFileDescA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
            GET_HDROP,       {CF_HDROP,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
            GET_URL,         {g_cfShellURL,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        };

        FORMATETC fmte;
        while (penum->Next(1, &fmte, NULL) == S_OK)
        {
            SHFree(fmte.ptd);
            fmte.ptd = NULL; // so nobody looks at it
            int i;
            for (i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
            {
                if (rg_data_handlers[i].fmte.cfFormat == fmte.cfFormat &&
                    rg_data_handlers[i].fmte.dwAspect == fmte.dwAspect)
                {
                    STGMEDIUM medium;
                    if (SUCCEEDED(pdtobj->GetData(&rg_data_handlers[i].fmte, &medium)))
                    {
                        switch ( rg_data_handlers[i].format )
                        {
                            case GET_FILECONTENT:
                                hr = _GetFileContentsFromData(pdtobj, &fmte, &medium, grfKeyState, pmp);
                                break;
            
                            case GET_HDROP:
                                hr = _GetHDROPFromData(pdtobj, &fmte, &medium, grfKeyState, pmp);
                                break;

                            case GET_URL:
                                hr = _GetURLFromData(pdtobj, &fmte, &medium, grfKeyState, pmp);
                                break;                                
                        }

                        ReleaseStgMedium(&medium);

                        if (SUCCEEDED(hr))
                            goto Done;
                    }
                }
            }
        }
Done:
        penum->Release();
    }

    if (SUCCEEDED(hr))
        hr = FilterPMP(pmp);
        
    return hr;
}


// allocate and free a file list.  pmp->nFiles MUST be initialized before calling this function!

BOOL CSendTo::AllocatePMP(MRPARAM *pmp, DWORD cchTitle, DWORD cchFiles)
{
    // Remember the array sizes for overflow checks, etc.
    pmp->cchFile = cchFiles;
    pmp->cchTitle = cchTitle;

    // compute size of each file entry and allocate enough for the number of files we have.  Also
    // add a TCHAR to the end of the buffer so we can do a double null termination safely while deleting files
    
    pmp->cbFileEntry = sizeof(MRFILEENTRY) + ((cchTitle + cchFiles) * sizeof(TCHAR));
    pmp->pFiles = (MRFILEENTRY *)GlobalAlloc(GPTR, (pmp->cbFileEntry * pmp->nFiles) + sizeof(TCHAR));
    if (!pmp->pFiles)
        return FALSE;

    CFileEnum MREnum(pmp, NULL);
    MRFILEENTRY *pFile;

    // Note: The use of the enumerator here is questionable since this is the loop that initializes the 
    //       data structure.  If the implementation changes in the future be sure this assumption still holds.

    while (pFile = MREnum.Next())
    {
        pFile->pszFileName = (LPTSTR)pFile->chBuf;
        pFile->pszTitle = pFile->pszFileName + cchFiles;

        ASSERTMSG(pFile->dwFlags == 0, "Expected zero-inited memory allocation");
        ASSERTMSG(pFile->pszFileName[cchFiles-1] == 0, "Expected zero-inited memory allocation");
        ASSERTMSG(pFile->pszTitle[cchTitle-1] == 0, "Expected zero-inited memory allocation");
        ASSERTMSG(pFile->pStream == NULL, "Expected zero-inited memory allocation");
    }
    
    return TRUE;
}

BOOL CSendTo::CleanupPMP(MRPARAM *pmp)
{
    CFileEnum MREnum(pmp, NULL);
    MRFILEENTRY *pFile;

    while (pFile = MREnum.Next())
    {
        // delete the file if we are supposed to
        if (pFile->dwFlags & MRFILE_DELETE)
            DeleteFile(pFile->pszFileName);

        // If we held on to a temporary stream release it so the underlying data will be deleted.
        ATOMICRELEASE(pFile->pStream);
    }

    if (pmp->pFiles)
    {
        GlobalFree((LPVOID)pmp->pFiles);
        pmp->pFiles = NULL;
    }

    GlobalFree(pmp);
    return TRUE;
}


// allow files to be massaged before sending

HRESULT CSendTo::FilterPMP(MRPARAM *pmp)
{
    // lets handle the initialization of the progress dialog
    IActionProgress *pap;
    HRESULT hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActionProgress, &pap));
    if (SUCCEEDED(hr))
    {
        TCHAR szBuffer[MAX_PATH];
        IActionProgressDialog *papd;
        hr = pap->QueryInterface(IID_PPV_ARG(IActionProgressDialog, &papd));
        if (SUCCEEDED(hr))
        {
            LoadString(g_hinst, IDS_SENDMAIL_TITLE, szBuffer, ARRAYSIZE(szBuffer));
            hr = papd->Initialize(0x0, szBuffer, NULL);
            papd->Release();
        }
        
        if (SUCCEEDED(hr))
        {
            LoadString(g_hinst, IDS_SENDMAIL_RECOMPRESS, szBuffer, ARRAYSIZE(szBuffer));
            pap->UpdateText(SPTEXT_ACTIONDESCRIPTION, szBuffer, FALSE);
            pap->Begin(SPACTION_COPYING, SPBEGINF_NORMAL);
        }

        if (FAILED(hr))
        {
            pap->Release();
            pap = NULL;
        }
    }

    // walk the files and perform the recompress if we need to.

    int iResponse = RESPONSE_UNKNOWN;

    CFileEnum MREnum(pmp, pap);
    MRFILEENTRY *pFile;
    for (hr = S_OK; (pFile = MREnum.Next()) && SUCCEEDED(hr); )
    {
        if (pap)
            pap->UpdateText(SPTEXT_ACTIONDETAIL, pFile->pszFileName, TRUE);

        // if this is a picture then lets off the option to recompress the image 

        if (PathIsImage(pFile->pszFileName))
        {
            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(pFile->pszFileName, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHCreateShellItem(NULL, NULL, pidl, &_psi);
                if (SUCCEEDED(hr))
                {   
                    // if the response is unknown then we need to prompt for which type of optimization
                    // needs to be performed. 

                    if (iResponse == RESPONSE_UNKNOWN)
                    {
                        // we need the link control window

                        INITCOMMONCONTROLSEX initComctl32;
                        initComctl32.dwSize = sizeof(initComctl32); 
                        initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
                        InitCommonControlsEx(&initComctl32);

                        // we need a parent window

                        HWND hwnd = GetActiveWindow();
                        if (pap)
                            IUnknown_GetWindow(pap, &hwnd);

                        iResponse = (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_RECOMPRESS), 
                                                        hwnd, s_ConfirmDlgProc, (LPARAM)this);

                    }
            
                    // based on the response we either have cache or the dialog lets perform
                    // that operation as needed.

                    if (iResponse == RESPONSE_CANCEL)
                    {
                        hr = E_CANCELLED;
                    }
                    else if (iResponse == RESPONSE_RECOMPRESS)
                    {
                        IStorage *pstg;
                        hr = _GetTempStorage(&pstg);
                        if (SUCCEEDED(hr))
                        {
                            IImageRecompress *pir;
                            hr = CoCreateInstance(CLSID_ImageRecompress, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImageRecompress, &pir));
                            if (SUCCEEDED(hr))
                            {
                                IStream *pstrm;
                                hr = pir->RecompressImage(_psi, _aQuality[_iRecompSetting].cx, _aQuality[_iRecompSetting].cy, _aQuality[_iRecompSetting].iQuality, pstg, &pstrm);
                                if (hr == S_OK)
                                {
                                    STATSTG stat;
                                    hr = pstrm->Stat(&stat, STATFLAG_DEFAULT);
                                    if (SUCCEEDED(hr))
                                    {
                                        // its OK to delete this file now, b/c we are going to replace it with the recompressed
                                        // stream we have just generated from the source.
                                        if (pFile->dwFlags & MRFILE_DELETE)
                                            DeleteFile(pFile->pszFileName);

                                        // get the information on the recompressed object.
                                        StrCpyNW(pFile->pszFileName, _szTempPath, pmp->cchFile);
                                        PathAppend(pFile->pszFileName, stat.pwcsName);
                                        _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle, pmp->cchTitle);

                                        pFile->dwFlags |= MRFILE_DELETE;
                                        pstrm->QueryInterface(IID_PPV_ARG(IStream, &pFile->pStream));
        
                                        CoTaskMemFree(stat.pwcsName);
                                    }
                                    pstrm->Release();
                                }
                                pir->Release();
                            }
                            pstg->Release();
                        }
                    }

                    if (SUCCEEDED(hr) && pap)
                    {
                        BOOL fCancelled;
                        if (SUCCEEDED(pap->QueryCancel(&fCancelled)) && fCancelled)
                        {
                            hr = E_CANCELLED;
                        }
                    }

                    _psi->Release();
                }
                ILFree(pidl);
            }
        }
    }

    if (pap)
    {
        pap->End();
        pap->Release();
    }

    return hr;
}


HRESULT CSendTo::_GetTempStorage(IStorage **ppStorage)
{    
    *ppStorage = NULL;
        
    HRESULT hr;
    if (_pStorageTemp == NULL)
    {
        if (GetTempPath(ARRAYSIZE(_szTempPath), _szTempPath))
        {
            LPITEMIDLIST pidl = NULL;
            hr = SHILCreateFromPath(_szTempPath, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IStorage, ppStorage));
                if (SUCCEEDED(hr))
                {
                    hr = (*ppStorage)->QueryInterface(IID_PPV_ARG(IStorage, &_pStorageTemp));
                }
                ILFree(pidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = _pStorageTemp->QueryInterface(IID_PPV_ARG(IStorage, ppStorage));
    }

    return hr;
}


void CSendTo::_CollapseOptions(HWND hwnd, BOOL fHide)
{
    _fOptionsHidden = fHide;

    RECT rc1, rc2;        
    GetWindowRect(GetDlgItem(hwnd, IDC_RECOMPORIGINAL), &rc1);
    GetWindowRect(GetDlgItem(hwnd, IDC_RECOMPLARGE), &rc2);
    int cyAdjust = (rc2.top - rc1.top) * (fHide ? -1:1);

    // show/hide the controls we are not going to use

    UINT idHide[] = { IDC_RECOMPMAKETHEM, IDC_RECOMPSMALL, IDC_RECOMPMEDIUM, IDC_RECOMPLARGE };
    for (int i = 0; i < ARRAYSIZE(idHide); i++)
    {
        ShowWindow(GetDlgItem(hwnd, idHide[i]), fHide ? SW_HIDE:SW_SHOW);
    }

    // move the buttons at the bottom of the dialog

    UINT idMove[] = { IDC_RECOMPSHOWHIDE, IDOK, IDCANCEL };
    for (int i = 0; i < ARRAYSIZE(idMove); i++)
    {
        RECT rcItem;
        GetWindowRect(GetDlgItem(hwnd, idMove[i]), &rcItem);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rcItem, 2);

        SetWindowPos(GetDlgItem(hwnd, idMove[i]), NULL, 
                     rcItem.left, rcItem.top + cyAdjust, 0, 0, 
                     SWP_NOSIZE|SWP_NOZORDER);
    }

    // resize the dialog accordingly

    RECT rcWindow;
    GetWindowRect(hwnd, &rcWindow);
    SetWindowPos(hwnd, NULL, 
                 0, 0, RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow) + cyAdjust, 
                 SWP_NOZORDER|SWP_NOMOVE);

    // update the link control

    TCHAR szBuffer[MAX_PATH];
    LoadString(g_hinst, fHide ? IDS_SENDMAIL_SHOWMORE:IDS_SENDMAIL_SHOWLESS, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(hwnd, IDC_RECOMPSHOWHIDE, szBuffer);
}


// dialog proc for the recompress prompt

BOOL_PTR CSendTo::s_ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CSendTo *pst = (CSendTo*)GetWindowLongPtr(hwnd, DWLP_USER);
    if (msg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pst = (CSendTo*)lParam;
    }    
    return pst->_ConfirmDlgProc(hwnd, msg, wParam, lParam);
}

BOOL_PTR CSendTo::_ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{    
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            HWND hwndThumbnail = GetDlgItem(hwnd, IDC_RECOMPTHUMBNAIL);
            LONG_PTR dwStyle = GetWindowLongPtr(hwndThumbnail, GWL_STYLE);

            // set the default state of the dialog
            _CollapseOptions(hwnd, TRUE);

            // set the default state of the buttons
            CheckRadioButton(hwnd, IDC_RECOMPORIGINAL, IDC_RECOMPALL, IDC_RECOMPALL);
            CheckRadioButton(hwnd, IDC_RECOMPSMALL, IDC_RECOMPLARGE, IDC_RECOMPSMALL + _iRecompSetting);

            // get the thumbnail and show it.
            IExtractImage *pei;
            HRESULT hr = _psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractImage, &pei));
            if (SUCCEEDED(hr))
            {
                RECT rcThumbnail;
                GetClientRect(GetDlgItem(hwnd, IDC_RECOMPTHUMBNAIL), &rcThumbnail);

                SIZE sz = {RECTWIDTH(rcThumbnail), RECTHEIGHT(rcThumbnail)};
                WCHAR szImage[MAX_PATH];
                DWORD dwFlags = 0;

                hr = pei->GetLocation(szImage, ARRAYSIZE(szImage), NULL, &sz, 24, &dwFlags);
                if (SUCCEEDED(hr))
                {
                    HBITMAP hbmp;
                    hr = pei->Extract(&hbmp);
                    if (SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_BITMAP);
                        HBITMAP hbmp2 = (HBITMAP)SendMessage(hwndThumbnail, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hbmp);
                        if (hbmp2)
                        {
                            DeleteObject(hbmp2);
                        }
                    }
                }
                pei->Release();
            }

            // if that failed then lets get the icon for the file and place that into the dialog,
            // this is less likely to fail - I hope.

            if (FAILED(hr))
            {
                IPersistIDList *ppid;
                hr = _psi->QueryInterface(IID_PPV_ARG(IPersistIDList, &ppid));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = ppid->GetIDList(&pidl);
                    if (SUCCEEDED(hr))
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCWSTR)pidl, -1, &sfi, sizeof(sfi), SHGFI_ICON|SHGFI_PIDL|SHGFI_ADDOVERLAYS))
                        {
                            SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_ICON);
                            HICON hIcon = (HICON)SendMessage(hwndThumbnail, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)sfi.hIcon);
                            if (hIcon)
                            {
                                DeleteObject(hIcon);
                            }
                        }
                        ILFree(pidl);
                    }
                    ppid->Release();
                }
            }

            break;
        }

        case WM_NOTIFY:
        {
           // Did they click/keyboard on the alter settings link?
            NMHDR *pnmh = (NMHDR *)lParam;
            if ((wParam == IDC_RECOMPSHOWHIDE) &&
                    (pnmh->code == NM_CLICK || pnmh->code == NM_RETURN)) 
            {
                _CollapseOptions(hwnd, !_fOptionsHidden);
                return TRUE;
            }
            break;
        }
           
        case WM_COMMAND:
        {
            switch (wParam)
            {
                case IDOK:
                {
                    // read back the quality index and store
                    if (IsDlgButtonChecked(hwnd, IDC_RECOMPSMALL))
                        _iRecompSetting = QUALITY_LOW;
                    else if (IsDlgButtonChecked(hwnd, IDC_RECOMPMEDIUM))
                        _iRecompSetting = QUALITY_MEDIUM;
                    else
                        _iRecompSetting = QUALITY_HIGH;

                    // dismiss the dialog, returning the radio button state
                    EndDialog(hwnd,(IsDlgButtonChecked(hwnd, IDC_RECOMPALL)) ? RESPONSE_RECOMPRESS:RESPONSE_ORIGINAL);
                    return FALSE;
                }

                case IDCANCEL:
                    EndDialog(hwnd, RESPONSE_CANCEL);
                    return FALSE;

                default: 
                    break;
            }
            break;
        }
            
        default:
            return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shfolder\resource.h ===
#define IDS_CSIDL_PERSONAL          1
#define IDS_CSIDL_MYPICTURES        2
#define IDS_CSIDL_APPDATA           3
#define IDS_CSIDL_LOCAL_APPDATA     4
#define IDS_CSIDL_CACHE             5
#define IDS_CSIDL_COOKIES           6
#define IDS_CSIDL_HISTORY           7
#define IDS_CSIDL_COMMON_DOCUMENTS  8
#define IDS_CSIDL_ADMINTOOLS        9
#define IDS_CSIDL_MYMUSIC           10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\sendto.h ===
// class that provides the base implementation of the send to object.  from here
// you can override the v_DropHandler and add your own functionality.

#define HINST_THISDLL   g_hinst

// shorthand for error code saying user requested cancel
#define E_CANCELLED     HRESULT_FROM_WIN32(ERROR_CANCELLED)

#define MRPARAM_DOC         0x00000001
#define MRPARAM_USECODEPAGE 0x00000002

#define MRFILE_DELETE       0x00000001

#include <shimgdata.h>

typedef struct
{
    DWORD   dwFlags;        // MRFILE_*
    LPTSTR  pszFileName;    // points to beginning of chBuf
    LPTSTR  pszTitle;       // points to space in chBuf after space needed for filename
    IStream *pStream;       // If non-null release stream when deleting the structure
    TCHAR   chBuf[1];
} MRFILEENTRY;

typedef struct 
{
    DWORD dwFlags;          // Attributes passed to the MAPI apis
    MRFILEENTRY *pFiles;    // List of file information
    DWORD cbFileEntry;      // number of bytes in a single MRFILELIST entry
    DWORD cchFile;          // number of characters in pszFileName field of MRFILELIST entry
    DWORD cchTitle;         // number of characters in pszTitle field of MRFILELIST entry
    int nFiles;             // The number of files being sent.
    UINT uiCodePage;        // Code page 
} MRPARAM;


/*
    Helper class for walking file list.  Example:
    
    CFileEnum MREnum(pmp, NULL);
    MRFILEENTRY *pFile;

    while (pFile = MREnum.Next())
    {
        ... do stuff with pFile ...
    }
*/
class CFileEnum
{
private:
    int             _nFilesLeft;
    MRPARAM *       _pmp;
    MRFILEENTRY *   _pFile;
    IActionProgress *_pap;

public:    
    CFileEnum(MRPARAM *pmp, IActionProgress *pap) 
        { _pmp = pmp; _pFile = NULL; _nFilesLeft = -1; _pap = NULL; IUnknown_Set((IUnknown**)&_pap, pap); }

    ~CFileEnum()
        { ATOMICRELEASE(_pap); }

    MRFILEENTRY * Next()
        { 
            if (_nFilesLeft < 0)
            {
                _nFilesLeft = _pmp->nFiles;
                _pFile = _pmp->pFiles;
            }

            MRFILEENTRY *pFile = NULL;            
            if (_nFilesLeft > 0)
            {
                pFile = _pFile;
                
                _pFile = (MRFILEENTRY *)((LPBYTE)_pFile + _pmp->cbFileEntry);
                --_nFilesLeft;
            }

            if (_pap)
                _pap->UpdateProgress(_pmp->nFiles-_nFilesLeft, _pmp->nFiles);

            return pFile;
        }
};

class CSendTo : public IDropTarget, IShellExtInit, IPersistFile
{
private:
    CLSID      _clsid;
    LONG       _cRef;
    DWORD      _grfKeyStateLast;
    DWORD      _dwEffectLast;    
    IStorage * _pStorageTemp;
    TCHAR      _szTempPath[MAX_PATH];
    
    BOOL        _fOptionsHidden;   
    INT         _iRecompSetting;
    IShellItem *_psi;

    int _PathCleanupSpec(/*IN OPTIONAL*/ LPCTSTR pszDir, /*IN OUT*/ LPTSTR pszSpec);
    HRESULT _CreateShortcutToPath(LPCTSTR pszPath, LPCTSTR pszTarget);
    FILEDESCRIPTOR* _GetFileDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, int nIndex, LPTSTR pszName);
    HRESULT _StreamCopyTo(IStream *pstmFrom, IStream *pstmTo, LARGE_INTEGER cb, LARGE_INTEGER *pcbRead, LARGE_INTEGER *pcbWritten);
    BOOL _CreateTempFileShortcut(LPCTSTR pszTarget, LPTSTR pszShortcut, int cchShortcut);
    HRESULT _GetFileNameFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, LPTSTR pszDesc, int cchDesc);
    void _GetFileAndTypeDescFromPath(LPCTSTR pszPath, LPTSTR pszDesc, int cchDesc);
    HRESULT _CreateNewURLShortcut(LPCTSTR pcszURL, LPCTSTR pcszURLFile);
    HRESULT _CreateURLFileToSend(IDataObject *pdtobj, MRPARAM *pmp);
    HRESULT _GetHDROPFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp);
    HRESULT _GetURLFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp);
    HRESULT _GetFileContentsFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp);
    HRESULT _GetTempStorage(IStorage **ppStorage);
    void _CollapseOptions(HWND hwnd, BOOL fHide);
    static BOOL_PTR s_ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR _ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
    BOOL AllocatePMP(MRPARAM *pmp, DWORD cbTitle, DWORD cbFiles);
    BOOL CleanupPMP(MRPARAM *pmp);
    HRESULT FilterPMP(MRPARAM *pmp);
    HRESULT CreateSendToFilesFromDataObj(IDataObject *pdtobj, DWORD grfKeyState, MRPARAM *pmp);

    // Virtual drop method implemented by derived object
    virtual HRESULT v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect) PURE;

public:
    CSendTo(CLSID clsid);
    virtual ~CSendTo();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)(); 

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *lpdobj, HKEY hkeyProgID)
        { return S_OK; };

    // IDropTarget
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave()
        { return S_OK; }
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID)
        { *pClassID = _clsid; return S_OK; };

    // IPersistFile
    STDMETHODIMP IsDirty(void)
        { return S_FALSE; };
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode)
        { return S_OK; };
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName)
        { *ppszFileName = NULL; return S_OK; };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\cenumusernotify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       CEnumUserNotify.cpp
//
//  Contents:   implements CEnumUserNotify object
//
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\sendmail\util.cpp ===
#include "precomp.h"       // pch file
#pragma hdrstop
#define DECL_CRTFREE
#include <crtfree.h>

// deal with IShellLinkA/W uglyness...

HRESULT ShellLinkSetPath(IUnknown *punk, LPCTSTR pszPath)
{
    IShellLinkW *pslW;
    HRESULT hres = punk->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW));
    if (SUCCEEDED(hres))
    {
        hres = pslW->SetPath(pszPath);
        pslW->Release();
    }
    return hres;
}

// deal with IShellLinkA/W uglyness...

HRESULT ShellLinkGetPath(IUnknown *punk, LPTSTR pszPath, UINT cch)
{
    HRESULT hres;

    IShellLinkW *pslW;
    hres = punk->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW));
    if (SUCCEEDED(hres))
    {
        hres = pslW->GetPath(pszPath, cch, NULL, SLGP_UNCPRIORITY);
        pslW->Release();
    }
    return hres;
}


// is a file a shortcut?  check its attributes

BOOL IsShortcut(LPCTSTR pszFile)
{
    SHFILEINFO sfi;
    return SHGetFileInfo(pszFile, 0, &sfi, sizeof(sfi), SHGFI_ATTRIBUTES) 
                                                && (sfi.dwAttributes & SFGAO_LINK);
}


// like OLE GetClassFile(), but it only works on ProgID\CLSID type registration
// not real doc files or pattern matched files

HRESULT CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid)
{
    TCHAR szProgID[80];
    LONG cb = SIZEOF(szProgID);
    if (RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szProgID, &cb) == ERROR_SUCCESS)
    {
        StrCatBuff(szProgID, TEXT("\\CLSID"), ARRAYSIZE(szProgID));

        TCHAR szCLSID[80];
        cb = SIZEOF(szCLSID);
        if (RegQueryValue(HKEY_CLASSES_ROOT, szProgID, szCLSID, &cb) == ERROR_SUCCESS)
        {
            return CLSIDFromString(szCLSID, pclsid);
        }
    }
    return E_FAIL;
}


// get the target of a shortcut. this uses IShellLink which 
// Internet Shortcuts (.URL) and Shell Shortcuts (.LNK) support so
// it should work generally

HRESULT GetShortcutTarget(LPCTSTR pszPath, LPTSTR pszTarget, UINT cch)
{
    *pszTarget = 0;     // assume none

    if (!IsShortcut(pszPath))
        return E_FAIL;

    CLSID clsid;
    if (FAILED(CLSIDFromExtension(PathFindExtension(pszPath), &clsid)))
        clsid = CLSID_ShellLink;        // assume it's a shell link

    IUnknown *punk;
    HRESULT hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hres))
    {
        IPersistFile *ppf;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
        {
            WCHAR wszPath[MAX_PATH];
            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
            ppf->Load(wszPath, 0);
            ppf->Release();
        }
        hres = ShellLinkGetPath(punk, pszTarget, cch);
        punk->Release();
    }

    return hres;
}


// get the pathname to a sendto folder item

HRESULT GetDropTargetPath(LPTSTR pszPath, int cchPath, int id, LPCTSTR pszExt)
{
    ASSERT(cchPath == MAX_PATH);

    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_SENDTO, &pidl)))
    {
        SHGetPathFromIDList(pidl, pszPath);
        SHFree(pidl);

        TCHAR szFileName[128], szBase[64];
        LoadString(g_hinst, id, szBase, ARRAYSIZE(szBase));
        StringCchPrintf(szFileName, ARRAYSIZE(szFileName), TEXT("\\%s.%s"), szBase, pszExt);

        StrCatBuff(pszPath, szFileName, cchPath);
        return S_OK;
    }
    return E_FAIL;
}


// do common registration

#define NEVERSHOWEXT            TEXT("NeverShowExt")
#define SHELLEXT_DROPHANDLER    TEXT("shellex\\DropHandler")

void CommonRegister(HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszExtension, int idFileName)
{
    HKEY hk;
    TCHAR szKey[80];

    RegSetValueEx(hkCLSID, NEVERSHOWEXT, 0, REG_SZ, (BYTE *)TEXT(""), SIZEOF(TCHAR));

    if (RegCreateKeyEx(hkCLSID, SHELLEXT_DROPHANDLER, 0, NULL, 0, KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS) 
    {
        RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)pszCLSID, (lstrlen(pszCLSID) + 1) * SIZEOF(TCHAR));
        RegCloseKey(hk);
    }

    StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT(".%s"), pszExtension);
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS) 
    {
        TCHAR szProgID[80];

        StringCchPrintf(szProgID, ARRAYSIZE(szProgID), TEXT("CLSID\\%s"), pszCLSID);

        RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)szProgID, (lstrlen(szProgID) + 1) * SIZEOF(TCHAR));
        RegCloseKey(hk);
    }

    TCHAR szFile[MAX_PATH];
    if (SUCCEEDED(GetDropTargetPath(szFile, ARRAYSIZE(szFile), idFileName, pszExtension)))
    {
        HANDLE hfile = CreateFile(szFile, 0, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hfile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hfile);
            SHSetLocalizedName(szFile, L"sendmail.dll", idFileName);
        }
    }
}

// SHPathToAnsi creates an ANSI version of a pathname.  If there is going to be a
// loss when converting from Unicode, the short pathname is obtained and stored in the 
// destination.  
//
// pszSrc  : Source buffer containing filename (of existing file) to be converted
// pszDest : Destination buffer to receive converted ANSI string.
// cbDest  : Size of the destination buffer, in bytes.
// 
// returns:
//      TRUE, the filename was converted without change
//      FALSE, we had to convert to short name
//

BOOL SHPathToAnsi(LPCTSTR pszSrc, LPSTR pszDest, int cbDest)
{
    BOOL bUsedDefaultChar = FALSE;
   
    WideCharToMultiByte(CP_ACP, 0, pszSrc, -1, pszDest, cbDest, NULL, &bUsedDefaultChar);

    if (bUsedDefaultChar) 
    {  
        TCHAR szTemp[MAX_PATH];
        if (GetShortPathName(pszSrc, szTemp, ARRAYSIZE(szTemp)))
            SHTCharToAnsi(szTemp, pszDest, cbDest);
    }

    return !bUsedDefaultChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\cenumusers.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       EnumUsers.cpp
//
//  Contents:   implementation of CLogonEnumUsers
//
//----------------------------------------------------------------------------

#include "priv.h"

#include "resource.h"
#include "UserOM.h"
#include <lmaccess.h>   // for NetQueryDisplayInformation
#include <lmapibuf.h>   // for NetApiBufferFree
#include <lmerr.h>      // for NERR_Success

#include <sddl.h>       // for ConvertSidToStringSid
#include <userenv.h>    // for DeleteProfile
#include <aclapi.h>     // for TreeResetNamedSecurityInfo
#include <tokenutil.h>  // for CPrivilegeEnable

#include <GinaIPC.h>
#include <MSGinaExports.h>


HRESULT BackupUserData(LPCTSTR pszSid, LPTSTR pszProfilePath, LPCTSTR pszDestPath);
DWORD EnsureAdminFileAccess(LPTSTR pszPath);


//
// IUnknown Interface
//

ULONG CLogonEnumUsers::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CLogonEnumUsers::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CLogonEnumUsers::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLogonEnumUsers, IDispatch),
        QITABENT(CLogonEnumUsers, IEnumVARIANT),
        QITABENT(CLogonEnumUsers, ILogonEnumUsers),
        {0},
    };

    return QISearch(this, qit, riid, ppvObj);
}


//
// IDispatch Interface
//

STDMETHODIMP CLogonEnumUsers::GetTypeInfoCount(UINT* pctinfo)
{ 
    return CIDispatchHelper::GetTypeInfoCount(pctinfo); 
}


STDMETHODIMP CLogonEnumUsers::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    return CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo); 
}


STDMETHODIMP CLogonEnumUsers::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{ 
    return CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}


STDMETHODIMP CLogonEnumUsers::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    return CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


STDMETHODIMP CLogonEnumUsers::Next(ULONG cUsers, VARIANT* rgvar, ULONG* pcUsersFetched)
{
    UNREFERENCED_PARAMETER(cUsers);
    UNREFERENCED_PARAMETER(rgvar);

    *pcUsersFetched = 0;
    return E_NOTIMPL;
}
STDMETHODIMP CLogonEnumUsers::Skip(ULONG cUsers)
{
    UNREFERENCED_PARAMETER(cUsers);

    return E_NOTIMPL;
}
STDMETHODIMP CLogonEnumUsers::Reset()
{
    return E_NOTIMPL;
}
STDMETHODIMP CLogonEnumUsers::Clone(IEnumVARIANT** ppenum)
{
    *ppenum = 0;
    return E_NOTIMPL;
}


//
// ILogonEnumUsers Interface
//

STDMETHODIMP CLogonEnumUsers::get_Domain(BSTR* pbstr)
{
    HRESULT hr;

    if (pbstr)
    {
        *pbstr = SysAllocString(_szDomain);
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::put_Domain(BSTR bstr)
{
    HRESULT hr;

    if (bstr)
    {
        hr = StringCchCopy(_szDomain, ARRAYSIZE(_szDomain), bstr);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::get_EnumFlags(ILUEORDER* porder)
{
    HRESULT hr;

    if (porder)
    {
        *porder = _enumorder;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::put_EnumFlags(ILUEORDER order)
{
    _enumorder = order;

    return S_OK;
}

STDMETHODIMP CLogonEnumUsers::get_currentUser(ILogonUser** ppLogonUserInfo)
{
    HRESULT hr = E_FAIL;

    *ppLogonUserInfo = NULL;
    if (ppLogonUserInfo)
    {
        WCHAR wszUsername[UNLEN+1];
        DWORD cch = UNLEN;

        if (GetUserNameW(wszUsername, &cch))
        {
            hr = _GetUserByName(wszUsername, ppLogonUserInfo);
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::get_length(UINT* pcUsers)
{
    HRESULT hr;

    if (!_hdpaUsers)
    {
        // need to go enumerate all of the users
        hr = _EnumerateUsers();
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "CLogonEnumUsers::get_length: failed to create _hdpaUsers!");
            return hr;
        }
    }

    if (pcUsers)
    {
        *pcUsers = (UINT)DPA_GetPtrCount(_hdpaUsers);
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::item(VARIANT varUserID, ILogonUser** ppLogonUserInfo)
{
    HRESULT hr = S_FALSE;
    
    *ppLogonUserInfo = NULL;

    if (varUserID.vt == (VT_BYREF | VT_VARIANT) && varUserID.pvarVal)
    {
        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        varUserID = *(varUserID.pvarVal);
    }

    switch (varUserID.vt)
    {
        case VT_ERROR:
            // BUGBUG (reinerf) - what do we do here??
            hr = E_INVALIDARG;
            break;

        case VT_I2:
            varUserID.lVal = (long)varUserID.iVal;
            // fall through...
        case VT_I4:
            hr = _GetUserByIndex(varUserID.lVal, ppLogonUserInfo);
            break;
        case VT_BSTR:
            hr = _GetUserByName(varUserID.bstrVal, ppLogonUserInfo);
            break;
        default:
            hr = E_NOTIMPL;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::_NewEnum(IUnknown** ppunk)
{
    return QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
}


STDMETHODIMP CLogonEnumUsers::create(BSTR bstrLoginName, ILogonUser **ppLogonUser)
{
    HRESULT hr = E_FAIL;

    if (bstrLoginName && *bstrLoginName)
    {
        NET_API_STATUS nasRet;
        USER_INFO_1 usri1 = {0};

        usri1.usri1_name     = bstrLoginName;
        usri1.usri1_priv     = USER_PRIV_USER;
        usri1.usri1_flags    = UF_NORMAL_ACCOUNT | UF_SCRIPT | UF_DONT_EXPIRE_PASSWD;

        nasRet = NetUserAdd(NULL,           // local computer
                            1,              // structure level
                            (LPBYTE)&usri1, // user infomarmation
                            NULL);          // don't care

        if (nasRet == NERR_PasswordTooShort)
        {
            // Password policy is in effect. Set UF_PASSWD_NOTREQD so we can
            // create the account with no password, and remove
            // UF_DONT_EXPIRE_PASSWD.
            //
            // We will then expire the password below, to force the user to
            // change it at first logon.

            usri1.usri1_flags = (usri1.usri1_flags & ~UF_DONT_EXPIRE_PASSWD) | UF_PASSWD_NOTREQD;
            nasRet = NetUserAdd(NULL,           // local computer
                                1,              // structure level
                                (LPBYTE)&usri1, // user infomarmation
                                NULL);          // don't care
        }

        if (nasRet == NERR_Success)
        {
            TCHAR szDomainAndName[256];
            LOCALGROUP_MEMBERS_INFO_3 lgrmi3;

            hr = StringCchPrintf(szDomainAndName, 
                                 ARRAYSIZE(szDomainAndName), 
                                 TEXT("%s\\%s"),
                                 _szDomain,
                                 bstrLoginName);
            if (SUCCEEDED(hr))
            {
                lgrmi3.lgrmi3_domainandname = szDomainAndName;

                // by default newly created accounts will be child accounts

                nasRet = NetLocalGroupAddMembers(
                            NULL,
                            TEXT("Users"),
                            3,
                            (LPBYTE)&lgrmi3,
                            1);

                if (usri1.usri1_flags & UF_PASSWD_NOTREQD)
                {
                    // Expire the password to force the user to change it at
                    // first logon.

                    PUSER_INFO_4 pusri4;
                    nasRet = NetUserGetInfo(NULL, bstrLoginName, 4, (LPBYTE*)&pusri4);
                    if (nasRet == NERR_Success)
                    {
                        pusri4->usri4_password_expired = TRUE;
                        nasRet = NetUserSetInfo(NULL, bstrLoginName, 4, (LPBYTE)pusri4, NULL);
                        NetApiBufferFree(pusri4);
                    }
                }

                if ( SUCCEEDED(CLogonUser::Create(bstrLoginName, TEXT(""), _szDomain, IID_ILogonUser, (LPVOID*)ppLogonUser)) )
                {
                    if ( _hdpaUsers && DPA_AppendPtr(_hdpaUsers, *ppLogonUser) != -1 )
                    {
                        (*ppLogonUser)->AddRef();
                    }
                    else
                    {
                        // Invalidate the cached user infomation forcing
                        // a reenumeration the next time a client uses
                        // this object
                        _DestroyHDPAUsers();
                    }
                    hr = S_OK;
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(nasRet);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT _BuildBackupPath(ILogonUser *pLogonUser, LPCWSTR pszLoginName, LPCWSTR pszDir, LPWSTR szPath)
{
    HRESULT hr;
    WCHAR szName[MAX_PATH];
    VARIANT varDisplayName = {0};

    szName[0] = L'\0';

    pLogonUser->get_setting(L"DisplayName", &varDisplayName);

    if ((varDisplayName.vt == VT_BSTR) && varDisplayName.bstrVal && *varDisplayName.bstrVal)
    {
        hr = StringCchCopyW(szName, ARRAYSIZE(szName), varDisplayName.bstrVal);
    }
    else
    {
        hr = StringCchCopyW(szName, ARRAYSIZE(szName), pszLoginName);
    }

    if (FAILED(hr)                                                          ||
        (PathCleanupSpec(pszDir, szName) & (PCS_PATHTOOLONG | PCS_FATAL))   ||
        (szName[0] == L'\0'))
    {
        if (LoadStringW(HINST_THISDLL, IDS_DEFAULT_BACKUP_PATH, szName, ARRAYSIZE(szName)))
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!PathCombineW(szPath, pszDir, szName))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::remove(VARIANT varUserId, VARIANT varBackupPath, VARIANT_BOOL *pbSuccess)
{
    HRESULT hr;
    ILogonUser *pLogonUser;

    // TODO: Check for multi-session. If the user is logged on,
    // forcibly log them off.

    *pbSuccess = VARIANT_FALSE;
    hr = S_FALSE;
    pLogonUser = NULL;

    if (IsUserAnAdmin() &&
        SUCCEEDED(item(varUserId, &pLogonUser)))
    {
        HRESULT         hrSid;
        NET_API_STATUS  nasRet;
        VARIANT         varLoginName = {0};
        VARIANT         varStringSid = {0};

        pLogonUser->get_setting(L"LoginName", &varLoginName);
        hrSid = pLogonUser->get_setting(L"SID", &varStringSid);

        ASSERT(varLoginName.vt == VT_BSTR);

        if (SUCCEEDED(hrSid))
        {
            TCHAR szKey[MAX_PATH];
            TCHAR szProfilePath[MAX_PATH];

            szProfilePath[0] = TEXT('\0');

            // First, get the profile path
            DWORD dwSize = sizeof(szProfilePath);

            if (SUCCEEDED(StringCchCopy(szKey,
                                        ARRAYSIZE(szKey),
                                        TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\")))    &&
                SUCCEEDED(StringCchCat(szKey,
                                       ARRAYSIZE(szKey),
                                       varStringSid.bstrVal))                                                       &&
                (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                             szKey,
                                             TEXT("ProfileImagePath"),
                                             NULL,
                                             szProfilePath,
                                             &dwSize)))
            {
                // Reset ACLs on the profile so we can backup files and
                // later delete the profile.
                EnsureAdminFileAccess(szProfilePath);

                // Backup the user's files, if requested
                if (varBackupPath.vt == VT_BSTR && varBackupPath.bstrVal && *varBackupPath.bstrVal)
                {
                    WCHAR szPath[MAX_PATH];

                    hr = _BuildBackupPath(pLogonUser, varLoginName.bstrVal, varBackupPath.bstrVal, szPath);
                    if (SUCCEEDED(hr))
                    {
                        ASSERT(varStringSid.vt == VT_BSTR);
                        hr = BackupUserData(varStringSid.bstrVal, szProfilePath, szPath);
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            nasRet = NetUserDel(NULL, varLoginName.bstrVal);

            // NERR_UserNotFound can happen if the account was deleted via
            // some other mechanism (e.g. lusrmgr.msc). However, we know
            // that the account existed recently, so try to clean up the
            // picture, profile, etc. and remove the user from our DPA.

            if ((nasRet == NERR_Success) || (nasRet == NERR_UserNotFound))
            {
                TCHAR szHintKey[MAX_PATH];
                int iUserIndex;

                // Delete the user's picture if it exists
                SHSetUserPicturePath(varLoginName.bstrVal, 0, NULL);

                // Delete the user's profile
                if (SUCCEEDED(hrSid))
                {
                    ASSERT(varStringSid.vt == VT_BSTR);
                    DeleteProfile(varStringSid.bstrVal, NULL, NULL);
                }

                // Delete the user's hint
                if (PathCombine(szHintKey, c_szRegRoot, varLoginName.bstrVal))
                {
                    SHDeleteKey(HKEY_LOCAL_MACHINE, szHintKey);
                }

                // Indicate success
                *pbSuccess = VARIANT_TRUE;
                hr = S_OK;

                // Patch up the list of users
                iUserIndex = DPA_GetPtrIndex(_hdpaUsers, pLogonUser);
                if ( iUserIndex != -1 )
                {
                    // Release ref held by DPA and remove from DPA
                    pLogonUser->Release();
                    DPA_DeletePtr(_hdpaUsers, iUserIndex);
                }
                else
                {
                    // Invalidate the cached user infomation forcing
                    // a reenumeration the next time a client uses
                    // this object
                    _DestroyHDPAUsers();
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(nasRet);
            }
        }

        pLogonUser->Release();

        SysFreeString(varLoginName.bstrVal);
        SysFreeString(varStringSid.bstrVal);
    }

    return hr;
}


HRESULT CLogonEnumUsers::_GetUserByName(BSTR bstrLoginName, ILogonUser** ppLogonUserInfo)
{
    HRESULT    hr;
    INT        cUsers, cRet;
    ILogonUser *pLogonUser;
    VARIANT    varLoginName;
    int        i;

    if (!_hdpaUsers)
    {
        // need to go enumerate all of the users.
        hr = _EnumerateUsers();
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "CLogonEnumUsers::get_length: failed to create _hdpaUsers!");
            return hr;
        }
    }

    cUsers = DPA_GetPtrCount(_hdpaUsers);
    hr = E_INVALIDARG;
    for (i = 0; i < cUsers; i++)
    {
        pLogonUser = (ILogonUser*)DPA_FastGetPtr(_hdpaUsers, i);
        pLogonUser->get_setting(L"LoginName", &varLoginName);

        ASSERT(varLoginName.vt == VT_BSTR);
        cRet = StrCmpW(bstrLoginName, varLoginName.bstrVal);
        SysFreeString(varLoginName.bstrVal);

        if ( cRet == 0 )
        {
            *ppLogonUserInfo = pLogonUser;
            (*ppLogonUserInfo)->AddRef();
            hr = S_OK;
            break;
        }

    }

    return hr;
}


HRESULT CLogonEnumUsers::_GetUserByIndex(LONG lUserID, ILogonUser** ppLogonUserInfo)
{
    HRESULT hr;
    int cUsers;

    *ppLogonUserInfo = NULL;

    if (!_hdpaUsers)
    {
        // need to go enumerate all of the users.
        hr = _EnumerateUsers();
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "CLogonEnumUsers::get_length: failed to create _hdpaUsers!");
            return hr;
        }
    }

    cUsers = DPA_GetPtrCount(_hdpaUsers);

    if ((cUsers > 0) && (lUserID >= 0) && (lUserID < cUsers))
    {
        *ppLogonUserInfo = (ILogonUser*)DPA_FastGetPtr(_hdpaUsers, lUserID);
        (*ppLogonUserInfo)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDAPI_(int) ReleaseLogonUserCallback(LPVOID pData1, LPVOID pData2)
{
    UNREFERENCED_PARAMETER(pData2);

    ILogonUser* pUser = (ILogonUser*)pData1;
    pUser->Release();

    return 1;
}


void CLogonEnumUsers::_DestroyHDPAUsers()
{
    HDPA hdpaToFree = (HDPA)InterlockedExchangePointer(reinterpret_cast<void**>(&_hdpaUsers), NULL);

    if (hdpaToFree)
    {
        DPA_DestroyCallback(hdpaToFree, ReleaseLogonUserCallback, 0);
    }
}

// creates the _hdpaUsers for each user on the system 
HRESULT CLogonEnumUsers::_EnumerateUsers()
{
    HRESULT hr = S_FALSE;
    NET_API_STATUS nasRet;
    GINA_USER_INFORMATION* pgui = NULL;
    DWORD dwEntriesRead = 0;

    nasRet = ShellGetUserList(FALSE,                               // don't remove Guest
                              &dwEntriesRead,
                              (LPVOID*)&pgui);
    if ((nasRet == NERR_Success) || (nasRet == ERROR_MORE_DATA))
    {
        if (_hdpaUsers)
        {
            // we have an old data in the dpa and we should dump it and start over
            _DestroyHDPAUsers();
        }

        // create a dpa with spaces for all of the users
        _hdpaUsers = DPA_Create(dwEntriesRead);

        if (_hdpaUsers)
        {
            if (dwEntriesRead != 0)
            {
                GINA_USER_INFORMATION* pguiCurrent;
                UINT uEntry;

                // cycle through and add each user to the hdpa
                for (uEntry = 0, pguiCurrent = pgui; uEntry < dwEntriesRead; uEntry++, pguiCurrent++)
                {
                    CLogonUser* pUser;

                    if (pguiCurrent->dwFlags & UF_ACCOUNTDISABLE)
                    {
                        // skip users whos account is disabled
                        continue;
                    }

                    if (SUCCEEDED(CLogonUser::Create(pguiCurrent->pszName, pguiCurrent->pszFullName, pguiCurrent->pszDomain, IID_ILogonUser, (void**)&pUser)))
                    {
                        ASSERT(pUser);

                        if (DPA_AppendPtr(_hdpaUsers, pUser) != -1)
                        {
                            // success! we added this user to the hdpa
                            hr = S_OK;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "CLogonEnumUsers::_EnumerateUsers: failed to add new user to the DPA!");
                            pUser->Release();
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (pgui != NULL)
        {
            LocalFree(pgui);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "CLogonEnumUsers::_EnumerateUsers: NetQueryDisplayInformation failed!!");
        hr = E_FAIL;
    }

    return hr;
}


CLogonEnumUsers::CLogonEnumUsers() : _cRef(1), CIDispatchHelper(&IID_ILogonEnumUsers, &LIBID_SHGINALib)
{
    DllAddRef();
}


CLogonEnumUsers::~CLogonEnumUsers()
{
    ASSERT(_cRef == 0);
    _DestroyHDPAUsers();
    DllRelease();
}


STDAPI CLogonEnumUsers_Create(REFIID riid, LPVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CLogonEnumUsers* pEnumUsers = new CLogonEnumUsers;

    if (pEnumUsers)
    {
        hr = pEnumUsers->QueryInterface(riid, ppv);
        pEnumUsers->Release();
    }

    return hr;
}

DWORD LoadHive(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszHive)
{
    DWORD dwErr;
    BOOLEAN bWasEnabled;
    NTSTATUS status;

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);

    if (NT_SUCCESS(status))
    {
        dwErr = RegLoadKey(hKey, pszSubKey, pszHive);

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    }
    else
    {
        dwErr = RtlNtStatusToDosError(status);
    }

    return dwErr;
}

DWORD UnloadHive(HKEY hKey, LPCTSTR pszSubKey)
{
    DWORD dwErr;
    BOOLEAN bWasEnabled;
    NTSTATUS status;

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);

    if ( NT_SUCCESS(status) )
    {
        dwErr = RegUnLoadKey(hKey, pszSubKey);

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    }
    else
    {
        dwErr = RtlNtStatusToDosError(status);
    }

    return dwErr;
}

void DeleteFilesInTree(LPCTSTR pszDir, LPCTSTR pszFilter)
{
    TCHAR szPath[MAX_PATH];
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    // This is best effort only. All errors are ignored
    // and no error or success code is returned.

    // Look for files matching the filter and delete them
    if (PathCombine(szPath, pszDir, pszFilter))
    {
        hFind = FindFirstFileEx(szPath, FindExInfoStandard, &fd, FindExSearchNameMatch, NULL, 0);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    if (PathCombine(szPath, pszDir, fd.cFileName))
                    {
                        DeleteFile(szPath);
                    }
                }
            }
            while (FindNextFile(hFind, &fd));

            FindClose(hFind);
        }
    }

    // Look for subdirectories and recurse into them
    if (PathCombine(szPath, pszDir, TEXT("*")))
    {
        hFind = FindFirstFileEx(szPath,
                                FindExInfoStandard,
                                &fd,
                                FindExSearchLimitToDirectories,
                                NULL,
                                0);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            do
            {
                if (PathIsDotOrDotDot(fd.cFileName))
                {
                    continue;
                }

                // FindExSearchLimitToDirectories is only an advisory flag,
                // so need to check for FILE_ATTRIBUTE_DIRECTORY here.
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                {
                    if (PathCombine(szPath, pszDir, fd.cFileName))
                    {
                        DeleteFilesInTree(szPath, pszFilter);
                    }

                    // Expect this to fail if the dir is non-empty
                    RemoveDirectory(szPath);
                }
            }
            while (FindNextFile(hFind, &fd));

            FindClose(hFind);
        }
    }
}

BOOL
_PathIsEqualOrSubFolder(
    LPTSTR pszParent,
    LPCTSTR pszSubFolder
    )
{
    TCHAR szCommon[MAX_PATH];

    //  PathCommonPrefix() always removes the slash on common
    return (pszParent[0] && PathRemoveBackslash(pszParent)
            && PathCommonPrefix(pszParent, pszSubFolder, szCommon)
            && lstrcmpi(pszParent, szCommon) == 0);
}

HRESULT BackupUserData(LPCTSTR pszSid, LPTSTR pszProfilePath, LPCTSTR pszDestPath)
{
    DWORD dwErr;
    TCHAR szHive[MAX_PATH];

    // We will copy these special folders
    const LPCTSTR aValueNames[] = 
    {
        TEXT("Desktop"),
        TEXT("Personal"),
        TEXT("My Pictures") // must come after Personal
    };

    if ( pszSid == NULL || *pszSid == TEXT('\0') ||
         pszProfilePath == NULL || *pszProfilePath == TEXT('\0') ||
         pszDestPath == NULL || *pszDestPath == TEXT('\0') )
    {
        return E_INVALIDARG;
    }

    // Before we do anything else, make sure the destination directory
    // exists. Create this even if we don't copy any files below, so the
    // user sees that something happened.
    dwErr = SHCreateDirectoryEx(NULL, pszDestPath, NULL);

    if ( dwErr == ERROR_FILE_EXISTS || dwErr == ERROR_ALREADY_EXISTS )
        dwErr = ERROR_SUCCESS;

    if ( dwErr != ERROR_SUCCESS )
        return dwErr;

    // Load the user's hive
    if (PathCombine(szHive, pszProfilePath, TEXT("ntuser.dat")))
    {
        dwErr = LoadHive(HKEY_USERS, pszSid, szHive);
    }
    else
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
    }

    if ( dwErr == ERROR_SUCCESS )
    {
        HKEY hkShellFolders = NULL;
        TCHAR szKey[MAX_PATH];

        // Open the Shell Folders key for the user. We use "Shell Folders"
        // here rather than "User Shell Folders" so we don't have to expand
        // ENV strings for the user (we don't have a token).
        //
        // The only way Shell Folders can be out of date is if someone
        // changed User Shell Folders since the last time the target user
        // logged on, and didn't subsequently call SHGetFolderPath. This
        // is a very small risk, but it's possible.
        //
        // If we encounter problems here, then we will need to build a
        // pseudo-environment block for the user containing USERNAME and
        // USERPROFILE (at least) so we can switch to User Shell Folders
        // and do the ENV substitution.

        if (SUCCEEDED(StringCchCopy(szKey, ARRAYSIZE(szKey), pszSid))    &&
            SUCCEEDED(StringCchCat(szKey,
                                   ARRAYSIZE(szKey),
                                   TEXT("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"))))
        {
            dwErr = RegOpenKeyEx(HKEY_USERS,
                                 szKey,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hkShellFolders);
        }
        else
        {
            dwErr == ERROR_INSUFFICIENT_BUFFER;
        }

        if ( dwErr == ERROR_SUCCESS )
        {
            LPTSTR pszFrom;
            LPTSTR pszTo;

            // Allocate 2 buffers for double-NULL terminated lists of paths.
            // Note that the buffers have 1 extra char (compared to cchFrom
            // and cchTo below) and are zero-inited. This extra char ensures
            // that the list is double-NULL terminated.

            pszFrom = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH+ 1) * ARRAYSIZE(aValueNames) * sizeof(TCHAR));
            pszTo = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * ARRAYSIZE(aValueNames) * sizeof(TCHAR));

            if (pszFrom && pszTo)
            {
                int i;

                // Get each source directory from the registry, build
                // a corresponding destination path, and add the paths
                // to the lists for SHFileOperation.

                for (i = 0; i < ARRAYSIZE(aValueNames); i++)
                {
                    // Copy the source path directly into the list
                    DWORD dwSize = MAX_PATH * sizeof(TCHAR);    // we allocated enough room for each string to be MAX_PATH above
                    dwErr = RegQueryValueEx(hkShellFolders,
                                            aValueNames[i],
                                            NULL,
                                            NULL,
                                            (LPBYTE)pszFrom,
                                            &dwSize);

                    if (dwErr == ERROR_SUCCESS)
                    {
                        if (!_PathIsEqualOrSubFolder(pszProfilePath, pszFrom))
                        {
                            // We only move folders underneath the profile path. The reason for this is
                            // two fold - first only the profile path will be deleted when the users profile
                            // is deleted, and second a malicious user could point their mydocs at c:\ and
                            // this code would be run as an administrator and we would go and try to move/delete
                            // the contents of the whole drive
                            continue;
                        }
                
                        // Build a destination path with the same
                        // leaf name as the source.
                        PathRemoveBackslash(pszFrom);
                        
                        LPCTSTR pszDir = PathFindFileName(pszFrom);
                        if (PathIsFileSpec(pszDir) &&
                            PathCombine(pszTo, pszDestPath, pszDir))
                        {
                            // we sucessfully have the pszFrom->pszTo mapping for this regkey
                            pszFrom += lstrlen(pszFrom) + 1;
                            pszTo += lstrlen(pszTo) + 1;
                        }
                    }
                }

                // Did we find anything?
                if ((*pszFrom != TEXT('\0') && (*pszTo != TEXT('\0'))))
                {
                    SHFILEOPSTRUCT fo = {0};

                    fo.hwnd = NULL;
                    fo.wFunc = FO_MOVE;
                    fo.pFrom = pszFrom;  // should already be double-null terminated (was alloced w/ zero init)
                    fo.pTo = pszTo;      // should already be double-null terminated (was alloced w/ zero init)
                    fo.fFlags = FOF_MULTIDESTFILES          |
                                FOF_NOCONFIRMATION          |
                                FOF_NOCONFIRMMKDIR          |
                                FOF_NOCOPYSECURITYATTRIBS   |
                                FOF_NOERRORUI               |
                                FOF_RENAMEONCOLLISION;

                    // Move everything in one shot
                    dwErr = SHFileOperation(&fo);

                    // We get ERROR_CANCELLED when My Pictures is contained
                    // within My Documents, which is the normal case. In this
                    // case My Pictures is moved along with My Documents and
                    // doesn't exist any more in the source location when the
                    // copy engine gets around to moving My Pictures.
                    //
                    // We have to continue to specify My Pictures separately
                    // to account for any cases where it is not contained
                    // in My Documents, even though that's relatively rare.
                    //
                    // Note that putting My Pictures ahead of Personal in
                    // aValueNames above would avoid the error, but My Pictures
                    // would no longer be under My Documents after the move.
                    if (dwErr == ERROR_CANCELLED)
                    {
                        dwErr = ERROR_SUCCESS;
                    }

                    if (dwErr == ERROR_SUCCESS)
                    {
                        // Now go back and delete stuff we didn't really
                        // want (i.e. shortcut files)
                        DeleteFilesInTree(pszDestPath, TEXT("*.lnk"));
                    }
                }
            }
            else
            {
                dwErr = ERROR_OUTOFMEMORY;
            }

            if (pszFrom != NULL)
            {
                LocalFree(pszFrom);
            }

            if (pszTo != NULL)
            {
                LocalFree(pszTo);
            }

            // Close the Shell Folders key
            RegCloseKey(hkShellFolders);
        }

        // Unload the hive
        UnloadHive(HKEY_USERS, pszSid);
    }

    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        // Something was missing, possibly the entire profile (e.g. if the
        // user had never logged on), or possibly just one of the Shell Folders
        // reg values. It just means there was less work to do.
        dwErr = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(dwErr);
}


BOOL _SetFileSecurityUsingNTName(LPWSTR pObjectName,
                                 PSECURITY_DESCRIPTOR pSD,
                                 PBOOL pbIsFile)
{
    NTSTATUS Status;
    UNICODE_STRING usFileName;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE hFile = NULL;

    Status = RtlInitUnicodeStringEx(&usFileName, pObjectName);
    if (NT_SUCCESS(Status))
    {
        InitializeObjectAttributes(&Obja,
                                   &usFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenFile(&hFile,
                            WRITE_DAC,
                            &Obja,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            FILE_OPEN_REPARSE_POINT);

        if (Status == STATUS_INVALID_PARAMETER)
        {
            Status = NtOpenFile(&hFile,
                                WRITE_DAC,
                                &Obja,
                                &IoStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                0);
        }

        if (NT_SUCCESS(Status))
        {
            if (!SetKernelObjectSecurity(hFile,
                                         DACL_SECURITY_INFORMATION,
                                         pSD))
            {
                Status = RtlGetLastNtStatus();

                // We successfully opened for WRITE_DAC access, so this shouldn't fail
                ASSERT(FALSE);
            }

            NtClose(hFile);
        }

        if (NT_SUCCESS(Status))
        {
            //
            // That worked. Now open the file again and read attributes, to see
            // if it's a file or directory.  Default to File if this fails.
            // See comments in _TreeResetCallback below.
            //
            *pbIsFile = TRUE;

            if (NT_SUCCESS(NtOpenFile(&hFile,
                                      FILE_GENERIC_READ,
                                      &Obja,
                                      &IoStatusBlock,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                      0)))
            {
                //
                // Query the attributes for the file/dir.
                //
                FILE_BASIC_INFORMATION BasicFileInfo;

                if (NT_SUCCESS(NtQueryInformationFile(hFile,
                                                      &IoStatusBlock,
                                                      &BasicFileInfo,
                                                      sizeof(BasicFileInfo),
                                                      FileBasicInformation)))
                {
                    if (BasicFileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        *pbIsFile = FALSE;
                    }
                }

                NtClose(hFile);
            }
        }
    }

    return NT_SUCCESS(Status);
}


void _TreeResetCallback(LPWSTR               pObjectName,
                        DWORD                status,
                        PPROG_INVOKE_SETTING pInvokeSetting,
                        PVOID                pContext,
                        BOOL                 bSecuritySet)
{
    BOOL bIsFile = TRUE;

    // Default is "continue"
    *pInvokeSetting = ProgressInvokeEveryObject;

    // Stamp the permissions on this object
    _SetFileSecurityUsingNTName(pObjectName, (PSECURITY_DESCRIPTOR)pContext, &bIsFile);

    //
    // bSecuritySet = TRUE means TreeResetNamedSecurityInfo set the owner.
    //
    // status != ERROR_SUCCESS means it couldn't enumerate the child.
    //
    // If it's not a file, retry the operation (with no access initially,
    // TreeResetNamedSecurityInfo can't get attributes and tries to
    // enumerate everything as if it's a directory).
    //
    // Have to be careful to avoid infinite loops here. Basically, we assume
    // everything is a file. If we can grant ourselves access above, we get
    // good attributes and do the right thing. If not, we skip the retry.
    //
    if (bSecuritySet                &&
        (status != ERROR_SUCCESS)   &&
        !bIsFile)
    {
        *pInvokeSetting = ProgressRetryOperation;
    }
}


DWORD EnsureAdminFileAccess(LPTSTR pszPath)
{
    DWORD dwErr;
    PSECURITY_DESCRIPTOR pSD;

    const TCHAR c_szAdminSD[] = TEXT("O:BAG:BAD:(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)");

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(c_szAdminSD, SDDL_REVISION_1, &pSD, NULL))
    {
        PSID pOwner = NULL;
        BOOL bDefault;

        CPrivilegeEnable privilege(SE_TAKE_OWNERSHIP_NAME);

        GetSecurityDescriptorOwner(pSD, &pOwner, &bDefault);

        //
        // When the current user doesn't have any access, we have to do things
        // in the correct order. For each file or directory in the tree,
        // 1. Take ownership, this gives us permission to...
        // 2. Set permissions, this gives us permission to...
        // 3. See if it is a directory, and recurse into it
        //
        // TreeResetNamedSecurityInfo doesn't quite work that way, so we use
        // it to set the owner and do the enumeration.  The callback sets
        // the permissions, and tells TreeResetNamedSecurityInfo to retry
        // the enumeration if necessary.
        //
        dwErr = TreeResetNamedSecurityInfo(pszPath,
                                           SE_FILE_OBJECT,
                                           OWNER_SECURITY_INFORMATION,
                                           pOwner,
                                           NULL,
                                           NULL,
                                           NULL,
                                           FALSE,
                                           _TreeResetCallback,
                                           ProgressInvokeEveryObject,
                                           pSD);

        LocalFree(pSD);
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shfolder\folder.c ===
#define _SHFOLDER_
#define NO_SHLWAPI_PATH

#include <windows.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <shfolder.h>
#include <platform.h>
#include <strsafe.h>

#include "resource.h"

#ifdef DBG
#define ASSERT(x) if (!(x)) DebugBreak();
#else
#define ASSERT(x)
#endif

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

// We can't rely on shlwapi SHUnicodeToAnsi/SHAnsiToUnicode in this module
#define SHAnsiToUnicode(psz, pwsz, cchwsz)  MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, psz, -1, pwsz, cchwsz)
#define SHUnicodeToAnsi _SHUnicodeToAnsi


//
// Global array of static system SIDs, corresponding to UI_SystemSid
//
struct
{
    SID sid;                // contains 1 subauthority
    DWORD dwSubAuth[1];     // we currently need at most 2 subauthorities
}
c_StaticSids[] =
{
    {{SID_REVISION, 1, SECURITY_CREATOR_SID_AUTHORITY, {SECURITY_CREATOR_OWNER_RID}},      {0}                             },
    {{SID_REVISION, 1, SECURITY_NT_AUTHORITY,          {SECURITY_AUTHENTICATED_USER_RID}}, {0}                             },
    {{SID_REVISION, 1, SECURITY_NT_AUTHORITY,          {SECURITY_LOCAL_SYSTEM_RID}},       {0}                             },
    {{SID_REVISION, 2, SECURITY_NT_AUTHORITY,          {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_ADMINS}       },
    {{SID_REVISION, 2, SECURITY_NT_AUTHORITY,          {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_POWER_USERS}  },
};

#define SSI_CREATOROWNER    0
#define SSI_AUTHUSER        1
#define SSI_SYSTEM          2
#define SSI_ADMIN           3
#define SSI_POWERUSER       4

typedef struct tagACEPARAMLIST
{
    DWORD dwSidIndex;
    DWORD AccessMask;
    DWORD dwAceFlags;
}
ACEPARAMLIST;

#define ACE_INHERIT         (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE)
#define FILE_MODIFY         (FILE_ALL_ACCESS & ~(WRITE_DAC | WRITE_OWNER))

const ACEPARAMLIST c_paplUnsecure[] =
{
    SSI_SYSTEM,         FILE_ALL_ACCESS,    0,
    SSI_SYSTEM,         GENERIC_ALL,        ACE_INHERIT,
    SSI_AUTHUSER,       FILE_MODIFY,        0,
    SSI_AUTHUSER,       FILE_MODIFY,        ACE_INHERIT,
};

//
// CSIDL_COMMON_DOCUMENTS
// Admins, System, Creator Owner: Full Control - Container Inherit, Object Inherit
// Users, Power Users: Read - Container Inherit, Object Inherit
// Users, Power Users: Write - Container Inherit
//
// Non admin users can create files and directories. They have full control over 
// the files they create. All other users can read those files by default, but 
// they cannot modify the files unless the original creator gives them explicit 
// permissions to do so.
//

const ACEPARAMLIST c_paplCommonDocs[] =
{
    SSI_SYSTEM,         FILE_ALL_ACCESS,    0,
    SSI_SYSTEM,         GENERIC_ALL,        ACE_INHERIT,
    SSI_ADMIN,          FILE_ALL_ACCESS,    0,
    SSI_ADMIN,          GENERIC_ALL,        ACE_INHERIT,
    SSI_CREATOROWNER,   GENERIC_ALL,        ACE_INHERIT,
    SSI_AUTHUSER,       FILE_GENERIC_READ,  0,
    SSI_AUTHUSER,       GENERIC_READ,       ACE_INHERIT,
    SSI_AUTHUSER,       FILE_GENERIC_WRITE, 0,
    SSI_AUTHUSER,       GENERIC_WRITE,      (CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE),
    SSI_POWERUSER,      FILE_GENERIC_READ,  0,
    SSI_POWERUSER,      GENERIC_READ,       ACE_INHERIT,
    SSI_POWERUSER,      FILE_GENERIC_WRITE, 0,
    SSI_POWERUSER,      GENERIC_WRITE,      (CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE),
};

//
// CSIDL_COMMON_APPDATA
// Admins, System, Creator Owner: Full Control - Container Inherit, Object Inherit
// Power Users: Modify - Container Inherit, Object Inherit
// Users: Read - Container Inherit, Object Inherit
//
// Users can only read common appdata which is presumably created by admins or 
// power users during setup.
//

const ACEPARAMLIST c_paplCommonAppData[] =
{
    SSI_SYSTEM,         FILE_ALL_ACCESS,    0,
    SSI_SYSTEM,         GENERIC_ALL,        ACE_INHERIT,
    SSI_ADMIN,          FILE_ALL_ACCESS,    0,
    SSI_ADMIN,          GENERIC_ALL,        ACE_INHERIT,
    SSI_CREATOROWNER,   GENERIC_ALL,        ACE_INHERIT,
    SSI_AUTHUSER,       FILE_GENERIC_READ,  0,
    SSI_AUTHUSER,       GENERIC_READ,       ACE_INHERIT,
    SSI_POWERUSER,      FILE_MODIFY,        0,
    SSI_POWERUSER,      FILE_MODIFY,        ACE_INHERIT,
};
      

long _SHUnicodeToAnsi(LPCWSTR pwsz, LPSTR psz, long cchCount)
{
    psz[0] = 0;
    return WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cchCount, 0, 0);
}

BOOL _SetDirAccess(LPCWSTR pszFile, const ACEPARAMLIST* papl, ULONG cPapl);


HINSTANCE g_hinst = NULL;

typedef void (__stdcall * PFNSHFLUSHSFCACHE)();

BOOL IsNewShlwapi(HMODULE hmod)
{
    DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hmod, "DllGetVersion");
    if (pfnGetVersion)
    {
        DLLVERSIONINFO dllinfo;
        dllinfo.cbSize = sizeof(dllinfo);
        if (pfnGetVersion(&dllinfo) == NOERROR)
        {
            return  (dllinfo.dwMajorVersion > 5) ||
                    ((dllinfo.dwMajorVersion == 5) &&
                     ((dllinfo.dwMinorVersion > 0) ||
                      ((dllinfo.dwMinorVersion == 0) &&
                       (dllinfo.dwBuildNumber > 2012))));
        }
    }
    return 0;
}

void FlushShellFolderCache()
{
    // We could link directly now, but this is a smaller delta...
    HMODULE hmod = LoadLibraryA("shlwapi.dll");
    if (hmod) 
    {
        // avoid IE5 beta1 shlwapi.dll that has an export here but
        // not what we expect
        if (IsNewShlwapi(hmod))
        {
            PFNSHFLUSHSFCACHE pfn = (PFNSHFLUSHSFCACHE)GetProcAddress(hmod, (CHAR *) MAKEINTRESOURCE(419));
            if (pfn) 
                pfn();
        }
        FreeLibrary(hmod);
    }
}

HRESULT _SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath)
{
    HRESULT hr = E_NOTIMPL;
    HMODULE hmod = LoadLibraryA("shell32.dll");
    if (hmod) 
    {
        PFNSHGETFOLDERPATHW pfn = (PFNSHGETFOLDERPATHW)GetProcAddress(hmod, "SHGetFolderPathW");
        if (pfn) 
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
        FreeLibrary(hmod);
    }
    return hr;
}

BOOL RunningOnNT()
{
    static BOOL s_fRunningOnNT = 42;
    if (s_fRunningOnNT == 42)
    {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        s_fRunningOnNT = (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);
    }
    return s_fRunningOnNT;
}


// shell32.SHGetSpecialFolderPath (175)
// undocumented API, but the only one that exists on all platforms
//
// this thunk deals with the A/W issues based on the platform as
// the export was TCHAR
//      

typedef BOOL(__stdcall * PFNSHGETSPECIALFOLDERPATH)(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);

BOOL _SHGetSpecialFolderPath(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate)
{
    BOOL bRet = FALSE;
    HMODULE hmod = LoadLibraryA("shell32.dll");
    if (hmod) 
    {
        PFNSHGETSPECIALFOLDERPATH pfn = (PFNSHGETSPECIALFOLDERPATH)GetProcAddress(hmod, (CHAR*) MAKEINTRESOURCE(175));
        if (pfn)
        {
            if (RunningOnNT())         // compute from Get
            {
                bRet = pfn(hwnd, pszPath, csidl, fCreate);
            }
            else
            {
                CHAR szPath[MAX_PATH];
                szPath[0] = 0;
                bRet = pfn(hwnd, (LPWSTR)szPath, csidl, fCreate);
                if (bRet)
                    SHAnsiToUnicode(szPath, pszPath, MAX_PATH);      // WideCharToMultiByte wrapper
            }
        }
        FreeLibrary(hmod);
    }
    return bRet;
}

BOOL GetProgramFiles(LPCWSTR pszValue, LPWSTR pszPath)
{
    HKEY hkey;
 
    DWORD cbPath = MAX_PATH;

    *pszPath = 0;
    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion", 0, KEY_QUERY_VALUE, &hkey)) 
    {
        if (RunningOnNT()) 
        {
            cbPath *= sizeof(WCHAR);
            RegQueryValueExW(hkey, pszValue, NULL, NULL, (LPBYTE) pszPath, &cbPath);
        }
        else 
        {
            CHAR szPath[MAX_PATH], szValue[64];
            szPath[0] = 0;
            _SHUnicodeToAnsi(pszValue, szValue, ARRAYSIZE(szValue));
            RegQueryValueExA(hkey, szValue, NULL, NULL, szPath, &cbPath);
            SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
        }

   
        RegCloseKey(hkey);
    }
    return (BOOL)*pszPath;
}



// get the equiv of %USERPROFILE% on both win95 and NT
//
// on Win95 without user profiles turned on this will fail
// out:
//      phkey   optional out param
//
// returns:
//      length of the profile path

UINT GetProfilePath(LPWSTR pszPath, HKEY *phkey, UINT *pcchProfile)
{
    
    if (phkey)
        *phkey = NULL;

    if (pcchProfile)
        *pcchProfile = 0;

    if (RunningOnNT()) 
    {
        ExpandEnvironmentStringsW(L"%USERPROFILE%", pszPath, MAX_PATH);
        if (pszPath[0] == L'%')
            pszPath[0] = 0;
    }
    else 
    {
        HKEY hkeyProfRec;
        LONG err;
        CHAR szProfileDir[MAX_PATH];
        szProfileDir [0] = 0;
        err = RegCreateKeyExA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation", 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE,
                                  NULL, &hkeyProfRec, NULL);
        if (err == ERROR_SUCCESS) 
        {
            DWORD cbData = sizeof(szProfileDir);
            RegQueryValueExA(hkeyProfRec, "ProfileDirectory", 0, NULL, (LPBYTE)szProfileDir, &cbData);
            if (phkey)
                *phkey = hkeyProfRec;
            else
                RegCloseKey(hkeyProfRec);
            if (pcchProfile)
                *pcchProfile = lstrlenA(szProfileDir);
            SHAnsiToUnicode(szProfileDir, pszPath, MAX_PATH);
        }
    }
    return lstrlenW(pszPath);
}

void SHGetWindowsDirectory(LPWSTR pszPath)
{
    if (RunningOnNT())
        GetWindowsDirectoryW(pszPath, MAX_PATH);
    else 
    {
        CHAR szPath[MAX_PATH];
        if (GetWindowsDirectoryA(szPath, ARRAYSIZE(szPath)-1))
            SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
    }
}

#define CH_WHACK FILENAME_SEPARATOR_W

// add a backslash to a qualified path
//
// in:
//  pszPath    path (A:, C:\foo, etc)
//
// out:
//  pszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path


STDAPI_(LPWSTR) PathAddBackslash(LPWSTR pszPath)
{
    LPWSTR pszEnd;

    // try to keep us from tromping over MAX_PATH in size.
    // if we find these cases, return NULL.  Note: We need to
    // check those places that call us to handle their GP fault
    // if they try to use the NULL!

    int ichPath = lstrlenW(pszPath);
    if (ichPath >= (MAX_PATH - 1))
        return NULL;

    pszEnd = pszPath + ichPath;

    // this is really an error, caller shouldn't pass
    // an empty string
    if (!*pszPath)
        return pszEnd;

    /* Get the end of the source directory
    */
    switch(* (pszEnd-1)) {
    case CH_WHACK:
        break;

    default:
        *pszEnd++ = CH_WHACK;
        *pszEnd = 0;
    }
    return pszEnd;
}

// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

STDAPI_(LPWSTR) PathFindFileName(LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; ++pPath) 
    {
        if ((pPath[0] == L'\\' || pPath[0] == L':' || pPath[0] == L'/')
            && pPath[1] &&  pPath[1] != L'\\'  &&   pPath[1] != L'/')
            pT = pPath + 1;
    }
    return (LPWSTR)pT;   // const -> non const
}

STDAPI_(LPWSTR) PathFindSecondFileName(LPCWSTR pPath)
{
    LPCWSTR pT, pRet = NULL;
    
    for (pT = pPath; *pPath; ++pPath) 
    {
        if ((pPath[0] == L'\\' || pPath[0] == L':' || pPath[0] == L'/')
            && pPath[1] &&  pPath[1] != L'\\'  &&   pPath[1] != L'/')
        {
            pRet = pT;    // remember last
            
            pT = pPath + 1;
        }
    }
    return (LPWSTR)pRet;   // const -> non const
}


// This function is modified in that if the string's length is 0, the null terminator is NOT copied to the buffer.

int _LoadStringExW(
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    cch = 0;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    if (hResInfo = FindResourceExW(g_hinst, (LPCWSTR)RT_STRING,
                                   (LPWSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)), wLangId))
    {
        // Load that segment.
        hStringSeg = LoadResource(g_hinst, hResInfo);

        // Lock the resource.
        if (lpsz = (LPWSTR)LockResource(hStringSeg))
        {
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)
            wID &= 0x0F;
            while (TRUE)
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }


            // Account for the NULL
            cchBufferMax--;

            // Don't copy more than the max allowed.
            if (cch > cchBufferMax)
                cch = cchBufferMax;

            // Copy the string into the buffer.
            CopyMemory(lpBuffer, lpsz, cch * sizeof(WCHAR));


            // Attach Null terminator.
            lpBuffer[cch] = 0;
        }
    }
    return cch;
}

BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCWSTR lpszType, LPCWSTR lpszName, LANGID wLangId, LPARAM lParam)
{
    *(LANGID *)lParam = wLangId;
    return FALSE;
}

BOOL CALLBACK EnumResNameProc(HINSTANCE hinst, LPCWSTR lpszType, LPCWSTR lpszName, LPARAM lParam)
{
    EnumResourceLanguagesW(hinst, lpszType, lpszName, EnumResLangProc, lParam);
    return FALSE;
}

LANGID GetShellLangId()
{
    static LANGID wShellLangID=0xffff;
    if (0xffff == wShellLangID) 
    {
        BOOL fSuccess;
        HINSTANCE hShell;
        hShell = LoadLibraryA("shell32.dll");
        if (hShell)
        {
            EnumResourceNamesW(hShell,  (LPWSTR) RT_VERSION, EnumResNameProc, (LPARAM) &wShellLangID);
            FreeLibrary(hShell);
        }
        if (0xffff == wShellLangID)
            wShellLangID = GetSystemDefaultLangID();
    }
    return wShellLangID;
}

void PathAppend(LPWSTR pszPath, LPCWSTR pszAppend)
{
    if (pszPath && pszAppend && PathAddBackslash(pszPath))
    {
        StringCchCatW(pszPath, MAX_PATH, pszAppend);
    }
}

void PathAppendResource(LPWSTR pszPath, UINT id)
{
    WCHAR sz[MAX_PATH];
    sz[0] = 0;

    if (!_LoadStringExW(id, sz, ARRAYSIZE(sz), GetShellLangId()))
    {
        _LoadStringExW(id, sz, ARRAYSIZE(sz), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
    }
    if (*sz)
    {
        PathAppend(pszPath, sz);
    }
}


const CHAR c_szUSF[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";
const CHAR c_szSF[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";

LONG RegSetStrW(HKEY hkey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    return RegSetValueExW(hkey, pszValueName, 0, REG_SZ, (LPBYTE)pszValue, (lstrlenW(pszValue) + 1) * sizeof(WCHAR));
}

LONG RegSetStrA(HKEY hkey, LPCSTR pszValueName, LPCSTR pszValue)
{
    return RegSetValueExA(hkey, pszValueName, 0, REG_SZ, (LPBYTE)pszValue, (lstrlenA(pszValue) + 1) * sizeof(CHAR));
}

void MakeFolderRoam(HKEY hkeyProfRec, LPCSTR pszName, LPCWSTR pszPath, UINT cchProfile)
{
    HKEY hSubKey;
    LONG err;
    CHAR szPath[MAX_PATH];


    ASSERT(!RunningOnNT());

    _SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));

    err = RegCreateKeyExA(hkeyProfRec, pszName, 0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_SET_VALUE, NULL, &hSubKey, NULL);
    if (err == ERROR_SUCCESS)
    {
        CHAR szDefaultPath[MAX_PATH];
        DWORD dwOne = 1;
        LPCSTR pszEnd = szPath + cchProfile + 1;

        szDefaultPath[0] = 0;
        StringCchCopy(szDefaultPath, ARRAYSIZE(szDefaultPath), "*windir");
        StringCchCat(szDefaultPath, ARRAYSIZE(szDefaultPath), szPath + cchProfile);

        RegSetStrA(hSubKey, "CentralFile", pszEnd);
        RegSetStrA(hSubKey, "LocalFile",   pszEnd);
        RegSetStrA(hSubKey, "Name",        "*.*");
        RegSetStrA(hSubKey, "DefaultDir",  szDefaultPath);

        RegSetValueExA(hSubKey, "MustBeRelative", 0, REG_DWORD, (LPBYTE)&dwOne, sizeof(dwOne));
        RegSetValueExA(hSubKey, "Default",        0, REG_DWORD, (LPBYTE)&dwOne, sizeof(dwOne));

        RegSetStrA(hSubKey, "RegKey",   c_szUSF);
        RegSetStrA(hSubKey, "RegValue", pszName);

        RegCloseKey(hSubKey);
    }
}

typedef struct _FOLDER_INFO
{
    int id;                 // CSIDL value
    HKEY hkRoot;            // per user, per machine
    UINT idsDirName;        // esource ID for directory name 
    LPCSTR pszRegValue;     // Name of reg value and ProfileReconciliation subkey
    BOOL (*pfnGetPath)(const struct _FOLDER_INFO *, LPWSTR);  // compute the path if not found
    const ACEPARAMLIST* papl;
    ULONG cApl;
}
FOLDER_INFO;


typedef struct _NT_FOLDER_INFO
{
    const FOLDER_INFO *pfi; 
    WCHAR wszRegValue[60]; // this should be long enough to hold the longest member of FOLDER_INFO.pszRegValue
}
NT_FOLDER_INFO;

BOOL DownLevelRoaming(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    HKEY hkeyProfRec;
    UINT cchProfile;
    UINT cwchProfile = GetProfilePath(pszPath, &hkeyProfRec, &cchProfile);
    if (cwchProfile)
    {
        PathAppendResource(pszPath, pfi->idsDirName);
        if (hkeyProfRec)
        {
            MakeFolderRoam(hkeyProfRec, pfi->pszRegValue, pszPath, cchProfile);
            RegCloseKey(hkeyProfRec);
        }
    }
    else
    {
        SHGetWindowsDirectory(pszPath);
        if (pfi->id == CSIDL_PERSONAL)
        {
            if (pszPath[1] == TEXT(':') &&
                pszPath[2] == TEXT('\\'))
            {
                pszPath[3] = 0; // strip to "C:\"
            }
        }
        PathAppendResource(pszPath, pfi->idsDirName);
    }

    return (BOOL)*pszPath;
}

BOOL DownLevelNonRoaming(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    UINT cchProfile = GetProfilePath(pszPath, NULL, 0);
    if (cchProfile)
    {
        PathAppendResource(pszPath, pfi->idsDirName);
    }
    else
    {
        SHGetWindowsDirectory(pszPath);
        PathAppendResource(pszPath, pfi->idsDirName);
    }

    return (BOOL)*pszPath;
}

BOOL DownLevelRelative(UINT csidl, UINT id, LPWSTR pszPath)
{
    *pszPath = 0;   // assume error

    // since this is inside MyDocs make sure MyDocs exists first (for the create call)
    if (SHGetFolderPathW(NULL, csidl | CSIDL_FLAG_CREATE, NULL, 0, pszPath) == S_OK)
    {
        PathAppendResource(pszPath, id);
    }
    return (BOOL)*pszPath;
}

// we explictly don't want the MyPics folder to roam. the reasonaing being
// that the contents of this are typically too large to give a good roaming
// experience. but of course NT4 (< SP4) still roams everyting in the profile
// dir thus this will roam on those platforms.

BOOL DownLevelMyPictures(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_PERSONAL, IDS_CSIDL_MYPICTURES, pszPath);
}

BOOL DownLevelMyMusic(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_PERSONAL, IDS_CSIDL_MYMUSIC, pszPath);
}

BOOL DownLevelAdminTools(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_PROGRAMS, IDS_CSIDL_ADMINTOOLS, pszPath);
}

BOOL DownLevelCommonAdminTools(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_COMMON_PROGRAMS, IDS_CSIDL_ADMINTOOLS, pszPath);
}

const WCHAR c_wszAllUsers[] = L"All Users"; // not localized

BOOL GetAllUsersRoot(LPWSTR pszPath)
{
    if (GetProfilePath(pszPath, NULL, 0))
    {
        // yes, non localized "All Users" per ericflo (NT4 behavior)
        LPWSTR pszFileName = PathFindFileName(pszPath);
        StringCchCopyW(pszFileName, MAX_PATH - (lstrlenW(pszPath) - lstrlenW(pszFileName)), c_wszAllUsers);
    }
    else
    {
        // Win95 case
        SHGetWindowsDirectory(pszPath); 

        // yes, non localized "All Users" per ericflo (NT4 behavior)
        PathAppend(pszPath, c_wszAllUsers);
    }
    return *pszPath;
}

BOOL DownLevelCommon(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    if (GetAllUsersRoot(pszPath))
    {
        PathAppendResource(pszPath, pfi->idsDirName);
    }
    return (BOOL)*pszPath;
}

BOOL DownLevelCommonPrograms(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    WCHAR szPath[MAX_PATH];

    if (S_OK == SHGetFolderPathW(NULL, CSIDL_PROGRAMS, NULL, 0, szPath))
    {
        if (GetAllUsersRoot(pszPath))
        {
            PathAppend(pszPath, PathFindSecondFileName(szPath));
        }
    }
    return (BOOL)*pszPath;
}


#define HKLM    HKEY_LOCAL_MACHINE
#define HKCU    HKEY_CURRENT_USER

const FOLDER_INFO c_rgFolders[] =
{
    { CSIDL_PERSONAL,           HKCU, IDS_CSIDL_PERSONAL,         "Personal",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_MYPICTURES,         HKCU, IDS_CSIDL_MYPICTURES,       "My Pictures",
            DownLevelMyPictures,        NULL,                0 },
    { CSIDL_MYMUSIC,            HKCU, IDS_CSIDL_MYMUSIC,          "My Music",
            DownLevelMyMusic,           NULL,                0 },
    { CSIDL_APPDATA,            HKCU, IDS_CSIDL_APPDATA,          "AppData",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_LOCAL_APPDATA,      HKCU, IDS_CSIDL_LOCAL_APPDATA,    "Local AppData",
            DownLevelNonRoaming,        NULL,                0 },
    { CSIDL_INTERNET_CACHE,     HKCU, IDS_CSIDL_CACHE,            "Cache",
            DownLevelNonRoaming,        NULL,                0 },
    { CSIDL_COOKIES,            HKCU, IDS_CSIDL_COOKIES,          "Cookies",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_HISTORY,            HKCU, IDS_CSIDL_HISTORY,          "History",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_ADMINTOOLS,         HKCU, IDS_CSIDL_ADMINTOOLS,       "Administrative Tools",
            DownLevelAdminTools,        NULL,                0 },
    { CSIDL_COMMON_APPDATA,     HKLM, IDS_CSIDL_APPDATA,          "Common AppData",
            DownLevelCommon,            c_paplCommonAppData, ARRAYSIZE(c_paplCommonAppData) },
    { CSIDL_COMMON_DOCUMENTS,   HKLM, IDS_CSIDL_COMMON_DOCUMENTS, "Common Documents",
            DownLevelCommon,            c_paplCommonDocs,    ARRAYSIZE(c_paplCommonDocs) },
    { CSIDL_COMMON_PROGRAMS,    HKLM, 0,                          "Common Programs",
            DownLevelCommonPrograms,    c_paplUnsecure,      ARRAYSIZE(c_paplUnsecure) },
    { CSIDL_COMMON_ADMINTOOLS,  HKLM, IDS_CSIDL_ADMINTOOLS,       "Common Administrative Tools",
            DownLevelCommonAdminTools,  c_paplUnsecure,      ARRAYSIZE(c_paplUnsecure) },
    { -1, HKCU, 0, NULL, NULL, NULL }
};


BOOL UnExpandEnvironmentString(LPCWSTR pszPath, LPCWSTR pszEnvVar, LPWSTR pszResult, UINT cchResult)
{
    DWORD nToCmp;
    WCHAR szEnvVar[MAX_PATH];
    szEnvVar[0] = 0;
    ASSERT(RunningOnNT());
    ExpandEnvironmentStringsW(pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar)); // don't count the NULL
    nToCmp = lstrlenW(szEnvVar);
   
    if (CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, nToCmp, pszPath, nToCmp) == 2) 
    {
        if (lstrlenW(pszPath) - (int)nToCmp  + lstrlenW(pszEnvVar) < (int)cchResult)
        {
            StringCchCopyW(pszResult, cchResult, pszEnvVar);
            StringCchCatW(pszResult, cchResult, pszPath + nToCmp);
            return TRUE;
        }
    }
    return FALSE;
}

const FOLDER_INFO *FindFolderInfo(int csidl)
{
    const FOLDER_INFO *pfi;
    for (pfi = c_rgFolders; pfi->id != -1; pfi++)
    {
        if (pfi->id == csidl) 
            return pfi;
    }
    return NULL;
}

BOOL _SHCreateDirectory(LPCWSTR pszPath) 
{
    if (RunningOnNT())
        return CreateDirectoryW(pszPath, NULL);
    else 
    {
        // no check for Unicode -> Ansi needed here, because we validated 
        // the path in _EnsureExistsOrCreate()
        CHAR szPath[MAX_PATH];
        _SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        return CreateDirectoryA(szPath, NULL);
    }
}


BOOL _CreateDirectoryDeep(LPCWSTR pszPath)
{
    BOOL fRet = _SHCreateDirectory(pszPath);
    if (!fRet && (lstrlenW(pszPath) < MAX_PATH))
    {
        WCHAR *pSlash, szTemp[MAX_PATH];

        // There are certain error codes that we should bail out here
        // before going through and walking up the tree...
        switch (GetLastError())
        {
        case ERROR_FILENAME_EXCED_RANGE:
        case ERROR_FILE_EXISTS:
            return FALSE;
        }

        StringCchCopyW(szTemp, ARRAYSIZE(szTemp), pszPath);
        fRet = (PathAddBackslash(szTemp) != NULL); // for the loop below
        if (fRet)
        {
            // assume we have 'X:\' to start this should even work
            // on UNC names because will will ignore the first error

            pSlash = szTemp + 3;

            // create each part of the dir in order

            while (*pSlash) 
            {
                while (*pSlash && *pSlash != CH_WHACK)
                    pSlash ++;

                if (*pSlash) 
                {
                    *pSlash = 0;    // terminate path at seperator
                    fRet = _SHCreateDirectory(szTemp);
                }
                *pSlash++ = CH_WHACK;     // put the seperator back
            }
        }
    }
    return fRet;
}

// check for
//      X:\foo
//      \\foo

BOOL PathIsFullyQualified(LPCWSTR pszPath)
{
    return pszPath[0] && pszPath[1] && 
        (pszPath[1] == ':' || (pszPath[0] == '\\' && pszPath[1] == '\\'));
}

HRESULT GetPathFromRegOrDefault(const NT_FOLDER_INFO *npfi, LPWSTR pszPath)
{
    HRESULT hr;
    HKEY hkeyUserShellFolders;
    LONG err;
    CHAR szPath[MAX_PATH];
    const FOLDER_INFO *pfi = npfi->pfi;

    szPath[0] = 0;

    err = RegCreateKeyExA(pfi->hkRoot, c_szUSF, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_QUERY_VALUE, NULL, &hkeyUserShellFolders, NULL);

    if (err == ERROR_SUCCESS)
    {
        DWORD dwType, cbData = MAX_PATH * sizeof(*pszPath);
        
        if (RunningOnNT()) 
        {
            err = RegQueryValueExW(hkeyUserShellFolders, npfi->wszRegValue, NULL, &dwType, (LPBYTE)pszPath, &cbData);
        }
        else
        {
            err = RegQueryValueExA(hkeyUserShellFolders, pfi->pszRegValue, NULL, &dwType, (LPBYTE)szPath, &cbData);
            SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
        }

        if (err == ERROR_SUCCESS && cbData)
        {
            if (dwType == REG_EXPAND_SZ)
            {
                if (RunningOnNT()) 
                {
                    WCHAR szExpand[MAX_PATH];
                    szExpand[0] = 0;
                    if (ExpandEnvironmentStringsW(pszPath, szExpand, ARRAYSIZE(szExpand)))
                    {
                        StringCchCopyW(pszPath, MAX_PATH, szExpand);
                    }
                }
                else
                {
                    CHAR szExpand[MAX_PATH];
                    szExpand[0] = 0;
                    if (ExpandEnvironmentStringsA(szPath, szExpand, ARRAYSIZE(szExpand)))
                    {
                        SHAnsiToUnicode(szExpand,  pszPath, MAX_PATH);
                    }
                }
            }
        }
        else if (pfi->pfnGetPath && pfi->pfnGetPath(pfi, pszPath))
        {
            err = ERROR_SUCCESS;

            // store results back to "User Shell Folders" on NT, but not on Win95

            if (RunningOnNT())
            {
                WCHAR szDefaultPath[MAX_PATH];
                HKEY hkeyWriteUserShellFolders;
                LONG err2;

                szDefaultPath[0] = 0;

                if (!UnExpandEnvironmentString(pszPath, L"%USERPROFILE%", szDefaultPath, ARRAYSIZE(szDefaultPath)))
                {
                    if (!UnExpandEnvironmentString(pszPath, L"%SYSTEMROOT%", szDefaultPath, ARRAYSIZE(szDefaultPath)))
                    {
                        StringCchCopyW(szDefaultPath, ARRAYSIZE(szDefaultPath), pszPath);
                    }
                }

                err2 = RegCreateKeyExA(pfi->hkRoot, c_szUSF, 0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE, NULL, &hkeyWriteUserShellFolders, NULL);

                if (err2 == ERROR_SUCCESS)
                {
                    RegSetValueExW(hkeyWriteUserShellFolders, npfi->wszRegValue, 0, REG_EXPAND_SZ, (LPBYTE)szDefaultPath, (lstrlenW(szDefaultPath) + 1) * sizeof(szDefaultPath[0]));

                    RegCloseKey(hkeyWriteUserShellFolders);
                }
            }
        }
        else
            err = ERROR_PATH_NOT_FOUND;

        // validate the returned path here
        if (err == ERROR_SUCCESS)
        {
            // expand failed (or some app messed up and did not use REG_EXPAND_SZ)
            if (*pszPath == L'%')
            {
                err = ERROR_ENVVAR_NOT_FOUND;
                *pszPath = 0;
            }
            else if (!PathIsFullyQualified(pszPath))
            {
                err = ERROR_PATH_NOT_FOUND;
                *pszPath = 0;
            }
        }

        RegCloseKey(hkeyUserShellFolders);
    }
    return HRESULT_FROM_WIN32(err);
}

HRESULT _EnsureExistsOrCreate(LPWSTR pszPath, BOOL bCreate, const ACEPARAMLIST* papl, ULONG cApl)
{
    HRESULT hr;
    DWORD dwFileAttributes;


    if (RunningOnNT()) 
        dwFileAttributes = GetFileAttributesW(pszPath);
    else 
    {
        CHAR szPath[MAX_PATH];
        if (_SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath)))
            dwFileAttributes = GetFileAttributesA(szPath);
        else
        {
            pszPath[0] = 0;
            return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
        }
    }

        
    if (dwFileAttributes == -1)
    {
        if (bCreate)
        {
            if (_CreateDirectoryDeep(pszPath))
            {
                hr = S_OK;
                if (papl && RunningOnNT())
                {
                    _SetDirAccess(pszPath, papl, cApl);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                *pszPath = 0;
            }
        }
        else
        {
            hr = S_FALSE;
            *pszPath = 0;
        }
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT _DownLevelGetFolderPath(int csidl, LPWSTR pszPath, BOOL bCreate)
{
    const FOLDER_INFO *pfi;
    HRESULT hr = E_INVALIDARG;
    
    *pszPath = 0;   // assume error
    
    pfi = FindFolderInfo(csidl);
    if (pfi)
    {
        NT_FOLDER_INFO nfi;
        nfi.pfi = pfi;
        SHAnsiToUnicode(pfi->pszRegValue, nfi.wszRegValue, ARRAYSIZE(nfi.wszRegValue));
        // get default value from "User Shell Folders"
        
        hr = GetPathFromRegOrDefault(&nfi, pszPath);
        if (SUCCEEDED(hr))
        {
            hr = _EnsureExistsOrCreate(pszPath, bCreate, pfi->papl, pfi->cApl);
            if (hr == S_OK)
            {
                HKEY hkeyShellFolders;
                LONG err;
                
                // store to "Shell Folders"
                err = RegCreateKeyExA(pfi->hkRoot, c_szSF, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_SET_VALUE, NULL, &hkeyShellFolders, NULL);

                if (err == ERROR_SUCCESS)
                {
                    if (RunningOnNT())  
                    {
                        RegSetStrW(hkeyShellFolders, nfi.wszRegValue, pszPath);
                    }
                    else 
                    {
                        CHAR szPath[MAX_PATH]; 
                        _SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
                        RegSetStrA(hkeyShellFolders, pfi->pszRegValue, szPath);
                    }
                    RegCloseKey(hkeyShellFolders);
                }
                
                FlushShellFolderCache();
            }
        }
    }
    else
    {
        if (csidl == CSIDL_WINDOWS)
        {
            SHGetWindowsDirectory(pszPath);
            hr = S_OK;
        }
        else if (csidl == CSIDL_SYSTEM)
        {
            if (RunningOnNT())
            {
                GetSystemDirectoryW(pszPath, MAX_PATH);
            }
            else 
            {
                CHAR szPath[MAX_PATH];
                szPath[0] = 0;
                GetSystemDirectoryA(szPath, ARRAYSIZE(szPath));
                SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
            }
            hr = S_OK;
        }
        else if (csidl == CSIDL_PROGRAM_FILES)
        {
            hr = GetProgramFiles(L"ProgramFilesDir", pszPath) ? S_OK : S_FALSE;
        }
        else if (csidl == CSIDL_PROGRAM_FILES_COMMON)
        {
            hr = GetProgramFiles(L"CommonFilesDir", pszPath) ? S_OK : S_FALSE;
        }
    }
    return hr;
}

// We pass csidl to _SHGetSpecialFolderPath only for NT 4 English folders
// NT bug # 60970
// NT bug # 222510
// NT bug # 221492

STDAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPath)
    {
        pszPath[0] = 0;
        hr = _SHGetFolderPath(hwnd, csidl, hToken, dwFlags, pszPath);
        if (hr == E_NOTIMPL || hr == E_INVALIDARG)
        {
            BOOL bCreate = csidl & CSIDL_FLAG_CREATE;
            csidl &= ~CSIDL_FLAG_MASK;    // strip the flags

            if (hToken || dwFlags)
                return E_INVALIDARG;

            if ((csidl < CSIDL_LOCAL_APPDATA) && _SHGetSpecialFolderPath(hwnd, pszPath, csidl, bCreate))
            {
                hr = S_OK;
            }
            else
            {
                hr = _DownLevelGetFolderPath(csidl, pszPath, bCreate);
            }
        }
    }
    return hr;
}

STDAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath)
{
    HRESULT hr = E_INVALIDARG;

    if (pszPath)
    {
        WCHAR wsz[MAX_PATH];

        pszPath[0] = 0;
        hr = SHGetFolderPathW(hwnd, csidl, NULL, 0, wsz);
        if (SUCCEEDED(hr))
        {
            if (!_SHUnicodeToAnsi(wsz, pszPath, MAX_PATH))
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
            }
        }
    }
    return hr;
}

BOOL APIENTRY DllMain(IN HANDLE hDll, IN DWORD dwReason, IN LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        g_hinst = hDll;
        break;
        
    default:
        break;
    }
    
    return TRUE;
}

BOOL _AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
{
    //
    // First verify that the SID is valid on this platform
    //
    WCHAR szName[MAX_PATH], szDomain[MAX_PATH];
    DWORD cbName = ARRAYSIZE(szName);
    DWORD cbDomain = ARRAYSIZE(szDomain);

    SID_NAME_USE snu;
    if (LookupAccountSidW(NULL, pSid, szName, &cbName, szDomain, &cbDomain, &snu))
    {
        //
        // Yes, it's valid; now add the ACE
        //
        return AddAccessAllowedAce(pAcl, dwAceRevision, AccessMask, pSid);
    }

    return FALSE;
}

BOOL _AddAces(PACL pAcl, const ACEPARAMLIST* papl, ULONG cPapl)
{
    ULONG i;
    for (i = 0; i < cPapl; i++)
    {
        PSID psid = &c_StaticSids[papl[i].dwSidIndex];

        if (_AddAccessAllowedAce(pAcl, ACL_REVISION, papl[i].AccessMask, psid))
        {
            if (papl[i].dwAceFlags)
            {
                ACE_HEADER* pAceHeader;
                if (GetAce(pAcl, i, &pAceHeader))
                {
                    pAceHeader->AceFlags |= papl[i].dwAceFlags;
                }
                else
                {
                    return FALSE;
                }
            }
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}

PACL _CreateAcl(ULONG cPapl)
{
    // Allocate space for the ACL
    DWORD cbAcl = (cPapl * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + sizeof(c_StaticSids[0])))
                  + sizeof(ACL);

    PACL pAcl = (PACL) GlobalAlloc(GPTR, cbAcl);
    if (pAcl) 
    {
        InitializeAcl(pAcl, cbAcl, ACL_REVISION);
    }

    return pAcl;
}

BOOL _SetDirAccess(LPCWSTR pszDir, const ACEPARAMLIST* papl, ULONG cPapl)
{
    BOOL bRetVal = FALSE;
    PACL pAcl;

    ASSERT(RunningOnNT());

    pAcl = _CreateAcl(cPapl);
    if (pAcl)
    {
        if (_AddAces(pAcl, papl, cPapl))
        {
            SECURITY_DESCRIPTOR sd;

            // Put together the security descriptor
            if (InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
            {
                if (SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE))
                {
                    // Set the security
                    bRetVal = SetFileSecurityW(pszDir, DACL_SECURITY_INFORMATION, &sd);
                }
            }
        }

        GlobalFree(pAcl);
    }
    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\cidispatchhelper.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CIDispatchHelper.cpp
//
//  Contents:   implementation of CIDispatchHelper class
//
//----------------------------------------------------------------------------

#include "priv.h"
#include "CIDispatchHelper.h"

#define TF_IDISPATCH 0


//
// helper function for pulling ITypeInfo out of the specified typelib
//
HRESULT CIDispatchHelper::_LoadTypeInfo(const GUID* rguidTypeLib, LCID lcid, UUID uuid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr;
    ITypeLib* pITypeLib;

    *ppITypeInfo = NULL;

    //
    // The type libraries are registered under 0 (neutral),
    // 7 (German), and 9 (English) with no specific sub-
    // language, which would make them 407 or 409 and such.
    // If you are sensitive to sub-languages, then use the
    // full LCID instead of just the LANGID as done here.
    //
    hr = LoadRegTypeLib(*rguidTypeLib, 1, 0, PRIMARYLANGID(lcid), &pITypeLib);

    //
    // If LoadRegTypeLib fails, try loading directly with
    // LoadTypeLib, which will register the library for us.
    // Note that there's no default case here because the
    // prior switch will have filtered lcid already.
    //
    // NOTE:  You should prepend your DIR registry key to the
    // .TLB name so you don't depend on it being it the PATH.
    // This sample will be updated later to reflect this.
    //
    if (FAILED(hr))
    {
        OLECHAR wszPath[MAX_PATH];
        GetModuleFileName(HINST_THISDLL, wszPath, ARRAYSIZE(wszPath));

        switch (PRIMARYLANGID(lcid))
        {
            case LANG_NEUTRAL:
            case LANG_ENGLISH:
                hr = LoadTypeLib(wszPath, &pITypeLib);
                break;
        }
    }

    if (SUCCEEDED(hr))
    {
        // got the type lib, get type info for the interface we want
        hr = pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }

    return hr;
}


//
// IDispatch Interface
// 

//
// CIDispatchHelper::GetTypeInfoCount
//
// Purpose:
//  Returns the number of type information (ITypeInfo) interfaces
//  that the object provides (0 or 1).
//
// Parameters:
//  pctInfo         UINT * to the location to receive
//                  the count of interfaces.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::GetTypeInfoCount(UINT *pctInfo)
{
    // we implement GetTypeInfo so return 1
    *pctInfo = 1;

    return NOERROR;
}


//
// CIDispatchHelper::GetTypeInfo
//
// Purpose:
//  Retrieves type information for the automation interface.  This
//  is used anywhere that the right ITypeInfo interface is needed
//  for whatever LCID is applicable.  Specifically, this is used
//  from within GetIDsOfNames and Invoke.
//
// Parameters:
//  itInfo          UINT reserved.  Must be zero.
//  lcid            LCID providing the locale for the type
//                  information.  If the object does not support
//                  localization, this is ignored.
//  ppITypeInfo     ITypeInfo ** in which to store the ITypeInfo
//                  interface for the object.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr = S_OK;
    ITypeInfo** ppITI;

    *ppITypeInfo = NULL;

    if (itInfo != 0)
    {
        return TYPE_E_ELEMENTNOTFOUND;
    }

#if 1
    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ppITI = &_pITINeutral;
#else
    //
    // Since we returned one from GetTypeInfoCount, this function
    // can be called for a specific locale.  We support English
    // and neutral (defaults to English) locales.  Anything
    // else is an error.
    //
    // After this switch statement, ppITI will point to the proper
    // member pITypeInfo. If *ppITI is NULL, we know we need to
    // load type information, retrieve the ITypeInfo we want, and
    // then store it in *ppITI.
    //
    switch (PRIMARYLANGID(lcid))
    {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            ppITI=&_pITINeutral;
            break;

        default:
            hr = DISP_E_UNKNOWNLCID;
    }
#endif

    if (SUCCEEDED(hr))
    {
        //Load a type lib if we don't have the information already
        if (*ppITI == NULL)
        {
            ITypeInfo* pITIDisp;

            hr = _LoadTypeInfo(_piidTypeLib, lcid, *_piid, &pITIDisp);

            if (SUCCEEDED(hr))
            {
                HREFTYPE hrefType;

                // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
                // returns the ITypeInfo of the IDispatch-part only. We need to
                // find the ITypeInfo for the dual interface-part.
                if (SUCCEEDED(pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType)) &&
                    SUCCEEDED(pITIDisp->GetRefTypeInfo(hrefType, ppITI)))
                {
                    // GetRefTypeInfo should have filled in ppITI with the dual interface
                    (*ppITI)->AddRef(); // add the ref for our caller
                    *ppITypeInfo = *ppITI;
                    
                    pITIDisp->Release();
                }
                else
                {
                    // I suspect GetRefTypeOfImplType may fail if someone uses
                    // CIDispatchHelper on a non-dual interface. In this case the
                    // ITypeInfo we got above is just fine to use.
                    *ppITI = pITIDisp;
                }
            }
        }
        else
        {
            // we already loaded the type library and we have an ITypeInfo from it
            (*ppITI)->AddRef(); // add the ref for our caller
            *ppITypeInfo = *ppITI;
        }
    }

    return hr;
}


//
// CIDispatchHelper::GetIDsOfNames
//
// Purpose:
//  Converts text names into DISPIDs to pass to Invoke
//
// Parameters:
//  riid            REFIID reserved.  Must be IID_NULL.
//  rgszNames       OLECHAR ** pointing to the array of names to be
//                  mapped.
//  cNames          UINT number of names to be mapped.
//  lcid            LCID of the locale.
//  rgDispID        DISPID * caller allocated array containing IDs
//                  corresponging to those names in rgszNames.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr;
    ITypeInfo* pTI;
 
    if (riid != IID_NULL)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    // get the right ITypeInfo for lcid.
    hr = GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        hr = pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);
        pTI->Release();
    }

    return hr;
}


//
// CIDispatchHelper::Invoke
//
// Purpose:
//  Calls a method in the dispatch interface or manipulates a
//  property.
//
// Parameters:
//  dispID          DISPID of the method or property of interest.
//  riid            REFIID reserved, must be IID_NULL.
//  lcid            LCID of the locale.
//  wFlags          USHORT describing the context of the invocation.
//  pDispParams     DISPPARAMS * to the array of arguments.
//  pVarResult      VARIANT * in which to store the result.  Is
//                  NULL if the caller is not interested.
//  pExcepInfo      EXCEPINFO * to exception information.
//  puArgErr        UINT * in which to store the index of an
//                  invalid parameter if DISP_E_TYPEMISMATCH
//                is returned.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::Invoke(DISPID dispID, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr;
    ITypeInfo *pTI;

    //riid is supposed to be IID_NULL always
    if (riid != IID_NULL)
    {
        return(DISP_E_UNKNOWNINTERFACE);
    }

    // make sure we have an interface to hand off to Invoke
    if (_pdisp == NULL)
    {
        hr = QueryInterface(*_piid, (LPVOID*)&_pdisp);
        
        if (FAILED(hr))
        {
            return hr;
        }

        // don't hold a refcount on ourself
        _pdisp->Release();
    }

    // get the ITypeInfo for lcid
    hr = GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        // clear exceptions
        SetErrorInfo(0L, NULL);

        // this is exactly what DispInvoke does--so skip the overhead.
        hr = pTI->Invoke(_pdisp, dispID, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
        pTI->Release();
    }

    return hr;
}


CIDispatchHelper::CIDispatchHelper(const IID* piid, const IID* piidTypeLib)
{
    // the constructor takes a guid that this IDispatch implementation is for
    _piid = piid;

    // and a guid that tells us which RegTypeLib to load
    _piidTypeLib = piidTypeLib;

    ASSERT(_pITINeutral == NULL);
    ASSERT(_pdisp == NULL);

    return;
}


CIDispatchHelper::~CIDispatchHelper(void)
{
    if (_pITINeutral)
    {
        _pITINeutral->Release();
        _pITINeutral = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\cinteractivelogon.h ===
//  --------------------------------------------------------------------------
//  Module Name: CInteractiveLogon.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that implements encapsulation of interactive logon information.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _CInteractiveLogon_
#define     _CInteractiveLogon_

EXTERN_C    BOOL    WINAPI  InitiateInteractiveLogon (const WCHAR *pszUsername, WCHAR *pszPassword, DWORD dwTimeout);

//  --------------------------------------------------------------------------
//  CInteractiveLogon
//
//  Purpose:    This class encapsulates interactive logon implementation.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

class   CInteractiveLogon
{
    private:
        static  const int       MAGIC_NUMBER    =   48517;

        class   CRequestData
        {
            public:
                                    CRequestData (void);
                                    ~CRequestData (void);

                void                Set (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword);
                DWORD               Get (WCHAR *pszUsername, size_t cchUsername, WCHAR *pszDomain, size_t cchDomain, WCHAR *pszPassword, size_t cchPassword)  const;
                void                SetErrorCode (DWORD dwErrorCode);
                DWORD               GetErrorCode (void)     const;
                HANDLE              OpenEventReply (void)   const;
            private:
                unsigned long       _ulMagicNumber;
                DWORD               _dwErrorCode;
                WCHAR               _szEventReplyName[64];
                WCHAR               _szUsername[UNLEN + sizeof('\0')];
                WCHAR               _szDomain[DNLEN + sizeof('\0')];
                unsigned char       _ucSeed;
                int                 _iPasswordLength;
                WCHAR               _szPassword[PWLEN + sizeof('\0')];
        };

    public:
                                    CInteractiveLogon (void);
                                    ~CInteractiveLogon (void);

                void                Start (void);
                void                Stop (void);

                void                SetHostWindow (HWND hwndUIHost);

        static  DWORD               Initiate (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword, DWORD dwTimeout);
    private:
        static  DWORD               CheckInteractiveLogonAllowed (DWORD dwTimeout);
        static  DWORD               CheckShutdown (void);
        static  DWORD               CheckMutex (DWORD dwTimeout);
        static  bool                FoundUserSessionID (HANDLE hToken, DWORD *pdwSessionID);
        static  DWORD               SendRequest (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword);
        static  HRESULT             FormulateObjectBasePath (DWORD dwSessionID, WCHAR *pszObjectPath, size_t cchObjectPath);
        static  HANDLE              CreateSessionNamedReplyEvent (DWORD dwSessionID);
        static  HANDLE              OpenSessionNamedSignalEvent (DWORD dwSessionID);
        static  HANDLE              CreateSessionNamedSection (DWORD dwSessionID);

                void                WaitForInteractiveLogonRequest (void);

        static  DWORD   WINAPI      CB_ThreadProc (void *pParameter);
        static  void    CALLBACK    CB_APCProc (ULONG_PTR dwParam);
    private:
                HANDLE              _hThread;
                bool                _fContinue;
                HWND                _hwndHost;

        static  const TCHAR         s_szEventReplyName[];
        static  const TCHAR         s_szEventSignalName[];
        static  const TCHAR         s_szSectionName[];
};

#endif  /*  _CInteractiveLogon_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\classfactory.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       ClassFactory.cpp
//
//  Contents:   com class factory routines
//
//----------------------------------------------------------------------------
#include "priv.h"

#include "UserOM.h" // needed for class factory prototypes


class CSHGinaFactory : public IClassFactory
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CSHGinaFactory(REFCLSID rclsid);
    ~CSHGinaFactory(void);

    // friend Functions
    friend HRESULT CSHGinaFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int _cRef;
    CLSID _rclsid;
};


//
// IUnknown Interface
//

ULONG CSHGinaFactory::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CSHGinaFactory::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CSHGinaFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory*);
        AddRef();
        hr = S_OK;
    }

    return hr;
}


//
// IClassFactory methods
//

HRESULT CSHGinaFactory::CreateInstance(IUnknown* punkOuter, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr = ResultFromScode(REGDB_E_CLASSNOTREG);
    *ppvObj = NULL;

    if (!punkOuter)
    {
        if (IsEqualIID(_rclsid, CLSID_ShellLogonEnumUsers))
        {
            hr = CLogonEnumUsers_Create(riid, ppvObj);
        }
        else if (IsEqualIID(_rclsid, CLSID_ShellLogonUser))
        {
            hr = CLogonUser_Create(riid, ppvObj);
        }
        else if (IsEqualIID(_rclsid, CLSID_ShellLocalMachine))
        {
            hr = CLocalMachine_Create(riid, ppvObj);
        }
        else if (IsEqualIID(_rclsid, CLSID_ShellLogonStatusHost))
        {
            hr = CLogonStatusHost_Create(riid, ppvObj);
        }
        else
        {
            // What are you looking for?
            ASSERTMSG(FALSE, "CSHGinaFactory::CreateInstance unable to create object.");
            hr = E_FAIL;
        }
    }
    else
    {
        // Does anybody support aggregation any more?
        hr = ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    return hr;
}


HRESULT CSHGinaFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllAddRef();
    }
    else
    {
        DllRelease();
    }

    return S_OK;
}


HRESULT CSHGinaFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (LPVOID) new CSHGinaFactory(rclsid);
        if (*ppvObj)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = ResultFromScode(E_NOINTERFACE);
    }

    return hr;
}


CSHGinaFactory::CSHGinaFactory(REFCLSID rclsid) : _cRef(1)
{
    _rclsid = rclsid;
    DllAddRef();
}


CSHGinaFactory::~CSHGinaFactory()
{
    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\cuser.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       User.cpp
//
//  Contents:   implementation of CLogonUser
//
//----------------------------------------------------------------------------

#include "priv.h"

#include "resource.h"
#include "UserOM.h"
#include <lmaccess.h>   // for NetUserSetInfo & structures
#include <lmapibuf.h>   // for NetApiBufferFree
#include <lmerr.h>      // for NERR_Success
#include <ntlsa.h>      // for LsaOpenPolicy, etc.
#include <sddl.h>       // for ConvertSidToStringSid
#include "LogonIPC.h"
#include "ProfileUtil.h"
#include <MSGinaExports.h>
#include <msshrui.h>    // for IsFolderPrivateForUser, SetFolderPermissionsForSharing
#include <winsta.h>     // for WinStationEnumerate, etc.
#include <ccstock.h>

#include <passrec.h>    // PRQueryStatus, dpapi.lib


typedef struct
{
    SID sid;            // contains 1 subauthority
    DWORD dwSubAuth;    // 2nd subauthority
} _ALIAS_SID;

#define DECLARE_ALIAS_SID(rid)    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,{SECURITY_BUILTIN_DOMAIN_RID}},(rid)}

struct
{
    _ALIAS_SID sid;
    LPCWSTR szDefaultGroupName;
    LPCWSTR pwszActualGroupName;
} g_groupname_map [] =
{
    // in ascending order of privilege
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_GUESTS),      L"Guests",         NULL},
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_USERS),       L"Users",          NULL},
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_POWER_USERS), L"Power Users",    NULL},
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_ADMINS),      L"Administrators", NULL}
};

void _InitializeGroupNames()
{
    int i;

    for (i = 0; i < ARRAYSIZE(g_groupname_map); i++)
    {
        if (g_groupname_map[i].pwszActualGroupName == NULL)
        {
            WCHAR szGroupName[GNLEN + 1];
            WCHAR szDomain[DNLEN + 1];
            DWORD cchGroupName = ARRAYSIZE(szGroupName);
            DWORD cchDomain = ARRAYSIZE(szDomain);
            SID_NAME_USE eUse;

            szGroupName[0] = L'\0';

            if (!LookupAccountSidW(NULL,
                                   &g_groupname_map[i].sid,
                                   szGroupName,
                                   &cchGroupName,
                                   szDomain,
                                   &cchDomain,
                                   &eUse))
            {
                // if the lookup fails, fall back to the default
                StringCchCopy(szGroupName, ARRAYSIZE(szGroupName), g_groupname_map[i].szDefaultGroupName);
            }

            if (szGroupName[0] != L'\0')
            {
                LPWSTR pwsz;
                DWORD cch;

                cch = lstrlenW(szGroupName) + 1;
                pwsz = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
                if (pwsz)
                {
                    if (FAILED(StringCchCopy(pwsz, cch, szGroupName))   ||
                        InterlockedCompareExchangePointer((void**)&g_groupname_map[i].pwszActualGroupName, pwsz, NULL))
                    {
                        // someone else beat us to initing pwszActualGroupName
                        LocalFree(pwsz);
                        pwsz = NULL;
                    }
                }
            }
        }
    }
}

BOOL FreeGroupNames()
{
    BOOL bRet = FALSE;
    int i;

    for (i = 0; i < ARRAYSIZE(g_groupname_map); i++)
    {
        LPWSTR psz = (LPWSTR)InterlockedExchangePointer((void **)&g_groupname_map[i].pwszActualGroupName, NULL);

        if (psz)
        {
            LocalFree(psz);
            bRet = TRUE;
        }
    }

    return bRet;
}

//
// IUnknown Interface
//

ULONG CLogonUser::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CLogonUser::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CLogonUser::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLogonUser, IDispatch),
        QITABENT(CLogonUser, ILogonUser),
        {0},
    };

    return QISearch(this, qit, riid, ppvObj);
}


//
// IDispatch Interface
//

STDMETHODIMP CLogonUser::GetTypeInfoCount(UINT* pctinfo)
{ 
    return CIDispatchHelper::GetTypeInfoCount(pctinfo); 
}


STDMETHODIMP CLogonUser::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    return CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo); 
}


STDMETHODIMP CLogonUser::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{ 
    return CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}


STDMETHODIMP CLogonUser::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    return CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


//
// ILogonUser Interface
//
STDMETHODIMP CLogonUser::get_setting(BSTR bstrName, VARIANT* pvarVal)
{
    return _UserSettingAccessor(bstrName, pvarVal, FALSE);
}


STDMETHODIMP CLogonUser::put_setting(BSTR bstrName, VARIANT varVal)
{
    return _UserSettingAccessor(bstrName, &varVal, TRUE);
}

STDMETHODIMP CLogonUser::get_isLoggedOn(VARIANT_BOOL* pbLoggedOn)
{
    HRESULT   hr = S_OK;
    CLogonIPC objLogon;

    if (NULL == pbLoggedOn)
        return E_POINTER;

    *pbLoggedOn = VARIANT_FALSE;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbLoggedOn = ( objLogon.IsUserLoggedOn(_szLoginName, _szDomain) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        TCHAR szUsername[UNLEN + 1];
        DWORD cch = ARRAYSIZE(szUsername);

        if (GetUserName(szUsername, &cch) && (StrCmp(szUsername, _szLoginName) == 0))
        {
            *pbLoggedOn = VARIANT_TRUE;
        }
        else
        {
            PLOGONID    pSessions;
            DWORD       cSessions;

            //  Iterate the sessions looking for active and disconnected sessions only.
            //  Then match the user name and domain (case INsensitive) for a result.

            if (WinStationEnumerate(SERVERNAME_CURRENT,
                                    &pSessions,
                                    &cSessions))
            {
                PLOGONID    pSession;
                DWORD       i;

                for (i = 0, pSession = pSessions; i < cSessions; ++i, ++pSession)
                {
                    if ((pSession->State == State_Active) || (pSession->State == State_Disconnected))
                    {
                        WINSTATIONINFORMATION   winStationInformation;
                        DWORD                   cb;

                        if (WinStationQueryInformation(SERVERNAME_CURRENT,
                                                       pSession->SessionId,
                                                       WinStationInformation,
                                                       &winStationInformation,
                                                       sizeof(winStationInformation),
                                                       &cb))
                        {
                            if ((0 == lstrcmpi(winStationInformation.UserName, _szLoginName)) &&
                                (0 == lstrcmpi(winStationInformation.Domain, _szDomain)))
                            {
                                *pbLoggedOn = VARIANT_TRUE;
                                break;
                            }
                        }
                    }
                }
                WinStationFreeMemory(pSessions);
            }
            else
            {
                DWORD   dwErrorCode;

                dwErrorCode = GetLastError();

                // We get RPC_S_INVALID_BINDING in safe mode, in which case
                // FUS is disabled, so we know the user isn't logged on.
                if (dwErrorCode != RPC_S_INVALID_BINDING)
                {
                    hr = HRESULT_FROM_WIN32(dwErrorCode);
                }
            }
        }
    }

    return hr;
}


STDMETHODIMP CLogonUser::get_passwordRequired(VARIANT_BOOL* pbPasswordRequired)
{
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbPasswordRequired = objLogon.TestBlankPassword(_szLoginName, _szDomain) ? VARIANT_FALSE: VARIANT_TRUE;
    }
    else
    {
        if (NULL == pbPasswordRequired)
            return E_POINTER;

        if ((BOOL)-1 == _bPasswordRequired)
        {
            BOOL    fResult;
            HANDLE  hToken;

            // Test for a blank password by trying to
            // logon the user with a blank password.

            fResult = LogonUser(_szLoginName,
                                NULL,
                                L"",
                                LOGON32_LOGON_INTERACTIVE,
                                LOGON32_PROVIDER_DEFAULT,
                                &hToken);
            if (fResult != FALSE)
            {
                TBOOL(CloseHandle(hToken));
                _bPasswordRequired = FALSE;
            }
            else
            {
                switch (GetLastError())
                {
                case ERROR_ACCOUNT_RESTRICTION:
                    // This means that blank password logons are disallowed, from
                    // which we infer that the password is blank.
                    _bPasswordRequired = FALSE;
                    break;

                case ERROR_LOGON_TYPE_NOT_GRANTED:
                    // Interactive logon was denied. We only get this if the
                    // password is blank, otherwise we get ERROR_LOGON_FAILURE.
                    _bPasswordRequired = FALSE;
                    break;

                case ERROR_LOGON_FAILURE:           // normal case (non-blank password)
                case ERROR_PASSWORD_MUST_CHANGE:    // expired password
                    _bPasswordRequired = TRUE;
                    break;

                default:
                    // We'll guess TRUE
                    _bPasswordRequired = TRUE;
                    break;
                }
            }
        }
        *pbPasswordRequired = (FALSE != _bPasswordRequired) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CLogonUser::get_interactiveLogonAllowed(VARIANT_BOOL *pbInteractiveLogonAllowed)
{
    HRESULT hr;
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbInteractiveLogonAllowed = objLogon.TestInteractiveLogonAllowed(_szLoginName, _szDomain) ? VARIANT_TRUE : VARIANT_FALSE;
        hr = S_OK;
    }
    else
    {
        int     iResult;

        iResult = ShellIsUserInteractiveLogonAllowed(_szLoginName);
        if (iResult == -1)
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            *pbInteractiveLogonAllowed = (iResult != 0) ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT _IsGuestAccessMode(void)
{
    HRESULT hr = E_FAIL;

    if (IsOS(OS_PERSONAL))
    {
        hr = S_OK;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        DWORD dwValue = 0;
        DWORD cbValue = sizeof(dwValue);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                                        TEXT("ForceGuest"),
                                        NULL,
                                        &dwValue,
                                        &cbValue)
            && 1 == dwValue)
        {
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CLogonUser::get_isProfilePrivate(VARIANT_BOOL* pbPrivate)
{
    HRESULT hr;

    if (NULL == pbPrivate)
        return E_POINTER;

    *pbPrivate = VARIANT_FALSE;

    // Only succeed if we are on Personal, or Professional with ForceGuest=1.
    hr = _IsGuestAccessMode();

    if (SUCCEEDED(hr))
    {
        // assume failure here
        hr = E_FAIL;

        _LookupUserSid();
        if (NULL != _pszSID)
        {
            TCHAR szPath[MAX_PATH];

            // Get the profile path
            DWORD cbData = sizeof(szPath);
            if (PathCombine(szPath, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), _pszSID) &&
                (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                             szPath,
                                             TEXT("ProfileImagePath"),
                                             NULL,
                                             szPath,
                                             &cbData)))
            {
                DWORD dwPrivateType;

                if (IsFolderPrivateForUser(szPath, _pszSID, &dwPrivateType, NULL))
                {
                    // Note that we return E_FAIL for FAT volumes
                    if (0 == (dwPrivateType & IFPFU_NOT_NTFS))
                    {
                        if (dwPrivateType & IFPFU_PRIVATE)
                        {
                            *pbPrivate = VARIANT_TRUE;
                        }

                        hr = S_OK;
                    }
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CLogonUser::makeProfilePrivate(VARIANT_BOOL bPrivate)
{
    HRESULT hr;

    // Only succeed if we are on Personal, or Professional with ForceGuest=1.
    hr = _IsGuestAccessMode();

    if (SUCCEEDED(hr))
    {
        // assume failure here
        hr = E_FAIL;

        _LookupUserSid();
        if (NULL != _pszSID)
        {
            TCHAR szPath[MAX_PATH];

            // Get the profile path
            DWORD cbData = sizeof(szPath);
            if (PathCombine(szPath, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), _pszSID) &&
                (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                            szPath,
                                            TEXT("ProfileImagePath"),
                                            NULL,
                                            szPath,
                                            &cbData)))
            {
                if (SetFolderPermissionsForSharing(szPath, _pszSID, (VARIANT_TRUE == bPrivate) ? 0 : 1, NULL))
                {
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CLogonUser::logon(BSTR pbstrPassword, VARIANT_BOOL* pbRet)
{
    HRESULT hr;
    CLogonIPC objLogon;
    TCHAR szPassword[PWLEN + 1];

    if (pbstrPassword)
    {
        StringCchCopy(szPassword, ARRAYSIZE(szPassword), pbstrPassword);
    }
    else
    {
        szPassword[0] = TEXT('\0');
    }
        
    if (!objLogon.IsLogonServiceAvailable())
    {
        *pbRet = VARIANT_FALSE;
        hr = S_OK;
    }
    else
    {
        if (objLogon.LogUserOn(_szLoginName, _szDomain, szPassword))
        {
            *pbRet = VARIANT_TRUE;
            hr = S_OK;
        }
        else
        {
            *pbRet = VARIANT_FALSE;
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}


STDMETHODIMP CLogonUser::logoff(VARIANT_BOOL* pbRet)
{
    HRESULT     hr;
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbRet = ( objLogon.LogUserOff(_szLoginName, _szDomain) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        *pbRet = ( ExitWindowsEx(EWX_LOGOFF, 0) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    hr = S_OK;

    return hr;
}


// Borrowed from msgina
BOOL IsAutologonUser(LPCTSTR szUser, LPCTSTR szDomain)
{
    BOOL fIsUser = FALSE;
    HKEY hkey = NULL;
    TCHAR szAutologonUser[UNLEN + sizeof('\0')];
    TCHAR szAutologonDomain[DNLEN + sizeof('\0')];
    TCHAR szTempDomainBuffer[DNLEN + sizeof('\0')];
    DWORD cbBuffer;
    DWORD dwType;

    *szTempDomainBuffer = 0;

    // Domain may be a empty string. If this is the case...
    if (0 == *szDomain)
    {
        DWORD cchBuffer;

        // We really mean the local machine name
        // Point to our local buffer
        szDomain = szTempDomainBuffer;
        cchBuffer = ARRAYSIZE(szTempDomainBuffer);

        GetComputerName(szTempDomainBuffer, &cchBuffer);
    }

    // See if the domain and user name
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey))
    {
        // Check the user name
        cbBuffer = sizeof(szAutologonUser);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             TEXT("DefaultUserName"),
                                             0,
                                             &dwType,
                                             (LPBYTE)szAutologonUser,
                                             &cbBuffer))
        {
            // Does it match?
            if (0 == lstrcmpi(szAutologonUser, szUser))
            {
                // Yes. Now check domain
                cbBuffer = sizeof(szAutologonDomain);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                                     TEXT("DefaultDomainName"),
                                                     0,
                                                     &dwType,
                                                     (LPBYTE)szAutologonDomain,
                                                     &cbBuffer))
                {
                    // Make sure domain matches
                    if (0 == lstrcmpi(szAutologonDomain, szDomain))
                    {
                        // Success - the users match
                        fIsUser = TRUE;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return fIsUser;
}

// Borrowed from msgina
NTSTATUS SetAutologonPassword(LPCWSTR szPassword)
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    
    InitializeObjectAttributes(&ObjectAttributes, NULL, 0L, (HANDLE)NULL, NULL);

    Status = LsaOpenPolicy(NULL, &ObjectAttributes, POLICY_CREATE_SECRET, &LsaHandle);
    if (NT_SUCCESS(Status))
    {
        UNICODE_STRING SecretName;
        
        Status = RtlInitUnicodeStringEx(&SecretName, L"DefaultPassword");
        if (NT_SUCCESS(Status))
        {
            UNICODE_STRING SecretValue;

            Status = RtlInitUnicodeStringEx(&SecretValue, szPassword);
            if (NT_SUCCESS(Status))
            {
                Status = LsaStorePrivateData(LsaHandle, &SecretName, &SecretValue);
            }
        }

        LsaClose(LsaHandle);
    }

    return Status;
}

STDMETHODIMP CLogonUser::changePassword(VARIANT varNewPassword, VARIANT varOldPassword, VARIANT_BOOL* pbRet)
{
    HRESULT hr;

    if (VT_BSTR == varNewPassword.vt && VT_BSTR == varOldPassword.vt)
    {
        TCHAR szUsername[UNLEN + sizeof('\0')];
        DWORD cch = ARRAYSIZE(szUsername);
        NET_API_STATUS  nasRet;
        USER_MODALS_INFO_0 *pumi0 = NULL;

        LPWSTR pszNewPassword = varNewPassword.bstrVal ? varNewPassword.bstrVal : L"\0";

        // We used to create accounts with UF_PASSWD_NOTREQD, and we still do
        // when password policy is enabled.  If UF_PASSWD_NOTREQD is set, then
        // the below code will succeed even with password policy is enabled,
        // so do a minimal policy check here.

        nasRet = NetUserModalsGet(NULL, 0, (LPBYTE*)&pumi0);
        if (nasRet == NERR_Success && pumi0 != NULL)
        {
            if ((DWORD)lstrlen(pszNewPassword) < pumi0->usrmod0_min_passwd_len)
            {
                nasRet = NERR_PasswordTooShort;
            }
            NetApiBufferFree(pumi0);
        }

        if (nasRet == NERR_Success)
        {
            if (GetUserName(szUsername, &cch) && (StrCmp(szUsername, _szLoginName) == 0))
            {
                // This is the case of a user changing their own password.
                // Both passwords must be provided to effect the change.

                LPCWSTR pszOldPassword = varOldPassword.bstrVal ? varOldPassword.bstrVal : L"\0";

                nasRet = NetUserChangePassword(NULL,            // Local machine
                                               _szLoginName,    // name of the person to change
                                               pszOldPassword,  // old password
                                               pszNewPassword); // new password
            }
            else
            {
                // This is the case of an admin changing someone else's password.
                // As an administrator they don't need to enter the old password.

                USER_INFO_1003 usri1003 = { pszNewPassword };

                nasRet = NetUserSetInfo(NULL,                   // local machine
                                        _szLoginName,           // name of the person to change
                                        1003,                   // structure level
                                        (LPBYTE)&usri1003,      // the update info
                                        NULL);                  // don't care
            }

            if (nasRet == NERR_Success)
            {
                // If this is the default user for autologon, delete the cleartext
                // password from the registry and save the new password.

                if (IsAutologonUser(_szLoginName, _szDomain))
                {
                    SHDeleteValue(HKEY_LOCAL_MACHINE,
                                  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
                                  TEXT("DefaultPassword"));
                    SetAutologonPassword(pszNewPassword);
                }
                
                // Make an attempt to remove UF_PASSWD_NOTREQD if it's
                // currently set. Ignore errors since we already changed
                // the password above.

                USER_INFO_1008 *pusri1008;
                if (NERR_Success == NetUserGetInfo(NULL, _szLoginName, 1008, (LPBYTE*)&pusri1008))
                {
                    if (pusri1008->usri1008_flags & UF_PASSWD_NOTREQD)
                    {
                        pusri1008->usri1008_flags &= ~UF_PASSWD_NOTREQD;
                        NetUserSetInfo(NULL, _szLoginName, 1008, (LPBYTE)pusri1008, NULL);
                    }
                    NetApiBufferFree(pusri1008);
                }
            }
        }

        hr = HRESULT_FROM_WIN32(nasRet);

        if (SUCCEEDED(hr))
        {
            _bPasswordRequired = !(L'\0' == *pszNewPassword);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    *pbRet = ( SUCCEEDED(hr) ) ? VARIANT_TRUE : VARIANT_FALSE;

    return hr;
}


STDAPI CLogonUser_Create(REFIID riid, void** ppvObj)
{
    return CLogonUser::Create(TEXT(""), TEXT(""), TEXT(""), riid, ppvObj);
}            


HRESULT CLogonUser::Create(LPCTSTR pszLoginName, LPCTSTR pszFullName, LPCTSTR pszDomain, REFIID riid, LPVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CLogonUser* pUser = new CLogonUser(pszLoginName, pszFullName, pszDomain);

    if (pUser)
    {
        hr = pUser->QueryInterface(riid, ppv);
        pUser->Release();
    }

    return hr;
}


CLogonUser::CLogonUser(LPCTSTR pszLoginName,
                       LPCTSTR pszFullName,
                       LPCTSTR pszDomain)
  : _cRef(1), CIDispatchHelper(&IID_ILogonUser, &LIBID_SHGINALib),
    _strDisplayName(NULL), _strPictureSource(NULL), _strDescription(NULL),
    _strHint(NULL), _iPrivilegeLevel(-1), _pszSID(NULL),
    _bPasswordRequired((BOOL)-1)
{
    _InitializeGroupNames();

    StringCchCopy(_szLoginName, ARRAYSIZE(_szLoginName), pszLoginName);
    StringCchCopy(_szDomain, ARRAYSIZE(_szDomain), pszDomain);

    if (pszFullName)
    {
        _strDisplayName = SysAllocString(pszFullName);
    }

    // Use the EOF marker to indicate an uninitialized string
    _szPicture[0] = _TEOF;

    DllAddRef();
}


CLogonUser::~CLogonUser()
{
    SysFreeString(_strDisplayName);
    SysFreeString(_strPictureSource);
    SysFreeString(_strDescription);
    SysFreeString(_strHint);

    if (_pszSID)
    {
        LocalFree(_pszSID);
    }

    ASSERT(_cRef == 0);
    DllRelease();
}


typedef HRESULT (CLogonUser::*PFNPUT)(VARIANT);
typedef HRESULT (CLogonUser::*PFNGET)(VARIANT *);

struct SETTINGMAP
{
    LPCWSTR szSetting;
    PFNGET  pfnGet;
    PFNPUT  pfnPut;
};

#define MAP_SETTING(x)          { L#x, CLogonUser::_Get##x, CLogonUser::_Put##x }
#define MAP_SETTING_GET_ONLY(x) { L#x, CLogonUser::_Get##x, NULL                }
#define MAP_SETTING_PUT_ONLY(x) { L#x, NULL,                CLogonUser::_Put##x }

// _UserSettingAccessor
//
// bstrName - name of the setting you widh to access
// pvarVal  - the value of the named setting
// bPut     - if true the named setting will be updated
//            with the value pointed to by pvarVal
//            if false the named setting will be retrieved
//            in pvarVal
//
HRESULT CLogonUser::_UserSettingAccessor(BSTR bstrName, VARIANT *pvarVal, BOOL bPut)
{
    static const SETTINGMAP setting_map[] =
    {
        // in descending order of expected access frequecy
        MAP_SETTING(LoginName),
        MAP_SETTING(DisplayName),
        MAP_SETTING(Picture),
        MAP_SETTING_GET_ONLY(PictureSource),
        MAP_SETTING(AccountType),
        MAP_SETTING(Hint),
        MAP_SETTING_GET_ONLY(Domain),
        MAP_SETTING(Description),
        MAP_SETTING_GET_ONLY(SID),
        MAP_SETTING_GET_ONLY(UnreadMail)
    };

    HRESULT hr;
    INT     i;

    // start off assuming bogus setting name
    hr = E_INVALIDARG;

    for ( i = 0; i < ARRAYSIZE(setting_map); i++)
    {
        if (StrCmpW(bstrName, setting_map[i].szSetting) == 0)
        {

            // what do we want to do with the named setting ... 
            if ( bPut ) 
            {
                // ... change its value 
                PFNPUT pfnPut = setting_map[i].pfnPut;

                if ( pfnPut != NULL )
                {
                    hr = (this->*pfnPut)(*pvarVal);
                }
                else
                {
                    // we don't support updated the value for this setting
                    hr = E_FAIL;
                }
            }
            else
            {
                // ... retrieve its value
                PFNGET pfnGet = setting_map[i].pfnGet;

                if ( pfnGet != NULL )
                {
                    hr = (this->*pfnGet)(pvarVal);
                }
                else
                {
                    // we don't support retieving the value for this setting
                    hr = E_FAIL;
                }
            }

            break;
        }
    }

    return hr;
}

HRESULT CLogonUser::_GetDisplayName(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strDisplayName)
    {
        PUSER_INFO_1011 pusri1011 = NULL;
        NET_API_STATUS nasRet;

        nasRet = NetUserGetInfo(NULL,                       // local machine
                                _szLoginName,               // whose information do we want
                                1011,                       // structure level
                                (LPBYTE*)&pusri1011);       // pointer to the structure we'll receive

        if ( nasRet == NERR_Success )
        {
            _strDisplayName = SysAllocString(pusri1011->usri1011_full_name);
            NetApiBufferFree(pusri1011);
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strDisplayName);

    return S_OK;
}


HRESULT CLogonUser::_PutDisplayName(VARIANT var)
{
    HRESULT hr;

    if ( var.vt == VT_BSTR )
    {
        USER_INFO_1011 usri1011;
        NET_API_STATUS nasRet;

        if ( var.bstrVal )
        {
            usri1011.usri1011_full_name = var.bstrVal;
        }
        else
        {
            // OK to have emply string as display name
            usri1011.usri1011_full_name = L"\0";
        }

        nasRet = NetUserSetInfo(NULL,                       // local machine
                                _szLoginName,               // name of the person to change
                                1011,                       // structure level
                                (LPBYTE)&usri1011,          // the update info
                                NULL);                      // don't care

        if ( nasRet == NERR_Success )
        {
            // DisplayName was successfully changed. Remember to update our
            // local copy
            SysFreeString(_strDisplayName);
            _strDisplayName = SysAllocString(usri1011.usri1011_full_name);

            // Notify everyone that a user name has changed
            SHChangeDWORDAsIDList dwidl;
            dwidl.cb      = SIZEOF(dwidl) - SIZEOF(dwidl.cbZero);
            dwidl.dwItem1 = SHCNEE_USERINFOCHANGED;
            dwidl.dwItem2 = 0;
            dwidl.cbZero  = 0;
            SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, (LPCITEMIDLIST)&dwidl, NULL);

            hr = S_OK;
        }
        else
        {
            // insufficient privileges?
            hr = HRESULT_FROM_WIN32(nasRet);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_GetLoginName(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_szLoginName);

    return S_OK;
}


HRESULT CLogonUser::_PutLoginName(VARIANT var)
{
    HRESULT hr;

    if ( (var.vt == VT_BSTR) && (var.bstrVal) && (*var.bstrVal) )
    {
        if (_szLoginName[0] == TEXT('\0'))
        {
            // We haven't been initialized yet. Initialize to the given name.
            hr = StringCchCopy(_szLoginName, ARRAYSIZE(_szLoginName), var.bstrVal);
        }
        else
        {
            USER_INFO_0 usri0;
            NET_API_STATUS nasRet;

            usri0.usri0_name = var.bstrVal;
            nasRet = NetUserSetInfo(NULL,                       // local machine
                                    _szLoginName,               // name of the person to change
                                    0,                          // structure level
                                    (LPBYTE)&usri0,             // the update info
                                    NULL);                      // don't care

            if (nasRet == NERR_Success)
            {
                // We should also rename the user's picture file to match
                // their new LoginName
                if (_TEOF == _szPicture[0])
                {
                    // This requires _szLoginName to still have the old name,
                    // so do it before updating _szLoginName below.
                    hr = _InitPicture();
                }
                else
                {
                    hr = S_OK;
                }

                if (SUCCEEDED(hr) && (TEXT('\0') != _szPicture[0]))
                {
                    LPTSTR pszOldPicturePath;
                    TCHAR  szNewPicture[ARRAYSIZE(_szPicture)];

                    pszOldPicturePath = &_szPicture[7]; // &[7] to skip over the "file://" part

                    if (SUCCEEDED(StringCchCopy(szNewPicture, ARRAYSIZE(szNewPicture), pszOldPicturePath))  &&
                        PathRemoveFileSpec(szNewPicture)                                                    &&
                        PathAppend(szNewPicture, usri0.usri0_name)                                          &&
                        SUCCEEDED(StringCchCat(szNewPicture, ARRAYSIZE(szNewPicture), PathFindExtension(pszOldPicturePath))))
                    {
                        if (MoveFileEx(pszOldPicturePath, szNewPicture, MOVEFILE_REPLACE_EXISTING))
                        {
                            StringCchCopy(_szPicture, ARRAYSIZE(_szPicture), TEXT("file://"));
                            StringCchCat(_szPicture, ARRAYSIZE(_szPicture), szNewPicture);
                        }
                        else
                        {
                            // Give up and just try to delete the old picture
                            // (otherwise it will be abandoned).
                            DeleteFile(pszOldPicturePath);
                            _szPicture[0] = _TEOF;
                        }
                    }
                }

                // LoginName was successfully changed. Remember to update our local copy
                hr = StringCchCopy(_szLoginName, ARRAYSIZE(_szLoginName), usri0.usri0_name);
            }
            else
            {
                // insufficient privileges?
                hr = HRESULT_FROM_WIN32(nasRet);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_GetDomain(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_szDomain);

    return S_OK;
}


HRESULT CLogonUser::_GetPicture(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (_TEOF == _szPicture[0])
    {
        _InitPicture();
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_szPicture);

    return S_OK;
}


HRESULT CLogonUser::_PutPicture(VARIANT var)
{
    HRESULT hr;

    if ((var.vt == VT_BSTR) && (var.bstrVal) && (*var.bstrVal))
    {
        // Passed a string which is not NULL and not empty

        TCHAR szNewPicturePath[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szNewPicturePath);

        // get the path of the image we want to copy
        if (PathIsURL(var.bstrVal))
        {
            hr = PathCreateFromUrl(var.bstrVal, szNewPicturePath, &dwSize, NULL);
        }
        else
        {
            hr = StringCchCopy(szNewPicturePath, ARRAYSIZE(szNewPicturePath), var.bstrVal);
        }

        if (SUCCEEDED(hr))
        {
            // REVIEW (phellar) : we build the URL string ourself so we know it's of the form,
            //                    file://<path>, the path starts on the 7th character.
            if ( _TEOF == _szPicture[0] || (StrCmpI(szNewPicturePath, &_szPicture[7]) != 0))
            {
                hr = _SetPicture(szNewPicturePath);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CLogonUser::_GetPictureSource(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strPictureSource)
    {
        TCHAR szHintKey[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD dwSize = 0;

        if (PathCombine(szHintKey, c_szRegRoot, _szLoginName)   &&
            (SHGetValue(HKEY_LOCAL_MACHINE,
                        szHintKey,
                        c_szPictureSrcVal,
                        &dwType,
                        NULL,
                        &dwSize) == ERROR_SUCCESS)              &&
            (REG_SZ == dwType)                                  &&
            (dwSize > 0))
        {
            _strPictureSource = SysAllocStringLen(NULL, dwSize / sizeof(TCHAR));
            if (NULL != _strPictureSource)
            {
                if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE,
                                                szHintKey,
                                                c_szPictureSrcVal,
                                                NULL,
                                                (LPVOID)_strPictureSource,
                                                &dwSize))
                {
                    SysFreeString(_strPictureSource);
                    _strPictureSource = NULL;
                }
            }
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strPictureSource);

    return S_OK;
}

HRESULT CLogonUser::_GetDescription(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strDescription)
    {
        NET_API_STATUS nasRet;
        USER_INFO_1007 *pusri1007;

        nasRet = NetUserGetInfo(NULL,                       // local machine
                                _szLoginName,               // whose information do we want
                                1007,                       // structure level
                                (LPBYTE*)&pusri1007);       // pointer to the structure we'll receive

        if ( nasRet == NERR_Success )
        {
            _strDescription = SysAllocString(pusri1007->usri1007_comment);
            NetApiBufferFree(pusri1007);
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strDescription);

    return S_OK;
}


HRESULT CLogonUser::_PutDescription(VARIANT var)
{
    HRESULT        hr;

    if ( var.vt == VT_BSTR )
    {
        USER_INFO_1007 usri1007;
        NET_API_STATUS nasRet;

        if ( var.bstrVal )
        {
            usri1007.usri1007_comment = var.bstrVal;
        }
        else
        {
            // OK to have emply string as a description 
            usri1007.usri1007_comment = L"\0";
        }

        nasRet = NetUserSetInfo(NULL,                       // local machine
                                _szLoginName,               // name of the person to change
                                1007,                       // structure level
                                (LPBYTE)&usri1007,          // the update info
                                NULL);                      // don't care

        if ( nasRet == NERR_Success )
        {
            // Description was successfully changed. Remember to update our
            // local copy
            SysFreeString(_strDescription);
            _strDescription = SysAllocString(usri1007.usri1007_comment);
            hr = S_OK;
        }
        else
        {
            // insufficient privileges?
            hr = HRESULT_FROM_WIN32(nasRet);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_GetHint(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strHint)
    {
        TCHAR szHintKey[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD dwSize = 0;

        if (PathCombine(szHintKey, c_szRegRoot, _szLoginName)   &&
            (SHGetValue(HKEY_LOCAL_MACHINE,
                        szHintKey,
                        NULL,
                        &dwType,
                        NULL,
                        &dwSize) == ERROR_SUCCESS)              &&
            (REG_SZ == dwType)                                  &&
            (dwSize > 0)                                        &&
            (dwSize < 512))
        {
            _strHint = SysAllocStringLen(NULL, dwSize/sizeof(TCHAR));
            if (NULL != _strHint)
            {
                if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE,
                                                szHintKey,
                                                NULL,
                                                NULL,
                                                (LPVOID)_strHint,
                                                &dwSize))
                {
                    SysFreeString(_strHint);
                    _strHint = NULL;
                }
            }
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strHint);

    return S_OK;
}


HRESULT CLogonUser::_PutHint(VARIANT var)
{
    HRESULT hr;

    if ( var.vt == VT_BSTR )
    {
        DWORD dwErr;
        TCHAR *pszHint;
        HKEY  hkUserHint;
        
        if (var.bstrVal)
        {
            pszHint = var.bstrVal;
        }
        else
        {
            pszHint = TEXT("\0");
        }

        dwErr = _OpenUserHintKey(KEY_SET_VALUE, &hkUserHint);

        if ( dwErr == ERROR_SUCCESS )
        {
            DWORD cbData = lstrlen(pszHint) * sizeof(TCHAR) + sizeof(TEXT('\0'));
            dwErr = RegSetValueEx(hkUserHint,
                                  NULL,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pszHint,
                                  cbData);
            RegCloseKey(hkUserHint);
        }

        if ( dwErr == ERROR_SUCCESS )
        {
            // Hint was successfully changed. Remember to update our local copy
            SysFreeString(_strHint);
            _strHint = SysAllocString(pszHint);
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CLogonUser::_GetAccountType(VARIANT* pvar)
{
    HRESULT hr;

    hr = E_FAIL;

    if (pvar)
    {
        if (-1 == _iPrivilegeLevel)
        {
            NET_API_STATUS nasRet;
            PLOCALGROUP_INFO_0 plgi0;
            DWORD dwEntriesRead;
            DWORD dwEntriesTotal;

            nasRet = NetUserGetLocalGroups(
                        NULL,
                        _szLoginName,
                        0,
                        0,
                        (LPBYTE *)&plgi0,
                        MAX_PREFERRED_LENGTH,
                        &dwEntriesRead,
                        &dwEntriesTotal);

            if ( nasRet == NERR_Success )
            {
                // make sure we read all the groups
                ASSERT(dwEntriesRead == dwEntriesTotal)

                INT i, j, iMostPrivileged;

                for (i = 0, iMostPrivileged = 0; i < (INT)dwEntriesRead; i++)
                {
                    for (j = ARRAYSIZE(g_groupname_map)-1; j > 0; j--)
                    {
                        if (lstrcmpiW(plgi0[i].lgrpi0_name, g_groupname_map[j].pwszActualGroupName) == 0)
                        {
                            break;
                        }
                    }

                    iMostPrivileged = (iMostPrivileged > j) ? iMostPrivileged : j;
                }

                _iPrivilegeLevel = iMostPrivileged;

                nasRet = NetApiBufferFree((LPVOID)plgi0);
            }
            hr = HRESULT_FROM_WIN32(nasRet);
        }

        if (-1 != _iPrivilegeLevel)
        {
            pvar->vt = VT_I4;
            pvar->lVal = _iPrivilegeLevel;
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_PutAccountType(VARIANT var)
{
    HRESULT hr;

    hr = VariantChangeType(&var, &var, 0, VT_I4);

    if (SUCCEEDED(hr))
    {
        if (var.lVal < 0 || var.lVal >= ARRAYSIZE(g_groupname_map))
        {
            hr = E_INVALIDARG;
        }
        else if (var.lVal != _iPrivilegeLevel)
        {
            NET_API_STATUS nasRet;
            TCHAR szDomainAndName[256];
            LOCALGROUP_MEMBERS_INFO_3 lgrmi3;

            // First add the user to their new group

            hr = StringCchPrintf(szDomainAndName, 
                                 ARRAYSIZE(szDomainAndName), 
                                 TEXT("%s\\%s"),
                                 _szDomain,
                                 _szLoginName);
            if (SUCCEEDED(hr))
            {
                lgrmi3.lgrmi3_domainandname = szDomainAndName;

                nasRet = NetLocalGroupAddMembers(NULL,
                                                 g_groupname_map[var.lVal].pwszActualGroupName,
                                                 3,
                                                 (LPBYTE)&lgrmi3,
                                                 1);

                // If we were successful in adding to the group or 
                // they were already in the group ...
                if ((nasRet == NERR_Success) || (nasRet == ERROR_MEMBER_IN_ALIAS))
                {
                    // remember the new privilege level
                    _iPrivilegeLevel = var.lVal;

                    // remove them from all more-privileged groups

                    for (int i = var.lVal+1; i < ARRAYSIZE(g_groupname_map); i++)
                    {
                        // "Power Users" doesn't exist on Personal, so this will
                        // fail sometimes.

                        NetLocalGroupDelMembers(NULL,
                                                g_groupname_map[i].pwszActualGroupName,
                                                3,
                                                (LPBYTE)&lgrmi3,
                                                1);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(nasRet);
                }
            }
        }
    }

    return hr;
}

HRESULT CLogonUser::_LookupUserSid()
{
    HRESULT hr;

    if (NULL == _pszSID)
    {
        BYTE rgSidBuffer[sizeof(SID) + (SID_MAX_SUB_AUTHORITIES-1)*sizeof(ULONG)];
        PSID pSid = (PSID)rgSidBuffer;
        DWORD cbSid = sizeof(rgSidBuffer);
        TCHAR szDomainName[MAX_PATH];
        DWORD cbDomainName = ARRAYSIZE(szDomainName);
        SID_NAME_USE snu;

        if (LookupAccountName(
                        (TEXT('\0') != _szDomain[0]) ? _szDomain : NULL,
                        _szLoginName,
                        pSid,
                        &cbSid,
                        szDomainName,
                        &cbDomainName,
                        &snu))
        {
            ConvertSidToStringSid(pSid, &_pszSID);
        }
    }

    if (NULL == _pszSID)
    {
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CLogonUser::_GetSID(VARIANT* pvar)
{
    HRESULT hr;

    if (pvar)
    {
        hr = _LookupUserSid();

        if (NULL != _pszSID)
        {
            pvar->vt = VT_BSTR;
            pvar->bstrVal = SysAllocString(_pszSID);
            hr = pvar->bstrVal ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

DWORD   CLogonUser::_GetExpiryDays (HKEY hKeyCurrentUser)

{
    DWORD   dwDays;
    DWORD   dwDataType;
    DWORD   dwData;
    DWORD   dwDataSize;
    HKEY    hKey;

    static  const TCHAR     s_szBaseKeyName[]               =   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\UnreadMail");
    static  const TCHAR     s_szMessageExpiryValueName[]    =   TEXT("MessageExpiryDays");

    dwDays = 3;
    if (RegOpenKeyEx(hKeyCurrentUser,
                     s_szBaseKeyName,
                     0,
                     KEY_QUERY_VALUE,
                     &hKey) == ERROR_SUCCESS)
    {
        dwDataSize = sizeof(dwData);
        if ((RegQueryValueEx(hKey,
                             s_szMessageExpiryValueName,
                             NULL,
                             &dwDataType,
                             (LPBYTE)&dwData,
                             &dwDataSize) == ERROR_SUCCESS) &&
            (dwDataType == REG_DWORD)                       &&
            (dwData <= 30))
        {
            dwDays = dwData;
        }
        TBOOL(RegCloseKey(hKey));
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      s_szBaseKeyName,
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hKey))
    {
        dwDataSize = sizeof(dwData);
        if ((RegQueryValueEx(hKey,
                             s_szMessageExpiryValueName,
                             NULL,
                             &dwDataType,
                             (LPBYTE)&dwData,
                             &dwDataSize) == ERROR_SUCCESS) &&
            (dwDataType == REG_DWORD)                       &&
            (dwData <= 30))
        {
            dwDays = dwData;
        }
        TBOOL(RegCloseKey(hKey));
    }

    return dwDays;
}

STDMETHODIMP CLogonUser::getMailAccountInfo(UINT uiAccountIndex, VARIANT *pvarAccountName, UINT *pcUnreadMessages)
{
    HRESULT hr;

    DWORD   dwComputerNameSize;
    TCHAR   szComputerName[CNLEN + sizeof('\0')];

    hr = E_FAIL;

    //  Only do this for local computer accounts.

    dwComputerNameSize = ARRAYSIZE(szComputerName);
    if ((GetComputerName(szComputerName, &dwComputerNameSize) != FALSE) &&
        (lstrcmpi(szComputerName, _szDomain) == 0))
    {
        CUserProfile    profile(_szLoginName, _szDomain);

        if (static_cast<HKEY>(profile) != NULL)
        {
            DWORD   dwCount;
            TCHAR   szMailAccountName[100];

            hr = SHEnumerateUnreadMailAccounts(profile, uiAccountIndex, szMailAccountName, ARRAYSIZE(szMailAccountName));
            if (SUCCEEDED(hr))
            {
                if (pvarAccountName)
                {
                    pvarAccountName->vt = VT_BSTR;
                    pvarAccountName->bstrVal = SysAllocString(szMailAccountName);
                    hr = pvarAccountName->bstrVal ? S_OK : E_OUTOFMEMORY;
                }

                if (SUCCEEDED(hr) && pcUnreadMessages)
                {
                    FILETIME ft, ftCurrent;
                    SYSTEMTIME st;

                    BOOL ftExpired = false;
                    DWORD dwExpiryDays = _GetExpiryDays(profile);

                    hr = SHGetUnreadMailCount(profile, szMailAccountName, &dwCount, &ft, NULL, 0);
                    IncrementFILETIME(&ft, FT_ONEDAY * dwExpiryDays);
                    GetLocalTime(&st);
                    SystemTimeToFileTime(&st, &ftCurrent);

                    ftExpired = ((CompareFileTime(&ft, &ftCurrent) < 0) || (dwExpiryDays == 0));

                    if (SUCCEEDED(hr) && !ftExpired)
                    {
                        *pcUnreadMessages = dwCount;
                    }
                    else
                    {
                        *pcUnreadMessages = 0;
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CLogonUser::_GetUnreadMail(VARIANT* pvar)
{
    HRESULT hr;

    if (pvar)
    {
        DWORD   dwComputerNameSize;
        TCHAR   szComputerName[CNLEN + sizeof('\0')];

        hr = E_FAIL;

        //  Only do this for local computer accounts.

        dwComputerNameSize = ARRAYSIZE(szComputerName);
        if ((GetComputerName(szComputerName, &dwComputerNameSize) != FALSE) &&
            (lstrcmpi(szComputerName, _szDomain) == 0))
        {
            CUserProfile    profile(_szLoginName, _szDomain);

            if (static_cast<HKEY>(profile) != NULL)
            {
                DWORD   dwCount;
                FILETIME ftFilter;
                SYSTEMTIME st;
                DWORD dwExpiryDays = _GetExpiryDays(profile);

                GetLocalTime(&st);
                SystemTimeToFileTime(&st, &ftFilter);
                DecrementFILETIME(&ftFilter, FT_ONEDAY * dwExpiryDays);

                hr = SHGetUnreadMailCount(profile, NULL, &dwCount, &ftFilter, NULL, 0);
                if (SUCCEEDED(hr) && (dwExpiryDays != 0))
                {
                    pvar->vt = VT_UI4;
                    pvar->uintVal = dwCount;
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_InitPicture()
{
    HRESULT hr;
    
    hr = StringCchCopy(_szPicture, ARRAYSIZE(_szPicture), TEXT("file://"));
    if (SUCCEEDED(hr))
    {
        TCHAR szTemp[MAX_PATH];

        hr = SHGetUserPicturePath(_szLoginName, SHGUPP_FLAG_CREATE, szTemp);
        if (SUCCEEDED(hr))
        {
            hr = StringCchCat(_szPicture, ARRAYSIZE(_szPicture), szTemp);
        }
    }

    if (FAILED(hr))
    {
        _szPicture[0] = TEXT('\0');
    }

    return hr;
}


HRESULT CLogonUser::_SetPicture(LPCTSTR pszNewPicturePath)
{
    //  use shell32!SHSetUserPicturePath to set the user's
    //  picture path. If this is successful then update the
    //  _szPicture member variable.

    HRESULT hr = SHSetUserPicturePath(_szLoginName, 0, pszNewPicturePath);
    if ( S_OK == hr )
    {
        DWORD dwErr;
        HKEY  hkUserHint;

        SysFreeString(_strPictureSource);
        _strPictureSource = SysAllocString(pszNewPicturePath);

        dwErr = _OpenUserHintKey(KEY_SET_VALUE, &hkUserHint);

        if ( dwErr == ERROR_SUCCESS )
        {
            if (pszNewPicturePath)
            {
                DWORD cbData = lstrlen(pszNewPicturePath) * sizeof(TCHAR) + sizeof(TEXT('\0'));
                dwErr = RegSetValueEx(hkUserHint,
                                      c_szPictureSrcVal,
                                      0,
                                      REG_SZ,
                                      (LPBYTE)pszNewPicturePath,
                                      cbData);
            }
            else
            {
                dwErr = RegDeleteValue(hkUserHint, c_szPictureSrcVal);
            }

            RegCloseKey(hkUserHint);
        }

        hr = StringCchCopy(_szPicture,  ARRAYSIZE(_szPicture), TEXT("file://"));
        if (SUCCEEDED(hr))
        {
            TCHAR szTemp[MAX_PATH];

            hr = SHGetUserPicturePath(_szLoginName, 0, szTemp);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCat(_szPicture, ARRAYSIZE(_szPicture), szTemp);
            }
        }

        if (FAILED(hr))
        {
            hr = StringCchCopy(_szPicture, ARRAYSIZE(_szPicture), pszNewPicturePath);
        }
    }

    return hr;
}


DWORD CLogonUser::_OpenUserHintKey(REGSAM sam, HKEY *phkey)
{
    DWORD dwErr;
    TCHAR szHintKey[MAX_PATH];

    // We have to store hint information under HKLM so the logon page can
    // access it, Also, we want to allow non-admins to change their own
    // hints, but non-admins can't write values under HKLM by default.
    //
    // The solution is to use subkeys rather than named values so we can
    // tweak the ACLs on a per-user basis.
    //
    // A non-admin user needs the ability to do 2 things:
    // 1. Create a hint subkey for themselves if one does not exist.
    // 2. Modify the hint contained in their subkey if one already exists.
    //
    // At install time, we set the ACL on the Hints key to allow
    // Authenticated Users KEY_CREATE_SUB_KEY access. Thus, a user is
    // able to create a hint for themselves if one doesn't exist.
    //
    // Immediately after creating a hint subkey, whether it was created
    // by the target user or an admin, we grant the target user
    // KEY_SET_VALUE access to the subkey. This ensures that a user can
    // modify their own hint no matter who created it for them.
    //
    // Note that we don't call RegCreateKeyEx or SHSetValue since we
    // don't want the key to be automatically created here.
    //
    // Note that admins are able to create and modify hints for any user,
    // but a non-admin is only able to create or modify their own hint.

    // First assume the hint already exists and just try to open it.
    if (PathCombine(szHintKey, c_szRegRoot, _szLoginName))
    {
        dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            szHintKey,
                            0,
                            sam,
                            phkey);
        if ( dwErr == ERROR_FILE_NOT_FOUND )
        {
            HKEY hkHints;

            // The hint subkey doesn't exist yet for this user.
            // Try to create one.

            // Open the Hints key for KEY_CREATE_SUB_KEY
            dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                c_szRegRoot,
                                0,
                                KEY_CREATE_SUB_KEY,
                                &hkHints);
            if (dwErr == ERROR_SUCCESS)
            {
                // Create a subkey for this user
                dwErr = RegCreateKeyEx(hkHints,
                                       _szLoginName,
                                       0,
                                       NULL,
                                       0,
                                       sam,
                                       NULL,
                                       phkey,
                                       NULL);
                if (dwErr == ERROR_SUCCESS)
                {
                    // Grant KEY_SET_VALUE access to the user so they can
                    // change their own hint.
                    _LookupUserSid();
                    if (NULL != _pszSID)
                    {
                        TCHAR szKey[MAX_PATH];
                        TCHAR szSD[MAX_PATH];

                        if (PathCombine(szKey, TEXT("MACHINE"), szHintKey)  &&
                            SUCCEEDED(StringCchPrintf(szSD,
                                                      ARRAYSIZE(szSD),
                                                      TEXT("D:(A;;0x2;;;%s)"),  // 0x2 = KEY_SET_VALUE
                                                      _pszSID)))
                        {
                            if (!SetDacl(szKey, SE_REGISTRY_KEY, szSD))
                            {
                                dwErr = GetLastError();
                            }
                        }
                        else
                        {
                            dwErr = ERROR_INSUFFICIENT_BUFFER;
                        }
                    }
                    else
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                RegCloseKey(hkHints);
            }
        }
    }
    else
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
    }

    return dwErr;
}


STDMETHODIMP CLogonUser::get_isPasswordResetAvailable(VARIANT_BOOL* pbResetAvailable)
{
    DWORD dwResult;

    if (!pbResetAvailable)
        return E_POINTER;

    *pbResetAvailable = VARIANT_FALSE;

    if (0 == PRQueryStatus(NULL, _szLoginName, &dwResult))
    {
        if (0 == dwResult)
        {
            *pbResetAvailable = VARIANT_TRUE;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\cinteractivelogon.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CInteractiveLogon.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that implements encapsulation of interactive logon information.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

#include "priv.h"
#include "CInteractiveLogon.h"

#include <winsta.h>

#include "GinaIPC.h"
#include "TokenInformation.h"
#include "UIHostIPC.h"

const TCHAR     CInteractiveLogon::s_szEventReplyName[]     =   TEXT("shgina: InteractiveLogonRequestReply");
const TCHAR     CInteractiveLogon::s_szEventSignalName[]    =   TEXT("shgina: InteractiveLogonRequestSignal");
const TCHAR     CInteractiveLogon::s_szSectionName[]        =   TEXT("shgina: InteractiveLogonRequestSection");

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::CRequestData
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CRequestData.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::CRequestData::CRequestData (void)

{
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::~CRequestData
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CRequestData.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::CRequestData::~CRequestData (void)

{
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::Set
//
//  Arguments:  pszUsername     =   Username.
//              pszDomain       =   Domain.
//              pszPassword     =   Password.
//
//  Returns:    <none>
//
//  Purpose:    Sets the information into the section object. Makes the data
//              valid by signing it with a 4-byte signature.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::CRequestData::Set (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword)

{
    UNICODE_STRING  passwordString;

    _ulMagicNumber = MAGIC_NUMBER;
    _dwErrorCode = ERROR_ACCESS_DENIED;

    StringCchCopy(_szEventReplyName, ARRAYSIZE(s_szEventReplyName), s_szEventReplyName);
    StringCchCopy(_szUsername, ARRAYSIZE(_szUsername), pszUsername);
    StringCchCopy(_szDomain, ARRAYSIZE(_szDomain), pszDomain);

    // REVIEW (jeffreys) I think the 127 char limit is bogus. I don't
    // agree with comments in logonipc.cpp.
    StringCchCopyNEx(_szPassword, ARRAYSIZE(_szPassword), pszPassword, 127, NULL, NULL, STRSAFE_FILL_BEHIND_NULL);
    ZeroMemory(pszPassword, (lstrlen(pszPassword) + 1) * sizeof(WCHAR));

    _iPasswordLength = lstrlen(_szPassword);

    passwordString.Buffer = _szPassword;
    passwordString.Length = (USHORT)(_iPasswordLength * sizeof(WCHAR));
    passwordString.MaximumLength = sizeof(_szPassword);

    _ucSeed = 0;
    RtlRunEncodeUnicodeString(&_ucSeed, &passwordString);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::Get
//
//  Arguments:  pszUsername     =   Username (returned).
//              pszDomain       =   Domain (returned).
//              pszPassword     =   Password (clear-text) returned.
//
//  Returns:    DWORD
//
//  Purpose:    Extracts the information transmitted in the section across
//              sessions in the receiving process' context. Checks the
//              signature written by Set.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CRequestData::Get (WCHAR *pszUsername, size_t cchUsername, WCHAR *pszDomain, size_t cchDomain, WCHAR *pszPassword, size_t cchPassword)  const

{
    DWORD   dwErrorCode;

    if (_ulMagicNumber == MAGIC_NUMBER)
    {
        if (cchPassword < ((UINT)_iPasswordLength + 1) ||
            FAILED(StringCchCopy(pszUsername, cchUsername, _szUsername)) ||
            FAILED(StringCchCopy(pszDomain, cchDomain, _szDomain)))
        {
            dwErrorCode = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            UNICODE_STRING  passwordString;

            CopyMemory(pszPassword, _szPassword, (_iPasswordLength + 1) * sizeof(WCHAR));
            passwordString.Buffer = pszPassword;
            passwordString.Length = (USHORT)(_iPasswordLength * sizeof(WCHAR));
            passwordString.MaximumLength = (USHORT)(cchPassword * sizeof(WCHAR));

            RtlRunDecodeUnicodeString(_ucSeed, &passwordString);
            pszPassword[_iPasswordLength] = L'\0';

            dwErrorCode = ERROR_SUCCESS;
        }
    }
    else
    {
        dwErrorCode = ERROR_INVALID_PARAMETER;
    }

    return dwErrorCode;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::SetErrorCode
//
//  Arguments:  dwErrorCode     =   Error code to set.
//
//  Returns:    DWORD
//
//  Purpose:    Sets the error code into the section.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::CRequestData::SetErrorCode (DWORD dwErrorCode)

{
    _dwErrorCode = dwErrorCode;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::GetErrorCode
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns the error code from the section.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CRequestData::GetErrorCode (void)     const

{
    return(_dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::OpenEventReply
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens a handle to the reply event. The reply event is named
//              in the section object.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::CRequestData::OpenEventReply (void)   const

{
    return(OpenEvent(EVENT_MODIFY_STATE, FALSE, _szEventReplyName));
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CInteractiveLogon
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CInteractiveLogon. Create a thread to wait
//              on the auto-reset event signaled on an external request. This
//              thread is cleaned up on object destruction and also on
//              process termination.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::CInteractiveLogon (void) :
    _hThread(NULL),
    _fContinue(true),
    _hwndHost(NULL)

{
    Start();
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::~CInteractiveLogon
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Terminate the wait thread. Queue an APC to set the member
//              variable to end the termination. The wait is satisfied and
//              returns (WAIT_IO_COMPLETION). The loop is exited and the
//              thread is exited.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::~CInteractiveLogon (void)

{
    Stop();
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::Start
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Create the thread that listens on interactive logon requests.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::Start (void)

{
    if (_hThread == NULL)
    {
        DWORD   dwThreadID;

        _hThread = CreateThread(NULL,
                                0,
                                CB_ThreadProc,
                                this,
                                0,
                                &dwThreadID);
    }
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::Stop
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Stop the thread that listens on interactive logon requests.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::Stop (void)

{
    HANDLE  hThread;

    hThread = InterlockedExchangePointer(&_hThread, NULL);
    if (hThread != NULL)
    {
        if (QueueUserAPC(CB_APCProc, hThread, reinterpret_cast<ULONG_PTR>(this)) != FALSE)
        {
            (DWORD)WaitForSingleObject(hThread, INFINITE);
        }
        TBOOL(CloseHandle(hThread));
    }
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::SetHostWindow
//
//  Arguments:  hwndHost    =   HWND of the actual UI host.
//
//  Returns:    <none>
//
//  Purpose:    Sets the HWND into the member variable so that the message
//              can be sent directly to the UI host rather than the status
//              host which is a go-between.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::SetHostWindow (HWND hwndHost)

{
    _hwndHost = hwndHost;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::Initiate
//
//  Arguments:  pszUsername     =   User name.
//              pszDomain       =   Domain.
//              pszPassword     =   Password.
//              dwTimeout       =   Timeout value.
//
//  Returns:    DWORD
//
//  Purpose:    External entry point implementing interactive logon requests.
//              This function checks for privileges and mutexes and events
//              and does the right thing.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::Initiate (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword, DWORD dwTimeout)

{
    DWORD   dwErrorCode;

    dwErrorCode = CheckInteractiveLogonAllowed(dwTimeout);
    if (ERROR_SUCCESS == dwErrorCode)
    {
        HANDLE  hToken;

        //  First authenticate the user with the given credentials for an
        //  interactive logon. Go no further unless that's valid.

        dwErrorCode = CTokenInformation::LogonUser(pszUsername,
                                                   pszDomain,
                                                   pszPassword,
                                                   &hToken);
        if (ERROR_SUCCESS == dwErrorCode)
        {
            HANDLE  hMutex;

            hMutex = OpenMutex(SYNCHRONIZE | MUTEX_MODIFY_STATE, FALSE, SZ_INTERACTIVE_LOGON_REQUEST_MUTEX_NAME);
            if (hMutex != NULL)
            {
                dwErrorCode = WaitForSingleObject(hMutex, dwTimeout);
                if (WAIT_OBJECT_0 == dwErrorCode)
                {
                    DWORD   dwSessionID, dwUserSessionID;
                    HANDLE  hEvent;

                    //  User is authenticated correctly. There are several cases
                    //  that need to be handled.

                    dwSessionID = USER_SHARED_DATA->ActiveConsoleId;

                    //  Determine if the session has the welcome screen displayed
                    //  by opening the named signal event for the session.

                    hEvent = OpenSessionNamedSignalEvent(dwSessionID);
                    if (hEvent != NULL)
                    {
                        TBOOL(CloseHandle(hEvent));
                        dwErrorCode = SendRequest(pszUsername, pszDomain, pszPassword);
                    }
                    else
                    {

                        //  Do whatever needs to be done to log the user on.

                        if (FoundUserSessionID(hToken, &dwUserSessionID))
                        {
                            if (dwUserSessionID == dwSessionID)
                            {

                                //  User is the active console session. No further work needs
                                //  to be done. Return success.

                                dwErrorCode = ERROR_SUCCESS;
                            }
                            else
                            {

                                //  User is disconnected. Reconnect back to the user session.
                                //  If that fails then return the error code back.

                                if (WinStationConnect(SERVERNAME_CURRENT,
                                                      dwUserSessionID,
                                                      USER_SHARED_DATA->ActiveConsoleId,
                                                      L"",
                                                      TRUE) != FALSE)
                                {
                                    dwErrorCode = ERROR_SUCCESS;
                                }
                                else
                                {
                                    dwErrorCode = GetLastError();
                                }
                            }
                        }
                        else
                        {
                            HANDLE  hEvent;
                            
                            hEvent = CreateEvent(NULL, TRUE, FALSE, SZ_INTERACTIVE_LOGON_REPLY_EVENT_NAME);
                            if (hEvent != NULL)
                            {

                                //  User has no session. If at the welcome screen then send the
                                //  request to the welcome screen. Otherwise disconnect the
                                //  current session and use a new session to log the user on.

                                dwErrorCode = ShellStartCredentialServer(pszUsername, pszDomain, pszPassword, dwTimeout);
                                if (ERROR_SUCCESS == dwErrorCode)
                                {
                                    dwErrorCode = WaitForSingleObject(hEvent, dwTimeout);
                                }
                                TBOOL(CloseHandle(hEvent));
                            }
                            else
                            {
                                dwErrorCode = GetLastError();
                            }
                        }
                    }
                    TBOOL(ReleaseMutex(hMutex));
                }
                TBOOL(CloseHandle(hMutex));
            }
            TBOOL(CloseHandle(hToken));
        }
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CheckInteractiveLogonAllowed
//
//  Arguments:  dwTimeout   =   Timeout value.
//
//  Returns:    DWORD
//
//  Purpose:    Check whether the interactive logon request is allowed. To
//              make this call:
//
//              1. You must have SE_TCB_PRIVILEGE.
//              2. There must be an active console session ID that's valid.
//              3. The machine must not be shutting down.
//              4. The logon mutex must be available.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CheckInteractiveLogonAllowed (DWORD dwTimeout)

{
    DWORD   dwErrorCode;

    //  1. Check for trusted call (SE_TCB_PRIVILEGE).

    if (SHTestTokenPrivilege(NULL, SE_TCB_NAME) != FALSE)
    {

        //  2. Check for active console session.

        if (USER_SHARED_DATA->ActiveConsoleId != static_cast<DWORD>(-1))
        {

            //  3. Check for machine shutdown.

            dwErrorCode = CheckShutdown();
            if (ERROR_SUCCESS == dwErrorCode)
            {

                //  4. Check for mutex availability.

                dwErrorCode = CheckMutex(dwTimeout);
            }
        }
        else
        {
            dwErrorCode = ERROR_NOT_READY;
        }
    }
    else
    {
        dwErrorCode = ERROR_PRIVILEGE_NOT_HELD;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CheckShutdown
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns an error code indicating if the machine is shutting
//              down or not. If the event cannot be opened then the request
//              is rejected.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CheckShutdown (void)

{
    DWORD   dwErrorCode;
    HANDLE  hEvent;

    hEvent = OpenEvent(SYNCHRONIZE, FALSE, SZ_SHUT_DOWN_EVENT_NAME);
    if (hEvent != NULL)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 0))
        {
            dwErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
        }
        else
        {
            dwErrorCode = ERROR_SUCCESS;
        }
        TBOOL(CloseHandle(hEvent));
    }
    else
    {
        dwErrorCode = GetLastError();
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CheckMutex
//
//  Arguments:  dwTimeout   =   Timeout value.
//
//  Returns:    DWORD
//
//  Purpose:    Attempts to grab the logon mutex. This ensures that the state
//              of winlogon is known and it's not busy processing a request.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CheckMutex (DWORD dwTimeout)

{
    DWORD   dwErrorCode;
    HANDLE  hMutex;

    hMutex = OpenMutex(SYNCHRONIZE, FALSE, SZ_INTERACTIVE_LOGON_MUTEX_NAME);
    if (hMutex != NULL)
    {
        dwErrorCode = WaitForSingleObject(hMutex, dwTimeout);
        if ((WAIT_OBJECT_0 == dwErrorCode) || (WAIT_ABANDONED == dwErrorCode))
        {
            TBOOL(ReleaseMutex(hMutex));
            dwErrorCode = ERROR_SUCCESS;
        }
    }
    else
    {
        dwErrorCode = GetLastError();
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::FoundUserSessionID
//
//  Arguments:  hToken          =   Token of user session to find.
//              pdwSessionID    =   Returned session ID.
//
//  Returns:    bool
//
//  Purpose:    Looks for a user session based on a given token. The match
//              is made by user SID.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

bool    CInteractiveLogon::FoundUserSessionID (HANDLE hToken, DWORD *pdwSessionID)

{
    bool        fResult;
    PLOGONID    pLogonIDs;
    ULONG       ulEntries;

    fResult = false;
    if (WinStationEnumerate(SERVERNAME_CURRENT, &pLogonIDs, &ulEntries) != FALSE)
    {
        ULONG       ulIndex;
        PLOGONID    pLogonID;

        for (ulIndex = 0, pLogonID = pLogonIDs; !fResult && (ulIndex < ulEntries); ++ulIndex, ++pLogonID)
        {
            if ((pLogonID->State == State_Active) || (pLogonID->State == State_Disconnected))
            {
                ULONG                   ulReturnLength;
                WINSTATIONUSERTOKEN     winStationUserToken;

                winStationUserToken.ProcessId = ULongToHandle(GetCurrentProcessId());
                winStationUserToken.ThreadId = ULongToHandle(GetCurrentThreadId());
                winStationUserToken.UserToken = NULL;
                if (WinStationQueryInformation(SERVERNAME_CURRENT,
                                               pLogonID->SessionId,
                                               WinStationUserToken,
                                               &winStationUserToken,
                                               sizeof(winStationUserToken),
                                               &ulReturnLength) != FALSE)
                {
                    fResult = CTokenInformation::IsSameUser(hToken, winStationUserToken.UserToken);
                    if (fResult)
                    {
                        *pdwSessionID = pLogonID->SessionId;
                    }
                    TBOOL(CloseHandle(winStationUserToken.UserToken));
                }
            }
        }

        //  Free any resources used.

        (BOOLEAN)WinStationFreeMemory(pLogonIDs);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::SendRequest
//
//  Arguments:  pszUsername     =   Username.
//              pszDomain       =   Domain.
//              pszPassword     =   Password. This string must be writable.
//
//  Returns:    DWORD
//
//  Purpose:    This function knows how to transmit the interactive logon
//              request from (presumably) session 0 to whatever session is
//              the active console session ID.
//
//              pszUsername must be UNLEN + sizeof('\0') characters.
//              pszDomain must be DNLEN + sizeof('\0') characters.
//              pszPassword must be PWLEN + sizeof('\0') characters.
//
//              pszPassword must be writable. The password is copied and
//              encoded and erased from the source buffer.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::SendRequest (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword)

{
    DWORD   dwErrorCode, dwActiveConsoleID;
    HANDLE  hEventReply;

    dwErrorCode = ERROR_ACCESS_DENIED;

    //  First get the active console session ID.

    dwActiveConsoleID = USER_SHARED_DATA->ActiveConsoleId;

    //  Create a named event in that session named object space.

    hEventReply = CreateSessionNamedReplyEvent(dwActiveConsoleID);
    if (hEventReply != NULL)
    {
        HANDLE  hEventSignal;

        hEventSignal = OpenSessionNamedSignalEvent(dwActiveConsoleID);
        if (hEventSignal != NULL)
        {
            HANDLE  hSection;

            //  Create a named section that the UI host will open. This code
            //  is executed in the service context so it's always on session 0.

            hSection = CreateSessionNamedSection(dwActiveConsoleID);
            if (hSection != NULL)
            {
                void    *pV;

                //  Map the section into this process address space so we can put
                //  stuff it in.

                pV = MapViewOfFile(hSection,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0);
                if (pV != NULL)
                {
                    __try
                    {
                        DWORD           dwWaitResult;
                        CRequestData    *pRequestData;

                        //  Fill the section data with the information given.

                        pRequestData = static_cast<CRequestData*>(pV);
                        pRequestData->Set(pszUsername, pszDomain, pszPassword);

                        //  Wake up the waiting thread in the UI host.

                        TBOOL(SetEvent(hEventSignal));

                        //  Wait 15 seconds for a reply the UI host.

                        dwWaitResult = WaitForSingleObject(hEventReply, 15000);

                        //  Return an error code accordingly.

                        if (WAIT_OBJECT_0 == dwWaitResult)
                        {
                            dwErrorCode = pRequestData->GetErrorCode();
                        }
                        else
                        {
                            dwErrorCode = dwWaitResult;
                        }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        dwErrorCode = ERROR_OUTOFMEMORY;
                    }
                    TBOOL(UnmapViewOfFile(pV));
                }
                TBOOL(CloseHandle(hSection));
            }
            TBOOL(CloseHandle(hEventSignal));
        }
        TBOOL(CloseHandle(hEventReply));
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::FormulateObjectBasePath
//
//  Arguments:  dwSessionID     =   Session ID of the named object space.
//              pszObjectPath   =   Buffer to receive path.
//              cchObjecPath    =   Count of characters in buffer
//
//  Returns:    <none>
//
//  Purpose:    Creates the correct path to the named object space for the
//              given session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HRESULT    CInteractiveLogon::FormulateObjectBasePath (DWORD dwSessionID, WCHAR *pszObjectPath, size_t cchObjectPath)

{
    HRESULT hr;

    if (dwSessionID == 0)
    {
        hr = StringCchCopyW(pszObjectPath, cchObjectPath, L"\\BaseNamedObjects\\");
    }
    else
    {
        hr = StringCchPrintfW(pszObjectPath, cchObjectPath, L"\\Sessions\\%d\\BaseNamedObjects\\", dwSessionID);
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CreateSessionNamedReplyEvent
//
//  Arguments:  dwSessionID     =   Session ID.
//
//  Returns:    HANDLE
//
//  Purpose:    Creates the named reply event in the target session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::CreateSessionNamedReplyEvent (DWORD dwSessionID)

{
    HANDLE              hEvent = NULL;
    UNICODE_STRING      eventName;
    WCHAR               szEventName[128];

    if (SUCCEEDED(FormulateObjectBasePath(dwSessionID, szEventName, ARRAYSIZE(szEventName)))    &&
        SUCCEEDED(StringCchCat(szEventName, ARRAYSIZE(szEventName), s_szEventReplyName))        &&
        NT_SUCCESS(RtlInitUnicodeStringEx(&eventName, szEventName)))
    {
        OBJECT_ATTRIBUTES   objectAttributes;

        InitializeObjectAttributes(&objectAttributes,
                                   &eventName,
                                   0,
                                   NULL,
                                   NULL);
        NtCreateEvent(&hEvent,
                      EVENT_ALL_ACCESS,
                      &objectAttributes,
                      SynchronizationEvent,
                      FALSE);
    }

    return hEvent;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::OpenSessionNamedSignalEvent
//
//  Arguments:  dwSessionID     =   Session ID.
//
//  Returns:    HANDLE
//
//  Purpose:    Opens the named signal event in the target session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::OpenSessionNamedSignalEvent (DWORD dwSessionID)

{
    HANDLE              hEvent = NULL;
    UNICODE_STRING      eventName;
    WCHAR               szEventName[128];

    if (SUCCEEDED(FormulateObjectBasePath(dwSessionID, szEventName, ARRAYSIZE(szEventName)))    &&
        SUCCEEDED(StringCchCat(szEventName, ARRAYSIZE(szEventName), s_szEventSignalName))       &&
        NT_SUCCESS(RtlInitUnicodeStringEx(&eventName, szEventName)))
    {
        OBJECT_ATTRIBUTES   objectAttributes;

        InitializeObjectAttributes(&objectAttributes,
                                   &eventName,
                                   0,
                                   NULL,
                                   NULL);
        NtOpenEvent(&hEvent,
                    EVENT_MODIFY_STATE,
                    &objectAttributes);
    }

    return hEvent;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CreateSessionNamedSection
//
//  Arguments:  dwSessionID     =   Session ID.
//
//  Returns:    HANDLE
//
//  Purpose:    Creates a named section object in the target session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::CreateSessionNamedSection (DWORD dwSessionID)

{
    HANDLE              hSection = NULL;
    UNICODE_STRING      sectionName;
    WCHAR               szSectionName[128];

    if (SUCCEEDED(FormulateObjectBasePath(dwSessionID, szSectionName, ARRAYSIZE(szSectionName)))    &&
        SUCCEEDED(StringCchCat(szSectionName, ARRAYSIZE(szSectionName), s_szSectionName))           &&
        NT_SUCCESS(RtlInitUnicodeStringEx(&sectionName, szSectionName)))
    {
        OBJECT_ATTRIBUTES   objectAttributes;
        LARGE_INTEGER       sectionSize;

        InitializeObjectAttributes(&objectAttributes,
                                   &sectionName,
                                   0,
                                   NULL,
                                   NULL);

        sectionSize.LowPart = sizeof(CRequestData);
        sectionSize.HighPart = 0;
        
        NtCreateSection(&hSection,
                        STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_WRITE | SECTION_MAP_READ,
                        &objectAttributes,
                        &sectionSize,
                        PAGE_READWRITE,
                        SEC_COMMIT,
                        NULL);
    }

    return hSection;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::WaitForInteractiveLogonRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Thread that executes in the UI host context of the receiving
//              session. This thread waits in an alertable state for the
//              signal event. If the event is signaled it does work to log the
//              specified user on.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::WaitForInteractiveLogonRequest (void)

{
    HANDLE  hEvent;

    // null SA ok, since we run as part of system
    hEvent = CreateEvent(NULL,
                         FALSE,
                         FALSE,
                         s_szEventSignalName);
    if (hEvent != NULL)
    {
        DWORD   dwWaitResult;

        while (_fContinue)
        {
            dwWaitResult = WaitForSingleObjectEx(hEvent, INFINITE, TRUE);
            if (WAIT_OBJECT_0 == dwWaitResult)
            {
                HANDLE  hSection;

                hSection = OpenFileMapping(FILE_MAP_WRITE,
                                           FALSE,
                                           s_szSectionName);
                if (hSection != NULL)
                {
                    void    *pV;

                    pV = MapViewOfFile(hSection,
                                       FILE_MAP_READ,
                                       0,
                                       0,
                                       0);
                    if (pV != NULL)
                    {
                        __try
                        {
                            DWORD                       dwErrorCode;
                            HANDLE                      hEventReply;
                            CRequestData                *pRequestData;
                            INTERACTIVE_LOGON_REQUEST   interactiveLogonRequest;

                            pRequestData = static_cast<CRequestData*>(pV);
                            hEventReply = pRequestData->OpenEventReply();
                            if (hEventReply != NULL)
                            {
                                dwErrorCode = pRequestData->Get(interactiveLogonRequest.szUsername,
                                                                ARRAYSIZE(interactiveLogonRequest.szUsername),
                                                                interactiveLogonRequest.szDomain,
                                                                ARRAYSIZE(interactiveLogonRequest.szDomain),
                                                                interactiveLogonRequest.szPassword,
                                                                ARRAYSIZE(interactiveLogonRequest.szPassword));
                                if (ERROR_SUCCESS == dwErrorCode)
                                {
                                    dwErrorCode = static_cast<DWORD>(SendMessage(_hwndHost, WM_UIHOSTMESSAGE, HM_INTERACTIVE_LOGON_REQUEST, reinterpret_cast<LPARAM>(&interactiveLogonRequest)));
                                }
                                pRequestData->SetErrorCode(dwErrorCode);
                                TBOOL(SetEvent(hEventReply));
                                TBOOL(CloseHandle(hEventReply));
                            }
                            else
                            {
                                dwErrorCode = GetLastError();
                                pRequestData->SetErrorCode(dwErrorCode);
                            }
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                        TBOOL(UnmapViewOfFile(pV));
                    }
                    TBOOL(CloseHandle(hSection));
                }
            }
            else
            {
                ASSERTMSG((WAIT_FAILED == dwWaitResult) || (WAIT_IO_COMPLETION == dwWaitResult), "Unexpected result from kernel32!WaitForSingleObjectEx in CInteractiveLogon::WaitForInteractiveLogonRequest");
                _fContinue = false;
            }
        }
        TBOOL(CloseHandle(hEvent));
    }
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CB_ThreadProc
//
//  Arguments:  pParameter  =   this object.
//
//  Returns:    DWORD
//
//  Purpose:    Callback function stub to member function.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI      CInteractiveLogon::CB_ThreadProc (void *pParameter)

{
    static_cast<CInteractiveLogon*>(pParameter)->WaitForInteractiveLogonRequest();
    return(0);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CB_APCProc
//
//  Arguments:  dwParam     =   this object.
//
//  Returns:    <none>
//
//  Purpose:    Set object member variable to exit thread loop.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CInteractiveLogon::CB_APCProc (ULONG_PTR dwParam)

{
    reinterpret_cast<CInteractiveLogon*>(dwParam)->_fContinue = false;
}

//  --------------------------------------------------------------------------
//  ::InitiateInteractiveLogon
//
//  Arguments:  pszUsername     =   User name.
//              pszPassword     =   Password.
//              dwTimeout       =   Time out in milliseconds.
//
//  Returns:    BOOL
//
//  Purpose:    External entry point function exported by name to initiate
//              an interactive logon with specified timeout.
//
//  History:    2001-04-10  vtan        created
//              2001-06-04  vtan        added timeout
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  InitiateInteractiveLogon (const WCHAR *pszUsername, WCHAR *pszPassword, DWORD dwTimeout)

{
    DWORD   dwErrorCode;

    dwErrorCode = CInteractiveLogon::Initiate(pszUsername, L"", pszPassword, dwTimeout);
    if (ERROR_SUCCESS != dwErrorCode)
    {
        SetLastError(dwErrorCode);
    }
    return(ERROR_SUCCESS == dwErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\cidispatchhelper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CIDispatchHelper.h
//
//  Contents:   class defintion for CIDispatchHelper, a helper class to share code
//              for the IDispatch implementation that others can inherit from. 
//
//----------------------------------------------------------------------------

#ifndef _CIDISPATCHHELPER_H_
#define _CIDISPATCHHELPER_H_





class CIDispatchHelper
{
    public:
        // we need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        // *** IDispatch methods ***
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
        STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

        // helper function to get a ITypeInfo uuid/lcid out of the type library
        HRESULT _LoadTypeInfo(const GUID* rguidTypeLib, LCID lcid, UUID uuid, ITypeInfo** ppITypeInfo);

        CIDispatchHelper(const IID* piid, const IID* piidTypeLib);
        ~CIDispatchHelper(void);

    private:
        const IID* _piid;           // guid that this IDispatch implementation is for
        const IID* _piidTypeLib;    // guid that specifies which TypeLib to load
        IDispatch* _pdisp;
        ITypeInfo* _pITINeutral;    // cached Type information
};

#endif // _CIDISPATCHHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\clogonstatushost.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CLogonStatusHost.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that contains implementation for ILogonStatusHost for use by UI host
//  executables.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

#include "priv.h"
#include <wtsapi32.h>
#include <winsta.h>

#include "UserOM.h"
#include "GinaIPC.h"
#include "CInteractiveLogon.h"

const WCHAR     CLogonStatusHost::s_szTermSrvReadyEventName[]   =   TEXT("TermSrvReadyEvent");

//
// IUnknown Interface
//

ULONG   CLogonStatusHost::AddRef (void)

{
    return(++_cRef);
}

ULONG   CLogonStatusHost::Release (void)

{
    ULONG   ulResult;

    ASSERTMSG(_cRef > 0, "Invalid reference count in CLogonStatusHost::Release");
    ulResult = --_cRef;
    if (ulResult <= 0)
    {
        delete this;
        ulResult = 0;
    }
    return(ulResult);
}

HRESULT     CLogonStatusHost::QueryInterface (REFIID riid, void **ppvObj)

{
    static  const QITAB     qit[] = 
    {
        QITABENT(CLogonStatusHost, IDispatch),
        QITABENT(CLogonStatusHost, ILogonStatusHost),
        {0},
    };

    return(QISearch(this, qit, riid, ppvObj));
}

//
// IDispatch Interface
//

STDMETHODIMP    CLogonStatusHost::GetTypeInfoCount (UINT* pctinfo)

{
    return(CIDispatchHelper::GetTypeInfoCount(pctinfo));
}

STDMETHODIMP    CLogonStatusHost::GetTypeInfo (UINT itinfo, LCID lcid, ITypeInfo** pptinfo)

{
    return(CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo));
}

STDMETHODIMP    CLogonStatusHost::GetIDsOfNames (REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)

{
    return(CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid));
}

STDMETHODIMP    CLogonStatusHost::Invoke (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)

{
    return(CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr));
}

//
// ILogonStatusHost Interface
//

//  --------------------------------------------------------------------------
//  CLogonStatusHost::Initialize
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process.
//              hwndHost    =   HWND of UI host process.
//
//  Returns:    HRESULT
//
//  Purpose:    Registers the StatusWindowClass and creates an invisible
//              window of this class to receive messages from GINA to pass
//              through to the UI host.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP    CLogonStatusHost::Initialize (HINSTANCE hInstance, HWND hwndHost)

{
    HRESULT     hr;
    HANDLE      hEvent;
    WNDCLASSEX  wndClassEx = {0};

    ASSERTMSG(_hInstance == NULL, "CLogonStatusHost::Initialized already invoked by caller.");

    //  Save parameters to member variables.

    _hInstance = hInstance;
    _hwndHost = hwndHost;

    //  Register this window class.
    wndClassEx.cbSize = sizeof(WNDCLASSEX);
    wndClassEx.lpfnWndProc = StatusWindowProc;
    wndClassEx.hInstance = hInstance;
    wndClassEx.lpszClassName = STATUS_WINDOW_CLASS_NAME;
    _atom = RegisterClassEx(&wndClassEx);

    //  Create the window to receive messages from msgina.

    _hwnd = CreateWindow(MAKEINTRESOURCE(_atom),
                         TEXT("GINA UI"),
                         WS_OVERLAPPED,
                         0, 0,
                         0, 0,
                         NULL,
                         NULL,
                         _hInstance,
                         this);

    //  Signal msgina that we're ready.

    hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("msgina: StatusHostReadyEvent"));
    if (hEvent != NULL)
    {
        TBOOL(SetEvent(hEvent));
        TBOOL(CloseHandle(hEvent));
    }

    //  If we have a window then set the host window in, start waiting
    //  for terminal services to be ready and a wait on the parent process.

    if (_hwnd != NULL)
    {
        _interactiveLogon.SetHostWindow(_hwndHost);
        StartWaitForParentProcess();
        StartWaitForTermService();
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::UnInitialize
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Cleans up resources and memory allocated in Initialize.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP    CLogonStatusHost::UnInitialize (void)

{
    ASSERTMSG(_hInstance != NULL, "CLogonStatusHost::UnInitialized invoked without Initialize.");
    if (_hwnd != NULL)
    {
        EndWaitForTermService();
        EndWaitForParentProcess();
        if (_fRegisteredNotification != FALSE)
        {
            TBOOL(WinStationUnRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd));
            _fRegisteredNotification = FALSE;
        }
        TBOOL(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
        _atom = 0;
    }
    _hwndHost = NULL;
    _hInstance = NULL;
    return(S_OK);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::WindowProcedureHelper
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    HRESULT
//
//  Purpose:    Handles certain messages for the status UI host. This allows
//              things like ALT-F4 to be discarded or power messages to be
//              responded to correctly.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP    CLogonStatusHost::WindowProcedureHelper (HWND hwnd, UINT uMsg, VARIANT wParam, VARIANT lParam)

{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(lParam);

    HRESULT     hr;

    hr = E_NOTIMPL;
    switch (uMsg)
    {
        case WM_SYSCOMMAND:
            if (SC_CLOSE == wParam.uintVal)     //  Blow off ALT-F4
            {
                hr = S_OK;
            }
            break;
        default:
            break;
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::Handle_WM_UISERVICEREQUEST
//
//  Arguments:  wParam  =   WPARAM sent from GINA.
//              lParam  =   LPARAM sent from GINA.
//
//  Returns:    LRESULT
//
//  Purpose:    Receives messages from GINA bound for the UI host. Turns
//              around and passes the messages to the UI host. This allows
//              the actual implementation to change without having to
//              rebuild the UI host.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CLogonStatusHost::Handle_WM_UISERVICEREQUEST (WPARAM wParam, LPARAM lParam)

{
    LRESULT     lResult;
    WPARAM      wParamSend;
    void        *pV;

    lResult = 0;
    pV = NULL;
    wParamSend = HM_NOACTION;
    switch (wParam)
    {
        case UI_TERMINATE:
            ExitProcess(0);
            break;
        case UI_STATE_STATUS:
            _interactiveLogon.Stop();
            wParamSend = HM_SWITCHSTATE_STATUS;
            break;
        case UI_STATE_LOGON:
            _interactiveLogon.Start();
            wParamSend = HM_SWITCHSTATE_LOGON;
            break;
        case UI_STATE_LOGGEDON:
            _interactiveLogon.Stop();
            wParamSend = HM_SWITCHSTATE_LOGGEDON;
            break;
        case UI_STATE_HIDE:
            _interactiveLogon.Stop();
            TBOOL(SetProcessWorkingSetSize(GetCurrentProcess(), static_cast<SIZE_T>(-1), static_cast<SIZE_T>(-1)));
            wParamSend = HM_SWITCHSTATE_HIDE;
            break;
        case UI_STATE_END:
            EndWaitForTermService();
            EndWaitForParentProcess();
            wParamSend = HM_SWITCHSTATE_DONE;
            break;
        case UI_NOTIFY_WAIT:
            wParamSend = HM_NOTIFY_WAIT;
            break;
        case UI_SELECT_USER:
            pV = LocalAlloc(LPTR, sizeof(SELECT_USER));
            if (pV != NULL)
            {
                SELECT_USER* psl = (SELECT_USER*)pV;
                LOGONIPC_USERID* pipc = (LOGONIPC_USERID*)lParam;

                StringCchCopyW(psl->szUsername, ARRAYSIZE(psl->szUsername), pipc->wszUsername);
                StringCchCopyW(psl->szDomain, ARRAYSIZE(psl->szDomain), pipc->wszDomain);

                wParamSend = HM_SELECT_USER;
                lParam = (LPARAM)pV;
            }
            break;
        case UI_SET_ANIMATIONS:
            wParamSend = HM_SET_ANIMATIONS;
            break;
        case UI_INTERACTIVE_LOGON:
            pV = LocalAlloc(LPTR, sizeof(INTERACTIVE_LOGON_REQUEST));
            if (pV != NULL)
            {
                INTERACTIVE_LOGON_REQUEST* plr = (INTERACTIVE_LOGON_REQUEST*)pV;
                LOGONIPC_CREDENTIALS* pipc = (LOGONIPC_CREDENTIALS*)lParam;

                StringCchCopyW(plr->szUsername, ARRAYSIZE(plr->szUsername), pipc->userID.wszUsername);
                StringCchCopyW(plr->szDomain, ARRAYSIZE(plr->szDomain), pipc->userID.wszDomain);
                StringCchCopyW(plr->szPassword, ARRAYSIZE(plr->szPassword), pipc->wszPassword);
                
                ZeroMemory(pipc->wszPassword, (lstrlenW(pipc->wszPassword) + 1) * sizeof(WCHAR));
                
                wParamSend = HM_INTERACTIVE_LOGON_REQUEST;
                lParam = (LPARAM)pV;
            }
            break;
        case UI_DISPLAY_STATUS:
            wParamSend = HM_DISPLAYSTATUS;
            break;
        default:
            break;
    }
    if (wParam != HM_NOACTION)
    {
        lResult = SendMessage(_hwndHost, WM_UIHOSTMESSAGE, wParamSend, lParam);
    }
    else
    {
        lResult = 0;
    }
    if (pV != NULL)
    {
        (HLOCAL)LocalFree(pV);
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::Handle_WM_WTSSESSION_CHANGE
//
//  Arguments:  wParam  =   
//              lParam  =   
//
//  Returns:    LRESULT
//
//  Purpose:    Receives messages from GINA bound for the UI host. Turns
//              around and passes the messages to the UI host. This allows
//              the actual implementation to change without having to
//              rebuild the UI host.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CLogonStatusHost::Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam)

{
    UNREFERENCED_PARAMETER(lParam);

    LRESULT     lResult;

    lResult = 0;
    switch (wParam)
    {
        case WTS_CONSOLE_CONNECT:
        case WTS_CONSOLE_DISCONNECT:
        case WTS_REMOTE_CONNECT:
        case WTS_REMOTE_DISCONNECT:
            break;
        case WTS_SESSION_LOGON:
        case WTS_SESSION_LOGOFF:
            lResult = SendMessage(_hwndHost, WM_UIHOSTMESSAGE, HM_DISPLAYREFRESH, 0);
            break;
        default:
            break;
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::StatusWindowProc
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    <none>
//
//  Purpose:    Window procedure for StatusWindowClass.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

LRESULT CALLBACK    CLogonStatusHost::StatusWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    LRESULT             lResult;
    CLogonStatusHost    *pThis;

    pThis = reinterpret_cast<CLogonStatusHost*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT    *pCreateStruct;

            pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams));
            lResult = 0;
            break;
        }
        case WM_UISERVICEREQUEST:
            lResult = pThis->Handle_WM_UISERVICEREQUEST(wParam, lParam);
            break;
        case WM_WTSSESSION_CHANGE:
            lResult = pThis->Handle_WM_WTSSESSION_CHANGE(wParam, lParam);
            break;
        case WM_SETTINGCHANGE:
            if (wParam == SPI_SETWORKAREA)
            {
                lResult = SendMessage(pThis->_hwndHost, WM_UIHOSTMESSAGE, HM_DISPLAYRESIZE, 0);
            }
            else
            {
                lResult = 0;
            }
            break;
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::IsTermServiceDisabled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Determines from the service control manager whether terminal
//              services is disabled.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatusHost::IsTermServiceDisabled (void)

{
    bool        fResult;
    SC_HANDLE   hSCManager;

    fResult = false;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCTermService;

        hSCTermService = OpenService(hSCManager, TEXT("TermService"), SERVICE_QUERY_CONFIG);
        if (hSCTermService != NULL)
        {
            DWORD                   dwBytesNeeded;
            QUERY_SERVICE_CONFIG    *pServiceConfig;

            (BOOL)QueryServiceConfig(hSCTermService, NULL, 0, &dwBytesNeeded);
            pServiceConfig = static_cast<QUERY_SERVICE_CONFIG*>(LocalAlloc(LMEM_FIXED, dwBytesNeeded));
            if (pServiceConfig != NULL)
            {
                if (QueryServiceConfig(hSCTermService, pServiceConfig, dwBytesNeeded, &dwBytesNeeded) != FALSE)
                {
                    fResult = (pServiceConfig->dwStartType == SERVICE_DISABLED);
                }
                (HLOCAL)LocalFree(pServiceConfig);
            }
            TBOOL(CloseServiceHandle(hSCTermService));
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::StartWaitForTermService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Register for console notifications with terminal services. If
//              the service is disabled don't bother. If the service hasn't
//              started then create a thread to wait for it and re-perform the
//              registration.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::StartWaitForTermService (void)

{

    //  Don't do anything if terminal services is disabled.

    if (!IsTermServiceDisabled())
    {

        //  Try to register the notification first.

        _fRegisteredNotification = WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd, NOTIFY_FOR_ALL_SESSIONS);
        if (_fRegisteredNotification == FALSE)
        {
            DWORD   dwThreadID;

            (ULONG)AddRef();
            _hThreadWaitForTermService = CreateThread(NULL,
                                                      0,
                                                      CB_WaitForTermService,
                                                      this,
                                                      0,
                                                      &dwThreadID);
            if (_hThreadWaitForTermService == NULL)
            {
                (ULONG)Release();
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::EndWaitForTermService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    If a thread has been created and the thread is still executing
//              then wake it up and force it to exit. If the thread cannot be
//              woken up then terminate it. Release handles.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::EndWaitForTermService (void)

{
    HANDLE  hThread;

    //  Grab the _hThreadWaitForTermService now. This will indicate to the
    //  thread should it decide to finish executing that it shouldn't release
    //  the reference on itself.

    hThread = InterlockedExchangePointer(&_hThreadWaitForTermService, NULL);
    if (hThread != NULL)
    {

        //  Queue an APC to the wait thread. If the queue succeeds then
        //  wait for the thread to finish executing. If the queue fails
        //  the thread probably finished between the time we executed the
        //  InterlockedExchangePointer above and the QueueUserAPC.

        if (QueueUserAPC(CB_WakeupThreadAPC, hThread, PtrToUlong(this)) != FALSE)
        {
            (DWORD)WaitForSingleObject(hThread, INFINITE);
        }
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::WaitForTermService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Simple thread that waits for terminal services to signal that
//              it's ready and then registers for notifications. This is
//              required because this DLL initializes before terminal services
//              has had a chance to start up.
//
//  History:    2000-10-20  vtan        created
//              2001-01-04  vtan        allow premature exit
//  --------------------------------------------------------------------------

void    CLogonStatusHost::WaitForTermService (void)

{
    DWORD       dwWaitResult;
    int         iCounter;
    HANDLE      hTermSrvReadyEvent, hThread;

    dwWaitResult = 0;
    iCounter = 0;
    hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, s_szTermSrvReadyEventName);
    while ((dwWaitResult == 0) && (hTermSrvReadyEvent == NULL) && (iCounter < 60))
    {
        ++iCounter;
        dwWaitResult = SleepEx(1000, TRUE);
        if (dwWaitResult == 0)
        {
            hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, s_szTermSrvReadyEventName);
        }
    }
    if (hTermSrvReadyEvent != NULL)
    {
        dwWaitResult = WaitForSingleObjectEx(hTermSrvReadyEvent, 60000, TRUE);
        if (dwWaitResult == WAIT_OBJECT_0)
        {
            _fRegisteredNotification = WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd, NOTIFY_FOR_ALL_SESSIONS);
        }
        TBOOL(CloseHandle(hTermSrvReadyEvent));
    }

    //  Grab the _hThreadWaitForTermService now. This will indicate to the
    //  EndWaitForTermService function that we've reached the point of no
    //  return and we're going to release ourselves. If we can't grab the
    //  handle then EndWaitForTermService must be telling us to stop now.

    hThread = InterlockedExchangePointer(&_hThreadWaitForTermService, NULL);
    if (hThread != NULL)
    {
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CB_WaitForTermService
//
//  Arguments:  pParameter  =   User defined data.
//
//  Returns:    DWORD
//
//  Purpose:    Stub to call member function.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CLogonStatusHost::CB_WaitForTermService (void *pParameter)

{
    static_cast<CLogonStatusHost*>(pParameter)->WaitForTermService();
    return(0);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::StartWaitForParentProcess
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Create a thread to wait on the parent process. Terminal
//              services will terminate a non-session 0 winlogon which will
//              leave us dangling. Detect this case and exit cleanly. This
//              will allow csrss and win32k to clean up and release resources.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::StartWaitForParentProcess (void)

{
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    //  Open a handle to our parent process. This will be winlogon.
    //  If the parent dies then so do we.

    if (NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(),
                                             ProcessBasicInformation,
                                             &processBasicInformation,
                                             sizeof(processBasicInformation),
                                             &ulReturnLength)))
    {
        _hProcessParent = OpenProcess(PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                                      FALSE,
                                      static_cast<DWORD>(processBasicInformation.InheritedFromUniqueProcessId));
#ifdef      DEBUG
        if (IsDebuggerPresent())
        {
            if (NT_SUCCESS(NtQueryInformationProcess(_hProcessParent,
                                                     ProcessBasicInformation,
                                                     &processBasicInformation,
                                                     sizeof(processBasicInformation),
                                                     &ulReturnLength)))
            {
                TBOOL(CloseHandle(_hProcessParent));
                _hProcessParent = OpenProcess(PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                                              FALSE,
                                              static_cast<DWORD>(processBasicInformation.InheritedFromUniqueProcessId));
            }
        }
#endif  /*  DEBUG   */
        if (_hProcessParent != NULL)
        {
            DWORD dwThreadID;

            (ULONG)AddRef();
            _hThreadWaitForParentProcess = CreateThread(NULL,
                                                        0,
                                                        CB_WaitForParentProcess,
                                                        this,
                                                        0,
                                                        &dwThreadID);
            if (_hThreadWaitForParentProcess == NULL)
            {
                (ULONG)Release();
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::EndWaitForParentProcess
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    If a thread waiting on the parent process is executing then
//              wake it up and force it to exit. If the thread cannot be woken
//              then terminate it. Release the handles used.
//
//  History:    2000-12-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::EndWaitForParentProcess (void)

{
    HANDLE  hThread;

    //  Do exactly the same thing that EndWaitForTermService does to correctly
    //  control the reference count on the "this" object. Whoever grabs the
    //  _hThreadWaitForParentProcess is the guy who releases the reference.

    hThread = InterlockedExchangePointer(&_hThreadWaitForParentProcess, NULL);
    if (hThread != NULL)
    {
        if (QueueUserAPC(CB_WakeupThreadAPC, hThread, PtrToUlong(this)) != FALSE)
        {
            (DWORD)WaitForSingleObject(hThread, INFINITE);
        }
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }

    //  Always release this handle the callback doesn't do this.

    if (_hProcessParent != NULL)
    {
        TBOOL(CloseHandle(_hProcessParent));
        _hProcessParent = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::ParentProcessTerminated
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Handles parent process termination. Terminate process on us.
//
//  History:    2000-12-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::WaitForParentProcess (void)

{
    DWORD   dwWaitResult;
    HANDLE  hThread;

    //  Make a Win32 API call now so that the thread is converted to
    //  a GUI thread. This will allow the PostMessage call to work
    //  once the parent process is terminated. If the thread isn't
    //  a GUI thread the system will not convert it to one in the
    //  state when the callback is executed.

    TBOOL(PostMessage(_hwndHost, WM_NULL, 0, 0));
    dwWaitResult = WaitForSingleObjectEx(_hProcessParent, INFINITE, TRUE);
    if (dwWaitResult == WAIT_OBJECT_0)
    {
        TBOOL(PostMessage(_hwndHost, WM_UIHOSTMESSAGE, HM_SWITCHSTATE_DONE, 0));
    }
    hThread = InterlockedExchangePointer(&_hThreadWaitForParentProcess, NULL);
    if (hThread != NULL)
    {
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CB_WaitForParentProcess
//
//  Arguments:  pParameter  =   User defined data.
//
//  Returns:    DWORD
//
//  Purpose:    Stub to call member function.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CLogonStatusHost::CB_WaitForParentProcess (void *pParameter)

{
    static_cast<CLogonStatusHost*>(pParameter)->WaitForParentProcess();
    return(0);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CB_WakeupThreadAPC
//
//  Arguments:  dwParam     =   User defined data.
//
//  Returns:    <none>
//
//  Purpose:    APCProc to wake up a thread waiting in an alertable state.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CLogonStatusHost::CB_WakeupThreadAPC (ULONG_PTR dwParam)

{
    UNREFERENCED_PARAMETER(dwParam);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CLogonStatusHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CLogonStatusHost.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

CLogonStatusHost::CLogonStatusHost (void) :
    CIDispatchHelper(&IID_ILogonStatusHost, &LIBID_SHGINALib),
    _cRef(1),
    _hInstance(NULL),
    _hwnd(NULL),
    _hwndHost(NULL),
    _atom(0),
    _fRegisteredNotification(FALSE),
    _hThreadWaitForTermService(NULL),
    _hThreadWaitForParentProcess(NULL),
    _hProcessParent(NULL)

{
    DllAddRef();
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::~CLogonStatusHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CLogonStatusHost.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

CLogonStatusHost::~CLogonStatusHost (void)
{
    ASSERTMSG((_hProcessParent == NULL) &&
              (_hThreadWaitForParentProcess == NULL) &&
              (_hThreadWaitForTermService == NULL) &&
              (_fRegisteredNotification == FALSE) &&
              (_atom == 0) &&
              (_hwndHost == NULL) &&
              (_hwnd == NULL) &&
              (_hInstance == NULL), "Must UnIniitialize object before destroying in CLogonStatusHost::~CLogonStatusHost");
    ASSERTMSG(_cRef == 0, "Reference count expected to be zero in CLogonStatusHost::~CLogonStatusHost");
    DllRelease();
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost_Create
//
//  Arguments:  riid    =   Class GUID to QI to return.
//              ppv     =   Interface returned.
//
//  Returns:    HRESULT
//
//  Purpose:    Creates the CLogonStatusHost class and returns the specified
//              interface supported by the class to the caller.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------
STDAPI      CLogonStatusHost_Create (REFIID riid, void** ppvObj)

{
    HRESULT             hr;
    CLogonStatusHost*   pLogonStatusHost;

    hr = E_OUTOFMEMORY;
    pLogonStatusHost = new CLogonStatusHost;
    if (pLogonStatusHost != NULL)
    {
        hr = pLogonStatusHost->QueryInterface(riid, ppvObj);
        pLogonStatusHost->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\clocalmachine.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CLocalMachine.cpp
//
//  Contents:   implementation of CLocalMachine
//
//----------------------------------------------------------------------------

#include "priv.h"

#include "UserOM.h"
#include "LogonIPC.h"
#include "CInteractiveLogon.h"
#include "WinUser.h"
#include "trayp.h"      // for TM_REFRESH
#include <lmaccess.h>   // for NetUserModalsGet
#include <lmapibuf.h>   // for NetApiBufferFree
#include <lmerr.h>      // for NERR_Success
#include <ntlsa.h>
#include <cfgmgr32.h>
#include <cscapi.h>     // for CSCIsCSCEnabled

//
// IUnknown Interface
//

ULONG CLocalMachine::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CLocalMachine::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CLocalMachine::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLocalMachine, IDispatch),
        QITABENT(CLocalMachine, ILocalMachine),
        {0},
    };

    return QISearch(this, qit, riid, ppvObj);
}


//
// IDispatch Interface
//

STDMETHODIMP CLocalMachine::GetTypeInfoCount(UINT* pctinfo)
{ 
    return CIDispatchHelper::GetTypeInfoCount(pctinfo); 
}


STDMETHODIMP CLocalMachine::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    return CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo); 
}


STDMETHODIMP CLocalMachine::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{ 
    return CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}


STDMETHODIMP CLocalMachine::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    return CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


//
// ILocalMachine Interface
//



STDMETHODIMP CLocalMachine::get_MachineName(VARIANT* pvar)
{
    HRESULT hr;
    DWORD cch;
    WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH+1];

    if (pvar)
    {
        pvar->vt = VT_BSTR;
        cch = MAX_COMPUTERNAME_LENGTH+1;
        if (GetComputerNameW(szMachineName, &cch))
        {
            pvar->bstrVal = SysAllocString(szMachineName);
        }
        else
        {
            pvar->bstrVal = SysAllocString(TEXT(""));
        }
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


DWORD BuildAccountSidFromRid(LPCWSTR pszServer, DWORD dwRid, PSID* ppSid)
{
    DWORD dwErr = ERROR_SUCCESS;
    PUSER_MODALS_INFO_2 umi2;
    NET_API_STATUS nasRet;

    *ppSid = NULL;

    // Get the account domain Sid on the target machine
    nasRet = NetUserModalsGet(pszServer, 2, (LPBYTE*)&umi2);

    if ( nasRet == NERR_Success )
    {
        UCHAR cSubAuthorities;
        PSID pSid;

        cSubAuthorities = *GetSidSubAuthorityCount(umi2->usrmod2_domain_id);

        // Allocate storage for new the Sid (domain Sid + account Rid)
        pSid = (PSID)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(cSubAuthorities+1)));

        if (pSid != NULL)
        {
            if (InitializeSid(pSid,
                              GetSidIdentifierAuthority(umi2->usrmod2_domain_id),
                              (BYTE)(cSubAuthorities+1)))
            {
                // Copy existing subauthorities from domain Sid to new Sid
                for (UINT i = 0; i < cSubAuthorities; i++)
                {
                    *GetSidSubAuthority(pSid, i) = *GetSidSubAuthority(umi2->usrmod2_domain_id, i);
                }

                // Append Rid to new Sid
                *GetSidSubAuthority(pSid, cSubAuthorities) = dwRid;

                *ppSid = pSid;
            }
            else
            {
                dwErr = GetLastError();
                LocalFree(pSid);
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        NetApiBufferFree(umi2);
    }
    else
    {
        dwErr = nasRet;
    }

    return dwErr;
}

PSID g_pGuestSid = NULL;

DWORD GetGuestSid(PSID* ppSid)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (g_pGuestSid == NULL)
    {
        PSID pSid;

        dwErr = BuildAccountSidFromRid(NULL, DOMAIN_USER_RID_GUEST, &pSid);
        if (dwErr == ERROR_SUCCESS)
        {
            if (InterlockedCompareExchangePointer(&g_pGuestSid, pSid, NULL))
            {
                // someone else beat us to initing g_pGuestSid, free ours
                LocalFree(pSid);
                pSid = NULL;
            }
        }
    }

    // There is no need to free the returned PSID
    *ppSid = g_pGuestSid;

    if (*ppSid == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwErr;
}

BOOL FreeGuestSid()
{
    BOOL bRet = FALSE;
    PSID pSid = (PSID)InterlockedExchangePointer(&g_pGuestSid, NULL);
    
    if (pSid)
    {
        LocalFree(pSid);
        bRet = TRUE;
    }

    return bRet;
}

LPCWSTR g_pszGuestAccountName = NULL;

LPCWSTR GetGuestAccountName()
{
    if (g_pszGuestAccountName == NULL)
    {
        PSID pSidGuest;
        WCHAR szGuestAccountName[UNLEN + 1];
        WCHAR szDomain[DNLEN + 1];
        DWORD cchGuestAccountName;
        DWORD cchDomain;
        SID_NAME_USE eUse;

        szGuestAccountName[0] = L'\0';

        if (GetGuestSid(&pSidGuest) == ERROR_SUCCESS)
        {
            cchGuestAccountName = ARRAYSIZE(szGuestAccountName);
            cchDomain = ARRAYSIZE(szDomain);

            if (LookupAccountSidW(NULL,
                                  pSidGuest,
                                  szGuestAccountName,
                                  &cchGuestAccountName,
                                  szDomain,
                                  &cchDomain,
                                  &eUse))
            {
                ASSERT(szGuestAccountName[0] != L'\0');
            }
            else
            {
                // If LookupAccountSid failed, assume english "Guest" and see if the reverse-lookup matches
                // the pSidGuest
                BYTE rgByte[sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES - 1) * sizeof(ULONG))] = {0};
                PSID pSid;
                DWORD cbSid;

                pSid = (PSID)&rgByte;
                cbSid = sizeof(rgByte);
                cchDomain = ARRAYSIZE(szDomain);

                if (LookupAccountNameW(NULL,
                                       L"Guest",
                                       pSid,
                                       &cbSid,
                                       szDomain,
                                       &cchDomain,
                                       &eUse))
                {
                    if (!EqualSid(pSidGuest, pSid))
                    {
                        // guest sid dosen't match the sid for "Guest" account
                        szGuestAccountName[0] = L'\0';
                    }
                }
            }
        }

        if (szGuestAccountName[0] != L'\0')
        {
            LPWSTR pwsz;
            size_t cch;

            cch = lstrlenW(szGuestAccountName) + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
            if (pwsz)
            {
                if (FAILED(StringCchCopy(pwsz, cch, szGuestAccountName)) ||
                    InterlockedCompareExchangePointer((void**)&g_pszGuestAccountName, pwsz, NULL))
                {
                    // someone else beat us to initializing g_pszGuestAccountName, free ours
                    LocalFree(pwsz);
                    pwsz = NULL;
                }
            }
        }
    }

    return g_pszGuestAccountName;
}

BOOL FreeGuestAccountName()
{
    BOOL bRet = FALSE;
    LPWSTR psz = (LPWSTR)InterlockedExchangePointer((void **)&g_pszGuestAccountName, NULL);

    if (psz)
    {
        LocalFree(psz);
        bRet = TRUE;
    }

    return bRet;
}

STDMETHODIMP CLocalMachine::get_isGuestEnabled(ILM_GUEST_FLAGS flags, VARIANT_BOOL* pbEnabled)
{
    HRESULT         hr = S_OK;
    DWORD           dwErr;
    BOOL            bEnabled = FALSE;
    USER_INFO_1     *pusri1 = NULL;
    DWORD           dwFlags = (DWORD)(flags & (ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON));
    LPCTSTR         pszGuest;

    if (NULL == pbEnabled)
    {
        return E_POINTER;
    }

    pszGuest = GetGuestAccountName();
    if (pszGuest)
    {
        //  First check to see if the guest account is truly enabled
        dwErr = NetUserGetInfo(NULL, pszGuest, 1, (LPBYTE*)&pusri1);
        if ((ERROR_SUCCESS == dwErr) && ((pusri1->usri1_flags & UF_ACCOUNTDISABLE) == 0))
        {
            // Guest is enabled
            bEnabled = TRUE;

            // Do they want to check the LSA logon rights?
            if (0 != dwFlags)
            {
                BOOL bDenyInteractiveLogon = FALSE;
                BOOL bDenyNetworkLogon = FALSE;
                LSA_HANDLE hLsa;
                LSA_OBJECT_ATTRIBUTES oa = {0};

                oa.Length = sizeof(oa);
                dwErr = LsaNtStatusToWinError(LsaOpenPolicy(NULL, &oa, POLICY_LOOKUP_NAMES, &hLsa));

                if (ERROR_SUCCESS == dwErr)
                {
                    PSID pSid;

                    dwErr = GetGuestSid(&pSid);
                    if (ERROR_SUCCESS == dwErr)
                    {
                        PLSA_UNICODE_STRING pAccountRights;
                        ULONG cRights;

                        // Get the list of LSA rights assigned to the Guest account
                        //
                        // Note that SE_INTERACTIVE_LOGON_NAME is often inherited via
                        // group membership, so its absence doesn't mean much. We could
                        // bend over backwards and check group membership and such, but
                        // Guest normally gets SE_INTERACTIVE_LOGON_NAME one way or
                        // another, so we only check for SE_DENY_INTERACTIVE_LOGON_NAME
                        // here.

                        dwErr = LsaNtStatusToWinError(LsaEnumerateAccountRights(hLsa, pSid, &pAccountRights, &cRights));
                        if (ERROR_SUCCESS == dwErr)
                        {
                            PLSA_UNICODE_STRING pRight;
                            for (pRight = pAccountRights; cRights > 0 && 0 != dwFlags; pRight++, cRights--)
                            {
                                if (0 != (dwFlags & ILM_GUEST_INTERACTIVE_LOGON) &&
                                    CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
                                                                NORM_IGNORECASE,
                                                                SE_DENY_INTERACTIVE_LOGON_NAME,
                                                                -1,
                                                                pRight->Buffer,
                                                                pRight->Length/2))
                                {
                                    bDenyInteractiveLogon = TRUE;
                                    dwFlags &= ~ILM_GUEST_INTERACTIVE_LOGON;
                                }
                                else if (0 != (dwFlags & ILM_GUEST_NETWORK_LOGON) &&
                                    CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
                                                                NORM_IGNORECASE,
                                                                SE_DENY_NETWORK_LOGON_NAME,
                                                                -1,
                                                                pRight->Buffer,
                                                                pRight->Length/2))
                                {
                                    bDenyNetworkLogon = TRUE;
                                    dwFlags &= ~ILM_GUEST_NETWORK_LOGON;
                                }
                            }
                            LsaFreeMemory(pAccountRights);
                        }
                        else if (ERROR_FILE_NOT_FOUND == dwErr)
                        {
                            // Guest isn't in LSA's database, so we know it can't
                            // have either of the deny logon rights.
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    LsaClose(hLsa);
                }

                if (bDenyInteractiveLogon || bDenyNetworkLogon)
                    bEnabled = FALSE;
            }
        }
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (NULL != pusri1)
    {
        (NET_API_STATUS)NetApiBufferFree(pusri1);
    }

    hr = HRESULT_FROM_WIN32(dwErr);

    *pbEnabled = bEnabled ? VARIANT_TRUE : VARIANT_FALSE;

    return hr;
}

STDMETHODIMP CLocalMachine::EnableGuest(ILM_GUEST_FLAGS flags)
{
    DWORD           dwErr;
    USER_INFO_1     *pusri1;
    DWORD dwFlags = (DWORD)(flags & (ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON));
    LPCTSTR pszGuest;

    pszGuest = GetGuestAccountName();
    if (pszGuest)
    {
        //  First truly enable the guest account. Do this ALL the time.
        dwErr = NetUserGetInfo(NULL, pszGuest, 1, (LPBYTE*)&pusri1);
        if (ERROR_SUCCESS == dwErr)
        {
            pusri1->usri1_flags &= ~UF_ACCOUNTDISABLE;
            dwErr = NetUserSetInfo(NULL, pszGuest, 1, (LPBYTE)pusri1, NULL);
            if (ERROR_SUCCESS == dwErr && 0 != dwFlags)
            {
                LSA_HANDLE hLsa;
                LSA_OBJECT_ATTRIBUTES oa = {0};

                oa.Length = sizeof(oa);
                dwErr = LsaNtStatusToWinError(LsaOpenPolicy(NULL, &oa, POLICY_LOOKUP_NAMES, &hLsa));

                if (ERROR_SUCCESS == dwErr)
                {
                    PSID pSid;

                    dwErr = GetGuestSid(&pSid);
                    if (ERROR_SUCCESS == dwErr)
                    {
                        if (0 != (dwFlags & ILM_GUEST_INTERACTIVE_LOGON))
                        {
                            DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_INTERACTIVE_LOGON_NAME);
                            NTSTATUS status = LsaRemoveAccountRights(hLsa, pSid, FALSE, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                            dwErr = LsaNtStatusToWinError(status);
                        }
                        if (0 != (dwFlags & ILM_GUEST_NETWORK_LOGON))
                        {
                            DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_NETWORK_LOGON_NAME);
                            NTSTATUS status = LsaRemoveAccountRights(hLsa, pSid, FALSE, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                            if (ERROR_SUCCESS == dwErr)
                                dwErr = LsaNtStatusToWinError(status);
                        }

                        if (ERROR_FILE_NOT_FOUND == dwErr)
                        {
                            //
                            // NTRAID#NTBUG9-396428-2001/05/16-jeffreys
                            //
                            // This means Guest isn't in LSA's database, so we know
                            // it can't have either of the deny logon rights. Since
                            // we were trying to remove one or both rights, count
                            // this as success.
                            //
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    LsaClose(hLsa);
                }
            }
            (NET_API_STATUS)NetApiBufferFree(pusri1);
        }
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return HRESULT_FROM_WIN32(dwErr);
}

STDMETHODIMP CLocalMachine::DisableGuest(ILM_GUEST_FLAGS flags)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwFlags = (DWORD)(flags & (ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON));

    if (0 != dwFlags)
    {
        LSA_HANDLE hLsa;
        LSA_OBJECT_ATTRIBUTES oa = {0};

        // Turn on DenyInteractiveLogon and/or DenyNetworkLogon, but don't
        // necessarily change the enabled state of the guest account.

        oa.Length = sizeof(oa);
        dwErr = LsaNtStatusToWinError(LsaOpenPolicy(NULL, &oa, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES, &hLsa));

        if (ERROR_SUCCESS == dwErr)
        {
            PSID pSid;

            dwErr = GetGuestSid(&pSid);
            if (ERROR_SUCCESS == dwErr)
            {
                if (0 != (dwFlags & ILM_GUEST_INTERACTIVE_LOGON))
                {
                    DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_INTERACTIVE_LOGON_NAME);
                    NTSTATUS status = LsaAddAccountRights(hLsa, pSid, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                    dwErr = LsaNtStatusToWinError(status);
                }
                if (0 != (dwFlags & ILM_GUEST_NETWORK_LOGON))
                {
                    DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_NETWORK_LOGON_NAME);
                    NTSTATUS status = LsaAddAccountRights(hLsa, pSid, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                    if (ERROR_SUCCESS == dwErr)
                        dwErr = LsaNtStatusToWinError(status);
                }
            }
            LsaClose(hLsa);
        }

        if (ERROR_SUCCESS == dwErr)
        {
            // If both  SE_DENY_INTERACTIVE_LOGON_NAME and SE_DENY_NETWORK_LOGON_NAME
            // are turned on, then we might as well disable the account altogether.
            if ((ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON) == dwFlags)
            {
                // We just turned both on, so disable guest below
                dwFlags = 0;
            }
            else
            {
                VARIANT_BOOL bEnabled;

                if (ILM_GUEST_INTERACTIVE_LOGON == dwFlags)
                {
                    // We just turned on SE_DENY_INTERACTIVE_LOGON_NAME, check
                    // for SE_DENY_NETWORK_LOGON_NAME.
                    flags = ILM_GUEST_NETWORK_LOGON;
                }
                else if (ILM_GUEST_NETWORK_LOGON == dwFlags)
                {
                    // We just turned on SE_DENY_NETWORK_LOGON_NAME, check
                    // for SE_DENY_INTERACTIVE_LOGON_NAME.
                    flags = ILM_GUEST_INTERACTIVE_LOGON;
                }
                else
                {
                    // Getting here implies that someone defined a new flag.
                    // Setting flags to ILM_GUEST_ACCOUNT causes a benign
                    // result in all cases (we only disable guest if guest
                    // is already disabled).
                    flags = ILM_GUEST_ACCOUNT;
                }

                if (SUCCEEDED(get_isGuestEnabled(flags, &bEnabled)) && (VARIANT_FALSE == bEnabled))
                {
                    // Both are on, so disable guest below
                    dwFlags = 0;
                }
            }
        }
    }

    if (0 == dwFlags)
    {
        USER_INFO_1 *pusri1;
        LPCTSTR pszGuest = GetGuestAccountName();

        if (pszGuest)
        {
            //  Truly disable the guest account.
            dwErr = NetUserGetInfo(NULL, pszGuest, 1, (LPBYTE*)&pusri1);
            if (ERROR_SUCCESS == dwErr)
            {
                pusri1->usri1_flags |= UF_ACCOUNTDISABLE;
                dwErr = NetUserSetInfo(NULL, GetGuestAccountName(), 1, (LPBYTE)pusri1, NULL);
                (NET_API_STATUS)NetApiBufferFree(pusri1);
            }
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return HRESULT_FROM_WIN32(dwErr);
}

STDMETHODIMP CLocalMachine::get_isFriendlyUIEnabled(VARIANT_BOOL* pbEnabled)

{
    *pbEnabled = ShellIsFriendlyUIActive() ? VARIANT_TRUE : VARIANT_FALSE;
    return(S_OK);
}

STDMETHODIMP CLocalMachine::put_isFriendlyUIEnabled(VARIANT_BOOL bEnabled)

{
    HRESULT hr;

    if (ShellEnableFriendlyUI(bEnabled != VARIANT_FALSE ? TRUE : FALSE) != FALSE)
    {
        RefreshStartMenu();
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return(hr);
}

STDMETHODIMP CLocalMachine::get_isMultipleUsersEnabled(VARIANT_BOOL* pbEnabled)

{
    *pbEnabled = ShellIsMultipleUsersEnabled() ? VARIANT_TRUE : VARIANT_FALSE;
    return(S_OK);
}

STDMETHODIMP CLocalMachine::put_isMultipleUsersEnabled(VARIANT_BOOL bEnabled)

{
    HRESULT hr;

    if (ShellEnableMultipleUsers(bEnabled != VARIANT_FALSE ? TRUE : FALSE) != FALSE)
    {
        RefreshStartMenu();
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return(hr);
}

STDMETHODIMP CLocalMachine::get_isRemoteConnectionsEnabled(VARIANT_BOOL* pbEnabled)

{
    *pbEnabled = ShellIsRemoteConnectionsEnabled() ? VARIANT_TRUE : VARIANT_FALSE;
    return(S_OK);
}

STDMETHODIMP CLocalMachine::put_isRemoteConnectionsEnabled(VARIANT_BOOL bEnabled)

{
    HRESULT hr;

    if (ShellEnableRemoteConnections(bEnabled != VARIANT_FALSE ? TRUE : FALSE) != FALSE)
    {
        RefreshStartMenu();
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return(hr);
}

BOOL _CanEject()
{
    BOOL fEjectAllowed = FALSE;

    if(SHRestricted(REST_NOSMEJECTPC))  //Is there a policy restriction?
        return FALSE;

    CM_Is_Dock_Station_Present(&fEjectAllowed);

    return SHTestTokenPrivilege(NULL, SE_UNDOCK_NAME) &&
           fEjectAllowed  &&
           !GetSystemMetrics(SM_REMOTESESSION);
}

STDMETHODIMP CLocalMachine::get_isUndockEnabled(VARIANT_BOOL* pbEnabled)

{
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbEnabled = objLogon.TestEjectAllowed() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        *pbEnabled = _CanEject() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    return(S_OK);
}

STDMETHODIMP CLocalMachine::get_isShutdownAllowed(VARIANT_BOOL* pbShutdownAllowed)

{
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbShutdownAllowed = objLogon.TestShutdownAllowed() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        *pbShutdownAllowed = VARIANT_FALSE;
    }
    return(S_OK);
}

STDMETHODIMP CLocalMachine::get_isGuestAccessMode(VARIANT_BOOL* pbForceGuest)
{
    *pbForceGuest = SUCCEEDED(_IsGuestAccessMode()) ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}


STDMETHODIMP CLocalMachine::get_isOfflineFilesEnabled(VARIANT_BOOL *pbEnabled)
{
    if (CSCIsCSCEnabled())
    {
        *pbEnabled = VARIANT_TRUE;
    }
    else
    {
        *pbEnabled = VARIANT_FALSE;
    }

    return S_OK;
}


LPCWSTR g_pszAdminAccountName = NULL;

LPCWSTR GetAdminAccountName(void)
{
    if (g_pszAdminAccountName == NULL)
    {
        PSID pSidAdmin;

        if (BuildAccountSidFromRid(NULL,
                                   DOMAIN_USER_RID_ADMIN,
                                   &pSidAdmin) == ERROR_SUCCESS)
        {
            WCHAR szAdminAccountName[UNLEN + 1];
            WCHAR szDomain[DNLEN + 1];
            DWORD cchAdminAccountName;
            DWORD cchDomain;
            SID_NAME_USE eUse;

            cchAdminAccountName = ARRAYSIZE(szAdminAccountName);
            cchDomain = ARRAYSIZE(szDomain);

            if (LookupAccountSidW(NULL,
                                  pSidAdmin,
                                  szAdminAccountName,
                                  &cchAdminAccountName,
                                  szDomain,
                                  &cchDomain,
                                  &eUse))
            {
                LPWSTR psz;
                DWORD cch;

                ASSERT(szAdminAccountName[0] != L'\0');

                cch = lstrlenW(szAdminAccountName) + 1;
                psz = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
                if (psz)
                {
                    if (InterlockedCompareExchangePointer((void**)&g_pszAdminAccountName, psz, NULL))
                    {
                        // someone else beat us to initing g_pszAdminAccountName, free ours
                        LocalFree(psz);
                        psz = NULL;
                    }
                }
            }
                
            LocalFree(pSidAdmin);
        }
    }

    return g_pszAdminAccountName;
}

BOOL FreeAdminAccountName()
{
    BOOL bRet = FALSE;
    LPWSTR psz = (LPWSTR)InterlockedExchangePointer((void **)&g_pszAdminAccountName, NULL);

    if (psz)
    {
        LocalFree(psz);
        bRet = TRUE;
    }

    return bRet;
}

STDMETHODIMP CLocalMachine::get_AccountName(VARIANT varAccount, VARIANT* pvar)
{
    DWORD dwRID = 0;
    LPCWSTR pszName = NULL;

    if (NULL == pvar)
        return E_POINTER;

    switch (varAccount.vt)
    {
    case VT_I4:
    case VT_UI4:
        dwRID = varAccount.ulVal;
        break;

    case VT_BSTR:
        if (0 == StrCmpIW(varAccount.bstrVal, L"Guest"))
            dwRID = DOMAIN_USER_RID_GUEST;
        else if (0 == StrCmpIW(varAccount.bstrVal, L"Administrator"))
            dwRID = DOMAIN_USER_RID_ADMIN;
        else
            return E_INVALIDARG;
        break;

    default:
        return E_INVALIDARG;
    }

    switch (dwRID)
    {
    case DOMAIN_USER_RID_GUEST:
        pszName = GetGuestAccountName();
        break;

    case DOMAIN_USER_RID_ADMIN:
        pszName = GetAdminAccountName();
        break;

    default:
        return E_INVALIDARG;
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(pszName);

    return(S_OK);
}

STDMETHODIMP CLocalMachine::TurnOffComputer()
{
    HRESULT hr;
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    if (objLogon.TurnOffComputer ())
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}

STDMETHODIMP CLocalMachine::UndockComputer()
{
    HRESULT hr;
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    if (objLogon.EjectComputer())
        hr = S_OK;
    else
        hr = E_FAIL;
    return hr;
}

STDMETHODIMP CLocalMachine::SignalUIHostFailure()
{
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    objLogon.SignalUIHostFailure ();
    return S_OK;
}

STDMETHODIMP CLocalMachine::AllowExternalCredentials()

{
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    if (!objLogon.AllowExternalCredentials ())
    {
        return E_NOTIMPL;
    }
    else
    {
        return S_OK;
    }
}

STDMETHODIMP CLocalMachine::RequestExternalCredentials()
{
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    objLogon.RequestExternalCredentials ();
    return S_OK;
}

STDMETHODIMP CLocalMachine::LogonWithExternalCredentials(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, VARIANT_BOOL* pbRet)
{
    HRESULT hr;
    CLogonIPC objLogon;
    TCHAR szUsername[UNLEN + 1];
    TCHAR szDomain[DNLEN + 1];
    TCHAR szPassword[PWLEN + 1];

    if (pstrUsername)
    {
        StringCchCopy(szUsername, ARRAYSIZE(szUsername), pstrUsername);
    }
    else
    {
        szUsername[0] = TEXT('\0');
    }

    if (pstrDomain)
    {
        StringCchCopy(szDomain, ARRAYSIZE(szDomain),  pstrDomain);
    }
    else
    {
        szDomain[0] = TEXT('\0');
    }

    if (pstrPassword)
    {
        StringCchCopy(szPassword, ARRAYSIZE(szPassword), pstrPassword);
    }
    else
    {
        szPassword[0] = TEXT('\0');
    }
        
    if (!objLogon.IsLogonServiceAvailable())
    {
        *pbRet = VARIANT_FALSE;
        hr = S_OK;
    }
    else
    {
        if (objLogon.LogUserOn(szUsername, szDomain, szPassword))
        {
            *pbRet = VARIANT_TRUE;
            hr = S_OK;
        }
        else
        {
            *pbRet = VARIANT_FALSE;
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CLocalMachine::InitiateInteractiveLogon
//
//  Arguments:  pstrUsername    =   User name.
//              pstrDomain      =   Domain.
//              pstrPassword    =   Password (in clear text).
//              pbRet           =   Result (returned).
//
//  Returns:    HRESULT
//
//  Purpose:    Send a request for interactive logon using CInteractiveLogon.
//              It's magic. I don't care how it works.
//
//  History:    2000-12-06  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP CLocalMachine::InitiateInteractiveLogon(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, DWORD dwTimeout, VARIANT_BOOL* pbRet)

{
    DWORD   dwErrorCode;

    dwErrorCode = CInteractiveLogon::Initiate(pstrUsername, pstrDomain, pstrPassword, dwTimeout);
    *pbRet = (ERROR_SUCCESS == dwErrorCode) ? VARIANT_TRUE : VARIANT_FALSE;
    return(HRESULT_FROM_WIN32(dwErrorCode));
}

//  --------------------------------------------------------------------------
//  CLocalMachine::RefreshStartMenu
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Finds the shell tray window and sends it a message to refresh
//              its contents.
//
//  History:    2000-08-01  vtan        created
//  --------------------------------------------------------------------------

void    CLocalMachine::RefreshStartMenu (void)

{
    HWND    hwndTray;

    hwndTray = FindWindow(TEXT("Shell_TrayWnd"), NULL);
    if (hwndTray != NULL)
    {
        TBOOL(PostMessage(hwndTray, TM_REFRESH, 0, 0));
    }
}

CLocalMachine::CLocalMachine() : _cRef(1), CIDispatchHelper(&IID_ILocalMachine, &LIBID_SHGINALib)
{
    DllAddRef();
}


CLocalMachine::~CLocalMachine()
{
    ASSERT(_cRef == 0);
    DllRelease();
}


STDAPI CLocalMachine_Create(REFIID riid, LPVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CLocalMachine* pLocalMachine = new CLocalMachine();

    if (pLocalMachine)
    {
        hr = pLocalMachine->QueryInterface(riid, ppv);
        pLocalMachine->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\makefile.inc ===
$(SELFREGNAME) : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln

shgina.rc : $(PROJECT_ROOT)\lib\$(O)\shgina.tlb $(SELFREGNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\resource.h ===
#ifndef RESOURCE_H 
#define RESOURCE_H 

#define IDS_DEFAULT_BACKUP_PATH 102

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\logonipc.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: LogonIPC.cpp
//
//  Copyright (c) 1999, Microsoft Corporation
//
//  Class that implements communication between an external process and the
//  GINA logon dialog.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "priv.h"
#include "limits.h"
#include "LogonIPC.h"

#include "GinaIPC.h"

//  --------------------------------------------------------------------------
//  CLogonIPC::CLogonIPC
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CLogonIPC class.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

CLogonIPC::CLogonIPC (void) :
    _iLogonAttemptCount(0),
    _hwndLogonService(NULL)

{
}

//  --------------------------------------------------------------------------
//  CLogonIPC::~CLogonIPC
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases any resources used by the CLogonIPC class.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

CLogonIPC::~CLogonIPC (void)

{
}

//  --------------------------------------------------------------------------
//  CLogonIPC::IsLogonServiceAvailable
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Presence or abscence.
//
//  Purpose:    Finds out if the window providing logon service in GINA is
//              available. The determination is not performed statically but
//              rather dynamically which allows this class to be hosted by
//              the actual window providing the service as well.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::IsLogonServiceAvailable (void)

{
    _hwndLogonService = FindWindow(NULL, TEXT("GINA Logon"));
    return(_hwndLogonService != NULL);
}

//  --------------------------------------------------------------------------
//  CLogonIPC::IsUserLoggedOn
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool    =   Presence or abscence.
//
//  Purpose:    Finds out if the given user is logged onto the system. You
//              may pass a NULL pwszDomain for the local machine.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::IsUserLoggedOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_QUERY_LOGGED_ON, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::LogUserOn
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//              pwszPassword    =   User password. This is passed clear text.
//                                  Once encoded the password buffer is
//                                  zeroed. This function owns the memory that
//                                  you pass in.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Attempts to log the user with the given credentials onto the
//              system. The password buffer is owned by this function for the
//              purpose of clearing it once encoded. Failed logon attempts
//              cause a counter to be incremented and a subsequent delay using
//              that counter is done to slow dictionary attacks.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::LogUserOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword)

{
    bool                    fResult;
    UNICODE_STRING          passwordString;
    LOGONIPC_CREDENTIALS    logonIPCCredentials;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCCredentials.userID);

    //  Limit the password to 127 characters. RtlRunEncodeUnicodeString
    //  does not support strings greater than 127 characters.
    //
    //  REVIEW (jeffreys) I don't think that's true.

    StringCchCopyNEx(logonIPCCredentials.wszPassword, ARRAYSIZE(logonIPCCredentials.wszPassword), pwszPassword, 127, NULL, NULL, STRSAFE_FILL_BEHIND_NULL);
    ZeroMemory(pwszPassword, (lstrlen(pwszPassword) + 1) * sizeof(WCHAR));

    logonIPCCredentials.iPasswordLength = lstrlen(logonIPCCredentials.wszPassword);
    logonIPCCredentials.ucPasswordSeed = 0;

    passwordString.Buffer = logonIPCCredentials.wszPassword;
    passwordString.Length = (USHORT)(logonIPCCredentials.iPasswordLength * sizeof(WCHAR));
    passwordString.MaximumLength = sizeof(logonIPCCredentials.wszPassword);

    RtlRunEncodeUnicodeString(&logonIPCCredentials.ucPasswordSeed, &passwordString);

    fResult = SendToLogonService(LOGON_LOGON_USER, &logonIPCCredentials, sizeof(logonIPCCredentials), false);
    if (!fResult)
    {
        Sleep(_iLogonAttemptCount * 1000);
        if (_iLogonAttemptCount < 5)
        {
            _iLogonAttemptCount++;
        }
    }

    return fResult;
}

//  --------------------------------------------------------------------------
//  CLogonIPC::LogUserOff
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Attempts to log the given user off the system. This will fail
//              if they aren't logged on.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::LogUserOff (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_LOGOFF_USER, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestBlankPassword
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Attempts to log the given user on the system with a blank
//              password. The token is then dump and failure/success returned.
//
//  History:    2000-03-09  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestBlankPassword (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_TEST_BLANK_PASSWORD, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestInteractiveLogonAllowed
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool
//
//  Purpose:    Test whether the user has interactive logon rights to this
//              machine. The presence of SeDenyInteractiveLogonRight
//              determines this - NOT the presence of SeInteractiveLogonRight.
//
//  History:    2000-08-15  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestInteractiveLogonAllowed (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_TEST_INTERACTIVE_LOGON_ALLOWED, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestEjectAllowed
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Tests whether the computer is ejectable (docked laptop).
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestEjectAllowed (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_TEST_EJECT_ALLOWED, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestShutdownAllowed
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Tests whether the computer can be shut down.
//
//  History:    2001-02-22  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestShutdownAllowed (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_TEST_SHUTDOWN_ALLOWED, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TurnOffComputer
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Brings up the "Turn Off Computer" dialog and allows the user
//              to choose what to do.
//
//  History:    2000-04-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TurnOffComputer (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_TURN_OFF_COMPUTER, &logonIPC, sizeof(logonIPC), false));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::EjectComputer
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Ejects the computer (docked laptop).
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::EjectComputer (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_EJECT_COMPUTER, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::SignalUIHostFailure
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Called when the UI host has an error that it cannot recover
//              from. This signals msgina to fall back to classic mode.
//
//  History:    2000-03-09  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::SignalUIHostFailure (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_SIGNAL_UIHOST_FAILURE, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::AllowExternalCredentials
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::AllowExternalCredentials (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_ALLOW_EXTERNAL_CREDENTIALS, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::RequestExternalCredentials
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::RequestExternalCredentials (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_REQUEST_EXTERNAL_CREDENTIALS, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::PackageIdentification
//
//  Arguments:  pwszUsername        =   User name.
//              pwszDomain          =   User domain.
//              pIdentification     =   Pointer to a LOGONIPC_USERID struct
//                                      which is masked as void* to allow
//                                      LogonIPC.h to not expose this detail.
//
//  Returns:    <none>
//
//  Purpose:    Takes the user name and domain and packages them into the
//              given struct. If no domain is given the a zero length string
//              is used which indicates to the logon service provider that
//              the local machine is desired.
//
//              Now parses the user name given. If the user has "\" then it
//              is assumed to be of the form "DOMAIN\USER". If the user has
//              "@" then it is assumed to be a UPN name.
//
//  History:    1999-08-20  vtan        created
//              2000-06-27  vtan        added UPN and DOMAIN parsing support
//  --------------------------------------------------------------------------

void    CLogonIPC::PackageIdentification (const WCHAR *pwszUsername, const WCHAR *pwszDomain, void *pIdentification)

{
    LPTSTR psz;
    LOGONIPC_USERID     *pLogonIPCUserID;

    pLogonIPCUserID = reinterpret_cast<LOGONIPC_USERID*>(pIdentification);

    pLogonIPCUserID->wszUsername[0] = L'\0';
    pLogonIPCUserID->wszDomain[0] = L'\0';
    
    psz = StrChrW(pwszUsername, L'\\');
    if (psz)
    {
        // stuff after the '\' is the username
        StringCchCopyW(pLogonIPCUserID->wszUsername, ARRAYSIZE(pLogonIPCUserID->wszUsername), psz + 1);

        // stuff before the '\' is the domain name
        StringCchCopyNW(pLogonIPCUserID->wszDomain, ARRAYSIZE(pLogonIPCUserID->wszDomain), pwszUsername, psz - pwszUsername);
    }
    else
    {
        StringCchCopyW(pLogonIPCUserID->wszUsername, ARRAYSIZE(pLogonIPCUserID->wszUsername), pwszUsername);
    }
}

//  --------------------------------------------------------------------------
//  CLogonIPC::SendToLogonService
//
//  Arguments:  wQueryType  =   What type of service we are interested in.
//              pData       =   Pointer to the data.
//              wDataSize   =   Size of the data.
//              fBlock      =   Block message pump or not.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Takes the package data and sends the message to the logon
//              service provider and receives the result. The logon service
//              provider started this process and reads this process' memory
//              directly (like a debugger would).
//
//              This function should block the message pump because if it
//              processes another state change message while waiting for a
//              response it could destroy data.
//
//  History:    1999-08-20  vtan        created
//              2001-06-22  vtan        changed to SendMessageTimeout
//              2001-06-28  vtan        added block parameter
//  --------------------------------------------------------------------------

bool    CLogonIPC::SendToLogonService (WORD wQueryType, void *pData, WORD wDataSize, bool fBlock)

{
    bool    fResult;

    fResult = IsLogonServiceAvailable();
    if (fResult)
    {
        DWORD_PTR   dwResult;

        reinterpret_cast<LOGONIPC*>(pData)->fResult = false;

        //  WARNING: Danger Will Robinson.

        //  Do NOT change INT_MAX to INFINITE. INT_MAX is a SIGNED number.
        //  INFINITE is an UNSIGNED number. Despite the SDK and prototype
        //  of SendMessageTimeout this timeout value is a SIGNED number.
        //  Passing in an unsigned number causes the timeout to be
        //  ignored and the function returns with a timeout.

        (LRESULT)SendMessageTimeout(_hwndLogonService,
                                    WM_LOGONSERVICEREQUEST,
                                    MAKEWPARAM(wDataSize, wQueryType),
                                    reinterpret_cast<LPARAM>(pData),
                                    fBlock ? SMTO_BLOCK : SMTO_NORMAL,
                                    INT_MAX,                                //  See above warning.
                                    &dwResult);
        fResult = (reinterpret_cast<LOGONIPC*>(pData)->fResult != FALSE);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonIPC::PostToLogonService
//
//  Arguments:  wQueryType  =   What type of service we are interested in.
//              pData       =   Pointer to the data.
//              wDataSize   =   Size of the data.
//
//  Returns:    <none>
//
//  Purpose:    Takes the package data and posts the message to the logon
//              service provider and receives the result. The logon service
//              provider started this process and reads this process' memory
//              directly (like a debugger would).
//
//  History:    1999-11-26  vtan        created
//  --------------------------------------------------------------------------

void    CLogonIPC::PostToLogonService (WORD wQueryType, void *pData, WORD wDataSize)

{
    if (IsLogonServiceAvailable())
    {
        TBOOL(PostMessage(_hwndLogonService, WM_LOGONSERVICEREQUEST, MAKEWPARAM(wDataSize, wQueryType), reinterpret_cast<LPARAM>(pData)));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       debug.cpp
//
//  Contents:   #defines so we can include shell\inc\debug.h
//
//----------------------------------------------------------------------------
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "SHGINA"
#define SZ_MODULE           "SHGINA"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\dllreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       DllReg.cpp
//
//  Contents:   automatic registration and unregistration
//
//----------------------------------------------------------------------------
#include "priv.h"
#include "resource.h"
#include <advpub.h>
#include <sddl.h>   // for string security descriptor stuff
#include <shfusion.h>
#include <MSGinaExports.h>

#include <ntlsa.h>

// prototypes
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine);

//
// Calls the ADVPACK entry-point which executes an inf
// file section.
//
HRESULT CallRegInstall(HINSTANCE hinst, LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    char szThisDLL[MAX_PATH];

    if (GetModuleFileNameA(hinst, szThisDLL, ARRAYSIZE(szThisDLL)))
    {
        STRENTRY seReg[] = {
            {"THISDLL", szThisDLL },
            { "25", "%SystemRoot%" },           // These two NT-specific entries
            { "11", "%SystemRoot%\\system32" }, // must be at the end of the table
        };
        STRTABLE stReg = {ARRAYSIZE(seReg) - 2, seReg};

        hr = RegInstall(hinst, szSection, &stReg);
    }

    return hr;
}


HRESULT UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    TCHAR szGuid[GUIDSTR_MAX];
    HKEY hk;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szGuid, ARRAYSIZE(szGuid));

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("TypeLib"), 0, MAXIMUM_ALLOWED, &hk) == ERROR_SUCCESS)
    {
        if (SHDeleteKey(hk, szGuid))
        {
            // success
            hr = S_OK;
        }
        RegCloseKey(hk);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    return hr;
}


HRESULT RegisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    ITypeLib* pTypeLib;
    WCHAR wszModuleName[MAX_PATH];

    // Load and register our type library.
    
    if (GetModuleFileNameW(HINST_THISDLL, wszModuleName, ARRAYSIZE(wszModuleName)))
    {
        hr = LoadTypeLib(wszModuleName, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library in case we had some old junk in the registry
            UnregisterTypeLibrary(piidLibrary);

            hr = RegisterTypeLib(pTypeLib, wszModuleName, NULL);
            if (FAILED(hr))
            {
                TraceMsg(TF_WARNING, "RegisterTypeLibrary: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "RegisterTypeLibrary: LoadTypeLib failed (%x) on", hr);
        }
    } 

    return hr;
}


BOOL SetDacl(LPTSTR pszTarget, SE_OBJECT_TYPE seType, LPCTSTR pszStringSD)
{
    BOOL bResult;
    PSECURITY_DESCRIPTOR pSD;

    bResult = ConvertStringSecurityDescriptorToSecurityDescriptor(pszStringSD,
                                                                  SDDL_REVISION_1,
                                                                  &pSD,
                                                                  NULL);
    if (bResult)
    {
        PACL pDacl;
        BOOL bPresent;
        BOOL bDefault;

        bResult = GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault);
        if (bResult)
        {
            DWORD dwErr;

            dwErr = SetNamedSecurityInfo(pszTarget,
                                         seType,
                                         DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         pDacl,
                                         NULL);

            if (ERROR_SUCCESS != dwErr)
            {
                SetLastError(dwErr);
                bResult = FALSE;
            }
        }

        LocalFree(pSD);
    }

    return bResult;
}


STDAPI DllRegisterServer()
{
    HRESULT hr;

    hr = CallRegInstall(HINST_THISDLL, "ShellUserOMInstall");
    ASSERT(SUCCEEDED(hr));

    // Grant Authenticated Users the right to create subkeys under the Hints key.
    // This is so non-admins can change their own hint.
    SetDacl(TEXT("MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Hints"),
            SE_REGISTRY_KEY,
            TEXT("D:(A;;0x4;;;AU)")); // 0x4 = KEY_CREATE_SUB_KEY

    hr = RegisterTypeLibrary(&LIBID_SHGINALib);
    ASSERT(SUCCEEDED(hr));

    return hr;
}


STDAPI DllUnregisterServer()
{
    return S_OK;
}


// this function is responsible for deleting the old file-based fusion manifests that were
// written out to system32 in XP client.
BOOL DeleteOldManifestFile(LPCTSTR pszFile)
{
    BOOL bRet = FALSE;
    TCHAR szOldManifestFile[MAX_PATH];

    if (GetSystemDirectory(szOldManifestFile, ARRAYSIZE(szOldManifestFile)) &&
        PathAppend(szOldManifestFile, pszFile))
    {
        DWORD dwAttributes = GetFileAttributes(szOldManifestFile);

        if ((dwAttributes != INVALID_FILE_ATTRIBUTES)   &&
            !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (dwAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
            {
                SetFileAttributes(szOldManifestFile, dwAttributes & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
            }

            bRet = DeleteFile(szOldManifestFile);
        }
    }

    return bRet;
}

//  --------------------------------------------------------------------------
//  IsLogonTypePresent
//
//  Arguments:  hKey    =   HKEY to HKLM\SW\MS\WINNT\CV\Winlogon.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the value "LogonType" is present. This helps
//              determines upgrade cases.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsLogonTypePresent (HKEY hKey)

{
    DWORD   dwType, dwLogonType, dwLogonTypeSize;

    dwLogonTypeSize = sizeof(dwLogonType);
    if ((RegQueryValueEx(hKey,
                         TEXT("LogonType"),
                         NULL,
                         &dwType,
                         reinterpret_cast<LPBYTE>(&dwLogonType),
                         &dwLogonTypeSize) == ERROR_SUCCESS)    &&
           (REG_DWORD == dwType))
    {
        return true;
    }

    return false;
}

//  --------------------------------------------------------------------------
//  IsDomainMember
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Is this machine a member of a domain? Use the LSA to get this
//              information.
//
//  History:    1999-09-14  vtan        created
//              2000-09-04  vtan        copied from msgina
//  --------------------------------------------------------------------------

bool    IsDomainMember (void)

{
    bool                            fResult;
    int                             iCounter;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               objectAttributes;
    LSA_HANDLE                      lsaHandle;
    SECURITY_QUALITY_OF_SERVICE     securityQualityOfService;
    PPOLICY_DNS_DOMAIN_INFO         pDNSDomainInfo;

    fResult = false;
    securityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    securityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    securityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    securityQualityOfService.EffectiveOnly = FALSE;
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);
    objectAttributes.SecurityQualityOfService = &securityQualityOfService;
    iCounter = 0;
    do
    {
        status = LsaOpenPolicy(NULL, &objectAttributes, POLICY_VIEW_LOCAL_INFORMATION, &lsaHandle);
        if (RPC_NT_SERVER_TOO_BUSY == status)
        {
            Sleep(10);
        }
    } while ((RPC_NT_SERVER_TOO_BUSY == status) && (++iCounter < 10));
    ASSERTMSG(iCounter < 10, "Abandoned advapi32!LsaOpenPolicy call - counter limit exceeded\r\n");
    if (NT_SUCCESS(status))
    {
        status = LsaQueryInformationPolicy(lsaHandle, PolicyDnsDomainInformation, reinterpret_cast<void**>(&pDNSDomainInfo));
        if (NT_SUCCESS(status) && (pDNSDomainInfo != NULL))
        {
            fResult = ((pDNSDomainInfo->DnsDomainName.Length != 0) ||
                       (pDNSDomainInfo->DnsForestName.Length != 0) ||
                       (pDNSDomainInfo->Sid != NULL));
            (NTSTATUS)LsaFreeMemory(pDNSDomainInfo);
        }
        (NTSTATUS)LsaClose(lsaHandle);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  IsDomainMembershipAttempted
//
//  Arguments:  hKey    =   HKEY to HKLM\SW\MS\WINNT\CV\Winlogon.
//
//  Returns:    bool
//
//  Purpose:    Returns whether a domain join was attempt (success or failure)
//              during network install.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsDomainMembershipAttempted (HKEY hKey)

{
    DWORD   dwType, dwRunNetAccessWizardType, dwRunNetAccessWizardTypeSize;

    dwRunNetAccessWizardTypeSize = sizeof(dwRunNetAccessWizardType);
    if ((RegQueryValueEx(hKey,
                         TEXT("RunNetAccessWizard"),
                         NULL,
                         &dwType,
                         reinterpret_cast<LPBYTE>(&dwRunNetAccessWizardType),
                         &dwRunNetAccessWizardTypeSize) == ERROR_SUCCESS)   &&
        (REG_DWORD == dwType)                                               &&
        ((NAW_PSDOMAINJOINED == dwRunNetAccessWizardType) || (NAW_PSDOMAINJOINFAILED == dwRunNetAccessWizardType)))
    {
        return true;
    }

    return false;
}

//  --------------------------------------------------------------------------
//  IsPersonal
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this product is personal.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsPersonal (void)

{
    return(IsOS(OS_PERSONAL) != FALSE);
}

//  --------------------------------------------------------------------------
//  IsProfessional
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this product is professional.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsProfessional (void)

{
    return(IsOS(OS_PROFESSIONAL) != FALSE);
}

//  --------------------------------------------------------------------------
//  IsServer
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this product is server.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsServer (void)

{
    return(IsOS(OS_ANYSERVER) != FALSE);
}

//  --------------------------------------------------------------------------
//  SetDefaultLogonType
//
//  Arguments:  ulWizardType    =   Type of network access configured during setup.
//
//  Returns:    <none>
//
//  Purpose:    Sets the default logon type based on network settings. In this case the
//              machine is still on a workgroup and therefore will have all
//              consumer UI enabled by default. Because join domain was
//              requested the logon type is set to classic GINA.
//
//  History:    2000-03-14  vtan        created
//              2000-07-24  vtan        turn on FUS by default
//              2000-09-04  vtan        moved from winlogon to shgina
//  --------------------------------------------------------------------------

void    SetDefaultLogonType (void)

{
    HKEY    hKeyWinlogon;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hKeyWinlogon))
    {

        //  Any of the following cause the logon type to be defaulted
        //  which means that the value is NOT written to the registry:
        //
        //  1.  Value already present (this is an upgrade).
        //  2.  Machine is a domain member (this is not supported).
        //  3.  Machine attempted to join a domain (this indicates security).
        //  4.  The product is a server
        //
        //  Otherwise the product is either personal or professional and
        //  the machine was joined to a workgroup or is a member of a workgroup
        //  and therefore requires the friendly UI.

        if (!IsLogonTypePresent(hKeyWinlogon) &&
            !IsDomainMember() &&
            !IsDomainMembershipAttempted(hKeyWinlogon) &&
            !IsServer())
        {
            MEMORYSTATUSEX  memoryStatusEx;

            TBOOL(ShellEnableFriendlyUI(TRUE));

            //  Multiple users used to be enabled when the friendly UI was
            //  enabled. However, on 64Mb machines the experience is
            //  unsatisfactory. Disable it on 64Mb or lower machines.

            memoryStatusEx.dwLength = sizeof(memoryStatusEx);
            GlobalMemoryStatusEx(&memoryStatusEx);
            TBOOL(ShellEnableMultipleUsers((memoryStatusEx.ullTotalPhys / (1024 * 1024) > 64)));
        }
        TW32(RegCloseKey(hKeyWinlogon));
    }
}


STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;

    if (bInstall)
    {
        // We shipped XP with file-based manifests. Since we now use resource-based manifests,
        // delete the old files
        DeleteOldManifestFile(TEXT("logonui.exe.manifest"));
        DeleteOldManifestFile(TEXT("WindowsLogon.manifest"));

        ShellInstallAccountFilterData();

#ifdef  _X86_
        SetDefaultLogonType();
#endif
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       DllMain.cpp
//
//  Contents:   DllMain routines
//
//----------------------------------------------------------------------------

#include "priv.h"
#define DECL_CRTFREE
#include <crtfree.h>

// dll refrence count;
LONG g_cRef = 0;

// global hinstance
HINSTANCE g_hinst = 0;

// from clocalmachine.cpp
BOOL FreeGuestSid();
BOOL FreeGuestAccountName();
BOOL FreeAdminAccountName();

// from cuser.cpp
BOOL FreeGroupNames();


//
// DllAddRef increment dll refrence count
//
void DllAddRef(void)
{
    InterlockedIncrement(&g_cRef);
}


//
// DllRelease decrement dll refrence count
//
void DllRelease(void)
{
    LONG lRet;

    ASSERT( 0 != g_cRef );

    lRet = InterlockedDecrement(&g_cRef);
}


//
// DllGetClassObject
//
// OLE entry point.  Produces an IClassFactory for the indicated GUID.
//
// The artificial refcount inside DllGetClassObject helps to
// avoid the race condition described in DllCanUnloadNow.  It's
// not perfect, but it makes the race window much smaller.
//
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    DllAddRef();
    if (IsEqualIID(rclsid, CLSID_ShellLogonEnumUsers)               ||
        IsEqualIID(rclsid, CLSID_ShellLogonUser)                    || 
        IsEqualIID(rclsid, CLSID_ShellLocalMachine)                 ||
        IsEqualIID(rclsid, CLSID_ShellLogonStatusHost))
        //IsEqualIID(rclsid, CLSID_ShellLogonUserEnumNotifications)   ||
        //IsEqualIID(rclsid, CLSID_ShellLogonUserNotification))
    {
        hr = CSHGinaFactory_Create(rclsid, riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    DllRelease();
    return hr;
}


//
// DllCanUnloadNow
//
// OLE entry point.  Fail iff there are outstanding refs.
//
// There is an unavoidable race condition between DllCanUnloadNow
// and the creation of a new IClassFactory:  Between the time we
// return from DllCanUnloadNow() and the caller inspects the value,
// another thread in the same process may decide to call
// DllGetClassObject, thus suddenly creating an object in this DLL
// when there previously was none.
//
// It is the caller's responsibility to prepare for this possibility;
// there is nothing we can do about it.
//
STDMETHODIMP DllCanUnloadNow()
{
    HRESULT hr;

    if (g_cRef == 0)
    {
        // refcount is zero, ok to unload
        hr = S_OK;
    }
    else
    {
        // still cocreated objects, dont unload
        hr = S_FALSE;
    }

    return hr;
}

#define OLD_USERS_AND_PASSWORD TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\NameSpace\\{7A9D77BD-5403-11d2-8785-2E0420524153}")

//
// DllMain (attach/deatch) routine
//
STDAPI_(BOOL) DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(lpReserved);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            // HACKHACK (phellyar) Delete this registry key everytime we're loaded
            // to prevent the old users and password cpl from appearing in the
            // control panel. Since we're loaded by the welcome screen, we'll
            // be able to delete this key before a user ever gets a chance to open
            // the control panel, thereby ensuring the old cpl doesn't appear.
            RegDeleteKey(HKEY_LOCAL_MACHINE, OLD_USERS_AND_PASSWORD);
                         
            // Don't put it under #ifdef DEBUG
            CcshellGetDebugFlags();
            DisableThreadLibraryCalls(hinst);
            g_hinst = hinst;
            break;

        case DLL_PROCESS_DETACH:
        {
            ASSERTMSG(g_cRef == 0, "Dll ref count is not zero: g_cRef = %d", g_cRef);

            FreeGuestSid();
            FreeGuestAccountName();
            FreeAdminAccountName();

            FreeGroupNames();
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\logonipc.h ===
//  --------------------------------------------------------------------------
//  Module Name: LogonIPC.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements communication between an external process and the
//  GINA logon dialog.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _LogonIPC_
#define     _LogonIPC_

//  --------------------------------------------------------------------------
//  CLogonIPC
//
//  Purpose:    This class handles sending messages to the GINA logon dialog
//              which provides logon services for an external process hosting
//              the UI for the logon. All string are unicode strings.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//              2000-03-09  vtan        added UI host failure
//  --------------------------------------------------------------------------

class   CLogonIPC
{
    private:
                            CLogonIPC (const CLogonIPC& copyObject);
        bool                operator == (const CLogonIPC& compareObject)    const;
        const CLogonIPC&    operator = (const CLogonIPC& assignObject);
    public:
                            CLogonIPC (void);
                            ~CLogonIPC (void);

        bool                IsLogonServiceAvailable (void);
        bool                IsUserLoggedOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                LogUserOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword);
        bool                LogUserOff (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                TestBlankPassword (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                TestInteractiveLogonAllowed (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                TestEjectAllowed (void);
        bool                TestShutdownAllowed (void);
        bool                TurnOffComputer (void);
        bool                EjectComputer (void);
        bool                SignalUIHostFailure (void);
        bool                AllowExternalCredentials (void);
        bool                RequestExternalCredentials (void);
    private:
        void                PackageIdentification (const WCHAR *pwszUsername, const WCHAR *pwszDomain, void *pIdentification);
        bool                SendToLogonService (WORD wQueryType, void *pData, WORD wDataSize, bool fBlock);
        void                PostToLogonService (WORD wQueryType, void *pData, WORD wDataSize);
    private:
        int                 _iLogonAttemptCount;
        HWND                _hwndLogonService;
};

#endif  /*  _LogonIPC_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\priv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       priv.h
//
//  Contents:   precompiled header for shgina.dll
//
//----------------------------------------------------------------------------
#ifndef _PRIV_H_
#define _PRIV_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <oleauto.h>    // for IEnumVARIANT
#include <lmcons.h>     // for NET_API_STATUS

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <ccstock.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shlobjp.h>

#include <shgina.h>     // our IDL generated header file

#include <commctrl.h>   // these are needed
#include <comctrlp.h>   // for HDPA

#include <shlwapi.h>    // these are needed
#include <shlwapip.h>   // for QISearch

#include <w4warn.h>

#include <msginaexports.h>

#include <tchar.h>      // for _TEOF

#include <strsafe.h>

// dll ref counting functions
STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

// class factory helper function
HRESULT CSHGinaFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

// helper for setting permissions on newly created files and reg keys
#include <aclapi.h>     // for SE_OBJECT_TYPE
BOOL SetDacl(LPTSTR pszTarget, SE_OBJECT_TYPE seType, LPCTSTR pszStringSD);


// global hinstance
extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

// global dll refrence count
extern LONG g_cRef;


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\atl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\docfile.cpp ===
#include "precomp.h"
#include "thumbutil.h"
#include "strsafe.h"

HRESULT GetMediaManagerThumbnail(IPropertyStorage * pPropStg, const SIZE * prgSize, 
                            DWORD dwClrDepth, HPALETTE hpal, BOOL fOrigSize,
                            HBITMAP * phBmpThumbnail);
                                  
HRESULT GetDocFileThumbnail(IPropertyStorage * pPropStg, const SIZE * prgSize, 
                            DWORD dwClrDepth, HPALETTE hpal, BOOL fOrigSize,
                            HBITMAP * phBmpThumbnail);

// PACKEDMETA struct for DocFile thumbnails.
typedef struct
{
    WORD    mm;
    WORD    xExt;
    WORD    yExt;
    WORD    dummy;
} PACKEDMETA;

VOID CalcMetaFileSize(HDC hDC, PACKEDMETA * pMeta, const SIZEL * prgSize, RECT * pRect);

CDocFileThumb::CDocFileThumb()
{
    m_pszPath = NULL;
}

CDocFileThumb::~CDocFileThumb()
{
    LocalFree(m_pszPath);   // accepts NULL
}

STDMETHODIMP CDocFileThumb::GetLocation(LPWSTR pszFileName, DWORD cchMax,
                                        DWORD * pdwPriority, const SIZE * prgSize,
                                        DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (m_pszPath)
    {
        m_rgSize = *prgSize;
        m_dwRecClrDepth = dwRecClrDepth;
        
        // just copy the current path into the buffer as we do not share thumbnails...
        hr = StringCchCopyW(pszFileName, cchMax, m_pszPath);

        if (SUCCEEDED(hr))
        {
            if (*pdwFlags & IEIFLAG_ASYNC)
            {
                // we support async 
                hr = E_PENDING;
                *pdwPriority = PRIORITY_EXTRACT_NORMAL;
            }

            m_fOrigSize = BOOLIFY(*pdwFlags & IEIFLAG_ORIGSIZE);
            
            // we don't want it cached....
            *pdwFlags &= ~IEIFLAG_CACHE;
        }        
    }

    return hr;
}

HPALETTE PaletteFromClrDepth(DWORD dwRecClrDepth)
{
    HPALETTE hpal = NULL;
    if (dwRecClrDepth == 8)
    {
        hpal = SHCreateShellPalette(NULL);
    }
    else if (dwRecClrDepth < 8)
    {
        hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
    }
    return hpal;
}

STDMETHODIMP CDocFileThumb::Extract(HBITMAP * phBmpThumbnail)
{
    if (!m_pszPath)
        return E_UNEXPECTED;
    
    IStorage *pstg;
    HRESULT hr = StgOpenStorage(m_pszPath, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, NULL, &pstg);
    if (SUCCEEDED(hr))
    {
        IPropertySetStorage *pPropSetStg;
        hr = pstg->QueryInterface(IID_PPV_ARG(IPropertySetStorage, &pPropSetStg));
        if (SUCCEEDED(hr))
        {
            // "MIC" Microsoft Image Composer files needs special casing because they use
            // the Media Manager internal thumbnail propertyset ... (by what it would be like
            // to be standard for once ....)
            FMTID fmtidPropSet = StrCmpIW(PathFindExtensionW(m_pszPath), L".MIC") ?
                FMTID_SummaryInformation : FMTID_CmsThumbnailPropertySet;

            IPropertyStorage *pPropSet;
            hr = pPropSetStg->Open(fmtidPropSet, STGM_READ | STGM_SHARE_EXCLUSIVE, &pPropSet);
            if (SUCCEEDED(hr))
            {
                HPALETTE hpal = PaletteFromClrDepth(m_dwRecClrDepth);
    
                if (FMTID_CmsThumbnailPropertySet == fmtidPropSet)
                {
                    hr = GetMediaManagerThumbnail(pPropSet, &m_rgSize, m_dwRecClrDepth, hpal, m_fOrigSize, phBmpThumbnail);
                }
                else
                {
                    hr = GetDocFileThumbnail(pPropSet, &m_rgSize, m_dwRecClrDepth, hpal, m_fOrigSize, phBmpThumbnail);
                }

                if (hpal)
                    DeleteObject(hpal);
                pPropSet->Release();
            }
            pPropSetStg->Release();
        }
        pstg->Release();
    }
    
    return hr;   
}

STDMETHODIMP CDocFileThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    LocalFree(m_pszPath);
    return SHStrDup(pszFileName, &m_pszPath);
}

HRESULT GetMediaManagerThumbnail(IPropertyStorage * pPropStg,
                                 const SIZE * prgSize, DWORD dwClrDepth,
                                 HPALETTE hpal, BOOL fOrigSize, HBITMAP * phBmpThumbnail)
{
    // current version of media manager simply stores the DIB data in a under a 
    // named property Thumbnail...
    // read the thumbnail property from the property storage.
    PROPVARIANT pvarResult = {0};
    PROPSPEC propSpec;

    propSpec.ulKind = PRSPEC_LPWSTR;
    propSpec.lpwstr = L"Thumbnail";
    
    HRESULT hr = pPropStg->ReadMultiple(1, &propSpec, &pvarResult);
    if (SUCCEEDED(hr))
    {
        BITMAPINFO * pbi = (BITMAPINFO *)pvarResult.blob.pBlobData;
        void *pBits = CalcBitsOffsetInDIB(pbi);
        
        hr = E_FAIL;
        if (pbi->bmiHeader.biSize == sizeof(BITMAPINFOHEADER))
        {
            if (ConvertDIBSECTIONToThumbnail(pbi, pBits, phBmpThumbnail, prgSize, dwClrDepth, hpal, 15, fOrigSize))
            {
                hr = S_OK;
            }
        }

        PropVariantClear(&pvarResult);
    }
    
    return hr;
}

HRESULT GetDocFileThumbnail(IPropertyStorage * pPropStg,
                            const SIZE * prgSize, DWORD dwClrDepth,
                            HPALETTE hpal, BOOL fOrigSize, HBITMAP * phBmpThumbnail)
{
    HRESULT hr;

    HDC hDC = GetDC(NULL);
    HDC hMemDC = CreateCompatibleDC(hDC);
    if (hMemDC)
    {
        HBITMAP hBmp = NULL;
        PROPSPEC propSpec;
        PROPVARIANT pvarResult = {0};
        // read the thumbnail property from the property storage.
        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = PIDSI_THUMBNAIL;
        hr = pPropStg->ReadMultiple(1, &propSpec, &pvarResult);
        if (SUCCEEDED(hr))
        {
            // assume something is going to go terribly wrong
            hr = E_FAIL;

            // make sure we are dealing with a clipboard format. CLIPDATA
            if ((pvarResult.vt == VT_CF) && (pvarResult.pclipdata->ulClipFmt == -1))
            {
                LPDWORD pdwCF = (DWORD *)pvarResult.pclipdata->pClipData;
                LPBYTE  pStruct = pvarResult.pclipdata->pClipData + sizeof(DWORD);

                if (*pdwCF == CF_METAFILEPICT)
                {
                    SetMapMode(hMemDC, MM_TEXT);
                
                    // handle thumbnail that is a metafile.
                    PACKEDMETA * pMeta = (PACKEDMETA *)pStruct;
                    LPBYTE pData = pStruct + sizeof(PACKEDMETA);
                    RECT rect;

                    UINT cbSize = pvarResult.pclipdata->cbSize - sizeof(DWORD) - sizeof(pMeta->mm) - 
                    sizeof(pMeta->xExt) - sizeof(pMeta->yExt) - sizeof(pMeta->dummy);

                    // save as a metafile.
                    HMETAFILE hMF = SetMetaFileBitsEx(cbSize, pData);
                    if (hMF)
                    {    
                        SIZE rgNewSize;
                    
                        // use the mapping mode to calc the current size
                        CalcMetaFileSize(hMemDC, pMeta, prgSize, & rect);
                    
                        CalculateAspectRatio(prgSize, &rect);

                        if (fOrigSize)
                        {
                            // use the aspect rect to refigure the size...
                            rgNewSize.cx = rect.right - rect.left;
                            rgNewSize.cy = rect.bottom - rect.top;
                            prgSize = &rgNewSize;
                        
                            // adjust the rect to be the same as the size (which is the size of the metafile)
                            rect.right -= rect.left;
                            rect.bottom -= rect.top;
                            rect.left = 0;
                            rect.top = 0;
                        }

                        if (CreateSizedDIBSECTION(prgSize, dwClrDepth, hpal, NULL, &hBmp, NULL, NULL))
                        {
                            HGDIOBJ hOldBmp = SelectObject(hMemDC, hBmp);
                            HGDIOBJ hBrush = GetStockObject(WHITE_BRUSH);
                            HGDIOBJ hOldBrush = SelectObject(hMemDC, hBrush);
                            HGDIOBJ hPen = GetStockObject(WHITE_PEN);
                            HGDIOBJ hOldPen = SelectObject(hMemDC, hPen);

                            Rectangle(hMemDC, 0, 0, prgSize->cx, prgSize->cy);
        
                            SelectObject(hMemDC, hOldBrush);
                            SelectObject(hMemDC, hOldPen);
                    
                            int iXBorder = 0;
                            int iYBorder = 0;
                            if (rect.left == 0)
                            {
                                iXBorder ++;
                            }
                            if (rect.top == 0)
                            {
                                iYBorder ++;
                            }
                        
                            SetViewportExtEx(hMemDC, rect.right - rect.left - 2 * iXBorder, rect.bottom - rect.top - 2 * iYBorder, NULL);
                            SetViewportOrgEx(hMemDC, rect.left + iXBorder, rect.top + iYBorder, NULL);

                            SetMapMode(hMemDC, pMeta->mm);

                            // play the metafile.
                            BOOL bRet = PlayMetaFile(hMemDC, hMF);
                            if (bRet)
                            {
                                *phBmpThumbnail = hBmp;
                                if (*phBmpThumbnail)
                                {
                                    // we got the thumbnail bitmap, return success.
                                    hr = S_OK;
                                }
                            }

                            DeleteMetaFile(hMF);
                            SelectObject(hMemDC, hOldBmp);

                            if (FAILED(hr) && hBmp)
                            {
                                DeleteObject(hBmp);
                            }
                        }
                        else
                        {
                            hr = DV_E_CLIPFORMAT;
                        }
                    }
                }
                else if (*pdwCF == CF_DIB)
                {
                    // handle thumbnail that is a bitmap.
                    BITMAPINFO * pDib = (BITMAPINFO *) pStruct;

                    if (pDib->bmiHeader.biSize == sizeof(BITMAPINFOHEADER))
                    {
                        void *pBits = CalcBitsOffsetInDIB(pDib);
                    
                        if (ConvertDIBSECTIONToThumbnail(pDib, pBits, phBmpThumbnail, prgSize, dwClrDepth, hpal, 15, fOrigSize))
                        {
                            hr = S_OK;
                        }
                        else
                        {
                            hr = DV_E_CLIPFORMAT;
                        }
                    }
                }
                else
                {
                    hr = DV_E_CLIPFORMAT;
                }
            }
            else
            {
                hr = DV_E_CLIPFORMAT;
            }
            PropVariantClear(&pvarResult);
        }
        DeleteDC(hMemDC);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    ReleaseDC(NULL, hDC);
    return hr;
}


VOID CalcMetaFileSize(HDC hDC, PACKEDMETA * prgMeta, const SIZEL * prgSize, RECT * prgRect)
{
    ASSERT(prgMeta && prgRect);

    prgRect->left = 0;
    prgRect->top = 0;

    if (!prgMeta->xExt || !prgMeta->yExt)
    {
        // no size, then just use the size rect ...
        prgRect->right = prgSize->cx;
        prgRect->bottom = prgSize->cy;
    }
    else
    {
        // set the mapping mode....
        SetMapMode(hDC, prgMeta->mm);

        if (prgMeta->mm == MM_ISOTROPIC || prgMeta->mm == MM_ANISOTROPIC)
        {
            // we must set the ViewPortExtent and the window extent to get the scaling
            SetWindowExtEx(hDC, prgMeta->xExt, prgMeta->yExt, NULL);
            SetViewportExtEx(hDC, prgMeta->xExt, prgMeta->yExt, NULL);
        }

        POINT pt;
        pt.x = prgMeta->xExt;
        pt.y = prgMeta->yExt;

        // convert to pixels....
        LPtoDP(hDC, &pt, 1);

        prgRect->right = abs(pt.x);
        prgRect->bottom = abs(pt.y);
    }
}

STDMETHODIMP CDocFileThumb::GetClassID(CLSID * pCLSID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocFileThumb::IsDirty()
{
    return S_FALSE;
}

STDMETHODIMP CDocFileThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocFileThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocFileThumb::GetCurFile(LPOLESTR * ppszFileName)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\events.cpp ===
// FooBarEvents.cpp : Implementation of CWebTestApp and DLL registration.

#include "precomp.h"

#include "Events.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shgina\userom.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       UserOM.h
//
//  Contents:   shell user object model (interface implemtation for ILogonEnumUsers, ILogonUser)
//
//----------------------------------------------------------------------------
#ifndef _USEROM_H_
#define _USEROM_H_

#include "priv.h"

#include "CIDispatchHelper.h"
#include "UIHostIPC.h"
#include "CInteractiveLogon.h"

HRESULT _IsGuestAccessMode(void);

const TCHAR CDECL c_szRegRoot[]         = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Hints");
const TCHAR CDECL c_szPictureSrcVal[]   = TEXT("PictureSource");

// prototypes for class factory functions
STDAPI CLogonEnumUsers_Create(REFIID riid, void** ppvObj);
STDAPI CLocalMachine_Create(REFIID riid, void** ppvObj);
STDAPI CLogonStatusHost_Create(REFIID riid, void** ppvObj);
STDAPI CLogonUser_Create(REFIID riid, void** ppvObj);

class CLogonEnumUsers : public CIDispatchHelper,
                        public IEnumVARIANT,
                        public ILogonEnumUsers
{

public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(ULONG cUsers, VARIANT* rgvar, ULONG* pcUsersFetched);
    virtual STDMETHODIMP Skip(ULONG cUsers);
    virtual STDMETHODIMP Reset();
    virtual STDMETHODIMP Clone(IEnumVARIANT** ppenum);

    // *** ILogonEnumUsers ***
    virtual STDMETHODIMP get_Domain(BSTR* pbstr);
    virtual STDMETHODIMP put_Domain(BSTR bstr);
    virtual STDMETHODIMP get_EnumFlags(ILUEORDER* porder);
    virtual STDMETHODIMP put_EnumFlags(ILUEORDER order);
    virtual STDMETHODIMP get_length(UINT* pcUsers);
    virtual STDMETHODIMP get_currentUser(ILogonUser** ppLogonUserInfo);
    virtual STDMETHODIMP item(VARIANT varUserId, ILogonUser** ppLogonUserInfo);
    virtual STDMETHODIMP _NewEnum(IUnknown** ppunk);

    virtual STDMETHODIMP create(BSTR bstrLoginName, ILogonUser **ppLogonUser);
    virtual STDMETHODIMP remove(VARIANT varUserId, VARIANT varBackupPath, VARIANT_BOOL *pbSuccess);
        
public:
    // friend functions
    friend HRESULT CLogonEnumUsers_Create(REFIID riid, void** ppvObj);

private:
    // private member variables
    int _cRef;

    TCHAR _szDomain[256];       // name of the domain we are enumerating users on
    ILUEORDER _enumorder;       // order in which to enumerate users
    HDPA _hdpaUsers;             // dpa holding the list of enumerated users

    // private member functions
    HRESULT _EnumerateUsers();
    HRESULT _GetUserByIndex(LONG lUserID, ILogonUser** ppLogonUserInfo);
    HRESULT _GetUserByName(BSTR bstrUserName, ILogonUser** ppLogonUserInfo);
    void _DestroyHDPAUsers();
    CLogonEnumUsers();
    ~CLogonEnumUsers();
};

class CLogonUser : public CIDispatchHelper,
                   public ILogonUser
{

public:
    static HRESULT Create(LPCTSTR pszLoginName, LPCTSTR pszFullName, LPCTSTR pszDomain, REFIID riid, LPVOID* ppv);

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** ILogonUser ***
    virtual STDMETHODIMP get_setting(BSTR bstrName, VARIANT* pvarVal);
    virtual STDMETHODIMP put_setting(BSTR bstrName, VARIANT varVal);
    virtual STDMETHODIMP get_isLoggedOn(VARIANT_BOOL* pbLoggedIn);
    virtual STDMETHODIMP get_passwordRequired(VARIANT_BOOL* pbPasswordRequired);
    virtual STDMETHODIMP get_interactiveLogonAllowed(VARIANT_BOOL *pbInteractiveLogonAllowed);
    virtual STDMETHODIMP get_isProfilePrivate(VARIANT_BOOL* pbPrivate);
    virtual STDMETHODIMP get_isPasswordResetAvailable(VARIANT_BOOL* pbResetAvailable);

    virtual STDMETHODIMP logon(BSTR pstrPassword, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP logoff(VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP changePassword(VARIANT varNewPassword, VARIANT varOldPassword, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP makeProfilePrivate(VARIANT_BOOL bPrivate);
    virtual STDMETHODIMP getMailAccountInfo(UINT uiAccountIndex, VARIANT *pvarAccountName, UINT *pcUnreadMessages);

private:

    // private member variables
    int      _cRef;
    TCHAR    _szLoginName[UNLEN + sizeof('\0')];
    TCHAR    _szDomain[DNLEN + sizeof('\0')];
    BSTR     _strDisplayName;
    TCHAR    _szPicture[MAX_PATH+7];  // +7 for "file://" prefix
    BSTR     _strPictureSource;
    BSTR     _strHint;
    BSTR     _strDescription;
    BOOL     _bPasswordRequired;
    int      _iPrivilegeLevel;
    LPTSTR   _pszSID;

    // private member functions
    CLogonUser(LPCTSTR pszLoginName, LPCTSTR pszFullName, LPCTSTR pszDomain);
    ~CLogonUser();

    HRESULT _InitPicture();
    HRESULT _SetPicture(LPCTSTR pszNewPicturePath);
    DWORD   _OpenUserHintKey(REGSAM sam, HKEY *phkey);

    HRESULT _UserSettingAccessor(BSTR bstrName, VARIANT *pvarVal, BOOL bPut);

    // DisplayName 
    HRESULT _GetDisplayName(VARIANT* pvar);
    HRESULT _PutDisplayName(VARIANT var);

    // LoginName
    HRESULT _GetLoginName(VARIANT* pvar);
    HRESULT _PutLoginName(VARIANT var);

    // Domain
    HRESULT _GetDomain(VARIANT* pvar);

    // Picture
    HRESULT _GetPicture(VARIANT* pvar);
    HRESULT _PutPicture(VARIANT var);
    HRESULT _GetPictureSource(VARIANT* pvar);

    // Description
    HRESULT _GetDescription(VARIANT* pvar);
    HRESULT _PutDescription(VARIANT var);

    // Hint
    HRESULT _GetHint(VARIANT* pvar);
    HRESULT _PutHint(VARIANT var);

    // AccountType
    HRESULT _GetAccountType(VARIANT* pvar);
    HRESULT _PutAccountType(VARIANT var);

    // SID
    HRESULT _LookupUserSid();
    HRESULT _GetSID(VARIANT* pvar);

    //
    DWORD   _GetExpiryDays (HKEY hKeyCurrentUser);
    HRESULT _GetUnreadMail(VARIANT* pvar);
};

class CLocalMachine : public CIDispatchHelper,
                      public ILocalMachine
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** ILocalMachine ***
    virtual STDMETHODIMP get_MachineName(VARIANT* pvar);
    virtual STDMETHODIMP get_isGuestEnabled(ILM_GUEST_FLAGS flags, VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP get_isFriendlyUIEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP put_isFriendlyUIEnabled(VARIANT_BOOL bEnabled);
    virtual STDMETHODIMP get_isMultipleUsersEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP put_isMultipleUsersEnabled(VARIANT_BOOL bEnabled);
    virtual STDMETHODIMP get_isRemoteConnectionsEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP put_isRemoteConnectionsEnabled(VARIANT_BOOL bEnabled);
    virtual STDMETHODIMP get_AccountName(VARIANT varAccount, VARIANT* pvar);
    virtual STDMETHODIMP get_isUndockEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP get_isShutdownAllowed(VARIANT_BOOL* pbShutdownAllowed);
    virtual STDMETHODIMP get_isGuestAccessMode(VARIANT_BOOL* pbForceGuest);
    virtual STDMETHODIMP get_isOfflineFilesEnabled(VARIANT_BOOL *pbEnabled);

    virtual STDMETHODIMP TurnOffComputer(void);
    virtual STDMETHODIMP SignalUIHostFailure(void);
    virtual STDMETHODIMP AllowExternalCredentials(void);
    virtual STDMETHODIMP RequestExternalCredentials(void);
    virtual STDMETHODIMP LogonWithExternalCredentials(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP InitiateInteractiveLogon(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, DWORD dwTimeout, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP UndockComputer(void);
    virtual STDMETHODIMP EnableGuest(ILM_GUEST_FLAGS flags);
    virtual STDMETHODIMP DisableGuest(ILM_GUEST_FLAGS flags);

public:
    // friend Functions
    friend HRESULT CLocalMachine_Create(REFIID riid, LPVOID* ppv);

private:
    // private member variables
    int _cRef;

private:
    // private member functions
    CLocalMachine(void);
    ~CLocalMachine();

    static  void    RefreshStartMenu(void);
};

class CLogonStatusHost : public CIDispatchHelper,
                         public ILogonStatusHost
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** ILogonStatusHost ***
    virtual STDMETHODIMP Initialize(HINSTANCE hInstance, HWND hwndHost);
    virtual STDMETHODIMP WindowProcedureHelper(HWND hwnd, UINT uMsg, VARIANT wParam, VARIANT lParam);
    virtual STDMETHODIMP UnInitialize(void);

public:
    // friend Functions
    friend HRESULT CLogonStatusHost_Create(REFIID riid, LPVOID* ppv);

private:
    // implementation helpers
    LRESULT Handle_WM_UISERVICEREQUEST (WPARAM wParam, LPARAM lParam);
    LRESULT Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam);
    static  LRESULT CALLBACK    StatusWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    // terminal service wait helpers
    bool IsTermServiceDisabled (void);
    void StartWaitForTermService (void);
    void EndWaitForTermService (void);
    void WaitForTermService (void);
    static DWORD WINAPI CB_WaitForTermService (void *pParameter);
    // parent process wait helpers
    void StartWaitForParentProcess (void);
    void EndWaitForParentProcess (void);
    void WaitForParentProcess (void);
    static DWORD WINAPI CB_WaitForParentProcess (void *pParameter);
    // thread helper
    static void CALLBACK CB_WakeupThreadAPC (ULONG_PTR dwParam);
private:
    // private member variables
    int _cRef;

    HINSTANCE               _hInstance;
    HWND                    _hwnd;
    HWND                    _hwndHost;
    ATOM                    _atom;
    BOOL                    _fRegisteredNotification;
    HANDLE                  _hThreadWaitForTermService;
    HANDLE                  _hThreadWaitForParentProcess;
    HANDLE                  _hProcessParent;
    CInteractiveLogon       _interactiveLogon;

    static  const WCHAR     s_szTermSrvReadyEventName[];
public:
    // private member functions
    CLogonStatusHost(void);
    ~CLogonStatusHost();

};


#endif // _USEROM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\docfile.h ===
#ifndef _DOCFILE_H
#define _DOCFILE_H

class CDocFileThumb :   public IExtractImage,
                        public IPersistFile,
                        public CComObjectRoot,
                        public CComCoClass< CDocFileThumb,&CLSID_DocfileThumbnailHandler >
{
public:
    CDocFileThumb();
    ~CDocFileThumb();
    
    BEGIN_COM_MAP( CDocFileThumb )
        COM_INTERFACE_ENTRY( IExtractImage )
        COM_INTERFACE_ENTRY( IPersistFile )
    END_COM_MAP( )

    DECLARE_REGISTRY( CDocFileThumb,
                      _T("Shell.ThumbnailExtract.Docfile.1"),
                      _T("Shell.ThumbnailExtract.DocFile.1"),
                      IDS_DOCTHUMBEXTRACT_DESC,
                      THREADFLAGS_APARTMENT);

    DECLARE_NOT_AGGREGATABLE( CDocFileThumb );

    // IExtractThumbnail
    STDMETHOD (GetLocation) ( LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags );
 
    STDMETHOD (Extract)( HBITMAP * phBmpThumbnail);

    // IPersistFile
    STDMETHOD (GetClassID)(CLSID * pCLSID );
    STDMETHOD (IsDirty)(void);
    STDMETHOD (Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile)(LPOLESTR * ppszFileName);
protected:
    LPWSTR m_pszPath;
    SIZE m_rgSize;
    DWORD m_dwRecClrDepth;
    BITBOOL m_fOrigSize : 1;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\autoplay.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "prevwnd.h"

#include <shpriv.h>

DWORD g_dwThreadID = 0;

class CAutoplayForSlideShow : public IHWEventHandler,
                              public IDropTarget,
                              public NonATLObject
{
public:
    CAutoplayForSlideShow() : _cRef(1) {}

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IHWEventHandler
    STDMETHOD(Initialize)(LPCWSTR pszParams);
    STDMETHOD(HandleEvent)(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID,
        LPCWSTR pszEventType);
    STDMETHOD(HandleEventWithContent)(LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj);

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    LONG _cRef;
};


STDMETHODIMP CAutoplayForSlideShow::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CAutoplayForSlideShow, IHWEventHandler),
        QITABENT(CAutoplayForSlideShow, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CAutoplayForSlideShow::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAutoplayForSlideShow::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI CAutoplayForSlideShow_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CAutoplayForSlideShow* pass = new CAutoplayForSlideShow();
    if (!pass)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pass->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pass->Release();
    return hr;
}

STDMETHODIMP CAutoplayForSlideShow::Initialize(LPCWSTR)
{
    // We don't care about params a this point
    return S_OK;
}

STDMETHODIMP CAutoplayForSlideShow::HandleEvent(LPCWSTR pszDeviceID,
    LPCWSTR pszAltDeviceID, LPCWSTR pszEventType)
{
    return E_NOTIMPL;
}

DWORD WINAPI SlideShowThread(void* pv)
{
    IStream *pstm = (IStream *)pv;
    IDataObject* pdtobj;
    HRESULT hr = CoGetInterfaceAndReleaseStream(pstm, IID_PPV_ARG(IDataObject, &pdtobj));
    if (SUCCEEDED(hr))
    {
        CPreviewWnd cwndPreview;
        hr = cwndPreview.Initialize(NULL, SLIDESHOW_MODE, TRUE);
        if (SUCCEEDED(hr))
        {
            // 4 is the walk depth, make sure we pick up pictures
            if (cwndPreview.CreateSlideshowWindow(4))
            {
                hr = cwndPreview.StartSlideShow(pdtobj);
                if (SUCCEEDED(hr))
                {
                    MSG msg;

                    while (GetMessage(&msg, NULL, 0, 0))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }

                    ::PostThreadMessage(g_dwThreadID, WM_QUIT, 0, 0);
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }

        pdtobj->Release();
    }

    return hr;
}

HRESULT _StartSlideShowThread(IDataObject *pdo)
{
    IStream *pstm;
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdo, &pstm);
    if (SUCCEEDED(hr))
    {
        //  maybe do threadref?
        if (!SHCreateThread(SlideShowThread, pstm, CTF_COINIT, NULL))
        {
            pstm->Release();
            hr = E_FAIL;
        }
    }
    return hr;
}

STDMETHODIMP CAutoplayForSlideShow::HandleEventWithContent(
    LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
    LPCWSTR pszContentTypeHandler, IDataObject* pdtobj)
{
    return _StartSlideShowThread(pdtobj);
}

// IDropTarget::DragEnter
HRESULT CAutoplayForSlideShow::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragOver
HRESULT CAutoplayForSlideShow::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragLeave
HRESULT CAutoplayForSlideShow::DragLeave(void)
{
    return S_OK;
}

// IDropTarget::DragDrop
HRESULT CAutoplayForSlideShow::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return _StartSlideShowThread(pdtobj);
}

void WINAPI ImageView_COMServer(HWND hwnd, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow)
{
    HRESULT hrOle = SHCoInitialize();
    if (SUCCEEDED(hrOle))
    {
        g_dwThreadID = GetCurrentThreadId();

        IUnknown* punkFact;
        // the preview window will init GDI+
        HRESULT hr = DllGetClassObject(CLSID_AutoplayForSlideShow, IID_PPV_ARG(IUnknown, &punkFact));
        if (SUCCEEDED(hr))
        {
            DWORD dwROC;
            hr = CoRegisterClassObject(CLSID_AutoplayForSlideShow, punkFact, CLSCTX_LOCAL_SERVER,
                REGCLS_SINGLEUSE, &dwROC);

            if (SUCCEEDED(hr))
            {
                MSG msg;

                while (GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

                CoRevokeClassObject(dwROC);
            }

            punkFact->Release();
        }

        SHCoUninitialize(hrOle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\events.h ===
// Events.h: Definition of the FooBarEvents class
//
//////////////////////////////////////////////////////////////////////

#if !defined(__EVENTS_H__06E192AB_5CAD_11D1_B670_00A024E430AB__INCLUDED_)
#define __EVENTS_H__06E192AB_5CAD_11D1_B670_00A024E430AB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "shimgvw.h"

/////////////////////////////////////////////////////////////////////////////
// FooBarEvents

class CEvents
{
public:
    virtual void OnClose()
    {}
    virtual void OnPreviewReady()
    {}
    virtual void OnError()
    {}
    virtual void OnChangeUI()
    {}
    virtual void OnBestFitPress()
    {}
    virtual void OnActualSizePress()
    {}
};

template <class T>
class CControlEvents : public CEvents,
                       public IConnectionPointImpl<T, &DIID_DPreviewEvents, CComDynamicUnkArray>
{
protected:
    void _FireEvent( DWORD dwID, DISPPARAMS *pdisp = NULL )
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };

                if ( !pdisp )
                    pdisp = &disp;
                    
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(dwID, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, pdisp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
};

template <class T>
class CPreviewEvents : public CControlEvents<T>
{
public:
    virtual void OnClose()
    {
        _FireEvent( 0x1 );
    }
    virtual void OnPreviewReady()
    {
        _FireEvent( 0x2 );
    }
    virtual void OnError()
    {
        _FireEvent( 0x3 );
    }
    virtual void OnBestFitPress()
    {
        _FireEvent( 0x4 );
    }
    virtual void OnActualSizePress()
    {
        _FireEvent( 0x5 );
    }
};

#endif // !defined(__EVENTS_H__06E192AB_5CAD_11D1_B670_00A024E430AB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\guids.h ===
// GUIDs for the categories of tasks that we have:
DEFINE_GUID(TOID_PrimaryDecode, 0xAC5B936C, 0xFB81, 0x4E8B, 0x9B, 0x46, 0x74, 0x76, 0xFF, 0xB8, 0x3A, 0x81);
DEFINE_GUID(TOID_SlideshowDecode, 0x2b4ce8db, 0x3372, 0x465e, 0x9f, 0x27, 0xad, 0x60, 0x3e, 0xac, 0x4e, 0xa0);
DEFINE_GUID(TOID_DrawFrame, 0x702B4720, 0xCFAA, 0x4FB8, 0x93, 0xE8, 0xF3, 0x53, 0x9C, 0x18, 0x40, 0xE2);
DEFINE_GUID(TOID_DrawSlideshowFrame, 0x7d24187d, 0xb5be, 0x4226, 0x92, 0x8f, 0x8e, 0xda, 0x7b, 0x14, 0x94, 0x1c);

// Class ID for the context menu handler
/* e84fda7c-1d6a-45f6-b725-cb260c236066 */
DEFINE_GUID(CLSID_PhotoVerbs, 0xe84fda7c, 0x1d6a, 0x45f6, 0xb7, 0x25, 0xcb, 0x26, 0x0c, 0x23, 0x60, 0x66);

// the Media Manager Thumbnail Property set FormatID
// {4A839CC0-F8FF-11ce-A06B-00AA00A71191}
DEFINE_GUID( FMTID_CmsThumbnailPropertySet, 0x4a839cc0, 0xf8ff, 0x11ce, 0xa0, 0x6b, 0x0, 0xaa, 0x0, 0xa7, 0x11, 0x91 );


DEFINE_GUID(IID_IThumbnailMaker, 0x7aaa28d2, 0x3bf2, 0x11cf, 0xb6, 0xe6, 0x0, 0xaa, 0x0, 0xbb, 0xba, 0x9e);

// html thumbnail extractor
// {EAB841A0-9550-11cf-8C16-00805F1408F3}
DEFINE_GUID( CLSID_HtmlThumbnailExtractor, 0xeab841a0, 0x9550, 0x11cf, 0x8c, 0x16, 0x0, 0x80, 0x5f, 0x14, 0x8, 0xf3);
#define CLSIDSTR_HtmlThumbnailExtractor     "{EAB841A0-9550-11cf-8C16-00805F1408F3}"

// GDI+ thumbnail extractor .....
// {3F30C968-480A-4C6C-862D-EFC0897BB84B}
DEFINE_GUID( CLSID_GdiThumbnailExtractor, 0x3f30c968, 0x480a, 0x4c6c, 0x86, 0x2d, 0xef, 0xc0, 0x89, 0x7b, 0xb8, 0x4b);
#define CLSIDSTR_GdiThumbnailExtractor  "{3F30C968-480A-4C6C-862D-EFC0897BB84B}"

// handles the thumbnail in FMTID_SummaryInfo property set on docfiles...
// {9DBD2C50-62AD-11d0-B806-00C04FD706EC}
DEFINE_GUID( CLSID_DocfileThumbnailHandler, 0x9dbd2c50, 0x62ad, 0x11d0, 0xb8, 0x6, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#define CLSIDSTR_DocfileThumbnailHandler    "{9DBD2C50-62AD-11d0-B806-00C04FD706EC}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\html.h ===
#ifndef _HTML_H
#define _HTML_H

#include "webvw.h"

interface IHTMLDocument2;

#define DECLAREWAITCURSOR2  HCURSOR hcursor_wait_cursor_save

//
// a class host for trident so that we can control what it downloads 
// and what it doesn't...
//
class CTridentHost : public IOleClientSite,
                     public IDispatch,
                     public IDocHostUIHandler
{
    public:
        CTridentHost();
        ~CTridentHost();

        HRESULT SetTrident( IOleObject * pTrident );

        // IUnknown
        STDMETHOD ( QueryInterface )( REFIID riid, void ** ppvObj );
        STDMETHOD_( ULONG, AddRef ) ( void );
        STDMETHOD_( ULONG, Release ) ( void );
        
        // IDispatch (ambient properties)
        STDMETHOD( GetTypeInfoCount ) (UINT *pctinfo);
        STDMETHOD( GetTypeInfo )(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
        STDMETHOD( GetIDsOfNames )(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                                   LCID lcid, DISPID *rgdispid);
        STDMETHOD( Invoke )(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                            DISPPARAMS *pdispparams, VARIANT *pvarResult,
                            EXCEPINFO *pexcepinfo, UINT *puArgErr);

        // IOleClientSite
        STDMETHOD( SaveObject )(void);
        STDMETHOD( GetMoniker )(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
        STDMETHOD( GetContainer )(IOleContainer **ppContainer);
        STDMETHOD( ShowObject )(void);
        STDMETHOD( OnShowWindow )(BOOL fShow);
        STDMETHOD( RequestNewObjectLayout )(void);

        // IDocHostUIHandler
        STDMETHOD( ShowContextMenu )( DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
        STDMETHOD( GetHostInfo )( DOCHOSTUIINFO *pInfo);
        STDMETHOD( ShowUI )( DWORD dwID, IOleInPlaceActiveObject *pActiveObject,IOleCommandTarget *pCommandTarget,
            IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
        STDMETHOD( HideUI )( void);
        STDMETHOD( UpdateUI )( void);
        STDMETHOD( EnableModeless )( BOOL fEnable);
        STDMETHOD( OnDocWindowActivate )( BOOL fActivate);
        STDMETHOD( OnFrameWindowActivate )( BOOL fActivate);
        STDMETHOD( ResizeBorder )( LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
        STDMETHOD( TranslateAccelerator )( LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
        STDMETHOD( GetOptionKeyPath )( LPOLESTR *pchKey, DWORD dw);
        STDMETHOD( GetDropTarget )( IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
        STDMETHOD( GetExternal )( IDispatch **ppDispatch);
        STDMETHOD( TranslateUrl )( DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
        STDMETHOD( FilterDataObject )( IDataObject *pDO, IDataObject **ppDORet);

    public:
        BITBOOL m_fOffline : 1;
        
   protected:
        long m_cRef;
};

class CHtmlThumb : public IExtractImage,
                   public IThumbnailCapture,
                   public IRunnableTask,
                   public IPropertyNotifySink,
                   public IPersistFile,
                   public IPersistMoniker,
                   public CComObjectRoot,
                   public CComCoClass< CHtmlThumb,&CLSID_HtmlThumbnailExtractor >
{
public:
    CHtmlThumb();
    ~CHtmlThumb();

    BEGIN_COM_MAP( CHtmlThumb )
        COM_INTERFACE_ENTRY( IExtractImage)
        COM_INTERFACE_ENTRY( IThumbnailCapture )
        COM_INTERFACE_ENTRY( IRunnableTask )
        COM_INTERFACE_ENTRY( IPropertyNotifySink )
        COM_INTERFACE_ENTRY( IPersistFile )
        COM_INTERFACE_ENTRY( IPersistMoniker )
    END_COM_MAP( )

    DECLARE_REGISTRY( CHtmlThumb,
                      _T("Shell.ThumbnailExtract.HTML.1"),
                      _T("Shell.ThumbnailExtract.HTML.1"),
                      IDS_HTMLTHUMBEXTRACT_DESC,
                      THREADFLAGS_APARTMENT);

    DECLARE_NOT_AGGREGATABLE( CHtmlThumb );

    // IExtractImage
    STDMETHOD (GetLocation) ( LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags );
 
    STDMETHOD (Extract)( HBITMAP * phBmpThumbnail );

    // IThumbnailCapture
    STDMETHOD (CaptureThumbnail) ( const SIZE * pMaxSize, IUnknown * pHTMLDoc2, HBITMAP * phbmThumbnail );

    // IRunnableTask 
    STDMETHOD (Run)( void ) ;
    STDMETHOD (Kill)( BOOL fWait );
    STDMETHOD (Suspend)( );
    STDMETHOD (Resume)( );
    STDMETHOD_( ULONG, IsRunning )( void );

    // IPropertyNotifySink
    STDMETHOD (OnChanged)( DISPID dispID);
    STDMETHOD (OnRequestEdit) ( DISPID dispID);

    // IPersistFile
    STDMETHOD (GetClassID )(CLSID *pClassID);
    STDMETHOD (IsDirty )();
    STDMETHOD (Load )( LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save )( LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted )( LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile )( LPOLESTR *ppszFileName);

    // IPersistMoniker
    STDMETHOD( Load )( BOOL fFullyAvailable, IMoniker *pimkName, LPBC pibc, DWORD grfMode);
    STDMETHOD( Save )( IMoniker *pimkName, LPBC pbc, BOOL fRemember);
    STDMETHOD( SaveCompleted )( IMoniker *pimkName, LPBC pibc);
    STDMETHOD( GetCurMoniker )( IMoniker **ppimkName);

protected:
    HRESULT InternalResume( void );
    HRESULT Create_URL_Moniker( IMoniker **ppMoniker );
    HRESULT WaitForRender( void );
    HRESULT Finish( HBITMAP * pBmp, const SIZE * prgSize, DWORD dwClrDepth );
    HRESULT CheckReadyState( );
    void ReportError( void ** pMsgArgs );
    
    LONG m_lState;
    BOOL m_fAsync;
    HANDLE m_hDone;
    CTridentHost m_Host;
    IHTMLDocument2 * m_pHTML;
    IOleObject * m_pOleObject;
    IConnectionPoint * m_pConPt;
    IViewObject * m_pViewObject;
    DWORD m_dwTimeout;
    DWORD m_dwCurrentTick;
    DWORD m_dwPropNotifyCookie;
    WCHAR m_szPath[MAX_PATH];
    SIZE m_rgSize;
    HBITMAP * m_phBmp;
    DWORD m_dwClrDepth;
    DECLAREWAITCURSOR2;
    DWORD m_dwXRenderSize;
    DWORD m_dwYRenderSize;
    IMoniker * m_pMoniker;
};

// time we wait before asking the internet explorer if it is done yet ...
#define TIME_PAUSE 200

// default timeout (seconds)
#define TIME_DEFAULT 90

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\shimgvw\html.cpp ===
#include "precomp.h"
#include <urlmon.h>
#include <mshtml.h>
#include <mshtmdid.h>
#include <idispids.h>
#include <ocidl.h>
#include <optary.h>
#include "thumbutil.h"
#include "strsafe.h"

#ifdef SetWaitCursor
#undef SetWaitCursor
#endif
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursorA(NULL, (LPCSTR) IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#define REGSTR_THUMBNAILVIEW    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Thumbnail View")

// the default size to render to .... these constants must be the same
#define DEFSIZE_RENDERWIDTH     800
#define DEFSIZE_RENDERHEIGHT    800

#define  REGSTR_HTMLTIMEOUT TEXT("HTMLExtractTimeout")

#define PROGID_HTML L"htmlfile"
#define PROGID_MHTML    L"mhtmlfile"
#define PROGID_XML      L"xmlfile"

#define DLCTL_DOWNLOAD_FLAGS  (DLCTL_DLIMAGES | \
                                DLCTL_VIDEOS | \
                                DLCTL_NO_DLACTIVEXCTLS | \
                                DLCTL_NO_RUNACTIVEXCTLS | \
                                DLCTL_NO_JAVA | \
                                DLCTL_NO_SCRIPTS | \
                                DLCTL_SILENT)


// get color resolution of the current display.
UINT GetCurColorRes(void)
{
    HDC hdc = GetDC(NULL);
    UINT uColorRes = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL , hdc);
    return uColorRes;
}



// Register the classes.

CHtmlThumb::CHtmlThumb()
{
    m_lState = IRTIR_TASK_NOT_RUNNING;
    ASSERT(!m_fAsync);
    ASSERT(!m_hDone);
    ASSERT(!m_pHTML);
    ASSERT(!m_pOleObject);
    ASSERT(!m_pMoniker);

    m_dwXRenderSize = DEFSIZE_RENDERWIDTH;
    m_dwYRenderSize = DEFSIZE_RENDERHEIGHT;
}

CHtmlThumb::~CHtmlThumb()
{
    // make sure we are not registered for callbacks...
    if (m_pConPt)
    {
        m_pConPt->Unadvise(m_dwPropNotifyCookie);
        ATOMICRELEASE(m_pConPt);
    }
    
    if (m_hDone)
    {
        CloseHandle(m_hDone);
    }

    ATOMICRELEASE(m_pHTML);
    ATOMICRELEASE(m_pOleObject);
    ATOMICRELEASE(m_pViewObject);
    ATOMICRELEASE(m_pMoniker);
}

STDMETHODIMP CHtmlThumb::Run()
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::Kill(BOOL fWait)
{
    if (m_lState == IRTIR_TASK_RUNNING)
    {
        LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_PENDING);
        if (lRes == IRTIR_TASK_FINISHED)
        {
            m_lState = lRes;
        }
        else if (m_hDone)
        {
            // signal the event it is likely to be waiting on
            SetEvent(m_hDone);
        }
        
        return S_OK;
    }
    else if (m_lState == IRTIR_TASK_PENDING || m_lState == IRTIR_TASK_FINISHED)
    {
        return S_FALSE;
    }

    return E_FAIL;
}

STDMETHODIMP CHtmlThumb::Suspend()
{
    if (m_lState != IRTIR_TASK_RUNNING)
    {
        return E_FAIL;
    }

    // suspend ourselves
    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_SUSPENDED);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        m_lState = lRes;
        return S_OK;
    }

    // if it is running, then there is an Event Handle, if we have passed where
    // we are using it, then we are close to finish, so it will ignore the suspend
    // request
    ASSERT(m_hDone);
    SetEvent(m_hDone);
    
    return S_OK;
}

STDMETHODIMP CHtmlThumb::Resume()
{
    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        return E_FAIL;
    }
    
    ResetEvent(m_hDone);
    m_lState = IRTIR_TASK_RUNNING;
    
    // the only point we allowed for suspension was in the wait loop while
    // trident is doing its stuff, so we just restart where we left off...
    SetWaitCursor();
    HRESULT hr = InternalResume();   
    ResetWaitCursor();
    return hr;
}

STDMETHODIMP_(ULONG) CHtmlThumb::IsRunning()
{
    return m_lState;
}

STDMETHODIMP CHtmlThumb::OnChanged(DISPID dispID)
{
    if (DISPID_READYSTATE == dispID && m_pHTML && m_hDone)
    {
        CheckReadyState();
    }

    return S_OK;
}

STDMETHODIMP CHtmlThumb::OnRequestEdit (DISPID dispID)
{
    return E_NOTIMPL;
}

// IExtractImage
STDMETHODIMP CHtmlThumb::GetLocation(LPWSTR pszPathBuffer, DWORD cch,
                                     DWORD * pdwPriority, const SIZE * prgSize,
                                     DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr = S_OK;

    m_rgSize = *prgSize;
    m_dwClrDepth = dwRecClrDepth;

    // fix the max colour depth at 8 bit, otherwise we are going to allocate a boat load of
    // memory just to scale the thing down.
    DWORD dwColorRes = GetCurColorRes();
    
    if (m_dwClrDepth > dwColorRes && dwColorRes >= 8)
    {
        m_dwClrDepth = dwColorRes;
    }
    
    if (*pdwFlags & IEIFLAG_SCREEN)
    {
        HDC hdc = GetDC(NULL);
        
        m_dwXRenderSize = GetDeviceCaps(hdc, HORZRES);
        m_dwYRenderSize = GetDeviceCaps(hdc, VERTRES);

        ReleaseDC(NULL, hdc);
    }
    if (*pdwFlags & IEIFLAG_ASPECT)
    {
        // scale the rect to the same proportions as the new one passed in
        if (m_rgSize.cx > m_rgSize.cy)
        {
            // make the Y size bigger
            m_dwYRenderSize = MulDiv(m_dwYRenderSize, m_rgSize.cy, m_rgSize.cx);
        }
        else
        {
            // make the X size bigger
            m_dwXRenderSize = MulDiv(m_dwXRenderSize, m_rgSize.cx, m_rgSize.cy);
        }            
    }

    m_Host.m_fOffline = BOOLIFY(*pdwFlags & IEIFLAG_OFFLINE);
    
    if (m_pMoniker)
    {
        LPOLESTR pszName = NULL;
        hr = m_pMoniker->GetDisplayName(NULL, NULL, &pszName);
        if (SUCCEEDED(hr))
        {
            hr = StringCchCopyW(pszPathBuffer, cch, pszName);
            CoTaskMemFree(pszName);
        }
    }
    else
    {
        hr = StringCchCopyW(pszPathBuffer, cch, m_szPath);
    }

    // scale our drawing size to match the in
    if (SUCCEEDED(hr) && (*pdwFlags & IEIFLAG_ASYNC))
    {
        hr = E_PENDING;

        // much lower priority, this task could take ages ...
        *pdwPriority = 0x00010000;
        m_fAsync = TRUE;
    }


    *pdwFlags = IEIFLAG_CACHE;

    return hr;
}

STDMETHODIMP CHtmlThumb::Extract(HBITMAP * phBmpThumbnail)
{
    if (m_lState != IRTIR_TASK_NOT_RUNNING)
    {
        return E_FAIL;
    }

    // check we were initialized somehow..
    if (m_szPath[0] == 0 && !m_pMoniker)
    {
        return E_FAIL;
    }

    // we use manual reset so that once fired we will always get it until we reset it...
    m_hDone = CreateEventA(NULL, TRUE, TRUE, NULL);
    if (!m_hDone)
    {
        return E_OUTOFMEMORY;
    }
    ResetEvent(m_hDone);
    
    // the one thing we cache is the place where the result goes....
    m_phBmp = phBmpThumbnail; 
    
    IMoniker *pURLMoniker = NULL;
    CLSID clsid;
    IUnknown *pUnk = NULL;
    IConnectionPointContainer * pConPtCtr = NULL;
    LPCWSTR pszDot = NULL;
    BOOL fUrl = FALSE;
    LPCWSTR pszProgID = NULL;
    
    if (!m_pMoniker)
    {
        // work out what the extension is....
        pszDot = PathFindExtension(m_szPath);
        if (pszDot == NULL)
        {
            return E_UNEXPECTED;
        }

        // check for what file type it is ....
        if (StrCmpIW(pszDot, L".htm") == 0 || 
            StrCmpIW(pszDot, L".html") == 0 ||
            StrCmpIW(pszDot, L".url") == 0)
        {
            pszProgID = PROGID_HTML;
        }
        else if (StrCmpIW(pszDot, L".mht") == 0 ||
                 StrCmpIW(pszDot, L".mhtml") == 0 ||
                 StrCmpIW(pszDot, L".eml") == 0 ||
                 StrCmpIW(pszDot, L".nws") == 0)
        {
            pszProgID = PROGID_MHTML;
        }
        else if (StrCmpIW(pszDot, L".xml") == 0)
        {
            pszProgID = PROGID_XML;
        }
        else
            return E_INVALIDARG;
    }
    else
    {
        pszProgID = PROGID_HTML;
    }
    
    HRESULT hr = S_OK;

    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_RUNNING);
    if (lRes == IRTIR_TASK_PENDING)
    {
        ResetWaitCursor();
        m_lState = IRTIR_TASK_FINISHED;
        return E_FAIL;
    }

    LPWSTR pszFullURL = NULL;
        
    if (m_pMoniker)
    {
        pURLMoniker = m_pMoniker;
        pURLMoniker->AddRef();
    }
    else if (StrCmpIW(pszDot, L".url") == 0)
    {
        hr = Create_URL_Moniker(&pURLMoniker);
        if (FAILED(hr))
        {
            return hr;
        }
        fUrl = TRUE;
    }

    SetWaitCursor();
    
    // reached here with a valid URL Moniker hopefully.....
    // or we are to use the text string and load it from a file ...
    // now fish around in the registry for the data for the MSHTML control ...

    hr = CLSIDFromProgID(pszProgID, &clsid);
    if (hr == S_OK)
    {
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                               IID_PPV_ARG(IUnknown, &pUnk));
    }

    if (SUCCEEDED(hr))
    {
        // now set the extent of the object ....
        hr = pUnk->QueryInterface(IID_PPV_ARG(IOleObject, &m_pOleObject));
    }

    if (SUCCEEDED(hr))
    {
        // give trident to our hosting sub-object...
        hr = m_Host.SetTrident(m_pOleObject);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(IID_PPV_ARG(IViewObject, &m_pViewObject));
    }

    // try and load the file, either through the URL moniker or
    // via IPersistFile::Load()
    if (SUCCEEDED(hr))
    {
        if (pURLMoniker != NULL)
        {
            IBindCtx *pbc = NULL;
            IPersistMoniker * pPersistMon = NULL;
                
            // have reached here with the interface I need ...  
            hr = pUnk->QueryInterface(IID_PPV_ARG(IPersistMoniker, &pPersistMon));
            if (SUCCEEDED(hr))
            {
                hr = CreateBindCtx(0, &pbc);
            }
            if (SUCCEEDED(hr) && fUrl)
            {
                IHtmlLoadOptions *phlo;
                hr = CoCreateInstance(CLSID_HTMLLoadOptions, NULL, CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IHtmlLoadOptions, &phlo));
                if (SUCCEEDED(hr))
                {
                    // deliberately ignore failures here
                    phlo->SetOption(HTMLLOADOPTION_INETSHORTCUTPATH, m_szPath, (lstrlenW(m_szPath) + 1)*sizeof(WCHAR));
                    pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                    phlo->Release();
                }
            }
            
            if (SUCCEEDED(hr))
            {            
                //tell MSHTML to start to load the page given
                hr = pPersistMon->Load(TRUE, pURLMoniker, pbc, NULL);
            }

            if (pPersistMon)
            {
                pPersistMon->Release();
            }

            if (pbc)
            {
                pbc->Release();
            }
        }
        else
        {
            IPersistFile *pPersistFile;
            hr = pUnk->QueryInterface(IID_PPV_ARG(IPersistFile, &pPersistFile));
            if (SUCCEEDED(hr))
            {
                hr = pPersistFile->Load(m_szPath, STGM_READ | STGM_SHARE_DENY_NONE);
                pPersistFile->Release();
            }
        }
    }

    if (pURLMoniker != NULL)
    {
        pURLMoniker->Release();
    }

    if (SUCCEEDED(hr))
    {
        SIZEL rgSize;
        rgSize.cx = m_dwXRenderSize;
        rgSize.cy = m_dwYRenderSize;
        
        HDC hDesktopDC = GetDC(NULL);
 
        // convert the size to himetric
        rgSize.cx = (rgSize.cx * 2540) / GetDeviceCaps(hDesktopDC, LOGPIXELSX);
        rgSize.cy = (rgSize.cy * 2540) / GetDeviceCaps(hDesktopDC, LOGPIXELSY);
            
        hr = m_pOleObject->SetExtent(DVASPECT_CONTENT, &rgSize);
        ReleaseDC(NULL, hDesktopDC);
    }

    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &m_pHTML));
    }

    if (pUnk)
    {
        pUnk->Release();
    }
    
    if (SUCCEEDED(hr))
    {
        // get the timeout from the registry....
        m_dwTimeout = 0;
        
        DWORD cbSize = sizeof(m_dwTimeout);
        // SHGetValueW
        SHRegGetUSValueW(REGSTR_THUMBNAILVIEW, REGSTR_HTMLTIMEOUT, NULL, &m_dwTimeout, &cbSize, FALSE, NULL, 0);

        if (m_dwTimeout == 0)
        {
            m_dwTimeout = TIME_DEFAULT;
        }

        // adjust to milliseconds
        m_dwTimeout *= 1000;
 
        // register the connection point for notification of the readystate
        hr = m_pOleObject->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pConPtCtr));
    }

    if (SUCCEEDED(hr))
    {
        hr = pConPtCtr->FindConnectionPoint(IID_IPropertyNotifySink, &m_pConPt);
    }
    if (pConPtCtr)
    {
        pConPtCtr->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pConPt->Advise((IPropertyNotifySink *) this, &m_dwPropNotifyCookie);
    }

    if (SUCCEEDED(hr))
    {
        m_dwCurrentTick = 0;

        // delegate to the shared function
        hr = InternalResume();
    }

    ResetWaitCursor();

    return hr;
}

// this function is called from either Create or from 
HRESULT CHtmlThumb::InternalResume()
{
    HRESULT hr = WaitForRender();

    // if we getE_PENDING, we will drop out of Run()
    
    // all errors and succeeds excepting Suspend() need to Unadvise the 
    // connection point
    if (hr != E_PENDING)
    {
        // unregister the connection point ...
        m_pConPt->Unadvise(m_dwPropNotifyCookie);
        ATOMICRELEASE(m_pConPt);
    }
            
    if (m_lState == IRTIR_TASK_PENDING)
    {
        // we were told to quit, so do it...
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        hr = Finish(m_phBmp, &m_rgSize, m_dwClrDepth);
    }

    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        m_lState = IRTIR_TASK_FINISHED;
    }

    if (hr != E_PENDING)
    {
        // we are not being suspended, so we don't need any of this stuff anymore so ...
        // let it go here so that its on the same thread as where we created it...
        ATOMICRELEASE(m_pHTML);
        ATOMICRELEASE(m_pOleObject);
        ATOMICRELEASE(m_pViewObject);
        ATOMICRELEASE(m_pMoniker);
    }

    return hr;
}

HRESULT CHtmlThumb::WaitForRender()
{
    DWORD dwLastTick = GetTickCount();
    CheckReadyState();

    do
    {
        MSG msg;
        while (PeekMessageWrapW(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if ((msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST) ||
                (msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST  && msg.message != WM_MOUSEMOVE))
            {
                continue;
            }
            TranslateMessage(&msg);
            DispatchMessageWrapW(&msg);
        }

        HANDLE rgWait[1] = {m_hDone};
        DWORD dwRet = MsgWaitForMultipleObjects(1, rgWait, FALSE,
                                                 m_dwTimeout - m_dwCurrentTick, QS_ALLINPUT);

        if (dwRet != WAIT_OBJECT_0)
        {
            // check the handle, TRIDENT pumps LOADS of messages, so we may never
            // detect the handle fired, even though it has...
            DWORD dwTest = WaitForSingleObject(m_hDone, 0);
            if (dwTest == WAIT_OBJECT_0)
            {
                break;
            }
        }
        
        if (dwRet == WAIT_OBJECT_0)
        {
            // Done signalled (either killed, or complete)
            break;
        }

        // was it a message that needed processing ?
        if (dwRet != WAIT_TIMEOUT)
        {
            DWORD dwNewTick = GetTickCount();
            if (dwNewTick < dwLastTick)
            {
                // it wrapped to zero, 
                m_dwCurrentTick += dwNewTick + (0xffffffff - dwLastTick);
            }
            else
            {
                m_dwCurrentTick += (dwNewTick - dwLastTick);
            }
            dwLastTick = dwNewTick;
        }

        if ((m_dwCurrentTick > m_dwTimeout) || (dwRet == WAIT_TIMEOUT))
        {
            ASSERT(m_pOleObject);
            
            m_pOleObject->Close(OLECLOSE_NOSAVE);
            
            return E_FAIL;
        }
    }
    whi