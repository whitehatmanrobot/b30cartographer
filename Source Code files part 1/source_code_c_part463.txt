
                                : L"Playback", 
                            szDefaultDeviceNameFromSoundMapper, 
                            &cch) == ERROR_SUCCESS)
            {
                dstrDefaultDeviceNameFromSoundMapper = szDefaultDeviceNameFromSoundMapper;
            }
            
            ::RegCloseKey(hkey);
        }
    }
    
    // Now we will need someplace to store the tokens (in user)
    CComPtr<ISpDataKey> cpDataKeyToStoreTokens;
    if (SUCCEEDED(hr) && cDevs >= 1)
    {
        CSpDynamicString dstrRegPath;
        if (NULL == (dstrRegPath = m_fInput
            ? SPMMSYS_AUDIO_IN_TOKEN_ID
            : SPMMSYS_AUDIO_OUT_TOKEN_ID))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            SPDBG_ASSERT(dstrRegPath[dstrRegPath.Length() - 1] == '\\');
            dstrRegPath.TrimToSize(dstrRegPath.Length() - 1);
        
            hr = SpSzRegPathToDataKey(
                    HKEY_CURRENT_USER, 
                    dstrRegPath,
                    TRUE,
                    &cpDataKeyToStoreTokens);
        }
    }

    // Loop thru each device, building the tokens along the way, remembering which
    // token should be our default
    CSpDynamicString dstrDefaultTokenId;
     
    for (UINT i = 0; SUCCEEDED(hr) && i < cDevs; i++)
    {
        #ifdef _WIN32_WCE
        WAVEINCAPS wic;
        WAVEOUTCAPS woc;
        #else
        WAVEINCAPSW wic;
        WAVEOUTCAPSW woc;
        #endif
        
        // Get the device's capabilities
        MMRESULT mmresult;
        const WCHAR * pszDeviceName;
        if (m_fInput)
        {
            mmresult = g_Unicode.waveInGetDevCaps(i, &wic, sizeof(wic));
            pszDeviceName = wic.szPname;
        }
        else
        {
            mmresult = g_Unicode.waveOutGetDevCaps(i, &woc, sizeof(woc));
            pszDeviceName = woc.szPname;
        }
        
        if (mmresult == MMSYSERR_NOERROR)
        {
            // Create the token id for the new token
            CSpDynamicString dstrTokenId;
            dstrTokenId.Append(
                m_fInput
                    ? SPMMSYS_AUDIO_IN_TOKEN_ID
                    : SPMMSYS_AUDIO_OUT_TOKEN_ID);
            dstrTokenId.Append(pszDeviceName);
            
            // Create a token for the device, and initialize it
            CComPtr<ISpDataKey> cpDataKeyForToken;
            hr = cpDataKeyToStoreTokens->CreateKey(pszDeviceName, &cpDataKeyForToken);
            
            CComPtr<ISpObjectTokenInit> cpToken;
            if (SUCCEEDED(hr))
            {
                hr = cpToken.CoCreateInstance(CLSID_SpObjectToken);
            }
            
            if (SUCCEEDED(hr))
            {
                hr = cpToken->InitFromDataKey(
                                m_fInput
                                    ? SPCAT_AUDIOIN
                                    : SPCAT_AUDIOOUT,
                                dstrTokenId,
                                cpDataKeyForToken);
            }
            
            // Tell it what it's language independent name is
            if (SUCCEEDED(hr))
            {
                hr = cpToken->SetStringValue(NULL, pszDeviceName);
            }
            
            // Set it's CLSID
            CSpDynamicString dstrClsidToCreate;
            if (SUCCEEDED(hr))
            {
                hr = StringFromCLSID(
                        m_fInput
                            ? CLSID_SpMMAudioIn
                            : CLSID_SpMMAudioOut,
                        &dstrClsidToCreate);
            }
            
            if (SUCCEEDED(hr))
            {
                hr = cpToken->SetStringValue(SPTOKENVALUE_CLSID, dstrClsidToCreate);
            }

            // Set it's device name and it's attributes
            if (SUCCEEDED(hr))
            {
                hr = cpToken->SetStringValue(L"DeviceName", pszDeviceName);
            }
            
            CComPtr<ISpDataKey> cpDataKeyAttribs;
            if (SUCCEEDED(hr))
            {
                hr = cpToken->CreateKey(SPTOKENKEY_ATTRIBUTES, &cpDataKeyAttribs);
            }
            
            if (SUCCEEDED(hr))
            {
                hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
            }
            
            if (SUCCEEDED(hr))
            {
                hr = cpDataKeyAttribs->SetStringValue(L"Technology", L"MMSys");
            }

            // Get CLSID of AudioUI object.
            CSpDynamicString dstrUIClsid;
            if (SUCCEEDED(hr))
            {
                hr = StringFromCLSID(
                        CLSID_SpAudioUI,
                        &dstrUIClsid);
            }
            
            if (SUCCEEDED(hr) && m_fInput)
            {
                // Add advanced properties UI for input devices only.
                CComPtr<ISpDataKey> cpDataKeyUI;
                CComPtr<ISpDataKey> cpDataKeyUI2;
                hr = cpToken->CreateKey(SPTOKENKEY_UI, &cpDataKeyUI);
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyUI->CreateKey(SPDUI_AudioProperties, &cpDataKeyUI2);
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyUI2->SetStringValue(SPTOKENVALUE_CLSID, dstrUIClsid);
                }
            }
            if (SUCCEEDED(hr))
            {
                // Add audio volume UI for all MM devices.
                CComPtr<ISpDataKey> cpDataKeyUI;
                CComPtr<ISpDataKey> cpDataKeyUI2;
                hr = cpToken->CreateKey(SPTOKENKEY_UI, &cpDataKeyUI);
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyUI->CreateKey(SPDUI_AudioVolume, &cpDataKeyUI2);
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpDataKeyUI2->SetStringValue(SPTOKENVALUE_CLSID, dstrUIClsid);
                }
            }
            
            // If we've gotten this far, add this token to the enum builder
            if (SUCCEEDED(hr))
            {
                ISpObjectToken * pToken = cpToken;
                hr = m_cpEnum->AddTokens(1, &pToken);
            }
            
            // If there is supposed to be a default, record the default token id
            if (SUCCEEDED(hr) && 
                dstrDefaultTokenId == NULL && 
                dstrDefaultDeviceNameFromSoundMapper != NULL && 
                wcsicmp(dstrDefaultDeviceNameFromSoundMapper, pszDeviceName) == 0)
            {
                cpToken->GetId(&dstrDefaultTokenId);
            }
#ifndef _WIN32_WCE
            // On a clean machine, the default device won't be in the registry 
            // - simply use the first one with a mixer.
            if (SUCCEEDED(hr) &&
                dstrDefaultTokenId == NULL &&
                dstrDefaultDeviceNameFromSoundMapper == NULL && 
                cDevs > 1)
            {
                UINT mixerId = 0;
                // Don't need to check return code.
                ::mixerGetID(   (HMIXEROBJ)(static_cast<DWORD_PTR>(i)), 
                                &mixerId, 
                                (m_fInput) ? MIXER_OBJECTF_WAVEIN : MIXER_OBJECTF_WAVEOUT );
                // -1 signifies device has no mixer.
                if (mixerId != (UINT)(-1))
                {
                    cpToken->GetId(&dstrDefaultTokenId);
                }
            }
#endif //_WIN32_WCE
        }
    }

    // Finally, sort the enum builder, and give it back to our caller
    if (SUCCEEDED(hr))
    {
        if (dstrDefaultTokenId != NULL)
        {
            m_cpEnum->Sort(dstrDefaultTokenId);
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmaudiobuffer.h ===
/****************************************************************************
*   mmaudiobuffer.h
*       Declarations for the CMMAudioBuffer class and it's derivatives.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "sapi.h"
#include "baseaudiobuffer.h"
#include "mmaudioutils.h"

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
*   CMMAudioBuffer
*
******************************************************************** robch */
class CMMAudioBuffer : public CBaseAudioBuffer
{
//=== Methods ===
public:
    //--- Ctor, dtor
    CMMAudioBuffer(ISpMMSysAudio * pmmaudio);
    ~CMMAudioBuffer();
    
    //--- Override async methods
    HRESULT IsAsyncDone() { return m_Header.dwFlags & WHDR_DONE; };

    //--- Override the write offset
    ULONG GetWriteOffset() const { return m_Header.dwBytesRecorded; };
    void SetWriteOffset(ULONG cb) { m_Header.dwBytesRecorded = cb; };

//=== Protected methods ===
protected:

    //--- Override internal buffer related functions
    BOOL AllocInternalBuffer(ULONG cb);
    HRESULT ReadFromInternalBuffer(void *pvData, ULONG cb);
    HRESULT WriteToInternalBuffer(const void *pvData, ULONG cb);

//=== Protected data ===
protected:

    ISpMMSysAudio * m_pmmaudio;
};

/****************************************************************************
*
*   CMMAudioInBuffer
*
******************************************************************** robch */
class CMMAudioInBuffer : public CMMAudioBuffer
{
//=== Methods ===
public:

    CMMAudioInBuffer(ISpMMSysAudio * pmmaudio);
    ~CMMAudioInBuffer();

//=== Protected methods ===
protected:

    //--- Override read/write methods
    HRESULT AsyncRead();
    HRESULT AsyncWrite();

//=== Private methods ===
private:

    //--- Unprepare the audio buffer
    void Unprepare();
};

/****************************************************************************
*
*   CMMAudioOutBuffer
*
******************************************************************** robch */
class CMMAudioOutBuffer : public CMMAudioBuffer
{
//=== Methods ===
public:

    CMMAudioOutBuffer(ISpMMSysAudio * pmmaudio);
    ~CMMAudioOutBuffer();

//=== Protected methods ===
protected:

    //--- Override read/write methods
    HRESULT AsyncRead();
    HRESULT AsyncWrite();

//=== Private methods ===
private:

    //--- Unprepare the audio buffer
    void Unprepare();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmaudioin.cpp ===
/****************************************************************************
*   mmaudioin.cpp
*       Implementation for the CMMAudioIn class.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------

#include "stdafx.h"
#include "mmmixerline.h"
#include "mmaudioin.h"
#include "mmaudiobuffer.h"
#include <sphelper.h>
#include <dbt.h>
#include <mmreg.h>
#include <mmsystem.h>

/****************************************************************************
* CMMAudioIn::CMMAudioIn *
*------------------------*
*   Description:  
*       ctor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CMMAudioIn::CMMAudioIn() : 
CMMAudioDevice(FALSE)
{
#ifndef _WIN32_WCE
    m_pWaveInLine = NULL;
    m_pMicInLine  = NULL;
    m_pMicOutLine = NULL;
    m_hMixer = NULL;
    m_uMixerDeviceId = (UINT)-1;
#endif
}

/****************************************************************************
* CMMAudioIn::~CMMAudioIn *
*-------------------------*
*   Description:  
*       dtor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CMMAudioIn::~CMMAudioIn()
{
#ifndef _WIN32_WCE
    SPDBG_ASSERT(NULL == m_hMixer);
#endif
}

/****************************************************************************
* CMMAudioIn::GetVolumeLevel *
*----------------------------*
*   Description:
*       Returns the volume level on a linear scale of (0 - 10000)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** YUNUSM ***/
STDMETHODIMP CMMAudioIn::GetVolumeLevel(ULONG *pulLevel)
{
    SPDBG_FUNC("CMMAudioIn::GetVolumeLevel");
    HRESULT hr = S_OK;
    DWORD vol;
    
    if (SP_IS_BAD_WRITE_PTR(pulLevel))
    {
        hr = E_POINTER;
    }
#ifdef _WIN32_WCE
    if (SUCCEEDED(hr))
    {
        hr =  SPERR_DEVICE_NOT_SUPPORTED;
    }
#else
    if (SUCCEEDED(hr))
    {
        if (m_lDelayedVolumeSet != -1)
        {
            *pulLevel = m_lDelayedVolumeSet;
        }
        else if (m_pMicInLine && m_pMicInLine->HasVolume())
        {
            hr = m_pMicInLine->GetVolume(&vol);
            *pulLevel = (10000 * (vol & 0xffff)) / 0xffff;
        }
        else if (m_pWaveInLine && m_pWaveInLine->HasVolume())
        {
            hr = m_pWaveInLine->GetVolume(&vol);
            *pulLevel = (10000 * (vol & 0xffff)) / 0xffff;
        }
        else
        {
            *pulLevel = 0;
            hr = SPERR_UNINITIALIZED;
        }
    }

    // Now deal with boost complications.
    if (SUCCEEDED(hr) && 
        m_lDelayedVolumeSet == -1 && 
        m_pMicInLine && m_pMicInLine->HasBoost())
    {
        BOOL fUseBoost = TRUE;
        Get_UseBoost(&fUseBoost); // Ignore return value.
        if (fUseBoost)
        {
            // Boost present - need to adjust volumelevel.
            BOOL fBoost;
            if (SUCCEEDED(m_pMicInLine->GetBoost(&fBoost)))
            {
                (*pulLevel)/=2;
                if (fBoost)
                {
                    (*pulLevel) += 5000;
                }
            }
        }
    }
    // If no boost, leave volume alone.
#endif
    return hr;
}

/****************************************************************************
* CMMAudioIn::SetVolumeLevel *
*----------------------------*
*   Description:
*       Sets the volume level on a linear scale of (0 - 10000)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** YUNUSM ***/
STDMETHODIMP CMMAudioIn::SetVolumeLevel(ULONG ulLevel)
{
    SPDBG_FUNC("CMMAudioIn::SetVolumeLevel");
    HRESULT hr = S_OK;
    
    if (ulLevel > 10000)
    {
        hr = E_INVALIDARG;
    }
#ifdef _WIN32_WCE
    // No method to set the input volume on CE.
    if (SUCCEEDED(hr))
    {
        hr = SPERR_DEVICE_NOT_SUPPORTED;
    }
#else
    else if (!m_pWaveInLine && !m_pMicInLine)
    {
        m_lDelayedVolumeSet = ulLevel;
        // Nothing happens if we later get error below.
    }
    else if (!m_pMicInLine->HasVolume() && !m_pWaveInLine->HasVolume()) 
    {
        hr = SPERR_DEVICE_NOT_SUPPORTED;
    }
    else
    {
        DWORD vol = (ulLevel * 0xffff) / 10000;
        BOOL fUseBoost = TRUE;
        Get_UseBoost(&fUseBoost); // Ignore return value.
        if (fUseBoost && m_pMicInLine && m_pMicInLine->HasBoost())
        {
            // Recalculate volume.
            vol = ((ulLevel%5000) * 0xffff) / 5000;
            if (ulLevel == 10000)
            {
                vol = 0xffff;
            }
            hr = m_pMicInLine->SetBoost(ulLevel >= 5000);
            SPDBG_REPORT_ON_FAIL(hr);
        }
        if (m_pMicInLine && m_pMicInLine->HasVolume())
        {
            // Set microphone source line to required volume.
            hr = m_pMicInLine->SetVolume(vol);
            SPDBG_REPORT_ON_FAIL(hr);
        }
        if (m_pWaveInLine && m_pWaveInLine->HasVolume())
        {
            // If WaveIn destination line has a master volume control set this to 
            // the same value.
            hr = m_pWaveInLine->SetVolume(vol);
            SPDBG_REPORT_ON_FAIL(hr);
        }
    }
#endif
    return hr;
}

/****************************************************************************
* CMMAudioIn::GetLineId *
*-----------------------*
*   Description:
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
**************************************************************** AGARSIDE ***/
STDMETHODIMP CMMAudioIn::GetLineId(UINT *puLineIndex)
{
    HRESULT hr = S_OK;
    SPDBG_FUNC("CMMAudioIn::GetLineId");

    if (SP_IS_BAD_WRITE_PTR(puLineIndex))
    {
        hr = E_POINTER;
    }

    hr = Get_Line(puLineIndex);

    return hr;
}

/****************************************************************************
* CMMAudioIn::SetLineId *
*-----------------------*
*   Description:
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
**************************************************************** AGARSIDE ***/
STDMETHODIMP CMMAudioIn::SetLineId(UINT uLineIndex)
{
    HRESULT hr = S_OK;
    SPDBG_FUNC("CMMAudioIn::SetLineId");

    // We cannot do sensible validation of the range here since we have not
    // necessarily opened the device. We will simply validate during the open
    // and if the value is greater than cConnections, ignore it and default
    // to automatic selection.
    if (m_hMixer)
    {
        // Mixer already open.
        if (m_pWaveInLine)
        {
            UINT nConnections;
            hr = m_pWaveInLine->GetConnections(&nConnections);
            if (SUCCEEDED(hr) && uLineIndex >= nConnections)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                hr = S_OK;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = Set_Line(uLineIndex);
        }
    }
    else
    {
        // Mixer not open open.
        OpenMixer();
        if (m_pWaveInLine)
        {
            UINT nConnections;
            hr = m_pWaveInLine->GetConnections(&nConnections);
            if (SUCCEEDED(hr) && uLineIndex >= nConnections)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                hr = S_OK;
            }
        }
        CloseMixer();
        if (SUCCEEDED(hr))
        {
            hr = Set_Line(uLineIndex);
        }
    }

    return hr;
}

/****************************************************************************
* CMMAudioIn::SetFormat *
*-----------------------*
*   Description:  
*       ISpAudio::SetFormat implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CMMAudioIn::SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pwfex)
{
    SPDBG_FUNC("CMMAudioIn::SetFormat");
    HRESULT hr = S_OK;

    CSpStreamFormat OldFmt;
    hr = OldFmt.AssignFormat(m_StreamFormat);
    if (SUCCEEDED(hr))
    {
        hr = CBaseAudio<ISpMMSysAudio>::SetFormat(rguidFmtId, pwfex);
    }
    if (SUCCEEDED(hr))
    {
        hr = _MMRESULT_TO_HRESULT(::waveInOpen(NULL, m_uDeviceId, pwfex, 0, 0, WAVE_FORMAT_QUERY));
        if (FAILED(hr))
        {
            HRESULT hr2 = CBaseAudio<ISpMMSysAudio>::SetFormat(OldFmt.FormatId(), OldFmt.WaveFormatExPtr());
            SPDBG_ASSERT(SUCCEEDED(hr2));
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CMMAudioIn::SetDeviceNameFromToken *
*------------------------------------*
*   Description:  
*       Set the device name from the token (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::SetDeviceNameFromToken(const WCHAR * pszDeviceName)
{
    SPDBG_FUNC("CMMAudioIn::SetDeviceNameFromToken");

    UINT cDevs = ::waveInGetNumDevs();
    for (UINT i = 0; i < cDevs; i++)
    {
#ifdef _WIN32_WCE
        WAVEINCAPS wic;
#else
        WAVEINCAPSW wic;
#endif
        MMRESULT mmr = g_Unicode.waveInGetDevCaps(i, &wic, sizeof(wic));
        if (mmr == MMSYSERR_NOERROR)
        {
            if (wcscmp(pszDeviceName, wic.szPname) == 0)
            {
                return SetDeviceId(i);
            }
        }
    }
    return E_INVALIDARG;
}

/****************************************************************************
* CMMAudioIn::GetDefaultDeviceFormat *
*------------------------------------*
*   Description:  
*       Get the default device format (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    SPDBG_FUNC("CMMAudioIn::GetDefaultDeviceFormat");
    if (!m_MMHandle)
    {
        return SPERR_UNINITIALIZED;
    }
    WAVEINCAPS wic;
    SPSTREAMFORMAT eFormat;
    HRESULT hr = _MMRESULT_TO_HRESULT(::waveInGetDevCaps(m_uDeviceId, &wic, sizeof(wic)));
    if (SUCCEEDED(hr))
    {
        hr = ConvertFormatFlagsToID(wic.dwFormats, &eFormat);
    }
    if (SUCCEEDED(hr))
    {
        hr = SpConvertStreamFormatEnum(eFormat, pFormatId, ppCoMemWaveFormatEx);
    }
    return hr;
}

#ifndef _WIN32_WCE
/****************************************************************************
* CMMAudioIn::OpenMixer *
*-----------------------*
*   Description:  
*       Open the mixer for the device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::OpenMixer()
{
    SPDBG_FUNC("CMMAudioIn::OpenMixer");
    HRESULT hr = S_OK;

    if (m_uMixerDeviceId == m_uDeviceId)
    {
        // Already open.
        return S_OK;
    }
    if (m_hMixer)
    {
        CloseMixer(); // Ignore return code.
    }
    MMRESULT mm;
    mm = mixerOpen((HMIXER*)&m_hMixer, (UINT)m_uDeviceId, 0, 0, MIXER_OBJECTF_WAVEIN);
    if (mm != MMSYSERR_NOERROR)
    {
        return _MMRESULT_TO_HRESULT(mm);
    }
    
    // Create mixer line objects to set inputs.
    SPDBG_ASSERT(m_pWaveInLine == NULL);
    SPDBG_ASSERT(m_pMicInLine == NULL);
    m_pWaveInLine = new CMMMixerLine((HMIXER &)m_hMixer);
    if (!m_pWaveInLine)
    {
        return E_OUTOFMEMORY;
    }
    m_pMicInLine = new CMMMixerLine((HMIXER&)m_hMixer);
    if (!m_pMicInLine)
    {
        return E_OUTOFMEMORY;
    }
    
    // Find wave in destination line.
    hr = m_pWaveInLine->CreateDestinationLine(MIXERLINE_COMPONENTTYPE_DST_WAVEIN);
    BOOL bAutomatic = TRUE;
    if (SUCCEEDED(hr))
    {
        hr = Get_UseAutomaticLine(&bAutomatic);
    }
    if (SUCCEEDED(hr))
    {
        if (bAutomatic)
        {
            // If using automatic settings, 
            // Find microphone input attached to destination line.
            hr = m_pWaveInLine->GetMicSourceLine(m_pMicInLine);
        }
        else
        {
            UINT dwLineIndex;
            hr = Get_Line(&dwLineIndex);
            if (SUCCEEDED(hr))
            {
                hr = m_pWaveInLine->GetSourceLine(m_pMicInLine, static_cast<DWORD>(dwLineIndex));
            }
            if (FAILED(hr))
            {
                SPDBG_REPORT_ON_FAIL(hr);
                // Fallback to automatic if non-automatic fails.
                hr = m_pWaveInLine->GetMicSourceLine(m_pMicInLine);
            }

        }
    }

    // Set up audio system
    if (SUCCEEDED(hr))
    {
        BOOL fUseAGC = TRUE;
        Get_UseAGC(&fUseAGC); // Ignore return value.
        if (fUseAGC && m_pMicInLine->HasAGC())
        {
            hr = m_pMicInLine->SetAGC(FALSE);
            // Currently we do not know of any soundcards where this default behaviour
            // causes a problem. The opposite (TRUE) is known to cause noticeable reduction
            // in recognition accuracy with most engines.
        }
        SPDBG_ASSERT(SUCCEEDED(hr));
        hr = S_OK;
    }
    if (SUCCEEDED(hr) && m_pMicInLine->HasBoost())
    {
        hr = m_pMicInLine->GetBoost(&m_fOrigMicBoost);
        SPDBG_ASSERT(SUCCEEDED(hr));
        hr = S_OK;
    }
    if (SUCCEEDED(hr) && m_pWaveInLine->HasSelect())
    {
        hr = m_pWaveInLine->ExclusiveSelect(m_pMicInLine);
        SPDBG_ASSERT(SUCCEEDED(hr));
        hr = S_OK;
    }
    
    // Get current input volume.
    m_dwOrigMicInVol = m_dwOrigWaveInVol = -1;
    if (SUCCEEDED(hr) && m_pWaveInLine->HasVolume())
    {
        hr = m_pWaveInLine->GetVolume(&m_dwOrigWaveInVol);
        SPDBG_ASSERT(SUCCEEDED(hr));
        hr = S_OK;
    }
    if (SUCCEEDED(hr) && m_pMicInLine->HasVolume())
    {
        hr = m_pMicInLine->GetVolume(&m_dwOrigMicInVol);
        SPDBG_ASSERT(SUCCEEDED(hr));
        hr = S_OK;
    }
    
    // Now fix microphone output - default is to unmute it but set it to *zero* volume.
    // This works around a known sound driver bug. 
    // It isn't necessary in the audio output code as it should already have been 
    // handled here.
    BOOL fFixMicOutput = TRUE;
    Get_FixMicOutput(&fFixMicOutput); // ignore return value.
    if (fFixMicOutput)
    {
        SPDBG_ASSERT(m_pMicOutLine == NULL);
        CMMMixerLine *pSpeakerLine = new CMMMixerLine((HMIXER&)m_hMixer);
        if (!pSpeakerLine)
        {
            return E_OUTOFMEMORY;
        }
        m_pMicOutLine = new CMMMixerLine((HMIXER&)m_hMixer);
        if (!m_pMicOutLine)
        {
            return E_OUTOFMEMORY;
        }
    
        HRESULT tmphr;
        // Not an error if this fails.
        m_dwOrigMicOutVol = -1;
        m_fOrigMicOutMute = TRUE;
        tmphr = pSpeakerLine->CreateDestinationLine(MIXERLINE_COMPONENTTYPE_DST_SPEAKERS);
        if (SUCCEEDED(tmphr))
        {
            tmphr = pSpeakerLine->GetMicSourceLine(m_pMicOutLine);
            // If line microphone used, can't currently turn output for it off.
            // However, SAPI doesn't currently allow use of line microphones so not yet an issue.
        }
        if (SUCCEEDED(tmphr))
        {
            if (m_pMicOutLine->HasVolume())
            {
                // If it has a volume, set it to zero and unmute it.
                // This is a workaround for a specific sound card/driver + OS combination
                // where no microphone input is possible if the microphone output is muted.
                // This may be Crystal sound cards.
                tmphr = m_pMicOutLine->GetVolume(&m_dwOrigMicOutVol);
                if (SUCCEEDED(tmphr))
                {
                    tmphr = m_pMicOutLine->SetVolume(0);
                    m_pMicOutLine->GetMute(&m_fOrigMicOutMute);
                    // Ignore return value.
                }
                if (SUCCEEDED(tmphr))
                {
                    DWORD vol = 0;
                    tmphr = m_pMicInLine->GetVolume(&vol); // Ignore return code.
                    if (vol == 0) // Linked input/output volumes
                    {
                        // Default to muting output.
                        tmphr = m_pMicOutLine->SetMute(TRUE);
                    }
                    else
                    {
                        tmphr = m_pMicOutLine->SetMute(FALSE);
                    }
                }
                else
                {
                    tmphr = m_pMicOutLine->SetMute(TRUE);
                }
            }
            else
            {
                // If no volume control is present, simply mute the microphone.
                tmphr = m_pMicOutLine->SetMute(TRUE);
            }
        }
        // Output code may have changed input volume.
        if (SUCCEEDED(tmphr) && m_pMicInLine->HasVolume())
        {
            // Reset original volume.
            hr = m_pMicInLine->SetVolume(m_dwOrigMicInVol);
            SPDBG_ASSERT(SUCCEEDED(hr));
            hr = S_OK;
        }
        delete pSpeakerLine;
    }
    
    // Do we have a delayed volume set to honor?
    // Otherwise above original volume will remain active.
    if (SUCCEEDED(hr) && m_lDelayedVolumeSet != -1)
    {
		hr = SetVolumeLevel(m_lDelayedVolumeSet);
        m_lDelayedVolumeSet = -1;
    }
    if (SUCCEEDED(hr))
    {
        m_uMixerDeviceId = m_uDeviceId;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CMMAudioIn::CloseMixer *
*------------------------*
*   Description:  
*       Closes the mixer for the device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::CloseMixer()
{
    SPDBG_FUNC("CMMAudioIn::CloseMixer");

    if (!m_hMixer)
    {
        return E_FAIL;
    }
    if (m_pMicOutLine)
    {
        if (m_pMicOutLine->HasVolume() && m_dwOrigMicOutVol != -1)
        {
            m_pMicOutLine->SetVolume(m_dwOrigMicOutVol);
        }
        if (m_pMicOutLine->HasMute() && m_dwOrigMicOutVol != -1)
        {
            m_pMicOutLine->SetMute(m_fOrigMicOutMute);
        }
        delete m_pMicOutLine;
        m_pMicOutLine = NULL;
    }
    if (m_pMicInLine)
    {
        if (m_pMicInLine->HasVolume() && m_dwOrigMicInVol != -1)
        {
            m_pMicInLine->SetVolume(m_dwOrigMicInVol);
        }
		if (m_pMicInLine->HasBoost())
		{
			m_pMicInLine->SetBoost(m_fOrigMicBoost);
		}
        delete m_pMicInLine;
        m_pMicInLine = NULL;
    }
    if (m_pWaveInLine)
    {
        if (m_pWaveInLine->HasVolume() && m_dwOrigWaveInVol != -1)
        {
            m_pWaveInLine->SetVolume(m_dwOrigWaveInVol);
        }
        delete m_pWaveInLine;
        m_pWaveInLine = NULL;
    }
    if (m_hMixer)
    {
        mixerClose((HMIXER)m_hMixer);
        m_hMixer = NULL;
    }
    m_uMixerDeviceId = (UINT)-1;
    return S_OK;
}
#endif

/****************************************************************************
* CMMAudioIn::OpenDevice *
*------------------------*
*   Description:  
*       Open the device (called by the base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::OpenDevice(HWND hwnd)
{
    SPDBG_FUNC("CMMAudioIn::OpenDevice");
    HRESULT hr = S_OK;
    
#ifndef _WIN32_WCE
    OpenMixer(); // Ignore return code.
#endif

    // Return from this function only the result of waveInOpen, not mixer APIs
    // If SAPI can't set the mixer up, there's nothing it can do - we will just hope it's
    // in a suitable state for ok to good recognition.
    hr = _MMRESULT_TO_HRESULT(::waveInOpen(NULL, m_uDeviceId, m_StreamFormat.WaveFormatExPtr(), 0, 0, WAVE_FORMAT_QUERY));
    if (SUCCEEDED(hr))
    {
        hr = _MMRESULT_TO_HRESULT(::waveInOpen((HWAVEIN *)&m_MMHandle, m_uDeviceId, m_StreamFormat.WaveFormatExPtr(), (DWORD_PTR)hwnd, (DWORD_PTR)this, CALLBACK_WINDOW));
        if (hr == SPERR_UNSUPPORTED_FORMAT)
        {
            // Know this is not the case as we've explicitly tested above.
            hr = SPERR_DEVICE_BUSY;
        }
    }

#ifndef _WIN32_WCE
    if (FAILED(hr))
    {
        CloseMixer(); // Ignore return code.
    }
#endif
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CMMAudioIn::ChangeDeviceState *
*-------------------------------*
*   Description:  
*       Make whatever changes to the device status that are required (called
*       by the base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::ChangeDeviceState(SPAUDIOSTATE NewState)
{
    SPDBG_FUNC("CMMAudioIn::ChangeDeviceState");

    switch (NewState)
    {
    case SPAS_STOP:
        ::waveInStop((HWAVEIN)m_MMHandle);
        ::waveInReset((HWAVEIN)m_MMHandle);
        break;
        
    case SPAS_PAUSE:
        ::waveInStop((HWAVEIN)m_MMHandle);
        break;

    case SPAS_RUN:
        ::waveInStart((HWAVEIN)m_MMHandle);
        break;

    }
    return S_OK;
}

/****************************************************************************
* CMMAudioIn::CloseDevice *
*-------------------------*
*   Description:  
*       Close the device (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::CloseDevice()
{
    SPDBG_FUNC("CMMAudioIn::CloseDevice");

    SPDBG_ASSERT(m_MMHandle != NULL);
    
    HRESULT hr = S_OK;
    HWAVEIN hwi = (HWAVEIN)m_MMHandle;
    m_MMHandle = NULL;
    ::waveInReset(hwi);
    ::waveInStop(hwi);
    PurgeAllQueues();
    m_State = SPAS_CLOSED;
#ifndef _WIN32_WCE
    CloseMixer(); // Ignore return code.
    return _MMRESULT_TO_HRESULT(::waveInClose(hwi));
#else
    for (UINT i = 0; i < 20; i++)
    {
        // Workaround for WinCE bug
        if (FAILED(hr = _MMRESULT_TO_HRESULT(::waveInClose(hwi))))
        {
            Sleep(10);
        }
        else
        {
            break;
        }
    }
    return hr;
#endif
}

/****************************************************************************
* CMMAudioIn::AllocateDeviceBuffer *
*----------------------------------*
*   Description:  
*       Allocate a buffer specific for this device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::AllocateDeviceBuffer(CBuffer ** ppBuff)
{
    SPDBG_FUNC("CMMAudioIn::AllocateDeviceBuffer");

    *ppBuff = new CMMAudioInBuffer(this);
    return *ppBuff ? S_OK : E_OUTOFMEMORY;
}

/****************************************************************************
* CMMAudioIn::ProcessDeviceBuffers *
*----------------------------------*
*   Description:  
*       Process the device buffers
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioIn::ProcessDeviceBuffers(BUFFPROCREASON Reason)
{
    SPDBG_FUNC("CMMAudioIn::ProcessDeviceBuffers");

    HRESULT hr = CMMAudioDevice::ProcessDeviceBuffers(Reason);
    
    //  If we just opened the device, we need to start it after the buffers are added
    if (SUCCEEDED(hr) && GetState() == SPAS_RUN && !IsPumpRunning())
    {
        StartPump();
        hr = _MMRESULT_TO_HRESULT(::waveInStart((HWAVEIN)m_MMHandle));
    }
    return hr;
}

//-- ISpMMSysAudioConfig --------------------------------------------------

/****************************************************************************
* CMMAudioIn::Get_UseAutomaticLine *
*----------------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Get_UseAutomaticLine(BOOL *bAutomatic)
{
    SPDBG_FUNC("CMMAudioIn::Get_UseAutomaticLine");
    CComPtr<ISpObjectToken> cpObjectToken;
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(bAutomatic))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        *bAutomatic = TRUE;
        hr = GetObjectToken(&cpObjectToken);
    }
    if (S_OK == hr)
    {
        DWORD dwUseAuto;
        hr = cpObjectToken->GetDWORD(L"UseAutomaticLine", &dwUseAuto);
        if (FAILED(hr)) // In particular - SPERR_NOT_FOUND
        {
            hr = S_OK;
        }
        else
        {
            *bAutomatic = (dwUseAuto==1);
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
}

/****************************************************************************
* CMMAudioIn::Set_UseAutomaticLine *
*----------------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Set_UseAutomaticLine(BOOL bUseAutomatic)
{
    SPDBG_FUNC("CMMAudioIn::Set_UseAutomaticLine");
    HRESULT hr = S_OK;
    CComPtr<ISpObjectToken> cpObjectToken;

    if (SUCCEEDED(hr))
    {
        hr = GetObjectToken(&cpObjectToken);
        if (S_FALSE == hr)
        {
            hr = SPERR_NOT_FOUND;
        }
    }
    if (SUCCEEDED(hr))
    {
        DWORD dwUseAuto = bUseAutomatic?1:0;
        hr = cpObjectToken->SetDWORD(L"UseAutomaticLine", dwUseAuto);
    }

    if (SUCCEEDED(hr))
    {
        // Reset input using new settings.
        if (m_hMixer)
        {
            CloseMixer();
            OpenMixer();
        }
        else
        {
            OpenMixer();
            CloseMixer();
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
}

/****************************************************************************
* CMMAudioIn::Get_Line *
*----------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Get_Line(UINT *uiLineId)
{
    SPDBG_FUNC("CMMAudioIn::Get_Line");
    CComPtr<ISpObjectToken> cpObjectToken;
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(uiLineId))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        *uiLineId = 0;
        hr = GetObjectToken(&cpObjectToken);
        if (S_FALSE == hr)
        {
            hr = SPERR_NOT_FOUND;
        }
    }
    if (SUCCEEDED(hr))
    {
        DWORD dwLineIndex;
        hr = cpObjectToken->GetDWORD(L"LineIndex", &dwLineIndex);
        if (SUCCEEDED(hr))
        {
            *uiLineId = static_cast<UINT>(dwLineIndex);
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
}

/****************************************************************************
* CMMAudioIn::Set_Line *
*----------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Set_Line(UINT uiLineId)
{
    SPDBG_FUNC("CMMAudioIn::Set_Line");
    HRESULT hr = S_OK;
    CComPtr<ISpObjectToken> cpObjectToken;

    if (SUCCEEDED(hr))
    {
        hr = GetObjectToken(&cpObjectToken);
        if (S_FALSE == hr)
        {
            hr = SPERR_NOT_FOUND;
        }
    }
    if (SUCCEEDED(hr))
    {
        DWORD dwLineIndex = static_cast<DWORD>(uiLineId);
        hr = cpObjectToken->SetDWORD(L"LineIndex", dwLineIndex);
    }

    if (SUCCEEDED(hr))
    {
        // Reset input using new settings.
        if (m_hMixer)
        {
            CloseMixer();
            OpenMixer();
        }
        else
        {
            OpenMixer();
            CloseMixer();
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
}

/****************************************************************************
* CMMAudioIn::Get_UseBoost *
*--------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Get_UseBoost(BOOL *bUseBoost) 
{ 
    SPDBG_FUNC("CMMAudioIn::Get_UseBoost");
    CComPtr<ISpObjectToken> cpObjectToken;
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(bUseBoost))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        *bUseBoost = TRUE;
        hr = GetObjectToken(&cpObjectToken);
    }
    if (S_OK == hr)
    {
        DWORD dwBool;
        hr = cpObjectToken->GetDWORD(L"UseBoost", &dwBool);
        if (SUCCEEDED(hr))
        {
            *bUseBoost = (dwBool==1)?TRUE:FALSE;
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
};

/****************************************************************************
* CMMAudioIn::Set_UseBoost *
*--------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Set_UseBoost(BOOL bUseBoost) 
{
    SPDBG_FUNC("CMMAudioIn::Set_UseBoost");
    HRESULT hr = S_OK;
    CComPtr<ISpObjectToken> cpObjectToken;

    if (SUCCEEDED(hr))
    {
        hr = GetObjectToken(&cpObjectToken);
        if (S_FALSE == hr)
        {
            hr = SPERR_NOT_FOUND;
        }
    }
    if (SUCCEEDED(hr))
    {
        DWORD dwBool = bUseBoost?1:0;
        hr = cpObjectToken->SetDWORD(L"UseBoost", dwBool);
    }

    if (SUCCEEDED(hr))
    {
        // Reset input using new settings.
        if (m_hMixer)
        {
            CloseMixer();
            OpenMixer();
        }
        else
        {
            OpenMixer();
            CloseMixer();
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
};

/****************************************************************************
* CMMAudioIn::Get_UseAGC *
*------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Get_UseAGC(BOOL *bUseAGC) 
{
    SPDBG_FUNC("CMMAudioIn::Get_UseAGC");
    CComPtr<ISpObjectToken> cpObjectToken;
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(bUseAGC))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        *bUseAGC = TRUE;
        hr = GetObjectToken(&cpObjectToken);
    }
    if (S_OK == hr)
    {
        DWORD dwBool;
        hr = cpObjectToken->GetDWORD(L"UseAGC", &dwBool);
        if (SUCCEEDED(hr))
        {
            *bUseAGC = (dwBool==1)?TRUE:FALSE;
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
};

/****************************************************************************
* CMMAudioIn::Set_UseAGC *
*------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Set_UseAGC(BOOL bUseAGC) 
{
    SPDBG_FUNC("CMMAudioIn::Set_UseAGC");
    HRESULT hr = S_OK;
    CComPtr<ISpObjectToken> cpObjectToken;

    if (SUCCEEDED(hr))
    {
        hr = GetObjectToken(&cpObjectToken);
        if (S_FALSE == hr)
        {
            hr = SPERR_NOT_FOUND;
        }
    }
    if (SUCCEEDED(hr))
    {
        DWORD dwBool = bUseAGC?1:0;
        hr = cpObjectToken->SetDWORD(L"UseAGC", dwBool);
    }

    if (SUCCEEDED(hr))
    {
        // Reset input using new settings.
        if (m_hMixer)
        {
            CloseMixer();
            OpenMixer();
        }
        else
        {
            OpenMixer();
            CloseMixer();
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
};

/****************************************************************************
* CMMAudioIn::Get_FixMicOutput *
*------------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Get_FixMicOutput(BOOL *bFixMicOutput) 
{
    SPDBG_FUNC("CMMAudioIn::Get_FixMicOutput");
    CComPtr<ISpObjectToken> cpObjectToken;
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(bFixMicOutput))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        *bFixMicOutput = TRUE;
        hr = GetObjectToken(&cpObjectToken);
    }
    if (S_OK == hr)
    {
        DWORD dwBool;
        hr = cpObjectToken->GetDWORD(L"FixMicOutput", &dwBool);
        if (SUCCEEDED(hr))
        {
            *bFixMicOutput = (dwBool==1)?TRUE:FALSE;
        }
        else
        {
            // Usual error will be that the key is not present.
            *bFixMicOutput = TRUE;
        }
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
}

/****************************************************************************
* CMMAudioIn::Set_UseAGC *
*------------------------*
*   Description:  
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
STDMETHODIMP CMMAudioIn::Set_FixMicOutput(BOOL bFixMicOutput)
{
    SPDBG_FUNC("CMMAudioIn::Set_FixMicOutput");
    HRESULT hr = S_OK;
    CComPtr<ISpObjectToken> cpObjectToken;

    if (SUCCEEDED(hr))
    {
        hr = GetObjectToken(&cpObjectToken);
        if (S_FALSE == hr)
        {
            hr = SPERR_NOT_FOUND;
        }
    }
    if (SUCCEEDED(hr))
    {
        DWORD dwBool = bFixMicOutput?1:0;
        hr = cpObjectToken->SetDWORD(L"FixMicOutput", dwBool);
    }

    // No need to reset this in realtime.
    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmaudiodevice.h ===
/****************************************************************************
*   mmaudiodevice.h
*       Declarataions for the CMMAudioDevice
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "audiobufferqueue.h"
#include "baseaudio.h"
#include "mmaudioutils.h"

//--- Class, Struct and Union Definitions -----------------------------------

class ATL_NO_VTABLE CMMAudioDevice : 
    public CBaseAudio<ISpMMSysAudio>,
    public ISpMMSysAudioConfig
    //--- Automation
    #ifdef SAPI_AUTOMATION
	,public IDispatchImpl<ISpeechMMSysAudio, &IID_ISpeechMMSysAudio, &LIBID_SpeechLib, 5>
    #endif
{
//=== ATL Setup ===
public:

    BEGIN_COM_MAP(CMMAudioDevice)
        COM_INTERFACE_ENTRY(ISpMMSysAudioConfig)
        COM_INTERFACE_ENTRY(ISpMMSysAudio)
        COM_INTERFACE_ENTRY_CHAIN(CBaseAudio<ISpMMSysAudio>)
        //--- Automation
        #ifdef SAPI_AUTOMATION
	    COM_INTERFACE_ENTRY(ISpeechMMSysAudio)
	    COM_INTERFACE_ENTRY(ISpeechAudio)
	    COM_INTERFACE_ENTRY(ISpeechBaseStream)
	    COM_INTERFACE_ENTRY(IDispatch)
        #endif
    END_COM_MAP()

//=== Methods ===
public:

    //--- Ctor, dtor
    CMMAudioDevice(BOOL bWrite);

//=== Interfaces ===
public:
    //-- ISpMMSysAudioConfig --------------------------------------------------
    virtual STDMETHODIMP Get_UseAutomaticLine(BOOL *bAutomatic) { return E_NOTIMPL; };
    virtual STDMETHODIMP Set_UseAutomaticLine(BOOL bAutomatic) { return E_NOTIMPL; };
    virtual STDMETHODIMP Get_Line(UINT *uiLineIndex) { return E_NOTIMPL; };
    virtual STDMETHODIMP Set_Line(UINT uiLineIndex) { return E_NOTIMPL; };
    virtual STDMETHODIMP Get_UseBoost(BOOL *bUseBoost) { return E_NOTIMPL; };
    virtual STDMETHODIMP Set_UseBoost(BOOL bUseBoost) { return E_NOTIMPL; };
    virtual STDMETHODIMP Get_UseAGC(BOOL *bUseAGC) { return E_NOTIMPL; };
    virtual STDMETHODIMP Set_UseAGC(BOOL bUseAGC) { return E_NOTIMPL; };
    virtual STDMETHODIMP Get_FixMicOutput(BOOL *bFixMicOutput) { return E_NOTIMPL; };
    virtual STDMETHODIMP Set_FixMicOutput(BOOL bFixMicOutput) { return E_NOTIMPL; };
    virtual STDMETHODIMP Get_LineNames(WCHAR **szCoMemLineList);
    virtual STDMETHODIMP HasMixer(BOOL *bHasMixer);
    virtual STDMETHODIMP DisplayMixer(void);

    //--- ISpMMSysAudio -----------------------------------------------------
    STDMETHODIMP SetDeviceId(UINT uDeviceId);
    STDMETHODIMP GetDeviceId(UINT * puDeviceId);
    STDMETHODIMP GetMMHandle(void ** pHandle) ;

    #ifdef SAPI_AUTOMATION
    //--- ISpeechMMSysAudio ----------------------------------
    STDMETHODIMP get_DeviceId(long* pDeviceID) { return GetDeviceId((UINT*)pDeviceID); };
    STDMETHODIMP put_DeviceId(long DeviceID) { return SetDeviceId((UINT)DeviceID); };
    STDMETHODIMP get_LineId(long* pLineID) { return GetLineId((UINT*)pLineID); };
    STDMETHODIMP put_LineId(long LineID) { return SetLineId((UINT)LineID); };
    STDMETHODIMP get_MMHandle(long* pHandle) { return GetMMHandle((void**)pHandle); };

    //--- ISpeechBaseStream ----------------------------------------
    STDMETHODIMP get_Format(ISpeechAudioFormat** ppStreamFormat) { return CBaseAudio<ISpMMSysAudio>::get_Format(ppStreamFormat); };
    STDMETHODIMP putref_Format(ISpeechAudioFormat* pFormat) { return CBaseAudio<ISpMMSysAudio>::putref_Format(pFormat); };
    STDMETHODIMP Read(VARIANT* pvtBuffer, long NumBytes, long* pRead) { return CBaseAudio<ISpMMSysAudio>::Read(pvtBuffer, NumBytes, pRead); };
    STDMETHODIMP Write(VARIANT vtBuffer, long* pWritten) { return CBaseAudio<ISpMMSysAudio>::Write(vtBuffer, pWritten); };
    STDMETHODIMP Seek(VARIANT Pos, SpeechStreamSeekPositionType Origin, VARIANT* pNewPosition) { return CBaseAudio<ISpMMSysAudio>::Seek(Pos, Origin, pNewPosition); };

    //--- ISpeechAudio ----------------------------------
	STDMETHODIMP SetState( SpeechAudioState State ) { return CBaseAudio<ISpMMSysAudio>::SetState(State); };
	STDMETHODIMP get_Status( ISpeechAudioStatus** ppStatus ) { return CBaseAudio<ISpMMSysAudio>::get_Status(ppStatus); };
    STDMETHODIMP get_BufferInfo(ISpeechAudioBufferInfo** ppBufferInfo) { return CBaseAudio<ISpMMSysAudio>::get_BufferInfo(ppBufferInfo); };
    STDMETHODIMP get_DefaultFormat(ISpeechAudioFormat** ppStreamFormat) { return CBaseAudio<ISpMMSysAudio>::get_DefaultFormat(ppStreamFormat); };
    STDMETHODIMP get_Volume(long* pVolume) { return CBaseAudio<ISpMMSysAudio>::get_Volume(pVolume); };
    STDMETHODIMP put_Volume(long Volume) { return CBaseAudio<ISpMMSysAudio>::put_Volume(Volume); };
    STDMETHODIMP get_BufferNotifySize(long* pBufferNotifySize) { return CBaseAudio<ISpMMSysAudio>::get_BufferNotifySize(pBufferNotifySize); };
    STDMETHODIMP put_BufferNotifySize(long BufferNotifySize) { return CBaseAudio<ISpMMSysAudio>::put_BufferNotifySize(BufferNotifySize); };
    STDMETHODIMP get_EventHandle(long* pEventHandle) { return CBaseAudio<ISpMMSysAudio>::get_EventHandle(pEventHandle); };
    #endif // SAPI_AUTOMATION

//=== Overrides ===
public:
    STDMETHODIMP_(LRESULT) WindowMessage(void * pvIgnored, HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);

//=== Protected data ===
protected:

    UINT m_uDeviceId;
    void * m_MMHandle;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmaudioin.h ===
/****************************************************************************
*   mmaudioin.h
*       Declarations for the CMMAudioIn class
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#pragma once

//--- Includes --------------------------------------------------------------

#include "resource.h"       // main symbols
#include "mmaudiodevice.h"
#include "sapi.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CMMMixerLine;

/****************************************************************************
*
*   CMMAudioIn
*
******************************************************************** robch */
class ATL_NO_VTABLE CMMAudioIn : 
    public CMMAudioDevice,
	public CComCoClass<CMMAudioIn, &CLSID_SpMMAudioIn>
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_AUDIOIN)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

//=== Methods ===

//=== Ctor, Dtor ===
public:
    CMMAudioIn();
    ~CMMAudioIn();

//=== Interfaces ===
public:

    //--- ISpAudio ----------------------------------------------------------
    STDMETHODIMP GetVolumeLevel(ULONG *pulLevel);
    STDMETHODIMP SetVolumeLevel(ULONG ulLevel);

    //=== Overrides from the base class ===
public:
    //-- ISpMMSysAudioConfig --------------------------------------------------
    STDMETHODIMP Get_UseAutomaticLine(BOOL *bAutomatic);
    STDMETHODIMP Set_UseAutomaticLine(BOOL bAutomatic);
    STDMETHODIMP Get_Line(UINT *uiLineIndex);
    STDMETHODIMP Set_Line(UINT uiLineIndex);
    STDMETHODIMP Get_UseBoost(BOOL *bUseBoost);
    STDMETHODIMP Set_UseBoost(BOOL bUseBoost);
    STDMETHODIMP Get_UseAGC(BOOL *bUseAGC);
    STDMETHODIMP Set_UseAGC(BOOL bUseAGC);
    STDMETHODIMP Get_FixMicOutput(BOOL *bFixMicOutput);
    STDMETHODIMP Set_FixMicOutput(BOOL bFixMicOutput);

    //--- ISpMMSysAudio -----------------------------------------------------
    STDMETHODIMP GetLineId(UINT *puLineId);
    STDMETHODIMP SetLineId(UINT uLineId);

    STDMETHODIMP SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx);

    HRESULT SetDeviceNameFromToken(const WCHAR * pszDeviceName);
    HRESULT GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);

    HRESULT OpenDevice(HWND hwnd);
    HRESULT ChangeDeviceState(SPAUDIOSTATE NewState);
    HRESULT CloseDevice();

    HRESULT AllocateDeviceBuffer(CBuffer ** ppBuff);

    HRESULT ProcessDeviceBuffers(BUFFPROCREASON Reason);

//=== Data ===
private:
#ifndef _WIN32_WCE
    HRESULT         OpenMixer();
    HRESULT         CloseMixer();

    HMIXEROBJ       m_hMixer;
	CMMMixerLine    *m_pWaveInLine;
	CMMMixerLine    *m_pMicInLine;
	CMMMixerLine    *m_pMicOutLine;
    UINT            m_uMixerDeviceId;
    DWORD           m_dwOrigMicInVol;
    DWORD           m_dwOrigWaveInVol;
    DWORD           m_dwOrigMicOutVol;
    BOOL            m_fOrigMicOutMute;
	BOOL			m_fOrigMicBoost;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmaudioout.h ===
/****************************************************************************
*   mmaudioout.h
*       Declarations for the CMMAudioOut class.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "resource.h"       // main symbols
#include "mmaudiodevice.h"
#include "sapi.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CMMMixerLine;

/****************************************************************************
*
*   CMMAudioOut
*
******************************************************************** robch */
class ATL_NO_VTABLE CMMAudioOut : 
    public CMMAudioDevice,
	public CComCoClass<CMMAudioOut, &CLSID_SpMMAudioOut>
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_AUDIOOUT)
    DECLARE_NOT_AGGREGATABLE(CMMAudioOut);
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

//=== Methods ===
public:

    //--- Ctor ---
    CMMAudioOut();
    ~CMMAudioOut();

//=== Interfaces ===
public:

    //--- ISpAudio ----------------------------------------------------------
	STDMETHODIMP GetVolumeLevel(ULONG *pulLevel);
	STDMETHODIMP SetVolumeLevel(ULONG ulLevel);

//=== Overrides from the base class ===
public:
    //--- ISpMMSysAudio -----------------------------------------------------
    STDMETHODIMP GetLineId(UINT *puLineId)
    { return E_NOTIMPL; }
    STDMETHODIMP SetLineId(UINT uLineId)
    { return E_NOTIMPL; }

    STDMETHODIMP SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx);

    HRESULT SetDeviceNameFromToken(const WCHAR * pszDeviceName);
    HRESULT GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);

    HRESULT OpenDevice(HWND hwnd);
    HRESULT ChangeDeviceState(SPAUDIOSTATE NewState);
    HRESULT CloseDevice();

    HRESULT AllocateDeviceBuffer(CBuffer ** ppBuff);

    BOOL UpdateDevicePosition(long *plFreeSpace, ULONG *pulNonBlockingIO);

//=== Data ===
private:
#ifndef _WIN32_WCE
    HRESULT OpenMixer();
    HRESULT CloseMixer();
    HMIXEROBJ m_hMixer;
    UINT m_uMixerDeviceId;
	CMMMixerLine *m_pSpeakerLine;
	CMMMixerLine *m_pWaveOutLine;
#endif
    DWORD m_dwLastWavePos;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmmixerline.cpp ===
/****************************************************************************
*   mmmixerline.cpp
*       Implementation for the CMMMixerLine class.
*
*   Owner: agarside
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------

#include "stdafx.h"
#include "mmmixerline.h"
#include "mmaudioutils.h"
#include <sphelper.h>
#include <mmreg.h>
#include <mmsystem.h>

#ifndef _WIN32_WCE

#pragma warning (disable : 4296)

UINT   g_nMicTypes = 7;
TCHAR * g_MicNames[] = {
    _T("Microphone"),
    _T("Mic"),
    _T("Microphone"),
    _T("Mic"),
    _T("Microphone"),
    _T("Mic"),
    NULL };
UINT   g_MicTypes[] = {
    MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE, 
    MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE,
    MIXERLINE_COMPONENTTYPE_SRC_LINE,
    MIXERLINE_COMPONENTTYPE_SRC_LINE,
    MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED,
    MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED,
    MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE };

UINT   g_nBoostTypes = 4;
TCHAR * g_BoostNames[] = {
    _T("Boost"), 
    _T("20dB"),
    _T("Boost"),
    _T("20db") };
UINT   g_BoostTypes[] = {
    MIXERCONTROL_CONTROLTYPE_ONOFF,
    MIXERCONTROL_CONTROLTYPE_ONOFF,
    MIXERCONTROL_CONTROLTYPE_LOUDNESS,
    MIXERCONTROL_CONTROLTYPE_LOUDNESS };

UINT   g_nAGCTypes = 6;
TCHAR * g_AGCNames[] = {
    _T("Automatic Gain Control"),
    _T("AGC"),
    _T("Microphone Gain Control"),
    _T("Gain Control"), 
    _T("Automatic"), 
    _T("Gain") };

TCHAR * g_MuteName = _T("Mute");

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMMMixerLine::CMMMixerLine() : m_bUseMutesForSelect(true),
    m_bCaseSensitiveCompare(false),
    m_bInitialised(FALSE)
{
    m_mixerLineRecord.cbStruct = sizeof(MIXERLINE);
}

CMMMixerLine::CMMMixerLine(HMIXER &hMixer) : m_bUseMutesForSelect(true),
    m_bCaseSensitiveCompare(false),
    m_bInitialised(FALSE)
{
    m_mixerLineRecord.cbStruct = sizeof(MIXERLINE);
    m_hMixer = hMixer;
}

CMMMixerLine::~CMMMixerLine()
{
}

//////////////////////////////////////////////////////////////////////
// Methods
//////////////////////////////////////////////////////////////////////

HRESULT CMMMixerLine::CreateFromMixerLineStruct(const MIXERLINE *mixerLineRecord)
{
    m_mixerLineRecord = *mixerLineRecord;
    m_mixerLineRecord.cbStruct = sizeof(MIXERLINE);
    return InitFromMixerLineStruct();
}

HRESULT CMMMixerLine::InitFromMixerLineStruct()
{
    UINT i;
    HRESULT hr;
    
    if (m_mixerLineRecord.dwComponentType >= MIXERLINE_COMPONENTTYPE_DST_FIRST && 
        m_mixerLineRecord.dwComponentType <= MIXERLINE_COMPONENTTYPE_DST_LAST )
    {
        m_bDestination = true;
    }
    else
    {
        m_bDestination = false;
    }
    
    MIXERCONTROL mixerControl;
    memset( &mixerControl, 0, sizeof(mixerControl) );
    
    // Find volume control
    m_nVolCtlID = -1;
    hr = GetControl(mixerControl, MIXERCONTROL_CONTROLTYPE_VOLUME, NULL);
    if (SUCCEEDED(hr))
    {
        m_nVolCtlID = mixerControl.dwControlID;
        m_nVolMin = mixerControl.Bounds.lMinimum;
        m_nVolMax = mixerControl.Bounds.lMaximum;
    }
    
    // Find boost control
    m_nBoostCtlID = -1;
    for (i=0; i < g_nBoostTypes; i++)
    {
        // NTRAID#SPEECH-4176-2000/07/28-agarside: WILL FAIL ON NON-ENGLISH MACHINE DUE TO NON-LOCALIZED g_BoostNames
        // NO FALLBACK - IT WILL FAIL TO FIND THE BOOST!!
        hr = GetControl(mixerControl, g_BoostTypes[i], g_BoostNames[i]);
        if (SUCCEEDED(hr))
        {
            m_nBoostCtlID = mixerControl.dwControlID;
            break;
        }
    }
    
    // Find AGC control
    // Names to match (case insensitive) in decreasing order
    m_nAGCCtlID = -1;
    for (i=0; i < g_nAGCTypes; i++)
    {
        // NTRAID#SPEECH-4176-2000/07/28-agarside: WILL FAIL ON NON-ENGLISH MACHINE DUE TO NON-LOCALIZED g_AGCNames
        // NO FALLBACK - IT WILL FAIL TO FIND THE AGC!!
        hr = GetControl(mixerControl, MIXERCONTROL_CONTROLTYPE_ONOFF, g_AGCNames[i]);
        if (SUCCEEDED(hr) && m_nBoostCtlID != (int)mixerControl.dwControlID)
        {
            m_nAGCCtlID = mixerControl.dwControlID;
            break;
        }
    }
    
    // Find select control
    m_nSelectCtlID = -1;
    hr = GetControl(mixerControl, MIXERCONTROL_CONTROLTYPE_MUX, NULL);
    if (SUCCEEDED(hr))
    {
        m_bSelTypeMUX = true;
        m_nSelectCtlID = mixerControl.dwControlID;
        m_nSelectNumItems = mixerControl.cMultipleItems;
    }
    else
    {
        hr = GetControl(mixerControl, MIXERCONTROL_CONTROLTYPE_MIXER, NULL);
        if (SUCCEEDED(hr))
        {
            m_bSelTypeMUX = false;
            m_nSelectCtlID = mixerControl.dwControlID;
            m_nSelectNumItems = mixerControl.cMultipleItems;
        }
    }
    
    // Find Mute control
    m_nMuteCtlID = -1;
    hr = GetControl(mixerControl, MIXERCONTROL_CONTROLTYPE_MUTE, NULL); 
    if (SUCCEEDED(hr))
    {
        m_nMuteCtlID = mixerControl.dwControlID;
    }
    else
    {
        // NTRAID#SPEECH-4176-2000/07/28-agarside: WILL FAIL ON NON-ENGLISH MACHINE DUE TO NON-LOCALIZED g_MuteName
        // NO FALLBACK - IT WILL FAIL TO FIND THE MUTE!!
        hr = GetControl(mixerControl, MIXERCONTROL_CONTROLTYPE_ONOFF, g_MuteName);
        if (SUCCEEDED(hr))
        {
            m_nMuteCtlID = mixerControl.dwControlID;
        }
    }
    
    m_bInitialised = TRUE;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Destination/source line and control obtaining operations
//////////////////////////////////////////////////////////////////////

HRESULT CMMMixerLine::CreateDestinationLine(UINT type)
{
    HRESULT hr = S_OK;
    
    int err;
    if (type >= MIXERLINE_COMPONENTTYPE_DST_FIRST && 
        type <= MIXERLINE_COMPONENTTYPE_DST_LAST )
    {
        m_mixerLineRecord.dwComponentType = type;
        m_mixerLineRecord.cbStruct = sizeof(MIXERLINE);
        err = mixerGetLineInfo((HMIXEROBJ)m_hMixer, &m_mixerLineRecord, MIXER_GETLINEINFOF_COMPONENTTYPE);
        if ( err != MMSYSERR_NOERROR)
        {
            hr = E_FAIL;
            // Destination line not found.
        }
    }
    else
    {
        hr = E_FAIL;
        // Specified type is not a destination line.
    }
    
    if (SUCCEEDED(hr))
    {
        hr = InitFromMixerLineStruct();
    }

    return hr;
}

HRESULT CMMMixerLine::GetMicSourceLine(CMMMixerLine *mixerLine)
{
    HRESULT hr = S_OK;
        
    for(UINT i = 0; i < g_nMicTypes; i++)
    {
        // NTRAID#SPEECH-4176-2000/07/28-agarside: WILL FAIL ON NON-ENGLISH MACHINE DUE TO NON-LOCALIZED g_MicNames
        // Falls back to searching purely based on type which is correct maybe in 90% of drivers.
        hr = GetSourceLine(mixerLine, g_MicTypes[i], g_MicNames[i]);
        if (SUCCEEDED(hr))
        {
            return S_OK;
        }
    }
    
    return E_FAIL;
    // Unable to find a suitable 'Microphone' source line on the destination line.
}

HRESULT CMMMixerLine::GetSourceLine(CMMMixerLine *sourceMixerLine, DWORD index)
{
    SPDBG_FUNC("CMMMixerLine::GetSourceLine");
    HRESULT hr = S_OK;

    if (index<0 || index >= m_mixerLineRecord.cConnections)
    {
        hr = E_INVALIDARG;
    }
    if (SUCCEEDED(hr))
    {
        sourceMixerLine->m_mixerLineRecord.dwDestination = m_mixerLineRecord.dwDestination;
        sourceMixerLine->m_hMixer = m_hMixer;
        sourceMixerLine->m_mixerLineRecord.dwSource = index;
        hr = _MMRESULT_TO_HRESULT (mixerGetLineInfo((HMIXEROBJ)m_hMixer, &sourceMixerLine->m_mixerLineRecord, MIXER_GETLINEINFOF_SOURCE) );
        if (SUCCEEDED(hr))
        {
            hr = sourceMixerLine->InitFromMixerLineStruct();
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CMMMixerLine::GetSourceLine(CMMMixerLine *sourceMixerLine, DWORD componentType, const TCHAR * lpszNameSubstring)
{
    SPDBG_FUNC("CMMMixerLine::GetSourceLine");
    HRESULT hr = S_OK;

    // Variable declarations
    TCHAR * nameUpr = NULL;
    int i;
    BOOL gotMatch = false;
    
    // Initial sanity checks
    if (!m_bDestination)
    {
        hr = E_INVALIDARG;
        // You can only get source lines from destination lines.
    }
    
    if (SUCCEEDED(hr) && componentType == NULL && lpszNameSubstring == NULL)
    {
        hr = E_INVALIDARG;
        // You must specify either a component type or a substring (or both).
    }
    
    // copy and capitalise name substring
    if (SUCCEEDED(hr) && lpszNameSubstring != NULL && !m_bCaseSensitiveCompare)
    {
        nameUpr = new TCHAR[_tcslen(lpszNameSubstring) + 1];
        if (NULL != nameUpr)
        {
            _tcscpy(nameUpr, lpszNameSubstring);
            _tcsupr(nameUpr);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        sourceMixerLine->m_mixerLineRecord.dwDestination = m_mixerLineRecord.dwDestination;
        sourceMixerLine->m_hMixer = m_hMixer;
    
        // Step through each source line for this destination line
        for (i=0; i<(int)m_mixerLineRecord.cConnections && !gotMatch && SUCCEEDED(hr); i++)
        {
            sourceMixerLine->m_mixerLineRecord.dwSource = i;
            if (mixerGetLineInfo((HMIXEROBJ)m_hMixer, &sourceMixerLine->m_mixerLineRecord, MIXER_GETLINEINFOF_SOURCE) == MMSYSERR_NOERROR)
            {
                if (componentType != NULL)
                {
                    if (sourceMixerLine->m_mixerLineRecord.dwComponentType == componentType)
                    {
                        gotMatch = true;
                    }
                }
                if ((componentType == NULL || (componentType != NULL && gotMatch)) && lpszNameSubstring != NULL)
                {
                    if (!m_bCaseSensitiveCompare) _tcsupr(sourceMixerLine->m_mixerLineRecord.szName);
                    if (_tcsstr(sourceMixerLine->m_mixerLineRecord.szName, nameUpr) != NULL)
                    {
                        gotMatch = true;
                    }
                    else
                    {
                        if (!m_bCaseSensitiveCompare) _tcsupr(sourceMixerLine->m_mixerLineRecord.szShortName);
                        if (_tcsstr(sourceMixerLine->m_mixerLineRecord.szShortName, nameUpr) != NULL)
                        {
                            gotMatch = true;
                        }
                        else
                        {
                            gotMatch = false;
                        }
                    }
                }
            }
            else
            {
                hr = E_FAIL;
                // Error getting line info.
            }
        }
    }
    
    delete [] nameUpr;
    
    if (SUCCEEDED(hr) && !gotMatch)
    {
        hr = E_FAIL;
        // Source line not found.
    }

    if (SUCCEEDED(hr))
    {
        hr = sourceMixerLine->InitFromMixerLineStruct();
    }
    
    return hr;
}

HRESULT CMMMixerLine::GetControl(MIXERCONTROL &mixerControl, DWORD controlType, const TCHAR * lpszNameSubstring)
{
    // Variable declarations
    TCHAR *	nameUpr = NULL;
    UINT    i, err;
    BOOL    gotMatch = false;
    HRESULT hr = S_OK;
    MIXERLINECONTROLS mixerLineControls;
    MIXERCONTROL * mixerControlArray = NULL;

    // Sanity checks
    if ( controlType == NULL && lpszNameSubstring == NULL)
    {
        hr = E_INVALIDARG;
        // You must specify either a component type or a substring (or both).
    }
    
    // Copy and uppercase name substring
    if (SUCCEEDED(hr) && lpszNameSubstring != NULL && !m_bCaseSensitiveCompare)
    {
        int len = _tcslen(lpszNameSubstring);
        nameUpr = new TCHAR[len + 1];
        if (NULL != nameUpr)
        {
            _tcscpy(nameUpr, lpszNameSubstring);
            _tcsupr(nameUpr);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        mixerControlArray = new MIXERCONTROL[m_mixerLineRecord.cControls];
        if (NULL == mixerControlArray)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        mixerLineControls.dwLineID	= m_mixerLineRecord.dwLineID;
        mixerLineControls.cbStruct  = sizeof(MIXERLINECONTROLS);
        mixerLineControls.cbmxctrl  = sizeof(MIXERCONTROL);
        mixerLineControls.cControls = m_mixerLineRecord.cControls;
        mixerLineControls.pamxctrl  = mixerControlArray;
    
        // Get all controls
        err = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mixerLineControls, MIXER_GETLINECONTROLSF_ALL);
        if (err != MMSYSERR_NOERROR)
        {
            hr = E_FAIL;
        }
    }
    if (SUCCEEDED(hr))
    {
        for (i=0; i<(int)mixerLineControls.cControls && !gotMatch; i++)
        {
            if (controlType != NULL)
            {
                if (mixerControlArray[i].dwControlType == controlType)
                {
                    gotMatch = true;
                }
            }
            
            if ((controlType == NULL || (controlType != NULL && gotMatch)) && lpszNameSubstring != NULL)
            {
                if (!m_bCaseSensitiveCompare) _tcsupr(mixerControlArray[i].szName);
                if (_tcsstr(mixerControlArray[i].szName, nameUpr) != NULL)
                {
                    gotMatch = true;
                }
                else
                {
                    if (!m_bCaseSensitiveCompare) _tcsupr(mixerControlArray[i].szShortName);
                    if (_tcsstr(mixerControlArray[i].szShortName, nameUpr) != NULL)
                    {
                        gotMatch = true;
                    }
                    else
                    {
                        gotMatch = false;
                    }
                }
            }
            
            if (gotMatch)
            {
                break;
            }
        }
    }
    
    if (SUCCEEDED(hr) && gotMatch)
    {
        mixerControl = mixerControlArray[i];
    }

    if (SUCCEEDED(hr) && !gotMatch)
    {
        // Special hack for Boost control. 
        // If a control exists on the speaker destination line, and this is the wave in destination
        // line then use that instead.
        if (m_mixerLineRecord.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE &&
            (controlType == MIXERCONTROL_CONTROLTYPE_ONOFF || controlType == MIXERCONTROL_CONTROLTYPE_LOUDNESS) &&
            lpszNameSubstring != NULL)
        {
            for (i=0; i < g_nBoostTypes; i++)
            {
                // NTRAID#SPEECH-4176-2000/07/28-agarside: WILL FAIL ON NON-ENGLISH MACHINE DUE TO NON-LOCALIZED g_MicNames
                // NO FALLBACK - IT WILL FAIL TO FIND THE BOOST!!
                if ( _tcsstr(lpszNameSubstring, g_BoostNames[i]) != NULL )
                {
                    // find the component type of the line's destination line.
                    MIXERLINE mxl;
                    mxl.cbStruct = sizeof(MIXERLINE);
                    mxl.dwDestination = m_mixerLineRecord.dwDestination;
                    mixerGetLineInfo((HMIXEROBJ) m_hMixer, &mxl, MIXER_GETLINEINFOF_DESTINATION);
                    
                    if (mxl.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN)
                    {
                        gotMatch = false;
                        CMMMixerLine spkrLine(this->m_hMixer);
                        CMMMixerLine micLine(this->m_hMixer);
                        MIXERCONTROL boostCtl;
                        memset( &boostCtl, 0, sizeof(boostCtl) );
                        boostCtl.cbStruct = sizeof(boostCtl);
                                                hr = spkrLine.CreateDestinationLine(MIXERLINE_COMPONENTTYPE_DST_SPEAKERS);
                        if (SUCCEEDED(hr))
                        {
                            hr = spkrLine.GetSourceLine(&micLine, MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE, NULL);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = micLine.GetControl(boostCtl, controlType, lpszNameSubstring);
                        }
                        if (SUCCEEDED(hr))
                        {
                            gotMatch = true;
                            mixerControl = boostCtl;
                            break;
                        }
                    }
                }
            }
        }
    }
    
    delete [] nameUpr;
    delete [] mixerControlArray;

    if (SUCCEEDED(hr) && !gotMatch)
    {
        hr = E_FAIL;
        // Control not found.
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Control operations
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Control presence queries
//////////////////////////////////////////////////////////////////////

BOOL CMMMixerLine::HasAGC()
{
    return m_nAGCCtlID != -1;
}

BOOL CMMMixerLine::HasBoost()
{
    return m_nBoostCtlID != -1;
}

BOOL CMMMixerLine::HasSelect()
{
    return (m_nSelectCtlID != -1) || 
        (m_bUseMutesForSelect && m_bDestination) ||
        (m_mixerLineRecord.cConnections == 1 && m_bDestination);
}

BOOL CMMMixerLine::HasVolume()
{
    return m_nVolCtlID != -1;
}

BOOL CMMMixerLine::HasMute()
{
    return m_nMuteCtlID != -1;
}

//////////////////////////////////////////////////////////////////////
// Control state queries
//////////////////////////////////////////////////////////////////////

HRESULT CMMMixerLine::GetAGC(BOOL *bState)
{
    if (m_nAGCCtlID != -1)
    {
        return QueryBoolControl(m_nAGCCtlID, bState);
    }
    return E_FAIL;
}

HRESULT CMMMixerLine::GetBoost(BOOL *bState)
{
    if (m_nBoostCtlID != -1)
    {
        return QueryBoolControl(m_nBoostCtlID, bState);
    }
    return E_FAIL;
}

HRESULT CMMMixerLine::GetSelect(DWORD *lState)
{
    return E_NOTIMPL;
#if 0
    // warning: This function doesn't work properly!!
    
    MIXERCONTROLDETAILS mixerControlDetails;
    MIXERCONTROLDETAILS_BOOLEAN mbool[32];
    
    // Initialise MIXERCONTROLDETAILS structure
    mixerControlDetails.cbStruct=sizeof(MIXERCONTROLDETAILS);
    mixerControlDetails.dwControlID=m_nSelectCtlID;
    mixerControlDetails.cChannels=1;
    mixerControlDetails.cMultipleItems=m_nSelectNumItems;
    mixerControlDetails.cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerControlDetails.paDetails = &mbool;
    
    // Query mixer
    int err = mixerGetControlDetails( (HMIXEROBJ) m_hMixer, &mixerControlDetails, MIXER_GETCONTROLDETAILSF_VALUE );
    if (err!=MMSYSERR_NOERROR) 
    {
        return -1;
        // Error getting control details.
    }
    
    return mbool[0].fValue != 0;
#endif
}

HRESULT CMMMixerLine::GetVolume(DWORD *lState)
{
    if (m_nVolCtlID != -1)
    {
        return QueryIntegerControl(m_nVolCtlID, lState);
    }
    return E_FAIL;
}

HRESULT CMMMixerLine::GetMute(BOOL *bState)
{
    if (m_nMuteCtlID != -1)
    {
        return QueryBoolControl(m_nMuteCtlID, bState);
    }
    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////
// Control update
//////////////////////////////////////////////////////////////////////

HRESULT CMMMixerLine::SetAGC(BOOL agc)
{
    if (m_nAGCCtlID != -1)
    {
        return SetBoolControl(m_nAGCCtlID, agc);
    }
    return E_FAIL;
}

HRESULT CMMMixerLine::SetBoost(BOOL boost)
{
    if (m_nBoostCtlID != -1)
    {
        return SetBoolControl(m_nBoostCtlID, boost);
    }
    return E_FAIL;
}

HRESULT CMMMixerLine::SetMute(BOOL mute)
{
    if (m_nMuteCtlID != -1)
    {
        return SetBoolControl(m_nMuteCtlID, mute);
    }
    return E_FAIL;
}

HRESULT CMMMixerLine::ExclusiveSelect(const CMMMixerLine *mixerLine)
{
    if (mixerLine->m_bDestination)
    {
        return E_FAIL;
        // Line to be selected must be a source line.
    }
    
    if (mixerLine->m_mixerLineRecord.dwDestination != m_mixerLineRecord.dwDestination)
    {
        return E_FAIL;
        // Line to be selected must be connected to this destination line.
    }
    
    return ExclusiveSelect(mixerLine->m_mixerLineRecord.dwLineID);
}

HRESULT CMMMixerLine::ExclusiveSelect(UINT lineID)
{
    MIXERCONTROLDETAILS mixerControlDetails;
    int i;
    HRESULT hr = S_OK;
    
    if (!HasSelect())
    {
        hr = E_FAIL;
        // Destination line does not have select control.
    }
    else if (m_nSelectCtlID != -1)
    {
        MIXERCONTROLDETAILS_BOOLEAN * mbool = new MIXERCONTROLDETAILS_BOOLEAN[m_nSelectNumItems];
        if (NULL == mbool)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memset(mbool, 0, sizeof(MIXERCONTROLDETAILS_BOOLEAN)*m_nSelectNumItems);
        
            // Search for matching dwLineID;
            MIXERCONTROLDETAILS details;
            details.cbStruct       = sizeof( MIXERCONTROLDETAILS );
            details.dwControlID    = m_nSelectCtlID;
            details.cMultipleItems = m_nSelectNumItems;
            details.cbDetails      = sizeof( MIXERCONTROLDETAILS_LISTTEXT );
        
            details.cChannels = 1;  // specify that we want to operate on each line
            // as if it were 'uniform' 
        
            MIXERCONTROLDETAILS_LISTTEXT *list = new MIXERCONTROLDETAILS_LISTTEXT[m_nSelectNumItems];
            if (NULL == list)
            {
                hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                details.paDetails = list;
        
                // Query the mixer device to list all of the items it controls.
                if( mixerGetControlDetails( (HMIXEROBJ) m_hMixer, &details, 
                    MIXER_GETCONTROLDETAILSF_LISTTEXT ) != MMSYSERR_NOERROR )
                {
                    hr = E_FAIL;
                }

                if (SUCCEEDED(hr))
                {
                    // Search for the device specified by lineID
                    BOOL found = false;
                    for ( int i = 0; i < m_nSelectNumItems; i++ )
                    {
                        if (list[i].dwParam1==lineID)
                        {
                            // Found correct device.
                            found = true;
                            mbool[i].fValue = TRUE;
                            break;
                        }
                    }
        
                    // Throw an exception if we can't find the specified line
                    if (!found)
                    {
                        hr = E_FAIL;
                        // Couldn't find line with.
                    }
                }
        
                if (SUCCEEDED(hr))
                {
                    // Initialise MIXERCONTROLDETAILS structure
                    mixerControlDetails.cbStruct		= sizeof(MIXERCONTROLDETAILS);
                    mixerControlDetails.dwControlID		= m_nSelectCtlID;
                    mixerControlDetails.cChannels		= 1;
                    mixerControlDetails.cMultipleItems	= m_nSelectNumItems;
                    mixerControlDetails.cbDetails		= sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                    mixerControlDetails.paDetails		= mbool;
        
                    // Query mixer
                    int err = mixerSetControlDetails( (HMIXEROBJ) m_hMixer, &mixerControlDetails, MIXER_SETCONTROLDETAILSF_VALUE );
        
                    if (err!=MMSYSERR_NOERROR)
                    {
                        hr = E_FAIL;
                        // Error setting control details.
                    }
                }
                delete [] list;
            }
            delete [] mbool;
        }
    }
    else
    {
        // use mute controls instead.
        MIXERLINE sourceLine;
        sourceLine.cbStruct = sizeof(sourceLine);
        sourceLine.dwDestination = m_mixerLineRecord.dwDestination;
        BOOL foundLine = FALSE;
        
        // 1. find all controls on this destination line
        for(i = 0; i < (int)m_mixerLineRecord.cConnections; i++)
        {
            CMMMixerLine sl(m_hMixer);
            int err;
            sourceLine.dwSource = i;
            err = mixerGetLineInfo((HMIXEROBJ) m_hMixer, &sourceLine, MIXER_GETLINEINFOF_SOURCE);
            
            if (err == MMSYSERR_NOERROR)
            {
                sl.CreateFromMixerLineStruct(&sourceLine);
                
                if (sl.HasMute())
                {
                    // switch mute on except for the line we want on (lineID)
                    if (sourceLine.dwLineID == lineID)
                    {
                        foundLine = TRUE;
                        sl.SetMute(FALSE);
                    }
                    else if (sourceLine.dwComponentType != MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT)
                    {
                        // Mute everything but the wave-out device (some sound cards have waveout as an input
                        // and it is fully linked to the output. Hence muting it mutes the output).
                        sl.SetMute(TRUE);
                    }
                }
            }
        }
        
        // If we only have one device attched to this mixer, then return
        // silently. There is no need to select this device. 
        // 
        // This situation was encountered when using a 'Telex USB Microphone'.
        if (m_mixerLineRecord.cConnections > 1 && !foundLine )
        {
            hr = E_FAIL;
            // Couldn't find mute control for line.
        }
    }

    return hr;
}

HRESULT CMMMixerLine::SetVolume(DWORD volume)
{
    if (m_nVolCtlID != -1)
    {
        if (volume < m_nVolMin) volume = m_nVolMin;
        if (volume > m_nVolMax) volume = m_nVolMax;
        return SetIntegerControl(m_nVolCtlID, volume);
    }
    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////
// General control operations
//////////////////////////////////////////////////////////////////////

HRESULT CMMMixerLine::QueryBoolControl(DWORD ctlID, BOOL *bState)
{
    MIXERCONTROLDETAILS mixerControlDetails;
    MIXERCONTROLDETAILS_BOOLEAN mbool;
    
    // Initialise MIXERCONTROLDETAILS structure
    mixerControlDetails.cbStruct=sizeof(MIXERCONTROLDETAILS);
    mixerControlDetails.dwControlID=ctlID;
    mixerControlDetails.cChannels=1;
    mixerControlDetails.cMultipleItems=0;
    mixerControlDetails.cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerControlDetails.paDetails = &mbool;
    
    // Query mixer
    int err = mixerGetControlDetails( (HMIXEROBJ) m_hMixer, &mixerControlDetails, MIXER_GETCONTROLDETAILSF_VALUE );
    if (err!=MMSYSERR_NOERROR)
    {
        return E_FAIL;
        // Error getting control details.
    }
    
    *bState = mbool.fValue != 0;
    return S_OK;
}

HRESULT CMMMixerLine::SetBoolControl(DWORD ctlID, BOOL bNewState)
{
    MIXERCONTROLDETAILS mixerControlDetails;
    MIXERCONTROLDETAILS_BOOLEAN mbool;
    
    // Initialise MIXERCONTROLDETAILS structure
    mixerControlDetails.cbStruct=sizeof(MIXERCONTROLDETAILS);
    mixerControlDetails.dwControlID=ctlID;
    mixerControlDetails.cChannels=1;
    mixerControlDetails.cMultipleItems=0;
    mixerControlDetails.cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerControlDetails.paDetails = &mbool;
    
    // Query mixer
    mbool.fValue = bNewState;
    int err = mixerSetControlDetails( (HMIXEROBJ) m_hMixer, &mixerControlDetails, NULL );
    if (err!=MMSYSERR_NOERROR)
    {
        return E_FAIL;
        // Error getting control details.
    }
    
    return S_OK;
}

HRESULT CMMMixerLine::QueryIntegerControl(DWORD ctlID, DWORD *lState)
{
    MIXERCONTROLDETAILS mixerControlDetails;
    MIXERCONTROLDETAILS_SIGNED msigned;
    
    // Initialise MIXERCONTROLDETAILS structure
    mixerControlDetails.cbStruct=sizeof(MIXERCONTROLDETAILS);
    mixerControlDetails.dwControlID=ctlID;
    mixerControlDetails.cChannels=1;
    mixerControlDetails.cMultipleItems=0;
    mixerControlDetails.cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerControlDetails.paDetails = &msigned;
    
    // Query mixer
    int err = mixerGetControlDetails( (HMIXEROBJ) m_hMixer, &mixerControlDetails, MIXER_GETCONTROLDETAILSF_VALUE );
    if (err!=MMSYSERR_NOERROR) 
    {
        return E_FAIL;
        // Error getting control details.
    }
    
    *lState = msigned.lValue;
    return S_OK;
}

HRESULT CMMMixerLine::SetIntegerControl(DWORD ctlID, DWORD lNewState)
{
    MIXERCONTROLDETAILS mixerControlDetails;
    MIXERCONTROLDETAILS_SIGNED msigned;
    
    // Initialise MIXERCONTROLDETAILS structure
    mixerControlDetails.cbStruct=sizeof(MIXERCONTROLDETAILS);
    mixerControlDetails.dwControlID=ctlID;
    mixerControlDetails.cChannels=1;
    mixerControlDetails.cMultipleItems=0;
    mixerControlDetails.cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerControlDetails.paDetails = &msigned;
    
    // Query mixer
    msigned.lValue = lNewState;
    int err = mixerSetControlDetails( (HMIXEROBJ) m_hMixer, &mixerControlDetails, NULL );
    if (err != MMSYSERR_NOERROR)
    {
        return E_FAIL;
        // Error getting control details.
    }
    
    return S_OK;
}

BOOL CMMMixerLine::IsInitialised()
{
    return m_bInitialised;
}

HRESULT CMMMixerLine::GetLineNames(WCHAR **szCoMemLineList)
{
    USES_CONVERSION;
    SPDBG_FUNC("CMMMixerLine::GetLineNames");
    HRESULT hr = S_OK;
    MMRESULT mm;
    UINT i, cbList = 0;
    WCHAR *szTmp;

    MIXERLINE mixerLine;
    memset(&mixerLine, 0, sizeof(mixerLine));
    mixerLine.cbStruct = sizeof(mixerLine);
    mixerLine.dwDestination = m_mixerLineRecord.dwDestination;

    for (i=0; i<m_mixerLineRecord.cConnections; i++)
    {
        mixerLine.dwSource = i;
        hr = _MMRESULT_TO_HRESULT( mixerGetLineInfo((HMIXEROBJ)m_hMixer, &mixerLine, MIXER_GETLINEINFOF_SOURCE) );
        if (SUCCEEDED(hr))
        {
            #ifdef _UNICODE
            cbList += _tcslen(mixerLine.szName) + 1;
            #else
            cbList += ::MultiByteToWideChar(CP_ACP, 0, mixerLine.szName, -1, NULL, 0);
            #endif
        }
    }

    if (SUCCEEDED(hr))
    {
        *szCoMemLineList = (WCHAR *)::CoTaskMemAlloc(sizeof(WCHAR)*(cbList+2));
        if (!(*szCoMemLineList))
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        szTmp = *szCoMemLineList;
        for (i=0; i<m_mixerLineRecord.cConnections; i++)
        {
            mixerLine.dwSource = i;
            hr = _MMRESULT_TO_HRESULT( mixerGetLineInfo((HMIXEROBJ)m_hMixer, &mixerLine, MIXER_GETLINEINFOF_SOURCE) );
            if (SUCCEEDED(hr))
            {
                #ifdef _UNICODE
                _tcsncpy(szTmp, mixerLine.szName, (cbList+1)-(int)(szTmp-*szCoMemLineList));
                #else
                ::MultiByteToWideChar(CP_ACP, 0, mixerLine.szName, -1, szTmp, (cbList+1)-(int)(szTmp-*szCoMemLineList));
                #endif
                szTmp += wcslen(szTmp) + 1;
            }
        }
        // Add zero-length terminating string.
        szTmp[0]=0;
        szTmp[1]=0;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CMMMixerLine::GetConnections(UINT *nConnections)
{
    SPDBG_FUNC("CMMMixerLine::GetConnections");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(nConnections))
    {
        hr = E_POINTER;
    }
    else if (m_mixerLineRecord.cConnections == 0)
    {
        SPDBG_ASSERT(FALSE);
        hr = SPERR_UNINITIALIZED;
    }
    if (SUCCEEDED(hr))
    {
        *nConnections = m_mixerLineRecord.cConnections;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

#endif // _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmaudioout.cpp ===
/****************************************************************************
*   mmaudioout.cpp
*       Implementation of the CMMAudioOut class.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------

#include "stdafx.h"
#include "mmmixerline.h"
#include "mmaudioout.h"
#include "mmaudiobuffer.h"
#include <sphelper.h>
#include <dbt.h>
#include <mmreg.h>
#include <mmsystem.h>

/****************************************************************************
* CMMAudioOut::CMMAudioOut *
*--------------------------*
*   Description:  
*       ctor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CMMAudioOut::CMMAudioOut() : 
    CMMAudioDevice(TRUE)
{
#ifndef _WIN32_WCE
	m_pSpeakerLine = NULL;
	m_pWaveOutLine = NULL;
	m_hMixer = NULL;
    m_uMixerDeviceId = (UINT)-1;
#endif
}

/****************************************************************************
* CMMAudioOut::~CMMAudioOut *
*--------------------------*
*   Description:  
*       dtor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CMMAudioOut::~CMMAudioOut()
{
#ifndef _WIN32_WCE
    SPDBG_ASSERT(NULL == m_hMixer);
#endif
}

/****************************************************************************
* CMMAudioOut::GetVolumeLevel *
*-----------------------------*
*   Description:
*       Returns the volume level on a linear scale of (0 - 10000)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** YUNUSM ***/
STDMETHODIMP CMMAudioOut::GetVolumeLevel(ULONG *pulLevel)
{
    SPDBG_FUNC("CMMAudioOut::GetVolumeLevel");
    HRESULT hr = S_OK;
    DWORD dwVolume;

    if (!pulLevel || SPIsBadWritePtr(pulLevel, sizeof(ULONG)))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        if (m_lDelayedVolumeSet != -1)
        {
            *pulLevel = m_lDelayedVolumeSet;
        }
#ifdef _WIN32_WCE
        else if (!m_MMHandle)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            // CE uses waveOutGetVolume instead of mixer access as CE doesn't have a mixer.
            hr = _MMRESULT_TO_HRESULT(::waveOutGetVolume((HWAVEOUT)m_MMHandle, &dwVolume));
            // support only mono channel getting/setting
            *pulLevel = (10000 * (dwVolume & 0xffff)) / 0xffff;
        }
    }
#else
        else if (m_pWaveOutLine && m_pWaveOutLine->HasVolume())
        {
            hr = m_pWaveOutLine->GetVolume(&dwVolume);
            *pulLevel = (dwVolume * 10000) / 0xffff;
        }
        else if (m_pSpeakerLine && m_pSpeakerLine->HasVolume())
        {
            hr = m_pSpeakerLine->GetVolume(&dwVolume);
            *pulLevel = (dwVolume * 10000) / 0xffff;
        }
        else
        {
            *pulLevel = 0;
            hr = SPERR_UNINITIALIZED;
        }
    }
#endif
    return hr;
}

/****************************************************************************
* CMMAudioOut::SetVolumeLevel *
*-----------------------------*
*   Description:
*       Sets the volume level on a linear scale of (0 - 10000)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** YUNUSM ***/
STDMETHODIMP CMMAudioOut::SetVolumeLevel(ULONG ulLevel)
{
    SPDBG_FUNC("CMMAudioOut::SetVolumeLevel");
    HRESULT hr = S_OK;

    if  (ulLevel > 10000)
    {
        hr = E_INVALIDARG;
    }
#ifdef _WIN32_WCE
    // Use waveOutGetVolume for CE - use delayed set if device not open.
    else if (!m_MMHandle)
    {
        m_lDelayedVolumeSet = ulLevel;
        // Nothing happens if we later get error when we really try and set this.
    }
    else
    {
        // support only mono channel getting/setting
        // CE uses waveOutSetVolume instead of mixer accesses since it doesn't have a mixer.
        hr = _MMRESULT_TO_HRESULT(::waveOutSetVolume((HWAVEOUT)m_MMHandle, (ulLevel * 0xffff) / 10000));
    }
#else
    else if (!m_pWaveOutLine && !m_pSpeakerLine)
    {
        m_lDelayedVolumeSet = ulLevel;
        // Nothing happens if we later get error when we really try and set this.
    }
    else if (!m_pWaveOutLine->HasVolume() && !m_pSpeakerLine->HasVolume()) 
    {
        hr = SPERR_DEVICE_NOT_SUPPORTED;
    }
    else
    {
        ulLevel = (ulLevel * 0xffff) / 10000;
        if (m_pWaveOutLine && m_pWaveOutLine->HasVolume())
        {
            hr = m_pWaveOutLine->SetVolume(ulLevel);
        }
        if (m_pSpeakerLine && m_pSpeakerLine->HasVolume())
        {
            hr = m_pSpeakerLine->SetVolume(ulLevel);
        }
    }
#endif
    return hr;
}

/****************************************************************************
* CMMAudioOut::SetFormat *
*------------------------*
*   Description:  
*       ISpAudio::SetFormat implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CMMAudioOut::SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pwfex)
{
    HRESULT hr = S_OK;

    CSpStreamFormat OldFmt;
    hr = OldFmt.AssignFormat(m_StreamFormat);
    if (SUCCEEDED(hr))
    {
        hr = CBaseAudio<ISpMMSysAudio>::SetFormat(rguidFmtId, pwfex);
    }
    if (SUCCEEDED(hr))
    {
        hr = _MMRESULT_TO_HRESULT(::waveOutOpen(NULL, m_uDeviceId, pwfex, 0, 0, WAVE_FORMAT_QUERY));
        if (FAILED(hr))
        {
            HRESULT hr2 = CBaseAudio<ISpMMSysAudio>::SetFormat(OldFmt.FormatId(), OldFmt.WaveFormatExPtr());
            SPDBG_ASSERT(SUCCEEDED(hr2));
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CMMAudioOut::SetDeviceNameFromToken *
*-------------------------------------*
*   Description:  
*       Set the device name from the token (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::SetDeviceNameFromToken(const WCHAR * pszDeviceName)
{
    UINT cDevs = ::waveOutGetNumDevs();
    for (UINT i = 0; i < cDevs; i++)
    {
#ifdef _WIN32_WCE
        WAVEOUTCAPS woc;
#else
        WAVEOUTCAPSW woc;
#endif
        MMRESULT mmr = g_Unicode.waveOutGetDevCaps(i, &woc, sizeof(woc));
        if (mmr == MMSYSERR_NOERROR)
        {
            if (wcscmp(pszDeviceName, woc.szPname) == 0)
            {
                return SetDeviceId(i);
            }
        }
    }
    return E_INVALIDARG;
}

/****************************************************************************
* CMMAudioOut::GetDefaultDeviceFormat *
*------------------------------------*
*   Description:  
*       Get the default device format (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    if (!m_MMHandle)
    {
        return SPERR_UNINITIALIZED;
    }
    WAVEOUTCAPS woc;
    SPSTREAMFORMAT eFormat;
    HRESULT hr = _MMRESULT_TO_HRESULT(::waveOutGetDevCaps(m_uDeviceId, &woc, sizeof(woc)));
    if (SUCCEEDED(hr))
    {
        hr = ConvertFormatFlagsToID(woc.dwFormats, &eFormat);
    }
    if (SUCCEEDED(hr))
    {
        hr = SpConvertStreamFormatEnum(eFormat, pFormatId, ppCoMemWaveFormatEx);
    }
    return hr;
}

#ifndef _WIN32_WCE
/****************************************************************************
* CMMAudioOut::OpenMixer *
*------------------------*
*   Description:  
*       Open the mixer for the device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::OpenMixer()
{
    HRESULT hr = S_OK;
	MMRESULT mm;

    if (m_uMixerDeviceId == m_uDeviceId)
    {
        // Already open.
        return S_OK;
    }
    if (m_hMixer)
    {
        CloseMixer(); // Ignore return code.
    }
	mm = mixerOpen((HMIXER*)&m_hMixer, (UINT)m_uDeviceId, 0, 0, MIXER_OBJECTF_WAVEOUT);
	if (mm != MMSYSERR_NOERROR)
	{
		return _MMRESULT_TO_HRESULT(mm);
	}

	// Create mixer line objects to set inputs.
	SPDBG_ASSERT(m_pSpeakerLine == NULL);
	SPDBG_ASSERT(m_pWaveOutLine == NULL);
	m_pSpeakerLine = new CMMMixerLine((HMIXER &)m_hMixer);
	if (!m_pSpeakerLine)
	{
		return E_OUTOFMEMORY;
	}
	m_pWaveOutLine = new CMMMixerLine((HMIXER &)m_hMixer);
	if (!m_pWaveOutLine)
	{
		return E_OUTOFMEMORY;
	}

	// Find speaker destination line and wave out source line.
	hr = m_pSpeakerLine->CreateDestinationLine(MIXERLINE_COMPONENTTYPE_DST_SPEAKERS);
    if (SUCCEEDED(hr))
    {
    	hr = m_pSpeakerLine->GetSourceLine(m_pWaveOutLine, MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT, NULL);
    }

#if 0 // No longer automatically unmute output. Undesirable to override user settings in this scenario.
	// Unmute speaker and waveout.
    if (SUCCEEDED(hr))
    {
    	hr = m_pWaveOutLine->SetMute(false);
    }
    if (SUCCEEDED(hr))
    {
	    hr = m_pSpeakerLine->SetMute(false);
    }
#endif

    // Do we have a delayed volume set to honor?
    // Otherwise above original volume will remain active.
    if (SUCCEEDED(hr) && m_lDelayedVolumeSet != -1)
    {
		hr = SetVolumeLevel(m_lDelayedVolumeSet);
        m_lDelayedVolumeSet = -1;
    }

    if (SUCCEEDED(hr))
    {
        m_uMixerDeviceId = m_uDeviceId;
    }
    return hr;
}

/****************************************************************************
* CMMAudioOut::CloseMixer *
*-------------------------*
*   Description:  
*       Close the mixer for the device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::CloseMixer()
{
    if (!m_hMixer)
    {
        return E_FAIL;
    }
    if (m_hMixer)
    {
	    mixerClose((HMIXER)m_hMixer);
	    m_hMixer = NULL;
    }
    if (m_pWaveOutLine)
    {
	    delete m_pWaveOutLine;
	    m_pWaveOutLine = NULL;
    }
    if (m_pSpeakerLine)
    {
	    delete m_pSpeakerLine;
    	m_pSpeakerLine = NULL;
    }
    m_uMixerDeviceId = (UINT)-1;
    return S_OK;
}
#endif

/****************************************************************************
* CMMAudioOut::OpenDevice *
*------------------------*
*   Description:  
*       Open the device (called by the base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::OpenDevice(HWND hwnd)
{
    SPDBG_FUNC("CMMAudioOut::OpenDevice");
    HRESULT hr = S_OK;

#ifndef _WIN32_WCE
    OpenMixer(); // Ignore return code.
#endif

    m_dwLastWavePos = 0;
    hr = _MMRESULT_TO_HRESULT(::waveOutOpen(NULL, m_uDeviceId, m_StreamFormat.WaveFormatExPtr(), 0, 0, WAVE_FORMAT_QUERY));
    if (SUCCEEDED(hr))
    {
        hr = _MMRESULT_TO_HRESULT(::waveOutOpen((HWAVEOUT *)&m_MMHandle, m_uDeviceId, m_StreamFormat.WaveFormatExPtr(), (DWORD_PTR)hwnd, (DWORD_PTR)this, CALLBACK_WINDOW));
        if (hr == SPERR_UNSUPPORTED_FORMAT)
        {
            // Know this is not the case as we've explicitly tested above.
            hr = SPERR_DEVICE_BUSY;
        }
    }

#ifndef _WIN32_WCE
    if (FAILED(hr))
    {
        CloseMixer(); // Ignore return code.
    }
#endif

#ifdef _WIN32_WCE
    // Non-CE is handled in OpenMixer.
    if (SUCCEEDED(hr) && m_lDelayedVolumeSet != -1)
    {
        HRESULT hr2;
        hr2 = _MMRESULT_TO_HRESULT(::waveOutSetVolume((HWAVEOUT)m_MMHandle, m_lDelayedVolumeSet));
        SPDBG_ASSERT(S_OK == hr2);
        // We don't want this error to propogate. If we fail a delayed set, so be it.
        m_lDelayedVolumeSet = -1;
    }
#endif

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CMMAudioOut::ChangeDeviceState *
*-------------------------------*
*   Description:  
*       Make whatever changes to the device status that are required (called
*       by the base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::ChangeDeviceState(SPAUDIOSTATE NewState)
{
    switch (NewState)
    {
        case SPAS_STOP:
            m_dwLastWavePos = 0;
            ::waveOutPause((HWAVEOUT)m_MMHandle);
            ::waveOutReset((HWAVEOUT)m_MMHandle);
            break;

        case SPAS_PAUSE:
            ::waveOutPause((HWAVEOUT)m_MMHandle);
            break;

        case SPAS_RUN:
            ::waveOutRestart((HWAVEOUT)m_MMHandle);
            break;
    }

    return S_OK;
}
                
/****************************************************************************
* CMMAudioOut::CloseDevice *
*-------------------------*
*   Description:  
*       Close the device (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::CloseDevice()
{
    HRESULT hr = S_OK;
    HWAVEOUT hwo = (HWAVEOUT)m_MMHandle;
    m_MMHandle = NULL;
    SPDBG_ASSERT(hwo);
    ::waveOutReset(hwo);
    PurgeAllQueues();
    m_State = SPAS_CLOSED;
#ifndef _WIN32_WCE
    CloseMixer(); // Ignore return code.
    return _MMRESULT_TO_HRESULT(::waveOutClose(hwo));
#else
    for (UINT i = 0; i < 20; i++)
    {
        if (FAILED(hr = _MMRESULT_TO_HRESULT(::waveOutClose(hwo))))
        {
            Sleep(10);
        }
        else
        {
            break;
        }
    }
    return hr;
#endif
}

/****************************************************************************
* CMMAudioOut::AllocateDeviceBuffer *
*----------------------------------*
*   Description:  
*       Allocate a buffer specific for this device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CMMAudioOut::AllocateDeviceBuffer(CBuffer ** ppBuff)
{
    *ppBuff = new CMMAudioOutBuffer(this);
    return *ppBuff ? S_OK : E_OUTOFMEMORY;
}

/****************************************************************************
* CMMAudioOut::UpdateDevicePosition *
*-----------------------------------*
*   Description:  
*       Update the device position by calling teh wave out APIs, then chaining
*       to the base class.
*
*   Return:
*   BaseClass::UpdateDevicePosition()
******************************************************************** robch */
BOOL CMMAudioOut::UpdateDevicePosition(long * plFreeSpace, ULONG *pulNonBlockingIO)
{
    if (m_MMHandle)
    {
        MMTIME mmt;
        mmt.wType = TIME_BYTES;
        ::waveOutGetPosition((HWAVEOUT)m_MMHandle, &mmt, sizeof(mmt));
        DWORD dwElapsed = mmt.u.cb - m_dwLastWavePos;
        // Sometimes the stupid driver goes backwards a little bit.  Ignore this
        if (dwElapsed < 0x80000000)
        {
           // On Win98 (crystal driver) sometimes the device position gets ahead of the seek position. Cant allow that.
	        if ((m_ullDevicePosition + dwElapsed) > m_ullSeekPosition)
	        {
		        dwElapsed = static_cast<DWORD>(m_ullSeekPosition - m_ullDevicePosition);
            }
            m_dwLastWavePos += dwElapsed;
	        m_ullDevicePosition += dwElapsed;
        }
    }
    return CMMAudioDevice::UpdateDevicePosition(plFreeSpace, pulNonBlockingIO);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmmixerline.h ===
/****************************************************************************
*   mmaudioin.h
*       Declarations for the CMMAudioIn class
*
*   Owner: agarside
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#pragma once

#ifndef _WIN32_WCE
//--- Includes --------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

class CMMMixerLine  
{
// === Ctor, Dtor ===
public:
	CMMMixerLine();
	CMMMixerLine(HMIXER &hMixer);
	virtual ~CMMMixerLine();

// === Methods ===
public:
	// Initialisation functions
	HRESULT		CreateDestinationLine(UINT type);
	HRESULT		CreateFromMixerLineStruct(const MIXERLINE *mixerLine);

	// sub-line functions
	// Retrieve source line specified by (optional) componentType and or substring.
	HRESULT		GetMicSourceLine(CMMMixerLine *mixerLine);
    HRESULT     GetSourceLine(CMMMixerLine *sourceMixerLine, DWORD index);
	HRESULT		GetSourceLine(CMMMixerLine *mixerLine, DWORD componentType, const TCHAR *lpszNameSubstring);
    HRESULT     GetLineNames(WCHAR **szCoMemLineList);

	// Retrieve control specified by (optional) controlType and or substring. Throws if no match found
	HRESULT		GetControl(MIXERCONTROL &mixerControl, DWORD controlType, const TCHAR *lpszNameSubstring);

	// Line status queries
	BOOL		IsInitialised(void);

	// Control availability queries
	BOOL		HasAGC(void);
	BOOL		HasBoost(void);
	BOOL		HasSelect(void);
	BOOL		HasVolume(void);
	BOOL		HasMute(void);
    HRESULT     GetConnections(UINT *nConnections);

	// Control state queries
	HRESULT		GetAGC(BOOL *bState);
	HRESULT		GetBoost(BOOL *bState);
	HRESULT		GetSelect(DWORD *lState);
	HRESULT		GetVolume(DWORD *lState);
	HRESULT		GetMute(BOOL *bState);

	// Update control state
	HRESULT		SetAGC(BOOL agc);
	HRESULT		SetBoost(BOOL boost);
	HRESULT		ExclusiveSelect(const CMMMixerLine *mixerLine);
	HRESULT		ExclusiveSelect(UINT lineID);
	HRESULT		SetVolume(DWORD volume);
	HRESULT		SetMute(BOOL mute);

	// General control operations
	HRESULT		QueryBoolControl(DWORD ctlID, BOOL *bState);
	HRESULT		SetBoolControl(DWORD ctlID, BOOL bNewState);

	HRESULT		QueryIntegerControl(DWORD ctlID, DWORD *lState);
	HRESULT		SetIntegerControl(DWORD ctlID, DWORD lNewState);

// === Data ===
private:

	HMIXER		m_hMixer;

	// m_bUseMutesForSelect:
	// true => ExclusiveSelect will use mute controls to select the input
	//         device if there is no MIXER or MUX control.
	// false => disable this feature.
	BOOL		m_bUseMutesForSelect;
	BOOL		m_bCaseSensitiveCompare;

	BOOL		m_bDestination;	// true if this is a 'destination' line. false if a 'source' line

	MIXERLINE	m_mixerLineRecord;
	
	// Volume control
	DWORD		m_nVolMin;		// minimum value for volume control
	DWORD		m_nVolMax;		// maximum value for volume control
	int			m_nVolCtlID;	// volume control

	int			m_nAGCCtlID;	// AGC mixer control
	int			m_nBoostCtlID;	// boost mixer control
	int			m_nMuteCtlID;	// mute control
	
	BOOL		m_bSelTypeMUX;  // false => mixer (multiple select), true=>mux (single select)
	int			m_nSelectCtlID;	// input select mixer control
	int			m_nSelectNumItems; // number of selectable items on this line

	HRESULT		InitFromMixerLineStruct();
	BOOL		m_bInitialised;		// true if this line is initialised with valid data
};

#endif // _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\mmaudioutils.h ===
/****************************************************************************
*   mmaudioutils.h
*       Multimedia audio utilities
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#pragma once

//--- Inline Function Definitions -------------------------------------------

/****************************************************************************
* ConvertFormatFlagsToID *
*------------------------*
*   Description:  
*       Convert the dwFormats parameter from WAVEINCAPS or WAVEOUTCAPS to the
*       appropriate SAPI format GUID.
*
*       The following values are defined in MMSYSTEM.  Since these were
*       defined a LONG time ago, they can never change, so we can rely on the
*       order for our GUID table.                                         
*
*       WAVE_INVALIDFORMAT     0x00000000       invalid format
*       WAVE_FORMAT_1M08       0x00000001       11.025 kHz, Mono,   8-bit
*       WAVE_FORMAT_1S08       0x00000002       11.025 kHz, Stereo, 8-bit
*       WAVE_FORMAT_1M16       0x00000004       11.025 kHz, Mono,   16-bit
*       WAVE_FORMAT_1S16       0x00000008       11.025 kHz, Stereo, 16-bit
*       WAVE_FORMAT_2M08       0x00000010       22.05  kHz, Mono,   8-bit
*       WAVE_FORMAT_2S08       0x00000020       22.05  kHz, Stereo, 8-bit
*       WAVE_FORMAT_2M16       0x00000040       22.05  kHz, Mono,   16-bit
*       WAVE_FORMAT_2S16       0x00000080       22.05  kHz, Stereo, 16-bit
*       WAVE_FORMAT_4M08       0x00000100       44.1   kHz, Mono,   8-bit
*       WAVE_FORMAT_4S08       0x00000200       44.1   kHz, Stereo, 8-bit
*       WAVE_FORMAT_4M16       0x00000400       44.1   kHz, Mono,   16-bit
*       WAVE_FORMAT_4S16       0x00000800       44.1   kHz, Stereo, 16-bit
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
inline HRESULT ConvertFormatFlagsToID(DWORD dwFormatFlags, SPSTREAMFORMAT * peFormat)
{
    static const SPSTREAMFORMAT aFormats[] =
    {
        SPSF_NoAssignedFormat,               // If we run off the end then we'll return NULL
        SPSF_11kHz8BitMono,
        SPSF_11kHz8BitStereo,
        SPSF_11kHz16BitMono,
        SPSF_11kHz16BitStereo,
        SPSF_22kHz8BitMono,
        SPSF_22kHz8BitStereo,
        SPSF_22kHz16BitMono,
        SPSF_22kHz16BitStereo,
        SPSF_44kHz8BitMono,
        SPSF_44kHz8BitStereo,
        SPSF_44kHz16BitMono,
        SPSF_44kHz16BitStereo,
    };
    //
    // We'll start with the highest quality and work our way down
    //
    DWORD dwTest = (1 << (sp_countof(aFormats) - 1));
    const SPSTREAMFORMAT * pFmt = aFormats + sp_countof(aFormats);
    do
    {
        pFmt--;
        dwTest = dwTest >> 1;
    } while (dwTest && ((dwFormatFlags & dwTest) == 0));
    *peFormat = *pFmt;
    return dwTest ? S_OK : SPERR_UNSUPPORTED_FORMAT;
}


/****************************************************************************
* _MMRESULT_TO_HRESULT *
*----------------------*
*   Description:  
*       Convert the multimedia mmresult code into a SPG HRESULT.
*   NOTE:  Do not use this for mmioxxx functions since the error codes overlap
*   with the MCI error codes.
*
*   Return:
*   The converted HRESULT.
******************************************************************** robch */
inline HRESULT _MMRESULT_TO_HRESULT(MMRESULT mm)
{
    switch (mm)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_BADDEVICEID: 
        return SPERR_DEVICE_NOT_SUPPORTED; 

    case MMSYSERR_ALLOCATED: 
        return SPERR_DEVICE_BUSY; 

    case MMSYSERR_NOMEM: 
        return E_OUTOFMEMORY; 

    case MMSYSERR_NOTENABLED:
        return SPERR_DEVICE_NOT_ENABLED;

    case MMSYSERR_NODRIVER: 
        return SPERR_NO_DRIVER;

#ifndef _WIN32_WCE
    case MIXERR_INVALLINE:
    case MIXERR_INVALCONTROL:
    case MMSYSERR_INVALFLAG:
    case MMSYSERR_INVALHANDLE:
    case MMSYSERR_INVALPARAM:
        return E_INVALIDARG;
#endif

    case MMSYSERR_NOTSUPPORTED:
        return E_NOTIMPL;

    case WAVERR_BADFORMAT:
        return SPERR_UNSUPPORTED_FORMAT;

    default:
        return SPERR_GENERIC_MMSYS_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\nullconv.h ===
/*******************************************************************************
*   NullConv.h
*   This is the header file for the Null Phone Converter class.
*
*   Owner: (written by BillRo)
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include "CommonLx.h"

//--- TypeDef and Enumeration Declarations -------------------------------------

//--- Class, Struct and Union Definitions --------------------------------------

/*******************************************************************************
*
*   CSpNullPhoneConverter
*
********************************************************************************/
class ATL_NO_VTABLE CSpNullPhoneConverter :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpNullPhoneConverter, &CLSID_SpNullPhoneConverter>,
    public ISpPhoneConverter
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_NULLPHONECONV)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CSpNullPhoneConverter)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
        COM_INTERFACE_ENTRY(ISpPhoneConverter)
    END_COM_MAP()
        
//=== Methods ====
public:

//=== Interfaces ===
public:         

    //--- ISpObjectWithToken
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

    //--- ISpPhoneConverter
    STDMETHODIMP SetLanguage(LANGID LangID);
    STDMETHODIMP PhoneToId(const WCHAR * pszPhone, SPPHONEID * pszId);
    STDMETHODIMP IdToPhone(const WCHAR * pszId, WCHAR * pszPhone);

//=== Private methods ===
private:

//=== Private data ===
private:
    CComPtr<ISpObjectToken> m_cpObjectToken;    // object token
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\nullconv.cpp ===
/*******************************************************************************
*   NullConv.cpp
*   Null phone converter object for Japanese/Chinese, where SAPI phone IDs are
*   Unicode kana, so no conversion is necessary.
*
*   Owner: (written by BillRo)
*   Copyright (C) 2000 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

//--- Includes -----------------------------------------------------------------

#include "stdafx.h"
#include "NullConv.h"
#ifndef _WIN32_WCE
#include <wchar.h>
#endif

//--- Constants ----------------------------------------------------------------

STDMETHODIMP CSpNullPhoneConverter::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC("CSpNullPhoneConverter::SetObjectToken");
    HRESULT hr = S_OK;

    hr = SpGenericSetObjectToken(pToken, m_cpObjectToken);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

STDMETHODIMP CSpNullPhoneConverter::GetObjectToken(ISpObjectToken **ppToken)
{
    return SpGenericGetObjectToken(ppToken, m_cpObjectToken);
}

/*******************************************************************************
* CSpNullPhoneConverter::PhoneToId *
*-------------------------------*
*   
*   Description:
*       Convert an internal phone string to Id code string.
*       Copy input to output, since SAPI IDs for this language are Unicode.
*
*   Return: 
*       S_OK
*       E_INVALIDARG
*******************************************************************************/
STDMETHODIMP CSpNullPhoneConverter::PhoneToId(const WCHAR *pszIntPhone,    // Internal phone string
                                          SPPHONEID *pId               // Returned Id string
                                          )
{
    SPDBG_FUNC("CSpNullPhoneConverter::PhoneToId");

    if (!pszIntPhone || SPIsBadStringPtr(pszIntPhone) || !pId)
    {
        return E_INVALIDARG;
    }

    return SPCopyPhoneString(pszIntPhone, (WCHAR*)pId);
}

/*******************************************************************************
* CSpNullPhoneConverter::IdToPhone *
*-------------------------------*
*
*   Description:
*       Convert an Id code string to internal phone.
*       Copy input to output, since SAPI IDs for this language are Unicode.
*
*   Return:
*       S_OK
*       E_INVALIDARG
*******************************************************************************/
STDMETHODIMP CSpNullPhoneConverter::IdToPhone(const SPPHONEID *pId,       // Id string
                                          WCHAR *pszIntPhone          // Returned Internal phone string
                                          )
{
    SPDBG_FUNC("CSpNullPhoneConverter::IdToPhone");

    if (!pId || SPIsBadStringPtr((WCHAR*)pId) || !pszIntPhone)
    {
        return E_INVALIDARG;
    }

    return SPCopyPhoneString((WCHAR*)pId, pszIntPhone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttoken.h ===
/****************************************************************************
*   ObjectToken.h
*       Declarations for the CSpObjectToken class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "sapi.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CSpObjectToken :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpObjectToken, &CLSID_SpObjectToken>,
    #ifdef SAPI_AUTOMATION
        public IDispatchImpl<ISpeechObjectToken, &IID_ISpeechObjectToken, &LIBID_SpeechLib, 5>,
    #endif // SAPI_AUTOMATION
    public ISpObjectTokenInit
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_OBJECTTOKEN)

    BEGIN_COM_MAP(CSpObjectToken)
        COM_INTERFACE_ENTRY(ISpObjectToken)
        COM_INTERFACE_ENTRY(ISpObjectTokenInit)
        #ifdef SAPI_AUTOMATION
            COM_INTERFACE_ENTRY(IDispatch)
            COM_INTERFACE_ENTRY(ISpeechObjectToken)
        #endif // SAPI_AUTOMATION
    END_COM_MAP()

//=== Interfaces ===
public:

    STDMETHODIMP FinalConstruct();
    STDMETHODIMP FinalRelease();

    //--- ISpObjectTokenInit --------------------------------------------------
    STDMETHODIMP InitFromDataKey(const WCHAR * pszCategoryId, const WCHAR * pszTokenId, ISpDataKey * pDataKey);
    
    //--- ISpObjectToken ------------------------------------------------------
    STDMETHODIMP SetId(const WCHAR * pszCategoryId, const WCHAR * pszTokenId, BOOL fCreateIfNotExist);
    STDMETHODIMP GetId(WCHAR ** ppszCoMemTokenId);
    STDMETHODIMP GetCategory(ISpObjectTokenCategory ** ppTokenCategory);

    STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, DWORD dwClsContext, REFIID riid, void ** ppvObject);

    STDMETHODIMP GetStorageFileName(REFCLSID clsidCaller, const WCHAR *pszValueName, const WCHAR *pszFileNameSpecifier, ULONG nFolder, WCHAR ** ppszFilePath);
    STDMETHODIMP RemoveStorageFileName(REFCLSID clsidCaller, const WCHAR *pszKeyName, BOOL fDeleteFile);

    STDMETHODIMP Remove(const CLSID * pclsidCaller);
    
    STDMETHODIMP IsUISupported(const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData, IUnknown * punkObject, BOOL *pfSupported);
    STDMETHODIMP DisplayUI(HWND hwndParent, const WCHAR * pszTitle, const WCHAR * pszTypeOfUI, void * pvExtra, ULONG cbExtraData, IUnknown * punkObject);

    STDMETHODIMP MatchesAttributes(const WCHAR * pszAttributes, BOOL *pfMatches);

    //--- ISpDataKey ----------------------------------------------------------
    STDMETHODIMP SetData(const WCHAR * pszValueName, ULONG cbData, const BYTE * pData);
    STDMETHODIMP GetData(const WCHAR * pszValueName, ULONG * pcbData, BYTE * pData);
    STDMETHODIMP GetStringValue(const WCHAR * pszValueName, WCHAR ** ppValue);
    STDMETHODIMP SetStringValue(const WCHAR * pszValueName, const WCHAR * pszValue);
    STDMETHODIMP SetDWORD(const WCHAR * pszValueName, DWORD dwValue);
    STDMETHODIMP GetDWORD(const WCHAR * pszValueName, DWORD *pdwValue);
    STDMETHODIMP OpenKey(const WCHAR * pszSubKeyName, ISpDataKey ** ppKey);
    STDMETHODIMP CreateKey(const WCHAR * pszSubKeyName, ISpDataKey ** ppKey);
    STDMETHODIMP DeleteKey(const WCHAR * pszSubKeyName);
    STDMETHODIMP DeleteValue(const WCHAR * pszValueName);
    STDMETHODIMP EnumKeys(ULONG Index, WCHAR ** ppszSubKeyName);
    STDMETHODIMP EnumValues(ULONG Index, WCHAR ** ppszValueName);

    #ifdef SAPI_AUTOMATION
        //--- ISpeechDataKey is provided by the CSpRegDataKey class -------------------------------------

        //--- ISpeechObjectToken dispatch interface -------------------------------------
        STDMETHOD(get_Id)( BSTR* pObjectId );
        STDMETHOD(get_DataKey)( ISpeechDataKey** DataKey );
        STDMETHOD(get_Category)( ISpeechObjectTokenCategory** Category );
        STDMETHOD(GetDescription)( long LocaleId, BSTR* pDescription );
        STDMETHOD(SetId)( BSTR Id, BSTR CategoryID, VARIANT_BOOL CreateIfNotExist );
        STDMETHOD(GetAttribute)( BSTR AttributeName, BSTR* AttributeValue);
        STDMETHOD(CreateInstance)( IUnknown *pUnkOuter, SpeechTokenContext ClsContext, IUnknown **ppObject );
        STDMETHOD(Remove)( BSTR ObjectStgCLSID );
        STDMETHOD(GetStorageFileName)( BSTR clsidCaller, BSTR KeyName, BSTR FileName, SpeechTokenShellFolder Folder, BSTR* pFilePath );
        STDMETHOD(RemoveStorageFileName)( BSTR clsidCaller, BSTR KeyName, VARIANT_BOOL fDeleteFile);
        STDMETHOD(IsUISupported)( const BSTR TypeOfUI, const VARIANT* ExtraData, IUnknown* pObject, VARIANT_BOOL *Supported );
        STDMETHOD(DisplayUI)( long hWnd, BSTR Title, const BSTR TypeOfUI,  const VARIANT* ExtraData, IUnknown* pObject );
        STDMETHOD(MatchesAttributes)( BSTR Attributes, VARIANT_BOOL* Matches );
    #endif // SAPI_AUTOMATION

//=== Private methods ===
private:

    HRESULT ParseTokenId(
                const WCHAR * pszCategoryId,
                const WCHAR * pszTokenId,
                WCHAR ** ppszCategoryId,
                WCHAR ** ppszTokenIdForEnum,
                WCHAR ** ppszTokenEnumExtra);

    HRESULT InitToken(const WCHAR * pszCategoryId, const WCHAR * pszTokenId, BOOL fCreateIfNotExist);
    HRESULT InitFromTokenEnum(const WCHAR * pszCategoryId, const WCHAR * pszTokenId, const WCHAR * pszTokenIdForEnum, const WCHAR * pszTokenEnumExtra);

    HRESULT CreatePath(const WCHAR *pszPath, ULONG ulCreateFrom);
    HRESULT GenerateFileName(const WCHAR *pszPath, const WCHAR *pszFileNameSpecifier, CSpDynamicString &fileName);
    HRESULT FileSpecifierToRegPath(const WCHAR *pszFileNameSpecifier, ULONG nFolder, CSpDynamicString &filePath, CSpDynamicString &regPath);
    HRESULT RegPathToFilePath(const WCHAR *regPath, CSpDynamicString &filePath);
    HRESULT OpenFilesKey(REFCLSID clsidCaller, BOOL fCreateKey, ISpDataKey ** ppKey);
    HRESULT DeleteFileFromKey(ISpDataKey * pKey, const WCHAR * pszValueName);
    HRESULT RemoveAllStorageFileNames(const CLSID * pclsidCaller);

    HRESULT GetUIObjectClsid(const WCHAR * pszTypeOfUI, CLSID *pclsid);

    //=== Methods for locking of tokens ===
    HRESULT MakeHandleName(const CSpDynamicString &dstrID, CSpDynamicString &dstrHandleName, BOOL fEvent);
    HRESULT EngageUseLock(const WCHAR *pszTokenId);
    HRESULT ReleaseUseLock();
    HRESULT EngageRemovalLock();
    HRESULT ReleaseRemovalLock();

//=== Private data ===
private:

    BOOL m_fKeyDeleted;     // Has associated registry key been deleted
    HANDLE m_hTokenLock;        // Used to lock token creation / removal
    HANDLE m_hRegistryInUseEvent;    // Used to detect if registry key already in use when trying to create /remove

    CSpDynamicString        m_dstrTokenId;
    CSpDynamicString        m_dstrCategoryId;

    CComPtr<ISpDataKey>     m_cpDataKey;
    CComPtr<ISpObjectToken> m_cpTokenDelegate;
};


#ifdef SAPI_AUTOMATION

class CSpeechDataKey : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ISpeechDataKey, &IID_ISpeechDataKey, &LIBID_SpeechLib, 5>
{
//=== ATL Setup ===
public:

    BEGIN_COM_MAP(CSpeechDataKey)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISpeechDataKey)
    END_COM_MAP()

//=== Methods ===
public:

    //--- Ctor, dtor

//=== Interfaces ===
public:

    //--- ISpeechDataKey --------------------------------------------------
    STDMETHODIMP SetBinaryValue( const BSTR bstrValueName, VARIANT psaData );
    STDMETHODIMP GetBinaryValue( const BSTR bstrValueName, VARIANT* psaData );
    STDMETHODIMP SetStringValue( const BSTR bstrValueName, const BSTR szString );
    STDMETHODIMP GetStringValue( const BSTR bstrValueName, BSTR * szSting );
    STDMETHODIMP SetLongValue( const BSTR bstrValueName, long Long );
    STDMETHODIMP GetLongValue( const BSTR bstrValueName, long* pLong );
    STDMETHODIMP OpenKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey );
    STDMETHODIMP CreateKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey );
    STDMETHODIMP DeleteKey( const BSTR bstrSubKeyName );
    STDMETHODIMP DeleteValue( const BSTR bstrValueName );
    STDMETHODIMP EnumKeys( long Index, BSTR* pbstrSubKeyName );
    STDMETHODIMP EnumValues( long Index, BSTR* pbstrValueName );

    CComPtr<ISpDataKey>    m_cpDataKey;
};

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttoken.cpp ===
/****************************************************************************
*   ObjectToken.cpp
*       Implementation for the CSpObjectToken class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "ObjectToken.h"
#include "RegHelpers.h"
#include "ObjectTokenAttribParser.h"
#include "shlobj.h"
#include <stdio.h>
#ifndef _WIN32_WCE
#include "shfolder.h"
#endif

// Constants used in GetStorageFileName file storage functionality
//
// Relative path below special folders where storage files are stored
static const WCHAR* pszFileStoragePath = L"\\Microsoft\\Speech\\Files\\";
// Prefix used for storage files if not otherwise set
static const WCHAR* pszDefaultFilePrefix = L"SP_";
// Extension used for storage files if not otherwise set
static const WCHAR* pszDefaultFileSuffix = L".dat";
// Specifier used to generate a random filename.
static const WCHAR* pszGenerateFileNameSpecifier = L"%d";

/****************************************************************************
* CSpObjectToken::FinalConstruct *
*--------------------------------*
*   Description:  
*       Basic initialization (not really needed, but FinalRelease is).
*
*   Return:
*   S_OK
****************************************************************** davewood */
STDMETHODIMP CSpObjectToken::FinalConstruct()
{
    m_fKeyDeleted = FALSE;
    m_hTokenLock = NULL;
    m_hRegistryInUseEvent = NULL;
    return S_OK;
}

/****************************************************************************
* CSpObjectToken::FinalRelease   *
*--------------------------------*
*   Description:  
*       If the object has been initialized and EngageUseLock called,
*       makes sure ReleaseUseLock called.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** davewood */
STDMETHODIMP CSpObjectToken::FinalRelease()
{
    HRESULT hr = S_OK;

    if (m_dstrTokenId != NULL && m_cpTokenDelegate == NULL)
    {
        hr = ReleaseUseLock();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::MakeHandleName *
*--------------------------------*
*   Description:  
*       Helper function that makes a unique handle name from the token id
*       (Handle names cannot have '\' characters in them).
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** davewood */
HRESULT CSpObjectToken::MakeHandleName(const CSpDynamicString &dstrID, CSpDynamicString &dstrHandleName, BOOL fEvent)
{
    SPDBG_FUNC("CSpObjectToken::MakeHandleName");
    HRESULT hr = S_OK;

    dstrHandleName = dstrID;
    if(dstrHandleName.m_psz == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        for(ULONG i = 0; dstrHandleName.m_psz[i]; i++)
        {
            if(dstrHandleName.m_psz[i] == L'\\')
            {
                dstrHandleName.m_psz[i] = L'_';
            }
        }

        WCHAR *psz;
        if(fEvent)
        {
            psz = L"_Event";
        }
        else
        {
            psz = L"_Mutex";
        }

        if(!dstrHandleName.Append(psz))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::EngageUseLock *
*-------------------------------*
*   Description:  
*       Called when a token is initialised to make the named event m_hRegistryInUseEvent.
*       The existance of this event is used to prevent the registry information
*       this token refers to from being deleted by another object token.
*       A named mutex is used to prevent thread conflicts between tokens.
*
*   Return:
*   S_OK on success
*   SPERR_TOKEN_IN_USE if another token is currently deleting this registry key
*   FAILED(hr) otherwise
****************************************************************** davewood */
HRESULT CSpObjectToken::EngageUseLock(const WCHAR *pszTokenId)
{
    SPDBG_FUNC("CSpObjectToken::EngageUseLock");
    HRESULT hr = S_OK;

#ifndef _WIN32_WCE
    SPDBG_ASSERT(m_hTokenLock == NULL && m_hRegistryInUseEvent == NULL);

    CSpDynamicString dstrMutexName, dstrEventName;

    hr = MakeHandleName(pszTokenId, dstrMutexName, FALSE);
    if(SUCCEEDED(hr))
    {
        hr = MakeHandleName(pszTokenId, dstrEventName, TRUE);
    }

    // create mutex without claiming it
    if(SUCCEEDED(hr))
    {
        m_hTokenLock = g_Unicode.CreateMutex(NULL, FALSE, dstrMutexName.m_psz);
        if(!m_hTokenLock)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    // now claim the mutex
    if(SUCCEEDED(hr))
    {
        DWORD dw = ::WaitForSingleObject(m_hTokenLock, 5000);
        if(dw == WAIT_TIMEOUT)
        {
            // We couldn't obtain the mutex for this token even after waiting.
            // Another thread may have hung inside the objecttoken create or remove methods.
            // This should never happen.
            hr = SPERR_TOKEN_IN_USE;
        }
        else if(dw == WAIT_FAILED)
        {
            hr = SpHrFromLastWin32Error();
        }
        // If we can get the mutex (WAIT_ABANDONED or WAIT_OBJECT_0) then continue
    }

    // create event - state and previous existence not important
    if(SUCCEEDED(hr))
    {
        m_hRegistryInUseEvent = g_Unicode.CreateEvent(NULL, TRUE, TRUE, dstrEventName.m_psz);
        if(!m_hRegistryInUseEvent)
        {
            hr = SpHrFromLastWin32Error();
        }

        // release mutex
        if(!::ReleaseMutex(m_hTokenLock))
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    if(FAILED(hr))
    {
        if(m_hTokenLock)
        {
            ::CloseHandle(m_hTokenLock);
            m_hTokenLock = NULL;
        }
        if(m_hRegistryInUseEvent)
        {
            ::CloseHandle(m_hRegistryInUseEvent);
            m_hRegistryInUseEvent = NULL;
        }
    }
#endif

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


/****************************************************************************
* CSpObjectToken::ReleaseUseLock *
*-------------------------------*
*   Description:  
*       Called when an object token is deleted. Closes handles.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** davewood */
HRESULT CSpObjectToken::ReleaseUseLock()
{
    SPDBG_FUNC("CSpObjectToken::ReleaseUseLock");
    HRESULT hr = S_OK;

#ifndef _WIN32_WCE
    SPDBG_ASSERT(m_hTokenLock && m_hRegistryInUseEvent);

    // don't need to release mutex as will have called ReleaseRemovalLock prior to this

    // close event & mutex
    if(m_hTokenLock && !::CloseHandle(m_hTokenLock))
    {
        hr = SpHrFromLastWin32Error();
    }    
    if(m_hRegistryInUseEvent && !::CloseHandle(m_hRegistryInUseEvent))
    {
        hr = SpHrFromLastWin32Error();
    }

    m_hTokenLock = NULL;
    m_hRegistryInUseEvent = NULL;
#endif

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


/****************************************************************************
* CSpObjectToken::EngageRemovalLock *
*-----------------------------------*
*   Description:  
*       Called when the registry information the token refers to is being
*       removed (i.e. when Remove() is called). The closes and tries to
*       reopen the named event. If it can this indicates another token is
*       using the registry key. Also locks the named mutex so deletion
*       can continue without a new token being created on the same key.
*
*   Return:
*   S_OK on success
*   SPERR_TOKEN_IN_USE if another token is currently using this registry key
*   FAILED(hr) otherwise
****************************************************************** davewood */
HRESULT CSpObjectToken::EngageRemovalLock()
{
    SPDBG_FUNC("CSpObjectToken::EngageRemovalLock");
    HRESULT hr = S_OK;

#ifndef _WIN32_WCE
    USES_CONVERSION; // Needed for OpenKey method

    // assert id, event, mutex
    SPDBG_ASSERT(m_dstrTokenId != NULL);
    SPDBG_ASSERT(m_hTokenLock && m_hRegistryInUseEvent);

    // wait for mutex
    DWORD dw = ::WaitForSingleObject(m_hTokenLock, 5000);
    if(dw == WAIT_TIMEOUT)
    {
        // We couldn't obtain the mutex for this token even after waiting.
        // Another thread may have hung inside the objecttoken create or remove methods.
        // This should never happen.
        hr = SPERR_TOKEN_IN_USE;
    }
    else if(dw == WAIT_FAILED)
    {
        hr = SpHrFromLastWin32Error();
    }
    // If we can get the mutex (WAIT_ABANDONED or WAIT_OBJECT_0) then continue

    if(SUCCEEDED(hr))
    {
        CSpDynamicString dstrEventName;
        hr = MakeHandleName(m_dstrTokenId, dstrEventName, TRUE);

        // Close event in order to see if we can subsequently re-open it.
        if(SUCCEEDED(hr))
        {
            if(!::CloseHandle(m_hRegistryInUseEvent))
            {
                hr = SpHrFromLastWin32Error();
            }
        }

        // open event
        if(SUCCEEDED(hr))
        {
            m_hRegistryInUseEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, W2T(dstrEventName.m_psz));
            if(m_hRegistryInUseEvent)
            {
                hr = SPERR_TOKEN_IN_USE;
            }
            else
            {
                // okay - we can't open existing event so no one else is using it
                // create event to put back to original state
                m_hRegistryInUseEvent = g_Unicode.CreateEvent(NULL, FALSE, FALSE, dstrEventName.m_psz);
                if(!m_hRegistryInUseEvent)
                {
                    hr = SpHrFromLastWin32Error();
                }
            }
        }

        // Unlock if failed, else held locked until ReleaseRemovalLock
        if(FAILED(hr))
        {
            if(!::ReleaseMutex(m_hTokenLock))
            {
                hr = SpHrFromLastWin32Error();
            }
        }

    }
#endif

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::ReleaseRemovalLock *
*------------------------------------*
*   Description:  
*       Called when an object token has finished removing the removing the
*       registry info. Puts the locks back to the same state 
*       as before EngageRemovalLock.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** davewood */
HRESULT CSpObjectToken::ReleaseRemovalLock()
{
    SPDBG_FUNC("CSpObjectToken::ReleaseRemovalLock");
    HRESULT hr = S_OK;

#ifndef _WIN32_WCE
    SPDBG_ASSERT(m_dstrTokenId != NULL);
    SPDBG_ASSERT(m_hTokenLock && m_hRegistryInUseEvent);

    // release mutex that was claimed in EngageReleaseLock
    if(!::ReleaseMutex(m_hTokenLock))
    {
        hr = SpHrFromLastWin32Error();
    }
#endif

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


/****************************************************************************
* CSpObjectToken::SetId *
*-----------------------*
*   Description:  
*       Set the token id. Can only be called once.
*
*       Category IDS look something like:
*           "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\
*            Speech\Recognizers"
*
*       Known HKEY_* are:
*           HKEY_CLASSES_ROOT, 
*           HKEY_CURRENT_USER, 
*           HKEY_LOCAL_MACHINE, 
*           HKEY_CURRENT_CONFIG
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::SetId(const WCHAR * pszCategoryId, const WCHAR * pszTokenId, BOOL fCreateIfNotExist)
{
    SPDBG_FUNC("CSpObjectToken::SetId");
    HRESULT hr = S_OK;
    
    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_dstrTokenId != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszCategoryId) ||
             SP_IS_BAD_STRING_PTR(pszTokenId))
    {
        hr = E_POINTER;
    }

    CSpDynamicString dstrCategoryId, dstrTokenIdForEnum, dstrTokenEnumExtra;
    if (SUCCEEDED(hr))
    {
        SPDBG_ASSERT(m_dstrTokenId == NULL);
        SPDBG_ASSERT(m_dstrCategoryId == NULL);
        SPDBG_ASSERT(m_cpDataKey == NULL);
        SPDBG_ASSERT(m_cpTokenDelegate == NULL);
        
        hr = ParseTokenId(
                pszCategoryId, 
                pszTokenId, 
                &dstrCategoryId, 
                &dstrTokenIdForEnum,
                &dstrTokenEnumExtra);
    }

    if (SUCCEEDED(hr))
    {
        if (dstrTokenIdForEnum != NULL)
        {
            hr = InitFromTokenEnum(
                    dstrCategoryId, 
                    pszTokenId, 
                    dstrTokenIdForEnum, 
                    dstrTokenEnumExtra);
        }
        else
        {
            hr = InitToken(dstrCategoryId, pszTokenId, fCreateIfNotExist);
        }
    }

    #ifdef DEBUG
    if (SUCCEEDED(hr))
    {
        SPDBG_ASSERT(m_dstrTokenId != NULL);
        SPDBG_ASSERT(m_cpDataKey != NULL || m_cpTokenDelegate != NULL);
    }
    #endif // DEBUG
    
    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/****************************************************************************
* CSpObjectToken::GetId *
*-----------------------*
*   Description:  
*       Get the token id as a co task mem allocated string
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::GetId(WCHAR ** ppszCoMemTokenId)
{
    SPDBG_FUNC("CSpObjectToken::GetId");
    HRESULT hr = S_OK;

    if (m_dstrTokenId == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppszCoMemTokenId))
    {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr))
    {
        hr = SpCoTaskMemAllocString(m_dstrTokenId, ppszCoMemTokenId);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::GetCategory *
*-----------------------------*
*   Description:  
*       Get the category if this token has one
*
*   Return:
*   S_OK on success
*   SPERR_UNINITIALIZED if the token doesn't have a category
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::GetCategory(ISpObjectTokenCategory ** ppTokenCategory)
{
    SPDBG_FUNC("CSpObjectToken::GetCategory");
    HRESULT hr = S_OK;

    if (m_dstrCategoryId == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppTokenCategory))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = SpGetCategoryFromId(m_dstrCategoryId, ppTokenCategory);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::CreateInstance *
*--------------------------------*
*   Description:  
*       Create the associated object instance for the token. For example, 
*       if this was a token for a recognizer, CreateInstance would actually
*       create the recognizer itself.
*
*   Return:
*   S_OK on success
*   SPERR_UNINITIALIZED if the token hasn't been initialized
*   SPERR_NOT_FOUND if the token doesn't contain a CLSID
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::CreateInstance(
    IUnknown * pUnkOuter, DWORD dwClsContext, REFIID riid, void ** ppvObject)
{
    SPDBG_FUNC("CSpObjectToken::CreateInstance");
    HRESULT hr = S_OK;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_cpDataKey == NULL && m_cpTokenDelegate == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppvObject))
    {
        hr = E_POINTER;
    }
    else if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pUnkOuter))
    {
        hr = E_INVALIDARG;
    }
    else if (m_cpTokenDelegate != NULL)
    {
        hr = m_cpTokenDelegate->CreateInstance(
                    pUnkOuter, 
                    dwClsContext, 
                    riid, 
                    ppvObject);
    }
    else
    {
        // Get the clsid
        CSpDynamicString dstrClsid;
        hr = m_cpDataKey->GetStringValue(SPTOKENVALUE_CLSID, &dstrClsid);

        // Convert from a string
        CLSID clsid;
        if (SUCCEEDED(hr))
        {
            hr = ::CLSIDFromString(dstrClsid, &clsid);
        }

        // Create the object
        if (SUCCEEDED(hr))
        {
            hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, riid, ppvObject);
        }

        // Set the object token
        if (SUCCEEDED(hr))
        {
            CComQIPtr<ISpObjectWithToken> cpObjWithToken((IUnknown *)(*ppvObject));
            if (cpObjWithToken)
            {
                CComPtr<ISpObjectTokenInit> cpObjectTokenCopy;
                hr = cpObjectTokenCopy.CoCreateInstance(CLSID_SpObjectToken);
                if(SUCCEEDED(hr))
                {
                    cpObjectTokenCopy->InitFromDataKey(m_dstrCategoryId, m_dstrTokenId, this);
                }

                if(SUCCEEDED(hr))
                {
                    hr = cpObjWithToken->SetObjectToken(cpObjectTokenCopy);
                }

                if (FAILED(hr))
                {
                    ((IUnknown *)(*ppvObject))->Release();
                    *ppvObject = NULL;
                }
            }
        }
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CSpObjectToken::GenerateFileName *
*----------------------------------*
*   Description:
*       Given a path and file specifier, creates a new filename.
*       Just the filename is returned, not the path.
*        
*   Returns:
*   S_OK on success
*   FAILED(hr) otherwise
********************************************************************* DAVEWOOD ***/
HRESULT CSpObjectToken::GenerateFileName(const WCHAR *pszPath, const WCHAR *pszFileNameSpecifier, CSpDynamicString &dstrFileName)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    // Is the caller asking for a random filename element in the name
    if(pszFileNameSpecifier == NULL || wcslen(pszFileNameSpecifier) == 0 ||
        wcsstr(pszFileNameSpecifier, pszGenerateFileNameSpecifier) != NULL)
    {
        // Generate a random filename using prefix and suffix
        CSpDynamicString dstrFilePrefix;
        CSpDynamicString dstrFileSuffix;

        if(pszFileNameSpecifier == NULL || wcslen(pszFileNameSpecifier) == 0 ||
            (wcslen(pszFileNameSpecifier) == wcslen(pszGenerateFileNameSpecifier) &&
            wcscmp(pszFileNameSpecifier, pszGenerateFileNameSpecifier) == 0))
        {
            // No specific format given so make files of format "SP_xxxx.dat"
            dstrFilePrefix = pszDefaultFilePrefix;
            dstrFileSuffix = pszDefaultFileSuffix;
        }
        else
        {
            // Extract the prefix and suffix of the random element
            WCHAR *psz = wcsstr(pszFileNameSpecifier, pszGenerateFileNameSpecifier);
            dstrFilePrefix.Append(pszFileNameSpecifier, (ULONG)(psz - pszFileNameSpecifier));
            dstrFileSuffix.Append(psz + wcslen(pszGenerateFileNameSpecifier));
        }

        if(SUCCEEDED(hr))
        {
            // Create random GUID to use as part of filename
            GUID guid;
            hr = ::CoCreateGuid(&guid);

            // Convert to string
            CSpDynamicString dstrGUID;
            if(SUCCEEDED(hr))
            {
                hr = ::StringFromCLSID(guid, &dstrGUID);
            }

            CSpDynamicString dstrRandomString;
            if(SUCCEEDED(hr))
            {
                dstrRandomString.ClearAndGrowTo(dstrGUID.Length());
                if(dstrRandomString.m_psz == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // Remove non-alpha numeric characters
            if(SUCCEEDED(hr))
            {
                WCHAR *pszDest = dstrRandomString.m_psz;
                for(WCHAR *pszSrc = dstrGUID.m_psz; *pszSrc != L'\0'; pszSrc++)
                {
                    if(iswalnum(*pszSrc))
                    {
                        *pszDest = *pszSrc;
                        pszDest++;
                    }
                }
                *pszDest = L'\0';
            }

            if(SUCCEEDED(hr))
            {
                dstrFileName = dstrFilePrefix;
                if(dstrFileName.m_psz == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }

                if(SUCCEEDED(hr))
                {
                    dstrFileName.Append2(dstrRandomString, dstrFileSuffix);
                }

                CSpDynamicString dstrFileAndPath;
                if(SUCCEEDED(hr))
                {
                    dstrFileAndPath.Append2(pszPath, dstrFileName);
                    if(dstrFileAndPath.m_psz == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                // See if file can be created
                if(SUCCEEDED(hr))
                {
                    HANDLE hFile = g_Unicode.CreateFile(dstrFileAndPath, GENERIC_WRITE, 0, NULL, CREATE_NEW, 
                        FILE_ATTRIBUTE_NORMAL, NULL);
                    if(hFile != INVALID_HANDLE_VALUE)
                    {
                        // Successfully created empty new file, so close and return
                        if(!CloseHandle(hFile))
                        {
                            hr = SpHrFromLastWin32Error();
                        }
                    }
                    else
                    {
                        hr = SpHrFromLastWin32Error();
                    }
                }
            }
            
            if(FAILED(hr))
            {
                dstrFileName.Clear();
            }
            
        }
    }
    else
    {
        CSpDynamicString dstrFileAndPath;
        dstrFileAndPath.Append2(pszPath, pszFileNameSpecifier);
        if(dstrFileAndPath.m_psz == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            // Create file if it doesn't already exist
            HANDLE hFile = g_Unicode.CreateFile(dstrFileAndPath, GENERIC_WRITE, 0, NULL, CREATE_NEW, 
                FILE_ATTRIBUTE_NORMAL, NULL);
            if(hFile != INVALID_HANDLE_VALUE)
            {
                // Successfully created empty new file, so close and return
                if(!CloseHandle(hFile))
                {
                    hr = SpHrFromLastWin32Error();
                }
            }
            // Otherwise we just leave things as they are
        }

        dstrFileName = pszFileNameSpecifier;
        if(dstrFileName.m_psz == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

/****************************************************************************
* CSpObjectToken::CreatePath *
*----------------------------*
*   Description:
*       Creates all non-existant directories in pszPath. Assumes all
*       directories prior to ulCreateFrom string offset already exist.
*        
*   Returns:
*   S_OK on success
*   FAILED(hr) otherwise
********************************************************************* DAVEWOOD ***/
HRESULT CSpObjectToken::CreatePath(const WCHAR *pszPath, ULONG ulCreateFrom)
{
    HRESULT hr = S_OK;

    CSpDynamicString dstrIncrementalPath;

    //if \\ skip \\ find next '\'
    if(ulCreateFrom == 0 && wcslen(pszPath) >= 2 && wcsncmp(pszPath, L"\\\\", 2) == 0)
    {
        while(pszPath[ulCreateFrom] == L'\\')
        {
            ulCreateFrom++;
        }
        const WCHAR *psz = wcschr(pszPath + ulCreateFrom, L'\\');
        if(!psz)
        {
            hr = E_INVALIDARG;
        }
        ulCreateFrom = (ULONG)(psz - pszPath + 1);
    }
    
    // Skip any '\' (also at start to cope with \\machine network paths
    while(pszPath[ulCreateFrom] == L'\\')
    {
        ulCreateFrom++;
    }

    // Copy over existing directories
    dstrIncrementalPath.Append(pszPath, ulCreateFrom);

    const WCHAR *pszStart = pszPath + ulCreateFrom;
    for(pszPath = pszStart; *pszPath != L'\0'; pszPath++)
    {
        // Scan thought path. Each time reach a '\', copy section and try and create directory
        if(*pszPath == L'\\')
        {
            // Copy last section and trailing slash
            dstrIncrementalPath.Append(pszStart, (ULONG)(pszPath - pszStart + 1));
            pszStart = pszPath +1; // pszStart points to first char of next section
            // See if directory already exists
            if(g_Unicode.GetFileAttributes(dstrIncrementalPath) == 0xFFFFFFFF)
            {
                // If not create new directory
                if(!g_Unicode.CreateDirectory(dstrIncrementalPath, NULL))
                {
                    hr = SpHrFromLastWin32Error();
                    break;
                }
            }
        }
    }

    // Repeat for final section if necessary
    if(SUCCEEDED(hr) && pszPath > pszStart)
    {
        dstrIncrementalPath.Append(pszStart, (ULONG)(pszPath - pszStart));
        if(g_Unicode.GetFileAttributes(dstrIncrementalPath) == 0xFFFFFFFF)
        {
            if(!g_Unicode.CreateDirectory(dstrIncrementalPath, NULL))
            {
                hr = SpHrFromLastWin32Error();
            }
        }
    }

    return hr;
}


/****************************************************************************
* CSpObjectToken::FileSpecifierToRegPath *
*----------------------------------------*
*   Description:
*       Given the file specifier string and nFolder value, convert to a reg key and file path.
*        
*   Returns:
*   S_OK on success
*   FAILED(hr) otherwise
********************************************************************* DAVEWOOD ***/
HRESULT CSpObjectToken::FileSpecifierToRegPath(const WCHAR *pszFileNameSpecifier, ULONG nFolder, CSpDynamicString &dstrFilePath, CSpDynamicString &dstrRegPath)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    const WCHAR *pszBaseFile;

    // Make sure return strings are empty
    dstrFilePath.Clear();
    dstrRegPath.Clear();

    if(SUCCEEDED(hr))
    {
        // Is it a "X:\" path or a "\\" path
        if(pszFileNameSpecifier && wcslen(pszFileNameSpecifier) >= 3 &&
        (wcsncmp(pszFileNameSpecifier + 1, L":\\", 2) == 0 || wcsncmp(pszFileNameSpecifier, L"\\\\", 2) == 0))
        {
            if(nFolder != CSIDL_FLAG_CREATE)
            {
                // Must not set any other flags
                hr = E_INVALIDARG;
            }

            if(SUCCEEDED(hr))
            {
                // Find last '\' that separates path from base file
                pszBaseFile = wcsrchr(pszFileNameSpecifier, L'\\');
                pszBaseFile++;

                // dstrFilePath holds the path with trailing '\'
                dstrFilePath.Append(pszFileNameSpecifier, (ULONG)(pszBaseFile - pszFileNameSpecifier));
                if (dstrFilePath.Length() > 0)
                {
                    hr = CreatePath(dstrFilePath, 0);
                }
            }

            if(SUCCEEDED(hr))
            {
                // Calculate the new filename
                CSpDynamicString dstrFileName;
                hr = GenerateFileName(dstrFilePath, pszBaseFile, dstrFileName);
                if(SUCCEEDED(hr))
                {
                    // Add fileName to path and copy to reg key
                    dstrFilePath.Append(dstrFileName);
                    dstrRegPath = dstrFilePath;
                }
            }
        }
    
        // It's a relative path
        else
        {
            if(nFolder == CSIDL_FLAG_CREATE)
            {
                // Must have set some other folder flags
                hr = E_INVALIDARG;
            }

            WCHAR szPath[MAX_PATH];
            if(SUCCEEDED(hr))
            {
#ifdef _WIN32_WCE
                _tcscpy(szPath, L"Windows");
                hr = S_OK;
#else
                hr = ::SHGetFolderPathW(NULL, nFolder, NULL, 0, szPath);
#endif
            }

            ULONG ulCreateDirsFrom;
            if(SUCCEEDED(hr))
            {
                // dstrFilePath holds the special folder path no trailing '\'
                dstrFilePath = szPath;
                if(dstrFilePath.m_psz == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                if(SUCCEEDED(hr))
                {
                    // all of special folder path must exist
                    ulCreateDirsFrom = dstrFilePath.Length();

                    // add the path that points to the speech directory
                    dstrFilePath.Append(pszFileStoragePath);
                    if(dstrFilePath.m_psz == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }

            if(SUCCEEDED(hr))
            {
                // Make the %...% folder identifier
                WCHAR pszFolder[MAX_PATH];
#ifndef _WIN32_WCE
                wcscpy(pszFolder, L"%");
                // convert the nFolder number - removing the create flag
                _ultow(nFolder - CSIDL_FLAG_CREATE, pszFolder + wcslen(pszFolder), 16);
                wcscat(pszFolder, L"%");
#endif

                // Add the %...% and path into reg data.
                dstrRegPath.Append2(pszFolder, pszFileStoragePath);
                if(dstrRegPath.m_psz == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }

                // both dstrRegPath and dstrFilePath have trailing '\'
            }

            // Now add any fileNameSpecifier directories
            if(SUCCEEDED(hr))
            {
                if(pszFileNameSpecifier == NULL || 
                    wcslen(pszFileNameSpecifier) == 0)
                {
                    pszBaseFile = NULL;
                }
                else
                {
                    pszBaseFile = wcsrchr(pszFileNameSpecifier, L'\\');
                    if(pszBaseFile)
                    {
                        // Specifier contains '\'
                        pszBaseFile++; // part after last '\' becomes base file

                        const WCHAR *pszPath;
                        pszPath = pszFileNameSpecifier; // part before '\' is path

                        if(pszPath[0] == L'\\')
                        {
                            pszPath++; // Skip initial '\'
                        }

                        // Add file specifier path to file and key
                        dstrRegPath.Append(pszPath, (ULONG)(pszBaseFile - pszPath));
                        dstrFilePath.Append(pszPath, (ULONG)(pszBaseFile - pszPath));
                    }
                    else
                    {
                        // no '\' - base file only
                        pszBaseFile = pszFileNameSpecifier;
                    }
                }

                // Create any new directories
                hr = CreatePath(dstrFilePath, ulCreateDirsFrom);

                if(SUCCEEDED(hr))
                {
                    // Generate the actual file name
                    CSpDynamicString dstrFileName;
                    hr = GenerateFileName(dstrFilePath, pszBaseFile, dstrFileName);
                    if(SUCCEEDED(hr))
                    {
                        // Add file name to path and reg key
                        dstrRegPath.Append(dstrFileName);
                        dstrFilePath.Append(dstrFileName);
                    }
                }
            }
        }
    }

    return hr;
}

/****************************************************************************
* CSpObjectToken::RegPathToFilePath *
*-----------------------------------*
*   Description:
*       Given a file storage value from the registry, convert to a file path.
*       This will extract the %...% value and finds the local special folder path.
*        
*   Returns:
*   S_OK on success
*   FAILED(hr) otherwise
**************************************************************** DAVEWOOD ***/
HRESULT CSpObjectToken::RegPathToFilePath(const WCHAR *pszRegPath, CSpDynamicString &dstrFilePath)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    // Is this a reference to a special folder 
    if(pszRegPath[0] == L'%')
    {
        // Find the second % symbol
        WCHAR *psz = wcsrchr(pszRegPath, L'%');
        ULONG nFolder;
        if(!psz)
        {
            hr = E_INVALIDARG;
        }
        if(SUCCEEDED(hr))
        {
            // Convert the string between the %s to a number
            nFolder = wcstoul(&pszRegPath[1], &psz, 16);
            if(psz == &pszRegPath[1])
            {
                hr = E_INVALIDARG;
            }

            psz++; // Point to start of real path '\'
            if(*psz != L'\\')
            {
                hr = E_INVALIDARG;
            }
        }

        WCHAR szPath[MAX_PATH];
        if(SUCCEEDED(hr))
        {

#ifdef _WIN32_WCE
            _tcscpy(szPath, L"");
#else
            hr = ::SHGetFolderPathW(NULL, nFolder, NULL, 0, szPath);
#endif
        }

        if(SUCCEEDED(hr))
        {
            // filePath now has the special folder path (with no trailing '\')
            dstrFilePath = szPath;
            if(dstrFilePath.m_psz == NULL)
            {
                hr = E_OUTOFMEMORY;
            }

            // Append the rest of the path
            dstrFilePath.Append(psz);
            if(dstrFilePath.m_psz == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        // Not a special folder so just copy
        dstrFilePath = pszRegPath;
        if(dstrFilePath.m_psz == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/****************************************************************************
* CSpObjectToken::GetStorageFileName *
*------------------------------------*
*   Description:
*       Get a filename which can be manipulated by this token. Storage files will
*       be deleted on a Remove call.
*       clsidCaller - a key will be made in registry below the token with this name and files key beneath that.
*       pszValueName - Value name which will be made in registry to store the file path string.
*       pszFileNameSpecifier - either NULL or a path/filename for storage file:
*           - if this starts with 'X:\' or '\\' then is assumed to be a full path.
*           - otherwise is assumed to be relative to special folders given in the nFolder parameter.
*           - if ends with a '\', or is NULL a unique filename will be created.
*           - if the name contains a %d the %d is replaced by a number to give a unique filename.
*           - intermediate directories are created.
*           - if a relative file is being used the value stored in the registry includes 
*               the nFolder value as %nFolder% before the rest of the path. This allows
*               roaming to work properly if you pick an nFolder value representing a raoming folder
*       nFolder - equivalent to the value given to SHGetFolderPath in the Shell API.
*       ppszFilePath - CoTaskMemAlloc'd returned file path.
*   Returns:
*   S_OK on success
*   S_FALSE indicates that a new file was created
*   SPERR_UNINITIALIZED if the token isn't initialized
*   FAILED(hr) otherwise
********************************************************************* RAL ***/
HRESULT CSpObjectToken::GetStorageFileName(
    REFCLSID clsidCaller,
    const WCHAR *pszValueName,
    const WCHAR *pszFileNameSpecifier,
    ULONG nFolder,
    WCHAR ** ppszFilePath)
{
    SPDBG_FUNC("CSpObjectToken::GetStorageFileName");
    HRESULT hr = S_OK;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_cpDataKey == NULL && m_cpTokenDelegate == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_STRING_PTR(pszValueName))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszFileNameSpecifier))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppszFilePath))
    {
        hr = E_POINTER;
    }
    else if (m_cpTokenDelegate != NULL)
    {
        hr = m_cpTokenDelegate->GetStorageFileName(
                    clsidCaller,
                    pszValueName,
                    pszFileNameSpecifier,
                    nFolder,
                    ppszFilePath);
    }
    else
    {
        // See if there is already a Files key in the registry for this token
        CComPtr<ISpDataKey> cpFilesKey;
        hr = OpenFilesKey(clsidCaller, (nFolder & CSIDL_FLAG_CREATE), &cpFilesKey);

        if (SUCCEEDED(hr))
        {
            CSpDynamicString dstrFilePath;  // Path to the file which we return to user.
            CSpDynamicString dstrRegPath;   // Path to the string which will be stored in the registry.

            // See if the key we are looking for is present
            hr = cpFilesKey->GetStringValue(pszValueName, &dstrRegPath);
#ifdef _WIN32_WCE
            if (hr == SPERR_NOT_FOUND && nFolder)
#else
            if (hr == SPERR_NOT_FOUND && (nFolder & CSIDL_FLAG_CREATE))
#endif //_WIN32_WCE
            {
                // Didn't find the key and want to create
                
                // Calculate the new file path and key value
                hr = FileSpecifierToRegPath(pszFileNameSpecifier, nFolder, dstrFilePath, dstrRegPath);
                if(SUCCEEDED(hr))
                {
                    // Set the key value
                    hr = cpFilesKey->SetStringValue(pszValueName, dstrRegPath);
                    if (SUCCEEDED(hr))
                    {                        
                        *ppszFilePath = dstrFilePath.Detach();
                        hr = S_FALSE;
                    }
                }
            }
            else if (SUCCEEDED(hr))
            {
                // Found existing entry so convert and return
                hr = RegPathToFilePath(dstrRegPath, dstrFilePath);
                if(SUCCEEDED(hr))
                {
                    *ppszFilePath = dstrFilePath.Detach();
                }
            }
        }
    }


    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/****************************************************************************
* CSpObjectToken::RemoveStorageFileName *
*---------------------------------------*
*   Description:  
*       Remove the specified storage file name and optionally delete the file
*
*   Return:
*   S_OK on success
*   SPERR_UNINITIALIZED if the token isn't init
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectToken::RemoveStorageFileName(
    REFCLSID clsidCaller, 
    const WCHAR *pszValueName,
    BOOL fDeleteFile)
{
    SPDBG_FUNC("CSpObjectToken::RemoveStorageFileName");
    HRESULT hr = S_OK;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_cpDataKey == NULL && m_cpTokenDelegate == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_STRING_PTR(pszValueName))
    {
        hr = E_INVALIDARG;
    }
    else if (m_cpTokenDelegate != NULL)
    {
        hr = m_cpTokenDelegate->RemoveStorageFileName(
                    clsidCaller, 
                    pszValueName,
                    fDeleteFile);
    }    
    else
    {
        CComPtr<ISpDataKey> cpDataKey;
        hr = OpenFilesKey(clsidCaller, FALSE, &cpDataKey);
        if (SUCCEEDED(hr) && fDeleteFile)
        {
            hr = DeleteFileFromKey(cpDataKey, pszValueName);
        }
        if (SUCCEEDED(hr))
        {
            hr = cpDataKey->DeleteValue(pszValueName);
        }
    }
    return hr;
}

/****************************************************************************
* CSpObjectToken::Remove *
*------------------------*
*   Description:  
*       Remove either a specified caller's section of the token, or the
*       entire token. We remove the entire token if pclsidCaller == NULL.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::Remove(const CLSID * pclsidCaller)
{
    SPDBG_FUNC("CSpObjectToken::Remove");
    HRESULT hr = S_OK;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_dstrTokenId == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_OPTIONAL_READ_PTR(pclsidCaller))
    {
        hr = E_POINTER;
    }
    else if (m_cpTokenDelegate != NULL)
    {
        hr = m_cpTokenDelegate->Remove(pclsidCaller);
    }
    else
    {
        if(pclsidCaller == NULL) // Only engage the lock if removing the complete token
        {
            hr = EngageRemovalLock();
        }

        if(SUCCEEDED(hr))
        {
            // Remove all the filenames
            hr = RemoveAllStorageFileNames(pclsidCaller);

            // Now go ahead and delete the registry entry which is either
            // the token itself (if pclsidCaller == NULL) or the clsid's
            // sub key
            if (SUCCEEDED(hr))
            {
                if (pclsidCaller == NULL)
                {
                    hr = SpDeleteRegPath(m_dstrTokenId, NULL);
                }
                else
                {
                    WCHAR szClsid[MAX_PATH];
                    hr = StringFromGUID2(*pclsidCaller, szClsid, sp_countof(szClsid));
                    if (SUCCEEDED(hr))
                    {
                        hr = SpDeleteRegPath(m_dstrTokenId, szClsid);
                    }
                }
            }

            if(pclsidCaller == NULL) // Only engage the lock if removing the complete token
            {
                HRESULT hr2 = ReleaseRemovalLock();
                if(SUCCEEDED(hr))
                {
                    hr = hr2; // Don't overwrite earlier failure code
                }
            }
        }
    }
    
    if(SUCCEEDED(hr) && pclsidCaller == NULL)
    {
        m_cpDataKey.Release();
        m_fKeyDeleted = TRUE;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::IsUISupported *
*-------------------------------*
*   Description:  
*       Determine if the specific type of UI is supported or not
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::IsUISupported(const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData, IUnknown * punkObject, BOOL *pfSupported)
{
    SPDBG_FUNC("CSpObjectToken::IsUISupported");
    HRESULT hr = S_OK;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_cpDataKey == NULL && m_cpTokenDelegate == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_STRING_PTR(pszTypeOfUI) ||
             (pvExtraData != NULL && SPIsBadReadPtr(pvExtraData, cbExtraData)) ||
             (punkObject != NULL && SP_IS_BAD_INTERFACE_PTR(punkObject)) ||
             SP_IS_BAD_WRITE_PTR(pfSupported))
    {
        hr = E_INVALIDARG;
    }
    else if (m_cpTokenDelegate != NULL)
    {
        // NTRAID#SPEECH-7392-2000/08/31-robch: Maybe we should first delegate, and if that doesn't work, 
        // try this token's category ui...
        hr = m_cpTokenDelegate->IsUISupported(
                    pszTypeOfUI, 
                    pvExtraData, 
                    cbExtraData, 
                    punkObject, 
                    pfSupported);
    }
    else
    {
        CLSID clsidObject;
        BOOL fSupported = FALSE;

        if (SUCCEEDED(GetUIObjectClsid(pszTypeOfUI, &clsidObject)))
        {
            CComPtr<ISpTokenUI> cpTokenUI;
            hr = cpTokenUI.CoCreateInstance(clsidObject);
            if (SUCCEEDED(hr))
            {
                hr = cpTokenUI->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, punkObject, &fSupported);
            }
        }
        
        if (SUCCEEDED(hr))
        {
            *pfSupported = fSupported;
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);   
    return hr;
}

/****************************************************************************
* CSpObjectToken::DisplayUI *
*---------------------------*
*   Description:  
*       Display the specified type of UI
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::DisplayUI(
    HWND hwndParent, 
    const WCHAR * pszTitle, 
    const WCHAR * pszTypeOfUI, 
    void * pvExtraData, 
    ULONG cbExtraData, 
    IUnknown * punkObject)
{
    SPDBG_FUNC("CSpObjectToken::DisplayUI");
    HRESULT hr;
    CLSID clsidObject;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_cpDataKey == NULL && m_cpTokenDelegate == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (!IsWindow(hwndParent) || 
             SP_IS_BAD_OPTIONAL_STRING_PTR(pszTitle) || 
             SP_IS_BAD_STRING_PTR(pszTypeOfUI) ||
             (pvExtraData != NULL && SPIsBadReadPtr(pvExtraData, cbExtraData)) ||
             (punkObject != NULL && SP_IS_BAD_INTERFACE_PTR(punkObject)))
    {
        hr = E_INVALIDARG;
    }
    else if (m_cpTokenDelegate != NULL)
    {
        // NTRAID#SPEECH-7392-2000/08/31-robch: Maybe we should first delegate, and if that doesn't work, 
        // try this token's category ui...
        hr = m_cpTokenDelegate->DisplayUI(
                    hwndParent, 
                    pszTitle, 
                    pszTypeOfUI, 
                    pvExtraData, 
                    cbExtraData, 
                    punkObject);
    }
    else
    {
        hr = GetUIObjectClsid(pszTypeOfUI, &clsidObject);

        CComPtr<ISpTokenUI> cpTokenUI;
        if (SUCCEEDED(hr))
        {
            hr = cpTokenUI.CoCreateInstance(clsidObject);
        }

        if (SUCCEEDED(hr))
        {
            hr = cpTokenUI->DisplayUI(
                                hwndParent, 
                                pszTitle, 
                                pszTypeOfUI, 
                                pvExtraData, 
                                cbExtraData, 
                                this, 
                                punkObject);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);   
    return hr;
}

/****************************************************************************
* CSpObjectToken::InitFromDataKey *
*---------------------------------*
*   Description:  
*       Initialize this token to use a specified datakey. Dynamic Token
*       Enumerators might use this to create tokens under their token
*       enumerator's token. They'll then be able to just CreateKey from
*       their data key, create a new object token, and call this method.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::InitFromDataKey(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszTokenId, 
    ISpDataKey * pDataKey)
{
    SPDBG_FUNC("CSpObjectToken::InitFromDataKey");
    HRESULT hr = S_OK;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_dstrTokenId != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszCategoryId) ||
             SP_IS_BAD_STRING_PTR(pszTokenId) ||
             SP_IS_BAD_INTERFACE_PTR(pDataKey))
    {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr))
    {
        hr = EngageUseLock(pszTokenId);
    }

    if (SUCCEEDED(hr))
    {
        m_dstrCategoryId = pszCategoryId;
        m_dstrTokenId = pszTokenId;
        m_cpDataKey = pDataKey;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpObjectToken::SetData *
*-------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::SetData(
    const WCHAR * pszValueName, 
    ULONG cbData, 
    const BYTE * pData)
{
    SPDBG_FUNC("CSpObjectToken::SetData");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->SetData(pszValueName, cbData, pData)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->SetData(pszValueName, cbData, pData)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::GetData *
*-------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::GetData(
    const WCHAR * pszValueName, 
    ULONG * pcbData, 
    BYTE * pData)
{
    SPDBG_FUNC("CSpObjectToken::GetData");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->GetData(pszValueName, pcbData, pData)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->GetData(pszValueName, pcbData, pData)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::SetStringValue *
*--------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::SetStringValue(
    const WCHAR * pszValueName, 
    const WCHAR * pszValue)
{
    SPDBG_FUNC("CSpObjectToken::SetStringValue");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->SetStringValue(pszValueName, pszValue)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->SetStringValue(pszValueName, pszValue)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::GetStringValue *
*--------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::GetStringValue(
    const WCHAR * pszValueName, 
    WCHAR ** ppValue)
{
    SPDBG_FUNC("CSpObjectToken::GetStringValue");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->GetStringValue(pszValueName, ppValue)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->GetStringValue(pszValueName, ppValue)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::SetDWORD *
*--------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::SetDWORD(const WCHAR * pszValueName, DWORD dwValue)
{
    SPDBG_FUNC("CSpObjectToken::SetDWORD");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->SetDWORD(pszValueName, dwValue)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->SetDWORD(pszValueName, dwValue)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::GetDWORD *
*--------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::GetDWORD(
    const WCHAR * pszValueName, 
    DWORD *pdwValue)
{
    SPDBG_FUNC("CSpObjectToken::GetDWORD");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->GetDWORD(pszValueName, pdwValue)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->GetDWORD(pszValueName, pdwValue)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;

}

/*****************************************************************************
* CSpObjectToken::OpenKey *
*-------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::OpenKey(
    const WCHAR * pszSubKeyName, 
    ISpDataKey ** ppKey)
{
    SPDBG_FUNC("CSpObjectToken::SetStringValue");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->OpenKey(pszSubKeyName, ppKey)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->OpenKey(pszSubKeyName, ppKey)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::CreateKey *
*---------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::CreateKey(
    const WCHAR * pszSubKeyName, 
    ISpDataKey ** ppKey)
{
    SPDBG_FUNC("CSpObjectToken::CreateKey");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->CreateKey(pszSubKeyName, ppKey)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->CreateKey(pszSubKeyName, ppKey)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::DeleteKey *
*---------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::DeleteKey(const WCHAR * pszSubKeyName)
{
    SPDBG_FUNC("CSpObjectToken:DeleteKey");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->DeleteKey(pszSubKeyName)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->DeleteKey(pszSubKeyName)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::DeleteValue *
*-----------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::DeleteValue(const WCHAR * pszValueName)
{   
    SPDBG_FUNC("CSpObjectToken::DeleteValue");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->DeleteValue(pszValueName)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->DeleteValue(pszValueName)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::EnumKeys *
*--------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::EnumKeys(ULONG Index, WCHAR ** ppszKeyName)
{
    SPDBG_FUNC("CSpObjectToken::EnumKeys");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->EnumKeys(Index, ppszKeyName)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->EnumKeys(Index, ppszKeyName)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectToken::EnumValues *
*----------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK
*   E_OUTOFMEMORY
******************************************************************* robch ***/
STDMETHODIMP CSpObjectToken::EnumValues(ULONG Index, WCHAR ** ppszValueName)
{
    SPDBG_FUNC("CSpObjectToken::EnumValues");

    return m_cpTokenDelegate != NULL
                ? m_cpTokenDelegate->EnumValues(Index, ppszValueName)
                : m_cpDataKey != NULL
                    ? m_cpDataKey->EnumValues(Index, ppszValueName)
                    : m_fKeyDeleted
                        ? SPERR_TOKEN_DELETED
                        : SPERR_UNINITIALIZED;
}

/****************************************************************************
* CSpObjectToken::ParseTokenId *
*------------------------------*
*   Description:  
*       Parse a token id into it's parts. For example:
*
*           pszCategoryId   = HKEY...\Recognizers
*           pszTokenId      = HKEY...\Recognizers\Tokens\MSASR English
*
*           *ppszCategoryId     = HKEY...\Recognizers
*           *ppszTokenId        = HKEY...\Recognizers\Tokens\MSASR English
*           *ppszTokenIdForEnum = NULL
*           *ppszTokenEnumExtra = NULL
*
*       or
*
*           pszCategoryId = HKEY...\AudioIn
*           pszTokenId =    HKEY...\AudioIn\TokenEnums\DSound
*
*           *ppszCategoryId     = HKEY...\AudioIn
*           *ppszTokenId        = HKEY...\AudioIn\TokenEnums\DSound
*           *ppszTokenIdForEnum = HKEY...\AudioIn\TokenEnums\DSound
*           *ppszTokenEnumExtra = NULL
*
*       or
*
*           pszCategoryId = HKEY...\AudioIn
*           pszTokenId =    HKEY...\AudioIn\TokenEnums\DSound\CrystalWave
*
*           *ppszCategoryId     = HKEY...\AudioIn
*           *ppszTokenId        = HKEY...\AudioIn\TokenEnums\DSound\CrystalWave
*           *ppszTokenIdForEnum = HKEY...\AudioIn\TokenEnums\DSound
*           *ppszTokenEnumExtra = CrystalWave
*       
*       pszCategoryId can be NULL. If it is, we'll calculate the category id
*       by finding the first occurrence of either "Tokens" or "TokenEnums"
*       The category id will immediately proceed that.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectToken::ParseTokenId(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenId,
    WCHAR ** ppszCategoryId,
    WCHAR ** ppszTokenIdForEnum,
    WCHAR ** ppszTokenEnumExtra)
{
    SPDBG_FUNC("CSpObjectToken::ParseTokenId");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_cpDataKey == NULL);
    SPDBG_ASSERT(m_cpTokenDelegate == NULL);
    SPDBG_ASSERT(m_dstrTokenId == NULL);
    SPDBG_ASSERT(m_dstrCategoryId == NULL);

    // If the caller supplied a category, we already know how big it is
    int cchCategoryId = 0;
    if (pszCategoryId != NULL)
    {
        cchCategoryId = wcslen(pszCategoryId);
        if (wcsnicmp(pszTokenId, pszCategoryId, cchCategoryId) != 0)
        {
            // The tokenid wasn't prefaced with the category id, a must
            hr = SPERR_INVALID_TOKEN_ID;
        }
    }

    const WCHAR * pszSlashTokensSlash = L"\\Tokens\\";
    const int cchSlashTokensSlash = wcslen(pszSlashTokensSlash);
    const WCHAR * pszSlashTokenEnumsSlash = L"\\TokenEnums\\";
    const int cchSlashTokenEnumsSlash = wcslen(pszSlashTokenEnumsSlash);

    int cchTokenId = 0;
    int cchTokenIdForEnum = 0;
    int cchTokenEnumExtraStart = 0;
    int cchTokenEnumExtra = 0;
    if (SUCCEEDED(hr))
    {
        const WCHAR * pszSearch = pszTokenId + cchCategoryId;
        while (*pszSearch)
        {
            if (wcsnicmp(pszSearch, pszSlashTokensSlash, cchSlashTokensSlash) == 0)
            {
                SPDBG_ASSERT(cchCategoryId == 0 ||
                             pszSearch - pszTokenId == cchCategoryId);
                cchCategoryId = (int)(pszSearch - pszTokenId);
                cchTokenId = wcslen(pszTokenId);

                pszSearch += cchSlashTokensSlash;
                if (wcschr(pszSearch, L'\\') != NULL)
                {
                    hr = SPERR_INVALID_TOKEN_ID;
                }
                break;
            }
            else if (wcsnicmp(pszSearch, pszSlashTokenEnumsSlash, cchSlashTokenEnumsSlash) == 0)
            {
                SPDBG_ASSERT(cchCategoryId == 0 ||
                             pszSearch - pszTokenId == cchCategoryId);
                cchCategoryId = (int)(pszSearch - pszTokenId);

                pszSearch += cchSlashTokenEnumsSlash;
                WCHAR * pszEnumNameTrailingSlash = wcschr(pszSearch, L'\\');
                if (pszEnumNameTrailingSlash == NULL)
                {
                    cchTokenId = wcslen(pszTokenId);
                }
                else
                {
                    cchTokenId = wcslen(pszTokenId);
                    cchTokenIdForEnum = (int)(pszEnumNameTrailingSlash - pszTokenId);
                    cchTokenEnumExtraStart = cchTokenIdForEnum + 1;
                    cchTokenEnumExtra = wcslen(pszEnumNameTrailingSlash) - 1;
                }
                break;
            }
            else if (cchCategoryId > 0)
            {
                break;
            }
            else
            {
                pszSearch++;
            }
        }

        if (cchTokenId == 0)
        {
            cchTokenId = wcslen(pszTokenId);
        }

        if (cchCategoryId == 0)
        {
            const WCHAR * psz = wcsrchr(pszTokenId, L'\\');
            if (psz == NULL)
            {
                hr = SPERR_NOT_FOUND;
            }
            else
            {
                cchCategoryId = (int)(psz - pszTokenId);
            }                
        }
        
        CSpDynamicString dstr;
        if (cchCategoryId > 0)
        {
            dstr = pszTokenId;
            dstr.TrimToSize(cchCategoryId);
            *ppszCategoryId = dstr.Detach();
        }
        else
        {
            *ppszCategoryId = NULL;
        }

        if (cchTokenIdForEnum > 0)
        {
            dstr = pszTokenId;
            dstr.TrimToSize(cchTokenIdForEnum);
            *ppszTokenIdForEnum = dstr.Detach();
        }
        else
        {
            *ppszTokenIdForEnum = NULL;
        }

        if (cchTokenEnumExtra > 0)
        {
            dstr = pszTokenId + cchTokenEnumExtraStart;
            dstr.TrimToSize(cchTokenEnumExtra);
            *ppszTokenEnumExtra = dstr.Detach();
        }
        else
        {
            *ppszTokenEnumExtra = NULL;
        }
    }
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::InitToken *
*---------------------------*
*   Description:  
*       Initialize the token for the specified static token. For example:
*
*           pszCategoryId = HKEY...\Recognizers
*           pszTokenId    = HKEY...\Recognizer\Tokens\MSASR English
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectToken::InitToken(const WCHAR * pszCategoryId, const WCHAR * pszTokenId, BOOL fCreateIfNotExist)
{
    SPDBG_FUNC("CSpObjectToken::InitToken");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_cpDataKey == NULL);
    SPDBG_ASSERT(m_cpTokenDelegate == NULL);
    SPDBG_ASSERT(m_dstrTokenId == NULL);
    SPDBG_ASSERT(m_dstrCategoryId == NULL);

    hr = EngageUseLock(pszTokenId);

    // Convert the token id into a datakey
    if(SUCCEEDED(hr))
    {
        hr = SpSzRegPathToDataKey(NULL, pszTokenId, fCreateIfNotExist, &m_cpDataKey);

        // If we got the data key, assign the category and token id
        if (SUCCEEDED(hr))
        {
            SPDBG_ASSERT(m_cpDataKey != NULL);
            m_dstrCategoryId = pszCategoryId;
            m_dstrTokenId = pszTokenId;
        }
        else // make sure returned to uninitialized state
        {
            ReleaseUseLock();
        }
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/****************************************************************************
* CSpObjectToken::InitFromTokenEnum *
*-----------------------------------*
*   Description:  
*       Init this token to delegate to a token from the token enumerator
*       specified. For example, to create the default token for an
*       enumerator:
*
*           pszCategoryId     = HKEY...\AudioIn
*           pszTokenId        = HKEY...\AudioIn\DSound
*           pszTokenIdForEnum = HKEY...\AudioIn\DSound
*           pszTokenEnumExtra = NULL
*
*        or to create a specific token from an enumerator
*
*           pszCategoryId     = HKEY...\AudioIn
*           pszTokenId        = HKEY...\AudioIn\DSound\CrystalWave
*           pszTokenIdForEnum = HKEY...\AudioIn\DSound
*           pszTokenEnumExtra = CrystalWave
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectToken::InitFromTokenEnum(const WCHAR * pszCategoryId, const WCHAR * pszTokenId, const WCHAR * pszTokenIdForEnum, const WCHAR * pszTokenEnumExtra)
{
    SPDBG_FUNC("CSpObjectToken::InitFromTokenEnum");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(pszCategoryId != NULL);
    SPDBG_ASSERT(pszTokenId != NULL);
    SPDBG_ASSERT(pszTokenIdForEnum != NULL);

    SPDBG_ASSERT(m_cpDataKey == NULL);
    SPDBG_ASSERT(m_cpTokenDelegate == NULL);
    SPDBG_ASSERT(m_dstrTokenId == NULL);
    SPDBG_ASSERT(m_dstrCategoryId == NULL);

    // First we have to create the token enumerator
    CComPtr<ISpDataKey> cpDataKeyForEnum;
    hr = SpSzRegPathToDataKey(NULL, pszTokenIdForEnum, FALSE, &cpDataKeyForEnum);

    CComPtr<ISpObjectTokenInit> cpTokenForEnumInit;
    if (SUCCEEDED(hr))
    {
        hr = cpTokenForEnumInit.CoCreateInstance(CLSID_SpObjectToken);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpTokenForEnumInit->InitFromDataKey(pszCategoryId, pszTokenIdForEnum, cpDataKeyForEnum);
    }

    CComPtr<IEnumSpObjectTokens> cpEnum;
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpTokenForEnumInit, &cpEnum);
    }

    // Now we need to enumerate each of the enum's tokens, and look for
    // a match
    CComPtr<ISpObjectToken> cpToken;
    CSpDynamicString dstrTokenId;
    while (SUCCEEDED(hr))
    {
        // Get the next token
        hr = cpEnum->Next(1, &cpToken, NULL);
        if (hr == S_FALSE || FAILED(hr))
        {
            break;
        }

        // Get the token's id
        dstrTokenId.Clear();
        hr = cpToken->GetId(&dstrTokenId);

        // If the caller didn't want a specific token from the enum,
        // just give them the fist token we find...
        if (pszTokenEnumExtra == NULL)
        {
            break;
        }

        // If that token's id is a match for what the caller wanted,
        // we're done
        if (SUCCEEDED(hr) &&
           wcsicmp(dstrTokenId, pszTokenId) == 0)
        {
            break;
        }

        // This token wasn't it ...
        cpToken.Release();
    }
    
    // If we couldn't find it
    if (SUCCEEDED(hr) && cpToken == NULL)
    {
        hr = SPERR_NOT_FOUND;
    }

    // We found it, set it up
    if (SUCCEEDED(hr))
    {
        m_dstrTokenId = dstrTokenId;
        m_dstrCategoryId = pszCategoryId;
        m_cpTokenDelegate = cpToken;
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/****************************************************************************
* CSpObjectToken::OpenFilesKey *
*------------------------------*
*   Description:  
*       Open the "Files" subkey of a specified data key's caller's sub key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectToken::OpenFilesKey(REFCLSID clsidCaller, BOOL fCreateKey, ISpDataKey ** ppKey)
{
    SPDBG_FUNC("CSpObjectToken::OpenFilesKey");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_cpDataKey != NULL);
    SPDBG_ASSERT(m_cpTokenDelegate == NULL);

    *ppKey = NULL;

    CComPtr<ISpDataKey> cpClsidKey;
    CSpDynamicString dstrCLSID;

    // Convert the string clsid to a real clsid
    hr = ::StringFromCLSID(clsidCaller, &dstrCLSID);
    if (SUCCEEDED(hr))
    {
        // Either create the data key or open it
        hr = fCreateKey ? 
            CreateKey(dstrCLSID, &cpClsidKey) :
            OpenKey(dstrCLSID, &cpClsidKey);
    }

    if (SUCCEEDED(hr))
    {
        // Either crate the files data key or open it
        hr = fCreateKey ?
            cpClsidKey->CreateKey(SPTOKENKEY_FILES, ppKey) :
            cpClsidKey->OpenKey(SPTOKENKEY_FILES, ppKey);
    }

    return hr;
}

/****************************************************************************
* CSpObjectToken::DeleteFileFromKey *
*-----------------------------------*
*   Description:  
*       Delete either a specific file (specified by pszValueName) or all files
*       (when pszValueName == NULL) from the specified data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectToken::DeleteFileFromKey(ISpDataKey * pDataKey, const WCHAR * pszValueName)
{
    SPDBG_FUNC("CSpObjectToken::DeleteFileFromKey");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_cpDataKey != NULL);
    SPDBG_ASSERT(m_cpTokenDelegate == NULL);

    // If the value name wasn't specified, we'll delete all the value's files
    if (pszValueName == NULL)
    {
        // Loop thru the values
        for (int i = 0; SUCCEEDED(hr); i++)
        {
            // Get the next value
            CSpDynamicString dstrValueName;
            hr = pDataKey->EnumValues(i, &dstrValueName);
            if (hr == SPERR_NO_MORE_ITEMS)
            {
                hr = S_OK;
                break;
            }

            // Delete the file
            if (SUCCEEDED(hr))
            {
                hr = DeleteFileFromKey(pDataKey, dstrValueName);
            }
        }
    }
    else
    {
        // Get the filename
        CSpDynamicString dstrFileName, dstrRegPath;
        hr = pDataKey->GetStringValue(pszValueName, &dstrRegPath);
        
        // Convert the path stored in the registry to a real file path
        if (SUCCEEDED(hr))
        {
            hr = RegPathToFilePath(dstrRegPath, dstrFileName) ;
        }

        // And delete the file
        if (SUCCEEDED(hr))
        {
            // Ignore errors from DeleteFile, we can't let this stop us
            g_Unicode.DeleteFile(dstrFileName);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::RemoveAllStorageFileNames *
*-------------------------------------------*
*   Description:  
*       Remove all filenames for a specified caller, or for all callers
*       if pclsidCaller is NULL.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectToken::RemoveAllStorageFileNames(const CLSID * pclsidCaller)
{
    SPDBG_FUNC("CSpObjectToken::RemoveAllStorageFileNames");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_cpDataKey != NULL);
    SPDBG_ASSERT(m_cpTokenDelegate == NULL);

    // If the clsid wasn't specified, we'll delete all files from all
    // keys that are clsids
    if (pclsidCaller == NULL)
    {
        // Loop thru all the keys
        for (int i = 0; SUCCEEDED(hr); i++)
        {
            // Get the next sub key
            CSpDynamicString dstrSubKey;
            hr = EnumKeys((ULONG)i, (WCHAR **)&dstrSubKey);
            if (hr == SPERR_NO_MORE_ITEMS)
            {
                hr = S_OK;
                break;
            }

            // If this key looks like a clsid, and it is, recursively call
            // this function to delete the specific clsid's files
            CLSID clsid;
            if (SUCCEEDED(hr) && 
                dstrSubKey[0] == L'{' &&
                SUCCEEDED(::CLSIDFromString(dstrSubKey, &clsid)))
            {
                hr = RemoveAllStorageFileNames(&clsid);
            }
        }
    }
    else
    {
        // Open the files data key, and delete all the files
        CComPtr<ISpDataKey> cpFilesKey;
        hr = OpenFilesKey(*pclsidCaller, FALSE, &cpFilesKey);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
        else if (SUCCEEDED(hr))
        {
            hr = DeleteFileFromKey(cpFilesKey, NULL);
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectToken::GetUIObjectClsid *
*------------------------------------*
*   Description:  
*       Get the UI object's clsid from the registry. First check under the
*       token's root, then under the category
*
*   Return:
*   TRUE if we could get the UI object's clsid
*   FALSE if we could not.
******************************************************************** robch */
HRESULT CSpObjectToken::GetUIObjectClsid(const WCHAR * pszTypeOfUI, CLSID *pclsid)
{
    SPDBG_FUNC("CSpObjectToken::GetUIObjectClsid");

    SPDBG_ASSERT(m_cpDataKey != NULL);
    SPDBG_ASSERT(m_cpTokenDelegate == NULL);

    // We'll try and retrive the CLSID as a string from the token ui registry
    // key, then from the category ui registry key. We'll convert to an actual
    // GUID at the end of the function
    CSpDynamicString dstrClsid;

    //--- Try getting the clsid from token's UI key
    CComPtr<ISpDataKey> cpTokenUI;
    HRESULT hr = OpenKey(SPTOKENKEY_UI, &cpTokenUI);
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpDataKey> cpType;
        hr = cpTokenUI->OpenKey(pszTypeOfUI, &cpType);
        if (SUCCEEDED(hr))
        {
            hr = cpType->GetStringValue(SPTOKENVALUE_CLSID, &dstrClsid);
        }
    }

    //--- Try getting the clsid from the category's UI key
    if (FAILED(hr) && m_dstrCategoryId != NULL)
    {
        CComPtr<ISpObjectTokenCategory> cpCategory;
        hr = SpGetCategoryFromId(m_dstrCategoryId, &cpCategory);
        if (SUCCEEDED(hr))
        {
            CComPtr<ISpDataKey> cpTokenUI;
            hr = cpCategory->OpenKey(SPTOKENKEY_UI, &cpTokenUI);
            if (SUCCEEDED(hr))
            {
                CComPtr<ISpDataKey> cpType;
                hr = cpTokenUI->OpenKey(pszTypeOfUI, &cpType);
                if (SUCCEEDED(hr))
                {
                    hr = cpType->GetStringValue(SPTOKENVALUE_CLSID, &dstrClsid);
                }
            }
        }
    }

    // If we were successful at getting the clsid, convert it
    if (SUCCEEDED(hr))
    {
        hr = ::CLSIDFromString(dstrClsid, pclsid);
    }

    return hr;
}


/****************************************************************************
* CSpObjectToken::MatchesAttributes *
*------------------------------------*
*   Description:
*       Check if the token supports the attributes list given in. The
*       attributes list has the same format as the required attributes given to
*       SpEnumTokens.
*
*   Return:
*   pfMatches returns TRUE or FALSE depending on whether the attributes match
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectToken::MatchesAttributes(const WCHAR * pszAttributes, BOOL *pfMatches)
{
    SPDBG_FUNC("CSpObjectToken::MatchesAttributes");
    HRESULT hr = S_OK;

    if (m_fKeyDeleted)
    {
        hr = SPERR_TOKEN_DELETED;
    }
    else if (m_cpDataKey == NULL && m_cpTokenDelegate == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszAttributes) ||
             SP_IS_BAD_WRITE_PTR(pfMatches))
    {
        hr = E_INVALIDARG;
    }
    else if (m_cpTokenDelegate != NULL)
    {
        hr = m_cpTokenDelegate->MatchesAttributes(pszAttributes, pfMatches);
    }
    else
    {
        CSpObjectTokenAttributeParser AttribParser(pszAttributes, TRUE);

        ULONG ulRank;
        hr = AttribParser.GetRank(this, &ulRank);

        if(SUCCEEDED(hr) && ulRank)
        {
            *pfMatches = TRUE;
        }
        else
        {
            *pfMatches = FALSE;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttokenattribparser.cpp ===
/****************************************************************************
*   ObjectTokenAttribParser.cpp
*       Implementation for the CSpObjectTokenAttribParser class and
*       supporting classes.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "ObjectTokenAttribParser.h"

CSpAttribCondition* CSpAttribCondition::ParseNewAttribCondition(
    const WCHAR * pszAttribCondition)
{
    SPDBG_FUNC("CSpAttribCondition::ParseNewAttribCondition");

    CSpDynamicString dstrAttribCondition = pszAttribCondition;
    CSpAttribCondition * pAttribCond = NULL;

    // Determine what type of condition it is
    if (wcsstr(dstrAttribCondition, L"!=") != NULL)
    {
        // '!=' means we're looking for a not match
        // pszAttribCondition = "Name!=Value"

        WCHAR * psz = wcsstr(dstrAttribCondition, L"!=");
        SPDBG_ASSERT(psz != NULL);
        
        CSpDynamicString dstrName;
        CSpDynamicString dstrValue;

        dstrName = dstrAttribCondition;
        dstrName.TrimToSize(ULONG(psz - (WCHAR*)dstrAttribCondition));

        dstrValue = psz + 2; // '!='
        
        pAttribCond = new CSpAttribConditionNot(
                            new CSpAttribConditionMatch(
                                        dstrName,
                                        dstrValue));
    }
    else if (wcsstr(dstrAttribCondition, L"=") != NULL)
    {
        // '=' means we're looking for a match
        // pszAttribCondition = "Name=Value"
        
        CSpDynamicString dstrName;
        CSpDynamicString dstrValue;

        dstrName = wcstok(dstrAttribCondition, L"=");
        SPDBG_ASSERT(dstrName != NULL);
        
        dstrValue = wcstok(NULL, L"");
        
        pAttribCond = new CSpAttribConditionMatch(
                                dstrName,
                                dstrValue);
    }
    else
    {
        // We didn't find any specific condition, so we'll assume the caller
        // is just looking for the existence of the attribute
        pAttribCond = new CSpAttribConditionExist(pszAttribCondition);
    }

    SPDBG_ASSERT(pAttribCond != NULL);
    return pAttribCond;
}
    
CSpAttribConditionExist::CSpAttribConditionExist(const WCHAR * pszAttribName)
{
    SPDBG_FUNC("CSpAttribConditionExist::CSpAttribConditionExist");
    m_dstrName = pszAttribName;
    m_dstrName.TrimBoth();
}

HRESULT CSpAttribConditionExist::Eval(
    ISpObjectToken * pToken, 
    BOOL * pfSatisfied)
{
    SPDBG_FUNC("CSpAttribConditionExist::Eval");
    HRESULT hr = S_OK;

    // Assume we don't satisfy the condition
    *pfSatisfied = FALSE;

    // Open attribs
    CComPtr<ISpDataKey> cpDataKey;
    hr = pToken->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpDataKey);

    // Get the value of the attribute
    CSpDynamicString dstrValue;
    if (SUCCEEDED(hr))
    {
        hr = cpDataKey->GetStringValue(m_dstrName, &dstrValue);
    }

    // If we got it, we're done
    if (SUCCEEDED(hr))
    {
        *pfSatisfied = TRUE;
    }

    // SPERR_NOT_FOUND either means Attribs couldn't be opened,
    // or that the attributed wasn't found. It's not really an
    // error for this condition.
    if (hr == SPERR_NOT_FOUND)
    {
        hr = S_OK;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

CSpAttribConditionMatch::CSpAttribConditionMatch(
    const WCHAR * pszAttribName, 
    const WCHAR * pszAttribValue)
{
    SPDBG_FUNC("CSpAttribConditionMatch::CSpAttribConditionMatch");

    SPDBG_ASSERT(pszAttribName);
    
    m_dstrName = pszAttribName;
    m_dstrName.TrimBoth();
    
    m_dstrValue = pszAttribValue;
    m_dstrValue.TrimBoth();
}

HRESULT CSpAttribConditionMatch::Eval(
    ISpObjectToken * pToken, 
    BOOL * pfSatisfied)
{
    SPDBG_FUNC("CSpAttribConditionMatch::Eval");
    HRESULT hr = S_OK;

    // Assume we won't satisfy the condition
    *pfSatisfied = FALSE;

    // Open up the attribs key
    CComPtr<ISpDataKey> cpDataKey;
    hr = pToken->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpDataKey);

    // Get the value of the attribute
    CSpDynamicString dstrValue;
    if (SUCCEEDED(hr))
    {
        hr = cpDataKey->GetStringValue(m_dstrName, &dstrValue);
    }

    // Now, values of attributes can look like this "val1;val2;val3",
    // so we'll need to parse that to see if we found a match
    if (SUCCEEDED(hr))
    {
        if (m_dstrValue != NULL)
        {
            const WCHAR * psz;
            psz = wcstok(dstrValue, L";");
            while (psz)
            {
                if (wcsicmp(m_dstrValue, psz) == 0)
                {
                    *pfSatisfied = TRUE;
                    break;
                }

                psz = wcstok(NULL, L";");
            }
        }
        else
        {
            // But this match could have been specified as "name=", and 
            // m_dstrValue will be NULL. In that case, we need to check
            // to see if the value is NULL, or empty
            *pfSatisfied = dstrValue == NULL || dstrValue[0] == '\0';
        }
    }

    // SPERR_NOT_FOUND either means Attribs couldn't be opened,
    // or that the attributed wasn't found. It's not really an
    // error for this condition.
    if (hr == SPERR_NOT_FOUND)
    {
        hr = S_OK;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
    

CSpAttribConditionNot::CSpAttribConditionNot(
    CSpAttribCondition * pAttribCond)
{
    SPDBG_FUNC("CSpAttribConditionNot::CSpAttribConditionNot");

    SPDBG_ASSERT(pAttribCond);

    m_pAttribCond = pAttribCond;
}

CSpAttribConditionNot::~CSpAttribConditionNot()
{
    SPDBG_FUNC("CSpAttribConditionNot::CSpAttributConditionNot");

    delete m_pAttribCond;
}

HRESULT CSpAttribConditionNot::Eval(
    ISpObjectToken * pToken, 
    BOOL * pfSatisfied)
{
    SPDBG_FUNC("CSpAttribConditionNot::Eval");
    HRESULT hr = S_OK;

    // Assume we won't satisfy the condition
    *pfSatisfied = FALSE;

    // Ask the contained condition
    if (m_pAttribCond != NULL)
    {
        hr = m_pAttribCond->Eval(pToken, pfSatisfied);
        if (SUCCEEDED(hr))
        {
            *pfSatisfied = !*pfSatisfied;
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

CSpObjectTokenAttributeParser::CSpObjectTokenAttributeParser(
    const WCHAR * pszAttribs, 
    BOOL fMatchAll) :
m_fMatchAll(fMatchAll)
{
    SPDBG_FUNC("CSpObjectTokenAttributeParser::CSpObjectTokenAttributeParser");

    if (pszAttribs != NULL)
    {
        CSpDynamicString dstrAttribs;
        dstrAttribs = pszAttribs;

        CSPList<const WCHAR *, const WCHAR *> listPszConditions;
        
        const WCHAR * pszNextCondition;
        pszNextCondition = wcstok(dstrAttribs, L";");
        while (pszNextCondition)
        {
            listPszConditions.AddTail(pszNextCondition);
            pszNextCondition = wcstok(NULL, L";");
        }

        SPLISTPOS pos = listPszConditions.GetHeadPosition();
        for (int i = 0; i < listPszConditions.GetCount(); i++)
        {
            const WCHAR * pszCondition = listPszConditions.GetNext(pos);

            CSpDynamicString dstrAttrib = pszCondition;
            CSpAttribCondition * pAttribCond = 
                CSpAttribCondition::ParseNewAttribCondition(
                    dstrAttrib.TrimBoth());

            SPDBG_ASSERT(pAttribCond);
            m_listAttribConditions.AddTail(pAttribCond);
        }
    }
}

CSpObjectTokenAttributeParser::~CSpObjectTokenAttributeParser()
{
    SPDBG_FUNC("CSpObjectTokenAttributeParser::~CSpObjectTokenAttributeParser");

    SPLISTPOS pos = m_listAttribConditions.GetHeadPosition();
    for (int i = 0; i < m_listAttribConditions.GetCount(); i++)
    {
        CSpAttribCondition * pAttribCond;
        pAttribCond = m_listAttribConditions.GetNext(pos);

        delete pAttribCond;
    }
}

ULONG CSpObjectTokenAttributeParser::GetNumConditions()
{
    SPDBG_FUNC("CSpObjectTokenATtributeParser::GetNumConditions");
    return m_listAttribConditions.GetCount();
}

HRESULT CSpObjectTokenAttributeParser::GetRank(ISpObjectToken * pToken, ULONG * pulRank)
{
    SPDBG_FUNC("CSpObjectTokenAttributeParser::GetRank");
    HRESULT hr = S_OK;

    BOOL fMatchedAll = TRUE;
    ULONG ulRank = 0;

    SPLISTPOS pos = m_listAttribConditions.GetHeadPosition();
    for (int i = 0; SUCCEEDED(hr) && i < m_listAttribConditions.GetCount(); i++)
    {
        CSpAttribCondition * pAttribCond;
        pAttribCond = m_listAttribConditions.GetNext(pos);

        BOOL fSatisfied;
        hr = pAttribCond->Eval(pToken, &fSatisfied);
        if (SUCCEEDED(hr) && fSatisfied)
        {
            ulRank |= (0x80000000 >> i);
        }
        else
        {
            fMatchedAll = FALSE;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (m_fMatchAll && !fMatchedAll)
        {
            ulRank = 0;
        }

        // Special case when we didn't have anything to match
        if (fMatchedAll && ulRank == 0)
        {
            SPDBG_ASSERT(m_listAttribConditions.GetCount() == 0);
            ulRank = 1;
        }

        *pulRank = ulRank;
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttokenattribparser.h ===
/****************************************************************************
*   ObjectTokenAttribParser.h
*       Declarations for the CSpObjectTokenAttribParser class and supporting
*       classes.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "sapi.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CSpAttribCondition
{
  //=== Public methods ===
  public:
    virtual ~CSpAttribCondition( void ) {}
    static CSpAttribCondition* ParseNewAttribCondition(const WCHAR * pszAttribCondition);
    virtual HRESULT Eval( ISpObjectToken * pToken, BOOL * pfSatisfied) = 0;
};

class CSpAttribConditionExist : public CSpAttribCondition
{
//=== Public methods ===
public:

    CSpAttribConditionExist(const WCHAR * pszAttribName);
    HRESULT Eval(
        ISpObjectToken * pToken, 
        BOOL * pfSatisfied);

//=== Private data ===
private:

    CSpDynamicString m_dstrName;
};

class CSpAttribConditionMatch : public CSpAttribCondition
{
//=== Public methods ===
public:

    CSpAttribConditionMatch(
        const WCHAR * pszAttribName, 
        const WCHAR * pszAttribValue);
    HRESULT Eval(
        ISpObjectToken * pToken, 
        BOOL * pfSatisfied);

//=== Private data ===
private:

    CSpDynamicString m_dstrName;
    CSpDynamicString m_dstrValue;
};

class CSpAttribConditionNot : public CSpAttribCondition
{
//=== Public methods ===
public:

    CSpAttribConditionNot(CSpAttribCondition * pAttribCond);
    ~CSpAttribConditionNot();
    
    HRESULT Eval(
        ISpObjectToken * pToken, 
        BOOL * pfSatisfied);

//=== Private data ===
private:

    CSpAttribCondition * m_pAttribCond;
};

class CSpObjectTokenAttributeParser
{
//=== Public methods ===
public:

    CSpObjectTokenAttributeParser(const WCHAR * pszAttribs, BOOL fMatchAll);
    ~CSpObjectTokenAttributeParser();

    ULONG GetNumConditions();
    HRESULT GetRank(ISpObjectToken * pToken, ULONG * pulRank);

//=== Private data ===
private:

    BOOL m_fMatchAll;
    CSPList<CSpAttribCondition*, CSpAttribCondition*> m_listAttribConditions;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttokencategory.cpp ===
/****************************************************************************
*   ObjectTokenCategory.cpp
*       Implementation for the CSpObjectTokenCategory class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "ObjectTokenCategory.h"
#include "RegHelpers.h"

//--- Constants -------------------------------------------------------------
const WCHAR g_szDefaultTokenIdValueName[] = L"DefaultTokenId";
const WCHAR g_szDefaultDefaultTokenIdValueName[] = L"DefaultDefaultTokenId";

/****************************************************************************
* CSpObjectTokenCategory::CSpObjectTokenCategory *
*------------------------------------------------*
*   Description:  
*       ctor
******************************************************************** robch */
CSpObjectTokenCategory::CSpObjectTokenCategory()
{
    SPDBG_FUNC("CSpObjectTokenCategory::CSpObjectTokenCategory");
}

/****************************************************************************
* CSpObjectTokenCategory::~CSpObjectTokenCategory *
*-------------------------------------------------*
*   Description:  
*       dtor
******************************************************************** robch */
CSpObjectTokenCategory::~CSpObjectTokenCategory()
{
    SPDBG_FUNC("CSpObjectTokenCategory::~CSpObjectTokenCategory");
}

/****************************************************************************
* CSpObjectTokenCategory::SetId *
*-------------------------------*
*   Description:  
*       Set the category id. Can only be called once.
*
*       Category IDS look something like:
*           "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\
*            Speech\Recognizers"
*
*       Known HKEY_* are:
*           HKEY_CLASSES_ROOT, 
*           HKEY_CURRENT_USER, 
*           HKEY_LOCAL_MACHINE, 
*           HKEY_CURRENT_CONFIG
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectTokenCategory::SetId(const WCHAR * pszCategoryId, BOOL fCreateIfNotExist)
{
    SPDBG_FUNC("CSpObjectTokenCategory::SetId");
    HRESULT hr = S_OK;

    if (m_cpDataKey != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if (SP_IS_BAD_STRING_PTR(pszCategoryId))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        hr = SpSzRegPathToDataKey(
                SpHkeyFromSPDKL(SPDKL_DefaultLocation), 
                pszCategoryId, 
                fCreateIfNotExist,
                &m_cpDataKey);
    }

    if (SUCCEEDED(hr))
    {
        m_dstrCategoryId = pszCategoryId;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenCategory::GetId *
*-------------------------------*
*   Description:  
*       Get the category id.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectTokenCategory::GetId(WCHAR ** ppszCoMemCategoryId)
{
    SPDBG_FUNC("CSpObjectTokenCategory::GetId");
    HRESULT hr = S_OK;

    if (m_cpDataKey == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppszCoMemCategoryId))
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString dstr;
        dstr = m_dstrCategoryId;

        *ppszCoMemCategoryId = dstr.Detach();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;    
}

/****************************************************************************
* CSpObjectTokenCategory::GetDataKey *
*------------------------------------*
*   Description:  
*       Get the data key associated with a specific location. An example of
*       where this can be used is from the Voices category, you can get the
*       CurrentUser data key for the category, and then you can see what the
*       per user tts rate and volume are.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectTokenCategory::GetDataKey(
    SPDATAKEYLOCATION spdkl, 
    ISpDataKey ** ppDataKey)
{
    SPDBG_FUNC("CSpObjectTokenCategory::GetDataKey");
    HRESULT hr = S_OK;

    if (m_cpDataKey == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppDataKey))
    {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr))
    {
        hr = SpSzRegPathToDataKey(
                SpHkeyFromSPDKL(spdkl), 
                m_dstrCategoryId, 
                TRUE,
                ppDataKey);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;    
}

/****************************************************************************
* CSpObjectTokenCategory::EnumTokens *
*------------------------------------*
*   Description:  
*       Enumerate the tokens for this category by inspecting each token,
*       and determining which tokens meet the specified required attribute
*       criteria. The order in which the tokens apear in the enumerator
*       is the order in which they satisfy the optional attribute criteria.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectTokenCategory::EnumTokens(
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum)
{
    SPDBG_FUNC("CSpObjectTokenCategory::EnumTokens");
    HRESULT hr = S_OK;

    if (m_cpDataKey == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszReqAttribs) ||
             SP_IS_BAD_OPTIONAL_STRING_PTR(pszOptAttribs) ||
             SP_IS_BAD_WRITE_PTR(ppEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = InternalEnumTokens(pszReqAttribs, pszOptAttribs, ppEnum, TRUE);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;    
}


/****************************************************************************
* CSpObjectTokenCategory::SetDefaultTokenId *
*-------------------------------------------*
*   Description:  
*       Set a specific token id as the default for this category. The defaults
*       are either stored directly in the category by setting the
*       DefaultTokenID value in the category data key, or they're indirected
*       by the DefaultTokenIDLocation which is simply a registry path.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectTokenCategory::SetDefaultTokenId(const WCHAR * pszTokenId)
{
    SPDBG_FUNC("CSpObjectTokenCategory::SetDefaultTokenId");
    HRESULT hr = S_OK;

    if (m_cpDataKey == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_STRING_PTR(pszTokenId))
    {
        hr = E_INVALIDARG;
    }

    // Determine where the default should go
    CComPtr<ISpDataKey> cpDataKey;
    if (SUCCEEDED(hr))
    {
        hr = GetDataKeyWhereDefaultTokenIdIsStored(&cpDataKey);
    }    

    // Set the new default
    if (SUCCEEDED(hr))
    {
        SPDBG_ASSERT(cpDataKey != NULL);
        hr = cpDataKey->SetStringValue(
                        g_szDefaultTokenIdValueName,
                        pszTokenId);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;    
}

/****************************************************************************
* CSpObjectTokenCategory::GetDefaultTokenId *
*-------------------------------------------*
*   Description:  
*       Get the default token id for this category.
*
*   Return:
*   S_OK on sucess
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CSpObjectTokenCategory::GetDefaultTokenId(WCHAR ** ppszTokenId)
{
    SPDBG_FUNC("CSpObjectTokenCategory::GetDefaultTokenId");
    HRESULT hr;
    
    hr = InternalGetDefaultTokenId(ppszTokenId, FALSE);
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpObjectTokenCategory::SetData *
*---------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::SetData(
    const WCHAR * pszValueName, 
    ULONG cbData, 
    const BYTE * pData)
{
    SPDBG_FUNC("CSpObjectTokenCategory::SetData");

    return m_cpDataKey != NULL
        ? m_cpDataKey->SetData(pszValueName, cbData, pData)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::GetData *
*---------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::GetData(
    const WCHAR * pszValueName, 
    ULONG * pcbData, 
    BYTE * pData)
{
    SPDBG_FUNC("CSpObjectTokenCategory::GetData");

    return m_cpDataKey != NULL
        ? m_cpDataKey->GetData(pszValueName, pcbData, pData)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::SetStringValue *
*----------------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::SetStringValue(
    const WCHAR * pszValueName, 
    const WCHAR * pszValue)
{
    SPDBG_FUNC("CSpObjectTokenCategory::SetStringValue");

    return m_cpDataKey != NULL
        ? m_cpDataKey->SetStringValue(pszValueName, pszValue)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::GetStringValue *
*----------------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::GetStringValue(
    const WCHAR * pszValueName, 
    WCHAR ** ppValue)
{
    SPDBG_FUNC("CSpObjectTokenCategory::GetStringValue");

    return m_cpDataKey != NULL
        ? m_cpDataKey->GetStringValue(pszValueName, ppValue)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::SetDWORD *
*----------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::SetDWORD(const WCHAR * pszValueName, DWORD dwValue)
{
    SPDBG_FUNC("CSpObjectTokenCategory::SetDWORD");

    return m_cpDataKey != NULL
        ? m_cpDataKey->SetDWORD(pszValueName, dwValue)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::GetDWORD *
*----------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::GetDWORD(
    const WCHAR * pszValueName, 
    DWORD *pdwValue)
{
    SPDBG_FUNC("CSpObjectTokenCategory::GetDWORD");

    return m_cpDataKey != NULL
        ? m_cpDataKey->GetDWORD(pszValueName, pdwValue)
        : SPERR_UNINITIALIZED;

}

/*****************************************************************************
* CSpObjectTokenCategory::OpenKey *
*---------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::OpenKey(
    const WCHAR * pszSubKeyName, 
    ISpDataKey ** ppKey)
{
    SPDBG_FUNC("CSpObjectTokenCategory::SetStringValue");

    return m_cpDataKey != NULL
        ? m_cpDataKey->OpenKey(pszSubKeyName, ppKey)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::CreateKey *
*-----------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::CreateKey(
    const WCHAR * pszSubKeyName, 
    ISpDataKey ** ppKey)
{
    SPDBG_FUNC("CSpObjectTokenCategory::CreateKey");

    return m_cpDataKey != NULL
        ? m_cpDataKey->CreateKey(pszSubKeyName, ppKey)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::DeleteKey *
*-----------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::DeleteKey(const WCHAR * pszSubKeyName)
{
    SPDBG_FUNC("CSpObjectTokenCategory:DeleteKey");

    return m_cpDataKey != NULL
        ? m_cpDataKey->DeleteKey(pszSubKeyName)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::DeleteValue *
*-------------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::DeleteValue(const WCHAR * pszValueName)
{   
    SPDBG_FUNC("CSpObjectTokenCategory::DeleteValue");

    return m_cpDataKey != NULL
        ? m_cpDataKey->DeleteValue(pszValueName)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::EnumKeys *
*----------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::EnumKeys(ULONG Index, WCHAR ** ppszKeyName)
{
    SPDBG_FUNC("CSpObjectTokenCategory::EnumKeys");

    return m_cpDataKey != NULL
        ? m_cpDataKey->EnumKeys(Index, ppszKeyName)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::EnumValues *
*------------------------------------*
*   Description:
*       Delegates to contained data key
*
*   Return:
*   S_OK
*   E_OUTOFMEMORY
******************************************************************* robch ***/
STDMETHODIMP CSpObjectTokenCategory::EnumValues(ULONG Index, WCHAR ** ppszValueName)
{
    SPDBG_FUNC("CSpObjectTokenCategory::EnumValues");

    return m_cpDataKey != NULL
        ? m_cpDataKey->EnumValues(Index, ppszValueName)
        : SPERR_UNINITIALIZED;
}

/*****************************************************************************
* CSpObjectTokenCategory::InternalEnumTokens *
*--------------------------------------------*
*   Description:
*       Enumerates the tokens, and optionall puts the default first
*
*   Return:
*   S_OK
*   E_OUTOFMEMORY
******************************************************************* robch ***/
HRESULT CSpObjectTokenCategory::InternalEnumTokens(
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum,
    BOOL fPutDefaultFirst)
{
    SPDBG_FUNC("CSpObjectTokenCategory::InternalEnumTokens");
    HRESULT hr = S_OK;
    BOOL fNotAllTokensAdded = FALSE;

    // Create an enumerator and populate it with the static tokens
    CComPtr<ISpObjectTokenEnumBuilder> cpEnum;
    if (SUCCEEDED(hr))
    {
        hr = cpEnum.CoCreateInstance(CLSID_SpObjectTokenEnum);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpEnum->SetAttribs(pszReqAttribs, pszOptAttribs);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpEnum->AddTokensFromDataKey(
                        m_cpDataKey,
                        L"Tokens", 
                        m_dstrCategoryId);
        if(hr == S_FALSE)
        {
            fNotAllTokensAdded = TRUE;
        }
    }
    
    // Create an enumerator for the enumertors and populate it with 
    // the tokens for the token enumerators
    CComPtr<ISpObjectTokenEnumBuilder> cpEnumForEnums;
    if (SUCCEEDED(hr))
    {
        hr = cpEnumForEnums.CoCreateInstance(CLSID_SpObjectTokenEnum);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpEnumForEnums->SetAttribs(NULL, NULL);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpEnumForEnums->AddTokensFromDataKey(
                                m_cpDataKey,
                                L"TokenEnums", 
                                m_dstrCategoryId);
        if(hr == S_FALSE)
        {
            fNotAllTokensAdded = TRUE;
        }
    }
    
    // Loop thru the enum enumerator
    while (SUCCEEDED(hr))
    {
        // Get the enumerator's token
        CComPtr<ISpObjectToken> cpTokenForEnum;
        hr = cpEnumForEnums->Next(1, &cpTokenForEnum, NULL);
        if (hr == S_FALSE)
        {
            break;
        }

        // Create the enumerator
        CComPtr<IEnumSpObjectTokens> cpTokenEnum;
        if (SUCCEEDED(hr))
        {
            hr = SpCreateObjectFromToken(cpTokenForEnum, &cpTokenEnum);
            if(FAILED(hr))
            {
                fNotAllTokensAdded = TRUE;
                hr = S_OK;
                continue;
            }
        }

        // Add the objects from the enumerator to the enumerator we already
        // populated with the static tokens.
        if (SUCCEEDED(hr))
        {
            hr = cpEnum->AddTokensFromTokenEnum(cpTokenEnum);
        }
    }

    // If we're supposed to put the default first, we need to
    // know what the default is
    CSpDynamicString dstrDefaultTokenId;
    if (SUCCEEDED(hr) && fPutDefaultFirst)
    {
        hr = InternalGetDefaultTokenId(&dstrDefaultTokenId, TRUE);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }
    
    // OK, go ahead and sort now
    if (SUCCEEDED(hr))
    {
        hr = cpEnum->Sort(dstrDefaultTokenId);
    }

    // We're done, return the enum back to the caller
    if (SUCCEEDED(hr))
    {
        *ppEnum = cpEnum.Detach();
    }

    if(SUCCEEDED(hr) && fNotAllTokensAdded)
    {
        hr = S_FALSE;
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;    
}

/****************************************************************************
* ParseVersion *
*---------------------------------------------------*
*   Description:  
*		Takes a version number string, checks it is valid, and fills the four 
*		values in the Version array. Valid version stings are "a[.b[.c[.d]]]",
*		where a,b,c,d are +ve integers, 0 -> 9999. If b,c,d are missing those 
*		version values are set as zero.
*   Return:
*		TRUE if valid version string.
*		FALSE if version string null or not valid.
******************************************************************** davewood */
BOOL ParseVersion(WCHAR *psz, unsigned short Version[4])
{
    BOOL fIsValid = TRUE;
    Version[0] = Version[1] = Version[2] = Version[3] = 0;

    if(!psz || psz[0] == L'\0')
    {
        fIsValid = FALSE;
    }
    else
    {
        WCHAR *pszCurPos = psz;
        for(ULONG ul = 0; ul < 4 && pszCurPos[0] != L'\0'; ul++)
        {
            // read +ve integer
            WCHAR *pszNewPos;
            ULONG ulVal = wcstoul(pszCurPos, &pszNewPos, 10);

            if(pszNewPos == pszCurPos || (pszNewPos[0] != L'.' && pszNewPos[0] != L'\0') || ulVal > 9999)
            {
                fIsValid = FALSE;
                break;
            }
            else
            {
                Version[ul] = (unsigned short)ulVal;
            }

            if(pszNewPos[0] == L'\0')
            {
                pszCurPos = pszNewPos;
                break;
            }
            else
            {
                pszCurPos = pszNewPos + 1;
            }

        }

        if(fIsValid && (pszCurPos[0] != '\0' || pszCurPos[-1] == '.'))
        {
            fIsValid = FALSE;
        }
    }
    return fIsValid; 
}

/****************************************************************************
* CompareVersions *
*---------------------------------------------------*
*   Description:  
*		Takes two version number strings and compares them. Sets *pRes > 0 if V1 > V2,
*		*pRes < 0 if V1 < V2, and *pRes == 0 if V1 == V2.
*		If V1 or V2 invalid format then the valid string is returned as being greater.
*   Return:
******************************************************************** davewood */
HRESULT CompareVersions(WCHAR *pszV1, WCHAR *pszV2, LONG *pRes)
{
    unsigned short v1[4];
    unsigned short v2[4];

    BOOL fV1OK = ParseVersion(pszV1, v1);
    BOOL fV2OK = ParseVersion(pszV2, v2);

    if(!fV1OK && !fV2OK)
    {
        *pRes = 0;
    }
    else if(fV1OK && !fV2OK)
    {
        *pRes = 1;
    }
    else if(!fV1OK && fV2OK)
    {
        *pRes = -1;
    }
    else
    {
        *pRes = 0;
        for(ULONG ul = 0; *pRes == 0 && ul < 4; ul++)
        {
            if(v1[ul] > v2[ul])
            {
                *pRes = 1;
            }
            else if(v1[ul] < v2[ul])
            {
                *pRes = -1;
            }
        }
    }

    return S_OK;
}

/****************************************************************************
* CompareTokenVersions *
*---------------------------------------------------*
*   Description:  
*		Takes two tokens and compares them using version info. Sets *pRes > 0 if T1 > T2,
*		*pRes < 0 if T1 < T2, and *pRes == 0 if T1 == T2.
*		Note only tokens that match on Vendor, ProductLine, Language get compared, the pfDidCompare flag indicates this
*   Return:
******************************************************************** davewood */
HRESULT CompareTokenVersions(ISpObjectToken *pToken1, ISpObjectToken *pToken2, LONG *pRes, BOOL *pfDidCompare)
{
    HRESULT hr = S_OK;
    *pfDidCompare = FALSE;

    CSpDynamicString dstrVendor1, dstrVendor2;
    CSpDynamicString dstrVersion1, dstrVersion2;
    CSpDynamicString dstrLanguage1, dstrLanguage2;
    CSpDynamicString dstrProductLine1, dstrProductLine2;

    // get vendor, version, language, product line for token 1
    CComPtr<ISpDataKey> cpAttKey1;
    hr = pToken1->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpAttKey1);

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey1->GetStringValue(L"Vendor", &dstrVendor1);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey1->GetStringValue(L"ProductLine", &dstrProductLine1);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey1->GetStringValue(L"Version", &dstrVersion1);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey1->GetStringValue(L"Language", &dstrLanguage1);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    // get vendor, version, language, product line for token 2
    CComPtr<ISpDataKey> cpAttKey2;
    if(SUCCEEDED(hr))
    {
        hr = pToken2->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpAttKey2);
    }

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey2->GetStringValue(L"Vendor", &dstrVendor2);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey2->GetStringValue(L"ProductLine", &dstrProductLine2);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey2->GetStringValue(L"Version", &dstrVersion2);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = cpAttKey2->GetStringValue(L"Language", &dstrLanguage2);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(((!dstrVendor1 && !dstrVendor2) || (dstrVendor1 && dstrVendor2 && !wcscmp(dstrVendor1, dstrVendor2))) &&
            ((!dstrProductLine1 && !dstrProductLine2) || (dstrProductLine1 && dstrProductLine2 && !wcscmp(dstrProductLine1, dstrProductLine2))) &&
            ((!dstrLanguage1 && !dstrLanguage2) || (dstrLanguage1 && dstrLanguage2 && !wcscmp(dstrLanguage1, dstrLanguage2))))
        {
            *pfDidCompare = TRUE;
            hr = CompareVersions(dstrVersion1, dstrVersion2, pRes);
        }
    }

    return hr;
}


/****************************************************************************
* CSpObjectTokenCategory::InternalGetDefaultTokenId *
*---------------------------------------------------*
*   Description:  
*       Get the default token id for this category and optionally expand it.
*
*   Return:
*   S_OK on sucess
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectTokenCategory::InternalGetDefaultTokenId(
    WCHAR ** ppszTokenId, 
    BOOL fExpandToRealTokenId)
{
    SPDBG_FUNC("CSpObjectTokenCategory::InternalGetDefaultTokenId");
    HRESULT hr = S_OK;
    BOOL fSaveNewDefault = FALSE;

    if (m_cpDataKey == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppszTokenId))
    {
        hr = E_POINTER;
    }

    // Determine where the default is
    CComPtr<ISpDataKey> cpDataKey;
    if (SUCCEEDED(hr))
    {
        hr = GetDataKeyWhereDefaultTokenIdIsStored(&cpDataKey);
    }

    // Get the default token id
    CSpDynamicString dstrDefaultTokenId;
    if (SUCCEEDED(hr))
    {
        hr = cpDataKey->GetStringValue(
            g_szDefaultTokenIdValueName,
            &dstrDefaultTokenId);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    // If there wasn't a default, but there's a default default
    // use that
    if (SUCCEEDED(hr) && dstrDefaultTokenId == NULL)
    {
        fSaveNewDefault = TRUE;

        CSpDynamicString dstrDefaultDefaultTokenId;
        hr = GetStringValue(g_szDefaultDefaultTokenIdValueName, &dstrDefaultDefaultTokenId);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }

        // create default default
        CComPtr<ISpObjectToken> cpDefaultDefaultToken;
        if(dstrDefaultDefaultTokenId)
        {
            hr = SpGetTokenFromId(dstrDefaultDefaultTokenId, &cpDefaultDefaultToken);

            if (hr == SPERR_NOT_FOUND)
            {
                dstrDefaultDefaultTokenId.Clear();
                hr = S_OK;
            }
        }

        // Now do special check to see if we have another token from the same vendor with a 
        // more recent version - if so use that.
        if(SUCCEEDED(hr) && dstrDefaultDefaultTokenId && cpDefaultDefaultToken)
        {
            CComPtr<IEnumSpObjectTokens> cpEnum;
            if(SUCCEEDED(hr))
            {
                hr = InternalEnumTokens(NULL, NULL, &cpEnum, FALSE);
            }

            while(SUCCEEDED(hr))
            {
                CComPtr<ISpObjectToken> cpToken;
                hr = cpEnum->Next(1, &cpToken, NULL);

                if(hr == S_FALSE)
                {
                    hr = S_OK;
                    break;
                }

                // if override and higher version - new preferred.
                BOOL fOverride = FALSE;
                if(SUCCEEDED(hr))
                {
                    hr = cpToken->MatchesAttributes(L"VersionDefault", &fOverride);
                }

                if(SUCCEEDED(hr) && fOverride)
                {
                    LONG lRes;
                    BOOL fDidCompare;
                    hr = CompareTokenVersions(cpToken, cpDefaultDefaultToken, &lRes, &fDidCompare);

                    if(SUCCEEDED(hr) && fDidCompare && lRes > 0)
                    {
                        cpDefaultDefaultToken = cpToken; // Overwrite default default here
                        dstrDefaultDefaultTokenId.Clear();
                        hr = cpDefaultDefaultToken->GetId(&dstrDefaultDefaultTokenId);
                    }
                }
            }
        }

        dstrDefaultTokenId = dstrDefaultDefaultTokenId; // Use default default even if we fail
        hr = S_OK;
    }

    // Now verify that it would actually be a valid token
    if (SUCCEEDED(hr) && dstrDefaultTokenId != NULL)
    {
        CComPtr<ISpObjectToken> cpToken;
        hr = SpGetTokenFromId(dstrDefaultTokenId, &cpToken);

        if (hr == SPERR_NOT_FOUND)
        {
            fSaveNewDefault = TRUE; // Default was invalid, will override with later default.
            dstrDefaultTokenId.Clear();
            hr = S_OK;
        }

        // Now get the actual token id from the token itself
        // because it could have been the token id of the enumerator
        // with the trailing '\' but we want the real token id here
        if (SUCCEEDED(hr) && cpToken != NULL && fExpandToRealTokenId)
        {
            dstrDefaultTokenId.Clear();
            hr = cpToken->GetId(&dstrDefaultTokenId);
        }
    }           

    // If there still wasn't a default, just pick one
    if (SUCCEEDED(hr))
    {
        if (dstrDefaultTokenId == NULL)
        {
            WCHAR szOptAttribs[MAX_PATH];
            swprintf(szOptAttribs, L"Language=%x;VendorPreferred", SpGetUserDefaultUILanguage());

            CComPtr<IEnumSpObjectTokens> cpEnum;
            hr = InternalEnumTokens(NULL, szOptAttribs, &cpEnum, FALSE);

            CComPtr<ISpObjectToken> cpDefaultToken;
            if(SUCCEEDED(hr))
            {
                hr = cpEnum->Next(1, &cpDefaultToken, NULL);
                if(hr == S_FALSE)
                {
                    hr = SPERR_NOT_FOUND;
                }
            }

            while (SUCCEEDED(hr))
            {
                CComPtr<ISpObjectToken> cpToken;
                hr = cpEnum->Next(1, &cpToken, NULL);
                if(hr == S_FALSE)
                {
                    hr = S_OK;
                    break;
                }

                // if exclusive and higher version - new preferred.
                BOOL fOverride = FALSE;
                if(SUCCEEDED(hr))
                {
                    hr = cpToken->MatchesAttributes(L"VersionDefault", &fOverride);
                }

                if(SUCCEEDED(hr) && fOverride)
                {
                    BOOL fDidCompare;
                    LONG lRes;
                    hr = CompareTokenVersions(cpToken, cpDefaultToken, &lRes, &fDidCompare);

                    if(SUCCEEDED(hr) && fDidCompare && lRes > 0)
                    {
                        cpDefaultToken = cpToken; // Overwrite default here
                    }
                }
            }

            if(cpDefaultToken)
            {
                hr = cpDefaultToken->GetId(&dstrDefaultTokenId);
            }
        }
    }

    if (SUCCEEDED(hr) && fSaveNewDefault && dstrDefaultTokenId != NULL)
    {
        hr = cpDataKey->SetStringValue(g_szDefaultTokenIdValueName, dstrDefaultTokenId);
    }

    if (SUCCEEDED(hr))
    {
        *ppszTokenId = dstrDefaultTokenId.Detach();
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/****************************************************************************
* CSpObjectTokenCategory::GetDataKeyWhereDefaultIsStored *
*--------------------------------------------------------*
*   Description:  
*       Get the data key where the current default is stored
*
*   Return:
*   S_OK on sucess
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CSpObjectTokenCategory::GetDataKeyWhereDefaultTokenIdIsStored(ISpDataKey ** ppDataKey)
{
    SPDBG_FUNC("CSpObjectTokenCategory::GetDataKeyWhereDefaultIsStored");
    HRESULT hr;
    
    // Does the contained data key have the current default token
    CSpDynamicString dstrDefaultTokenId;
    hr = m_cpDataKey->GetStringValue(
                g_szDefaultTokenIdValueName, 
                &dstrDefaultTokenId);
    if (SUCCEEDED(hr))
    {
        *ppDataKey = m_cpDataKey;
        (*ppDataKey)->AddRef();
    }
    else if (hr == SPERR_NOT_FOUND)
    {
        // Nope, the current data key didn't have it. OK, that
        // means we should use the user data key if we can
        CComPtr<ISpDataKey> cpDataKeyUser;
        hr = GetDataKey(SPDKL_CurrentUser, &cpDataKeyUser);

        if (SUCCEEDED(hr))
        {
            *ppDataKey = cpDataKeyUser.Detach();
            hr = S_OK;
        }            
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttokenenumbuilder.h ===
/****************************************************************************
*   ObjectTokenEnumBuilder.h
*       Declarations for the CSpObjectTokenEnumBuilder class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "sapi.h"
#include "ObjectTokenAttribParser.h"

//--- Class, Struct and Union Definitions -----------------------------------

class ATL_NO_VTABLE CSpObjectTokenEnumBuilder : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpObjectTokenEnumBuilder, &CLSID_SpObjectTokenEnum>,
#ifdef SAPI_AUTOMATION
    public IDispatchImpl<ISpeechObjectTokens, &IID_ISpeechObjectTokens, &LIBID_SpeechLib, 5>,
#endif // SAPI_AUTOMATION
    public ISpObjectTokenEnumBuilder
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_OBJECTTOKENENUMBUILDER)

    BEGIN_COM_MAP(CSpObjectTokenEnumBuilder)
        COM_INTERFACE_ENTRY(IEnumSpObjectTokens)
        COM_INTERFACE_ENTRY(ISpObjectTokenEnumBuilder)
#ifdef SAPI_AUTOMATION
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISpeechObjectTokens)
#endif // SAPI_AUTOMATION
    END_COM_MAP()

//=== Public methods ===
public:

    //--- ctor/dtor ---------------------------------------------------------
    CSpObjectTokenEnumBuilder();
    ~CSpObjectTokenEnumBuilder();

//=== Interfaces ===
public:

    //--- ISpEnumObjectTokens -----------------------------------------------
    STDMETHODIMP Next(ULONG celt, ISpObjectToken ** pelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumSpObjectTokens **ppEnum);
    STDMETHODIMP GetCount(ULONG * pulCount);
    STDMETHODIMP Item(ULONG Index, ISpObjectToken ** ppToken);

    //--- ISpObjectTokenEnumBuilder -----------------------------------------
    STDMETHODIMP SetAttribs(const WCHAR * pszReqAttrs, const WCHAR * pszOptAttrs);
    STDMETHODIMP AddTokens(ULONG cTokens, ISpObjectToken ** pToken);
    STDMETHODIMP AddTokensFromDataKey(ISpDataKey * pDataKey, const WCHAR * pszSubKey, const WCHAR * pszCategoryId);
    STDMETHODIMP AddTokensFromTokenEnum(IEnumSpObjectTokens * pTokenEnum);
    STDMETHODIMP Sort(const WCHAR * pszTokenIdToListFirst);

#ifdef SAPI_AUTOMATION
    //--- ISpeechObjectTokens --------------------------------------------------
    STDMETHOD(Item)( long Index, ISpeechObjectToken** ppToken );
    STDMETHOD(get_Count)( long* pVal );
    STDMETHOD(get__NewEnum)( IUnknown** ppEnumVARIANT );
#endif // SAPI_AUTOMATION

//=== Private methods ===
private:

    HRESULT MakeRoomFor(ULONG cTokens);

//=== Private data ===
private:

    ULONG               m_ulCurTokenIndex;
    ULONG               m_cTokens;
    ULONG               m_cAllocSlots;
    ISpObjectToken **   m_pTokenTable;
    
    CSpObjectTokenAttributeParser   *m_pAttribParserReq;
    CSpObjectTokenAttributeParser   *m_pAttribParserOpt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttokenenumbuilder.cpp ===
/****************************************************************************
*   ObjectTokenCategory.cpp
*       Implementation for the CSpObjectTokenCategory class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "ObjectTokenEnumBuilder.h"

/****************************************************************************
* CSpObjectTokenEnumBuilder::CSpObjectTokenEnumBuilder *
*------------------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
CSpObjectTokenEnumBuilder::CSpObjectTokenEnumBuilder()
{
    m_ulCurTokenIndex = 0;
    m_cTokens = 0;
    m_cAllocSlots = 0;
    m_pTokenTable = NULL;
    
    m_pAttribParserReq = NULL;
    m_pAttribParserOpt = NULL;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::~CSpObjectTokenEnumBuilder *
*-------------------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
CSpObjectTokenEnumBuilder::~CSpObjectTokenEnumBuilder()
{
    for (ULONG i = 0; i < m_cTokens; i++)
    {
        m_pTokenTable[i]->Release();
    }
    ::CoTaskMemFree(m_pTokenTable);

    delete m_pAttribParserReq;
    delete m_pAttribParserOpt;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::Next *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::Next(ULONG celt, ISpObjectToken ** pelt, ULONG *pceltFetched)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::Next");
    HRESULT hr = S_OK;

    if (celt == 0)
    {
        hr = E_INVALIDARG;
    }
    if (SUCCEEDED(hr) && SPIsBadWritePtr(pelt, sizeof(*pelt) * celt))
    {
        hr = E_POINTER;
    }
    else
    {
        memset(pelt, 0, sizeof(*pelt) * celt);
    }
    if (SUCCEEDED(hr) && 
        (celt > 1 && pceltFetched == NULL) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pceltFetched))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr) && m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    if (SUCCEEDED(hr))
    {
        ULONG cFetched = celt;      // Assume we'll get them all
        while (celt && m_ulCurTokenIndex < m_cTokens)
        {
            *pelt = m_pTokenTable[m_ulCurTokenIndex++];
            (*pelt)->AddRef();
            pelt++;
            celt--;
        }
        if (celt)
        {
            hr = S_FALSE;
            cFetched -= celt;
        }
        if (pceltFetched)
        {
            *pceltFetched = cFetched;
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::Skip *
*---------------------------------*
*   Description:
*
*   Returns:
*       S_OK    - Number of elements skipped was celt. 
*       S_FALSE - Number of elements skipped was less than celt.
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::Skip(ULONG celt)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::Skip");
    HRESULT hr = S_OK;

    if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else
    {
        m_ulCurTokenIndex += celt;
        if (m_ulCurTokenIndex > m_cTokens)
        {
            m_ulCurTokenIndex = m_cTokens;
            hr = S_FALSE;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::Reset *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::Reset()
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::Reset");
    HRESULT hr = S_OK;
    
    if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else
    {
        m_ulCurTokenIndex = 0;
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::Clone *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::Clone(IEnumSpObjectTokens **ppEnum)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::Clone");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
    }

    if (SUCCEEDED(hr) && m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }

    CComPtr<ISpObjectTokenEnumBuilder> cpNewEnum;
    if (SUCCEEDED(hr))
    {
        hr = cpNewEnum.CoCreateInstance(CLSID_SpObjectTokenEnum);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpNewEnum->SetAttribs(NULL, NULL);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpNewEnum->AddTokens(m_cTokens, m_pTokenTable);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpNewEnum->QueryInterface(ppEnum);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


/****************************************************************************
* CSpObjectTokenEnumBuilder::GetCount *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::GetCount(ULONG * pulCount)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::GetCount");
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(pulCount))
    {
        hr = E_POINTER;
    }
    else if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else
    {
        *pulCount = m_cTokens;
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::Item *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
STDMETHODIMP CSpObjectTokenEnumBuilder::Item(ULONG Index, ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::Item");
    HRESULT hr = S_OK;
    
    if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (Index >= m_cTokens)
    {
        hr = SPERR_NO_MORE_ITEMS;
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(ppToken))
        {
            hr = E_POINTER;
        }
        else
        {
            *ppToken = m_pTokenTable[Index];
            (*ppToken)->AddRef();
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::SetAttribs *
*---------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::SetAttribs(const WCHAR * pszReqAttrs, 
                                                           const WCHAR * pszOptAttrs)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::SetAttribs");
    HRESULT hr = S_OK;

    if (m_pAttribParserReq != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszReqAttrs) ||
             SP_IS_BAD_OPTIONAL_STRING_PTR(pszOptAttrs))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_pAttribParserReq = new CSpObjectTokenAttributeParser(pszReqAttrs, TRUE);
        m_pAttribParserOpt = new CSpObjectTokenAttributeParser(pszOptAttrs, FALSE);

        if (m_pAttribParserReq == NULL || m_pAttribParserOpt == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::AddTokens *
*--------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::AddTokens(ULONG cTokens, ISpObjectToken ** prgpToken)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::AddTokens");
    HRESULT hr = S_OK;

    if (SPIsBadReadPtr(prgpToken, sizeof(*prgpToken) * cTokens))
    {
        hr = E_INVALIDARG;
    }
    else if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }

    for (UINT i = 0; SUCCEEDED(hr) && i < cTokens; i++)
    {
        if(SP_IS_BAD_INTERFACE_PTR(prgpToken[i]))
        {
            hr = E_INVALIDARG;
            break;
        }

        ULONG ulRank;
        hr = m_pAttribParserReq->GetRank(prgpToken[i], &ulRank);

        if (SUCCEEDED(hr) && ulRank)
        {
            hr = MakeRoomFor(1);
            if (SUCCEEDED(hr))
            {
                prgpToken[i]->AddRef();
                m_pTokenTable[m_cTokens++] = prgpToken[i];
            }
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::AddTokensFromDataKey *
*-------------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::AddTokensFromDataKey(
    ISpDataKey * pDataKey, 
    const WCHAR * pszSubKey, 
    const WCHAR * pszCategoryId)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::InitFromDataKey");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pDataKey) ||
        SP_IS_BAD_STRING_PTR(pszCategoryId) ||
        (pszSubKey &&
        (SP_IS_BAD_STRING_PTR(pszSubKey) ||
        wcslen(pszSubKey) == 0)))
    {
        hr = E_INVALIDARG;
    }
    else if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }

    CSpDynamicString dstrTokenIdBase;
    CComPtr<ISpDataKey> cpDataKey;
    if (SUCCEEDED(hr))
    {
        dstrTokenIdBase = pszCategoryId;
        if (pszSubKey == NULL)
        {
            cpDataKey = pDataKey;
        }
        else
        {
            dstrTokenIdBase.Append2(L"\\", pszSubKey);
            hr = pDataKey->OpenKey(pszSubKey, &cpDataKey);
            if (hr == SPERR_NOT_FOUND)
            {
                hr = S_OK;
            }
        }
    }

    BOOL fNotAllTokensAdded = FALSE;
    for (UINT i = 0; SUCCEEDED(hr) && cpDataKey != NULL; i++)
    {
        CSpDynamicString dstrTokenKeyName;
        hr = cpDataKey->EnumKeys(i, &dstrTokenKeyName);
        if (hr == SPERR_NO_MORE_ITEMS)
        {
            hr = S_OK;
            break;
        }

        CComPtr<ISpDataKey> cpDataKeyForToken;
        if (SUCCEEDED(hr))
        {
            hr = cpDataKey->OpenKey(dstrTokenKeyName, &cpDataKeyForToken);
        }

        CComPtr<ISpObjectTokenInit> cpTokenInit;
        if (SUCCEEDED(hr))
        {
            hr = cpTokenInit.CoCreateInstance(CLSID_SpObjectToken);
        }

        if (SUCCEEDED(hr))
        {
            CSpDynamicString dstrTokenId;
            dstrTokenId = dstrTokenIdBase;
            dstrTokenId.Append2(L"\\", dstrTokenKeyName);
            hr = cpTokenInit->InitFromDataKey(pszCategoryId, dstrTokenId, cpDataKeyForToken);
        }

        if (SUCCEEDED(hr))
        {
            ISpObjectToken * pToken = cpTokenInit;
            hr = AddTokens(1, &pToken);
        }
        else
        {
            // We could not create this token but continue searching
            // Note this means it's not possible to tell if none, some, or all
            // of the data keys got added as tokens.
            hr = S_OK;
            fNotAllTokensAdded = TRUE;
        }
    }
    if(SUCCEEDED(hr) && fNotAllTokensAdded)
    {
        hr = S_FALSE;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::AddTokensFromTokenEnum *
*---------------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::AddTokensFromTokenEnum(IEnumSpObjectTokens * pTokenEnum)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::AddTokensFromTokenEnum");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pTokenEnum))
    {
        hr = E_INVALIDARG;
    }
    else if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }

    while (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpToken;
        hr = pTokenEnum->Next(1, &cpToken, NULL);
        if (hr == S_FALSE)
        {
            hr = S_OK;
            break;
        }

        if (SUCCEEDED(hr))
        {
            ISpObjectToken * pToken = cpToken;
            hr = AddTokens(1, &pToken);
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::Sort *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::Sort(const WCHAR * pszTokenIdToListFirst)
{
    SPDBG_FUNC("CSpObjectTokenEnumBuilder::Sort");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszTokenIdToListFirst))
    {
        hr = E_INVALIDARG;
    }
    else if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (m_cTokens > 1)
    {
        if (pszTokenIdToListFirst != NULL)
        {
            for (ULONG i = 1; SUCCEEDED(hr) && i < m_cTokens; i++)   // Ignore the first list entry (start at 1)
            {
                CSpDynamicString dstrId;
                hr = m_pTokenTable[i]->GetId(&dstrId);
                if (SUCCEEDED(hr) &&
                    wcsnicmp(pszTokenIdToListFirst, dstrId, wcslen(pszTokenIdToListFirst)) == 0)
                {
                    ISpObjectToken * pTokenToSwap = m_pTokenTable[0];
                    m_pTokenTable[0] = m_pTokenTable[i];
                    m_pTokenTable[i] = pTokenToSwap;
                    break;
                }
            }
        }

        if (SUCCEEDED(hr) && m_pAttribParserOpt->GetNumConditions())
        {
            ULONG * rgulRanks = (ULONG *)_alloca(sizeof(ULONG) * m_cTokens);
            for (ULONG i = 0; SUCCEEDED(hr) && i < m_cTokens; i++)
            {
                hr = m_pAttribParserOpt->GetRank(m_pTokenTable[i], &rgulRanks[i]);
            }

            if (SUCCEEDED(hr))
            {
                // CONSIDER: This is n^2. Perhaps we should use qsort here
                for (i = 0; i < m_cTokens - 1; i++)
                {
                    for (ULONG j = i + 1; j < m_cTokens; j++)
                    {
                        if (rgulRanks[j] > rgulRanks[i])
                        {
                            ULONG ulRank = rgulRanks[i];
                            ISpObjectToken * pToken = m_pTokenTable[i];
                            
                            rgulRanks[i] = rgulRanks[j];
                            m_pTokenTable[i] = m_pTokenTable[j];
                            
                            rgulRanks[j] = ulRank;
                            m_pTokenTable[j] = pToken;
                        }
                    }
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpObjectTokenEnumBuilder::MakeRoomFor *
*----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpObjectTokenEnumBuilder::MakeRoomFor(ULONG cNewTokens)
{
    SPDBG_FUNC("HRESULT CSpObjectTokenEnumBuilder::MakeRoomFor");
    HRESULT hr = S_OK;

    if (m_pAttribParserReq == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (m_cTokens + cNewTokens > m_cAllocSlots)
    {
        ULONG cDesired = m_cAllocSlots + ((cNewTokens > 4) ? cNewTokens : 4);
        void * pvNew = ::CoTaskMemRealloc(m_pTokenTable, cDesired * sizeof(*m_pTokenTable));
        if (pvNew == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_cAllocSlots = cDesired;
            m_pTokenTable = (ISpObjectToken **)pvNew;
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\phoneconv.cpp ===
/*******************************************************************************
*   PhoneConv.cpp
*   Phone convertor object. Converts between internal phone and Id phone set.
*
*   Owner: YUNUSM/YUNCJ                                  Date: 06/18/99
*   Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

//--- Includes -----------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "PhoneConv.h"
#include "a_helpers.h"

//--- Constants ----------------------------------------------------------------

/*******************************************************************************
* CSpPhoneConverter::CSpPhoneConverter *
*--------------------------------------*
*   Description:
*       Constructor
*   Result:
*       n/a
***************************************************************** YUNUSM ******/
CSpPhoneConverter::CSpPhoneConverter()
{
    SPDBG_FUNC("CPhoneConv::CSpPhoneConverter");

    m_pPhoneId = NULL;
    m_pIdIdx = NULL;
    m_dwPhones = 0;
    m_cpObjectToken = NULL;
    m_fNoDelimiter = FALSE;
#ifdef SAPI_AUTOMATION
    m_LangId = 0;
#endif //SAPI_AUTOMATION
}


/*******************************************************************************
* CSpPhoneConverter::~CSpPhoneConverter *
*---------------------------------------*
*   Description:
*       Destructor
*   Result:
*       n/a
***************************************************************** YUNUSM ******/
CSpPhoneConverter::~CSpPhoneConverter()
{
    SPDBG_FUNC("CSpPhoneConverter::~CSpPhoneConverter");

    delete [] m_pPhoneId;
    free(m_pIdIdx);
}

STDMETHODIMP CSpPhoneConverter::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC("CSpPhoneConverter::SetObjectToken");
    HRESULT hr = S_OK;

    hr = SpGenericSetObjectToken(pToken, m_cpObjectToken);

    // Try to read the phone map from the token
    CSpDynamicString dstrPhoneMap;
    if (SUCCEEDED(hr))
    {
        hr = pToken->GetStringValue(L"PhoneMap", &dstrPhoneMap);
    }

    if(SUCCEEDED(hr))
    {
        BOOL fNoDelimiter;
        hr = pToken->MatchesAttributes(L"NoDelimiter", &fNoDelimiter);
        if(SUCCEEDED(hr))
        {
            m_fNoDelimiter = fNoDelimiter;
        }
    }

    BOOL fNumericPhones;
    if(SUCCEEDED(hr))
    {
        hr = pToken->MatchesAttributes(L"NumericPhones", &fNumericPhones);
    }

    // Set it on ourselves
    if (SUCCEEDED(hr))
    {
        hr = SetPhoneMap(dstrPhoneMap, fNumericPhones);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

STDMETHODIMP CSpPhoneConverter::GetObjectToken(ISpObjectToken **ppToken)
{
    return SpGenericGetObjectToken(ppToken, m_cpObjectToken);
}

/*******************************************************************************
* CSpPhoneConverter::PhoneToId *
*-------------------------------*
*   
*   Description:
*       Convert an internal phone string to Id code string
*       The internal phones are space separated and may have a space
*       at the end.
*
*   Return: 
*       S_OK
*       E_POINTER
*       E_INVALIDARG
***************************************************************** YUNUSM ******/
STDMETHODIMP CSpPhoneConverter::PhoneToId(const WCHAR *pszIntPhone,    // Internal phone string
                                          SPPHONEID *pId               // Returned Id string
                                          )
{
    SPDBG_FUNC("CSpPhoneConverter::PhoneToId");

    if (!pszIntPhone || SPIsBadStringPtr(pszIntPhone))
    {
        return E_INVALIDARG;
    }
    else if (wcslen(pszIntPhone) >= SP_MAX_PRON_LENGTH * (g_dwMaxLenPhone + 1))
    {
        return E_INVALIDARG;
    }
    else if (m_pPhoneId == NULL)
    {
        return SPERR_UNINITIALIZED;
    }

    HRESULT hr = S_OK;
    SPPHONEID pidArray[SP_MAX_PRON_LENGTH];
    pidArray[0] = L'\0';
    SPPHONEID *pidPos = pidArray;

    WCHAR szPhone[g_dwMaxLenPhone + 1];
    const WCHAR *p = pszIntPhone, *p1;

    while (SUCCEEDED(hr) && p)
    {
        // skip over leading spaces
        while (*p && *p == L' ')
            p++;
        if (!*p)
        {
            p = NULL;
            break;
        }
    
        if(m_fNoDelimiter)
        {
            p1 = p + 1;
        }
        else
        {
            p1 = wcschr(p, L' ');
            if(!p1)
            {
                p1 = p + wcslen(p);
            }
        }
        if(p1 - p > g_dwMaxLenPhone)
        {
            hr = E_INVALIDARG;
            break;
        }

        wcsncpy(szPhone, p, p1 - p);
        szPhone[p1 - p] = L'\0';

        // Search for this phone
        int i = 0;
        int j = m_dwPhones - 1;
        while (i <= j) 
        {
            int l = wcsicmp(szPhone, m_pPhoneId[(i+j)/2].szPhone);
            if (l > 0)
                i = (i+j)/2 + 1;
            else if (l < 0)
                j = (i+j)/2 - 1;
            else 
            {
                // found
                if ((pidPos - pidArray) > (SP_MAX_PRON_LENGTH - g_dwMaxLenId -1))
                    hr = E_FAIL;
                else
                {
                    wcscpy(pidPos, m_pPhoneId[(i+j)/2].pidPhone);
                    pidPos += wcslen(pidPos);
                }
                break;
            }
        }
    
        if (i > j)
            hr = E_INVALIDARG; // Phone not found
    
        p = p1;
    }
 
    if (SUCCEEDED(hr))
        hr = SPCopyPhoneString(pidArray, pId);

    return hr;
} /* CSpPhoneConverter::PhoneToId */

/*******************************************************************************
* CSpPhoneConverter::IdToPhone *
*-------------------------------*
*
*   Description:
*       Convert an Id code string to internal phone.
*       The output internal phones are space separated.
*
*   Return:
*       S_OK
*       E_POINTER
*       E_INVALIDARG
***************************************************************** YUNUSM ******/
STDMETHODIMP CSpPhoneConverter::IdToPhone(const SPPHONEID *pId,       // Id string
                                          WCHAR *pszIntPhone          // Returned Internal phone string
                                          )
{
    SPDBG_FUNC("CSpPhoneConverter::IdToPhone");

    if (SPIsBadStringPtr(pId))
    {
        return E_POINTER;
    }
    else if (wcslen(pId) >= SP_MAX_PRON_LENGTH)
    {
        return E_INVALIDARG;
    }
    else if (m_pPhoneId == NULL)
    {
        return SPERR_UNINITIALIZED;
    }

    HRESULT hr = S_OK;
    WCHAR szPhone[SP_MAX_PRON_LENGTH * (g_dwMaxLenPhone + 1)];
    DWORD nLen = wcslen (pId);
    DWORD nOffset = 0;
    WCHAR *p = szPhone;
    *p = NULL;
 
    while (SUCCEEDED(hr) && nLen)
    {
        SPPHONEID pidStr[g_dwMaxLenId +1];
        DWORD nCompare = (nLen > g_dwMaxLenId) ? g_dwMaxLenId : nLen;
        wcsncpy (pidStr, pId + nOffset, nCompare);
        pidStr[nCompare] = L'\0';
        for (;;)
        {
            int i = 0;
            int j = m_dwPhones - 1;
     
            while (i <= j) 
            {
                int cmp = wcscmp(m_pIdIdx[(i+j)/2]->pidPhone, pidStr);

                if(cmp > 0)
                {
                    j = (i+j)/2 - 1;
                }
                else if(cmp <0)
                {
                    i = (i+j)/2 + 1;
                }
                else
                {
                    break;
                }
            }
            
            if (i <= j)
            {
                // found

                // 2 for the seperating space and terminating NULL
                if ((DWORD)(p - szPhone) > (SP_MAX_PRON_LENGTH * (g_dwMaxLenPhone + 1) - g_dwMaxLenPhone - 2))
                    hr = E_FAIL;
                else
                {
                    if (!m_fNoDelimiter && p != szPhone)
                    {
                        wcscat (p, L" ");
                    }

                    // Check if its an Id that this phone-set doesnt care about
                    if (wcscmp(m_pIdIdx[(i+j)/2]->szPhone, L"##"))
                    {
                        wcscat (p, m_pIdIdx[(i+j)/2]->szPhone);
                        p += wcslen (p);
                    }
                    // Here 'p' is always pointing to a NULL so the above strcats work fine
                    break;
                }
            }
 
            pidStr[--nCompare] = L'\0';
            if (!nCompare)
            {
                *szPhone = NULL;
                hr = E_INVALIDARG;
                break;
            }
         
        } // for (;;)
    
        nLen -= nCompare;
        nOffset += nCompare;
    } // while (nLen)
 
    if (SUCCEEDED(hr))
        hr = SPCopyPhoneString(szPhone, pszIntPhone);

    return hr;
} /* CSpPhoneConverter::IdToPhone */

/*******************************************************************************
* ComparePhone *
*--------------*
*   Description:
*       Compares two internal phones
*   Result:
*       0, 1, -1
***************************************************************** YUNUSM ******/
int __cdecl ComparePhone(const void* p1, const void* p2)
{
    SPDBG_FUNC("ComparePhone");
    return wcsicmp(((PHONEMAPNODE*)p1)->szPhone, ((PHONEMAPNODE*)p2)->szPhone);
} /* ComparePhone */

/*******************************************************************************
* CompareId *
*-----------*
*   Description:
*       Compares two Id chars
*   Result:
*       0, 1, -1
***************************************************************** YUNUSM ******/
int CompareId(const void *p1, const void *p2)
{
    SPDBG_FUNC("CompareId");
    return wcscmp((*((PHONEMAPNODE**)p1))->pidPhone, (*((PHONEMAPNODE**)p2))->pidPhone);
} /* CompareId */

/*******************************************************************************
* CSpPhoneConverter::SetPhoneMap *
*--------------------------------*
*
*   Description:
*       Sets the phone map
*
*   Return:
*       S_OK
*       E_POINTER
*       E_INVALIDARG
*       E_OUTOFMEMORY
***************************************************************** YUNUSM ******/
HRESULT CSpPhoneConverter::SetPhoneMap(const WCHAR *pwMap, BOOL fNumericPhones)
{
    SPDBG_FUNC("CPhoneConv::SetPhoneMap");

    HRESULT hr = S_OK;
    const WCHAR *p = pwMap;
    DWORD k = 0;
 
    // Count the number of phones
    while (*p)
    {
        while (*p && *p == L' ')
            p++;

        if (!*p)
            break;

        m_dwPhones++;

        while (*p && *p != L' ')
            p++;
    }

    if (!m_dwPhones || m_dwPhones % 2 || m_dwPhones > 32000)
        hr = E_INVALIDARG;

    // Alloc the data structures
    if (SUCCEEDED(hr))
    {
        m_pPhoneId = new PHONEMAPNODE[m_dwPhones / 2];
        if (!m_pPhoneId) 
            hr = E_OUTOFMEMORY;
        else
            ZeroMemory(m_pPhoneId, sizeof(PHONEMAPNODE) * (m_dwPhones / 2));
    } 
 
    // Read the data
    if (SUCCEEDED(hr))
    {
        const WCHAR *pPhone = pwMap, *pEnd;
        for (k = 0; SUCCEEDED(hr) && k < m_dwPhones; k++) 
        {
            // Get the next phone
            while (*pPhone && *pPhone == L' ')
                pPhone++;

            pEnd = pPhone;
            while (*pEnd && *pEnd != L' ')
                pEnd++;

            if (!(k % 2))
            {
                if(fNumericPhones)
                {
                    // wchar phone but stored as a 4 character hex string
                    if ((pEnd - pPhone) % 4 ||
                        pEnd - pPhone > g_dwMaxLenPhone * 4)
                    {
                        hr = E_INVALIDARG;
                        continue;
                    }
                    WCHAR szId[(g_dwMaxLenPhone + 1) * 4];
                    wcsncpy(szId, pPhone, pEnd - pPhone);
                    szId[pEnd - pPhone] = L'\0';
    
                    // Convert the space separated hex values to array of WCHARS
                    ahtoi(szId, m_pPhoneId[k / 2].szPhone);
                }
                else
                {
                    // wchar phone
                    if (pEnd - pPhone > g_dwMaxLenPhone)
                    {
                        hr = E_INVALIDARG;
                        continue;
                    }
                    wcsncpy(m_pPhoneId[k / 2].szPhone, pPhone, pEnd - pPhone);
                    (m_pPhoneId[k / 2].szPhone)[pEnd - pPhone] = L'\0';
                }
            }
            else
            {
                // Id Phone
                if ((pEnd - pPhone) % 4 ||
                    pEnd - pPhone > g_dwMaxLenId * 4)
                {
                    hr = E_INVALIDARG;
                    continue;
                }

                WCHAR szId[(g_dwMaxLenId + 1) * 4];
                wcsncpy(szId, pPhone, pEnd - pPhone);
                szId[pEnd - pPhone] = L'\0';

                // Convert the space separated ids to array
                ahtoi(szId, (PWSTR)m_pPhoneId[k / 2].pidPhone);
            }
            pPhone = pEnd;
        }
    }
    
    // Build the indexes
    if (SUCCEEDED(hr))
    {
        m_dwPhones /= 2;
        // Sort the phone-Id table on phones
        qsort(m_pPhoneId, m_dwPhones, sizeof(PHONEMAPNODE), ComparePhone);
 
        // Create an index to search the phone-Id table on Id
        m_pIdIdx = (PHONEMAPNODE**)malloc(m_dwPhones * sizeof(PHONEMAPNODE*));
        if (!m_pIdIdx)
            hr = E_OUTOFMEMORY;
    }
 
    if (SUCCEEDED(hr))
    {
        // Initialize with indexes of Id phones in the Phone-Id table
        for (k = 0; k < m_dwPhones; k++)
            m_pIdIdx[k] = m_pPhoneId + k;
 
        // Sort on Id
        qsort(m_pIdIdx, m_dwPhones, sizeof(PHONEMAPNODE*), CompareId);
    }

    return hr;
} /* CSpPhoneConverter::SetPhoneMap */

/*******************************************************************************
* CSpPhoneConverter::ahtoi *
*--------------------------*
*   Description:
*       Convert space separated tokens to an array of shorts. This function is
*       used by the phone convertor object and the tools
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CSpPhoneConverter::ahtoi(WCHAR *pszTokens,                      // hex numbers as wchar string
                              WCHAR *pszHexChars                    // output WCHAR (hex) string
                              )
{
    WCHAR szInput[sizeof(SPPHONEID[g_dwMaxLenId + 1]) * 4];
    wcscpy (szInput, pszTokens);
    _wcslwr(szInput); // Internally convert this to lower case to make conversion easy
    pszTokens = szInput;

    *pszHexChars = 0;
    int nHexChars = 0;
    // Horner's rule
    while (*pszTokens) 
    {
        // Convert the token to its numeral form in a WCHAR
        WCHAR wHexVal = 0;
        bool fFirst = true;

        for (int i = 0; i < 4; i++)
        {
            SPDBG_ASSERT(*pszTokens);
            WCHAR k = *pszTokens;
            if (k >= L'a')
                k = 10 + k - L'a';
            else
                k -= L'0';

            if (fFirst)
                fFirst = false;
            else
                wHexVal *= 16;

            wHexVal += k;
            pszTokens++;
       }

       pszHexChars[nHexChars++] = wHexVal;
   }

   pszHexChars[nHexChars] = 0;
} /* CSpPhoneConverter::ahtoi */

#ifdef SAPI_AUTOMATION  

/*****************************************************************************
* CSpPhoneConverter::get_LanguageId *
*--------------------------------------*
*       
**************************************************************** Leonro ***/
STDMETHODIMP CSpPhoneConverter::get_LanguageId( SpeechLanguageId* LanguageId )
{
    SPDBG_FUNC("CSpPhoneConverter::get_LanguageId");
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( LanguageId ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // Only return the LanguageId if the phoneconv has been initialized with a language
        if( m_pPhoneId == NULL )
        {
            return SPERR_UNINITIALIZED;
        }
        else
        {
            *LanguageId = (SpeechLanguageId)m_LangId;
        }
    }

    return hr;
} /* CSpPhoneConverter::get_LanguageId */
 
/*****************************************************************************
* CSpPhoneConverter::put_LanguageId *
*--------------------------------------*
*       
**************************************************************** Leonro ***/
STDMETHODIMP CSpPhoneConverter::put_LanguageId( SpeechLanguageId LanguageId )
{
    SPDBG_FUNC("CSpPhoneConverter::put_LanguageId");
    HRESULT                      hr = S_OK;
    CComPtr<IEnumSpObjectTokens> cpEnum;
    CComPtr<ISpObjectToken>      cpPhoneConvToken;
    WCHAR                        szLang[MAX_PATH];
    WCHAR                        szLangCondition[MAX_PATH];
    
    SpHexFromUlong( szLang, LanguageId );
    
    wcscpy( szLangCondition, L"Language=" );
    wcscat( szLangCondition, szLang );
    
    // Delete any internal phone to Id tables that have been set previously
    if( m_cpObjectToken )
    {
        delete [] m_pPhoneId;
        free(m_pIdIdx);
        m_dwPhones = 0;
        m_cpObjectToken.Release();
    }

    // Get the token enumerator
    hr = SpEnumTokens( SPCAT_PHONECONVERTERS, szLangCondition, L"VendorPreferred", &cpEnum);
    
    // Get the actual token
    if (SUCCEEDED(hr))
    {
        hr = cpEnum->Next(1, &cpPhoneConvToken, NULL);
        if (hr == S_FALSE)
        {
            cpPhoneConvToken = NULL;
            hr = SPERR_NOT_FOUND;
        }
    }

    // Set the token on the PhoneConverter
    if( SUCCEEDED( hr ) )
    {
        hr = SetObjectToken( cpPhoneConvToken );
    }

    if( SUCCEEDED( hr ) )
    {
        m_LangId = (LANGID)LanguageId;
    }

    return hr;
} /* CSpPhoneConverter::put_LanguageId */
 

/*****************************************************************************
* CSpPhoneConverter::PhoneToId *
*--------------------------------------*
*       
**************************************************************** Leonro ***/
STDMETHODIMP CSpPhoneConverter::PhoneToId( const BSTR Phonemes, VARIANT* IdArray )
{
    SPDBG_FUNC("CSpPhoneConverter::PhoneToId");
    HRESULT hr = S_OK;
    int     numPhonemes = 0;
    
    if( SP_IS_BAD_STRING_PTR( Phonemes ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_WRITE_PTR( IdArray ) )
    {
        hr = E_POINTER;
    }
    else
    {
        SPPHONEID   pidArray[SP_MAX_PRON_LENGTH]={0};

        hr = PhoneToId( Phonemes, pidArray );
        
        if( SUCCEEDED( hr ) )
        {
            BYTE *pArray;
            numPhonemes = wcslen( pidArray );
            SAFEARRAY* psa = SafeArrayCreateVector( VT_I2, 0, numPhonemes );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy(pArray, pidArray, numPhonemes*sizeof(SPPHONEID) );
                    SafeArrayUnaccessData( psa );
                    VariantClear(IdArray);
                    IdArray->vt     = VT_ARRAY | VT_I2;
                    IdArray->parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
} /* CSpPhoneConverter::PhoneToId */
 
/*****************************************************************************
* CSpPhoneConverter::IdToPhone *
*--------------------------------------*
*       
**************************************************************** Leonro ***/
STDMETHODIMP CSpPhoneConverter::IdToPhone( const VARIANT IdArray, BSTR* Phonemes )
{
    SPDBG_FUNC("CSpPhoneConverter::IdToPhone");
    HRESULT hr = S_OK;
    unsigned short*      pIdArray;
    
    if( SP_IS_BAD_WRITE_PTR( Phonemes ) )
    {
        hr = E_POINTER;
    }
    else
    {   
        WCHAR  pszwPhone[SP_MAX_PRON_LENGTH * (g_dwMaxLenPhone + 1)] = L"";
        SPPHONEID*   pIds;

        hr = VariantToPhoneIds(&IdArray, &pIds);

        if( SUCCEEDED( hr ) )
        {
            hr = IdToPhone( pIds, pszwPhone );
            delete pIds;
        }

        if( SUCCEEDED( hr ) )
        {
            CComBSTR    bstrPhone( pszwPhone ); 
            *Phonemes = bstrPhone.Detach();
        }
    }

    return hr;
} /* CSpPhoneConverter::IdToPhone */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\objecttokencategory.h ===
/****************************************************************************
*   ObjectTokenCategory.h
*       Declarations for the CSpObjectTokenCategory class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "sapi.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CSpObjectTokenCategory : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpObjectTokenCategory, &CLSID_SpObjectTokenCategory>,
#ifdef SAPI_AUTOMATION
    public IDispatchImpl<ISpeechObjectTokenCategory, &IID_ISpeechObjectTokenCategory, &LIBID_SpeechLib, 5>,
#endif // SAPI_AUTOMATION
    public ISpObjectTokenCategory
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_OBJECTTOKENCATEGORY)

    BEGIN_COM_MAP(CSpObjectTokenCategory)
        COM_INTERFACE_ENTRY(ISpObjectTokenCategory)
        COM_INTERFACE_ENTRY(ISpDataKey)
#ifdef SAPI_AUTOMATION
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISpeechObjectTokenCategory)
#endif
    END_COM_MAP()

//=== Methods ===
public:

    //--- Ctor, dtor
    CSpObjectTokenCategory();
    ~CSpObjectTokenCategory();

//=== Interfaces ===
public:

    //--- ISpObjectTokenCategory ----------------------------------------------    
    STDMETHODIMP SetId(const WCHAR * pszCategoryId, BOOL fCreateIfNotExist);
    STDMETHODIMP GetId(WCHAR ** ppszCoMemCategoryId);
    STDMETHODIMP GetDataKey(SPDATAKEYLOCATION spdkl, ISpDataKey ** ppDataKey);

    STDMETHODIMP EnumTokens(
                    const WCHAR * pszReqAttribs, 
                    const WCHAR * pszOptAttribs, 
                    IEnumSpObjectTokens ** ppEnum);

    STDMETHODIMP SetDefaultTokenId(const WCHAR * pszTokenId);
    STDMETHODIMP GetDefaultTokenId(WCHAR ** ppszCoMemTokenId);

    //--- ISpDataKey ----------------------------------------------------------
    STDMETHODIMP SetData(const WCHAR * pszKeyName, ULONG cbData, const BYTE * pData);
    STDMETHODIMP GetData(const WCHAR * pszKeyName, ULONG * pcbData, BYTE * pData);
    STDMETHODIMP GetStringValue(const WCHAR * pszKeyName, WCHAR ** ppValue);
    STDMETHODIMP SetStringValue(const WCHAR * pszKeyName, const WCHAR * pszValue);
    STDMETHODIMP SetDWORD(const WCHAR * pszKeyName, DWORD dwValue );
    STDMETHODIMP GetDWORD(const WCHAR * pszKeyName, DWORD *pdwValue );
    STDMETHODIMP OpenKey(const WCHAR * pszSubKeyName, ISpDataKey ** ppKey);
    STDMETHODIMP CreateKey(const WCHAR * pszSubKeyName, ISpDataKey ** pKey);
    STDMETHODIMP DeleteKey(const WCHAR * pszSubKeyName);
    STDMETHODIMP DeleteValue(const WCHAR * pszValueName);
    STDMETHODIMP EnumKeys(ULONG Index, WCHAR ** ppszSubKeyName);
    STDMETHODIMP EnumValues(ULONG Index, WCHAR ** ppszValueName);

#ifdef SAPI_AUTOMATION
    //--- ISpeechDataKey is provided by the CSpRegDataKey class -------------------------------------

    //--- ISpeechObjectTokenCategory --------------------------------------------------
	STDMETHOD( get_Id )(BSTR * pbstrCategoryId);
	STDMETHOD( put_Default )(const BSTR bstrTokenId);
	STDMETHOD( get_Default )(BSTR * pbstrTokenId);
	STDMETHOD( SetId )(const BSTR bstrCategoryId, VARIANT_BOOL fCreateIfNotExist);
	STDMETHOD( GetDataKey )(SpeechDataKeyLocation Location, ISpeechDataKey ** ppDataKey);
	STDMETHOD( EnumerateTokens )( BSTR bstrReqAttrs, BSTR bstrOptAttrs, ISpeechObjectTokens** ppColl );
#endif // SAPI_AUTOMATION


//=== Private methods ===
private:

    HRESULT InternalGetDefaultTokenId(WCHAR ** ppszCoMemTokenId, BOOL fExpandToRealTokenId);
    HRESULT InternalEnumTokens(
                const WCHAR * pszReqAttribs, 
                const WCHAR * pszOptAttribs, 
                IEnumSpObjectTokens ** ppEnum,
                BOOL fPutDefaultFirst);
    
    HRESULT GetDataKeyWhereDefaultTokenIdIsStored(ISpDataKey ** ppDataKey);

//=== Private data ===
private:

    CSpDynamicString    m_dstrCategoryId;
    CComPtr<ISpDataKey> m_cpDataKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\queuenode.h ===
#pragma once

template <class T>
class CSpQueueNode
{
public:

    CSpQueueNode(T * p) : m_p(p), m_pNext(NULL) {};
    
    T * m_p;
    CSpQueueNode<T> * m_pNext;

    static LONG Compare(CSpQueueNode<T> * p1, CSpQueueNode<T> * p2)
    {
        return T::Compare(p1->m_p, p2->m_p);
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\recoctxt.cpp ===
// RecoCtxt.cpp : Implementation of CRecoCtxt
#include "stdafx.h"
#include "Sapi.h"
#include "RecoCtxt.h"
#include "Recognizer.h"
#include "spphrase.h"
#include "srgrammar.h"
#include "srtask.h"
#include "a_recocp.h"
#include "a_helpers.h"



/////////////////////////////////////////////////////////////////////////////
// CRecoCtxt

/****************************************************************************
* CRecoCtxt::PrivateCallQI *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT WINAPI CRecoCtxt::PrivateCallQI(void* pvThis, REFIID riid, LPVOID* ppv, DWORD_PTR dw)
{
    SPDBG_FUNC("CRecoCtxt::PrivateCallQI");
    HRESULT hr = S_OK;

    CRecoCtxt *pThis = (CRecoCtxt*)pvThis;
    if (pThis->m_bCreatingAgg)
    {
        *ppv = static_cast<_ISpPrivateEngineCall*>(pThis);  // don't ref count, because we don't want the
                                               // aggregated object to prevent release
    }
    else
    {
        *ppv = NULL;
        hr = S_FALSE;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::ExtensionQI *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT WINAPI CRecoCtxt::ExtensionQI(void* pvThis, REFIID riid, LPVOID* ppv, DWORD_PTR dw)
{
    SPDBG_FUNC("CRecoCtxt::ExtensionQI");
    HRESULT hr = S_OK;

    CRecoCtxt *pThis = (CRecoCtxt*)pvThis;

    if (riid != __uuidof(_ISpPrivateEngineCall))
    {
        pThis->Lock();
        if (pThis->m_cpExtension == NULL && pThis->m_clsidExtension != GUID_NULL)
        {
            pThis->m_bCreatingAgg = TRUE;
            hr = pThis->m_cpExtension.CoCreateInstance(pThis->m_clsidExtension, pThis->GetControllingUnknown(), CLSCTX_INPROC_SERVER);
            pThis->m_bCreatingAgg = FALSE;
        }
        if (pThis->m_cpExtension)
        {
            hr = pThis->m_cpExtension->QueryInterface(riid, ppv);
        }
        pThis->Unlock();
    }
    else
    {
        *ppv = NULL;
        hr = S_FALSE;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/*****************************************************************************
* CRecoCtxt::CRecoCtxt *
*-------------------*
*   Description:
*       Constructor for the CRecoCtxt object which simply initializes various
*       members.
********************************************************************* RAP ***/
CRecoCtxt::CRecoCtxt():
    m_SpEventSource_Context(this),
    m_hRecoInstContext(NULL),
    m_pszhypothesis(NULL),
    m_hypsize(0),
    m_hyplen(0),
    m_bCreatingAgg(FALSE),
    m_ullEventInterest(0),
    m_ullVoicePurgeInterest(0),
    m_fRetainAudio(FALSE),
    m_cMaxAlternates(0),
    m_clsidExtension(GUID_NULL),
    m_State(SPCS_ENABLED),
    m_fHandlingEvent(FALSE)
{
    SpZeroStruct(m_Stat);
}

/*****************************************************************************
* CRecoCtxt::FinalRelease *
*-------------------------*
*   Description:
*       This method handles the release of the recognition context object.
*       It disconnects from the engine object.
********************************************************************* RAP ***/
void CRecoCtxt::FinalRelease()
{
    SPDBG_FUNC( "CRecoCtxt::FinalRelease" );

    m_cpExtension.Release();    // release the extension first in case it wants to
                                // call the engine
    if (m_cpRecognizer)
    {
        HRESULT hrDelete = CRCT_DELETECONTEXT::DeleteContext(this);
        SPDBG_ASSERT(SUCCEEDED(hrDelete));
        m_cpRecognizer->RemoveRecoContextFromList(this);
    }
}


/*****************************************************************************
* CRecoCtxt::SetVoicePurgeEvent *
*-------------------------------*
*   Description:
*       This method sets the SR event(s) which will stop audio output from the
*       ISpVoice. It passes the events as
*       extra event interests to the engine. When such an event occurs it will
*       be passed to this context on EventNotify or Recognition notify where
*       the voice is flushed.
***************************************************************** DAVEWOOD ***/
STDMETHODIMP CRecoCtxt::SetVoicePurgeEvent(ULONGLONG ullEventInterest)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC( "CRecoCtxt::SetVoicePurgeEvent" );
    HRESULT hr = S_OK;

    if(ullEventInterest && ((ullEventInterest & ~SPFEI_ALL_SR_EVENTS) ||
        (SPFEI_FLAGCHECK != (ullEventInterest & SPFEI_FLAGCHECK))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_ullVoicePurgeInterest = ullEventInterest;
        hr = CRCT_SETEVENTINTEREST::SetEventInterest(this, m_ullVoicePurgeInterest | m_ullEventInterest);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/*****************************************************************************
* CRecoCtxt::GetVoicePurgeEvent *
*-------------------------------*
*   Description: 
*       Returns whatever is set as the current VoicePurgeEvents
***************************************************************** DAVEWOOD ***/
STDMETHODIMP CRecoCtxt::GetVoicePurgeEvent(ULONGLONG *pullEventInterest)
{
    SPDBG_FUNC( "CRecoCtxt::GetVoicePurgeEvent" );
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    HRESULT hr = S_OK;
    if(SP_IS_BAD_WRITE_PTR(pullEventInterest))
    {
        hr = E_POINTER;
    }
    else
    {
        *pullEventInterest = m_ullVoicePurgeInterest;
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/*****************************************************************************
* CRecoCtxt::SetInterest *
*------------------------*
*   Description:
*       This method sets the events the app is interested in. The same events
*       are sent to both the engine and associated CRecoCtxtVoice.   
***************************************************************** DAVEWOOD ***/
STDMETHODIMP CRecoCtxt::SetInterest(ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest)
{
    SPDBG_FUNC( "CRecoCtxt::SetInterest" );
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    HRESULT hr = S_OK;

    if(ullEventInterest && ((ullEventInterest & ~SPFEI_ALL_SR_EVENTS) ||
        (SPFEI_FLAGCHECK != (ullEventInterest & SPFEI_FLAGCHECK))))
    {
        hr = E_INVALIDARG;
    }
    else if(ullQueuedInterest && ((ullQueuedInterest & ~SPFEI_ALL_SR_EVENTS) ||
        (SPFEI_FLAGCHECK != (ullQueuedInterest & SPFEI_FLAGCHECK))))
    {
        hr = E_INVALIDARG;
    }
    else if ((ullQueuedInterest | ullEventInterest) != ullEventInterest)
    {
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr))
    {
        m_ullEventInterest = ullEventInterest;
        m_ullQueuedInterest = ullQueuedInterest;
        // EventSource will only forward SetInterest events to app
        hr = m_SpEventSource_Context._SetInterest(m_ullEventInterest, ullQueuedInterest);
    }

    if (SUCCEEDED(hr))
    {
        // inform engine of interest in both SetInterest events and SetVoicePurgeEvent
        hr = CRCT_SETEVENTINTEREST::SetEventInterest(this, m_ullVoicePurgeInterest | m_ullEventInterest);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/*****************************************************************************
* CRecoCtxt::GetVoice *
*---------------------*
*   Description:
*       This method creates the associated ISpVoice object.
***************************************************************** DAVEWOOD ***/
STDMETHODIMP CRecoCtxt::GetVoice(ISpVoice **ppVoice)
{
    SPDBG_FUNC( "CRecoCtxt::GetVoice" );
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    HRESULT hr = S_OK;

    if(SP_IS_BAD_WRITE_PTR(ppVoice))
    {
        return E_POINTER;
    }
    *ppVoice = NULL;

    if(!m_cpVoice)
    {
        CComPtr<ISpVoice> cpVoice;
        hr = cpVoice.CoCreateInstance(CLSID_SpVoice);
        if(SUCCEEDED(hr))
        {
            hr = _SetVoiceFormat(cpVoice);
            if(SUCCEEDED(hr))
            {
                m_cpVoice = cpVoice;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        *ppVoice = m_cpVoice;
        (*ppVoice)->AddRef();
        m_fAllowVoiceFormatChanges = TRUE;
    }

    return hr;
}

/*****************************************************************************
* CRecoCtxt::SetVoice *
*---------------------*
*   Description:
*       This method the associated ISpVoice to the given object. If
*       fAllowFormatChanges will alter voice format to the given engine format.
***************************************************************** DAVEWOOD ***/
STDMETHODIMP CRecoCtxt::SetVoice(ISpVoice *pVoice, BOOL fAllowFormatChanges)
{
    SPDBG_FUNC( "CRecoCtxt::SetVoice" );
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    HRESULT hr = S_OK;

    if(SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pVoice))
    {
        return E_POINTER;
    }
    
    if(pVoice && fAllowFormatChanges)
    {
        hr = _SetVoiceFormat(pVoice);
    }

    if(SUCCEEDED(hr))
    {
        m_fAllowVoiceFormatChanges = fAllowFormatChanges;
        m_cpVoice = pVoice; // AddRefs
    }

    return hr;
}    


/*****************************************************************************
* CRecoCtxt::_SetVoiceFormat *
*----------------------------*
*   Description:
*       Sets the voice audio format to the current format for the engine.
*       If no format yet set then do nothing.
***************************************************************** DAVEWOOD ***/

HRESULT CRecoCtxt::_SetVoiceFormat(ISpVoice *pVoice)
{
    HRESULT hr = S_OK;

    CSpStreamFormat NewFmt;

    CComQIPtr<ISpRecognizer> cpReco(m_cpRecognizer);
    hr = cpReco->GetFormat(SPWF_INPUT, &NewFmt.m_guidFormatId, &NewFmt.m_pCoMemWaveFormatEx);
    if(hr == SPERR_UNINITIALIZED)
    {
        hr = cpReco->GetFormat(SPWF_SRENGINE, &NewFmt.m_guidFormatId, &NewFmt.m_pCoMemWaveFormatEx);
    }
    if(SUCCEEDED(hr) && NewFmt.m_guidFormatId != GUID_NULL)
    {
        CComPtr<ISpAudio> cpDefaultAudio;
        hr = SpCreateDefaultObjectFromCategoryId(SPCAT_AUDIOOUT, &cpDefaultAudio);
        if (SUCCEEDED(hr))
        {
            hr = cpDefaultAudio->SetFormat(NewFmt.FormatId(), NewFmt.WaveFormatExPtr());
        }
        if (SUCCEEDED(hr))
        {
            hr = pVoice->SetOutput(cpDefaultAudio, FALSE);     // Force this format to stick
        }
    }

    return hr;
}

/*****************************************************************************
* CRecoCtxt::GetInterests *
*-----------------------*
*   Description:
*       This method gets the currently set event interests on the CRecoCtxt.
*
********************************************************************* Leonro ***/
HRESULT CRecoCtxt::GetInterests(ULONGLONG* pullInterests, ULONGLONG* pullQueuedInterests)
{
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pullInterests ) || SP_IS_BAD_OPTIONAL_WRITE_PTR( pullQueuedInterests ))
    {
        hr = E_POINTER;
    }
    else
    {
        if( pullInterests )
        {
            *pullInterests = m_SpEventSource_Context.m_ullEventInterest;
        }

        if( pullQueuedInterests )
        {
            *pullQueuedInterests = m_SpEventSource_Context.m_ullQueuedInterest;
        }
    }

    return hr;
} /* CRecoCtxt::GetInterests */

/****************************************************************************
* CRecoCtxt::SetContextState *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::SetContextState(SPCONTEXTSTATE eContextState)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::SetContextState");
    HRESULT hr = S_OK;
    
    if (eContextState != SPCS_DISABLED &&
        eContextState != SPCS_ENABLED)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_State != eContextState)
        {
            hr = CRCT_SETCONTEXTSTATE::SetContextState(this, eContextState);
            if (SUCCEEDED(hr))
            {
                m_State = eContextState;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::GetContextState *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::GetContextState(SPCONTEXTSTATE * pState)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::GetContextState");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pState))
    {
        hr = E_POINTER;
    }
    else
    {
        *pState = m_State;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

    

/*****************************************************************************
* CRecoCtxt::GetStatus *
*----------------------*
*   Description:
*       This method returns current state information about a context. 
********************************************************************* RAP ***/

STDMETHODIMP CRecoCtxt::GetStatus(SPRECOCONTEXTSTATUS *pStatus)
{
    SPAUTO_OBJ_LOCK;    // Take the event queue critical seciton to access m_Stat;

    SPDBG_FUNC( "CRecoCtxt::GetStatus" );
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pStatus))
    {
        hr = E_POINTER;
    }
    else
    {
        *pStatus = m_Stat;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::DeserializeResult *
*------------------------------*
*   Description:
*       This method creates a new result object.
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::DeserializeResult(const SPSERIALIZEDRESULT * pSerializedResult, ISpRecoResult ** ppResult)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::DeserializeResult");
    HRESULT hr = S_OK;
    const ULONG cb = pSerializedResult->ulSerializedSize;
    const SPRESULTHEADER * pCallersHeader = (const SPRESULTHEADER *)pSerializedResult;

    if (SP_IS_BAD_READ_PTR(pSerializedResult) ||
        SPIsBadReadPtr(pSerializedResult, cb) ||
        pCallersHeader->cbHeaderSize != sizeof(SPRESULTHEADER))
    {
        hr = E_INVALIDARG;  
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(ppResult))
        {
            hr = E_POINTER;
        }
        else
        {
            *ppResult = NULL;
            SPRESULTHEADER * pResultHeader = (SPRESULTHEADER *)::CoTaskMemAlloc(cb);
            if (pResultHeader)
            {
                CSpResultObject * pNewResult;
                hr = CSpResultObject::CreateInstance(&pNewResult);
                if (SUCCEEDED(hr))
                {
                    memcpy(pResultHeader, pSerializedResult, cb);
                    hr = pNewResult->Init(this, pResultHeader);
                    pNewResult->AddRef();
                    if (SUCCEEDED(hr))
                    {
                        *ppResult = pNewResult; // Give object ref to caller
                    }
                    else
                    {
                        pNewResult->Release();
                    }
                }
                else
                {
                    ::CoTaskMemFree(pResultHeader);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::Bookmark *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::Bookmark(SPBOOKMARKOPTIONS Options, ULONGLONG ullStreamPosition, LPARAM lParamEvent)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::Bookmark");
    HRESULT hr = S_OK;
    
    if (Options != SPBO_NONE && Options != SPBO_PAUSE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRCT_BOOKMARK::Bookmark(this, Options, ullStreamPosition, lParamEvent);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoCtxt::SetAdaptationData *
*------------------------------*
*   Description:
*
*   Returns:
*
**************************************************************** PhilSch ***/

STDMETHODIMP CRecoCtxt::SetAdaptationData(const WCHAR *pAdaptationData, const ULONG cch)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::SetAdaptationData");
    HRESULT hr = S_OK;

    if ((cch && SPIsBadReadPtr(pAdaptationData, sizeof(*pAdaptationData)*cch)) ||
        ((pAdaptationData == NULL) && (cch != 0)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRCT_ADAPTATIONDATA::SetAdaptationData(this, pAdaptationData, cch);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRecoCtxt::Pause *
*------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::Pause(DWORD dwReserved)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::Pause");
    HRESULT hr = S_OK;

    if (dwReserved)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRCT_PAUSECONTEXT::Pause(this);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::Resume *
*-------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::Resume(DWORD dwReserved)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::Resume");
    HRESULT hr = S_OK;

    if (dwReserved)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRCT_RESUMECONTEXT::Resume(this);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/*****************************************************************************
* CRecoCtxt::GetRecognizer *
*----------------------------*
*   Description:
*       This method returns a reference to the current engine object.
********************************************************************* RAP ***/
STDMETHODIMP CRecoCtxt::GetRecognizer(ISpRecognizer ** ppRecognizer)
{
    SPDBG_FUNC( "CRecoCtxt::GetRecognizer" );
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppRecognizer))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_cpRecognizer.QueryInterface(ppRecognizer);
    }
    return hr;
}

/****************************************************************************
* CRecoCtxt::GetMaxAlternates *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::GetMaxAlternates(ULONG * pcMaxAlternates)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::GetMaxAlternates");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pcMaxAlternates))
    {
        hr = E_POINTER;
    }
    else
    {
        *pcMaxAlternates = m_cMaxAlternates;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::SetMaxAlternates *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::SetMaxAlternates(ULONG cMaxAlternates)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::SetMaxAlternates");
    HRESULT hr = S_OK;

    m_cMaxAlternates = cMaxAlternates;
    hr = CRCT_SETMAXALTERNATES::SetMaxAlternates(this, cMaxAlternates);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRecoCtxt::GetAudioOptions *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::GetAudioOptions(SPAUDIOOPTIONS * pOptions, GUID *pAudioFormatId, WAVEFORMATEX **ppCoMemWFEX)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::GetAudioOptions");
    HRESULT hr = S_OK;

    if (pOptions)
    {
        if (SP_IS_BAD_WRITE_PTR(pOptions))
        {
            hr = E_POINTER;
        }
        else
        {
            *pOptions = m_fRetainAudio ? SPAO_RETAIN_AUDIO : SPAO_NONE;
        }
    }

    if (SUCCEEDED(hr) && pAudioFormatId)
    {
        hr = m_RetainedFormat.ParamValidateCopyTo(pAudioFormatId, ppCoMemWFEX);
        if (m_RetainedFormat.m_guidFormatId == GUID_NULL)
        {
            // Lazy init to engine format.
            CSpStreamFormat NewFmt;
            CComQIPtr<ISpRecognizer> cpReco(m_cpRecognizer);
            HRESULT hr1 = cpReco->GetFormat(SPWF_INPUT, &NewFmt.m_guidFormatId, &NewFmt.m_pCoMemWaveFormatEx);        
            if (SUCCEEDED(hr1))
            {
                hr = NewFmt.ParamValidateCopyTo(pAudioFormatId, ppCoMemWFEX);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::SetAudioOptions *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::SetAudioOptions(SPAUDIOOPTIONS Options, const GUID *pAudioFormatId, const WAVEFORMATEX *pWaveFormatEx)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::SetAudioOptions");
    HRESULT hr = S_OK;

    if (Options != SPAO_NONE && Options != SPAO_RETAIN_AUDIO)
    {
        hr = E_INVALIDARG;
    }
    else if (pAudioFormatId == NULL && pWaveFormatEx == NULL)
    {
        // Don't do anything to format - leave as is.
    }
    else if (*pAudioFormatId == GUID_NULL && pWaveFormatEx == NULL)
    {
        // Set format to engine format.
        CSpStreamFormat NewFmt;
        CComQIPtr<ISpRecognizer> cpReco(m_cpRecognizer);
        hr = cpReco->GetFormat(SPWF_INPUT, &NewFmt.m_guidFormatId, &NewFmt.m_pCoMemWaveFormatEx);
        if(hr == SPERR_UNINITIALIZED)
        {
            hr = m_RetainedFormat.ParamValidateAssignFormat(GUID_NULL, NULL, FALSE);
        }
        else
        {
            hr = m_RetainedFormat.ParamValidateAssignFormat(NewFmt.m_guidFormatId, NewFmt.m_pCoMemWaveFormatEx, FALSE);
        }
    }
    else
    {
        // Set to supplied format which is required to be a waveformatex format.
        hr = m_RetainedFormat.ParamValidateAssignFormat(*pAudioFormatId, pWaveFormatEx, TRUE);
    }
    if (SUCCEEDED(hr))
    {
        if ((Options == SPAO_NONE && m_fRetainAudio) ||
            (Options == SPAO_RETAIN_AUDIO && (!m_fRetainAudio)))
        {
            m_fRetainAudio = (Options == SPAO_RETAIN_AUDIO);
            hr = CRCT_SETRETAINAUDIO::SetRetainAudio(this, m_fRetainAudio);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}




/****************************************************************************
* CRecoCtxt::CreateGrammar *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::CreateGrammar(ULONGLONG ullGrammarId, ISpRecoGrammar ** ppGrammar)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::CreateGrammar");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppGrammar))
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CRecoGrammar> *pGrm;
        hr = CComObject<CRecoGrammar>::CreateInstance(&pGrm);
        if (SUCCEEDED(hr))
        {
            pGrm->AddRef();
            hr = pGrm->Init(this, ullGrammarId);
            if (SUCCEEDED(hr))
            {
                *ppGrammar = pGrm;
            }
            else
            {
                *ppGrammar = NULL;
                pGrm->Release();
            }
        }
    }
 
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoCtxt::Init *
*-----------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoCtxt::Init(_ISpRecognizerBackDoor * pParent)
{
    SPDBG_FUNC("CRecoCtxt::InitInprocRecognizer");
    HRESULT hr = S_OK;
    WCHAR *pszRequestTypeOfUI;

    hr = CRIT_CREATECONTEXT::CreateContext(pParent, &m_hRecoInstContext, &pszRequestTypeOfUI);

    if (SUCCEEDED(hr))
    {
        wcscpy(m_Stat.szRequestTypeOfUI, pszRequestTypeOfUI);
        ::CoTaskMemFree(pszRequestTypeOfUI);

        CComQIPtr<ISpRecognizer> cpRecognizer(pParent);
        SPDBG_ASSERT(cpRecognizer);
        CComPtr<ISpObjectToken> cpEngineToken;
        hr = cpRecognizer->GetRecognizer(&cpEngineToken);
        if (SUCCEEDED(hr))
        {
            CSpDynamicString dstrGUID;
            if (SUCCEEDED(cpEngineToken->GetStringValue(SPRECOEXTENSION, &dstrGUID)))
            {
                hr = CLSIDFromString(dstrGUID, &m_clsidExtension);
            }
        }
        if (FAILED(hr))
        {
            SPDBG_ASSERT(false);
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pParent->AddRecoContextToList(this);
    }
    if (SUCCEEDED(hr))
    {
        m_cpRecognizer = pParent;
    }
    
    if (SUCCEEDED(hr))
    {
        m_ullEventInterest = SPFEI(SPEI_RECOGNITION);
        m_ullQueuedInterest = SPFEI(SPEI_RECOGNITION);
        hr = CRCT_SETEVENTINTEREST::SetEventInterest(this, m_ullEventInterest);
        if (SUCCEEDED(hr))
        {
            hr = m_SpEventSource_Context._SetInterest(m_ullEventInterest, m_ullEventInterest);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/*****************************************************************************
* CRecoCtxt::_DoVoicePurge *
*--------------------------*
*   Description:
*       Does the actual flushing of any TTS output. Called when the 
*       SetVoicePurgeEvent has triggered.
***************************************************************** DAVEWOOD ***/
HRESULT CRecoCtxt::_DoVoicePurge(void)
{
    HRESULT hr=S_OK;

    if(m_cpVoice)
    {
        hr = m_cpVoice->Speak(NULL, SPF_PURGEBEFORESPEAK, NULL); // purges output
    }
    
    return hr;
}


/*****************************************************************************
* CRecoCtxt::RecognitionNotify *
*------------------------------*
*   Description:
*       This method handle the recognition notification that come from the
*       engine object.  It creates a result object and adds it to the event
*       queue.
********************************************************************* RAP ***/

STDMETHODIMP CRecoCtxt::RecognitionNotify(SPRESULTHEADER *pResultHdr, WPARAM wParamEvent, SPEVENTENUM eEventId)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CRecoCtxt::RecognitionNotify" );
    HRESULT hr = S_OK;
    CSpResultObject *pNode;

    SPDBG_ASSERT(pResultHdr->ulSerializedSize);

    // Stop audio output if required
    if((1ui64 << eEventId) & m_ullVoicePurgeInterest)
    {
        hr = _DoVoicePurge();
    }

    // Add event if required
    if((1ui64 << eEventId) & m_ullEventInterest)
    {
        SPINTERNALSERIALIZEDPHRASE *pPhraseData = reinterpret_cast<SPINTERNALSERIALIZEDPHRASE*>(((BYTE*)pResultHdr) + pResultHdr->ulPhraseOffset);

        hr = CSpResultObject::CreateInstance(&pNode);
        if (SUCCEEDED(hr))
        {
            pNode->AddRef();
            hr = pNode->Init(this, pResultHdr);
            if (SUCCEEDED(hr))
            {

                // While the event is in the queue, make the reference a weak
                // reference, otherwise, if somebody releases the ctxt with 
                // a result in the queue, the context won't be released.
                pNode->WeakCtxtRef(TRUE);
                
                SPEVENT Event;
                Event.eEventId = eEventId;
                Event.elParamType = SPET_LPARAM_IS_OBJECT;
                Event.ulStreamNum = pResultHdr->ulStreamNum;
                Event.ullAudioStreamOffset = pResultHdr->ullStreamPosEnd;
                Event.wParam = wParamEvent;
                Event.lParam = LPARAM(pNode);

                // WARNING -- Past this point, pResultHdr could have changed do to a realloc
                // caused by the ScaleAudio method.  Do not use it past this point...
                if (pResultHdr->ulRetainedDataSize != 0)
                {
                    ULONG cbFormatHeader;
                    CSpStreamFormat cpStreamFormat;
                    hr = cpStreamFormat.Deserialize(((BYTE*)pResultHdr) + pResultHdr->ulRetainedOffset, &cbFormatHeader);
                    if (SUCCEEDED(hr) &&
                        m_RetainedFormat.FormatId() != GUID_NULL &&
                        m_RetainedFormat != cpStreamFormat)
                    {
                        // Do not let format conversion failures (if any) affect notifications
                        hr = pNode->ScaleAudio(&(m_RetainedFormat.m_guidFormatId), m_RetainedFormat.WaveFormatExPtr());
                        if (FAILED(hr))
                        {
                            if (hr == SPERR_UNSUPPORTED_FORMAT)
                            {
                                // Engine format is not waveformatex. Strip retained audio from result.
                                hr = pNode->Discard(SPDF_AUDIO);
                            }
                            else
                            {
                                SPDBG_ASSERT(SUCCEEDED(hr));
                                // Do not let format conversion failures (if any) affect notifications.
                                hr = S_OK;
                            }
                        }
                    }
                    else
                    {
                        // Retained audio doesn't need scaling but we need to scale input stream
                        // positions/sizes in phrase and its elements back to app stream format.
                        pNode->ScalePhrase();
                    }
                    if (m_RetainedFormat.FormatId() == GUID_NULL)
                    {
                        // Lazy init retained audio format to engine format.
                        HRESULT hr1 = m_RetainedFormat.ParamValidateAssignFormat(cpStreamFormat.m_guidFormatId, cpStreamFormat.WaveFormatExPtr(), FALSE);
                    }
                }
                else
                {
                    // Even if audio isn't being retained, we need to scale input stream
                    // positions/sizes in phrase and its elements back to app stream format.
                    pNode->ScalePhrase();
                }
                m_SpEventSource_Context._AddEvent(Event);   // This AddRef's the result again.
                m_SpEventSource_Context._CompleteEvents();
            }
            pNode->Release();
        }
        else
        {
            ::CoTaskMemFree(pResultHdr);   // we failed to create a result object, so free the result blob
        }
    }
    else
    {
        ::CoTaskMemFree(pResultHdr);   // we didn't create a result object, so free the result blob
    }

    return hr;
}


/*****************************************************************************
* CRecoCtxt::EventNotify *
*-------------------------*
*   Description:
*       This method handle the stream notifications that come from the
*       engine object.  The stream notifications are SPFEI_END_SR_STREAM,
*       SPFEI_SR_BOOKMARK, SPFEI_SOUNDSTART, SPFEI_SOUNDEND, and SPFEI_PHRASESTART,
*       and SPFEI_INTERFERENCE. This routine creates and queues an event for each 
*       notification.  It also changes the m_Stat member as necessary.
********************************************************************* RAP ***/
STDMETHODIMP CRecoCtxt::EventNotify( const SPSERIALIZEDEVENT64 * pEvent, ULONG cbEvent )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CRecoCtxt::EventNotify" );
    HRESULT hr = S_OK;

    CSpEvent Event;
    Event.Deserialize(pEvent);
    switch (Event.eEventId)
    {
        case SPEI_REQUEST_UI:
            if (Event.RequestTypeOfUI())
            {
                wcscpy(m_Stat.szRequestTypeOfUI, Event.RequestTypeOfUI());
            }
            else
            {
                m_Stat.szRequestTypeOfUI[0] = '\0';
            }
            break;
        
        case SPEI_INTERFERENCE:
            m_Stat.eInterference = Event.Interference();
            break;
        default:
            break;
    }

    if((1ui64 << pEvent->eEventId) & m_ullVoicePurgeInterest)
    {
        hr = _DoVoicePurge();
    }

    if(SUCCEEDED(hr) && ((1ui64 << pEvent->eEventId) & m_ullEventInterest))
    {
        m_SpEventSource_Context._AddEvent(Event);
        m_SpEventSource_Context._CompleteEvents();
    }

	return hr;
}



/****************************************************************************
* CRecoCtxt::CallEngine *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::CallEngine(void * pvData, ULONG cbData)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::CallEngine");
    HRESULT hr = S_OK;

    if (cbData == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SPIsBadWritePtr(pvData, cbData))
        {
            hr = E_POINTER;
        }
        else
        {
            hr = CRCT_CALLENGINE::CallEngine(this, pvData, cbData);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoCtxt::CallEngineEx *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoCtxt::CallEngineEx(const void * pvInCallFrame, ULONG cbInCallFrame,
                                     void ** ppvOutCallFrame, ULONG * pcbOutCallFrame)
{
    SPAUTO_SEC_LOCK(&m_ReentrancySec);
    SPDBG_FUNC("CRecoCtxt::CallEngineEx");
    HRESULT hr = S_OK;

    if (cbInCallFrame == 0 ||
        SPIsBadReadPtr(pvInCallFrame, cbInCallFrame))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(ppvOutCallFrame) ||
            SP_IS_BAD_WRITE_PTR(pcbOutCallFrame))
        {
            hr = E_POINTER;
        }
        else
        {
            hr = CRCT_CALLENGINEEX::CallEngineEx(this, pvInCallFrame, cbInCallFrame,
                                                 ppvOutCallFrame, pcbOutCallFrame);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CSharedRecoCtxt::FinalConstruct *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSharedRecoCtxt::FinalConstruct()
{
    SPDBG_FUNC("CSharedRecoCtxt::FinalConstruct");
    HRESULT hr = S_OK;

    hr = CRecoCtxt::FinalConstruct();
    if (SUCCEEDED(hr))
    {
        CComPtr<_ISpRecognizerBackDoor> cpSharedReco;
        hr = cpSharedReco.CoCreateInstance(CLSID_SpSharedRecognizer);
        if (SUCCEEDED(hr))
        {
            hr = Init(cpSharedReco);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


#ifdef SAPI_AUTOMATION
/****************************************************************************
* CInProcRecoCtxt::FinalConstruct *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* Leonro ***/

HRESULT CInProcRecoCtxt::FinalConstruct()
{
    SPDBG_FUNC("CInProcRecoCtxt::FinalConstruct");
    HRESULT hr = S_OK;

    hr = CRecoCtxt::FinalConstruct();
    if (SUCCEEDED(hr))
    {
        CComPtr<_ISpRecognizerBackDoor> cpInprocReco;
        hr = cpInprocReco.CoCreateInstance(CLSID_SpInprocRecognizer);
        if (SUCCEEDED(hr))
        {
            hr = Init(cpInprocReco);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//=== ISpNotifyCallback =======================================================
//  This section contains the methods to implement firing of events to a
//  connection point client.

/*****************************************************************************
* CRecoCtxt::NotifyCallback *
*--------------------------*
*   Description:
*       This method is used to fire events to the connection point client.
********************************************************************* TODDT **/
STDMETHODIMP CRecoCtxt::NotifyCallback( WPARAM wParam, LPARAM lParam )
{
    HRESULT hr = S_OK;
    CSpEvent Event;

    // If we are re-entering ourselves then just bail.  We'll pick up any new
    // event on the next iteration of the while loop.
    if ( m_fHandlingEvent )
    {
        return hr;
    }

    m_fHandlingEvent = TRUE;

    //AddRef so that when you debug in vb, the recocontext object won't go away while you are in this function.
    this->AddRef();
    while( ((hr = Event.GetFrom(this)) == S_OK ) )
    {
        CComVariant varStreamPos;

        // TODDT: How do we want to handle failure of this.  Ignore?
        /* hr = */ ULongLongToVariant( Event.ullAudioStreamOffset, &varStreamPos );

        switch( Event.eEventId )
        {
            case SPEI_START_SR_STREAM:
                Fire_StartStream( Event.ulStreamNum, varStreamPos );
                break;
            case SPEI_END_SR_STREAM:
                Fire_EndStream( Event.ulStreamNum, varStreamPos, Event.InputStreamReleased() ? VARIANT_TRUE : VARIANT_FALSE );
                break;
            case SPEI_SR_BOOKMARK:
                {
                    CComVariant varEventData;
                    hr = FormatPrivateEventData( Event.AddrOf(), &varEventData );
                    if ( SUCCEEDED( hr ) )
                    {
                        Fire_Bookmark( Event.ulStreamNum, varStreamPos, varEventData, 
                                       Event.IsPaused() ? SBOPause : SBONone );
                    }
                }
                break;
            case SPEI_SOUND_START:
                Fire_SoundStart( Event.ulStreamNum, varStreamPos );
                break;
            case SPEI_SOUND_END:
                Fire_SoundEnd( Event.ulStreamNum, varStreamPos );
                break;
            case SPEI_PHRASE_START:
                Fire_PhraseStart( Event.ulStreamNum, varStreamPos );
                break;
            case SPEI_RECOGNITION:
                {
                CComQIPtr<ISpeechRecoResult> cpRecoResult(Event.RecoResult());
                Fire_Recognition( Event.ulStreamNum, varStreamPos, (SpeechRecognitionType)Event.wParam, cpRecoResult );
                }
                break;
            case SPEI_HYPOTHESIS:
                {
                CComQIPtr<ISpeechRecoResult> cpRecoResult(Event.RecoResult());
                Fire_Hypothesis( Event.ulStreamNum, varStreamPos, cpRecoResult );
                }
                break;
            case SPEI_PROPERTY_NUM_CHANGE:
                {
                // PREFIX: check memory alloc
                CComBSTR bstrPropName(Event.PropertyName());
                if (bstrPropName)
                {
                    Fire_PropertyNumberChange( Event.ulStreamNum, varStreamPos, bstrPropName, Event.PropertyNumValue() );
                }
                break;
                }
            case SPEI_PROPERTY_STRING_CHANGE:
                {
                // PREFIX: check memory alloc
                CComBSTR bstrPropName(Event.PropertyName());
                CComBSTR bstrPropStringVal(Event.PropertyStringValue());
                if (bstrPropName && bstrPropStringVal)
                {
                    Fire_PropertyStringChange( Event.ulStreamNum, varStreamPos, bstrPropName, bstrPropStringVal );
                }
                break;
                }
            case SPEI_FALSE_RECOGNITION:
                {
                CComQIPtr<ISpeechRecoResult> cpRecoResult(Event.RecoResult());
                Fire_FalseRecognition( Event.ulStreamNum, varStreamPos, cpRecoResult );
                }
                break;
            case SPEI_INTERFERENCE:
                Fire_Interference( Event.ulStreamNum, varStreamPos, (SpeechInterference)Event.Interference() );
                break;
            case SPEI_REQUEST_UI:
                Fire_RequestUI( Event.ulStreamNum, varStreamPos, CComBSTR(Event.RequestTypeOfUI()) );
                break;
            case SPEI_RECO_STATE_CHANGE:
                Fire_RecognizerStateChange( Event.ulStreamNum, varStreamPos, (SpeechRecognizerState)Event.RecoState() );
                break;
            case SPEI_ADAPTATION:
                Fire_Adaptation( Event.ulStreamNum, varStreamPos );
                break;
            case SPEI_RECO_OTHER_CONTEXT:
                Fire_RecognitionForOtherContext( Event.ulStreamNum, varStreamPos );
                break;
            case SPEI_SR_AUDIO_LEVEL:
                Fire_AudioLevel( Event.ulStreamNum, varStreamPos, (long)Event.wParam );
                break;
            case SPEI_SR_PRIVATE:
                {
                    CComVariant varLParam;

                    hr = FormatPrivateEventData( Event.AddrOf(), &varLParam );

                    if ( SUCCEEDED( hr ) )
                    {
                        Fire_EnginePrivate(Event.ulStreamNum, varStreamPos, varLParam);
                    }
                    else
                    {
                        SPDBG_ASSERT(0);    // We failed handling lParam data
                    }
                }
                break;
            default:
                break;
        } // end switch()
    }

    //Release the object which has been AddRef earlier in this function.
    this->Release();

    m_fHandlingEvent = FALSE;

    return hr;
} /* CRecoCtxt::NotifyCallback */


/*****************************************************************************
* CRecoCtxt::Advise *
*------------------*
*   Description:
*       This method is called when a client is making a connection.
********************************************************************* EDC ***/
HRESULT CRecoCtxt::Advise( IUnknown* pUnkSink, DWORD* pdwCookie )
{
    HRESULT hr = S_OK;

    hr = CProxy_ISpeechRecoContextEvents<CRecoCtxt>::Advise( pUnkSink, pdwCookie );
    if( SUCCEEDED( hr ) && ( m_vec.GetSize() == 1 ) )
    {
        hr = SetNotifyCallbackInterface( this, NULL, NULL );

        if( SUCCEEDED( hr ) )
        {
            //--- Save previous interest so we can restore during unadvise
            m_ullPrevEventInterest  = m_ullEventInterest;
            m_ullPrevQueuedInterest = m_ullQueuedInterest;
            // Set all interests except SPEI_SR_AUDIO_LEVEL
            hr = SetInterest( ((ULONGLONG)(SREAllEvents & ~SREAudioLevel) << 34) | SPFEI_FLAGCHECK,
                              ((ULONGLONG)(SREAllEvents & ~SREAudioLevel) << 34) | SPFEI_FLAGCHECK );
        }
    }

    return hr;
} /* CRecoCtxt::Advise */

/*****************************************************************************
* CRecoCtxt::Unadvise *
*--------------------*
*   Description:
*       This method is called when a client is breaking a connection.
********************************************************************* EDC ***/
HRESULT CRecoCtxt::Unadvise( DWORD dwCookie )
{
    HRESULT hr = S_OK;

    hr = CProxy_ISpeechRecoContextEvents<CRecoCtxt>::Unadvise( dwCookie );
    if( SUCCEEDED( hr ) && ( m_vec.GetSize() == 0 ) )
    {
        hr = SetNotifySink( NULL );

        if( SUCCEEDED( hr ) )
        {
            hr = SetInterest( m_ullPrevEventInterest, m_ullPrevQueuedInterest );
        }
    }

    return hr;
} /* CRecoCtxt::Unadvise */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\recoctxt.h ===
// RecoCtxt.h : Declaration of the CRecoCtxt

#ifndef __RECOCTXT_H_
#define __RECOCTXT_H_

#include "resource.h"       // main symbols
#include "speventq.h"
#include "spphrase.h"
#include "SpResult.h"
#include "cfggrammar.h"     // Base class for grammar
#include "commonlx.h"
#include "a_recoCP.h"
#include "recognizer.h"
#include "a_reco.h"

class ATL_NO_VTABLE CRecoGrammar;


/////////////////////////////////////////////////////////////////////////////
// CRecoCtxt
class ATL_NO_VTABLE CRecoCtxt;
typedef CComObject<CRecoCtxt> CRecoCtxtObject;

class ATL_NO_VTABLE CRecoCtxt : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpRecoContext,
    public _ISpPrivateEngineCall
    //--- Automation
#ifdef SAPI_AUTOMATION
    , public ISpNotifyCallback,
    public IDispatchImpl<ISpeechRecoContext, &IID_ISpeechRecoContext, &LIBID_SpeechLib, 5>,
    public CProxy_ISpeechRecoContextEvents<CRecoCtxt>,
    public IConnectionPointContainerImpl<CRecoCtxt>
#endif  // SAPI_AUTOMATION
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_GET_CONTROLLING_UNKNOWN();
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CRecoCtxt)
        COM_INTERFACE_ENTRY(ISpRecoContext)
        COM_INTERFACE_ENTRY(ISpEventSource)
        COM_INTERFACE_ENTRY(ISpNotifySource)
        //--- Automation
#ifdef SAPI_AUTOMATION
        COM_INTERFACE_ENTRY(ISpeechRecoContext)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
#endif  // SAPI_AUTOMATION
        //--- Extension/private interfaces
    //    COM_INTERFACE_ENTRY(_ISpRecoCtxtPrivate)
        COM_INTERFACE_ENTRY_FUNC(__uuidof(_ISpPrivateEngineCall), 0, PrivateCallQI)
        COM_INTERFACE_ENTRY_FUNC_BLIND(0, ExtensionQI)
    END_COM_MAP()

    //--- Automation
#ifdef SAPI_AUTOMATION
    BEGIN_CONNECTION_POINT_MAP(CRecoCtxt)
        CONNECTION_POINT_ENTRY(DIID__ISpeechRecoContextEvents)
    END_CONNECTION_POINT_MAP()
#endif  // SAPI_AUTOMATION

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CRecoCtxt();
    void FinalRelease();

    /*--- Non interface methods ---*/
    //---  Function will return interface pointer for _ISpPrivateEngineCall iff this query is
    //     done while aggregating an extension object.
    static HRESULT WINAPI PrivateCallQI(void* pvThis, REFIID riid, LPVOID* ppv, DWORD_PTR dw);
    static HRESULT WINAPI ExtensionQI(void* pvThis, REFIID riid, LPVOID* ppv, DWORD_PTR dw);

    HRESULT Init(_ISpRecognizerBackDoor * pParent);

    HRESULT _DoVoicePurge(void);
    HRESULT _SetVoiceFormat(ISpVoice *pVoice);

    HRESULT GetInterests(ULONGLONG* pullInterests, ULONGLONG* pullQueuedInterests);

  /*=== Interfaces ====*/
  public:
    //--- Forward interface ISpEventSource ------------------------------------
    DECLARE_SPNOTIFYSOURCE_METHODS(m_SpEventSource_Context);
    STDMETHODIMP SetInterest(ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest);
    STDMETHODIMP GetEvents(ULONG ulCount, SPEVENT* pEventArray, ULONG * pulFetched) 
    {
        // Get the events, and for each (false) recognition addref ourselves because
        // the results reference us.
        HRESULT hr = m_SpEventSource_Context._GetEvents(ulCount, pEventArray, pulFetched); 
        if (SUCCEEDED(hr))
        {
            // While the event was in the queue, it had a weak reference.
            // Now, when we pull it out, we need to change it to a strong
            // reference. (see RecognitionNotify).
            UINT cEvents = (pulFetched != NULL 
                                ? *pulFetched
                                : (hr != S_FALSE
                                    ? 1
                                    : 0));
            for (UINT i = 0; i < cEvents; i++)
            {
                if (pEventArray[i].eEventId == SPEI_HYPOTHESIS ||
                    pEventArray[i].eEventId == SPEI_RECOGNITION ||
                    pEventArray[i].eEventId == SPEI_FALSE_RECOGNITION)
                {
                    ((CSpResult*)(ISpRecoResult*)(pEventArray[i].lParam))->WeakCtxtRef(FALSE);
                }
            }
        }

        return hr;
    } 
    STDMETHODIMP GetInfo(SPEVENTSOURCEINFO *pInfo)
    {
        return m_SpEventSource_Context._GetInfo(pInfo); 
    }

    //--- ISpRecoContext ------------------------------------------------------
    STDMETHODIMP GetRecognizer(ISpRecognizer ** ppRecognizer);
    STDMETHODIMP GetStatus(SPRECOCONTEXTSTATUS *pStatus);

    STDMETHODIMP SetMaxAlternates(ULONG cAlternates);
    STDMETHODIMP GetMaxAlternates(ULONG * pcAlternates);

    STDMETHODIMP GetAudioOptions(SPAUDIOOPTIONS * pOptions, GUID *pAudioFormatId, WAVEFORMATEX **ppCoMemWFEX);
    STDMETHODIMP SetAudioOptions(SPAUDIOOPTIONS Options, const GUID *pAudioFormatId, const WAVEFORMATEX *pWaveFormatEx);

    STDMETHODIMP CreateGrammar(ULONGLONG ullGrammarId, ISpRecoGrammar ** ppGrammar);
    STDMETHODIMP DeserializeResult(const SPSERIALIZEDRESULT * pSerializedResult, ISpRecoResult **ppResult);

    STDMETHODIMP Bookmark(SPBOOKMARKOPTIONS Options, ULONGLONG ullStreamPosition, LPARAM lparamEvent);

    STDMETHODIMP SetAdaptationData(const WCHAR *pAdaptationData, const ULONG cch);

    STDMETHODIMP Pause(DWORD dwReserved);
    STDMETHODIMP Resume(DWORD dwReserved);

    STDMETHODIMP SetVoice(ISpVoice *ppVoice, BOOL fAllowFormatChanges);
    STDMETHODIMP GetVoice(ISpVoice **ppVoice);
    STDMETHODIMP SetVoicePurgeEvent(ULONGLONG ullEventInterest);
    STDMETHODIMP GetVoicePurgeEvent(ULONGLONG *pullEventInterest);
    STDMETHODIMP SetContextState(SPCONTEXTSTATE eState);
    STDMETHODIMP GetContextState(SPCONTEXTSTATE * peState);

    //--- _ISpRecoCtxtPrivate -------------------------------------------------
    STDMETHODIMP RecognitionNotify(SPRESULTHEADER *pPhrase, WPARAM wParamEventFlags, SPEVENTENUM EventId);

    STDMETHODIMP EventNotify(const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize);

    STDMETHODIMP TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalBuffer, ULONG cbAdditionalBuffer);

    //--- _ISpPrivateEngineCall -----------------------------------------------
    STDMETHODIMP CallEngine(void * pvCallFrame, ULONG ulCallFrameSize);
    STDMETHODIMP CallEngineEx(const void * pvInCallFrame, ULONG cbInCallFrame,
                              void ** ppvOutCallFrame, ULONG * pcbOutCallFrame);

    inline HRESULT PerformTask(ENGINETASK * pTask)
    {
        pTask->hRecoInstContext = this->m_hRecoInstContext;
        return this->m_cpRecognizer->PerformTask(pTask);
    }

#ifdef SAPI_AUTOMATION
    // Override this to fix the jscript problem passing NULL objects.
    STDMETHOD(Invoke) ( DISPID          dispidMember,
                        REFIID          riid,
                        LCID            lcid,
                        WORD            wFlags,
                        DISPPARAMS 		*pdispparams,
                        VARIANT 		*pvarResult,
                        EXCEPINFO 		*pexcepinfo,
                        UINT 			*puArgErr);

    //--- IConnectionPointImpl overrides
    STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);

    //--- ISpNotifyCallback -----------------------------------
    STDMETHOD(NotifyCallback)( WPARAM wParam, LPARAM lParam );

    //--- ISpeechRecoContext --------------------------------------------------
    STDMETHODIMP get_Recognizer( ISpeechRecognizer** ppRecognizer );
	STDMETHODIMP get_AudioInputInterferenceStatus( SpeechInterference* pInterference );
	STDMETHODIMP get_RequestedUIType( BSTR* bstrUIType );
	STDMETHODIMP putref_Voice( ISpeechVoice *ppVoice );
    STDMETHODIMP get_Voice( ISpeechVoice **ppVoice );
	STDMETHODIMP put_AllowVoiceFormatMatchingOnNextSet( VARIANT_BOOL Allow );
    STDMETHODIMP get_AllowVoiceFormatMatchingOnNextSet( VARIANT_BOOL* pAllow );
    STDMETHODIMP put_VoicePurgeEvent( SpeechRecoEvents EventInterest );
    STDMETHODIMP get_VoicePurgeEvent( SpeechRecoEvents* EventInterest );
    STDMETHODIMP put_EventInterests( SpeechRecoEvents EventInterest );
    STDMETHODIMP get_EventInterests( SpeechRecoEvents* EventInterest );
    STDMETHODIMP CreateGrammar( VARIANT GrammarId, ISpeechRecoGrammar** ppGrammar );
    STDMETHODIMP CreateResultFromMemory( VARIANT* ResultBlock, ISpeechRecoResult **Result );
    STDMETHODIMP Pause( void );
    STDMETHODIMP Resume( void );
    STDMETHODIMP put_State( SpeechRecoContextState State );
    STDMETHODIMP get_State( SpeechRecoContextState* pState );
    STDMETHODIMP put_CmdMaxAlternates( long MaxAlternates );
    STDMETHODIMP get_CmdMaxAlternates( long * pMaxAlternates );
    STDMETHODIMP put_RetainedAudio(SpeechRetainedAudioOptions Option);
    STDMETHODIMP get_RetainedAudio(SpeechRetainedAudioOptions* pOption);
    STDMETHODIMP putref_RetainedAudioFormat(ISpeechAudioFormat* Format );
    STDMETHODIMP get_RetainedAudioFormat(ISpeechAudioFormat** pFormat );
    STDMETHODIMP Bookmark( SpeechBookmarkOptions Options, VARIANT StreamPos, VARIANT EventData);
    STDMETHODIMP SetAdaptationData( BSTR AdaptationString );

#endif // SAPI_AUTOMATION

  //=== Member data ===
  protected:
    CLSID                       m_clsidExtension;
    CComPtr<IUnknown>           m_cpExtension;        // inner IUnknown for aggregated extension object
    BOOL                        m_bCreatingAgg;

    CSpStreamFormat             m_RetainedFormat;

    SPCONTEXTSTATE              m_State;            
    SPRECOCONTEXTSTATUS         m_Stat;

    WCHAR                    *  m_pszhypothesis;
    ULONG                       m_hypsize;
    ULONG                       m_hyplen;
    ULONGLONG                   m_ullPrevEventInterest;        // Only used to restore interest
    ULONGLONG                   m_ullPrevQueuedInterest;       // after connection points removed

  public:
    SPRECOCONTEXTHANDLE         m_hRecoInstContext;
    CComPtr<_ISpRecognizerBackDoor>  m_cpRecognizer;

  private:
    ULONG                       m_cMaxAlternates;
    BOOL                        m_fRetainAudio;
    CSpEventSource              m_SpEventSource_Context;
    CComPtr<ISpVoice>           m_cpVoice;  // Associated voice object
    ULONGLONG                   m_ullEventInterest; // The actual events the app is interested in
    ULONGLONG                   m_ullQueuedInterest;
    ULONGLONG                   m_ullVoicePurgeInterest; // Voice purge events
    BOOL                        m_fAllowVoiceFormatChanges; // Keeps associated voice in same format as engine
    BOOL                        m_fHandlingEvent;

  protected:
    CComAutoCriticalSection     m_ReentrancySec;

// These fields are used by CRecognizer to add the context to a list and
// to find the appropriate context.
  public:
    CRecoCtxt               *   m_pNext;    // Used by list implementation
    operator ==(const SPRECOCONTEXTHANDLE h)
    {
        return h == m_hRecoInstContext;
    }
};


class ATL_NO_VTABLE CSharedRecoCtxt :
    public CRecoCtxt,
#ifdef SAPI_AUTOMATION
    public IProvideClassInfo2Impl<&CLSID_SpSharedRecoContext, NULL, &LIBID_SpeechLib, 5>,
#endif  // SAPI_AUTOMATION
    public CComCoClass<CSharedRecoCtxt, &CLSID_SpSharedRecoContext>
{

public:
    DECLARE_REGISTRY_RESOURCEID(IDR_RECOCTXT)
    HRESULT FinalConstruct();

#ifdef SAPI_AUTOMATION
    BEGIN_COM_MAP(CSharedRecoCtxt)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_CHAIN(CRecoCtxt)
    END_COM_MAP()
#endif  // SAPI_AUTOMATION

};

    
class ATL_NO_VTABLE CInProcRecoCtxt :
    public CRecoCtxt,
#ifdef SAPI_AUTOMATION
    public IProvideClassInfo2Impl<&CLSID_SpInProcRecoContext, NULL, &LIBID_SpeechLib, 5>,
#endif // SAPI_AUTOMATION
    public CComCoClass<CInProcRecoCtxt, &CLSID_SpInProcRecoContext>
{

public:
    DECLARE_REGISTRY_RESOURCEID(IDR_INPROCRECOCTXT)
    HRESULT FinalConstruct();

#ifdef SAPI_AUTOMATION
    BEGIN_COM_MAP(CInProcRecoCtxt)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_CHAIN(CRecoCtxt)
    END_COM_MAP()
#endif  // SAPI_AUTOMATION

};

#endif //__RECOCTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\phoneconv.h ===
/*******************************************************************************
*   PhoneConv.h
*   This is the header file for the Phone Converter class.
*
*   Owner: yunusm                                              Date: 07/05/99
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include "CommonLx.h"

typedef struct
{
   WCHAR szPhone[g_dwMaxLenPhone + 1]; // Unicode Phone string with NULL terminator
   SPPHONEID pidPhone[g_dwMaxLenId +1]; // PhoneID array with NULL terminator.
} PHONEMAPNODE;


//--- Class, Struct and Union Definitions --------------------------------------

/*******************************************************************************
*
*   CSpPhoneConverter
*
****************************************************************** YUNUSM *****/
class ATL_NO_VTABLE CSpPhoneConverter :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpPhoneConverter, &CLSID_SpPhoneConverter>,
    public ISpPhoneConverter
    #ifdef SAPI_AUTOMATION
    , public IDispatchImpl<ISpeechPhoneConverter, &IID_ISpeechPhoneConverter, &LIBID_SpeechLib, 5>
    #endif
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_PHONECONV)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CSpPhoneConverter)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
        COM_INTERFACE_ENTRY(ISpPhoneConverter)
#ifdef SAPI_AUTOMATION
        COM_INTERFACE_ENTRY(ISpeechPhoneConverter)
        COM_INTERFACE_ENTRY(IDispatch)
#endif // SAPI_AUTOMATION
    END_COM_MAP()
        
//=== Methods ====
public:

    //--- Ctor, Dtor, etc
    CSpPhoneConverter();
    ~CSpPhoneConverter();

    void NullMembers();
    void CleanUp();

//=== Interfaces ===
public:         

    //--- ISpObjectWithToken
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

    //--- ISpPhoneConverter
    STDMETHODIMP PhoneToId(const WCHAR * pszPhone, SPPHONEID * pszId);
    STDMETHODIMP IdToPhone(const WCHAR * pszId, WCHAR * pszPhone);

#ifdef SAPI_AUTOMATION    

    //--- ISpeechPhoneConverter-----------------------------------------------------
    STDMETHOD(get_LanguageId)(SpeechLanguageId* LanguageId);
    STDMETHOD(put_LanguageId)(SpeechLanguageId LanguageId);
    STDMETHOD(PhoneToId)(const BSTR Phonemes, VARIANT* IdArray);
    STDMETHOD(IdToPhone)(const VARIANT IdArray, BSTR* Phonemes);
  
#endif // SAPI_AUTOMATION

//=== Private methods ===
private:

    HRESULT SetPhoneMap(const WCHAR *pMap, BOOL fNumericPhones);
    void ahtoi(WCHAR *pszSpaceSeparatedTokens, WCHAR *pszHexChars);

//=== Private data ===
private:

    CComPtr<ISpObjectToken> m_cpObjectToken;    // object token
    
    DWORD m_dwPhones;                           // Number of phones
    PHONEMAPNODE  *m_pPhoneId;                  // internal phone to Id table
    PHONEMAPNODE **m_pIdIdx;                    // Index to search on Id
    BOOL m_fNoDelimiter;                        // Space separate phone strings

#ifdef SAPI_AUTOMATION
    LANGID         m_LangId;                    // Language Id of the PhoneConverter
#endif // SAPI_AUTOMATION

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\recognizer.h ===
/******************************************************************************
* Recognizer.h *
*--------------*
*  This is the header file for the CRecognizer implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#ifndef __Recognizer_h__
#define __Recognizer_h__

#include "SrRecoInst.h"

class CRecoCtxt;

//
//  This back-door interface is used for private communication between a reco context
//  and the CRecognizer class.  This exists so that the shared reco context can add itself
//  to the CRecognizer list of contexts.  T
//
MIDL_INTERFACE("635DAEDE-0ACF-4b2e-B9DE-8CD2BA7F6183")
_ISpRecognizerBackDoor : public IUnknown //public _ISpRecoIncoming
{
public:
    virtual HRESULT STDMETHODCALLTYPE PerformTask(ENGINETASK * pTask);
    virtual HRESULT STDMETHODCALLTYPE AddRecoContextToList(CRecoCtxt * pRecoCtxt);
    virtual HRESULT STDMETHODCALLTYPE RemoveRecoContextFromList(CRecoCtxt * pRecoCtxt);
};



class ATL_NO_VTABLE CRecognizer :
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpRecognizer,
    public _ISpRecognizerBackDoor
    //--- Automation
    #ifdef SAPI_AUTOMATION
    , public IDispatchImpl<ISpeechRecognizer, &IID_ISpeechRecognizer, &LIBID_SpeechLib, 5>
    #endif
{
public:

    DECLARE_GET_CONTROLLING_UNKNOWN()
    BEGIN_COM_MAP(CRecognizer)
        COM_INTERFACE_ENTRY(ISpRecognizer)
        COM_INTERFACE_ENTRY(_ISpRecognizerBackDoor)
        //--- Automation
#ifdef SAPI_AUTOMATION
        COM_INTERFACE_ENTRY(ISpeechRecognizer)
        COM_INTERFACE_ENTRY(IDispatch)
#endif // SAPI_AUTOMATION
    END_COM_MAP()

    HRESULT FinalConstruct();

public:
    //--- ISpProperties -------------------------------------------------------
    STDMETHODIMP SetPropertyNum( const WCHAR* pName, LONG lValue );
    STDMETHODIMP GetPropertyNum( const WCHAR* pName, LONG* plValue );
    STDMETHODIMP SetPropertyString( const WCHAR* pName, const WCHAR* pValue );
    STDMETHODIMP GetPropertyString( const WCHAR* pName, WCHAR** ppCoMemValue );

    //--- ISpRecognizer -----------------------------------------------------
    STDMETHODIMP SetRecognizer(ISpObjectToken * pEngineToken);
    STDMETHODIMP GetRecognizer(ISpObjectToken ** ppEngineToken);
    STDMETHODIMP SetInput(IUnknown * pUnkInput, BOOL fAllowFormatChanges);
    STDMETHODIMP GetInputObjectToken(ISpObjectToken ** ppToken);
    STDMETHODIMP GetInputStream(ISpStreamFormat ** ppStream);
    STDMETHODIMP CreateRecoContext(ISpRecoContext ** ppNewContext);
    STDMETHODIMP GetRecoProfile(ISpObjectToken **ppToken);
    STDMETHODIMP SetRecoProfile(ISpObjectToken *pToken);
    STDMETHODIMP IsSharedInstance(void);
    STDMETHODIMP SetRecoState( SPRECOSTATE NewState );
    STDMETHODIMP GetRecoState( SPRECOSTATE *pState );
    STDMETHODIMP GetStatus(SPRECOGNIZERSTATUS * pStatus);
    STDMETHODIMP GetFormat(SPSTREAMFORMATTYPE WaveFormatType, GUID *pFormatId, WAVEFORMATEX **ppCoMemWFEX);
    STDMETHODIMP IsUISupported(const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData, BOOL *pfSupported);
    STDMETHODIMP DisplayUI(HWND hwndParent, const WCHAR * pszTitle, const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData);
    STDMETHODIMP EmulateRecognition(ISpPhrase * pPhrase);

#ifdef SAPI_AUTOMATION
    // Override this to fix the jscript problem passing NULL objects.
    STDMETHOD(Invoke) ( DISPID          dispidMember,
                        REFIID          riid,
                        LCID            lcid,
                        WORD            wFlags,
                        DISPPARAMS 		*pdispparams,
                        VARIANT 		*pvarResult,
                        EXCEPINFO 		*pexcepinfo,
                        UINT 			*puArgErr);

    //--- ISpeechRecognizer -----------------------------------------------------
    STDMETHODIMP putref_Recognizer( ISpeechObjectToken* pRecognizer );
    STDMETHODIMP get_Recognizer( ISpeechObjectToken** ppRecognizer );
    STDMETHODIMP put_AllowAudioInputFormatChangesOnNextSet( VARIANT_BOOL fAllow );
    STDMETHODIMP get_AllowAudioInputFormatChangesOnNextSet( VARIANT_BOOL* pfAllow );
    STDMETHODIMP putref_AudioInput( ISpeechObjectToken* pInput );
    STDMETHODIMP get_AudioInput( ISpeechObjectToken** ppInput );
    STDMETHODIMP putref_AudioInputStream( ISpeechBaseStream* pInput );
    STDMETHODIMP get_AudioInputStream( ISpeechBaseStream** ppInput );
    STDMETHODIMP get_IsShared( VARIANT_BOOL* pShared );
    STDMETHODIMP put_State( SpeechRecognizerState State );
    STDMETHODIMP get_State( SpeechRecognizerState* pState );
    STDMETHODIMP get_Status( ISpeechRecognizerStatus** ppStatus );
    STDMETHODIMP CreateRecoContext( ISpeechRecoContext** ppNewCtxt );
    STDMETHODIMP GetFormat( SpeechFormatType Type, ISpeechAudioFormat** ppFormat );
    STDMETHODIMP putref_Profile( ISpeechObjectToken* pProfile );
    STDMETHODIMP get_Profile( ISpeechObjectToken** ppProfile );
    STDMETHODIMP EmulateRecognition(VARIANT Words, VARIANT* pDisplayAttributes, long LanguageId);
    STDMETHODIMP SetPropertyNumber( const BSTR Name, long Value, VARIANT_BOOL * pfSupported );
    STDMETHODIMP GetPropertyNumber( const BSTR Name, long* Value, VARIANT_BOOL * pfSupported );
    STDMETHODIMP SetPropertyString( const BSTR Name, const BSTR Value, VARIANT_BOOL * pfSupported );
    STDMETHODIMP GetPropertyString( const BSTR Name, BSTR* Value, VARIANT_BOOL * pfSupported );
    STDMETHODIMP IsUISupported( const BSTR TypeOfUI, const VARIANT* ExtraData, VARIANT_BOOL* Supported );
    STDMETHODIMP DisplayUI( long hWndParent, BSTR Title, const BSTR TypeOfUI, const VARIANT* ExtraData);
    STDMETHODIMP GetRecognizers( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens );
    STDMETHODIMP GetAudioInputs( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens );
    STDMETHODIMP GetProfiles( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens );
#endif // SAPI_AUTOMATION

    STDMETHODIMP AddRecoContextToList(CRecoCtxt * pRecoCtxt);
    STDMETHODIMP RemoveRecoContextFromList(CRecoCtxt * pRecoCtxt);

    STDMETHODIMP PerformTask(ENGINETASK * pTask);
    virtual HRESULT SendPerformTask(ENGINETASK * pTask) = 0;

    HRESULT EventNotify(SPRECOCONTEXTHANDLE hContext, const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize);
    HRESULT RecognitionNotify(SPRECOCONTEXTHANDLE hContext, SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, WPARAM wParamEvent, SPEVENTENUM eEventId);
    HRESULT TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalBuffer, ULONG cbAdditionalBuffer);


    bool                            m_fIsSharedReco;
///    CComPtr<_ISpRecoIncoming>       m_cpRecoMaster;
    CComAutoCriticalSection         m_CtxtListCritSec;
    CSpBasicQueue<CRecoCtxt>        m_CtxtList;   
    CSpAutoEvent                    m_autohTaskComplete;
    CComAutoCriticalSection         m_TaskCompleteTimeoutCritSec;
    ULONG                           m_ulTaskID; 
    bool        					m_fAllowFormatChanges;
};


class ATL_NO_VTABLE CInprocRecognizer :
    public CRecognizer,
    public CComCoClass<CInprocRecognizer, &CLSID_SpInprocRecognizer>
{
    CInprocRecoInst     m_RecoInst;
public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    HRESULT FinalConstruct();
    void FinalRelease();
    DECLARE_REGISTRY_RESOURCEID(IDR_RECOGNIZER) 

    HRESULT SendPerformTask(ENGINETASK * pTask);

private:
};

class ATL_NO_VTABLE CSharedRecognizer :
    public CRecognizer,
    public CComCoClass<CSharedRecognizer, &CLSID_SpSharedRecognizer>,
    public ISpCallReceiver
{
public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_NO_REGISTRY();    // .Reg file for inproc recognizer registers both

    BEGIN_COM_MAP(CSharedRecognizer)
        COM_INTERFACE_ENTRY(ISpCallReceiver)
        COM_INTERFACE_ENTRY_CHAIN(CRecognizer)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkCommunicator.p)
    END_COM_MAP()

    SP_DECLARE_CLASSFACTORY_RELEASABLE_SINGLETON(CSharedRecognizer)

    HRESULT FinalConstruct();    
    void FinalRelease();

    HRESULT SendPerformTask(ENGINETASK * pTask);

    STDMETHODIMP ReceiveCall(
                    DWORD dwMethodId,
                    PVOID pvData,
                    ULONG cbData,
                    PVOID * ppvDataReturn,
                    ULONG * pcbDataReturn);

    HRESULT ReceiveEventNotify(PVOID pvData, ULONG cbData);
    HRESULT ReceiveRecognitionNotify(PVOID pvData, ULONG cbData);
    HRESULT ReceiveTaskCompletedNotify(PVOID pvData, ULONG cbData);

private:

    CComPtr<IUnknown> m_cpunkCommunicator;
    ISpCommunicatorInit * m_pCommunicator;
};

#endif  // #ifndef __Recognizer_h__ - Keep as the last line of the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\recplayaudio.cpp ===
/****************************************************************************
*   RecPlayAudio.cpp
*       Implementation of the CRecPlayAudio device class
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "RecPlayAudio.h"

/****************************************************************************
* CRecPlayAudio::CRecPlayAudio *
*------------------------------*
*   Description:  
*       ctor
******************************************************************** robch */
CRecPlayAudio::CRecPlayAudio()
{
    m_fIn = FALSE;
    m_fOut = FALSE;
    
    m_pszFileList = NULL;
    m_ulBaseFileNextNum = 0;
    m_ulBaseFileMaxNum = UINT_MAX - 1;
    m_hStartReadingEvent = NULL;
    m_hFinishedReadingEvent = NULL;
}

/****************************************************************************
* CRecPlayAudio::FinalRelease *
*-----------------------------*
*   Description:  
*       Called by ATL when our object is going away. 
******************************************************************** robch */
void CRecPlayAudio::FinalRelease()
{
    CloseHandle(m_hStartReadingEvent);
    CloseHandle(m_hFinishedReadingEvent);
}

/****************************************************************************
* CRecPlayAudio::SetObjectToken *
*-------------------------------*
*   Description:  
*       ISpObjectToken::SetObjectToken implementation. Basically get ready
*       to read from the files specified, or write to the file specified,
*       in addition to delegating to the actual audio object.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC("CRecPlayAudio::SetObjectToken");
    HRESULT hr;

    SPAUTO_OBJ_LOCK;

    // Set our token (this does param validation, etc)
    hr = SpGenericSetObjectToken(pToken, m_cpToken);

    // Get the name of this RecPlayAudioDevice.
    CSpDynamicString dstrSRE, dstrFRE;
    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->GetStringValue(L"", &dstrSRE);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->GetStringValue(L"", &dstrFRE);
    }
    dstrSRE.Append(L"SRE");
    dstrFRE.Append(L"FRE");
    
    // Get the token id for the audio device
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->GetStringValue(L"AudioTokenId", &dstrTokenId);
    }
    
    // Create the audio device
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromTokenId(dstrTokenId, &m_cpAudio);
    }

    // Are we reading? Or writing?
    CSpDynamicString dstrReadOrWrite;
    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->GetStringValue(L"ReadOrWrite", &dstrReadOrWrite);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr) && dstrReadOrWrite)
    {
        if (wcsicmp(dstrReadOrWrite, L"Read") == 0)
        {
            m_fIn = TRUE;
        }
        else if (wcsicmp(dstrReadOrWrite, L"Write") == 0)
        {
            m_fOut = TRUE;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    // Create unsignalled StartReadingEvent.
    if (SUCCEEDED(hr))
    {
        m_hStartReadingEvent = g_Unicode.CreateEvent(NULL, TRUE, FALSE, dstrSRE);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->SetStringValue(L"StartReadingEvent", dstrSRE);
    }

    // Create unsignalled FinishedReadingEvent.
    if (SUCCEEDED(hr))
    {
        m_hFinishedReadingEvent = g_Unicode.CreateEvent(NULL, TRUE, FALSE, dstrFRE);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->SetStringValue(L"FinishedReadingEvent", dstrFRE);
    }

    if (SUCCEEDED(hr))
    {
        hr = InitFileList();
    }

    // We need input to be ready so we do proper format negotiation. Don't
    // worry about output, it'll get ready in the audio state transition
    // (after format negotiation).
    if (SUCCEEDED(hr) && m_fIn)
    {
        hr = GetNextFileReady();
        if (hr == SPERR_NO_MORE_ITEMS)
        {
            // This is now valid. RecPlayAudio will start feeding silence immediately.
            hr = S_OK;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);   
    return hr;
}

/****************************************************************************
* CRecPlayAudio::InitFileList *
*-----------------------------*
*   Description:  
*       Checks registry and updates file list information.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
***************************************************************** agarside */
HRESULT CRecPlayAudio::InitFileList(void)
{
    SPDBG_FUNC("CRecPlayAudio::InitFiles");
    HRESULT hr = S_OK;

    // What directory?
    if (SUCCEEDED(hr))
    {
        m_dstrDirectory.Clear();
        hr = m_cpToken->GetStringValue(L"Directory", &m_dstrDirectory);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    // Are we using a list of files
    if (SUCCEEDED(hr))
    {
        m_dstrFileList.Clear();
        hr = m_cpToken->GetStringValue(L"FileList", &m_dstrFileList);
        m_pszFileList = m_dstrFileList;

        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_dstrBaseFile.Clear();
        hr = m_cpToken->GetStringValue(L"BaseFile", &m_dstrBaseFile);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->GetDWORD(L"BaseFileNextNum", &m_ulBaseFileNextNum);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpToken->GetDWORD(L"BaseFileMaxNum", &m_ulBaseFileMaxNum);
        if (hr == SPERR_NOT_FOUND)
        {
            hr = S_OK;
        }
    }

    // Now check to make sure we're set up in a reasonable way
    if (SUCCEEDED(hr) && (m_fIn || m_fOut))
    {
        // We better have audio, and we can't be both in and out
        SPDBG_ASSERT(m_cpAudio != NULL);
        SPDBG_ASSERT(m_fIn != m_fOut);

        if (m_dstrFileList != NULL && m_dstrBaseFile != NULL)
        {
            hr = E_UNEXPECTED;
        }
        else if (m_dstrFileList == NULL && m_dstrBaseFile == NULL)
        {
            m_dstrBaseFile = L"RecPlay";
        }
        if (m_dstrFileList && wcslen(m_dstrFileList) == 0)
        {
            // Set this to null - indicates no more files left.
            m_pszFileList = NULL;
        }
        if (m_dstrBaseFile && wcslen(m_dstrBaseFile) == 0)
        {
            // Set this to null - indicates no more files left.
            m_dstrBaseFile.Clear();
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);   
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetObjectToken *
*-------------------------------*
*   Description:  
*       ISpObjectToken::GetObjectToken implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::GetObjectToken(ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("CRecPlayAudio::GetObjectToken");
    return SpGenericGetObjectToken(ppToken, m_cpToken);
}

/****************************************************************************
* CRecPlayAudio::Read *
*---------------------*
*   Description:  
*       ISequentialStream::Read implementation. Read data from the actual
*       audio object, potentially replacing it with data from the files on
*       disk, or potentially saving the data to a file on disk.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::Read(void * pv, ULONG cb, ULONG *pcbRead)
{
    SPDBG_FUNC("CRecPlayAudio::Read");
    HRESULT hr = S_OK;
    
    SPAUTO_OBJ_LOCK;
    
    if (SPIsBadWritePtr(pv, cb) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pcbRead))
    {
        hr = E_POINTER;
    }
    else if (m_cpAudio == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    
    // First read from the real device
    ULONG cbReadFromDevice;
    if (SUCCEEDED(hr))
    {
        hr = m_cpAudio->Read(pv, cb, &cbReadFromDevice);
    }
    
    // Now, we might need to write that back out
    if (SUCCEEDED(hr) && m_cpOutStream != NULL)
    {
        hr = m_cpOutStream->Write(pv, cbReadFromDevice, NULL);
    }
    
    // Might need to refresh file list if signalled via registry.
    if (m_fIn && m_cpInStream == NULL)
    {
        hr = GetNextFileReady();
    }

    // Now, we might need to replace the input with something else
    ULONG cbReadAndReplaced = 0;
    BYTE *pb = static_cast<BYTE*>(pv);
    while (SUCCEEDED(hr) && 
           m_cpInStream != NULL &&
           cbReadAndReplaced < cbReadFromDevice)
    {
        ULONG cbReadFromInStream;
        hr = m_cpInStream->Read(
                    pb + cbReadAndReplaced, 
                    cbReadFromDevice - cbReadAndReplaced,
                    &cbReadFromInStream);
        if (SUCCEEDED(hr))
        {
            // If we didn't read all that we wanted, from that
            // stream, go to the next stream
            if (cbReadFromInStream < cbReadFromDevice - cbReadAndReplaced)
            {
                m_cpInStream.Release();
                hr = GetNextFileReady();
            }
            
            cbReadAndReplaced += cbReadFromInStream;
        }
    }

    if (hr == SPERR_NO_MORE_ITEMS)
    {
        // Add silence to fill the requested buffer.

        // First get audio format to determine silence value.
        // 0x0000 for 16 bit
        // 0x80   for 8  bit
        GUID guidFormatId;
        WAVEFORMATEX *pCoMemWaveFormatEx;
        hr = m_cpAudio->GetFormat(&guidFormatId, &pCoMemWaveFormatEx);
        if (SUCCEEDED(hr) && 
            guidFormatId == SPDFID_WaveFormatEx &&
            pCoMemWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM )
        {
            if (pCoMemWaveFormatEx->wBitsPerSample == 8)
            {
                memset(pb + cbReadAndReplaced, 0x80, cbReadFromDevice - cbReadAndReplaced);
            }
            else
            {
                memset(pb + cbReadAndReplaced, 0, cbReadFromDevice - cbReadAndReplaced);
            }
        }
        else
        {
            // Set to zero if this fails. Should never happen.
            SPDBG_ASSERT(FALSE);
            memset(pb + cbReadAndReplaced, 0, cbReadFromDevice - cbReadAndReplaced);
        }
        if (SUCCEEDED(hr))
        {
            ::CoTaskMemFree(pCoMemWaveFormatEx);
        }
        cbReadAndReplaced = cbReadFromDevice;
        hr = S_OK;
    }
    
    // We're done. Tell the caller how much we read. This should now always
    // be the full amount as we artificially add flat-line silence.
    // Except when the audio device has been closed in which case it will be less.
    if (SUCCEEDED(hr))
    {
        if (pcbRead != NULL)
        {
            *pcbRead = cbReadFromDevice;
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    
    return hr;
}

/****************************************************************************
* CRecPlayAudio::Write *
*----------------------*
*   Description:  
*       ISequentialStream::Write implementation. Delegate to the actual
*       audio device.
*
*       NOTE: Currently, Recplay only replaces/records data for input. If
*             we wanted similar functionality for output, we'd modifiy this
*             function.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::Write(const void * pv, ULONG cb, ULONG *pcbWritten)
{
    SPDBG_FUNC("CRecPlayAudio::Write");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->Write(pv, cb, pcbWritten);
        
    return STG_E_ACCESSDENIED;
}

/****************************************************************************
* CRecPlayAudio::Seek *
*---------------------*
*   Description:  
*       IStream::Seek implementation. Delegate to the actual audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * plibNewPosition)
{
    SPDBG_FUNC("CRecPlayAudio::Seek");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    SPDBG_ASSERT(dwOrigin == STREAM_SEEK_CUR);
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->Seek(dlibMove, dwOrigin, plibNewPosition);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::SetSize *
*------------------------*
*   Description:  
*       IStream::SetSize implementation. Delegate to the actual audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::SetSize(ULARGE_INTEGER libNewSize)
{
    SPDBG_FUNC("CRecPlayAudio::SetSize");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->SetSize(libNewSize);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::CopyTo *
*-----------------------*
*   Description:  
*       IStream::CopyTo implementation. Delegate to the actual audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    SPDBG_FUNC("CRecPlayAudio::CopyTo");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->CopyTo(pstm, cb, pcbRead, pcbWritten);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::Commit *
*-----------------------*
*   Description:  
*       IStream::Commit implementation. Delegate to the actual audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::Commit(DWORD grfCommitFlags)
{
    SPDBG_FUNC("CRecPlayAudio::Commit");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->Commit(grfCommitFlags);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::Revert *
*-----------------------*
*   Description:  
*       IStream::Revert implementation. Delegate to the actual audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::Revert(void)
{
    SPDBG_FUNC("CRecPlayAudio::Revert");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->Revert();
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::LockRegion *
*---------------------------*
*   Description:  
*       IStream::LockRegion implementation. Delegate to the actual audio 
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    SPDBG_FUNC("CRecPlayAudio::LockRegion");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->LockRegion(libOffset, cb, dwLockType);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::UnlockRegion *
*-----------------------------*
*   Description:  
*       IStream::UnlockRegion implementation. Delegate to the actual audio
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    SPDBG_FUNC("CRecPlayAudio::UnlockRegion");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->UnlockRegion(libOffset, cb, dwLockType);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::Stat *
*---------------------*
*   Description:  
*       IStream::Stat implementation. Delegate to the actual audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SPDBG_FUNC("CRecPlayAudio::Stat");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->Stat(pstatstg, grfStatFlag);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::Clone *
*----------------------*
*   Description:  
*       IStream::Clone implementation. Delegate to the actual audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::Clone(IStream **ppstm)
{
    SPDBG_FUNC("CRecPlayAudio::Clone");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->Clone(ppstm);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetFormat *
*--------------------------*
*   Description:  
*       ISpStreamFormat::GetFormat implementation. The format of this audio
*       device, is either the format of the input files, or the format
*       of the underlying audio device.
*
*       Remember, RecPlay runs in one of three modes, if you will. It's
*       either a pass through, and thus we just delegate to the contained
*       audio device. Or it's reading from input files, and thus the format
*       is precisely that of the input files. Or, it's outputting to a file
*       on disk. In this mode, we still obtain the format via the audio 
*       device, because we really want to be in the format that the SR engine
*       wants, so we just let default behavior do this for us.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::GetFormat(GUID * pguidFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    SPDBG_FUNC("CRecPlayAudio::GetFormat");
    HRESULT hr = S_OK;
    
    SPAUTO_OBJ_LOCK;
    
    if (m_cpAudio == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (SP_IS_BAD_WRITE_PTR(pguidFormatId) || 
             SP_IS_BAD_WRITE_PTR(ppCoMemWaveFormatEx))
    {
        hr = E_POINTER;
    }
    
    if (SUCCEEDED(hr))
    {
        if (m_cpInStream != NULL)
        {
            hr = m_cpInStream->GetFormat(pguidFormatId, ppCoMemWaveFormatEx);
        }
        else
        {
            hr = m_cpAudio->GetFormat(pguidFormatId, ppCoMemWaveFormatEx);
        }
    }
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::SetState *
*-------------------------*
*   Description:  
*       ISpAudio::SetState implementation. Delegate to the actual audio
*       device. If we're transitioning to SPAS_RUN and we're supposed to be
*       writing an output, we need to create a new output file
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::SetState(SPAUDIOSTATE NewState, ULONGLONG ullReserved )
{
    SPDBG_FUNC("CRecPlayAudio::SetState");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->SetState(NewState, ullReserved);

    if (SUCCEEDED(hr) && NewState == SPAS_RUN)
    {
        if (m_fOut)
        {
            hr = GetNextFileReady();
            if (hr == SPERR_NO_MORE_ITEMS)
            {
                hr = S_OK;
            }
        }

        // Make sure the formats all look fine
        if (SUCCEEDED(hr))
        {
            hr = VerifyFormats();
        }
    }

    if (SUCCEEDED(hr) && NewState != SPAS_RUN && m_fOut)
    {
        m_cpOutStream.Release();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::SetFormat *
*--------------------------*
*   Description:  
*       ISpAudio::SetFormat implementation. We don't allow setting the format
*       to anything other than the input format if we're reading from input
*       files. We'll let the format converter do the right thing for us for
*       the SR engine.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx)
{
    SPDBG_FUNC("CRecPlayAudio::SetFormat");
    HRESULT hr = S_OK;
    
    SPAUTO_OBJ_LOCK;
    
    GUID guidFormat;
    CSpCoTaskMemPtr<WAVEFORMATEX> pwfex = NULL;
    
    if (m_cpAudio == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (m_cpInStream != NULL)
    {
        hr = m_cpInStream->GetFormat(&guidFormat, &pwfex);
    }
    
    // Allow setting the format, only to the in stream format, or
    // to anything if we have no in streams
    
    if (SUCCEEDED(hr) && pwfex != NULL)
    {
        if (guidFormat != rguidFmtId ||
            pwfex->cbSize != pWaveFormatEx->cbSize ||
            memcmp(pWaveFormatEx, pwfex, sizeof(WAVEFORMATEX) + pwfex->cbSize) != 0)
        {
            hr = SPERR_UNSUPPORTED_FORMAT;
        }
    }
    
    // If it's OK, delegate t the actual audio device
    if (SUCCEEDED(hr))
    {
        hr = m_cpAudio->SetFormat(rguidFmtId, pWaveFormatEx);
    }

    if (hr != SPERR_UNSUPPORTED_FORMAT)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetStatus *
*--------------------------*
*   Description:  
*       ISpAudio::GetStatus implementation. Delegate to the actual audio 
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::GetStatus(SPAUDIOSTATUS *pStatus)
{
    SPDBG_FUNC("CRecPlayAudio::GetStatus");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->GetStatus(pStatus);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::SetBufferInfo *
*------------------------------*
*   Description:  
*       ISpAudio::SetBufferInfo implementation. Delegate to the actual audio
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::SetBufferInfo(const SPAUDIOBUFFERINFO * pInfo)
{
    SPDBG_FUNC("CRecPlayAudio::SetBufferInfo");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->SetBufferInfo(pInfo);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetBufferInfo *
*------------------------------*
*   Description:  
*       ISpAudio::GetBufferInfo implementation. Delegate to the actual audio
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::GetBufferInfo(SPAUDIOBUFFERINFO * pInfo)
{
    SPDBG_FUNC("CRecPlayAudio::GetBufferInfo");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->GetBufferInfo(pInfo);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetDefaultFormat *
*---------------------------------*
*   Description:  
*       ISpAudio::GetDefaultFormat implementation. Our default format is
*       either that of the actual audio device, or that of the input files.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::GetDefaultFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    SPDBG_FUNC("CRecPlayAudio::GetDefaultFormat");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    // The default format is either the format of the in streams,
    // or whatever the actual audio device is
    
    if (m_cpAudio == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (m_cpInStream != NULL)
    {
        hr = m_cpInStream->GetFormat(pFormatId, ppCoMemWaveFormatEx);
    }
    else
    {
        hr = m_cpAudio->GetDefaultFormat(pFormatId, ppCoMemWaveFormatEx);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::EventHandle *
*----------------------------*
*   Description:  
*       ISpAudio::EventHandle implementation. Delegate to the actual audio
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP_(HANDLE) CRecPlayAudio::EventHandle()
{
    SPDBG_FUNC("CRecPlayAudio::EventHandle");
    
    SPAUTO_OBJ_LOCK;
    
    return m_cpAudio == NULL
        ? NULL
        : m_cpAudio->EventHandle();
}

/****************************************************************************
* CRecPlayAudio::GetVolumeLevel *
*-------------------------------*
*   Description:  
*       ISpAudio:GetVolumeLevel implementation. Delegate to the actual audio
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::GetVolumeLevel(ULONG *pLevel)
{
    SPDBG_FUNC("CRecPlayAudio::GetVolumeLevel");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->GetVolumeLevel(pLevel);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::SetVolumeLevel *
*-------------------------------*
*   Description:  
*       ISpAudio::SetVolumeLevel implementation. Delegate to the actual audio
*       device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::SetVolumeLevel(ULONG Level)
{
    SPDBG_FUNC("CRecPlayAudio::SetVolumeLevel");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->SetVolumeLevel(Level);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetBufferNotifySize *
*------------------------------------*
*   Description:  
*       ISpAudio::GetBufferNotifySize implementation. Delegate to the actual
*       audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::GetBufferNotifySize(ULONG *pcbSize)
{
    SPDBG_FUNC("CRecPlayAudio::GetBufferNotifySize");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->GetBufferNotifySize(pcbSize);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::SetBufferNotifySize *
*------------------------------------*
*   Description:  
*       ISpAudio::SetBufferNotifySize implementation. Delegate to the actual
*       audio device.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
STDMETHODIMP CRecPlayAudio::SetBufferNotifySize(ULONG cbSize)
{
    SPDBG_FUNC("CRecPlayAudio::SetBufferNotifySize");
    HRESULT hr;
    
    SPAUTO_OBJ_LOCK;
    
    hr = m_cpAudio == NULL
        ? SPERR_UNINITIALIZED
        : m_cpAudio->SetBufferNotifySize(cbSize);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetNextFileName *
*--------------------------------*
*   Description:  
*       Get the next file name either from the file list or create it from
*       the base file information
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CRecPlayAudio::GetNextFileName(WCHAR ** ppszFileName)
{
    SPDBG_FUNC("CRecPlayAudio::GetNextFileName");
    HRESULT hr = S_OK;

    CSpDynamicString dstrFileName;
    dstrFileName = m_dstrDirectory;
    if (dstrFileName.Length() >= 1 &&
        dstrFileName[dstrFileName.Length() - 1] != '\\')
    {
        dstrFileName.Append(L"\\");
    }
    
    if (m_pszFileList != NULL)
    {
        // Skip leading space and semi-colons
        while (iswspace(*m_pszFileList) || *m_pszFileList == ';')
        {
            m_pszFileList++;
        }

        // This is the beginning
        WCHAR * pszBeginningOfFileName = m_pszFileList;

        // Loop until we hit the end
        while (*m_pszFileList && *m_pszFileList != ';')
        {
            m_pszFileList++;
        }

        // Copy the filename
        CSpDynamicString dstrTemp;
        //PREFIX: check memory alloc
        if (NULL == (dstrTemp = pszBeginningOfFileName))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            dstrTemp.TrimToSize(ULONG(m_pszFileList - pszBeginningOfFileName));

            // If it contains slashes, it's probably a fully qualified path,
            // use that directly, otherwise append it to the already existing
            // filename which has already been prep'd with the directory
            if (wcschr(dstrTemp, L'\\') == NULL)
            {
                dstrFileName.Append(dstrTemp);
            }
            else
            {
                dstrFileName = dstrTemp;
            }
        }

        // We're done, this will trigger no more files
        if (*m_pszFileList == '\0')
        {
            m_pszFileList = NULL;
        }
    }
    else if (m_dstrBaseFile != NULL && 
             m_ulBaseFileNextNum <= m_ulBaseFileMaxNum)
    {
        TCHAR szNum[10];
        wsprintf(szNum, _T("%03d"), m_ulBaseFileNextNum++);

        USES_CONVERSION;
        
        dstrFileName.Append2(m_dstrBaseFile, T2W(szNum));
        dstrFileName.Append(L".wav");

        // Now update the token with the new file number
        // if we're writing
        if (m_fOut)
        {
            hr = m_cpToken->SetDWORD(L"BaseFileNextNum", m_ulBaseFileNextNum);
        }
    }
    else
    {
        hr = SPERR_NO_MORE_ITEMS;
    }

    if (SUCCEEDED(hr))
    {
        *ppszFileName = dstrFileName.Detach();
    }

    if (hr != SPERR_NO_MORE_ITEMS)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;
}

/****************************************************************************
* CRecPlayAudio::GetNextFileReady *
*---------------------------------*
*   Description:  
*       Get the next file ready, either input or output.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CRecPlayAudio::GetNextFileReady()
{
    SPDBG_FUNC("CRecPlayAudio::GetNextFileReady");
    HRESULT hr = S_OK;

    // If we're reading or writing
    if (m_fIn || m_fOut)
    {
        m_cpInStream.Release();
        m_cpOutStream.Release();
        
        // Get the file name
        CSpDynamicString dstrFileName;
        hr = GetNextFileName(&dstrFileName);

        if (hr == SPERR_NO_MORE_ITEMS)
        {
            // The file list has been fully used.
            // Set finished reading event to 1.
            HRESULT hr2 = S_OK;

            // Time to check 'StartReadingEvent' to
            // signal that we need to refresh our list of files.
            if (WaitForSingleObject(m_hStartReadingEvent, 0) == WAIT_OBJECT_0)
            {
                // Reset event.
                ResetEvent(m_hStartReadingEvent);
                ResetEvent(m_hFinishedReadingEvent);
                // Initialize with new file list.
                hr2 = InitFileList();
                SPDBG_ASSERT(SUCCEEDED(hr2));
                hr = GetNextFileName(&dstrFileName);
                // hr should now be S_OK
            }
            if (hr == SPERR_NO_MORE_ITEMS)
            {
                SetEvent(m_hFinishedReadingEvent);
                // hr is still SPERR_NO_MORE_ITEMS
            }

        }

        // Create the stream
        CComPtr<ISpStream> cpStream;
        if (SUCCEEDED(hr))
        {
            hr = cpStream.CoCreateInstance(CLSID_SpStream);
        }

        // Get the actual audio device format so we can open
        // our output to the correct format, or we can ensure
        // that our new input file is of the correct format
        GUID guidFormat;
        CSpCoTaskMemPtr<WAVEFORMATEX> pwfex;
        if (SUCCEEDED(hr))
        {
            hr = m_cpAudio->GetFormat(&guidFormat, &pwfex);
        }

        // Bind the stream to the specific file
        if (SUCCEEDED(hr))
        {
            hr = cpStream->BindToFile(
                            dstrFileName, 
                            m_fIn
                                ? SPFM_OPEN_READONLY
                                : SPFM_CREATE_ALWAYS,
                            m_fIn
                                ? NULL
                                : &guidFormat, 
                            m_fIn
                                ? NULL
                                : pwfex, 
                            0);
        }

        // Set up whichever stream we're supposed to
        if (SUCCEEDED(hr))
        {
            if (m_fIn)
            {
                m_cpInStream = cpStream;
            }
            else
            {
                m_cpOutStream = cpStream;
            }
        }
    }
    
    if (hr != SPERR_NO_MORE_ITEMS)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;
}

/****************************************************************************
* CRecPlayAudio::VerifyFormats *
*------------------------------*
*   Description:  
*       Verify that the formats are in fact correct.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
HRESULT CRecPlayAudio::VerifyFormats()
{
    SPDBG_FUNC("CRecPlayAudio::VerifyFormats");
    HRESULT hr;
    
    GUID guidFormat;
    CSpCoTaskMemPtr<WAVEFORMATEX> pwfex;

    // See what the acutal device format is
    SPDBG_ASSERT(m_cpAudio != NULL);
    hr = m_cpAudio->GetFormat(&guidFormat, &pwfex);

    // Make sure our input is the same
    if (SUCCEEDED(hr) && m_cpInStream != NULL)
    {
        GUID guidFormatIn;
        CSpCoTaskMemPtr<WAVEFORMATEX> pwfexIn;
        hr = m_cpInStream->GetFormat(&guidFormatIn, &pwfexIn);
    
        if (SUCCEEDED(hr))
        {
            if (guidFormat != guidFormatIn ||
                pwfex->cbSize != pwfexIn->cbSize ||
                memcmp(pwfex, pwfexIn, sizeof(WAVEFORMATEX) + pwfex->cbSize) != 0)
            {
                hr = SPERR_UNSUPPORTED_FORMAT;
            }
        }
    }

    // Make sure out output is the same
    if (SUCCEEDED(hr) && m_cpOutStream != NULL)
    {
        GUID guidFormatOut;
        CSpCoTaskMemPtr<WAVEFORMATEX> pwfexOut;
        hr = m_cpOutStream->GetFormat(&guidFormatOut, &pwfexOut);
        
        if (SUCCEEDED(hr))
        {
            if (guidFormat != guidFormatOut ||
                pwfex->cbSize != pwfexOut->cbSize ||
                memcmp(pwfex, pwfexOut, sizeof(WAVEFORMATEX) + pwfex->cbSize) != 0)
            {
                hr = SPERR_UNSUPPORTED_FORMAT;
            }                
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\recognizer.cpp ===
/******************************************************************************
* Recognizer.cpp *
*----------------*
*  This is the implementation of CRecognizer.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#include "stdafx.h"
#include "Recognizer.h"
#include "SrTask.h"

/****************************************************************************
* CInprocRecognizer::FinalConstruct *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CInprocRecognizer::FinalConstruct()
{
    SPDBG_FUNC("CInprocRecognizer::FinalConstruct");
    HRESULT hr = S_OK;

    m_fIsSharedReco = false;

    hr = CRecognizer::FinalConstruct();
    if (SUCCEEDED(hr))
    {
        hr = m_RecoInst.FinalConstruct(this);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CInprocRecognizer::FinalRelease *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CInprocRecognizer::FinalRelease()
{
    SPDBG_FUNC("CInprocRecognizer::FinalRelease");
    
    m_RecoInst.FinalRelease();
}


HRESULT CInprocRecognizer::SendPerformTask(ENGINETASK * pTask)
{
    SPDBG_ASSERT("CInprocRecognizer::SendPerformTask");
    HRESULT hr = S_OK;
    
    hr = m_RecoInst.PerformTask(pTask);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


//---- SHARED RECOGNIZER IMPLEMENTATION -------------------------------------

/****************************************************************************
* CSharedRecognizer::FinalConstruct *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSharedRecognizer::FinalConstruct()
{
    SPDBG_FUNC("CSharedRecognizer::FinalConstruct");
    HRESULT hr = S_OK;

    m_fIsSharedReco = true;
    
    hr = CRecognizer::FinalConstruct();
    
    if (SUCCEEDED(hr))
    {
        hr = m_cpunkCommunicator.CoCreateInstance(CLSID_SpCommunicator, (ISpCallReceiver*)this);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpunkCommunicator->QueryInterface(&m_pCommunicator);
    }

    if (SUCCEEDED(hr))
    {
        m_pCommunicator->Release();
        hr = m_pCommunicator->AttachToServer(CLSID__SpSharedRecoInst);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSharedRecognizer::FinalRelease *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CSharedRecognizer::FinalRelease()
{
    SPDBG_FUNC("CSharedRecognizer::FinalRelease");

    m_cpunkCommunicator.Release();
}


/****************************************************************************
* CSharedRecognizer::SendPerformTask *
*------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSharedRecognizer::SendPerformTask(ENGINETASK * pTask)
{
    SPDBG_FUNC("CSharedRecognizer::PerformTask");
    HRESULT hr = S_OK;

    ULONG cbData = 
        sizeof(SHAREDRECO_PERFORM_TASK_DATA) + 
        (pTask->pvAdditionalBuffer != NULL 
            ? pTask->cbAdditionalBuffer 
            : 0);
    SHAREDRECO_PERFORM_TASK_DATA * pdata =
        (SHAREDRECO_PERFORM_TASK_DATA*) new BYTE[cbData];

    if (pdata == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        pdata->task = *pTask;
        if (pTask->pvAdditionalBuffer != NULL)
        {
            memcpy(
                LPBYTE(pdata) + sizeof(SHAREDRECO_PERFORM_TASK_DATA), 
                pTask->pvAdditionalBuffer, 
                pTask->cbAdditionalBuffer);
        }
        
        hr = m_pCommunicator->SendCall(
                    SHAREDRECO_PERFORM_TASK_METHOD,
                    pdata,
                    cbData,
                    TRUE,
                    NULL,
                    NULL);
    }

    delete pdata;
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


STDMETHODIMP CSharedRecognizer::ReceiveCall(
    DWORD dwMethodId,
    PVOID pvData,
    ULONG cbData,
    PVOID * ppvDataReturn,
    ULONG * pcbDataReturn)
{
    SPDBG_FUNC("CSharedRecognizer::ReceiveCall");
    HRESULT hr = S_OK;

    switch (dwMethodId)
    {
        case SHAREDRECO_EVENT_NOTIFY_METHOD:
            hr = ReceiveEventNotify(pvData, cbData);
            break;

        case SHAREDRECO_RECO_NOTIFY_METHOD:
            hr = ReceiveRecognitionNotify(pvData, cbData);
            break;

        case SHAREDRECO_TASK_COMPLETED_NOTIFY_METHOD:
            hr = ReceiveTaskCompletedNotify(pvData, cbData);
            break;

        default:
            hr = E_FAIL;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSharedRecognizer::ReceiveEventNotify(PVOID pvData, ULONG cbData)
{
    SPDBG_FUNC("CSharedRecognizer::ReceiveEventNotify");
    HRESULT hr = S_OK;

    SHAREDRECO_EVENT_NOTIFY_DATA * pdata = 
        (SHAREDRECO_EVENT_NOTIFY_DATA*)pvData;

    if (cbData < sizeof(SHAREDRECO_EVENT_NOTIFY_DATA) ||
        cbData != sizeof(*pdata) + pdata->cbSerializedSize)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        SPSERIALIZEDEVENT64 * pEvent = 
            (SPSERIALIZEDEVENT64*)((BYTE*)pdata + sizeof(*pdata));
        
        hr = this->EventNotify(
                        pdata->hContext,
                        pEvent,
                        pdata->cbSerializedSize);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSharedRecognizer::ReceiveRecognitionNotify(PVOID pvData, ULONG cbData)
{
    SPDBG_FUNC("CSharedRecognizer::ReceiveRecognitionNotify");
    HRESULT hr = S_OK;

    SHAREDRECO_RECO_NOTIFY_DATA * pdata =
        (SHAREDRECO_RECO_NOTIFY_DATA*)pvData;

    SPRESULTHEADER * pResultHeaderEmbedded =
        (SPRESULTHEADER*)((BYTE*)pdata + sizeof(*pdata));

    if (cbData < sizeof(SHAREDRECO_RECO_NOTIFY_DATA) + sizeof(SPRESULTHEADER) ||
        cbData != sizeof(*pdata) + pResultHeaderEmbedded->ulSerializedSize)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {

        SPRESULTHEADER * pCoMemPhraseNowOwnedByCtxt = 
            (SPRESULTHEADER*)::CoTaskMemAlloc(pResultHeaderEmbedded->ulSerializedSize);

        if (pCoMemPhraseNowOwnedByCtxt == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            memcpy(pCoMemPhraseNowOwnedByCtxt, pResultHeaderEmbedded, pResultHeaderEmbedded->ulSerializedSize);

            hr = this->RecognitionNotify(
                            pdata->hContext, 
                            pCoMemPhraseNowOwnedByCtxt, 
                            pdata->wParamEvent, 
                            pdata->eEventId);
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSharedRecognizer::ReceiveTaskCompletedNotify(PVOID pvData, ULONG cbData)
{
    SPDBG_FUNC("CSharedRecognizer::ReceiveTaskCompletedNotify");
    HRESULT hr = S_OK;

    if (cbData < sizeof(ENGINETASKRESPONSE))
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        ENGINETASKRESPONSE * pResponse = (ENGINETASKRESPONSE *)pvData;
        void * pvAdditionalBuffer = NULL;
        ULONG cbAdditionalBuffer = cbData - sizeof(*pResponse);
        if (cbAdditionalBuffer)
        {
            pvAdditionalBuffer = (pResponse + 1);
        }

        hr = this->TaskCompletedNotify(pResponse, pvAdditionalBuffer, cbAdditionalBuffer);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;

}


//---- COMMON RECOGNIZER CODE (INPROC AND SHARED) ---------------------------

/****************************************************************************
* CRecognizer::AddRecoContextToList *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecognizer::AddRecoContextToList(CRecoCtxt * pCtxt)
{
    SPAUTO_SEC_LOCK(&m_CtxtListCritSec)
    SPDBG_FUNC("CRecognizer::AddRecoContextToList");
    HRESULT hr = S_OK;
    
    m_CtxtList.InsertHead(pCtxt);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::RemoveRecoContextFromList *
*----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecognizer::RemoveRecoContextFromList(CRecoCtxt * pCtxt)
{
    SPAUTO_SEC_LOCK(&m_CtxtListCritSec)
    SPDBG_FUNC("CRecognizer::RemoveRecoContextFromList");
    HRESULT hr = S_OK;

    m_CtxtList.Remove(pCtxt);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::FinalConstruct *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/


HRESULT CRecognizer::FinalConstruct()
{
    SPDBG_FUNC("CRecognizer::FinalConstruct");
    HRESULT hr = S_OK;
    
    hr = m_autohTaskComplete.InitEvent(NULL, FALSE, FALSE, NULL);

    m_ulTaskID = 0;
	m_fAllowFormatChanges = true;   // We want the audio objects format to be adjusted if possible
                                    // This avoids using potentially nasty ACM converters.                                  

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CRecognizer::SetPropertyNum *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::SetPropertyNum( const WCHAR* pName, LONG lValue )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::SetPropertyNum");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pName))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRIT_SETPROPERTYNUM::SetPropertyNum(this, pName, lValue);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::GetPropertyNum *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetPropertyNum( const WCHAR* pName, LONG* plValue )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetPropertyNum");
    HRESULT hr = S_OK;
    
    if (SP_IS_BAD_STRING_PTR(pName))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(plValue))
        {
            hr = E_POINTER;
        }
        else
        {
            hr = CRIT_GETPROPERTYNUM::GetPropertyNum(this, pName, plValue);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::SetPropertyString *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::SetPropertyString( const WCHAR* pName, const WCHAR* pValue )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::SetPropertyString");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pName) || SP_IS_BAD_STRING_PTR(pValue))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRIT_SETPROPERTYSTRING::SetPropertyString(this, pName, pValue);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::GetPropertyString *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetPropertyString( const WCHAR* pName, WCHAR** ppCoMemValue )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetPropertyString");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pName))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(ppCoMemValue))
        {
            hr = E_POINTER;
        }
        else
        {
            hr = CRIT_GETPROPERTYSTRING::GetPropertyString(this, pName, ppCoMemValue);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecognizer::SetRecognizer *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::SetRecognizer(ISpObjectToken * pEngineToken)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::SetRecognizer");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pEngineToken))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRIT_SETRECOGNIZER::SetRecognizer(this, pEngineToken);
    }

    // NTRAID#SPEECH-13025-2001/06/28-cthrash: We should be resetting the clsidExtension on the CRecoCtxt object

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::GetRecognizer *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetRecognizer(ISpObjectToken ** ppEngineToken)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetRecognizer");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppEngineToken))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = CRIT_GETRECOGNIZER::GetRecognizer(this, ppEngineToken);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::SetInput *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::SetInput(IUnknown * pUnkInput, BOOL fAllowFormatChanges)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::SetInput");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pUnkInput))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<ISpObjectToken> cpObjToken;
        CComPtr<ISpStreamFormat> cpStream;
        if (pUnkInput)
        {
            if (m_fIsSharedReco)
            {
                hr = SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER;
            }
            else if(FAILED(pUnkInput->QueryInterface(&cpObjToken)) &&
                 FAILED(pUnkInput->QueryInterface(&cpStream)))
            {
                hr = E_INVALIDARG;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = CRIT_SETINPUT::SetInput(this, cpObjToken, cpStream, fAllowFormatChanges);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::GetInputObjectToken *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetInputObjectToken(ISpObjectToken ** ppToken)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetInputObjectToken");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppToken))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = CRIT_GETINPUTTOKEN::GetInputToken(this, ppToken);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecognizer::GetInputStream *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetInputStream(ISpStreamFormat ** ppStream)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetInputStream");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppStream))
    {
        hr = E_POINTER;
    }
    else
    {
        if (this->m_fIsSharedReco)
        {
            hr = SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER;
        }
        else
        {
            hr = CRIT_GETINPUTSTREAM::GetInputStream(this, ppStream);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::CreateRecoContext *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::CreateRecoContext(ISpRecoContext ** ppNewContext)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::CreateRecoContext");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppNewContext))
    {
        hr = E_POINTER;
    }
    else
    {
        if (m_fIsSharedReco)
        {
            // The shared object will automatically add itself (it calls Init() internally)5
            hr = ::CoCreateInstance(CLSID_SpSharedRecoContext, NULL, CLSCTX_ALL, __uuidof(*ppNewContext), (void **)ppNewContext);
        }
        else
        {
            CComObject<CRecoCtxt> * pNewCtxt;
            hr = CComObject<CRecoCtxt>::CreateInstance(&pNewCtxt);
            if (SUCCEEDED(hr))
            {
                hr = pNewCtxt->Init(this);
                if (SUCCEEDED(hr))
                {
                    pNewCtxt->AddRef();
                    *ppNewContext = pNewCtxt;
                }
                else
                {
                    delete pNewCtxt;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecognizer::GetRecoProfile *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetRecoProfile(ISpObjectToken **ppToken)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetRecoProfile");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppToken))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = CRIT_GETPROFILE::GetProfile(this, ppToken);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::SetRecoProfile *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::SetRecoProfile(ISpObjectToken *pToken)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::SetRecoProfile");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pToken))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRIT_SETPROFILE::SetProfile(this, pToken);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::IsSharedInstance *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::IsSharedInstance()
{
    SPDBG_FUNC("CRecognizer::IsSharedInstance");
    return m_fIsSharedReco ? S_OK : S_FALSE;
}

/****************************************************************************
* CRecognizer::SetRecoState *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::SetRecoState( SPRECOSTATE NewState )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::SetRecoState");
    HRESULT hr = S_OK;

    if (NewState != SPRST_ACTIVE && NewState != SPRST_INACTIVE && NewState != SPRST_INACTIVE_WITH_PURGE
        && NewState != SPRST_ACTIVE_ALWAYS)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRIT_SETRECOSTATE::SetState(this, NewState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::GetRecoState *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetRecoState( SPRECOSTATE *pState )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetRecoState");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pState))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRIT_GETRECOSTATE::GetState(this, pState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::GetStatus *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetStatus(SPRECOGNIZERSTATUS * pStatus)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetStatus");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pStatus))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = CRIT_GETRECOINSTSTATUS::GetStatus(this, pStatus);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::GetFormat *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::GetFormat(SPSTREAMFORMATTYPE FormatType, GUID *pFormatId, WAVEFORMATEX **ppCoMemWFEX)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::GetFormat");
    HRESULT hr = S_OK;

    if (FormatType != SPWF_INPUT && FormatType != SPWF_SRENGINE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(pFormatId) || SP_IS_BAD_WRITE_PTR(ppCoMemWFEX))
        {
            hr = E_POINTER;
        }
        else
        {
            hr = CRIT_GETAUDIOFORMAT::GetFormat(this, FormatType, pFormatId, ppCoMemWFEX);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecognizer::IsUISupported *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::IsUISupported(const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData, BOOL *pfSupported)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::IsUISupported");
    HRESULT hr = S_OK;

    CComPtr<ISpObjectToken> cpObjToken;
    BOOL fSupported = FALSE;
    
    if (pvExtraData != NULL && SPIsBadReadPtr(pvExtraData, cbExtraData))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(pfSupported))
    {
        hr = E_POINTER;
    }
    
    // See if the recognizer supports the UI
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpEngineToken;
        if (GetRecognizer(&cpEngineToken) == S_OK)
        {
            hr = cpEngineToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, (ISpRecognizer*)this, &fSupported);
        }
    }
    
    // See if the audio object supports the UI
    if (SUCCEEDED(hr) && !fSupported)
    {
        CComPtr<ISpObjectToken> cpInToken;
        if (GetInputObjectToken(&cpInToken) == S_OK)
        {
            hr = cpInToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, GetControllingUnknown(), &fSupported);
        }
    }
    
    // Copy back if it's supported or not
    if (SUCCEEDED(hr))
    {
        *pfSupported = fSupported;
    }

    return hr;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecognizer::DisplayUI *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::DisplayUI(HWND hwndParent, const WCHAR * pszTitle, const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::DisplayUI");
    HRESULT hr = S_OK;

    CComPtr<ISpObjectToken> cpObjToken;
    BOOL fSupported = FALSE;
    
    // Validate params
    if (!IsWindow(hwndParent) ||
        SP_IS_BAD_OPTIONAL_STRING_PTR(pszTitle) ||
        (pvExtraData != NULL && SPIsBadReadPtr(pvExtraData, cbExtraData)))
    {
        hr = E_INVALIDARG;
    }

    // See if the recognizer supports the UI
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpObjectToken> cpEngineToken;
        if (GetRecognizer(&cpEngineToken) == S_OK)
        {
            hr = cpEngineToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, (ISpRecognizer*)this, &fSupported);
            if (SUCCEEDED(hr) && fSupported)
            {
                hr = cpEngineToken->DisplayUI(hwndParent, pszTitle, pszTypeOfUI, pvExtraData, cbExtraData, (ISpRecognizer*)this);
            }
        }
    }
    
    // See if the audio object supports the UI
    if (SUCCEEDED(hr) && !fSupported)
    {
        CComPtr<ISpObjectToken> cpInToken;
        if (GetInputObjectToken(&cpInToken) == S_OK)
        {
            hr = cpInToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, GetControllingUnknown(), &fSupported);
            if (SUCCEEDED(hr) && fSupported)
            {
                hr = cpInToken->DisplayUI(hwndParent, pszTitle, pszTypeOfUI, pvExtraData, cbExtraData, GetControllingUnknown());
            }
        }
    }
    
    // If nobody supported, we should consider the pszTypeOfUI to be a bad parameter
    if (SUCCEEDED(hr) && !fSupported)
    {
        hr = E_INVALIDARG;
    }

    return hr;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecognizer::EmulateRecognition *
*---------------------------------*
*   Description:
*
*   Returns:
*       S_OK - Phrase parsed completely and recognition was emulated
*       SP_NO_PARSE_FOUND - Phrase did not match any active rules
*       SP_RECOGNIZER_INACTIVE - Recognition is not currently active, so emulation
*                                can't complete.
*       or other error code.
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::EmulateRecognition(ISpPhrase * pPhrase)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecognizer::EmulateRecognition");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pPhrase))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = CRIT_EMULATERECOGNITION::EmulateReco(this, pPhrase);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CRecognizer::PerformTask *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecognizer::PerformTask(ENGINETASK * pTask)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CInprocRecognizer::PerformTask");
    HRESULT hr = S_OK;

    pTask->Response.ulTaskID = m_ulTaskID;

    pTask->Response.__pCallersTask = pTask;
    pTask->hCompletionEvent = m_autohTaskComplete;

    hr = this->SendPerformTask(pTask);

    if (SUCCEEDED(hr))
    {
        // Wait for up to 3 minutes before timing out...
        // the SR engine could be recognizing a really long utterance...
        switch (SpWaitForSingleObjectWithUserOverride(m_autohTaskComplete, 3 * 60000))
        {
        case WAIT_OBJECT_0:
            hr = pTask->Response.hr;
            m_ulTaskID++;
            break;
        case WAIT_TIMEOUT:
            {
                SPAUTO_SEC_LOCK(&m_TaskCompleteTimeoutCritSec);
                m_ulTaskID++;
                if (WAIT_OBJECT_0 ==  m_autohTaskComplete.Wait(0))
                {
                    hr = pTask->Response.hr;
                }
                else
                {
                    hr = SPERR_TIMEOUT;
                }
            }
            break;
        default:
            hr = SpHrFromLastWin32Error();
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//--- These methods are called from the RecoInst object to send events back
//--- to reco contexts.

/****************************************************************************
* CRecognizer::EventNotify *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecognizer::EventNotify(SPRECOCONTEXTHANDLE hContext, const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize)
{
    SPAUTO_SEC_LOCK(&m_CtxtListCritSec)
    SPDBG_FUNC("CRecognizer::EventNotify");
    HRESULT hr = S_OK;

    CRecoCtxt * pCtxt = m_CtxtList.Find(hContext);
    if (pCtxt)
    {
        hr = pCtxt->EventNotify(pEvent, cbSerializedSize);
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    if (hr != E_UNEXPECTED)
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }

    return hr;
}

/****************************************************************************
* CRecognizer::RecognitionNotify *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecognizer::RecognitionNotify(SPRECOCONTEXTHANDLE hContext, SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, WPARAM wParamEvent, SPEVENTENUM eEventId)
{
    SPAUTO_SEC_LOCK(&m_CtxtListCritSec)
    SPDBG_FUNC("CRecognizer::RecognitionNotify");
    HRESULT hr = S_OK;

    CRecoCtxt * pCtxt = m_CtxtList.Find(hContext);
    if (pCtxt)
    {
        hr = pCtxt->RecognitionNotify(pCoMemPhraseNowOwnedByCtxt, wParamEvent, eEventId);
    }
    else
    {
        SPDBG_ASSERT(false);
        hr = E_UNEXPECTED;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}   

/****************************************************************************
* CRecognizer::TaskCompletedNotify *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecognizer::TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalData, ULONG cbAdditionalData)
{
    SPAUTO_SEC_LOCK(&m_TaskCompleteTimeoutCritSec);

    SPDBG_FUNC("CRecognizer::TaskCompletedNotify");
    HRESULT hr = S_OK;

    if (pResponse->ulTaskID != m_ulTaskID)
    {
        hr = SPERR_TIMEOUT;
    }
    else
    {
        ENGINETASK * pOriginalTask = pResponse->__pCallersTask;

        pOriginalTask->Response = *pResponse;
        if (cbAdditionalData)
        {
            void * pDest;
            if (pOriginalTask->fExpectCoMemResponse)
            {
                pDest = ::CoTaskMemAlloc(cbAdditionalData);
                pOriginalTask->Response.pvCoMemResponse = pDest;
                if (pDest == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    pOriginalTask->Response.hr = hr;
                }
            }
            else
            {
                pDest = pOriginalTask->pvAdditionalBuffer;
                SPDBG_ASSERT(pOriginalTask->cbAdditionalBuffer == cbAdditionalData);
                SPDBG_ASSERT(pOriginalTask->fAdditionalBufferInResponse);
            }
            if (pDest)
            {
               memcpy(pDest, pvAdditionalData, cbAdditionalData);
            }
        }
        ::SetEvent(pOriginalTask->hCompletionEvent);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\regdatakey.cpp ===
/****************************************************************************
*   RegDataKey.cpp
*       Implementation for the CSpRegDataKey class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "RegDataKey.h"

//
//  Helper function will return a CoTaskMemAllocated string.  It will reallocate the buffer
//  if necessary to support strings > MAX_PATH.  If the key value is not found it will return
//  S_FALSE.  Note that for empty strings in the registry (they exist, but consist of only
//  a NULL), this function will return S_FALSE and a NULL pointer.
//
inline HRESULT SpQueryRegString(HKEY hk, const WCHAR * pszSubKey, WCHAR ** ppValue)
{
    HRESULT hr = S_OK;
    CSpDynamicString dstr;
    WCHAR szFirstTry[MAX_PATH];
    DWORD cch = sp_countof(szFirstTry);
    LONG rr = g_Unicode.RegQueryStringValue(hk, pszSubKey, szFirstTry, &cch);
    if (rr == ERROR_SUCCESS)
    {
        dstr = szFirstTry;
    }
    else
    {
        if (rr == ERROR_FILE_NOT_FOUND)
        {
            hr = SPERR_NOT_FOUND;
        }
        else
        {
            if (rr == ERROR_MORE_DATA)
            {
                dstr.ClearAndGrowTo(cch);
                if (dstr)
                {
                    rr = g_Unicode.RegQueryStringValue(hk, pszSubKey, dstr, &cch);
                }
            }
            hr = SpHrFromWin32(rr);
        }
    }
    if (hr == S_OK)
    {
        *ppValue = dstr.Detach();
        if (*ppValue == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppValue = NULL;
    }
    
    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }
    
    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;
}


/*****************************************************************************
* CSpRegDataKey::CSpRegDataKey *
*------------------------------*
*   Description:
*       ctor
******************************************************************* robch ***/
CSpRegDataKey::CSpRegDataKey() :
m_hkey(NULL)
{
    SPDBG_FUNC("CSpRegDataKey::CSpRegDataKey");
}

/*****************************************************************************
* CSpRegDataKey::~CSpRegDataKey *
*-------------------------------*
*   Description:
*       If a key has been opened, it will be closed when the object is 
*       destroyed.
******************************************************************* robch ***/
CSpRegDataKey::~CSpRegDataKey()
{
    SPDBG_FUNC("CSpRegDataKey::~CSpRegDataKey");
    if (m_hkey)
    {
        ::RegCloseKey(m_hkey);
    }
}

/*****************************************************************************
* CSpRegDataKey::SetKey *
*-----------------------*
*   Description:
*       Set's the registry key to use.
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::SetKey(HKEY hkey, BOOL fReadOnly)
{
    SPDBG_FUNC("CSpRegDataKey::SetKey");
    HRESULT hr;

    if (m_hkey != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else
    {
        m_fReadOnly = fReadOnly;
        m_hkey = hkey;
        hr = S_OK;
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpRegDataKey::SetData *
*------------------------*
*   Description:
*       Writes the specified binary data to the registry.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::SetData(
    const WCHAR * pszValueName, 
    ULONG cbData, 
    const BYTE * pData)
{
    SPDBG_FUNC("CSpRegDataKey::SetData");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszValueName) ||
        SPIsBadReadPtr(pData, cbData))
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        LONG lRet = g_Unicode.RegSetValueEx(
                m_hkey, pszValueName, 
                0, 
                REG_BINARY, 
                pData, 
                cbData);
        hr = SpHrFromWin32(lRet);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpRegDataKey::GetData *
*------------------------*
*   Description:
*       Reads the specified binary data from the registry.
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::GetData(
    const WCHAR * pszValueName, 
    ULONG * pcbData, 
    BYTE * pData)
{
    SPDBG_FUNC("CSpRegDataKey::GetData");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszValueName))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(pcbData) || 
             SPIsBadWritePtr(pData, *pcbData))
    {
        hr = E_POINTER;
    }
    else
    {
        DWORD dwType;
        LONG lRet = g_Unicode.RegQueryValueEx(
                    m_hkey, 
                    pszValueName, 
                    0, 
                    &dwType, 
                    pData, 
                    pcbData);
        hr = SpHrFromWin32(lRet);
    }
    
    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }
    
    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;
}

/*****************************************************************************
* CSpRegDataKey::SetStringValue *
*-------------------------------*
*   Description:
*       Reads the specified string value from the registry. If pszValueName 
*       is NULL then the default value of the registry key is read.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::SetStringValue(
    const WCHAR * pszValueName, 
    const WCHAR * pszValue)
{
    SPDBG_FUNC("CSpRegDataKey::SetStringValue");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszValueName) || 
        SP_IS_BAD_STRING_PTR(pszValue))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LONG lRet = g_Unicode.RegSetStringValue(m_hkey, pszValueName, pszValue);
        hr = SpHrFromWin32(lRet);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpRegDataKey::GetStringValue *
*-------------------------------*
*   Description:
*       Writes the specified string value to the registry. If pszValueName is 
*       NULL then the default value of the registy key is read.
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::GetStringValue(
    const WCHAR * pszValueName, 
    WCHAR ** ppValue)
{
    SPDBG_FUNC("CSpRegDataKey::GetStringValue");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszValueName))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppValue))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = SpQueryRegString(m_hkey, pszValueName, ppValue);
    }

    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/*****************************************************************************
* CSpRegDataKey::SetDWORD *
*-------------------------*
*   Description:
*       Writes the specified DWORD to the registry.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::SetDWORD(const WCHAR * pszValueName, DWORD dwValue)
{
    SPDBG_FUNC("CSpRegDataKey::SetDWORD");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszValueName))
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        LONG lRet = g_Unicode.RegSetValueEx(
                    m_hkey, 
                    pszValueName, 
                    0, REG_DWORD, 
                    (BYTE*)&dwValue, 
                    sizeof(dwValue));
        hr = SpHrFromWin32(lRet);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpRegDataKey::GetDWORD *
*-------------------------*
*   Description:
*       Reads the specified DWORD from the registry.
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::GetDWORD(
    const WCHAR * pszValueName, 
    DWORD *pdwValue)
{
    SPDBG_FUNC("CSpRegDataKey::GetDWORD");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszValueName))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(pdwValue))
    {
        hr = E_POINTER;
    }
    else
    {
        DWORD dwType, dwSize = sizeof(*pdwValue);
        LONG lRet = g_Unicode.RegQueryValueEx(
                    m_hkey, 
                    pszValueName, 
                    0, 
                    &dwType, 
                    (BYTE*)pdwValue, 
                    &dwSize);
        hr = SpHrFromWin32(lRet);
    }
    
    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/*****************************************************************************
* CSpRegDataKey::OpenKey *
*------------------------*
*   Description:
*       Opens a sub-key and returns a new object which supports ISpDataKey 
*       for the specified sub-key.
*
*   Return:
*   S_OK on success
*   SPERR_NOT_FOUND if not found
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::OpenKey(
    const WCHAR * pszSubKeyName, 
    ISpDataKey ** ppKey)
{
    SPDBG_FUNC("CSpRegDataKey::SetStringValue");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszSubKeyName) || 
        wcslen(pszSubKeyName) == 0)
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(ppKey))
    {
        hr = E_POINTER;
    }
    else
    {
        HKEY hk;
        LONG lRet = g_Unicode.RegOpenKeyEx(
                        m_hkey, 
                        pszSubKeyName, 
                        0, 
                        m_fReadOnly
                            ? KEY_READ
                            : KEY_READ | KEY_WRITE,
                        &hk);
        hr = SpHrFromWin32(lRet);

        if (SUCCEEDED(hr))
        {
            CComObject<CSpRegDataKey> * pNewKey;
            hr = CComObject<CSpRegDataKey>::CreateInstance(&pNewKey);
            if (SUCCEEDED(hr))
            {
                pNewKey->SetKey(hk, m_fReadOnly);
                pNewKey->QueryInterface(ppKey);
            }
            else
            {
                ::RegCloseKey(hk);
            }
        }
    }
    
    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/*****************************************************************************
* CSpRegDataKey::CreateKey *
*--------------------------*
*   Description:
*       Creates a sub-key and returns a new object which supports ISpDataKey 
*       for the specified sub-key.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::CreateKey(
    const WCHAR * pszSubKeyName, 
    ISpDataKey ** ppKey)
{
    SPDBG_FUNC("CSpRegDataKey::CreateKey");
    HRESULT hr = S_OK;
    HKEY hk;

    if (SP_IS_BAD_STRING_PTR(pszSubKeyName) || 
        wcslen(pszSubKeyName) == 0 ||
        SP_IS_BAD_WRITE_PTR(ppKey))
    {
        return E_INVALIDARG;
    }

    LONG lRet = g_Unicode.RegCreateKeyEx(
                            m_hkey, 
                            pszSubKeyName, 
                            0, 
                            NULL, 
                            0, 
                            m_fReadOnly
                                ? KEY_READ
                                : KEY_READ | KEY_WRITE,
                            NULL, 
                            &hk, 
                            NULL);

    if (lRet == ERROR_SUCCESS)
    {
        CComObject<CSpRegDataKey> * pNewKey;
        hr = CComObject<CSpRegDataKey>::CreateInstance(&pNewKey);
        if (SUCCEEDED(hr))
        {
            pNewKey->SetKey(hk, m_fReadOnly);
            hr = pNewKey->QueryInterface(ppKey);
        }
        else
        {
            ::RegCloseKey(hk);
        }
    }
    else
    {
        hr = SpHrFromWin32(lRet);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpRegDataKey::DeleteKey *
*--------------------------*
*   Description:
*       Deletes the specified key.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::DeleteKey(const WCHAR * pszSubKeyName)
{
    SPDBG_FUNC("CSpRegDataKey:DeleteKey");
    HRESULT hr;
    
    if (SP_IS_BAD_STRING_PTR(pszSubKeyName))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LONG lRet = g_Unicode.RegDeleteKey(m_hkey, pszSubKeyName);
        hr = SpHrFromWin32(lRet);
    }
    
    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;
}

/*****************************************************************************
* CSpRegDataKey::DeleteValue *
*----------------------------*
*   Description:
*       Deletes the specified value from the key.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::DeleteValue(const WCHAR * pszValueName)
{   
    SPDBG_FUNC("CSpRegDataKey::DeleteValue");
    HRESULT hr;
    
    if (SP_IS_BAD_OPTIONAL_STRING_PTR(pszValueName)) // allows deletion of default (null) value
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LONG lRet = g_Unicode.RegDeleteValue(m_hkey, pszValueName);
        hr = SpHrFromWin32(lRet);
    }

    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;    
}

/*****************************************************************************
* CSpRegDataKey::EnumKeys *
*-------------------------*
*   Description:
*   Enumerates the specified (by index) key

*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::EnumKeys(ULONG Index, WCHAR ** ppszKeyName)
{
    SPDBG_FUNC("CSpRegDataKey::EnumKeys");
    HRESULT hr;

    WCHAR szKeyName[MAX_PATH];
    ULONG cch = sp_countof(szKeyName);
    if (SP_IS_BAD_WRITE_PTR(ppszKeyName))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LONG lRet = g_Unicode.RegEnumKey(m_hkey, Index, szKeyName, &cch);
        hr =  SpHrFromWin32(lRet);
        if ( SUCCEEDED(hr) )
        {
            hr = SpCoTaskMemAllocString(szKeyName, ppszKeyName);
        }
    }

    if (hr == SpHrFromWin32(ERROR_NO_MORE_ITEMS))
    {
        hr = SPERR_NO_MORE_ITEMS;
    }

    if (hr != SPERR_NO_MORE_ITEMS)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/*****************************************************************************
* CSpRegDataKey::EnumValues *
*---------------------------*
*   Description:
*   Enumerates the specified (by index) values.

*   Return:
*   S_OK
*   E_OUTOFMEMORY
******************************************************************* robch ***/
STDMETHODIMP CSpRegDataKey::EnumValues(ULONG Index, WCHAR ** ppszValueName)
{
    SPDBG_FUNC("CSpRegDataKey::EnumValues");
    HRESULT hr;

    WCHAR szValueName[MAX_PATH];
    ULONG cch = sp_countof(szValueName);
    if (SP_IS_BAD_WRITE_PTR(ppszValueName))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LONG lRet = g_Unicode.RegEnumValueName(m_hkey, Index, szValueName, &cch);
        hr = SpHrFromWin32(lRet);
        if (SUCCEEDED(hr))
        {
            hr = SpCoTaskMemAllocString(szValueName, ppszValueName);
        }
    }

    if (hr == SpHrFromWin32(ERROR_NO_MORE_ITEMS))
    {
        hr = SPERR_NO_MORE_ITEMS;
    }

    if (hr != SPERR_NO_MORE_ITEMS)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\recplayaudio.h ===
/****************************************************************************
*   RecPlayAudio.h
*       Definitions for the CRecPlayAudio audio device.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "resource.h"
#include "sapi.h"


//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
* CRecPlayAudio *
*---------------*
*   Description:  
*       Definition of the CRecPlayAudio class. CRecPlay is used to either
*       replace data from an actual audio device at runtime with data from
*       a set of files, or to record data from the audio device while passing
*       it back to SAPI. The SAPI and SR teams uses this in testing and data
*       collection.
*
*       The "user" needs to set up a valid ObjectToken for the RecPlay 
*       audio input. Here's an example of how you might set up the RecPlay
*       token to replace runtime data with the files specified.
*
*       HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\
*           Speech\AudioInput\Tokens\RecPlayReadFileList
*
*               (Default)           RecPlay Read (random files from c:\recplay)
*               AudioTokenId        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\AudioInput\TokenEnums\MMAudioIn\
*               CLSID               {FEE225FC-7AFD-45e9-95D0-5A318079D911}
*               ReadOrWrite         Read
*               Directory           c:\recplay
*               FileList            newgame.wav;playace.wav
*
*       You could also set it up to read from a series of files (it will read from 
*       c:\recplay\recplay001.wav, then
*       c:\recplay\recplay002.wav, and finally
*       c:\recplay\recplay003.wav
*
*       HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\
*           Speech\AudioInput\Tokens\RecPlayReadBaseFile
*
*               (Default)           RecPlay Read (c:\recplay\recplay###.wav, 1 through 3)
*               AudioTokenId        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\AudioInput\TokenEnums\MMAudioIn\
*               CLSID               {FEE225FC-7AFD-45e9-95D0-5A318079D911}
*               ReadOrWrite         Read
*               Directory           c:\recplay
*               BaseFile            RecPlay
*               BaseFileNextNum     1
*               BaseFileMaxNum      3
*
*       Here's an example of how you might set up the RecPlay token to
*       record data at runtime to the directory specified. Each time the
*       microphone is opened, RecPlay will create a new file. So for this
*       example below, it would create files like:
*       c:\recplay\recplay001.wav, then
*       c:\recplay\recplay002.wav, and then
*       c:\recplay\recplay003.wav ...
*
*       HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\
*           Speech\AudioInput\Tokens\RecPlayWriteBaseFile
*
*               (Default)           RecPlay Record (c:\recplay\recplay###.wav, 1 to 65534)
*               AudioTokenId        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\AudioInput\TokenEnums\MMAudioIn\
*               CLSID               {FEE225FC-7AFD-45e9-95D0-5A318079D911}
*               ReadOrWrite         Write
*               Directory           c:\recplay
*               BaseFile            RecPlay
*               BaseFileNextNum     1
*
*       You can also set up the recording to record to a specific list of files.
*       In this example, the first time the mic is opened, we'll write data to
*       c:\recplay\newgame.wav, and then once the mic is closed, and reopened,
*       we'll write data to c:\recplay\aceofspades.wav. After that, we won't record
*       any more data.
*
*       HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\
*           Speech\AudioInput\Tokens\RecPlayWriteFileList
*
*               (Default)           RecPlay Record (random files from c:\recplay)
*               AudioTokenId        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\AudioInput\TokenEnums\MMAudioIn\
*               CLSID               {FEE225FC-7AFD-45e9-95D0-5A318079D911}
*               ReadOrWrite         Write
*               Directory           c:\recplay
*               FileList            newgame.wav;aceofspaces.wav
*
*       These objects will then both be selectable by the control panel
*       as well as used directly with Speech, by calling
*       ISpRecognizer->SetInput(...) in the inprocess case, or in the out
*       of process case, you could call SpSetDefaultTokenIdForCategoryId(...)
*
*       NOTES:
*
*       (Default), AudioTokenId, CLSID, and ReadOrWrite are required values
*       in the token.
*
*       ReadOrWrite must be exactly, either "Read" or "Write"
*
*       Directory is optional. If it isn't specified, the current working
*       directory of the process is used. This may be the server process,
*       so unless you really know what you're doing, you should probably
*       specify the directory.
*
*       You can either specify FileList or BaseFile. You cannot use both.
*
*       FileList is a semi-colon delimitted list of file names. The filenames
*       can be non-fully qualified file names (like newgame.wav) and RecPlay
*       will use the Directory specified above. The filenames can also be fully
*       qualified and RecPlay will not prepend the Directory from above.
*
*       BaseFile is the base file name if there is no file list. If there is
*       no FileList or BaseFile, we default to a BaseFile of "RecPlay".
*
*       BaseFileNextNum is the next number to be used when creating a filename
*       using BaseFile from above. Defaults to 0 if not specified.
*
*       BaseFileMaxNum is the maximum number that will be used to find a
*       file name. For example, if BaseFileNextNum is 1, and BaseFileMaxNum
*       is 3, only three files will be used.
*       
*       Finally, the audio object can be programmatically controlled to a
*       limited extent to allow restarting with the same or an update filelist.
*       When the audio object is created, it will create two named Win32 events.
*       The first is the 'StartReadingEvent' (SRE) and can be remotely opened and 
*       signalled to trigger RecPlayAudio into refreshing it's filelist from the 
*       registry and restarting sending data from the files.
*       The second is the 'FinishedReadingEvent' (FRE) and will be set by 
*       RecPlayAudio when it has exhausted the supplied filelist.
*
*       RecPlayAudio can also be started with an empty filelist by creating the
*       FileList entry as "" or the BaseFile as "" (but not both). Then later
*       you can supply a new filelist and signal the SRE event and RecPlayAudio
*       will read the new list and start sending the data.
*       The two names of the events will be added as strings under the names
*       'StartReadingEvent' and 'FinishedReadingEvent'.
*
*       The intended approach for programmatical control is to set up the audio
*       object with an empty filelist or an initial set which will be immediately
*       sent to the engine when recognition is started.
*       Then at any time in the future, the event entries are read to get the
*       names of the named events. The FRE event is waited on until it is signalled
*       to indicate the filelist has been exhausted.
*       The test application now updates the registry entries for the filelist and
*       signals the SRE event to cause the audio object to re-read the registry and
*       restart with the new filelist.
*
******************************************************************** robch */
class ATL_NO_VTABLE CRecPlayAudio : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CRecPlayAudio, &CLSID_SpRecPlayAudio>,
    public ISpAudio,
    public ISpObjectWithToken
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_RECPLAYAUDIO)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CRecPlayAudio)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
        COM_INTERFACE_ENTRY(ISequentialStream)
        COM_INTERFACE_ENTRY(IStream)
        COM_INTERFACE_ENTRY(ISpStreamFormat)
        COM_INTERFACE_ENTRY(ISpAudio)
    END_COM_MAP()

//=== Public methods ===
public:

    //--- ctor, dtor, etc ---
    CRecPlayAudio();
    void FinalRelease();
    
//=== Interfaces ===
public:

    //--- ISpObjectWithToken ---
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

    //--- ISequentialStream ---
    STDMETHODIMP Read(void * pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void * pv, ULONG cb, ULONG *pcbWritten);

    //--- IStream ---
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert(void);
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

    //--- ISpStreamFormat ---
    STDMETHODIMP GetFormat(GUID * pguidFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);

    //--- ISpAudio ---
    STDMETHODIMP SetState(SPAUDIOSTATE NewState, ULONGLONG ullReserved );
    STDMETHODIMP SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx);
    STDMETHODIMP GetStatus(SPAUDIOSTATUS *pStatus);
    STDMETHODIMP SetBufferInfo(const SPAUDIOBUFFERINFO * pInfo);
    STDMETHODIMP GetBufferInfo(SPAUDIOBUFFERINFO * pInfo);
    STDMETHODIMP GetDefaultFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);
    STDMETHODIMP_(HANDLE) EventHandle();
	STDMETHODIMP GetVolumeLevel(ULONG *pLevel);
	STDMETHODIMP SetVolumeLevel(ULONG Level);
    STDMETHODIMP GetBufferNotifySize(ULONG *pcbSize);
    STDMETHODIMP SetBufferNotifySize(ULONG cbSize);

//=== Private methods ===
private:

    HRESULT GetNextFileName(WCHAR ** ppszFileName);
    HRESULT GetNextFileReady();
    HRESULT InitFileList();
    
    HRESULT VerifyFormats();    

//=== Data ===
private:

    CComPtr<ISpObjectToken> m_cpToken;          // RecPlay's token
    CComPtr<ISpAudio> m_cpAudio;                // The actual audio device

    BOOL m_fIn;
    CComPtr<ISpStream> m_cpOutStream;

    BOOL m_fOut;
    CComPtr<ISpStream> m_cpInStream;

    CSpDynamicString m_dstrDirectory;
    
    CSpDynamicString m_dstrFileList;
    WCHAR * m_pszFileList;

    CSpDynamicString m_dstrBaseFile;
    ULONG m_ulBaseFileNextNum;
    ULONG m_ulBaseFileMaxNum;

    HANDLE m_hStartReadingEvent;
    HANDLE m_hFinishedReadingEvent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\reghelpers.h ===
/****************************************************************************
*   RegHelpers.h
*       Definition of SAPI Registry helper functions
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Inline Function Definitions -------------------------------------------

inline HKEY SpHkeyFromSPDKL(SPDATAKEYLOCATION spdkl)
{
    HKEY hkey;
    switch (spdkl)
    {
        default:
            SPDBG_ASSERT(spdkl == SPDKL_DefaultLocation);
            hkey = HKEY(0);
            break;

        case SPDKL_LocalMachine:
            hkey = HKEY_LOCAL_MACHINE;
            break;

        case SPDKL_CurrentUser:
            hkey = HKEY_CURRENT_USER;
            break;

#ifndef _WIN32_WCE
        case SPDKL_CurrentConfig:
            hkey = HKEY_CURRENT_CONFIG;
            break;
#endif // _WIN32_WCE
    }
    return hkey;
}
            
inline HRESULT SpSzRegPathToHkey(HKEY hkeyReplaceRoot, const WCHAR * pszRegPath, BOOL fCreateIfNotExist, HKEY * phkey, BOOL * pfReadOnly)
{
    typedef struct REGPATHTOKEY
    {
        const WCHAR * psz;
        HKEY hkey;
    } REGPATHTOKEY;

    REGPATHTOKEY rgRegPathToKeys[] = 
    {
        { L"HKEY_CLASSES_ROOT\\",   HKEY_CLASSES_ROOT },
        { L"HKEY_LOCAL_MACHINE\\",  HKEY_LOCAL_MACHINE },
        { L"HKEY_CURRENT_USER\\",   HKEY_CURRENT_USER },
#ifndef _WIN32_WCE
        { L"HKEY_CURRENT_CONFIG\\", HKEY_CURRENT_CONFIG }
#endif // _WIN32_WCE
    };

    HRESULT hr = SPERR_INVALID_REGISTRY_KEY;

    // Loop thru the different keys we know about
    int cRegPathToKeys = sp_countof(rgRegPathToKeys);
    for (int i = 0; i < cRegPathToKeys; i++)
    {
        // If we've foudn the match
        const WCHAR * psz = rgRegPathToKeys[i].psz;
        if (wcsnicmp(pszRegPath, psz, wcslen(psz)) == 0)
        {
            HKEY hkeyRoot = hkeyReplaceRoot == NULL
                                ? rgRegPathToKeys[i].hkey
                                : hkeyReplaceRoot;
                                
            HKEY hkey;
            BOOL fReadOnly = FALSE;

            pszRegPath = wcschr(pszRegPath, L'\\');
            SPDBG_ASSERT(pszRegPath != NULL);
            pszRegPath++;

            // Try to create/open the key with read / write access
            LONG lRet;

            if (fCreateIfNotExist)
            {
                lRet = g_Unicode.RegCreateKeyEx(
                            hkeyRoot, 
                            pszRegPath, 
                            0, 
                            NULL, 
                            0, 
                            KEY_READ | KEY_WRITE, 
                            NULL, 
                            &hkey, 
                            NULL);
            }
            else
            {
                lRet = g_Unicode.RegOpenKeyEx(
                            hkeyRoot,
                            pszRegPath,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkey);
            }                            

            // If that failed, try read only access
            if (lRet != ERROR_SUCCESS)
            {
                fReadOnly = TRUE;
                if (fCreateIfNotExist)
                {
                    lRet = g_Unicode.RegCreateKeyEx(
                                hkeyRoot, 
                                pszRegPath, 
                                0, 
                                NULL, 
                                0, 
                                KEY_READ, 
                                NULL, 
                                &hkey, 
                                NULL);
                }
                else
                {
                    lRet = g_Unicode.RegOpenKeyEx(
                                hkeyRoot,
                                pszRegPath,
                                0,
                                KEY_READ,
                                &hkey);
                }
            }

            if (lRet == ERROR_SUCCESS)
            {
                *phkey = hkey;
                if (pfReadOnly != NULL)
                {
                    *pfReadOnly = fReadOnly;
                }
                hr = S_OK;
            }
            else if (lRet == ERROR_FILE_NOT_FOUND || lRet == ERROR_NO_MORE_ITEMS)
            {
                hr = SPERR_NOT_FOUND;
            }
            else
            {
                hr = SpHrFromWin32(lRet);
            }

            break;
        }
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

inline SpSzRegPathToDataKey(HKEY hkeyReplaceRoot, const WCHAR * pszRegPath, BOOL fCreateIfNotExist, ISpDataKey ** ppDataKey)
{
    SPDBG_FUNC("SpSzRegPathToDataKey");
    HRESULT hr;

    // Convert the string to an hkey
    HKEY hkey = NULL;
    BOOL fReadOnly;
    hr = SpSzRegPathToHkey(hkeyReplaceRoot, pszRegPath, fCreateIfNotExist, &hkey, &fReadOnly);

    // Create the underlying registry based data key
    CComPtr<ISpRegDataKey> cpRegDataKey;
    if (SUCCEEDED(hr))
    {
        hr = cpRegDataKey.CoCreateInstance(CLSID_SpDataKey);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpRegDataKey->SetKey(hkey, fReadOnly);
    }

    if (SUCCEEDED(hr))
    {
        hkey = NULL;
        hr = cpRegDataKey->QueryInterface(ppDataKey);
    }

    if (FAILED(hr))
    {
        if (hkey != NULL)
        {
            ::RegCloseKey(hkey);
        }
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/****************************************************************************
* SpRecurseDeleteRegKey *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
inline HRESULT SpRecurseDeleteRegKey(HKEY hkeyRoot, const WCHAR * pszKeyName)
{
    SPDBG_FUNC("SpRecurseDeleteRegKey");
    HRESULT hr = S_OK;
    HKEY hkey;

    hr = SpHrFromWin32(g_Unicode.RegOpenKeyEx(hkeyRoot, pszKeyName, 0, KEY_ALL_ACCESS, &hkey));
    if (SUCCEEDED(hr))
    {
        while (SUCCEEDED(hr))
        {
            WCHAR szSubKey[MAX_PATH];
            ULONG cch = sp_countof(szSubKey);
            LONG rr = g_Unicode.RegEnumKey(hkey, 0, szSubKey, &cch);  // Always look at 0 since we keep deleteing them...
            if (rr == ERROR_NO_MORE_ITEMS)
            {
                break;
            }
            hr = SpHrFromWin32(rr);
            if (SUCCEEDED(hr))
            {
                hr = SpRecurseDeleteRegKey(hkey, szSubKey);
            }
        }
        ::RegCloseKey(hkey);
        if (SUCCEEDED(hr))
        {   
            LONG rr = g_Unicode.RegDeleteKey(hkeyRoot, pszKeyName);
            hr = SpHrFromWin32(rr);
        }
    }

    if (hr == SpHrFromWin32(ERROR_FILE_NOT_FOUND))
    {
        hr = SPERR_NOT_FOUND;
    }
    return hr;
}

/****************************************************************************
* SpDeleteRegPath *
*-----------------*
*   Description:  
*       Delete a registry key based on a registry path (string)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
inline HRESULT SpDeleteRegPath(const WCHAR * pszRegPath, const WCHAR * pszSubKeyName)
{
    SPDBG_FUNC("SpDeleteRegPath");
    HRESULT hr = S_OK;

    // We may need to parse pszRegPath for the root and the sub key ...
    
    CSpDynamicString dstrRegPathRoot;
    CSpDynamicString dstrSubKeyName;

    if (pszSubKeyName == NULL)
    {
        // To best understand the parsing, here's an example:
        //
        //              HKEY\Key1\Key2\Key3
        // pszRegPath   ^
        // pszLastSlash               ^
        //
        // pszLastSlash - pszRegPath = 14;
        // dstrRegPathRoot = "HKEY\Key1\Key2"
        //
        // dstrSubKeyName = "Key3"
        
        // To find the root, and the keyname, we first need to find
        // the last slash
        const WCHAR * pszLastSlash = wcsrchr(pszRegPath, L'\\');
        if (pszLastSlash == NULL)
        {
            hr = SPERR_INVALID_TOKEN_ID;
        }

        if (SUCCEEDED(hr))
        {
            dstrRegPathRoot = pszRegPath;
            dstrRegPathRoot.TrimToSize((ULONG)(pszLastSlash - pszRegPath));
            dstrSubKeyName = pszLastSlash + 1;
        }
    }
    else
    {
        // No need to parse, the caller passed both in ...
        dstrRegPathRoot = pszRegPath;
        dstrSubKeyName = pszSubKeyName;
    }

    // Try to convert the regpath into an actual key
    HKEY hkeyRoot;
    if (SUCCEEDED(hr))
    {
        hr = SpSzRegPathToHkey(NULL, dstrRegPathRoot, FALSE, &hkeyRoot, NULL);
    }

    // Now call our existing helper to delete a sub key recursively
    if (SUCCEEDED(hr))
    {
        hr = SpRecurseDeleteRegKey(hkeyRoot, dstrSubKeyName);
        ::RegCloseKey(hkeyRoot);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sapi.rc
//
#define IDS_PROJNAME                    100
#define IDR_SPRESOURCEMANAGER           101
#define IDS_XMLDOMLOAD                  101
#define IDS_XMLFORM                     102
#define IDR_SPVOICE                     103
#define IDS_EMPTY_LEAF                  103
#define IDR_SPSERVERPR                  104
#define IDS_P_INSIDE_LN                 104
#define IDS_OPT_INSIDE_LIST             105
#define IDR_SPEECHVOICE                 106
#define IDS_IGNORE_PROPNAME             106
#define IDR_SPEECHAUDIO                 107
#define IDS_USE_EXPRULE                 107
#define IDR_SPEECHSTREAM                108
#define IDS_EXPRULE_NOTIMPL             108
#define IDR_BUFFSTREAM                  109
#define IDS_IGNORE_TAG                  109
#define IDS_STATEWITHNOARCS             110
#define IDS_NOEXPORTS                   111
#define IDS_EMPTY_LANGUAGE              112
#define IDR_RECOGNIZER                  113
#define IDS_PARSER_INTERNAL_ERROR	114
#define IDS_XML_FORMAT_ERROR		115
#define IDS_UNK_ATTRIB			116
#define IDS_INCORR_ATTRIB_VALUE		117
#define IDS_UNSUPPORTED_WORDTYPE	118
#define IDS_INCORR_DELIMITER		119
#define IDS_DEFINE_ID_ERROR		120
#define IDS_INVALID_ID_VALUE		121
#define IDS_MIN_MAX_ERROR		122
#define IDS_EMPTY_STRING		123
#define IDS_MISSING_REQUIRED_ATTRIBUTE  124
#define IDS_RULE_REDEFINITION		125
#define IDS_ID_REDEFINITION		126
#define IDS_CONTAINMENT_ERROR		127
#define IDS_UNKNOWN_TAG			128
#define IDS_XOR_ATTRIBS			129
#define IDS_INVALID_RULEREF		130
#define IDS_INVALID_GRAMMAR_REFERENCE   131
#define IDS_MISSING_PROPERTY_NAME       132
#define IDS_MISSING_ID_VALUE		133
#define IDS_IDNAME_CONTAINS_SPACE	134
#define IDS_INCORR_VAL_ATTRIB_VALUE	135
#define IDS_OPT_IN_LIST                 136
#define IDS_MIN_IN_OPT                  137
#define IDS_MISSING_CLOSE_TAG           138
#define IDS_EMPTY_XML_RULE              139
#define IDS_PRON_WORD			140
#define IDS_DISP_WORD			141
#define IDS_PRON_SINGLE_WORD		142
#define IDS_INCORR_DELIM                143
#define IDS_INCORR_WORDFORMAT           144
#define IDS_INCORR_ATTRIBUTE            145
#define IDS_CUSTOM_PRON_EXISTS          146
#define IDS_TERMINAL_NODE               147
#define IDS_IE5_REQUIRED                148
#define IDS_AMBIGUOUS_PROPERTY          149

#define IDS_MSG				153
#define IDS_UNDEFINED_RULE              154
#define IDS_EMPTY_RULE                  155
#define IDS_DYNAMIC_EXPORT              156
#define IDS_SAVE_FAILED                 157
#define IDS_EPSILON_RULE                158
#define IDS_NO_RULES                    159
#define IDS_CIRCULAR_REF                160
#define IDS_WRITE_ERROR                 161
#define IDS_INTRNAL_ERROR               162
#define IDS_NOEXITPATH			        163
#define IDR_WMNOTIFY                    202
#define IDR_W32EVENT                    203
#define IDR_SPTASKMANAGER               204
#define IDR_AUDIOOUT                    205
#define IDR_WAVSTREAM                   206
#define IDR_AUDIOIN                     207
#define IDR_SPNOTIFY                    208
#define IDR_RECOCTXT                    210
#define IDR_SPUSER                      212
#define IDR_FMTCONV                     213
#define IDR_MMAUDIOENUM                 214
#define IDR_OBJECTTOKENENUMBUILDER      215
#define IDR_OBJECTTOKEN                 216
#define IDR_CFGENGINE                   217
#define IDR_LEXICON                     218
#define IDR_SPPHRASE                    219
#define IDR_VENDORLX                    220
#define IDR_LTSLX                       221
#define IDR_FRONTEND                    222
#define IDR_BACKEND                     223
#define IDR_PHONECONV                   227
#define IDR_NULLPHONECONV               228
#define IDR_TTS1033                     229
// two free IDs here
#define IDR_DSAUDIOIN                   232
#define IDR_DSAUDIOOUT                  233
#define IDR_DSAUDIOENUM                 234
#define IDR_SRRECEIVER                  237
#define IDR_ITNPROCESSOR                238
#define IDR_RECPLAYAUDIO                240
#define IDR_CONTLEXICON                 243
#define IDR_UNCOMPRESSEDLEXICON         244
#define IDR_COMPRESSEDLEXICON           248
#define IDR_OBJECTTOKENCATEGORY         249
#define IDR_REGDATAKEY                  250
#define IDR_SRRECOMASTER                251
#define IDR_SHAREDRECOINST              252
#define IDR_SPCOMMUNICATOR              253
#define IDR_SPSAPISERVER                254
#define IDR_SPAUDIOUI                   255
#define IDR_SPTEXTSELECTIONINFORMATION  256
#define IDR_SPPHRASEINFOBUILDER         257
#define IDR_SPAUDIOFORMAT	        258
#define IDR_SPWAVEFORMATEX              259
#define IDR_INPROCRECOCTXT              260
#define IDR_SPCUSTOMSTREAM              261
#define IDR_SPFILESTREAM                262
#define IDR_SPMEMORYSTREAM              263

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        264
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\regdatakey.h ===
/****************************************************************************
*   RegDataKey.h
*       Declarations for the CSpRegDataKey class.
*
*   Owner: robch
*   Copyright (c) 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include "sapi.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CSpRegDataKey :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpRegDataKey, &CLSID_SpDataKey>,
    public ISpRegDataKey
    #ifdef SAPI_AUTOMATION
    ,public IDispatchImpl<ISpeechDataKey, &IID_ISpeechDataKey, &LIBID_SpeechLib, 5>
    #endif // SAPI_AUTOMATION
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_REGDATAKEY)

    BEGIN_COM_MAP(CSpRegDataKey)
        COM_INTERFACE_ENTRY(ISpDataKey)
        COM_INTERFACE_ENTRY(ISpRegDataKey)
        #ifdef SAPI_AUTOMATION
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ISpeechDataKey)
        #endif // SAPI_AUTOMATION
    END_COM_MAP()

//=== Methods ===
public:

    //--- Ctor, dtor, etc ---
    CSpRegDataKey();
    ~CSpRegDataKey();

//=== Interfaces ===
public:

    //--- ISpDataKey ----------------------------------------------------------
    STDMETHODIMP SetData(const WCHAR * pszKeyName, ULONG cbData, const BYTE * pData);
    STDMETHODIMP GetData(const WCHAR * pszKeyName, ULONG * pcbData, BYTE * pData);
    STDMETHODIMP GetStringValue(const WCHAR * pszKeyName, WCHAR ** ppValue);
    STDMETHODIMP SetStringValue(const WCHAR * pszKeyName, const WCHAR * pszValue);
    STDMETHODIMP SetDWORD(const WCHAR * pszKeyName, DWORD dwValue );
    STDMETHODIMP GetDWORD(const WCHAR * pszKeyName, DWORD *pdwValue );
    STDMETHODIMP OpenKey(const WCHAR * pszSubKeyName, ISpDataKey ** ppKey);
    STDMETHODIMP CreateKey(const WCHAR * pszSubKeyName, ISpDataKey ** pKey);
    STDMETHODIMP DeleteKey(const WCHAR * pszSubKeyName);
    STDMETHODIMP DeleteValue(const WCHAR * pszValueName);
    STDMETHODIMP EnumKeys(ULONG Index, WCHAR ** ppszSubKeyName);
    STDMETHODIMP EnumValues(ULONG Index, WCHAR ** ppszValueName);

    //--- ISpRegDataKey -----------------------------------------------------------
    
    STDMETHODIMP SetKey(HKEY hkey, BOOL fReadOnly);

    #ifdef SAPI_AUTOMATION
        //--- ISpeechDataKey ------------------------------------------------------
        STDMETHODIMP SetBinaryValue( const BSTR bstrValueName, VARIANT psaData );
        STDMETHODIMP GetBinaryValue( const BSTR bstrValueName, VARIANT* psaData );
        STDMETHODIMP SetStringValue( const BSTR bstrValueName, const BSTR szString );
        STDMETHODIMP GetStringValue( const BSTR bstrValueName, BSTR * szSting );
        STDMETHODIMP SetLongValue( const BSTR bstrValueName, long Long );
        STDMETHODIMP GetLongValue( const BSTR bstrValueName, long* pLong );
        STDMETHODIMP OpenKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey );
        STDMETHODIMP CreateKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey );
        STDMETHODIMP DeleteKey( const BSTR bstrSubKeyName );
        STDMETHODIMP DeleteValue( const BSTR bstrValueName );
        STDMETHODIMP EnumKeys( long Index, BSTR* pbstrSubKeyName );
        STDMETHODIMP EnumValues( long Index, BSTR* pbstrValueName );
    #endif // SAPI_AUTOMATION

//=== Private data ===
private:

    HKEY m_hkey;
    BOOL m_fReadOnly;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\rwlock.cpp ===
/*******************************************************************************
* RWLock.cpp *
*------------*
*       Reader/Writer lock class
*
*  Owner: YUNUSM                                        Date: 06/18/99
*  Copyright (C) 1999 Microsoft Corporation. All Rights Reserved
*******************************************************************************/

//--- Includes ----------------------------------------------------------------

#include "stdafx.h"
#include "RWLock.h"
#include "CommonLx.h"

/*******************************************************************************
* CRWLock::CRWLock *
*------------------*
*   Description:
*       Constructor
*
*   Return:
***************************************************************** YUNUSM ******/
CRWLock::CRWLock(PRWLOCKINFO pInfo,     // header
                 HRESULT &hr            // result
                 )
{
    SPDBG_FUNC("CRWLock::CRWLock");
    
    hr = S_OK;
    bool fLockAcquired = false;

    m_hFileMapping = NULL;
    m_pSharedMem = NULL;
    m_hInitMutex = NULL;
    m_hReaderEvent = NULL;
    m_hGlobalMutex = NULL;
    m_hWriterMutex = NULL;
    m_piCounter = NULL;

    if (IsBadReadPtr(pInfo, sizeof (RWLOCKINFO)))
        hr = E_INVALIDARG;
    
    HRESULT hRes = S_OK;
    OLECHAR szObject[64];

    if (SUCCEEDED(hr))
    {
        if (!StringFromGUID2(pInfo->guidLockInitMutexName, szObject, sizeof(szObject)/sizeof(OLECHAR)))
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        m_hInitMutex = g_Unicode.CreateMutex(NULL, FALSE, szObject);
        if (!m_hInitMutex)
            hr = SpHrFromLastWin32Error();
    }

    if (SUCCEEDED(hr))
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject (m_hInitMutex, INFINITE))
            fLockAcquired = true;
        else
            hr = E_FAIL;
    }
 
    if (SUCCEEDED(hr))
    {
        if (!StringFromGUID2(pInfo->guidLockReaderEventName, szObject, sizeof(szObject)/sizeof(OLECHAR)))
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        m_hReaderEvent = g_Unicode.CreateEvent(NULL, TRUE, FALSE, szObject);
        if (!m_hReaderEvent)
            hr = SpHrFromLastWin32Error();
    }
 
    if (SUCCEEDED(hr))
    {
        if (!StringFromGUID2(pInfo->guidLockGlobalMutexName, szObject, sizeof(szObject)/sizeof(OLECHAR)))
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        m_hGlobalMutex = g_Unicode.CreateEvent(NULL, FALSE, TRUE, szObject);
        if (!m_hGlobalMutex)
            hr = SpHrFromLastWin32Error();
    }

    if (SUCCEEDED(hr))
    {
        if (!StringFromGUID2(pInfo->guidLockWriterMutexName, szObject, sizeof(szObject)/sizeof(OLECHAR)))
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        m_hWriterMutex = g_Unicode.CreateMutex(NULL, FALSE, szObject);
        if (!m_hWriterMutex)
            hr = SpHrFromLastWin32Error();
    }
 
    if (SUCCEEDED(hr))
    {
        if (!StringFromGUID2(pInfo->guidLockMapName, szObject, sizeof(szObject)/sizeof(OLECHAR)))
            hr = E_FAIL;
    }

    bool fMapCreated = false;
    if (SUCCEEDED(hr))
    {
        m_hFileMapping =  g_Unicode.CreateFileMapping(INVALID_HANDLE_VALUE, // use the system paging file
                                                      NULL, PAGE_READWRITE, 0, sizeof (DWORD), szObject);
        if (!m_hFileMapping)
            hr = SpHrFromLastWin32Error();
        else
        {
            if (ERROR_ALREADY_EXISTS == GetLastError())
                fMapCreated = false;
            else
                fMapCreated = true;
        }
    }
 
    if (SUCCEEDED(hr))
    {
        m_pSharedMem = MapViewOfFile(m_hFileMapping, FILE_MAP_WRITE, 0, 0, 0);
        if (!m_pSharedMem)
            hr = SpHrFromLastWin32Error();
    }
 
    if (SUCCEEDED(hr))
    {
        m_piCounter = (PDWORD)(m_pSharedMem);
        if (fMapCreated)
            *m_piCounter = (DWORD)-1;
    }
        
    if (fLockAcquired)
        ReleaseMutex (m_hInitMutex);
} /* CRWLock::CRWLock */

/*******************************************************************************
* CRWLock::~CRWLock *
*-------------------*
*   Description:
*       Destructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
CRWLock::~CRWLock()
{
    SPDBG_FUNC("CRWLock::~CRWLock");
    
    CloseHandle (m_hInitMutex);
    CloseHandle (m_hReaderEvent);
    CloseHandle (m_hGlobalMutex);
    CloseHandle (m_hWriterMutex);
    
    UnmapViewOfFile (m_pSharedMem);
    CloseHandle (m_hFileMapping);
} /* CRWLock::~CRWLock */

/*******************************************************************************
* CRWLock::ClaimReaderLock *
*--------------------------*
*   Description:
*       Lets in multiple readers
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CRWLock::ClaimReaderLock(void)
{
    SPDBG_FUNC("CRWLock::ClaimReaderLock");
    
    if (InterlockedIncrement ((LPLONG)m_piCounter) == 0)
    {
        WaitForSingleObject (m_hGlobalMutex, INFINITE);
        SetEvent (m_hReaderEvent);
    }

    WaitForSingleObject (m_hReaderEvent, INFINITE);
} /* CRWLock::ClaimReaderLock */

/*******************************************************************************
* CRWLock::ClaimWriterLock *
*--------------------------*
*   Description:
*       Lets in a single writer
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CRWLock::ClaimWriterLock(void)
{
    SPDBG_FUNC("CRWLock::ClaimWriterLock");
    
    WaitForSingleObject (m_hWriterMutex, INFINITE);
    WaitForSingleObject (m_hGlobalMutex, INFINITE);
} /* CRWLock::ClaimWriterLock */

/*******************************************************************************
* CRWLock::ReleaseReaderLock *
*----------------------------*
*   Description:
*       Releases a reader lock
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CRWLock::ReleaseReaderLock(void)
{
    SPDBG_FUNC("CRWLock::ReleaseReaderLock");
     
    if (InterlockedDecrement ((LPLONG)m_piCounter) < 0)
    {
        ResetEvent (m_hReaderEvent);
        SetEvent (m_hGlobalMutex);
    }
} /* CRWLock::ReleaseReaderLock */

/*******************************************************************************
* CRWLock::ReleaseWriterLock *
*----------------------------*
*   Description:
*       Releases a writer lock
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CRWLock::ReleaseWriterLock(void)
{
    SPDBG_FUNC("CRWLock::ReleaseWriterLock");
    
    SetEvent (m_hGlobalMutex);
    ReleaseMutex (m_hWriterMutex);
} /* CRWLock::ReleaseWriterLock */

//--- End of File --------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\sapi.cpp ===
// Speech.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Speechps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <SPDebug.h>
#include <initguid.h>
#include "SpResMgr.h"
#include "SpVoice.h"
#include "SpNotify.h"
#include "TaskMgr.h"
#include "mmAudioOut.h"
#include "mmAudioIn.h" 
#include "mmaudioenum.h"
#if 0
#include "dsaudioin.h"
#include "dsaudioout.h"
#include "dsaudioenum.h"
#endif
#include "AudioUI.h"
#include "WavStream.h"
#include "a_voice.h"
#include "RecoCtxt.h"
#include "FmtConv.h"
#include "CFGEngine.h"
#include "dict.h"
#include "Lexicon.h"
#include "SpPhrase.h"
#include "VendorLx.h"
#include "PhoneConv.h"
#include "NullConv.h"
#include "BackEnd.h"
#include "FrontEnd.h"
#include "sapi_i.c"
#include "sapiddk_i.c"
#include "sapiint_i.c"
#include "spguid.c"
#include "ITNProcessor.h"
#include "AssertWithStack.cpp"
#include "RegDataKey.h"
#include "ObjectToken.h"
#include "ObjectTokenCategory.h"
#include "ObjectTokenEnumBuilder.h"
#include "RecPlayAudio.h"
#include "Recognizer.h"
#include "SrRecoMaster.h"
#include "SrRecoInst.h"
#include "SpSapiServer.h"
#include "SpCommunicator.h"
#include "RegHelpers.h"
#include "a_txtsel.h"
#include "a_phbuilder.h"
#include "a_customstream.h"
#include "a_filestream.h"
#include "a_memorystream.h"

//--- Initialize static member of debug scope class

CSpUnicodeSupport   g_Unicode;



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)

OBJECT_ENTRY(CLSID_SpVoice              , CSpVoice           )

OBJECT_ENTRY(CLSID_SpLexicon            , CSpLexicon        )
OBJECT_ENTRY(CLSID_SpUnCompressedLexicon, CSpUnCompressedLexicon  )
OBJECT_ENTRY(CLSID_SpCompressedLexicon  , CCompressedLexicon)

OBJECT_ENTRY(CLSID_SpPhoneConverter     , CSpPhoneConverter )
OBJECT_ENTRY(CLSID_SpNullPhoneConverter , CSpNullPhoneConverter )

OBJECT_ENTRY(CLSID_SpObjectTokenCategory, CSpObjectTokenCategory)
OBJECT_ENTRY(CLSID_SpObjectTokenEnum    , CSpObjectTokenEnumBuilder)
OBJECT_ENTRY(CLSID_SpObjectToken        , CSpObjectToken    )
OBJECT_ENTRY(CLSID_SpDataKey            , CSpRegDataKey     )

OBJECT_ENTRY(CLSID_SpMMAudioEnum        , CMMAudioEnum       )
OBJECT_ENTRY(CLSID_SpMMAudioIn          , CMMAudioIn         )
OBJECT_ENTRY(CLSID_SpMMAudioOut         , CMMAudioOut        )
OBJECT_ENTRY(CLSID_SpStreamFormatConverter, CFmtConv         )
OBJECT_ENTRY(CLSID_SpRecPlayAudio       , CRecPlayAudio     )
OBJECT_ENTRY(CLSID_SpAudioUI            , CAudioUI          )

#if 0
OBJECT_ENTRY(CLSID_SpDSoundAudioIn      , CDSoundAudioIn     )
OBJECT_ENTRY(CLSID_SpDSoundAudioOut     , CDSoundAudioOut    )
OBJECT_ENTRY(CLSID_SpDSoundAudioEnum    , CDSoundAudioEnum   )
#endif
OBJECT_ENTRY(CLSID_SpStream             , CWavStream         )

#ifndef _WIN64
OBJECT_ENTRY(CLSID_SpInprocRecognizer   , CInprocRecognizer  )
OBJECT_ENTRY(CLSID_SpSharedRecognizer   , CSharedRecognizer  )
OBJECT_ENTRY(CLSID_SpSharedRecoContext  , CSharedRecoCtxt    )

OBJECT_ENTRY(CLSID_SpPhraseBuilder      , CPhrase           )
OBJECT_ENTRY(CLSID_SpCFGEngine          , CCFGEngine        )
OBJECT_ENTRY(CLSID_SpGrammarCompiler    , CGramFrontEnd     )
OBJECT_ENTRY(CLSID_SpGramCompBackend    , CGramBackEnd      )
OBJECT_ENTRY(CLSID_SpITNProcessor       , CITNProcessor     )

OBJECT_ENTRY(CLSID__SpRecoMaster        , CRecoMaster       )
OBJECT_ENTRY(CLSID__SpSharedRecoInst    , CSharedRecoInst   )

OBJECT_ENTRY(CLSID_SpSapiServer         , CSpSapiServer     )
OBJECT_ENTRY(CLSID_SpCommunicator       , CSpCommunicator   )
#endif

OBJECT_ENTRY(CLSID_SpResourceManager    , CSpResourceManager )
OBJECT_ENTRY(CLSID_SpTaskManager        , CSpTaskManager     )
OBJECT_ENTRY(CLSID_SpNotifyTranslator   , CSpNotify          )

#ifdef SAPI_AUTOMATION
OBJECT_ENTRY(CLSID_SpTextSelectionInformation, CSpTextSelectionInformation )
OBJECT_ENTRY(CLSID_SpPhraseInfoBuilder  , CSpPhraseInfoBuilder )
OBJECT_ENTRY(CLSID_SpAudioFormat        , CSpeechAudioFormat )
OBJECT_ENTRY(CLSID_SpWaveFormatEx       , CSpeechWaveFormatEx )
OBJECT_ENTRY(CLSID_SpInProcRecoContext  , CInProcRecoCtxt )
OBJECT_ENTRY(CLSID_SpCustomStream       , CCustomStream )
OBJECT_ENTRY(CLSID_SpFileStream         , CFileStream )
OBJECT_ENTRY(CLSID_SpMemoryStream       , CMemoryStream )
#endif //SAPI_AUTOMATION

END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

#ifdef _WIN32_WCE
extern "C" BOOL WINAPI DllMain(HANDLE hInstance, ULONG dwReason, LPVOID)
#else
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
#endif
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, (HINSTANCE)hInstance, &LIBID_SpeechLib);
        CSpNotify::RegisterWndClass((HINSTANCE)hInstance);
        CSpThreadTask::RegisterWndClass((HINSTANCE)hInstance);
#ifdef _DEBUG
        // Turn on memory leak checking
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CSpNotify::UnregisterWndClass((HINSTANCE)hInstance);
        CSpThreadTask::UnregisterWndClass((HINSTANCE)hInstance);
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    #ifdef _DEBUG
    static BOOL fDoneOnce = FALSE;
    if (!fDoneOnce)
    {
        fDoneOnce = TRUE;
        SPDBG_DEBUG_CLIENT_ON_START();
    }
    #endif // _DEBUG

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}




/****************************************************************************
* SpWaitForSingleObjectWithUserOverride *
*---------------------------------------*
*   Description:
*       Identical to the Win32 function WaitForSingleObject except that this
*   method will examine the global registry key
*
*       HKCU\Software\Microsoft\Speech\Debug
*
*   if there is a string value set to
*
*       DisableTimeouts=1
*
*   then this function will wait forever.    
*
*   Returns:
*       Same values as WaitForSingleObject
*
********************************************************************* RAL ***/

DWORD SpWaitForSingleObjectWithUserOverride(HANDLE hEvent, DWORD dwTimeout)
{
    static long fInitialized = false;
    static bool fInfiniteTimeouts = false;

    LONG lIsInit = ::InterlockedExchange(&fInitialized, true);
    
    if (lIsInit == false)
    {
        CComPtr<ISpDataKey> cpDataKey;
        if (SUCCEEDED(SpSzRegPathToDataKey(NULL, SPREG_USER_ROOT L"\\Debug", FALSE, &cpDataKey)))
        {
            CSpDynamicString dstrTimeoutValue;
            if (S_OK == cpDataKey->GetStringValue(L"DisableTimeouts", &dstrTimeoutValue))
            {
                if (wcstol(dstrTimeoutValue, NULL, 10))
                {
                    fInfiniteTimeouts = true;
                }
            }
        }
    }

    DWORD dwWaitResult = ::WaitForSingleObject(hEvent, dwTimeout);
    if (dwWaitResult == WAIT_TIMEOUT && fInfiniteTimeouts)
    {
        SPDBG_PMSG0(_T("Warning:  Timeout for SAPI event ignored due to registry timeout override."));
        DWORD dwWaitResult = ::WaitForSingleObject(hEvent, INFINITE);
    }
    return dwWaitResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\sapilib.c ===
#include "sapi_i.c"
#include "sapiddk_i.c"
#include "sapiint_i.c"
#include "spguid.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\rwlock.h ===
/*******************************************************************************
*   RWLock.h
*       This is the header file for Reader/Writer lock class. This class uses shared
*       memory to store its synchronization object names. This enables it to offer
*       reader/writer lock capabilities across process boundaries.
*
*       The idea for this class came from the MSDN article 'Compound Win32 
*       Synchronization Objects' by Ruediger R. Asche.
*   
*   Owner: yunusm                                               Date: 06/18/99
*   Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes ----------------------------------------------------------------

#include <windows.h>

//--- TypeDef and Enumeration Declarations -------------------------------------

typedef struct _rwlockinfo
{
   GUID guidLockMapName;
   GUID guidLockInitMutexName;
   GUID guidLockReaderEventName;
   GUID guidLockGlobalMutexName;
   GUID guidLockWriterMutexName;
} RWLOCKINFO, *PRWLOCKINFO;

//--- Class, Struct and Union Definitions -------------------------------------

/*******************************************************************************
*
*   CRWLock
*
****************************************************************** YUNUSM *****/
class CRWLock
{
//=== Methods ====
public:
    CRWLock(PRWLOCKINFO, HRESULT &);
   ~CRWLock();

   void ClaimReaderLock(void);
   void ReleaseReaderLock(void);
   void ClaimWriterLock(void);
   void ReleaseWriterLock(void);

//=== Private data ===
private:
   HANDLE m_hFileMapping;
   PVOID  m_pSharedMem;
   HANDLE m_hInitMutex;
   HANDLE m_hReaderEvent;
   HANDLE m_hGlobalMutex;
   HANDLE m_hWriterMutex;
   PDWORD m_piCounter;
};

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spautoevent.h ===
#pragma once

#include "SpAutoHandle.h"

class CSpAutoEvent : public CSpAutoHandle
{
    public:
        HRESULT InitEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
        {
            SPDBG_ASSERT(m_h == NULL);
            m_h = g_Unicode.CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);
            return (m_h) ? S_OK :  SpHrFromLastWin32Error();
        }
        BOOL SetEvent()
        {
            SPDBG_ASSERT(m_h);
            return ::SetEvent(m_h);
        }
        HRESULT HrSetEvent()
        {
            SPDBG_ASSERT(m_h);
            if (::SetEvent(m_h))
            {
                return S_OK;
            }
            return SpHrFromLastWin32Error();
        }
        BOOL ResetEvent()
        {
            SPDBG_ASSERT(m_h);
            return ::ResetEvent(m_h);
        }
        HRESULT HrResetEvent()
        {
            SPDBG_ASSERT(m_h);
            if (::ResetEvent(m_h))
            {
                return S_OK;
            }
            return SpHrFromLastWin32Error();
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\resultheader.h ===
#define FT64(/*FILETIME*/ filetime) (*((LONGLONG*)&(filetime)))

class CResultHeader
{
public:
    SPRESULTHEADER *m_pHdr;
    BYTE *m_pbPhrase;
    BYTE *m_pbPhraseAlts;
    BYTE *m_pbAudio;
    BYTE *m_pbDriverData;
    ULONG m_nextOffset;

    CResultHeader() :
        m_pHdr(NULL),
        m_nextOffset(sizeof(SPRESULTHEADER)),
        m_pbPhrase(NULL),
        m_pbPhraseAlts(NULL),
        m_pbAudio(NULL),
        m_pbDriverData(NULL)
    {}

    ~CResultHeader()
    {
        if (m_pHdr)
        {
            ::CoTaskMemFree(m_pHdr);
        }
    }

    void Clear()
    {
        if (m_pHdr)
        {
            ::CoTaskMemFree(m_pHdr);
            m_pHdr = NULL;
            m_nextOffset = sizeof(SPRESULTHEADER);
            m_pbPhrase = NULL;
            m_pbPhraseAlts = NULL;
            m_pbAudio = NULL;
            m_pbDriverData = NULL;
        }
    }

    SPRESULTHEADER * Detach()
    {
        SPRESULTHEADER *phdr = m_pHdr;
        m_pHdr = NULL;
        m_nextOffset = sizeof(SPRESULTHEADER);
        m_pbPhrase = NULL;
        m_pbPhraseAlts = NULL;
        m_pbAudio = NULL;
        m_pbDriverData = NULL;
        return phdr;
    }

    HRESULT Init( ULONG ulCFGphrasesSize,
                  ULONG ulPhraseAltsSize,
                  ULONG ulRetainedDataSize,
                  ULONG ulDriverDataSize)
    {
        ULONG totalSize = ulCFGphrasesSize + ulPhraseAltsSize + ulRetainedDataSize + ulDriverDataSize + sizeof(SPRESULTHEADER);
        totalSize = (totalSize + 3) & ~3;   // round up to dword boundary

        m_pHdr = (SPRESULTHEADER*)::CoTaskMemAlloc(totalSize);
        if (m_pHdr)
        {
            ::memset(m_pHdr, 0, sizeof(SPRESULTHEADER));

            m_pHdr->ulSerializedSize = totalSize;
            m_pHdr->cbHeaderSize = sizeof(SPRESULTHEADER);

            if (ulCFGphrasesSize)
            {
                m_pHdr->ulPhraseDataSize = ulCFGphrasesSize;
                m_pHdr->ulPhraseOffset   = m_nextOffset;
                m_pbPhrase    = (BYTE*)m_pHdr + m_nextOffset;
                m_nextOffset += ulCFGphrasesSize;
            }

            if (ulPhraseAltsSize)
            {
                m_pHdr->ulPhraseAltDataSize = ulPhraseAltsSize;
                m_pHdr->ulPhraseAltOffset   = m_nextOffset;
                m_pbPhraseAlts = (BYTE*)m_pHdr + m_nextOffset;
                m_nextOffset  += ulPhraseAltsSize;
            }

            if (ulRetainedDataSize)
            {
                m_pHdr->ulRetainedDataSize = ulRetainedDataSize;
                m_pHdr->ulRetainedOffset = m_nextOffset;
                m_pbAudio = (BYTE*)m_pHdr + m_nextOffset;
                m_nextOffset += ulRetainedDataSize;
            }

            if (ulDriverDataSize)
            {
                m_pHdr->ulDriverDataSize = ulDriverDataSize;
                m_pHdr->ulDriverDataOffset = m_nextOffset;
                m_pbDriverData = (BYTE*)m_pHdr + m_nextOffset;
                m_nextOffset += ulDriverDataSize;
            }
            return S_OK;
        }
        return E_OUTOFMEMORY;
    }

    /*****************************************************************************
    * StreamOffsetsToTime *
    *-----------------------------------*
    *   Description:
    *       This method converts the audio positions to filetimes and audio stream
    *       offsets to time offsets
    ****************************************************************** YUNUSM ***/
    HRESULT StreamOffsetsToTime(void)
    {
        SPDBG_FUNC( "CRecoEngine::_StreamOffsetsToTime" );
        HRESULT hr = S_OK;
    
        // Initialize the waveformat and convert the stream positions to time positions
        SPINTERNALSERIALIZEDPHRASE *pPhraseData = NULL;
        if (m_pHdr->ulPhraseOffset)
        {
            pPhraseData = reinterpret_cast<SPINTERNALSERIALIZEDPHRASE*>(((BYTE*)m_pHdr) + m_pHdr->ulPhraseOffset);
            pPhraseData->ftStartTime = FT64(m_pHdr->times.ftStreamTime);
            pPhraseData->ulAudioSizeTime = static_cast<ULONG>(m_pHdr->times.ullLength);
        }
    
        if( m_pHdr->ulPhraseDataSize )
        {
            SPDBG_ASSERT(m_pHdr->ulPhraseOffset);
            CComObject<CPhrase> pPhrase;
            hr = pPhrase.InitFromSerializedPhrase(reinterpret_cast<SPSERIALIZEDPHRASE*>(pPhraseData));
            if (SUCCEEDED(hr))
            {
                for (CPhraseElement * pElem = pPhrase.m_ElementList.GetHead(); pElem; pElem = pElem->m_pNext)
                {
                    pElem->ulAudioTimeOffset = static_cast<ULONG>(pElem->ulAudioStreamOffset * m_pHdr->fTimePerByte);
                    pElem->ulAudioSizeTime = static_cast<ULONG>(pElem->ulAudioSizeBytes * m_pHdr->fTimePerByte);
                }
    
                SPSERIALIZEDPHRASE *pCoMemScaledPhrase;
                hr = pPhrase.GetSerializedPhrase(&pCoMemScaledPhrase);
                if (SUCCEEDED(hr))
                {
                    // SPINTERNALSERIALIZEDPHRASE and SPSERIALIZEDPHRASE have the same layout in memory
                    // but are declared differently
                    CopyMemory(pPhraseData, pCoMemScaledPhrase, reinterpret_cast<SPINTERNALSERIALIZEDPHRASE*>(pCoMemScaledPhrase)->ulSerializedSize);
                    ::CoTaskMemFree(pCoMemScaledPhrase);
                }
            }
        }
        return hr;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spatl.h ===
// This include file declares SAPI specific extensions to ATL.

#ifndef __SPATL_H__
#define __SPATL_H__


// SINGLETON extension declarations:

/*****************************************************************************
* SP_DECLARE_CLASSFACTORY_RELEASABLE_SINGLETON *
*----------------------------------------------*
*
*   Use SP_DECLARE_CLASSFACTORY_RELEASABLE_SINGLETON in the declaration of an
*   ATL object instead of ATL's own DECLARE_CLASSFACTORY_SINGLETON when you
*   want a singleton object that can be released.  ATL's singleton factory
*   statically allocates, but dynamically initializes each singleton object.
*   Thus once the singleton object is initialized it stays "alive" after
*   seeing a final release of all references to it.  This releasable factory
*   dynamically allocates the singleton object so that it can be completely
*   released once all references to it are released.  The factory itself only
*   holds a weak reference to the object.
********************************************************************* RAP ***/
#define SP_DECLARE_CLASSFACTORY_RELEASABLE_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CSpComClassFactoryReleasableSingleton<obj>)


/*****************************************************************************
* class CSpComClassFactoryWithRelease *
*-------------------------------------*
*
*   This class definition adds a virtual method "ReleaseReference" to ATL's
*   own CComClassFactory.  The method isn't implemented here.  This class
*   is only used by the template class CSpComClassFactoryReleasableSingleton
*   which then implements ReleaseReference to NULL the weak reference that
*   it maintains to the singleton object it created.
********************************************************************* RAP ***/
class CSpComClassFactoryWithRelease : public CComClassFactory
{
public:
    virtual void ReleaseReference(void) = 0;
};


/*****************************************************************************
* class template CSpComObjectReleasableGlobal *
*---------------------------------------------*
*
*   Base is the user's class that derives from CComObjectRoot and whatever
*   interfaces the user wants to support on the object.
*
*   This class definition is taken from ATL's own CComObject.  The differences
*   are:
*
*       The addition of the m_pfactory member which will point to the factory
*       which created the object; this allows this object to notify the factory
*       when it sees the final release.
*
*       The extra logic in Release to call the factory's ReleaseReference
*       method to notify it of final release, as described above.
*
*       Removal of the static CreateInstance method.  Since the factory simply
*       uses "new" for creating the single instance of this object, the ATL
*       CreateInstance method isn't needed.
*
*   This class is only used by CSpComClassFactoryReleasableSingleton defined below.
********************************************************************* RAP ***/
template <class Base>
class CSpComObjectReleasableGlobal : public Base
{
public:
    CSpComClassFactoryWithRelease *m_pfactory;

	typedef Base _BaseClass;
    CSpComObjectReleasableGlobal(void* = NULL) : m_pfactory(NULL)
	{
		_Module.Lock();
    }
    HRESULT Construct(CSpComClassFactoryWithRelease *pfactory)
    {
        HRESULT hr = FinalConstruct();
        if (SUCCEEDED(hr))
        {
            m_pfactory = pfactory;
            if (m_pfactory)
            {
                m_pfactory->AddRef();
            }
        }
        return hr;
    }
	// Set refcount to 1 to protect destruction
	~CSpComObjectReleasableGlobal()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		_Module.Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
        {
            if (m_pfactory)
            {
                m_pfactory->ReleaseReference();  // tell factory we're released
                m_pfactory->Release();
            }
			delete this;
        }
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

/*****************************************************************************
* class template CSpComClassFactoryReleasableSingleton *
*------------------------------------------------------*
*
*   This class definition is taken from ATL's own CComClassFactorySingleton.
*   It provides a class factory which will only allow a single instance of
*   its creatable object to exist at a time.  Further requests to create
*   another instance simply return a reference to the existing object.  The
*   difference between this singleton factory and ATL's is that the created
*   object can be released.  Once all references to the object are released
*   the object calls our ReleaseReference method to indicate that it is being
*   released, so we NULL our weak reference to the object.  A future call to
*   CreateInstance will then result in creating a new singleton object.
********************************************************************* RAP ***/
template <class T>
class CSpComClassFactoryReleasableSingleton : public CSpComClassFactoryWithRelease
{
public:
    HRESULT FinalConstruct()
    {
        m_pObj = NULL;
        return S_OK;
    }
	void FinalRelease()
	{
        if (m_pObj)
		    CoDisconnectObject(m_pObj->GetUnknown(), 0);
	}

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// aggregation is not supported in Singletons
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
            {
                ATLTRACE(_T("CSpComClassFactoryReleasableSingleton::CreateInstance noagg"));
				hRes = CLASS_E_NOAGGREGATION;
            }
			else
			{
                Lock();
                if (m_pObj == NULL)
                {
                    // if singleton object doesn't exist, then attempt to create it
                    m_pObj = new CSpComObjectReleasableGlobal<T>;
                    if (m_pObj)
                    {
                        m_pObj->AddRef();
                        hRes = m_pObj->Construct(this);
                        if (FAILED(hRes))
                        {
                            // if contruction failed, then delete the object
                            delete m_pObj;
                            m_pObj = NULL;
                            Unlock();
                            return hRes;
                        }
                    }
                    else
                    {
                        Unlock();
                        return E_OUTOFMEMORY;
                    }
                }
                else
                {
                    m_pObj->AddRef();
                }
                // if we have a singleton object, then call it to get the desired interface
				hRes = m_pObj->QueryInterface(riid, ppvObj);
                m_pObj->Release();
                Unlock();
			}
		}
		return hRes;
	}
    // This is the entry point that the created object calls when it has seen
    // its final release and is about to delete itself.  Here we NULL our weak
    // reference to the object.
	void ReleaseReference(void)
	{
        Lock();
        m_pObj = NULL;
        Unlock();
	}
	CSpComObjectReleasableGlobal<T> *m_pObj;  //weak pointer
};

#endif //__SPATL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spautohandle.h ===
#pragma once

class CSpAutoEvent;
class CSpAutoMutex;

//
//  Class helper for handles (events, mutexes, etc) which automatically initializes
//  and cleans up handles.
//  The handle can only be assigned if it has previously been cleared.
//
class CSpAutoHandle
{
    friend CSpAutoEvent;
    friend CSpAutoMutex;
    
    private:
        HANDLE  m_h;
    public:
        CSpAutoHandle()
        {
            m_h = NULL;
        }
        ~CSpAutoHandle()
        {
            if (m_h)
            {
                ::CloseHandle(m_h);
            }
        }
        void Close()
        {
            if (m_h)
            {
                ::CloseHandle(m_h);
                m_h = NULL;
            }
        }
        HANDLE operator =(HANDLE hNew)
        {
            SPDBG_ASSERT(m_h == NULL);
            m_h = hNew;
            return hNew;
        }
        operator HANDLE()
        {
            return m_h;
        }
        DWORD Wait(DWORD dwMilliseconds = INFINITE)
        {
            SPDBG_ASSERT(m_h);
            return ::WaitForSingleObject(m_h, dwMilliseconds);
        }
        HRESULT HrWait(DWORD dwMilliseconds = INFINITE)
        {
            SPDBG_ASSERT(m_h);
            DWORD dwResult = ::WaitForSingleObject(m_h, dwMilliseconds);
            if (dwResult == WAIT_OBJECT_0)
            {
                return S_OK;
            }
            if (dwResult == WAIT_TIMEOUT)
            {
                return S_FALSE;
            }
            return SpHrFromLastWin32Error();
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spguid.c ===
#ifdef __cplusplus
extern "C"{
#endif 

//=== Stream Data Formats ============================================================
// {7CEEF9F9-3D13-11d2-9EE7-00C04F797396}
const IID SPDFID_Text = { 0x7ceef9f9, 0x3d13, 0x11d2, { 0x9e, 0xe7, 0x0, 0xc0, 0x4f, 0x79, 0x73, 0x96 } };

// {C31ADBAE-527F-4ff5-A230-F62BB61FF70C}
const IID SPDFID_WaveFormatEx = { 0xc31adbae, 0x527f, 0x4ff5, { 0xa2, 0x30, 0xf6, 0x2b, 0xb6, 0x1f, 0xf7, 0xc } };

//=== Grammar Data Formats ============================================================
// {4DDC926D-6CE7-4dc0-99A7-AF9E6B6A4E91}
const IID SPGDF_ContextFree       = { 0x4ddc926d, 0x6ce7, 0x4dc0, { 0x99, 0xa7, 0xaf, 0x9e, 0x6b, 0x6a, 0x4e, 0x91 } };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spautomutex.h ===
#pragma once

#include "SpAutoHandle.h"

class CSpAutoMutex : public CSpAutoHandle
{
    public:
        HRESULT InitMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
        {
            SPDBG_ASSERT(m_h == NULL);
            m_h = g_Unicode.CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
            return (m_h) ? S_OK :  SpHrFromLastWin32Error();
        }
        BOOL ReleaseMutex()
        {
            SPDBG_ASSERT(m_h);
            return ::ReleaseMutex(m_h);
        }
        HRESULT HrReleaseMutex()
        {
            SPDBG_ASSERT(m_h);
            if (::ReleaseMutex(m_h))
            {
                return S_OK;
            }
            return SpHrFromLastWin32Error();
        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spcontainednotify.h ===
#pragma once

template <class T>
class CSpContainedNotify : public ISpNotifySink
{
public:
    T * m_pParent;
    CSpContainedNotify(T * pParent) : m_pParent(pParent) {}
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (::IsEqualGUID(riid, __uuidof(ISpNotifySink)) || ::IsEqualGUID(riid, __uuidof(IUnknown)))
        {
            *ppv = (ISpNotifySink *)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return 2;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }
    STDMETHODIMP Notify()
    {
        return m_pParent->OnNotify();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spcommunicator.h ===
/****************************************************************************
*   SpCommunicator.h
*       Allows communication between sapi and sapisvr
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------
#include "sapi.h"
#include "sapiint.h"
#include "resource.h"
#include "queuenode.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CSpCommunicator : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpCommunicator, &CLSID_SpCommunicator>,
    public ISpCommunicatorInit, 
    public ISpThreadTask
{
//=== ATL Setup ===
public:

    DECLARE_POLY_AGGREGATABLE(CSpCommunicator)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_REGISTRY_RESOURCEID(IDR_SPCOMMUNICATOR)

    BEGIN_COM_MAP(CSpCommunicator)
        COM_INTERFACE_ENTRY(ISpCallSender)
        COM_INTERFACE_ENTRY(ISpCommunicator)
        COM_INTERFACE_ENTRY(ISpCommunicatorInit)
    END_COM_MAP()

//=== Public methods ===
public:

    //--- ctor, dtor
    CSpCommunicator();
    ~CSpCommunicator();

    //--- ATL methods
    HRESULT FinalConstruct();
    void FinalRelease();

    //--- ISpThreadTask -------------------------------------------------------
    STDMETHODIMP InitThread(
                 void * pvTaskData,
                 HWND hwnd);
    STDMETHODIMP ThreadProc(
                 void *pvTaskData,
                 HANDLE hExitThreadEvent,
                 HANDLE hNotifyEvent,
                 HWND hwndWorker,
                 volatile const BOOL * pfContinueProcessing);
    LRESULT STDMETHODCALLTYPE WindowMessage(
                 void *pvTaskData,
                 HWND hWnd,
                 UINT Msg,
                 WPARAM wParam,
                 LPARAM lParam);

//=== Interfaces ===
public:

    //--- ISpCallSender -------------------------------------------------------
    STDMETHODIMP SendCall(
                    DWORD dwMethodId, 
                    PVOID pvData,
                    ULONG cbData,
                    BOOL  fWantReturn,
                    PVOID * ppvDataReturn,
                    ULONG * pcbDataReturn);

    //--- ISpCommunicator -----------------------------------------------------
    
    //--- ISpCommunicatorInit -------------------------------------------------
    STDMETHODIMP AttachToServer(REFCLSID clsidServerObj);
    STDMETHODIMP AttachToClient(ISpSapiServer * pSapiServer, HWND hwndClient, UINT uMsgClient, DWORD dwClientProcessId);

//=== Private methods ===
private:

    typedef CSpBasicQueue<CSpQueueNode<SPCALL> > CSpCallQueue;

    HRESULT ReceiveThreadProc(
                 HANDLE hExitThreadEvent,
                 HANDLE hNotifyEvent,
                 HWND hwndWorker,
                 volatile const BOOL * pfContinueProcessing);
    LRESULT ReceiveWindowMessage(
                 HWND hWnd,
                 UINT Msg,
                 WPARAM wParam,
                 LPARAM lParam);
                 
    HRESULT SendThreadProc(
                 HANDLE hExitThreadEvent,
                 HANDLE hNotifyEvent,
                 HWND hwndWorker,
                 volatile const BOOL * pfContinueProcessing);

    HRESULT ProcessQueues();
    void FreeQueues();

    void FreeQueue(CSpCallQueue * pqueue);
    
    HRESULT QueueSendCall(SPCALL * pspcall);
    HRESULT ProcessSendQueue();
    HRESULT ProcessSendCall(SPCALL * pspcall);
    HRESULT RemoveQueuedSendCall(SPCALL * pspcall);

    HRESULT QueueReceivedCall(PCOPYDATASTRUCT pcds);
    HRESULT ProcessReceivedQueue();
    HRESULT ProcessReceivedCall(SPCALL * pspcall);

    HRESULT QueueReturnCall(PCOPYDATASTRUCT pcds);
    HRESULT ProcessReturnQueue();
    HRESULT ProcessReturnCall(SPCALL * pspcall);

    HRESULT QueueCallFromCopyDataStruct(
                PCOPYDATASTRUCT pcds, 
                CSpCallQueue * pqueue,
                CComAutoCriticalSection * pcritsec);

private:

    HRESULT m_hrDefaultResponse;

    CComPtr<ISpSapiServer> m_cpSapiServer;
    DWORD m_dwMonitorProcessId;

    HWND m_hwndSend;
    HWND m_hwndReceive;
    
    CComPtr<ISpThreadControl> m_cpThreadControlReceive;
    CComPtr<ISpThreadControl> m_cpThreadControlSend;

    CComAutoCriticalSection m_critsecSend;
    CSpCallQueue m_queueSend;
    
    CComAutoCriticalSection m_critsecReceive;
    CSpCallQueue m_queueReceive;
    
    CComAutoCriticalSection m_critsecReturn;
    CSpCallQueue m_queueReturn;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spcommunicator.cpp ===
/****************************************************************************
*   SpCommunicator.cpp
*       Allows communication between sapi and sapisvr
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "SpCommunicator.h"
#include "SpSapiServer.h"

#define SEND_THREAD_STOP_TIMEOUT                500
#define RECEIVE_THREAD_STOP_TIMEOUT             500

#define SPCCDS_COMMUNICATOR_SEND_RECEIVE_MSG    -1
#define SPCCDS_COMMUNICATOR_RETURN_MSG          -2

#define WM_COMMUNICATOR_SET_SEND_WINDOW         (WM_USER + 1)
#define WM_COMMUNICATOR_RELEASE                 (WM_USER + 2)

#ifdef _DEBUG
#define SEND_CALL_TIMEOUT   5 * 60 * 1000 // 5 minutes
#else
#define SEND_CALL_TIMEOUT   100 * 1000 // 100 seconds
#endif

enum CommunicatorThreadId
{
    CTID_RECEIVE,
    CTID_SEND
};

CSpCommunicator::CSpCommunicator()
{
    SPDBG_FUNC("CSpCommunicator::CSpCommunicator");

    m_hrDefaultResponse = S_OK;
    
    m_dwMonitorProcessId = 0;
    m_hwndSend = NULL;
    m_hwndReceive = NULL;
}

CSpCommunicator::~CSpCommunicator()
{
    FreeQueues();
}

HRESULT CSpCommunicator::FinalConstruct()
{
    SPDBG_FUNC("CSpCommunicator::FinalConstruct");
    HRESULT hr = S_OK;

    // Create the task manager
    CComPtr<ISpTaskManager> cpTaskManager;
    hr = cpTaskManager.CoCreateInstance(CLSID_SpResourceManager);

    // Start up our receive thread
    if (SUCCEEDED(hr))
    {
        hr = cpTaskManager->CreateThreadControl(this, (void*)CTID_RECEIVE, THREAD_PRIORITY_NORMAL, &m_cpThreadControlReceive);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpThreadControlReceive->StartThread(0, &m_hwndReceive);
    }

    // Start up our send thread
    if (SUCCEEDED(hr))
    {
        hr = cpTaskManager->CreateThreadControl(this, (void*)CTID_SEND, THREAD_PRIORITY_NORMAL, &m_cpThreadControlSend);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpThreadControlSend->StartThread(0, NULL);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

void CSpCommunicator::FinalRelease()
{
    SPDBG_FUNC("CSpCommunicator::FinalRelease");
    HRESULT hr;

    // Post a message to the other side to release us
    ::PostMessage(m_hwndSend, WM_COMMUNICATOR_RELEASE, (WPARAM)m_hwndReceive, 0);
    
    // Stop our send thread first
    if(m_cpThreadControlSend != NULL)
    {
        hr = m_cpThreadControlSend->WaitForThreadDone(TRUE, NULL, SEND_THREAD_STOP_TIMEOUT);
        SPDBG_ASSERT(SUCCEEDED(hr));
        m_cpThreadControlSend.Release();
    }

    // Now stop our receive thread
    if(m_cpThreadControlReceive != NULL)
    {
        hr = m_cpThreadControlReceive->WaitForThreadDone(TRUE, NULL, RECEIVE_THREAD_STOP_TIMEOUT);
        SPDBG_ASSERT(SUCCEEDED(hr));    
        m_cpThreadControlReceive.Release();
    }

    // We're either in the client process, or sapi server controls our
    // lifetime, so we shouldn't have a reference to sapi server at this point
    SPDBG_ASSERT(m_cpSapiServer == NULL);
    
    // Free the queues
    FreeQueues();    
}

HRESULT CSpCommunicator::InitThread(
    void * pvTaskData,
    HWND hwnd)
{
    SPDBG_FUNC("CSpCommunicator::InitThread");
    HRESULT hr;
    
    switch (PtrToLong(pvTaskData))
    {
    case CTID_RECEIVE:
    case CTID_SEND:
        hr = S_OK;
        break;

    default:
        hr = E_FAIL;
        break;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ThreadProc(
    void *pvTaskData,
    HANDLE hExitThreadEvent,
    HANDLE hNotifyEvent,
    HWND hwndWorker,
    volatile const BOOL * pfContinueProcessing)
{
    SPDBG_FUNC("CSpCommunicator::ThreadProc");
    HRESULT hr;

    // Dispatch to the appropriate thread procedure
    switch (PtrToLong(pvTaskData))
    {
    case CTID_RECEIVE:
        hr = ReceiveThreadProc(hExitThreadEvent, hNotifyEvent, hwndWorker, pfContinueProcessing);
        break;

    case CTID_SEND:
        hr = SendThreadProc(hExitThreadEvent, hNotifyEvent, hwndWorker, pfContinueProcessing);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

LRESULT CSpCommunicator::WindowMessage(
    void *pvTaskData,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
    SPDBG_FUNC("CSpCommunicator::WindowMessage");
    LRESULT lret = 0;

    // Dispatch tot he receive window message handler
    switch (PtrToLong(pvTaskData))
    {
    case CTID_RECEIVE:
        lret = ReceiveWindowMessage(hWnd, Msg, wParam, lParam);
        break;

    case CTID_SEND:
    default:
        SPDBG_ASSERT(FALSE);
        break;
    }

    return lret;
}

HRESULT CSpCommunicator::SendCall(
    DWORD dwMethodId, 
    PVOID pvData,
    ULONG cbData,
    BOOL  fWantReturn,
    PVOID * ppvDataReturn,
    ULONG * pcbDataReturn)
{
    SPDBG_FUNC("CSpCommunicator::SendCall");
    HRESULT hr = m_hrDefaultResponse;

    // Validate params
    if ((pvData != NULL && cbData == 0) ||
        (ppvDataReturn != NULL && !fWantReturn) ||
        (pcbDataReturn != NULL && !fWantReturn))
    {
        hr = E_INVALIDARG;
    }
    else if ((pvData != NULL && SPIsBadReadPtr(pvData, cbData)) ||
             SP_IS_BAD_OPTIONAL_WRITE_PTR(ppvDataReturn) ||
             SP_IS_BAD_OPTIONAL_WRITE_PTR(pcbDataReturn))
    {
        hr = E_POINTER;
    }
    else if (m_hwndSend == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }

    // Ensure we're not running on the wrong thread
    if (SUCCEEDED(hr) && m_cpThreadControlSend->ThreadId() == GetCurrentThreadId())
    {
        hr = SPERR_REMOTE_CALL_ON_WRONG_THREAD;
    }
    
    // Allocate the call struct
    SPCALL * pspcall = NULL;
    if (SUCCEEDED(hr))
    {
        pspcall = new SPCALL;
        if (pspcall == NULL)
        {
            hr =  E_OUTOFMEMORY;
        }
    }

    // Fill it out and queue it
    if (SUCCEEDED(hr))
    {
        memset(pspcall, 0, sizeof(*pspcall));

        pspcall->dwMethodId = dwMethodId;
        pspcall->pvData = pvData;
        pspcall->cbData = cbData;
        pspcall->fWantReturn = fWantReturn;
        pspcall->hwndReturnTo = m_hwndReceive;
        pspcall->heventCompleted = CreateEvent(NULL, FALSE, FALSE, NULL);
        pspcall->pspcall = pspcall;

        hr = QueueSendCall(pspcall);
    }

    // Tell our thread that it's got work to do
    if (SUCCEEDED(hr))
    {
        hr = m_cpThreadControlSend->Notify();
    }

    // Wait for it to be completed
    if (SUCCEEDED(hr))
    {
        switch (SpWaitForSingleObjectWithUserOverride(pspcall->heventCompleted, SEND_CALL_TIMEOUT))
        {
        case WAIT_OBJECT_0:
            hr = S_OK;
            break;

        case WAIT_TIMEOUT:
            hr = SPERR_REMOTE_CALL_TIMED_OUT;
            break;

        default:
            hr = SpHrFromLastWin32Error();
            break;
        }
    }

    // Copy the data back to the caller if necessary
    if (SUCCEEDED(hr))
    {
        if (ppvDataReturn != NULL)
        {
            *ppvDataReturn = pspcall->pvDataReturn;
            pspcall->pvDataReturn = NULL;
        }

        if (pcbDataReturn != NULL)
        {
            *pcbDataReturn = pspcall->cbDataReturn;
            pspcall->cbDataReturn = 0;
        }
    }

    // Clean up ...
    if (pspcall != NULL)
    {
        RemoveQueuedSendCall(pspcall);
        ::CloseHandle(pspcall->heventCompleted);

        if (pspcall->pvDataReturn != NULL)
        {
            ::CoTaskMemFree(pspcall->pvDataReturn);
        }
        
        delete pspcall;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::AttachToServer(REFCLSID clsidServerObj)
{
    SPDBG_FUNC("CSpCommunicator::AttachToServer");
    HRESULT hr = S_OK;

    if (m_hwndSend != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }

    if (SUCCEEDED(hr))
    {
        hr = CSpSapiServer::CreateServerObjectFromClient(clsidServerObj, m_hwndReceive, WM_COMMUNICATOR_SET_SEND_WINDOW);
        SPDBG_ASSERT(FAILED(hr) || m_hwndSend != NULL);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::AttachToClient(ISpSapiServer * pSapiServer, HWND hwndClient, UINT uMsgSendToClient, DWORD dwClientProcessId)
{
    SPDBG_FUNC("CSpCommunicator::AttachToClient");
    HRESULT hr = S_OK;

    SPAUTO_OBJ_LOCK;
    
    if (m_hwndSend != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if (!IsWindow(hwndClient))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_hwndSend = hwndClient;
        SPDBG_ASSERT(::IsWindow(m_hwndSend));

        BOOL fSent = (INT)::SendMessage(hwndClient, uMsgSendToClient, (WPARAM)m_hwndReceive, (LPARAM)::GetCurrentProcessId());
        if (!fSent)
        {
            hr = SPERR_REMOTE_PROCESS_TERMINATED;
        }

        if (SUCCEEDED(hr))
        {
            m_cpSapiServer = pSapiServer;
            hr = m_cpSapiServer->StartTrackingObject(this);
        }

        if (SUCCEEDED(hr))
        {
            m_dwMonitorProcessId = dwClientProcessId;
            hr = m_cpThreadControlReceive->Notify();
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ReceiveThreadProc(
    HANDLE hExitThreadEvent,
    HANDLE hNotifyEvent,
    HWND hwndWorker,
    volatile const BOOL * pfContinueProcessing)
{
    SPDBG_FUNC("CSpCommunicator::ReceiveThreadProc");
    HRESULT hr = S_OK;

    HANDLE heventMonitorProcess = NULL;
    HANDLE aEvents[] = { hExitThreadEvent, hNotifyEvent };
    
    while (*pfContinueProcessing && SUCCEEDED(hr))
    {
        DWORD dwWaitId = ::MsgWaitForMultipleObjects(
                                    sp_countof(aEvents),
                                    aEvents, 
                                    FALSE, 
                                    INFINITE, 
                                    QS_ALLINPUT);    
        switch (dwWaitId)
        {
        case WAIT_OBJECT_0: // hExitThread event
            SPDBG_ASSERT(!*pfContinueProcessing);
            break;

        case WAIT_OBJECT_0 + 1: // hNotifyEvent, or heventMonitorProcess
            if (m_dwMonitorProcessId != 0)
            {
                if (heventMonitorProcess == NULL)
                {
                    heventMonitorProcess = ::OpenProcess(SYNCHRONIZE, FALSE, m_dwMonitorProcessId);
                    if (heventMonitorProcess == NULL)
                    {
                        hr = SpHrFromLastWin32Error();
                    }
                    else
                    {
                        SPDBG_ASSERT(aEvents[1] == hNotifyEvent);
                        aEvents[1] = heventMonitorProcess;
                    }
                }
                else
                {
                    m_dwMonitorProcessId = 0;
                    m_hrDefaultResponse = SPERR_REMOTE_PROCESS_TERMINATED;
                    
                    SPDBG_ASSERT(aEvents[1] == heventMonitorProcess);
                    aEvents[1] = hNotifyEvent;
                    
                    if (m_cpSapiServer != NULL)
                    {
                        hr = m_cpSapiServer->StopTrackingObject(this);
                        m_cpSapiServer.Release();
                    }
                }
            }
            break;

        case WAIT_OBJECT_0 + 2: // A message
            MSG Msg;
            while (::PeekMessage(&Msg, NULL, 0, 0, TRUE))
            {
                ::DispatchMessage(&Msg);
            }
            break;

        default:
            hr = E_FAIL;
            break;
        }
    }

    if (heventMonitorProcess != NULL)
    {
        ::CloseHandle(heventMonitorProcess);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

LRESULT CSpCommunicator::ReceiveWindowMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
    SPDBG_FUNC("CSpCommunicator::ReceiveWindowMessage");
    HRESULT hr = S_OK;
    LRESULT lret = 0;

    // If it's copydata, and it's one of ours
    if (Msg == WM_COPYDATA)
    {
        PCOPYDATASTRUCT lpds = PCOPYDATASTRUCT(lParam);
        if (lpds && lpds->dwData == SPCCDS_COMMUNICATOR_SEND_RECEIVE_MSG)
        {
            hr = QueueReceivedCall(lpds);
        }
        else if (lpds && lpds->dwData == SPCCDS_COMMUNICATOR_RETURN_MSG)
        {
            hr = QueueReturnCall(lpds);
        }
        else
        {
            // lpds can be NULL when low memory encountered on ME. This is an OS bug and
            // the best that can be is to return an error here and not crash.
            hr = E_FAIL;
        }

        lret = SUCCEEDED(hr);
    }
    else if (Msg == WM_COMMUNICATOR_SET_SEND_WINDOW && m_hwndSend == NULL)
    {
        m_hwndSend = (HWND)wParam;
        SPDBG_ASSERT(::IsWindow(m_hwndSend));
        
        // Tell our thread that it should hook up monitoring now
        m_dwMonitorProcessId = (DWORD)lParam;
        hr = m_cpThreadControlReceive->Notify();

        lret = TRUE;
    }
    else if (Msg == WM_COMMUNICATOR_RELEASE && (HWND)wParam == m_hwndSend)
    {
        if (m_cpSapiServer != NULL)
        {
            hr = m_cpSapiServer->StopTrackingObject(this);
            m_cpSapiServer.Release();
        }
    }
    else
    {
        lret = DefWindowProc(hWnd, Msg, wParam, lParam);
    }
        
    SPDBG_REPORT_ON_FAIL(hr);
    return lret;
}

HRESULT CSpCommunicator::SendThreadProc(
    HANDLE hExitThreadEvent,
    HANDLE hNotifyEvent,
    HWND hwndWorker,
    volatile const BOOL * pfContinueProcessing)
{
    SPDBG_FUNC("CSpCommunicator::SendThreadProc");
    HRESULT hr = S_OK;

    // While we're supposed to continue
    HANDLE aEvents[] = { hExitThreadEvent, hNotifyEvent };
    while (*pfContinueProcessing && SUCCEEDED(hr))
    {
        // Wait for something to happen
        DWORD dwWait = ::WaitForMultipleObjects(sp_countof(aEvents), aEvents, FALSE, INFINITE);
        switch (dwWait)
        {
        case WAIT_OBJECT_0: // Exit Thread
            SPDBG_ASSERT(!*pfContinueProcessing);
            break;

        case WAIT_OBJECT_0 + 1: // Notify of new work in my queues
            hr = ProcessQueues();
            break;

        default:
            SPDBG_ASSERT(FALSE);
            hr = E_FAIL;
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ProcessQueues()
{
    SPDBG_FUNC("CSpCommunicator::ProcessQueues");
    HRESULT hr = S_OK;

    hr = ProcessReturnQueue();
    if (SUCCEEDED(hr))
    {
        hr = ProcessSendQueue();
    }
    if (SUCCEEDED(hr))
    {
        hr = ProcessReceivedQueue();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

void CSpCommunicator::FreeQueues()
{
    SPDBG_FUNC("CSpCommunicator::FreeQueues");

    // We only get into FreeQueues from FinalRelease, and we can only 
    // get into FinalRelease from the last reference to the communicator
    // being released. At that point in time, we shouldn't have any
    // queue'd sends or returns. Otherwise, that would mean that somebody
    // Released us while we're still in a call to SendCall. That would
    // be a bug in the caller of SendCall.
    
    SPDBG_ASSERT(m_queueSend.GetCount() == 0);
    SPDBG_ASSERT(m_queueReturn.GetCount() == 0);

    // However, we may still have items in our receive queue. That's
    // because the server may have tried to notify us of something but
    // we didn't get around to notifying the Receiver.
    FreeQueue(&m_queueReceive);
}

void CSpCommunicator::FreeQueue(CSpCallQueue * pqueue)
{
    SPDBG_FUNC("CSpCommunicator::FreeQueue");
    HRESULT hr = S_OK;

    // the send queue's ownership of memeory is different
    SPDBG_ASSERT(pqueue != &m_queueSend);

    // Loop thru, and for each, remove the data, then kill the node
    CSpQueueNode<SPCALL> * pnode;
    while (SUCCEEDED(hr) && (pnode = pqueue->RemoveHead()) != NULL)
    {
        // The send queue is the only queue that gets return data
        SPDBG_ASSERT(pnode->m_p->pvDataReturn == NULL);
        SPDBG_ASSERT(pnode->m_p->cbDataReturn == 0);

        if (pnode->m_p->pvData != NULL)
        {
            ::CoTaskMemFree(pnode->m_p->pvData);
        }
        
        delete pnode->m_p;
        delete pnode;
    }    
}

HRESULT CSpCommunicator::QueueSendCall(SPCALL * pspcall)
{
    SPDBG_FUNC("CSpCommunicator::QueueSendCall");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_critsecSend);
    
    // Allocate a new node (deleted in ProcessSendQueue)
    CSpQueueNode<SPCALL> * pnode = new CSpQueueNode<SPCALL>(pspcall);
    if (pnode == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        m_queueSend.InsertTail(pnode);
        hr = m_cpThreadControlSend->Notify();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;     
}

HRESULT CSpCommunicator::ProcessSendQueue()
{
    SPDBG_FUNC("CSpCommunicator::ProcessSendQueue");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_critsecSend);
    
    CSpQueueNode<SPCALL> * pnode;
    while (SUCCEEDED(hr) && (pnode = m_queueSend.RemoveHead()) != NULL)
    {
        hr = ProcessSendCall(pnode->m_p);
        delete pnode;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ProcessSendCall(SPCALL * pspcall)
{
    SPDBG_FUNC("CSpCommunicator::ProcessSendCall");
    HRESULT hr = S_OK;

    COPYDATASTRUCT cds;
    cds.dwData = SPCCDS_COMMUNICATOR_SEND_RECEIVE_MSG;
    cds.cbData = sizeof(*pspcall) + pspcall->cbData;
    cds.lpData = new BYTE[cds.cbData];

    if (cds.lpData == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        memcpy(cds.lpData, pspcall, sizeof(*pspcall));
        memcpy((BYTE*)cds.lpData + sizeof(*pspcall), pspcall->pvData, pspcall->cbData);
       
        DWORD_PTR dwSucceed = 0;
        BOOL fProcessed = (INT)SendMessageTimeout(m_hwndSend, WM_COPYDATA, (WPARAM)m_hwndReceive, (LPARAM)&cds, SMTO_BLOCK, SEND_CALL_TIMEOUT, &dwSucceed);

        delete (BYTE*)cds.lpData;

        if (!fProcessed || !dwSucceed)
        {
            m_hrDefaultResponse = SPERR_REMOTE_PROCESS_TERMINATED;
        }
        
        // If the caller didn't want to wait for the return, set the hr and event now
        if (!pspcall->fWantReturn)
        {
            pspcall->hrReturn = 
                fProcessed && dwSucceed
                    ? S_OK
                    : SpHrFromLastWin32Error();
            
            ::SetEvent(pspcall->heventCompleted);

            // There is no return data, since the caller didn't want any
            SPDBG_ASSERT(pspcall->pvDataReturn == NULL);
            SPDBG_ASSERT(pspcall->cbDataReturn == 0);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::RemoveQueuedSendCall(SPCALL * pspcall)
{
    SPDBG_FUNC("CSpCommunicator::RemoveQueuedSendCall");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_critsecSend);
    
    CSpQueueNode<SPCALL> * pnode = m_queueSend.GetHead();
    while (pnode != NULL && SUCCEEDED(hr))
    {
        if (pnode->m_p == pspcall)
        {
            m_queueSend.Remove(pnode);
            break;
        }
        pnode = m_queueSend.GetNext(pnode);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;    
}

HRESULT CSpCommunicator::QueueReceivedCall(PCOPYDATASTRUCT pcds)
{
    SPDBG_FUNC("CSpCommunicator::QueueReceivedCall");
    HRESULT hr;

    hr = QueueCallFromCopyDataStruct(pcds, &m_queueReceive, &m_critsecReceive);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ProcessReceivedQueue()
{
    SPDBG_FUNC("CSpCommunicator::ProcessReceivedQueue");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_critsecReceive);
    
    CSpQueueNode<SPCALL> * pnode;
    while (SUCCEEDED(hr) && (pnode = m_queueReceive.RemoveHead()) != NULL)
    {
        hr = ProcessReceivedCall(pnode->m_p);

        // Free the data (allocated in QueueReceiveCall)
        if (pnode->m_p->pvData != NULL)
        {
            ::CoTaskMemFree(pnode->m_p->pvData);
        }

        // We shouldn't have any return data, it should have
        // alrady been freed (in ProcessReceivedCall)
        SPDBG_ASSERT(pnode->m_p->pvDataReturn == NULL);
        
        delete pnode->m_p;
        delete pnode;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ProcessReceivedCall(SPCALL * pspcall)
{
    SPDBG_FUNC("CSpCommunicator::ProcessReceivedCall");
    HRESULT hr = S_OK;

    CComPtr<ISpCallReceiver> cpReceiver;
    hr = GetControllingUnknown()->QueryInterface(&cpReceiver);

    if (SUCCEEDED(hr))
    {
        // Send it to the receiver, perhaps receiving return data
        pspcall->hrReturn = 
            cpReceiver->ReceiveCall(
                pspcall->dwMethodId,
                pspcall->pvData,
                pspcall->cbData,
                pspcall->fWantReturn
                    ? &pspcall->pvDataReturn
                    : NULL,
                pspcall->fWantReturn
                    ? &pspcall->cbDataReturn
                    : NULL);

        // If the caller wanted the return, prepare it and send it
        if (pspcall->fWantReturn)
        {
            // The return data travels across as the data for the return
            SPCALL spcallReturn;
            spcallReturn = *pspcall;

            spcallReturn.pvData = pspcall->pvDataReturn;
            spcallReturn.cbData = pspcall->cbDataReturn;
            spcallReturn.pvDataReturn = NULL;
            spcallReturn.cbDataReturn = 0;
                
            COPYDATASTRUCT cds;
            cds.dwData = SPCCDS_COMMUNICATOR_RETURN_MSG;
            cds.cbData = sizeof(spcallReturn) + spcallReturn.cbData;
            cds.lpData = new BYTE[cds.cbData];
            
            if (cds.lpData == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memcpy(cds.lpData, &spcallReturn, sizeof(spcallReturn));
                memcpy((BYTE*)cds.lpData + sizeof(spcallReturn), spcallReturn.pvData, spcallReturn.cbData);
                
                BOOL fProcessed = (INT)SendMessage(pspcall->hwndReturnTo, WM_COPYDATA, (WPARAM)m_hwndReceive, (LPARAM)&cds);
                if (!fProcessed)
                {
                    m_hrDefaultResponse = SPERR_REMOTE_PROCESS_TERMINATED;
                }

                delete cds.lpData;
            }

            // If we have any return data, free it too
            if (pspcall->pvDataReturn != NULL)
            {
                ::CoTaskMemFree(pspcall->pvDataReturn);
                pspcall->pvDataReturn = NULL;
                pspcall->cbDataReturn = 0;                    
            }
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::QueueReturnCall(PCOPYDATASTRUCT pcds)
{
    SPDBG_FUNC("CSpCommunicator::QueueReturnCall");
    HRESULT hr;
    
    hr = QueueCallFromCopyDataStruct(pcds, &m_queueReturn, &m_critsecReturn);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ProcessReturnQueue()
{
    SPDBG_FUNC("CSpCommunicator::ProcessReturnQueue");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_critsecReturn);
    
    CSpQueueNode<SPCALL> * pnode;
    while (SUCCEEDED(hr) && (pnode = m_queueReturn.RemoveHead()) != NULL)
    {
        hr = ProcessReturnCall(pnode->m_p);

        // Free any data we may have for this return call
        // (allocated in QueueReturnCall)
        if (pnode->m_p->pvData != NULL)
        {
            ::CoTaskMemFree(pnode->m_p->pvData);
        }

        // We shouldn't have any return data here. The actual return data
        // came back as pvData/cbData. 
        SPDBG_ASSERT(pnode->m_p->pvDataReturn == NULL);
        SPDBG_ASSERT(pnode->m_p->cbDataReturn == NULL);

        delete pnode->m_p;
        delete pnode;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::ProcessReturnCall(SPCALL * pspcall)
{
    SPDBG_FUNC("CSpCommunicator::ProcessReturnCall");
    HRESULT hr = S_OK;

    // Make sure this call looks right
    SPDBG_ASSERT(pspcall->pspcall != NULL);
    SPDBG_ASSERT(pspcall->pspcall != pspcall);
    SPDBG_ASSERT(pspcall->pspcall->dwMethodId =  pspcall->dwMethodId);
    SPDBG_ASSERT(pspcall->pspcall->fWantReturn == pspcall->fWantReturn);
    SPDBG_ASSERT(pspcall->pspcall->heventCompleted == pspcall->heventCompleted);
    SPDBG_ASSERT(pspcall->pspcall->heventCompleted != NULL);
    SPDBG_ASSERT(pspcall->pspcall->hwndReturnTo == pspcall->hwndReturnTo);
    SPDBG_ASSERT(pspcall->pspcall->hwndReturnTo == m_hwndReceive);

    // NTRAID#SPEECH-0000-2000/08/22-robch: Make sure pspcall->pspcall is still valid (we'll probably have to store
    // in a temporary queue, and have RemoveQueuedSendCall remove it from there too.
    
    // Copy the return params
    pspcall->pspcall->hrReturn = pspcall->hrReturn;
    pspcall->pspcall->pvDataReturn = pspcall->pvData;
    pspcall->pspcall->cbDataReturn = pspcall->cbData;

    // Transfer ownership of the memory
    pspcall->pvData = NULL;
    pspcall->cbData = 0;

    // Signal the client thread that we've completed
    if (!::SetEvent(pspcall->heventCompleted))
    {
        hr = SpHrFromLastWin32Error();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpCommunicator::QueueCallFromCopyDataStruct(
    PCOPYDATASTRUCT pcds, 
    CSpCallQueue * pqueue,
    CComAutoCriticalSection * pcritsec)
{
    SPDBG_FUNC("CSpCommunicator::QueueCallFromCopyDataStruct");        
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(pcritsec);

    // Create the spcall and fill it out
    SPCALL * pspcall = new SPCALL;
    if (pspcall == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    // Make sure the cds is of an appropriate size
    if (SUCCEEDED(hr) && 
        (pcds->cbData < sizeof(*pspcall) ||
         pcds->cbData != sizeof(*pspcall) + ((SPCALL*)pcds->lpData)->cbData))
    {
        hr = E_INVALIDARG;
    }

    // Copy the struct and the data
    if (SUCCEEDED(hr))
    {
        *pspcall = *(SPCALL*)pcds->lpData;
        pspcall->pvData = ::CoTaskMemAlloc(pspcall->cbData);
        if (pspcall->pvData == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pspcall->pvData, (BYTE*)pcds->lpData + sizeof(*pspcall), pspcall->cbData);
        }
    }

    // Create the node and stick it in the queue
    if (SUCCEEDED(hr))
    {
        CSpQueueNode<SPCALL> * pnode = new CSpQueueNode<SPCALL>(pspcall);
        if (pnode == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pqueue->InsertTail(pnode);
            hr = m_cpThreadControlSend->Notify();
        }
    }

    // If anything failed, clean up
    if (FAILED(hr))
    {
        if (pspcall)
        {
            if (pspcall->pvData)
            {
                ::CoTaskMemFree(pspcall->pvData);
            }
            
            delete pspcall;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spinthlp.h ===
/*******************************************************************************
* SPINTHLP.h *
*------------*
*   Description:
*       This is the header file for internal helper functions implementation.
*******************************************************************************/
#ifndef SPINTHLP_h
#define SPINTHLP_h

#include <spunicode.h>
#include "SpAutoEvent.h"
#include "..\cpl\resource.h"
#include "spsatellite.h"
#ifndef _WIN32_WCE
#include "lmerr.h"
#include "lmaccess.h"
#include "lmapibuf.h"
#include <string.h>
#include <wchar.h>
#endif // _WIN32_WCE

/****************************************************************************
* SpValidateEvent *
*-----------------*
*   Description:
*       Does various tests to ensure that an event is valid.  Note that this
*   call does NOT TEST THE VALIDITY OF THE pEvent PARAMETER!  The caller must
*   make sure that pEvent is readable before calling this function.
*
*   Returns:
*       S_OK or E_INVALIDARG
*
********************************************************************* RAL ***/

inline HRESULT SpValidateEvent(const SPEVENT * pEvent)
{
    SPDBG_FUNC("SpValidateEvent");
    HRESULT hr = S_OK;

    switch (pEvent->elParamType)
    {
      case SPET_LPARAM_IS_TOKEN:
        if( SP_IS_BAD_INTERFACE_PTR( (ISpObjectToken*)(pEvent->lParam) ) )
        {
            hr = E_INVALIDARG;
        }
        break;
      case SPET_LPARAM_IS_OBJECT:
        if( SP_IS_BAD_INTERFACE_PTR( (IUnknown*)(pEvent->lParam) ) )
        {
            hr = E_INVALIDARG;
        }
        break;
      case SPET_LPARAM_IS_POINTER:
        if(pEvent->wParam && SPIsBadReadPtr( ((BYTE*)pEvent->lParam), (unsigned)pEvent->wParam ) )
        {
            hr = E_INVALIDARG;
        }
        break;
      case SPET_LPARAM_IS_STRING:
        if( SP_IS_BAD_OPTIONAL_STRING_PTR( (WCHAR*)(pEvent->lParam) ) )
        {
            hr = E_INVALIDARG;
        }
        break;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



inline HRESULT SpCopyStringLimit(WCHAR * pszDest, ULONG cchDest, const WCHAR * pszSrc)
{
    SPDBG_ASSERT(cchDest > 0);
    
    for (const WCHAR * pszLimit = pszDest + cchDest;
         pszDest < pszLimit;
         pszDest++, pszSrc++)
    {
        if (0 == (*pszDest = *pszSrc))
        {
            return S_OK;
        }
    }
    pszDest[-1] = 0;
    SPDBG_ASSERT(false);
    return E_UNEXPECTED;
}

template <class _C>
inline HRESULT SpSafeCopyString( _C & refDest, const WCHAR * pszSrc)
{
    return SpCopyStringLimit(refDest, sp_countof( refDest ), pszSrc);
}


template <class T>
void _CvtRelPtr(T ** ppDest, const SPCFGSERIALIZEDHEADER * pFirstByte, SPRELATIVEPTR RelPtr)
{
    *ppDest = RelPtr ? (T *)(((BYTE *) pFirstByte) + RelPtr) : NULL;
}

#define _CVTRELPTR(FIELDNAME) _CvtRelPtr(&pHeader->FIELDNAME, pFH, pFH->FIELDNAME)

template <class T>
void SpZeroStruct(T & Obj)
{
    memset(&Obj, 0, sizeof(Obj));
}

//
//  This helper converts a serialized CFG grammar header into an in-memory header
//
inline HRESULT SpConvertCFGHeader(const SPBINARYGRAMMAR * pBinaryGrammar, SPCFGHEADER * pHeader)
{
    const SPCFGSERIALIZEDHEADER * pFH = static_cast<const SPCFGSERIALIZEDHEADER *>(pBinaryGrammar);
    //
    //  Because in 64-bit code, pointers != sizeof(ULONG) we copy each member explicitly.
    //
    if (SP_IS_BAD_READ_PTR(pFH))
    {
        return E_INVALIDARG;
    }
    if (pFH->FormatId != SPGDF_ContextFree)
    {
        return SPERR_UNSUPPORTED_FORMAT;
    }
    pHeader->FormatId = pFH->FormatId;
    pHeader->GrammarGUID = pFH->GrammarGUID;
    pHeader->LangID = pFH->LangID;
    pHeader->cArcsInLargestState = pFH->cArcsInLargestState;
    pHeader->cWords = pFH->cWords;
    pHeader->cchWords = pFH->cchWords;
    pHeader->cchSymbols = pFH->cchSymbols;
    pHeader->cRules = pFH->cRules;
    pHeader->cArcs = pFH->cArcs;
    pHeader->cSemanticTags = pFH->cSemanticTags;
    pHeader->cResources = pFH->cResources;
    _CVTRELPTR(pszWords);
    _CVTRELPTR(pszSymbols);
    _CVTRELPTR(pResources);
    _CVTRELPTR(pWeights);
    _CVTRELPTR(pRules);
    _CVTRELPTR(pArcs);
    _CVTRELPTR(pSemanticTags);
    return S_OK;
}

#ifndef __CFGDUMP_
//  cfgdump gets upset if we include this! -- philsch
//
//  Helpers for logging errors
//
#define LOGERROR(uID)   if (hr != S_OK && pErrorLog) LogError(-1, hr, pErrorLog, (uID), NULL)
#define LOGERRORFMT(ulLine, uID, sz) if (hr != S_OK && pErrorLog) LogError((ulLine), hr, pErrorLog, (uID), (sz))
#define LOGERRORFMT2(ulLine , uID, sz1, sz2) if (hr != S_OK && pErrorLog) LogError2((ulLine), hr, pErrorLog, (uID), (sz1), (sz2))
#define LOGWARNING(uID) hr = S_FALSE; LogError(-1, hr, pErrorLog, (uID), NULL); hr = S_OK
#define LOGWARNINGFMT(uID, sz) hr = S_FALSE; LogError(-1, hr, pErrorLog, (uID), (sz)); hr = S_OK
#define LOGDIAGNOSE(uID) hr = S_OK; LogError(hr, pErrorLog, (uID), NULL)
#define LOGDIAGNOSEFMT(uID, sz) hr = S_OK; LogError(hr, pErrorLog, (uID), (sz))
#define REPORTERRORFMT(uID, sz) if (hr != S_OK && m_cpErrorLog) ::LogError(0, hr, m_cpErrorLog, (uID), (sz))

inline void LogError(const ULONG ulLine, HRESULT hr, ISpErrorLog * pErrorLog, UINT uID, const WCHAR * pszInsertString)
{
    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pErrorLog))
    {
        return;
    }
    USES_CONVERSION;
    TCHAR sz[MAX_PATH]; // 260 chars max for error string.
    if (::LoadString(_Module.GetModuleInstance(), uID, sz, sp_countof(sz)))
    {
        WCHAR szFormatted[MAX_PATH];
        WCHAR * pszErrorText = T2W(sz);
        if (pszInsertString)
        {
            _snwprintf(szFormatted, MAX_PATH, pszErrorText, pszInsertString);
            szFormatted[MAX_PATH - 1] = L'\0';
            pszErrorText = szFormatted;
        }
        if (pErrorLog)
        {
            pErrorLog->AddError(ulLine, hr, pszErrorText, NULL, 0);
        }
    }
}

inline void LogError2(const ULONG ulLine, HRESULT hr, ISpErrorLog * pErrorLog, UINT uID, const WCHAR * pszInsertString1, const WCHAR * pszInsertString2)
{
    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pErrorLog))
    {
        return;
    }
    USES_CONVERSION;
    TCHAR sz[MAX_PATH]; // 260 chars max for error string.
    if (::LoadString(_Module.GetModuleInstance(), uID, sz, sp_countof(sz)))
    {
        WCHAR szFormatted[MAX_PATH];
        WCHAR * pszErrorText = T2W(sz);
        _snwprintf(szFormatted, MAX_PATH, pszErrorText, pszInsertString1 ? pszInsertString1 : L"", pszInsertString2 ? pszInsertString2 : L"");
        szFormatted[MAX_PATH - 1] = L'\0';
        if (pErrorLog)
        {
            pErrorLog->AddError(ulLine, hr, szFormatted, NULL, 0);
        }
    }
}

#endif

//
//  Helper functions to convert from various variant types.
//  Note the variant type must be correct in the variant before calling
//
inline HRESULT CopySemanticValueToVariant(const SPVARIANTSUBSET * pSrc, VARIANT * pDest)
{
    HRESULT hr = S_OK;

    switch (pDest->vt)
    {
    case VT_EMPTY:
        break;
    case VT_I2:
        pDest->iVal = pSrc->iVal;
        break;
    case VT_I4:
        pDest->lVal = pSrc->lVal;
        break;
    case VT_R4:
        pDest->fltVal = pSrc->fltVal;
        break;
    case VT_R8:
        pDest->dblVal = pSrc->dblVal;
        break;
    case VT_CY:
        pDest->cyVal = pSrc->cyVal;
        break;
    case VT_DATE:
        pDest->date = pSrc->date;
        break;
    case VT_BOOL:
        pDest->boolVal = pSrc->boolVal;
        break;
    case VT_I1:
        pDest->cVal = pSrc->cVal;
        break;
    case VT_UI2:
        pDest->uiVal = pSrc->uiVal;
        break;
    case VT_UI4:
        pDest->ulVal = pSrc->ulVal;
        break;
    case VT_INT:
        pDest->intVal = pSrc->intVal;
        break;
    case VT_UINT:
        pDest->uintVal = pSrc->uintVal;
        break;

    case VT_BYREF | VT_VOID:
        pDest->byref = pSrc->byref;
        break;
    default:
        pDest->vt = VT_EMPTY;
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}


//
//  Helper functions to convert from various variant types.  Note that the 
//
inline HRESULT CopyVariantToSemanticValue(const VARIANT * pSrc, SPVARIANTSUBSET * pDest)
{
    HRESULT hr = S_OK;

    switch (pSrc->vt)
    {
    case VT_EMPTY:
        break;
    case VT_BYREF | VT_I2:
        pDest->iVal = *pSrc->piVal;
        break;
    case VT_I2:
        pDest->iVal = pSrc->iVal;
        break;
    case VT_BYREF | VT_I4:
        pDest->lVal = *pSrc->plVal;
        break;
    case VT_I4:
        pDest->lVal = pSrc->lVal;
        break;
    case VT_BYREF | VT_R4:
        pDest->fltVal = *pSrc->pfltVal;
        break;
    case VT_R4:
        pDest->fltVal = pSrc->fltVal;
        break;
    case VT_BYREF | VT_R8:
        pDest->dblVal = *pSrc->pdblVal;
        break;
    case VT_R8:
        pDest->dblVal = pSrc->dblVal;
        break;
    case VT_BYREF | VT_CY:
        pDest->cyVal = *pSrc->pcyVal;
        break;
    case VT_CY:
        pDest->cyVal = pSrc->cyVal;
        break;
    case VT_BYREF | VT_DATE:
        pDest->date = *pSrc->pdate;
        break;
    case VT_DATE:
        pDest->date = pSrc->date;
        break;
    case VT_BYREF | VT_BOOL:
        pDest->boolVal = *pSrc->pboolVal;
        break;
    case VT_BOOL:
        pDest->boolVal = pSrc->boolVal;
        break;
    case VT_BYREF | VT_I1:
        pDest->cVal = *pSrc->pcVal;
        break;
    case VT_I1:
        pDest->cVal = pSrc->cVal;
        break;
    case VT_BYREF | VT_UI2:
        pDest->uiVal = *pSrc->puiVal;
        break;
    case VT_UI2:
        pDest->uiVal = pSrc->uiVal;
        break;
    case VT_BYREF | VT_UI4:
        pDest->ulVal = *pSrc->pulVal;
        break;
    case VT_UI4:
        pDest->ulVal = pSrc->ulVal;
        break;
    case VT_BYREF | VT_INT:
        pDest->intVal = *pSrc->pintVal;
        break;
    case VT_INT:
        pDest->intVal = pSrc->intVal;
        break;
    case VT_BYREF | VT_UINT:
        pDest->uintVal = *pSrc->puintVal;
        break;
    case VT_UINT:
        pDest->uintVal = pSrc->uintVal;
        break;

    case VT_BYREF | VT_VOID:
        pDest->byref = pSrc->byref;
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}


/****************************************************************************
* AssignSemanticValue *
*---------------------*
*   Description:
*       WARNING!  This function will NOT call VariantClear() on the specified 
*       variant.  The caller should clear it before calling this function if 
*       necessary.
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT AssignSemanticValue(const SPCFGSEMANTICTAG * pTag, VARIANT * pv)
{
    SPDBG_FUNC("AssignSemanticValue");
    HRESULT hr = S_OK;
    pv->vt = (pTag->PropVariantType == SPVT_BYREF) ? (VT_BYREF | VT_VOID) : static_cast<VARTYPE>(pTag->PropVariantType);
    hr = CopySemanticValueToVariant(&pTag->SpVariantSubset, pv);
    return hr;
}


/****************************************************************************
* SpLoadCpl *
*-----------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT SpLoadCpl(HMODULE * phCPLUI)
{
    HRESULT hr = S_OK;
    *phCPLUI = NULL;
    HMODULE hCPL;
    
    // Get the module filename
    WCHAR szCpl[MAX_PATH+1];
    if (SUCCEEDED(hr))
    {
        if (g_Unicode.GetModuleFileName(_Module.GetModuleInstance(), szCpl, sp_countof(szCpl)) == 0)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // Strip the trailing sapi.dll part off
        WCHAR * pszLastSlash = wcsrchr(szCpl, L'\\');
        SPDBG_ASSERT(pszLastSlash != NULL);
        pszLastSlash[1] = '\0';
        
        // Add on the name of the control panel
        wcscat(szCpl, L"sapi.cpl");
    
        SPDBG_DMSG1("Loaded sapi.cpl from %S\n", szCpl);
        if ((hCPL = g_Unicode.LoadLibrary(szCpl)) == NULL)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    if (SUCCEEDED(hr))
    {
        CSpSatelliteDLL cpSatellite;
        *phCPLUI = cpSatellite.Load(hCPL, _T("spcplui.dll"));
        cpSatellite.Detach();
        if (*phCPLUI == NULL)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


/****************************************************************************
* SpGetUserName *
*---------------*
*   Description:
*
*   Returns:
*       True if 
*
********************************************************************* RAL ***/

inline BOOL SpGetUserName(WCHAR * pszFullName)
{
    BOOL fGotName = FALSE;
    HMODULE hModNetAPI = ::LoadLibrary(_T("netapi32.dll"));
    if (hModNetAPI)
    {
        NET_API_STATUS (PASCAL * pfnNetUserGetInfo)(LPWSTR, LPWSTR, DWORD, LPBYTE *);
        (FARPROC&)pfnNetUserGetInfo = ::GetProcAddress(hModNetAPI, "NetUserGetInfo");
        NET_API_STATUS (PASCAL * pfnNetApiBufferFree)(LPVOID);
        (FARPROC&)pfnNetApiBufferFree = ::GetProcAddress(hModNetAPI, "NetApiBufferFree");
        if (pfnNetUserGetInfo && pfnNetApiBufferFree)
        {
            WCHAR szUserName[MAX_PATH];
            ULONG cchUserName = sp_countof(szUserName);
            if (g_Unicode.GetUserName(szUserName, &cchUserName))
            {
                BYTE * pBuff;
                if (NERR_Success == pfnNetUserGetInfo(NULL, szUserName, 11, &pBuff))
                {
                    USER_INFO_11 * pUserInfo = (USER_INFO_11 *)pBuff;
                    if (pUserInfo->usri11_full_name &&
                        pUserInfo->usri11_full_name[0] &&
                        wcslen(pUserInfo->usri11_full_name) < MAX_PATH)
                    {
                        wcscpy(pszFullName, pUserInfo->usri11_full_name);
                        fGotName = TRUE;
                    }
                    pfnNetApiBufferFree(pBuff);
                }
            }
        }
        ::FreeLibrary(hModNetAPI);
    }
    return fGotName;
}

/****************************************************************************
* SpGetDefaultProfileDescription *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline BOOL SpGetDefaultProfileDescription(WCHAR * pszName)
{
    BOOL fGotName = FALSE;
    HMODULE hModCPL;
    if (SUCCEEDED(SpLoadCpl(&hModCPL)))
    {
        TCHAR szDefaultDesc[MAX_PATH];
        if (::LoadString(hModCPL, IDS_DEFAULT_PROFILE_NAME, szDefaultDesc, sp_countof(szDefaultDesc)))
        {
            USES_CONVERSION;
            wcscpy(pszName, T2W(szDefaultDesc));
            fGotName = TRUE;
        }
        ::FreeLibrary(hModCPL);
    }
    return fGotName;
}


/****************************************************************************
* SpGetOrCreateDefaultProfile *
*-----------------------------*
*   Description:
*       This function attempts to get the category default reco profile.  If there
*   isn't one, then it will attempt to create a new one, using the name of the
*   user.  If that method fails, then we get a string from a resourec in the
*   control panel.  If that fails, the name "Default Speech Profile" is used.
*
*   Returns:
*       S_OK or error.
*
********************************************************************* RAL ***/

inline HRESULT SpGetOrCreateDefaultProfile(ISpObjectToken ** ppProfileToken)
{
    SPDBG_FUNC("SpGetOrCreateDefaultProfile");
    HRESULT hr = S_OK;

    hr = SpGetDefaultTokenFromCategoryId(SPCAT_RECOPROFILES, ppProfileToken);
    if (hr == SPERR_NOT_FOUND)
    {
        WCHAR szName[MAX_PATH];

        if (!SpGetUserName(szName) &&
            !SpGetDefaultProfileDescription(szName))
        {
            wcscpy(szName, L"Default Speech Profile");
        }
        hr = SpCreateNewTokenEx(
                SPCAT_RECOPROFILES,
                NULL,
                NULL,
                szName,
                0,
                NULL,
                ppProfileToken,
                NULL);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



template <class T, BOOL bPurgeWhenDeleted = TRUE>
class CSpProducerConsumerQueue
{
private:
    CSpBasicQueue<T, bPurgeWhenDeleted, FALSE>  m_Queue;
    CComAutoCriticalSection                     m_CritSec;
    CSpAutoEvent                                m_autohEvent;    

public:
    CSpProducerConsumerQueue() 
    {
        HRESULT hr = m_autohEvent.InitEvent(NULL, TRUE, FALSE, NULL);
        SPDBG_ASSERT(hr == S_OK);
    }

    void Purge()
    {
        m_CritSec.Lock();
        m_autohEvent.ResetEvent();
        m_Queue.Purge();
        m_CritSec.Unlock();
    }

    void InsertTail(T * pNode)
    {
        m_CritSec.Lock();
        if (m_Queue.IsEmpty())
        {
            m_autohEvent.SetEvent();
        }
        m_Queue.InsertTail(pNode);
        m_CritSec.Unlock();
    }

    T * RemoveHead()
    {
        m_CritSec.Lock();
        T * pObj = m_Queue.RemoveHead();
        if (m_Queue.IsEmpty())
        {
            m_autohEvent.ResetEvent();
        }
        m_CritSec.Unlock();
        return pObj;
    }

    void InsertSorted(T * pNode)
    {
        m_CritSec.Lock();
        if (m_Queue.IsEmpty())
        {
            m_autohEvent.SetEvent();
        }
        m_Queue.InsertSorted(pNode);
        m_CritSec.Unlock();
    }

    template <class TFIND> 
    void FindAndDeleteAll(TFIND & FindVal)
    {
        m_CritSec.Lock();
        m_Queue.FindAndDeleteAll(FindVal);
        if (m_Queue.IsEmpty())
        {
            m_autohEvent.ResetEvent();
        }
        m_CritSec.Unlock();
    }

    operator HANDLE()
    {
        return m_autohEvent;
    }

    void IsEmpty()
    {
        return m_Queue.IsEmpty();
    }
};


// Exception handling macros. These are replacements for __try and __except
// that are enabled in release builds unless SP_NO_TRAP_EXCEPTIONS is
// defined when compiling. Used to trap and engine errors and (hopefully)
// allow SAPI to recover. Functions using these must have HRESULT hr variable.
// Only difference between SR_ and TTS_ macros is the error code set.

// Note files using these will need #pragma warning( disable : 4509 ) set.

#ifdef _DEBUG
#define SP_NO_TRAP_EXCEPTIONS
#endif

#ifdef SP_NO_TRAP_EXCEPTIONS

#define SR_TRY
#define SR_EXCEPT
#define TTS_TRY
#define TTS_EXCEPT

#else

#pragma warning( disable : 4509 ) 
#define SR_TRY                          \
    __try                               /* End-of-line */
#define SR_EXCEPT                       \
    __except(EXCEPTION_EXECUTE_HANDLER) \
    {                                   \
        SPDBG_ASSERT(0);                \
        hr = SPERR_SR_ENGINE_EXCEPTION; \
    }                                   \
                                        /* End-of-line */
#define TTS_TRY                          \
    __try                               /* End-of-line */
#define TTS_EXCEPT                       \
    __except(EXCEPTION_EXECUTE_HANDLER) \
    {                                   \
        SPDBG_ASSERT(0);                \
        hr = SPERR_TTS_ENGINE_EXCEPTION; \
    }                                   \
                                        /* End-of-line */

#endif


class CSpBasicErrorLog : public ISpErrorLog
{
public:
    CSpDynamicString    m_dstrText;

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(IUnknown) || riid == __uuidof(ISpErrorLog))
        {
            *ppv = static_cast<ISpErrorLog *>(this);
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return 2;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }
    STDMETHODIMP AddError(const long lLineNumber,
                          HRESULT hr, 
                          const WCHAR * pszDescription, 
                          const WCHAR * pszHelpFile, 
                          DWORD dwHelpContext)
    {
        WCHAR szHR[12];
        swprintf(szHR, L"%08X - ", hr);
        m_dstrText.Append(szHR);
        m_dstrText.Append2(pszDescription, L"\r\n");
        return (m_dstrText ? S_OK : E_OUTOFMEMORY);
    }
};



#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spmagicmutex.h ===
/*******************************************************************************
* SpMagicMutex.h *
*----------------*
*   Description:
*       This is the header file for the CSpMagicMutex implementation. This 
*   is a synchronization object similar to a mutex, except that it can be
*   released on a thread other than the one which obtained it.
*-------------------------------------------------------------------------------
*  Created By: AARONHAL                            Date: 8/15/2000
*  Copyright (C) 1999, 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#ifndef SpMagicMutex_h
#define SpMagicMutex_h

#define TIMEOUT_INTERVAL        5000

/*** CSpMagicMutex *****************************************************************
*   This class is used to control access to the audio device by normal and alert
*   priority voices.  A special class was needed, since a "mutex" used for 
*   this purpose must be releasable from a thread other than the one which obtained
*   it.
*/
class CSpMagicMutex
{
    private:
        HANDLE                m_hMutex;         // Used to control access to the events.
        HANDLE                m_hWaitEvent;     // This is the event which will become signalled
                                                //   when the mutex is available.
        HANDLE                m_hCreateEvent;   // This event is used to detect the occurence
                                                //   of a crash while the mutex is owned.
        BOOL                  m_fOwner;         // This bool is used to keep track of ownership
                                                //   internal to an instance of the class.
        CSpDynamicString      m_dstrName;       // This is used to store the name of m_hCreateEvent.

    public:
        CSpMagicMutex()
        {
            m_hWaitEvent        = NULL;
            m_hCreateEvent      = NULL;
            m_hMutex            = NULL;
            m_fOwner            = false;
        }

        ~CSpMagicMutex()
        {
            ReleaseMutex();
            Close();
        }

        BOOL IsInitialized()
        {
            return ( m_hWaitEvent ) ? true : false;
        }

        void Close()
        {
            if ( m_hMutex )
            {
                SPDBG_ASSERT( ::WaitForSingleObject( m_hMutex, TIMEOUT_INTERVAL ) == WAIT_OBJECT_0 );
            }
            if ( m_hCreateEvent )
            {
                ::CloseHandle( m_hCreateEvent );
                m_hCreateEvent = NULL;
            }
            if ( m_hWaitEvent )
            {
                ::CloseHandle( m_hWaitEvent );
                m_hWaitEvent = NULL;
            }
            m_fOwner = false;
            if ( m_hMutex )
            {
                ::ReleaseMutex( m_hMutex );
                ::CloseHandle( m_hMutex );
                m_hMutex = NULL;
            }
        }

        HRESULT InitMutex( LPCWSTR lpName )
        {
            HRESULT hr = S_OK;
            CSpDynamicString dstrWaitEventName, dstrMutexName;
            
            if ( lpName &&
                 dstrWaitEventName.Append2( L"WaitEvent-", lpName ) )
            {
                m_hWaitEvent = g_Unicode.CreateEvent( NULL, FALSE, TRUE, dstrWaitEventName );
                hr = ( m_hWaitEvent ) ? S_OK : SpHrFromLastWin32Error();
            }
            //--- Doesn't make any sense to use one of these if it isn't named!
            else if ( !lpName )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if ( SUCCEEDED( hr ) )
            {
                if ( dstrMutexName.Append2( L"Mutex-", lpName ) )
                {
                    m_hMutex = g_Unicode.CreateMutex( NULL, false, dstrMutexName );
                    hr = ( m_hMutex ) ? S_OK : SpHrFromLastWin32Error();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //--- Store the name which will be used for m_hCreateEvent
                m_dstrName.Clear();
                if ( !m_dstrName.Append2( L"CreateEvent-", lpName ) )
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            return hr;
        }

        HRESULT ReleaseMutex()
        {
            if ( m_fOwner )
            {
                if ( ::WaitForSingleObject( m_hMutex, TIMEOUT_INTERVAL ) != WAIT_OBJECT_0 )
                {
                    return E_UNEXPECTED;
                }
                ::CloseHandle( m_hCreateEvent );
                m_hCreateEvent = NULL;
                ::SetEvent( m_hWaitEvent );
                m_fOwner = false;
                ::ReleaseMutex( m_hMutex );
                return S_OK;
            }
            else
            {
                return S_FALSE;
            }
        }

       /*******************************************************************************
        * This function is the only complicated one - the algorithm goes like this:
        *
        *   (1) WAIT for m_hWaitEvent for TIMEOUT_INTERVAL milliSeconds
        *   (2) IF we get it, create m_hCreateEvent and return...
        *   (3) ELSE, check whether m_hCreateEvent already exists...
        *       (A) IF m_hCreateEvent already exists, everything is fine, and we go through
        *           the loop again,
        *       (B) ELSE, the thread which owned the mutex crashed, so signal m_hWaitEvent 
        *           and then go through the loop again.
        ********************************************************************************/
        DWORD Wait( const HANDLE hExit, DWORD dwMilliSeconds )
        {
            HRESULT hr = S_OK;
            DWORD   dwResult = 0;
            SPDBG_ASSERT( m_hWaitEvent );

            if ( m_fOwner )
            {
                return WAIT_OBJECT_0;
            }
            else
            {
                HANDLE pHandles[] = { m_hWaitEvent, hExit };
                DWORD dwLastWait = 0, dwNumWaits = 0;

                dwNumWaits = dwMilliSeconds / TIMEOUT_INTERVAL;
                dwLastWait = dwMilliSeconds % TIMEOUT_INTERVAL;

                //--- Main processing loop - handles all but the last wait...
                while ( SUCCEEDED( hr ) &&
                        dwNumWaits > 1 )
                {
                    dwResult = ::WaitForMultipleObjects( (hExit)?(2):(1), pHandles, false, TIMEOUT_INTERVAL );

                    switch ( dwResult )
                    {
                    case WAIT_OBJECT_0:
                        //--- Obtained m_hWaitEvent.  We now own the mutex - need to create
                        //---   m_hCreateEvent.
                        if ( ::WaitForSingleObject( m_hMutex, TIMEOUT_INTERVAL ) != WAIT_OBJECT_0 )
                        {
                            hr = SpHrFromLastWin32Error();
                        }

                        if ( SUCCEEDED( hr ) )
                        {
                            m_hCreateEvent = g_Unicode.CreateEvent( NULL, false, false, m_dstrName );
                            hr = ( m_hCreateEvent ) ? S_OK : SpHrFromLastWin32Error();
                        }

                        if ( SUCCEEDED( hr ) )
                        {
                            m_fOwner = true;
                            if ( !::ReleaseMutex( m_hMutex ) )
                            {
                                ::CloseHandle( m_hCreateEvent );
                                m_hCreateEvent = NULL;
                                return WAIT_FAILED;
                            }
                            else
                            {
                                return WAIT_OBJECT_0;
                            }
                        }
                        else
                        {
                            //--- Need to allow someone else to get the mutex, since this wait has failed...
                            ::SetEvent( m_hWaitEvent );
                            ::ReleaseMutex( m_hMutex );
                            return WAIT_FAILED;
                        }
                        break;

                    case WAIT_OBJECT_0 + 1:
                        //--- OK - just exiting
                        return WAIT_OBJECT_0 + 1;

                    case WAIT_TIMEOUT:
                        //--- Timeout - check for crash on owning thread.
                        if ( ::WaitForSingleObject( m_hMutex, TIMEOUT_INTERVAL ) != WAIT_OBJECT_0 )
                        {
                            hr = SpHrFromLastWin32Error();
                        }

                        if ( SUCCEEDED( hr ) )
                        {
                            ::SetLastError( ERROR_SUCCESS );
                            m_hCreateEvent = g_Unicode.CreateEvent( NULL, false, false, m_dstrName );

                            if ( m_hCreateEvent )
                            {
                                if ( ::GetLastError() != ERROR_ALREADY_EXISTS )
                                {
                                    //--- Crash occured on thread which owned the magic mutex
                                    ::SetEvent( m_hWaitEvent );
                                }
                                ::CloseHandle( m_hCreateEvent );
                                m_hCreateEvent = NULL;
                            }
                            else
                            {
                                hr = SpHrFromLastWin32Error();
                            }

                            if ( !::ReleaseMutex( m_hMutex ) )
                            {
                                hr = SpHrFromLastWin32Error();
                            }
                        }
                        break;

                    default:
                        return dwResult;
                    }
                    dwNumWaits--;
                }

                //--- Last Wait...
                if ( SUCCEEDED( hr ) )
                {
                    dwResult = ::WaitForMultipleObjects( (hExit)?(2):(1), pHandles, false, dwLastWait );

                    switch ( dwResult )
                    {
                    case WAIT_OBJECT_0:
                        //--- Obtained m_hWaitEvent.  We now own the mutex - need to create
                        //---   m_hCreateEvent.
                        if ( ::WaitForSingleObject( m_hMutex, TIMEOUT_INTERVAL ) != WAIT_OBJECT_0 )
                        {
                            hr = SpHrFromLastWin32Error();
                        }

                        if ( SUCCEEDED( hr ) )
                        {
                            m_hCreateEvent = g_Unicode.CreateEvent( NULL, false, false, m_dstrName );
                            hr = ( m_hCreateEvent ) ? S_OK : SpHrFromLastWin32Error();

                            if ( SUCCEEDED( hr ) )
                            {
                                m_fOwner = true;
                                if ( !::ReleaseMutex( m_hMutex ) )
                                {
                                    ::CloseHandle( m_hCreateEvent );
                                    m_hCreateEvent = NULL;
                                    return WAIT_FAILED;
                                }
                                else
                                {
                                    return WAIT_OBJECT_0;
                                }
                            }
                            else
                            {
                                //--- Need to allow someone else to get the mutex, since this wait has failed...
                                ::SetEvent( m_hWaitEvent );
                                ::ReleaseMutex( m_hMutex );
                                return WAIT_FAILED;
                            }
                        }
                        break;

                    default:
                        return dwResult;
                    }
                }
            }
            return WAIT_FAILED;
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spnotify.h ===
// SPNotify.h : Declaration of the CSpNotify

#ifndef __SPNOTIFY_H_
#define __SPNOTIFY_H_

#ifndef __sapi_h__
#include <sapi.h>
#endif

#include "resource.h"       // main symbols

typedef enum SpNotify_InitState
{
    NOTINIT, INITEVENT, INITHWND, INITCALLBACK, INITISPTASK
};

/////////////////////////////////////////////////////////////////////////////
// CSpNotify
class ATL_NO_VTABLE CSpNotify : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSpNotify, &CLSID_SpNotifyTranslator>,
    public ISpNotifyTranslator
{


public:
DECLARE_REGISTRY_RESOURCEID(IDR_SPNOTIFY)
DECLARE_NOT_AGGREGATABLE(CSpNotify);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSpNotify)
	COM_INTERFACE_ENTRY(ISpNotifyTranslator)
    COM_INTERFACE_ENTRY(ISpNotifySink)
END_COM_MAP()

// Non-interface methods
public:
    CSpNotify();
    void FinalRelease();

    static void RegisterWndClass(HINSTANCE hInstance);
    static void UnregisterWndClass(HINSTANCE hInstance);
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT InitPrivateWindow();

public:
    //
    //  ISpNotify
    //
    STDMETHODIMP Notify(void);
    //
    //  ISpNotifyTranslator
    //
    STDMETHODIMP InitWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP InitCallback(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP InitSpNotifyCallback(ISpNotifyCallback *pSpNotifyCallback, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP InitWin32Event(HANDLE hEvent, BOOL fCloseHandleOnRelease);
    STDMETHODIMP Wait(DWORD dwMilliseconds);
    STDMETHODIMP_(HANDLE) GetEventHandle(void);

private:
    SpNotify_InitState  m_InitState;
    union {
        HANDLE              m_hEvent;
        SPNOTIFYCALLBACK *  m_pfnCallback;
        HWND                m_hwndClient;
        ISpNotifyCallback * m_pSpNotifyCallback;
    };
    LPARAM              m_lParam;
    union
    {
        LONG        m_lScheduled;
        BOOL        m_fCloseHandleOnRelease;
    };
    HWND        m_hwndPrivate;
    WPARAM      m_wParam;
    UINT        m_MsgClient;
};

#endif //__SPNOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spnotify.cpp ===
/*******************************************************************************
* SpNotify.cpp *
*--------------*
*   Description:
*       This module contains the implementation for the CSpNotify object which
*   is used by applications to simplifiy free threaded notifications by providing
*   simple notifications via window messages, apartment model call-backs, or
*   Win32 events.
*-------------------------------------------------------------------------------
*  Created By: RAL
*  Copyright (C) 1998, 1998 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#include "stdafx.h"

#ifndef __sapi_h__
#include <sapi.h>
#endif

#include "SpNotify.h"

/////////////////////////////////////////////////////////////////////////////
// CSpNotify

// === Static member functions used for private window implementation

static const TCHAR szClassName[] = _T("CSpNotify Notify Window");

/*******************************************************************************
* CSpNotify::RegisterWndClass *
*-----------------------------*
*   Description:
*       This static member function registers the window class.  It is called from
*   Sapi.cpp in the DLL_PROCESS_ATTACH call
*******************************************************************************/

void CSpNotify::RegisterWndClass(HINSTANCE hInstance)
{
    WNDCLASS wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.lpfnWndProc = CSpNotify::WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = szClassName;
    if (RegisterClass(&wc) == 0)
    {
        SPDBG_ASSERT(TRUE);
    }
}

/*******************************************************************************
* CSpNotify::UnregisterWndClass *
*-------------------------------*
*   Description:
*       This static member function unreigisters the window class.  It is called from
*   Sapi.cpp in the DLL_PROCESS_DETACH call
*******************************************************************************/

void CSpNotify::UnregisterWndClass(HINSTANCE hInstance)
{
    ::UnregisterClass(szClassName, hInstance);
}

/*******************************************************************************
* CSpNotify::WndProc *
*--------------------*
*   Description:
*       This static member is the window proc for SpNotify objects that use the
*   private window (all except those that use Win32 events).  When the window
*   is cretated, the lpCreateParams of the CREATESTRUCT points to the CSPNotify
*   object that owns the window.  When WM_APP messages are processed by this 
*   function, it calls the appropriate notification mechanism that was specified
*   by the client.
*******************************************************************************/

LRESULT CALLBACK CSpNotify::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_CREATE)
    {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)((CREATESTRUCT *) lParam)->lpCreateParams);
    }
    else
    {
        if (uMsg == WM_APP)
        {
            CSpNotify * pThis = ((CSpNotify *)GetWindowLongPtr(hwnd, GWLP_USERDATA));
            if(pThis)
            {
                ::InterlockedExchange(&(pThis->m_lScheduled), FALSE);
                switch (pThis->m_InitState)
                {
                case INITHWND:
                    ::SendMessage(pThis->m_hwndClient, pThis->m_MsgClient, pThis->m_wParam, pThis->m_lParam);
                    break;
                case INITCALLBACK:
                    pThis->m_pfnCallback(pThis->m_wParam, pThis->m_lParam);
                    break;
                case INITISPTASK:
                    {
                        BOOL bIgnored = TRUE;
                        pThis->m_pSpNotifyCallback->NotifyCallback(pThis->m_wParam, pThis->m_lParam);
                    }
                }
            }
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// === Nonstatic member functions ===

/*******************************************************************************
* CSpNotify::(Constructor) *
*--------------------------*
*   Description:
*       Intitialize the state of members to the uninitialized state.
*******************************************************************************/

CSpNotify::CSpNotify()
{
    m_InitState = NOTINIT;
    m_hwndPrivate = NULL;
    m_lScheduled = FALSE;
}


/*******************************************************************************
* CSpNotify::FinalRelease *
*-------------------------*
*   Description:
*       Cleans up any objects allocated by the SpNotify object.  If the object
*   has an event, then close the handle, otherwise, if the state is anything other
*   than NOTINIT, we need to destroy the private window.
*******************************************************************************/

void CSpNotify::FinalRelease()
{
    if (m_InitState == INITEVENT)
    {
        if (m_fCloseHandleOnRelease)
        {   
            CloseHandle(m_hEvent);
        }
    }
    else
    {
        if (m_InitState != NOTINIT)
        {
            ::DestroyWindow(m_hwndPrivate);
        }
    }
}


/*******************************************************************************
* CSpNotify::InitPrivateWindow *
*------------------------------*
*   Description:
*       This helper function is used to create the private window.
*******************************************************************************/

HRESULT CSpNotify::InitPrivateWindow()
{
    m_hwndPrivate = CreateWindow(szClassName, szClassName,
                                 0, 0, 0, 0, 0, NULL, NULL,
                                 _Module.GetModuleInstance(), this);
    if (m_hwndPrivate)
    {
        return S_OK;
    }
    else
    {
        return SpHrFromLastWin32Error();
    }
}

// === Exported interface methods ===

/*******************************************************************************
* CSpNotify::Notify *
*-------------------*
*   Description:
*       This method is the Notify method of the ISpNotify interface.  It either
*   sets an event or posts a message to the private window if one has not already
*   been posted.
*******************************************************************************/

STDMETHODIMP CSpNotify::Notify(void)
{
    switch (m_InitState)
    {
    case NOTINIT:
        return SPERR_UNINITIALIZED;
    case INITEVENT:
        ::SetEvent(m_hEvent);
        break;
    default:
        if (::InterlockedExchange(&m_lScheduled, TRUE) == FALSE)
        {
            ::PostMessage(m_hwndPrivate, WM_APP, 0, 0);
        }
    }
    return S_OK;  
}

/*******************************************************************************
* CSpNotify::InitWindowMessage *
*------------------------------*
*   Description:
*       An application calls this method to initialize the CSpNotify object to
*   send window messages to a specified window when Notify() is called.
*   Parameters:
*       hWnd    Application's window handle to receive notifications
*       Msg     Message to send to window
*       wParam  wParam that will be used when Msg is sent to application
*       lParam  lParam that will be used when Msg is sent to application
*******************************************************************************/

STDMETHODIMP CSpNotify::InitWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    if (m_InitState != NOTINIT)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else
    {
        if (!::IsWindow(hWnd))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = InitPrivateWindow();
            if (SUCCEEDED(hr))
            {
                m_InitState = INITHWND;
                m_hwndClient = hWnd;
                m_MsgClient = Msg;
                m_wParam = wParam;
                m_lParam = lParam;
            }
        }
    }
    return hr;
}


/*******************************************************************************
* CSpNotify::InitCallback *
*-------------------------*
*   Description:
*       An application calls this method to initialize the CSpNotify object to
*   send notifications via a standard "C"-style callback function.
*   Parameters:
*       pfnCallback specifies the notification callback function
*       wParam and lParam will be passed to the pfnCallback function when it is called.
*******************************************************************************/

STDMETHODIMP CSpNotify::InitCallback(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    if (m_InitState != NOTINIT)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else
    {
        if (::IsBadCodePtr((FARPROC)pfnCallback))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = InitPrivateWindow();
            if (SUCCEEDED(hr))
            {
                m_InitState = INITCALLBACK;
                m_pfnCallback = pfnCallback;
                m_wParam = wParam;
                m_lParam = lParam;
            }
        }
    }
    return hr;
}

/*******************************************************************************
* CSpNotify::InitSpNotifyCallback *
*-------------------------------*
*   Description:
*       An application calls this method to initialize the CSpNotify object to
*   call a virtual function named "NotifyCallback" on a class for notifications.
*   Note that this is NOT a COM interface.  It is simply a standard C++ pure virtual
*   interface with a single method.  Therefore, the implementer is not required to
*   implement QueryInterface, AddRef, or Release.
*   Parameters:
*       pSpNotifyCallback - A pointer to an application-implemented virtual interface.
*       wParam and lParam will be passed to the NotifyCallback function when it is called.
*******************************************************************************/

STDMETHODIMP CSpNotify::InitSpNotifyCallback(ISpNotifyCallback * pSpNotifyCallback, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    if (m_InitState != NOTINIT)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else
    {
        if (SP_IS_BAD_CODE_PTR(pSpNotifyCallback)))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = InitPrivateWindow();
            if (SUCCEEDED(hr))
            {
                m_InitState = INITISPTASK;
                m_pSpNotifyCallback = pSpNotifyCallback;
                m_wParam = wParam;
                m_lParam = lParam;
            }
        }
    }
    return hr;
}

/*******************************************************************************
* CSpNotify::InitWin32Callback *
*------------------------------*
*   Description:
*       An application calls this method to initialize the CSpNotify object to
*   set an event handle when the Notify() method is called.  If the caller does
*   not specify a handle (hEvent is NULL) then this method will create a new event
*   using ::CreateEvent(NULL, FALSE, FALSE, NULL);
*   Parameters:
*       hEvent      An optional event handle provided by the application.  This
*                   parameter can be NULL, in which case it is created as described
*                   above
*       fCloseHandleOnRelease
*                   If hEvent is NULL then this parameter is ignored (the handle is
*                   always closed on release of the object).  If hEvent is non-NULL
*                   then this parameter specifies weather the hEvent handle should
*                   be closed when the object is released.
*******************************************************************************/

STDMETHODIMP CSpNotify::InitWin32Event(HANDLE hEvent, BOOL fCloseHandleOnRelease)
{
    HRESULT hr = S_OK;
    if (m_InitState != NOTINIT)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else
    {
        if (hEvent)
        {
            m_hEvent = hEvent;
            m_fCloseHandleOnRelease = fCloseHandleOnRelease;
        }
        else
        {
            m_hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
            m_fCloseHandleOnRelease = TRUE;
        }
        if (m_hEvent)
        {
            m_InitState = INITEVENT;
        }
        else
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    return hr;
}

/*******************************************************************************
* CSpNotify::Wait *
*-----------------*
*   Description:
*       This method is only valid to use if a SpNotify object has been initialized
*   using InitWin32Event.  It will wait on the event handle for the specified time
*   period using the Win32 API ::WaitEvent() and convert the result to a standard 
*   hresult.
*   Parameters:
*       dwMilliseconds  The maximum amount of time to wait for the event to be set.
*   Return value:
*       S_OK    Indicates the event was set
*       S_FALSE Indicates that the event was not set and the call timed-out
*       Other returns indicate an error.
*******************************************************************************/

STDMETHODIMP CSpNotify::Wait(DWORD dwMilliseconds)
{
    if (m_InitState == INITEVENT)
    {
        switch (::WaitForSingleObject(m_hEvent, dwMilliseconds))
        {
        case WAIT_OBJECT_0:
            return S_OK;
        case WAIT_TIMEOUT:
            return S_FALSE;
        default:
            return SpHrFromLastWin32Error();
        }
    }
    else
    {
        return SPERR_UNINITIALIZED;
    }
}


/*******************************************************************************
* CSpNotify::GetEventHandle *
*---------------------------*
*   Description:
*       This method is only valid to use if a SpNotify object has been initialized
*   using InitWin32Event.  It returns the event handle being used by the object.
*   The handle is NOT a duplicated handle and should NOT be closed by the caller.
*       Returns the Win32 event handle.
*   Parameters:
*       None
*   Return value:
*       If succeeded then the return value is the handle.
*       If the call fails then the return value is INVALID_HANDLE_VALUE
*******************************************************************************/

STDMETHODIMP_(HANDLE) CSpNotify::GetEventHandle(void)
{
    if (m_InitState == INITEVENT)
    {
        return m_hEvent;
    }
    else
    {
        return INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spphrase.cpp ===
/*******************************************************************************
* SpPhrase.Cpp *
*--------------*
*   Description:
*       This is the cpp file for the SpPhraseClass.
*-------------------------------------------------------------------------------
*  Created By: RAL                                        Date: 07/01/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"
#include "spphrase.h"
#include "backend.h" 

#pragma warning (disable : 4296)

//
//--- CPhraseElement --------------------------------------------------------
//

/****************************************************************************
* CPhraseElement::CPhraseElement *
*--------------------------------*
*   Description:
*       Constructor.  Note that the memory has already been allocated for this
*   element that is large enough to hold the text.
*
*   Returns:
*       Nothing
*
********************************************************************* RAL ***/

CPhraseElement::CPhraseElement(const SPPHRASEELEMENT * pElement)
{
    SPDBG_FUNC("CPhraseElement::CPhraseElement");

    *static_cast<SPPHRASEELEMENT *>(this) = *pElement;
    WCHAR * pszDest = m_szText;
    
    BOOL fLexIsDispText = (pszDisplayText == pszLexicalForm);

    CopyString(&pszDisplayText, &pszDest);
    if (fLexIsDispText)
    {
        pszLexicalForm = pszDisplayText;
    }
    else
    {
        CopyString(&pszLexicalForm, &pszDest);
    }
    CopyString(&pszPronunciation, &pszDest);
}


/****************************************************************************
* CPhraseElement::Allocate *
*--------------------------*
*   Description:
*       This call assumes that the caller has already checked the pElement pointer
*   and it is a valid read pointer.  The caller must also have checked that the
*   audio offset and size are valid with respect to both the phrase and the other
*   elements.  All other parmeters are validated by this function.
*
*   Returns:
*       S_OK
*       E_INVALIDARG - String pointer invalid or invalid display attributes
*       E_OUTOFMEMORY
*
********************************************************************* RAL ***/

HRESULT CPhraseElement::Allocate(const SPPHRASEELEMENT * pElement, CPhraseElement ** ppNewElement, ULONG * pcch)
{
    SPDBG_FUNC("CPhraseElement::Allocate");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_STRING_PTR(pElement->pszDisplayText) ||
        (pElement->pszLexicalForm != pElement->pszDisplayText && SP_IS_BAD_OPTIONAL_STRING_PTR(pElement->pszLexicalForm)) ||
        SP_IS_BAD_OPTIONAL_STRING_PTR(pElement->pszPronunciation) ||
        (pElement->bDisplayAttributes & (~SPAF_ALL)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pcch = TotalCCH(pElement);
        ULONG cb = sizeof(CPhraseElement) + ((*pcch) * sizeof(WCHAR));
        BYTE * pBuffer = new BYTE[cb];
        if (pBuffer)
        {
            *ppNewElement = new(pBuffer) CPhraseElement(pElement);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhraseElement::CopyTo *
*------------------------*
*   Description:
*       Copies the element data to an SPPHRASEELEMENT structure.  The caller
*   allocates the space for the element and the text, and passes a pointer to
*   a pointer to the current position in the text buffer.  When this function
*   returns, *ppTextBuffer will be updated to point past the copied text data.
*   The third parameter is ignored.    
*
*   Returns:
*       Nothing
*
********************************************************************* RAL ***/

void CPhraseElement::CopyTo(SPPHRASEELEMENT * pElement, WCHAR ** ppTextBuff, const BYTE *) const
{
    SPDBG_FUNC("CPhraseElement::CopyTo");

    *pElement = *static_cast<const SPPHRASEELEMENT *>(this);
    CopyString(&pElement->pszDisplayText, ppTextBuff);
    if (pszLexicalForm == pszDisplayText)
    {
        pElement->pszLexicalForm = pElement->pszDisplayText;
    }
    else
    {
        CopyString(&pElement->pszLexicalForm, ppTextBuff);
    }
    CopyString(&pElement->pszPronunciation, ppTextBuff);
}

/****************************************************************************
* CPhraseElement::CopyTo *
*------------------------*
*   Description:
*       Copies the element data to an SPSERIALIZEDPHRASEELEMENT.  The caller
*   allocates the space for the element and the text, and passes a pointer to
*   a pointer to the current position in the text buffer.  When this function
*   returns, *ppTextBuffer will be updated to point past the copied text data.
*   The third parameter points to the first byte of the allocated phrase structure
*   and is used to compute offsets of strings within the buffer.
*
*   Returns:
*       Noting
*
********************************************************************* RAL ***/

void CPhraseElement::CopyTo(SPSERIALIZEDPHRASEELEMENT * pElement, WCHAR ** ppTextBuff, const BYTE * pCoMem) const
{
    SPDBG_FUNC("CPhraseElement::CopyTo");

    pElement->ulAudioStreamOffset = ulAudioStreamOffset;
    pElement->ulAudioSizeBytes = ulAudioSizeBytes;
    pElement->ulRetainedStreamOffset = ulRetainedStreamOffset;
    pElement->ulRetainedSizeBytes = ulRetainedSizeBytes;
    pElement->ulAudioTimeOffset = ulAudioTimeOffset;
    pElement->ulAudioSizeTime = ulAudioSizeTime;
    pElement->bDisplayAttributes = bDisplayAttributes;
    pElement->RequiredConfidence = RequiredConfidence;
    pElement->ActualConfidence = ActualConfidence;
    pElement->Reserved = Reserved;
    pElement->SREngineConfidence = SREngineConfidence;
    SerializeString(&pElement->pszDisplayText, pszDisplayText, ppTextBuff, pCoMem);
    if (pszLexicalForm == pszDisplayText)
    {
        pElement->pszLexicalForm = pElement->pszDisplayText;
    }
    else
    {
        SerializeString(&pElement->pszLexicalForm, pszLexicalForm, ppTextBuff, pCoMem);
    }
    SerializeString(&pElement->pszPronunciation, pszPronunciation, ppTextBuff, pCoMem);
}

/****************************************************************************
* CPhraseElement::Discard *
*-------------------------*
*   Description:
*       Discards the requested data from an individual element.  This function
*   simply sets the string pointers to NULL, but does not attempt to reallocate
*   the structure.    
*
*   Returns:
*       The total number of characters discarded.
*
********************************************************************* RAL ***/

ULONG CPhraseElement::Discard(DWORD dwFlags)
{
    SPDBG_FUNC("CPhraseElement::Discard");
    ULONG cchRemoved = 0;
    if ((dwFlags & SPDF_DISPLAYTEXT) && pszDisplayText)
    {
        bDisplayAttributes = 0;
        if (pszDisplayText != pszLexicalForm)
        {
            cchRemoved = TotalCCH(pszDisplayText);
        }
        pszDisplayText = NULL;
    }
    if ((dwFlags & SPDF_LEXICALFORM) && pszLexicalForm)
    {
        if (pszDisplayText != pszLexicalForm)
        {
            cchRemoved += TotalCCH(pszLexicalForm);
        }
        pszLexicalForm = NULL;
    }
    if ((dwFlags & SPDF_PRONUNCIATION) && pszPronunciation)
    {
        cchRemoved += TotalCCH(pszPronunciation);
        pszPronunciation = NULL;
    }
    return cchRemoved;
}

//
//--- CPhraseRule -----------------------------------------------------------
//

/****************************************************************************
* CPhraseRule::CPhraseRule *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CPhraseRule::CPhraseRule(const SPPHRASERULE * pRule, const SPPHRASERULEHANDLE hRule) :
    m_hRule(hRule)
{
    SPDBG_FUNC("CPhraseRule::CPhraseRule");
        
    *static_cast<SPPHRASERULE *>(this) = *pRule;
    pFirstChild = NULL;
    pNextSibling = NULL;
    WCHAR * pszDest = m_szText;
    
    CopyString(&pszName, &pszDest);
}


/****************************************************************************
* CPhraseRule::Allocate *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhraseRule::Allocate(const SPPHRASERULE * pRule, const SPPHRASERULEHANDLE hRule, CPhraseRule ** ppNewRule, ULONG * pcch)
{
    SPDBG_FUNC("CPhraseValue::Allocate");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_STRING_PTR(pRule->pszName) ||
        pRule->Confidence < SP_LOW_CONFIDENCE ||
        pRule->Confidence > SP_HIGH_CONFIDENCE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pcch = TotalCCH(pRule);
        ULONG cb = sizeof(CPhraseRule) + ((*pcch) * sizeof(WCHAR));
        BYTE * pBuffer = new BYTE[cb];
        if (pBuffer)
        {
            *ppNewRule = new(pBuffer) CPhraseRule(pRule, hRule);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhraseRule::FindRuleFromHandle *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CPhraseRule * CPhraseRule::FindRuleFromHandle(const SPPHRASERULEHANDLE hRule)
{
    if (hRule == m_hRule)
    {
        return this;
    }
    for (CPhraseRule * pChild = m_Children.GetHead(); pChild; pChild = pChild->m_pNext)
    {
        CPhraseRule * pFound = pChild->FindRuleFromHandle(hRule);
        if (pFound)
        {
            return pFound;
        }
    }
    return NULL;
}


/****************************************************************************
* CPhraseRule::CopyTo *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CPhraseRule::CopyTo(SPPHRASERULE * pRule, WCHAR ** ppText, const BYTE *) const
{
    SPDBG_FUNC("CPhraseRule::CopyTo");
        
    *pRule = *(static_cast<const SPPHRASERULE *>(this));
    CopyString(&pRule->pszName, ppText);
}


/****************************************************************************
* CPhraseRule::CopyTo *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CPhraseRule::CopyTo(SPSERIALIZEDPHRASERULE * pRule, WCHAR ** ppText, const BYTE * pCoMem) const 
{
    SPDBG_FUNC("CPhraseRule::CopyTo");

    pRule->ulId = ulId;
    pRule->ulFirstElement = ulFirstElement;
    pRule->ulCountOfElements = ulCountOfElements;
    pRule->pNextSibling = 0;
    pRule->pFirstChild = 0;
    pRule->Confidence = Confidence;
    pRule->SREngineConfidence = SREngineConfidence;
    SerializeString(&pRule->pszName, pszName, ppText, pCoMem);
}




/****************************************************************************
* CPhraseRule::AddChild *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhraseRule::AddChild(const SPPHRASERULE * pRule, SPPHRASERULEHANDLE hNewRule, CPhraseRule ** ppNewRule, ULONG * pcch)
{
    SPDBG_FUNC("CPhraseRule::AddChild");
    HRESULT hr = S_OK;

    ULONG ulLastElement = pRule->ulFirstElement + pRule->ulCountOfElements;
    if (ulFirstElement > pRule->ulFirstElement ||
        ulFirstElement + ulCountOfElements < ulLastElement)
    {
        hr = E_INVALIDARG;
    }
    for (CPhraseRule * pSibling = m_Children.GetHead();
         SUCCEEDED(hr) && pSibling && pSibling->ulFirstElement < ulLastElement;
         pSibling = pSibling->m_pNext)
    {
        if (pSibling->ulFirstElement + pSibling->ulCountOfElements > ulLastElement)
        {
            SPDBG_ASSERT(FALSE);
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr))
    {
        CPhraseRule * pNew;
        hr = CPhraseRule::Allocate(pRule, hNewRule, &pNew, pcch);
        if (SUCCEEDED(hr))
        {
            m_Children.InsertSorted(pNew);
            *ppNewRule = pNew;
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



//
//--- CPhraseProperty --------------------------------------------------------
//

/****************************************************************************
* CPhraseProperty::CPhraseProperty *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CPhraseProperty::CPhraseProperty(const SPPHRASEPROPERTY * pProp, const SPPHRASEPROPERTYHANDLE hProperty, HRESULT * phr) :
    m_hProperty(hProperty)
{
    *static_cast<SPPHRASEPROPERTY *>(this) = *pProp;
    pszValue = NULL;    // Fixed up later
    pFirstChild = NULL;
    pNextSibling = NULL;
    WCHAR * pszDest = m_szText;
    
    CopyString(&pszName, &pszDest);
    ULONG ulIgnored;
    *phr = (pProp->pszValue) ? SetValueString(pProp->pszValue, &ulIgnored) : S_OK;
}

/****************************************************************************
* CPhraseProperty::Allocate *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhraseProperty::Allocate(const SPPHRASEPROPERTY * pProperty,
                                  const SPPHRASEPROPERTYHANDLE hProperty,
                                  CPhraseProperty ** ppNewProperty,
                                  ULONG * pcch)
{
    SPDBG_FUNC("CPhraseProperty::Allocate");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_STRING_PTR(pProperty->pszName) ||
        SP_IS_BAD_OPTIONAL_STRING_PTR(pProperty->pszValue) ||
        pProperty->Confidence < SP_LOW_CONFIDENCE ||
        pProperty->Confidence > SP_HIGH_CONFIDENCE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ValidateSemanticVariantType(pProperty->vValue.vt);
    }
    if (SUCCEEDED(hr))
    {
        ULONG cchName = TotalCCH(pProperty->pszName);
        *pcch = cchName + TotalCCH(pProperty->pszValue);
        ULONG cb = sizeof(CPhraseProperty) + (cchName * sizeof(WCHAR));
        BYTE * pBuffer = new BYTE[cb];
        if (pBuffer)
        {
            *ppNewProperty = new(pBuffer) CPhraseProperty(pProperty, hProperty, &hr);
            if (FAILED(hr))
            {
                delete (*ppNewProperty);
                *ppNewProperty = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CPhraseProperty::CopyTo *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CPhraseProperty::CopyTo(SPPHRASEPROPERTY * pProp, WCHAR ** ppTextBuff, const BYTE *) const
{
    SPDBG_FUNC("CPhraseProperty::CopyTo");
    *pProp = *(static_cast<const SPPHRASEPROPERTY *>(this));

    CopyString(&pProp->pszName, ppTextBuff);
    CopyString(&pProp->pszValue, ppTextBuff);
}


/****************************************************************************
* CPhraseProperty::CopyTo *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CPhraseProperty::CopyTo(SPSERIALIZEDPHRASEPROPERTY * pProp, WCHAR ** ppTextBuff, const BYTE * pCoMem) const 
{
    SPDBG_FUNC("CPhraseProperty::CopyTo");

    pProp->ulId = ulId;
    pProp->VariantType = vValue.vt;
    CopyVariantToSemanticValue(&vValue, &pProp->SpVariantSubset);
    pProp->ulFirstElement = ulFirstElement;
    pProp->ulCountOfElements = ulCountOfElements;
    pProp->pNextSibling = 0;
    pProp->pFirstChild = 0;
    pProp->Confidence = Confidence;
    pProp->SREngineConfidence = SREngineConfidence;

    SerializeString(&pProp->pszName, pszName, ppTextBuff, pCoMem);
    SerializeString(&pProp->pszValue, pszValue, ppTextBuff, pCoMem);
}



//
//--- CPhraseReplacement ----------------------------------------------------
//

/****************************************************************************
* CPhraseReplacement::CPhraseReplacement *
*----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CPhraseReplacement::CPhraseReplacement(const SPPHRASEREPLACEMENT * pReplace)
{
    *static_cast<SPPHRASEREPLACEMENT *>(this) = *pReplace;
    WCHAR * pszDest = m_szText;
    CopyString(&pszReplacementText, &pszDest);
}

/****************************************************************************
* CPhraseReplacement::Allocate *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhraseReplacement::Allocate(const SPPHRASEREPLACEMENT * pReplace, CPhraseReplacement ** ppNewReplace, ULONG * pcch)
{
    SPDBG_FUNC("CPhraseReplacement::Allocate");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pReplace->pszReplacementText))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pcch = TotalCCH(pReplace);
        ULONG cb = sizeof(CPhraseReplacement) + ((*pcch) * sizeof(WCHAR));
        BYTE * pBuffer = new BYTE[cb];
        if (pBuffer)
        {
            *ppNewReplace = new(pBuffer) CPhraseReplacement(pReplace);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhraseReplacement::CopyTo *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CPhraseReplacement::CopyTo(SPPHRASEREPLACEMENT * pReplace, WCHAR ** ppTextBuff, const BYTE *) const 
{
    SPDBG_FUNC("CPhraseReplacement::CopyTo");
    *pReplace = *(static_cast<const SPPHRASEREPLACEMENT *>(this));

    CopyString(&pReplace->pszReplacementText, ppTextBuff);
}


/****************************************************************************
* CPhraseReplacement::CopyTo *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CPhraseReplacement::CopyTo(SPSERIALIZEDPHRASEREPLACEMENT * pReplace, WCHAR ** ppTextBuff, const BYTE * pCoMem) const 
{
    SPDBG_FUNC("CPhraseReplacement::CopyTo");

    pReplace->ulFirstElement = ulFirstElement;
    pReplace->ulCountOfElements = ulCountOfElements;
    pReplace->bDisplayAttributes = bDisplayAttributes;

    SerializeString(&pReplace->pszReplacementText, pszReplacementText, ppTextBuff, pCoMem);
}




/****************************************************************************
* CPhrase::CPhrase *
*------------------*
*   Description:
*       Constructor.  Initializes the CPhrase object.
*
*   Returns:
*
********************************************************************* RAL ***/

CPhrase::CPhrase()
{
    SPDBG_FUNC("CPhrase::CPhrase");
    m_RuleHandle = NULL;
    m_pTopLevelRule = NULL;
    m_ulNextHandleValue = 1;
    m_cRules = 0;
    m_cProperties = 0;
    m_cchElements = 0;
    m_cchRules = 0;
    m_cchProperties = 0;
    m_cchReplacements = 0;
    m_ulSREnginePrivateDataSize = 0;
    m_pSREnginePrivateData = NULL;
}

/****************************************************************************
* CPhrase::~CPhrase *
*-------------------*
*   Description:
*       Destructor simply deletes the top level rule.  The destructors for
*   the various lists will delete all other allocated objects.    
*
*   Returns:
*       Nothing
*
********************************************************************* RAL ***/

CPhrase::~CPhrase()
{
    Reset();
}

/****************************************************************************
* CPhrase::Reset *
*----------------*
*   Description:
*       Resets the CPhrase object to its initial state (no elements, rules, etc)
*
*   Returns:
*       Nothing
*
********************************************************************* RAL ***/

void CPhrase::Reset()
{
    SPDBG_FUNC("CPhrase::Reset");
    if( m_pTopLevelRule )
    {
        m_pTopLevelRule->m_Children.ExplicitPurge();
    }

    delete m_pTopLevelRule;
    m_pTopLevelRule = NULL;

    m_PropertyList.ExplicitPurge();
    m_ReplaceList.ExplicitPurge();
    m_ElementList.ExplicitPurge();
    m_cpCFGEngine.Release();
    m_RuleHandle = NULL;
    m_ulNextHandleValue = 1;
    m_cRules = 0;
    m_cProperties = 0;
    m_cchElements = 0;
    m_cchRules = 0;
    m_cchProperties = 0;
    m_cchReplacements = 0;
    ::CoTaskMemFree(m_pSREnginePrivateData);
    m_pSREnginePrivateData = NULL;
    m_ulSREnginePrivateDataSize = 0;

}


/****************************************************************************
* InternalGetPhrase *
*-------------------*
*   Description:
*       Template function used by GetPhrase and GetSerializedPhrase.  The logic
*   for both is identical, so this simply inovokes the appropriate CopyTo() method
*   for the type of phrase.
*
*       This function assumes that the pPhrase object's critical section lock has
*   been claimed by the caller.
*
*   Returns:
*       S_OK
*       E_POINTER
*       SPERR_UNINITIALIZED
*       E_OUTOFMEMORY
*
********************************************************************* RAL ***/

template <class TPHRASE, class TELEMENT, class TRULE, class TPROP, class TREPLACE>
HRESULT InternalGetPhrase(const CPhrase * pPhrase, TPHRASE ** ppCoMemPhrase, ULONG * pcbAllocated)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(ppCoMemPhrase))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppCoMemPhrase = NULL;
        if (pPhrase->m_pTopLevelRule == NULL)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            ULONG cbPrivateDataSize = pPhrase->m_ulSREnginePrivateDataSize;
            cbPrivateDataSize = (cbPrivateDataSize + 3) - ((cbPrivateDataSize +3) % 4);
            ULONG cbStruct = sizeof(TPHRASE) +
                             (pPhrase->m_ElementList.GetCount() * sizeof(TELEMENT)) +
                             (pPhrase->m_cRules * sizeof(TRULE)) +
                             (pPhrase->m_cProperties * sizeof(TPROP)) +
                             (pPhrase->m_ReplaceList.GetCount() * sizeof(TREPLACE) +
                             cbPrivateDataSize);
            ULONG cch = pPhrase->TotalCCH();

            *pcbAllocated = cbStruct + (cch * sizeof(WCHAR));
            BYTE * pBuffer = (BYTE *)::CoTaskMemAlloc(*pcbAllocated);
            if (pBuffer)
            {
                TPHRASE * pNewPhrase = (TPHRASE *)pBuffer;
                memset(pNewPhrase, 0, sizeof(*pNewPhrase));
                *ppCoMemPhrase = pNewPhrase;
                pNewPhrase->cbSize = sizeof(*pNewPhrase);
                pNewPhrase->LangID = pPhrase->m_LangID;
                pNewPhrase->ullGrammarID = pPhrase->m_ullGrammarID;
                pNewPhrase->ftStartTime = pPhrase->m_ftStartTime;
                pNewPhrase->ullAudioStreamPosition = pPhrase->m_ullAudioStreamPosition;
                pNewPhrase->ulAudioSizeBytes = pPhrase->m_ulAudioSizeBytes;
                pNewPhrase->ulRetainedSizeBytes = pPhrase->m_ulRetainedSizeBytes;
                pNewPhrase->ulAudioSizeTime = pPhrase->m_ulAudioSizeTime;
                pNewPhrase->SREngineID = pPhrase->m_SREngineID;
                pNewPhrase->cReplacements = pPhrase->m_ReplaceList.GetCount();
                pNewPhrase->ulSREnginePrivateDataSize = pPhrase->m_ulSREnginePrivateDataSize;

                BYTE * pCopyBuff = (BYTE *)(&pNewPhrase->Rule);
                WCHAR * pszTextBuff = (WCHAR *)(pBuffer + cbStruct);

                pPhrase->m_pTopLevelRule->CopyTo((TRULE *)(pCopyBuff), &pszTextBuff, pBuffer);
                pCopyBuff = pBuffer + sizeof(TPHRASE);

                CopyTo<CPhraseElement, TELEMENT>(pPhrase->m_ElementList, &pNewPhrase->pElements, &pCopyBuff, &pszTextBuff, pBuffer);
                CopyToRecurse<CPhraseRule, TRULE>(pPhrase->m_pTopLevelRule->m_Children, &pNewPhrase->Rule.pFirstChild, &pCopyBuff, &pszTextBuff, pBuffer);
                CopyToRecurse<CPhraseProperty, TPROP>(pPhrase->m_PropertyList, &pNewPhrase->pProperties, &pCopyBuff, &pszTextBuff, pBuffer);
                CopyTo<CPhraseReplacement, TREPLACE>(pPhrase->m_ReplaceList, &pNewPhrase->pReplacements, &pCopyBuff, &pszTextBuff, pBuffer);

                CopyEnginePrivateData(&pNewPhrase->pSREnginePrivateData, pCopyBuff, pPhrase->m_pSREnginePrivateData, pPhrase->m_ulSREnginePrivateDataSize, pBuffer);
                // don't use pCopyBuff after this point because this doesn't advance pCopyBuff pointer,
                // if you need to, add in cbPrivateDataSize to pCopyBuff!

                SPDBG_ASSERT((BYTE *)pszTextBuff == pBuffer + cbStruct + (cch * sizeof(WCHAR)));
                SPDBG_ASSERT(pCopyBuff == pBuffer + cbStruct - cbPrivateDataSize);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

/****************************************************************************
* CPhrase::GetPhrase *
*--------------------*
*   Description:
*       Returns a CoTaskMemAlloc'ed block of memory that contains all of the data
*   for this phrase. 
*
*   Returns:
*       Same as InternalGetPhrase
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::GetPhrase(SPPHRASE ** ppCoMemPhrase)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CPhrase::GetPhrase");
    HRESULT hr = S_OK;
    ULONG cbIgnored;
    hr = InternalGetPhrase<SPPHRASE, SPPHRASEELEMENT, SPPHRASERULE, SPPHRASEPROPERTY, SPPHRASEREPLACEMENT>(this, ppCoMemPhrase, &cbIgnored);
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::GetSerializedPhrase *
*------------------------------*
*   Description:
*       Returns a CoTaskMemAlloc'ed block of memory that contains all of the data
*   for this phrase. 
*
*   Returns:
*       Same as InternalGetPhrase
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::GetSerializedPhrase(SPSERIALIZEDPHRASE ** ppCoMemPhrase)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CPhrase::GetSerializedPhrase");
    HRESULT hr = S_OK;
    ULONG cb;
    hr = InternalGetPhrase<SPINTERNALSERIALIZEDPHRASE, SPSERIALIZEDPHRASEELEMENT, SPSERIALIZEDPHRASERULE, SPSERIALIZEDPHRASEPROPERTY, SPSERIALIZEDPHRASEREPLACEMENT>(this, (SPINTERNALSERIALIZEDPHRASE **)ppCoMemPhrase, &cb);
    if (SUCCEEDED(hr))
    {
        (*ppCoMemPhrase)->ulSerializedSize = cb;
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::InitFromPhrase *
*-------------------------*
*   Description:
*       If this function is called with a NULL pSrcPhrase then the object is
*   reset to its initial state.  If pSrcPhrase is 
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::InitFromPhrase(const SPPHRASE * pSrcPhrase)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CPhrase::InitFromPhrase");
    HRESULT hr = S_OK;

    // Remember these values before reseting
    CComPtr<ISpCFGEngine> cpCFGEngine = m_cpCFGEngine;
    SPRULEHANDLE RuleHandle = m_RuleHandle;

    Reset();

    if (pSrcPhrase)
    {
        if (SP_IS_BAD_READ_PTR(pSrcPhrase) ||
            pSrcPhrase->cbSize != sizeof(*pSrcPhrase) ||
            pSrcPhrase->Rule.pNextSibling ||
            pSrcPhrase->LangID == 0)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_LangID = pSrcPhrase->LangID;
            m_ullGrammarID = pSrcPhrase->ullGrammarID;
            m_ftStartTime = pSrcPhrase->ftStartTime;
            m_ullAudioStreamPosition = pSrcPhrase->ullAudioStreamPosition;
            m_ulAudioSizeBytes = pSrcPhrase->ulAudioSizeBytes;
            m_ulRetainedSizeBytes = pSrcPhrase->ulRetainedSizeBytes;
            m_ulAudioSizeTime = pSrcPhrase->ulAudioSizeTime;
            hr = CPhraseRule::Allocate(&pSrcPhrase->Rule, NULL, &m_pTopLevelRule, &m_cchRules);
            if (SUCCEEDED(hr) && pSrcPhrase->Rule.ulCountOfElements)
            {
                hr = AddElements(pSrcPhrase->Rule.ulCountOfElements, pSrcPhrase->pElements);
            }
            if (SUCCEEDED(hr) && pSrcPhrase->Rule.pFirstChild)
            {
                hr = AddRules(NULL, pSrcPhrase->Rule.pFirstChild, NULL);
            }
            if (SUCCEEDED(hr) && pSrcPhrase->pProperties)
            {
                hr = AddProperties(NULL, pSrcPhrase->pProperties, NULL);
            }
            if (SUCCEEDED(hr) && pSrcPhrase->cReplacements)
            {
                hr = AddReplacements(pSrcPhrase->cReplacements, pSrcPhrase->pReplacements);
            }
            if (SUCCEEDED(hr))
            {
                m_cpCFGEngine = cpCFGEngine;
                m_RuleHandle = RuleHandle;
            }
            if (FAILED(hr))
            {
                Reset();
            }
            m_SREngineID = pSrcPhrase->SREngineID;
            if (pSrcPhrase->ulSREnginePrivateDataSize)
            {
                BYTE* pByte = (BYTE*)::CoTaskMemAlloc(pSrcPhrase->ulSREnginePrivateDataSize);
                if (pByte)
                {
                    m_ulSREnginePrivateDataSize = pSrcPhrase->ulSREnginePrivateDataSize;
                    memcpy(pByte, pSrcPhrase->pSREnginePrivateData, m_ulSREnginePrivateDataSize);
                    m_pSREnginePrivateData = pByte;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CPhrase::AddSerializedElements *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhrase::AddSerializedElements(const SPINTERNALSERIALIZEDPHRASE * pPhrase)
{
    SPDBG_FUNC("CPhrase::AddSerializedElements");
    HRESULT hr = S_OK;
    ULONG cElements = pPhrase->Rule.ulCountOfElements;

    const BYTE * pFirstByte = (const BYTE *)pPhrase;
    const BYTE * pPastEnd = pFirstByte + pPhrase->ulSerializedSize;
    if ((pFirstByte + pPhrase->pElements + (cElements * sizeof(SPSERIALIZEDPHRASEELEMENT))) > pPastEnd)    
    {
        hr = E_INVALIDARG;
    }
    else
    {
        SPSERIALIZEDPHRASEELEMENT * pSrc = (SPSERIALIZEDPHRASEELEMENT *)(pFirstByte + pPhrase->pElements);
        SPPHRASEELEMENT * pElems = STACK_ALLOC(SPPHRASEELEMENT, cElements);
        for (ULONG i = 0; i < cElements; i++)
        {
            pElems[i].ulAudioTimeOffset = pSrc[i].ulAudioTimeOffset;
            pElems[i].ulAudioSizeTime = pSrc[i].ulAudioSizeTime;
            pElems[i].ulAudioStreamOffset = pSrc[i].ulAudioStreamOffset;
            pElems[i].ulAudioSizeBytes = pSrc[i].ulAudioSizeBytes;
            pElems[i].ulRetainedStreamOffset = pSrc[i].ulRetainedStreamOffset;
            pElems[i].ulRetainedSizeBytes = pSrc[i].ulRetainedSizeBytes;
            pElems[i].bDisplayAttributes = pSrc[i].bDisplayAttributes;
            pElems[i].RequiredConfidence = pSrc[i].RequiredConfidence;
            pElems[i].ActualConfidence = pSrc[i].ActualConfidence;
            pElems[i].Reserved = pSrc[i].Reserved;
            pElems[i].SREngineConfidence = pSrc[i].SREngineConfidence;

            pElems[i].pszDisplayText = OffsetToString(pFirstByte, pSrc[i].pszDisplayText);
            pElems[i].pszLexicalForm = OffsetToString(pFirstByte, pSrc[i].pszLexicalForm);
            pElems[i].pszPronunciation = OffsetToString(pFirstByte, pSrc[i].pszPronunciation);
        }
        hr = AddElements(cElements, pElems);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::RecurseAddSerializedRule *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhrase::RecurseAddSerializedRule(const BYTE * pFirstByte, CPhraseRule * pParent, const SPSERIALIZEDPHRASERULE * pSerRule)
{
    SPDBG_FUNC("CPhrase::RecurseAddSerializedRule");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pSerRule))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        SPPHRASERULE Rule;

        Rule.ulId = pSerRule->ulId;
        Rule.ulFirstElement = pSerRule->ulFirstElement;
        Rule.ulCountOfElements = pSerRule->ulCountOfElements;
        Rule.pNextSibling = NULL;
        Rule.pFirstChild = NULL;
        Rule.SREngineConfidence = pSerRule->SREngineConfidence;
        Rule.Confidence = pSerRule->Confidence;
        Rule.pszName = OffsetToString(pFirstByte, pSerRule->pszName);

        CPhraseRule * pNewRule;
        ULONG cch;
        hr = pParent->AddChild(&Rule, (SPPHRASERULEHANDLE)NewHandleValue(), &pNewRule, &cch);
        if (SUCCEEDED(hr))
        {
            m_cchRules += cch;
            m_cRules++;
            if (pSerRule->pNextSibling)
            {
                hr = RecurseAddSerializedRule(pFirstByte, pParent, 
                                             (SPSERIALIZEDPHRASERULE *)(pFirstByte + pSerRule->pNextSibling));
            }
        }
        if (SUCCEEDED(hr) && pSerRule->pFirstChild)
        {
            hr = RecurseAddSerializedRule(pFirstByte, pNewRule,
                                         (SPSERIALIZEDPHRASERULE *)(pFirstByte + pSerRule->pFirstChild));
        }
        // No need to clean up on failure since entire phrase will be dumped
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CPhrase::RecurseAddSerializedProperty *
*---------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhrase::RecurseAddSerializedProperty(const BYTE * pFirstByte,
                                              CPropertyList * pParentPropList,
                                              ULONG ulParentFirstElement, 
                                              ULONG ulParentCountOfElements,
                                              const SPSERIALIZEDPHRASEPROPERTY * pSerProp)
{
    SPDBG_FUNC("CPhrase::RecurseAddSerializedProperty");
    HRESULT hr = S_OK;

    if (//ulParentCountOfElements == 0 ||   // If attempt to add child of a leaf element... NOW VALID!
        SP_IS_BAD_READ_PTR(pSerProp) ||
        (pSerProp->ulCountOfElements && (pSerProp->ulFirstElement < ulParentFirstElement ||
                                         pSerProp->ulFirstElement + pSerProp->ulCountOfElements > ulParentFirstElement + ulParentCountOfElements)))
        // (pSerProp->ulCountOfElements == 0 && (pSerProp->ulFirstElement != 0 || pSerProp->pFirstChild))) -- can't use it because of epsilon transitions -- PhilSch
    {
        SPDBG_ASSERT(FALSE);
        hr = E_INVALIDARG;
    }
    else
    {
        if (pSerProp->ulCountOfElements)
        {
            ULONG ulLastElement = pSerProp->ulFirstElement + pSerProp->ulCountOfElements;
            for (CPhraseProperty * pSibling = pParentPropList->GetHead();
                 SUCCEEDED(hr) && pSibling && pSibling->ulFirstElement < ulLastElement;
                 pSibling = pSibling->m_pNext)
            {
                if (pSibling->ulFirstElement + pSibling->ulCountOfElements > pSerProp->ulFirstElement)
                {
                    SPDBG_ASSERT(FALSE);
                    hr = E_INVALIDARG;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            SPPHRASEPROPERTY Prop;
            Prop.pszName = OffsetToString(pFirstByte, pSerProp->pszName);
            Prop.ulId = pSerProp->ulId;
            Prop.pszValue = OffsetToString(pFirstByte, pSerProp->pszValue);
            Prop.vValue.vt = pSerProp->VariantType;
            CopySemanticValueToVariant(&pSerProp->SpVariantSubset, &Prop.vValue);
            Prop.ulFirstElement = pSerProp->ulFirstElement;
            Prop.ulCountOfElements = pSerProp->ulCountOfElements;
            Prop.Confidence = pSerProp->Confidence;
            Prop.SREngineConfidence = pSerProp->SREngineConfidence;
            Prop.pFirstChild = NULL;
            Prop.pNextSibling = NULL;
            CPhraseProperty * pNewProp;
            ULONG cch;
            hr = CPhraseProperty::Allocate(&Prop, (SPPHRASEPROPERTYHANDLE)NewHandleValue(), &pNewProp, &cch);
            if (SUCCEEDED(hr))
            {
                m_cchProperties += cch;
                m_cProperties++;
                pParentPropList->InsertSorted(pNewProp);
                if (pSerProp->pNextSibling)
                {
                    hr = RecurseAddSerializedProperty(pFirstByte, pParentPropList, ulParentFirstElement, ulParentCountOfElements,
                                                      (SPSERIALIZEDPHRASEPROPERTY *)(pFirstByte + pSerProp->pNextSibling));
                }
                if (SUCCEEDED(hr) && pSerProp->pFirstChild)
                {
                    hr = RecurseAddSerializedProperty(pFirstByte, &pNewProp->m_Children, pNewProp->ulFirstElement, pNewProp->ulCountOfElements,
                                                      (SPSERIALIZEDPHRASEPROPERTY *)(pFirstByte + pSerProp->pFirstChild));
                }
                // No need to clean up on failure since entire phrase will be dumped
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CPhrase::AddSerializedReplacements *
*------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhrase::AddSerializedReplacements(const SPINTERNALSERIALIZEDPHRASE * pPhrase)
{
    SPDBG_FUNC("CPhrase::AddSerializedReplacements");
    HRESULT hr = S_OK;

    ULONG cReplacements = pPhrase->cReplacements;

    const BYTE * pFirstByte = (const BYTE *)pPhrase;
    const BYTE * pPastEnd = pFirstByte + pPhrase->ulSerializedSize;
    if ((pFirstByte + pPhrase->pReplacements + (cReplacements * sizeof(SPSERIALIZEDPHRASEREPLACEMENT))) > pPastEnd)    
    {
        hr = E_INVALIDARG;
    }
    else
    {
        SPSERIALIZEDPHRASEREPLACEMENT * pSrc = (SPSERIALIZEDPHRASEREPLACEMENT *)(pFirstByte + pPhrase->pReplacements);
        SPPHRASEREPLACEMENT * pRepl = STACK_ALLOC(SPPHRASEREPLACEMENT, cReplacements);
        for (ULONG i = 0; i < cReplacements; i++)
        {
            pRepl[i].ulFirstElement = pSrc[i].ulFirstElement;
            pRepl[i].ulCountOfElements = pSrc[i].ulCountOfElements;
            pRepl[i].bDisplayAttributes = pSrc[i].bDisplayAttributes;
            pRepl[i].pszReplacementText = OffsetToString(pFirstByte, pSrc[i].pszReplacementText);
        }
        hr = AddReplacements(cReplacements, pRepl);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CPhrase::InitFromSerializedPhrase *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::InitFromSerializedPhrase(const SPSERIALIZEDPHRASE * pExternalSrcPhrase)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CPhrase::InitFromSerializedPhrase");
    HRESULT hr = S_OK;

    SPINTERNALSERIALIZEDPHRASE * pSrcPhrase = (SPINTERNALSERIALIZEDPHRASE *)pExternalSrcPhrase;

    // Remember these values before reseting
    CComPtr<ISpCFGEngine> cpCFGEngine = m_cpCFGEngine;
    SPRULEHANDLE RuleHandle = m_RuleHandle;

    Reset();

    if (pSrcPhrase)
    {
        if (SP_IS_BAD_READ_PTR(pSrcPhrase) || pSrcPhrase->ulSerializedSize < sizeof(*pSrcPhrase) ||
            SPIsBadReadPtr(pSrcPhrase, pSrcPhrase->ulSerializedSize) ||
            pSrcPhrase->Rule.pNextSibling)
        {
            hr = E_INVALIDARG;
            SPDBG_ASSERT(0);
        }
        else
        {
            const BYTE * pFirstByte = (const BYTE *)pSrcPhrase;

            SPPHRASE NewPhrase;
            memset(&NewPhrase, 0, sizeof(NewPhrase));
            NewPhrase.cbSize = sizeof(NewPhrase);
            NewPhrase.LangID = pSrcPhrase->LangID;
            NewPhrase.ullGrammarID = pSrcPhrase->ullGrammarID;
            NewPhrase.ftStartTime = pSrcPhrase->ftStartTime;
            NewPhrase.ullAudioStreamPosition = pSrcPhrase->ullAudioStreamPosition;
            NewPhrase.ulAudioSizeBytes = pSrcPhrase->ulAudioSizeBytes;
            NewPhrase.ulRetainedSizeBytes = pSrcPhrase->ulRetainedSizeBytes;
            NewPhrase.ulAudioSizeTime = pSrcPhrase->ulAudioSizeTime;
            NewPhrase.SREngineID = pSrcPhrase->SREngineID;
            NewPhrase.Rule.pszName = OffsetToString(pFirstByte, pSrcPhrase->Rule.pszName);
            NewPhrase.Rule.ulId = pSrcPhrase->Rule.ulId;
            NewPhrase.Rule.SREngineConfidence = pSrcPhrase->Rule.SREngineConfidence;
            NewPhrase.Rule.Confidence = pSrcPhrase->Rule.Confidence;
            NewPhrase.ulSREnginePrivateDataSize = pSrcPhrase->ulSREnginePrivateDataSize;
            NewPhrase.pSREnginePrivateData = (pSrcPhrase->ulSREnginePrivateDataSize) ? pFirstByte + pSrcPhrase->pSREnginePrivateData : NULL;
            hr = InitFromPhrase(&NewPhrase);    

            if (SUCCEEDED(hr) && pSrcPhrase->Rule.ulCountOfElements)
            {
                hr = AddSerializedElements(pSrcPhrase);
            }
            if (SUCCEEDED(hr) && pSrcPhrase->Rule.pFirstChild)
            {
                hr = RecurseAddSerializedRule(pFirstByte, m_pTopLevelRule,
                                              (SPSERIALIZEDPHRASERULE *)(pFirstByte + pSrcPhrase->Rule.pFirstChild));
            }
            if (SUCCEEDED(hr) && pSrcPhrase->pProperties)
            {
                hr = RecurseAddSerializedProperty(pFirstByte, &m_PropertyList, 0, m_pTopLevelRule->ulCountOfElements,
                                                  (SPSERIALIZEDPHRASEPROPERTY *)(pFirstByte + pSrcPhrase->pProperties));
            }
            if (SUCCEEDED(hr) && pSrcPhrase->cReplacements)
            {
                hr = AddSerializedReplacements(pSrcPhrase);
            }
            if (SUCCEEDED(hr))
            {
                m_cpCFGEngine = cpCFGEngine;
                m_RuleHandle = RuleHandle;
            }
            if (FAILED(hr))
            {
                Reset();
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::GetText *
*------------------*
*   Description:
*
*   Returns:
*       S_OK    - *ppszCoMemText contains CoTaskMemAlloc'd string
*       S_FALSE - *ppszCoMemText is NULL, phrase contains no text
*
********************************************************************* RAL ***/


HRESULT CPhrase::GetText(ULONG ulStart, ULONG ulCount, BOOL fUseTextReplacements, 
                         WCHAR ** ppszCoMemText, BYTE * pbDisplayAttributes)
{
    SPDBG_FUNC("CPhrase::GetText");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppszCoMemText) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pbDisplayAttributes))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszCoMemText = NULL;
        if (pbDisplayAttributes)
        {
            *pbDisplayAttributes = 0;
        }
        if (m_pTopLevelRule == NULL)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            ULONG cElementsInPhrase = m_ElementList.GetCount();
            if (cElementsInPhrase && ulCount)       // If either no elements or caller asks for 0 elements, return S_FALSE.
            {
                // Get the correct start and count
                if ( SPPR_ALL_ELEMENTS == ulCount )
                {
                    if ( SPPR_ALL_ELEMENTS == ulStart )
                    {
                        ulStart = 0;
                    }
                    else
                    {
                        // Validate ulStart
                        if ( ulStart >= cElementsInPhrase )
                        {
                            return E_INVALIDARG;
                        }
                    }

                    // Go from ulStart to the end
                    ulCount = cElementsInPhrase - ulStart;
                }
                else
                {
                    // Verify that ulStart and ulCount are valid
                    if ( (ulStart < 0) || (ulStart >= cElementsInPhrase) )
                    {
                        // Bad start param
                        return E_INVALIDARG;
                    }

                    if ( (ulCount < 0) || ((ulStart + ulCount) > cElementsInPhrase) )
                    {
                        // Bad count param
                        return E_INVALIDARG;
                    }
                }

                // Allocate enough space to hold this text
                STRINGELEMENT * pStrings = STACK_ALLOC(STRINGELEMENT, ulCount);

                // Start with the first replacement which starts at ulStart or later
                // (or pReplace as NULL if no replacements apply to this element range)
                const CPhraseReplacement * pReplace = fUseTextReplacements ? m_ReplaceList.GetHead() : NULL;
                for ( ; 
                    pReplace && (pReplace->ulFirstElement < ulStart); 
                    pReplace = pReplace->m_pNext )
                    ;

                // Start with element number ulStart
                const CPhraseElement * pElement = m_ElementList.GetHead();
                for ( ULONG j=0; j < ulStart; j++ )
                {
                    if ( pElement )
                    {
                        pElement = pElement->m_pNext;
                    }
                }

                BYTE bFullTextAttrib = 0;
                ULONG i = 0;
                ULONG iElement = ulStart;
                ULONG cchTotal = 0;
                while (iElement < (ulStart + ulCount))
                {
                    BYTE bAttrib;

                    // Look for replacements that can be applied here.
                    // In order to be used, the replacement needs
                    // to be completely within the specified element range
                    if (pReplace && 
                        (pReplace->ulFirstElement == iElement) && 
                        ((pReplace->ulFirstElement + pReplace->ulCountOfElements) <= (ulStart + ulCount)) )
                    {
                        pStrings[i].psz = pReplace->pszReplacementText;
                        bAttrib = pReplace->bDisplayAttributes;
                        iElement += pReplace->ulCountOfElements;
                        for (ULONG iSkip = 0; iSkip < pReplace->ulCountOfElements; iSkip++)
                        {
                            pElement = pElement->m_pNext;
                        }
                        pReplace = pReplace->m_pNext;
                    }
                    else
                    {
                        pStrings[i].psz = pElement->pszDisplayText;
                        bAttrib = pElement->bDisplayAttributes;
                        pElement = pElement->m_pNext;
                        iElement++;
                    }
                    pStrings[i].cchString = pStrings[i].psz ? wcslen(pStrings[i].psz) : 0;
                    if (i)
                    {
                        if (bAttrib & SPAF_CONSUME_LEADING_SPACES)
                        {
                            cchTotal -= pStrings[i-1].cSpaces;
                            pStrings[i-1].cSpaces = 0;
                        }
                    }
                    else
                    {
                        bFullTextAttrib = (bAttrib & SPAF_CONSUME_LEADING_SPACES);
                    }
                    pStrings[i].cSpaces = (bAttrib & SPAF_TWO_TRAILING_SPACES) ? 2 :
                                            ((bAttrib & SPAF_ONE_TRAILING_SPACE) ? 1 : 0);
                    cchTotal += pStrings[i].cchString + pStrings[i].cSpaces;
                    i++;
                }
                ULONG cTrailingSpaces = pStrings[i-1].cSpaces;
                if (cTrailingSpaces)
                {
                    pStrings[i-1].cSpaces = 0;
                    cchTotal -= cTrailingSpaces;
                    if (cTrailingSpaces == 1)
                    {
                        bFullTextAttrib |= SPAF_ONE_TRAILING_SPACE;
                    }
                    else
                    {
                        bFullTextAttrib |= SPAF_TWO_TRAILING_SPACES;
                    }
                }
                if (cchTotal)
                {
                    WCHAR * psz = (WCHAR *)::CoTaskMemAlloc((cchTotal + 1) * sizeof(WCHAR));
                    if (psz)
                    {
                        *ppszCoMemText = psz;
                        if (pbDisplayAttributes)
                        { 
                            *pbDisplayAttributes = bFullTextAttrib;
                        }
                        for (ULONG j = 0; j < i; j++)
                        {
                            if (pStrings[j].psz)
                            {
                                memcpy(psz, pStrings[j].psz, pStrings[j].cchString * sizeof(WCHAR));
                                psz += pStrings[j].cchString;
                            }
                            while (pStrings[j].cSpaces)
                            {
                                *psz++ = L' ';
                                pStrings[j].cSpaces--;
                            }
                        }
                        *psz = 0;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = S_FALSE;   // No display text in any elements, so no string...
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CPhrase::Discard *
*------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::Discard(DWORD dwFlags)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CPhrase::Discard");
    HRESULT hr = S_OK;
    if (dwFlags & (~SPDF_ALL))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_pTopLevelRule == NULL)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            if (dwFlags & SPDF_PROPERTY)
            {
                m_PropertyList.ExplicitPurge();
                m_cchProperties = 0;
                m_cProperties = 0;
            }
            if (dwFlags & SPDF_REPLACEMENT)
            {
                m_ReplaceList.ExplicitPurge();
                m_cchReplacements = 0;
            }
            if ((dwFlags & SPDF_RULE) && m_pTopLevelRule)
            {
                m_pTopLevelRule->m_Children.ExplicitPurge();
                m_cchRules = ::TotalCCH(m_pTopLevelRule);
                m_cRules = 0;
            }
            if (dwFlags & (SPDF_DISPLAYTEXT | SPDF_LEXICALFORM | SPDF_PRONUNCIATION))
            {
                for (CPhraseElement * pElem = m_ElementList.GetHead(); pElem; pElem = pElem->m_pNext)
                {
                    m_cchElements -= pElem->Discard(dwFlags);
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CPhrase::AddElements *
*----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::AddElements(ULONG cElements, const SPPHRASEELEMENT * pElements)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CPhrase::AddElements");
    HRESULT hr = S_OK;
    if (cElements == 0 || SPIsBadReadPtr(pElements, sizeof(*pElements) * cElements))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_pTopLevelRule == NULL)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            ULONG cchTotalAdded = 0;
            CPhraseElement * pPrevElement = m_ElementList.GetTail();
            for (ULONG i = 0; i < cElements; i++)
            {
                CPhraseElement * pNewElement;
                ULONG cch;
                // Check element end not beyond end of stream for both input stream and retained stream.
                // Check previous element doesn't overlap for both input and retained streams.
                // Should always be valid for input stream.
                // For retained audio, NULL retained audio will have all zeros and hence still pass.
                if ((pElements[i].ulAudioStreamOffset + pElements[i].ulAudioSizeBytes > m_ulAudioSizeBytes) ||
                    (pPrevElement && (pPrevElement->ulAudioStreamOffset + pPrevElement->ulAudioSizeBytes > pElements[i].ulAudioStreamOffset)) ||
                    (m_ulRetainedSizeBytes != 0 && 
                     ( (pElements[i].ulRetainedStreamOffset + pElements[i].ulRetainedSizeBytes > m_ulRetainedSizeBytes) ) ||
                       (pPrevElement && (pPrevElement->ulRetainedStreamOffset + pPrevElement->ulRetainedSizeBytes > pElements[i].ulRetainedStreamOffset)) ) )
                {
                    SPDBG_ASSERT(FALSE);
                    hr = E_INVALIDARG;
                }
                else
                {
                    hr = CPhraseElement::Allocate(pElements + i, &pNewElement, &cch);
                    if (m_ulRetainedSizeBytes == 0)
                    {
                        // Force them to zero if there is no retained audio in case engine hasn't initialized them to this.
                        pNewElement->ulRetainedStreamOffset = 0;
                        pNewElement->ulRetainedSizeBytes = 0;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    m_ElementList.InsertTail(pNewElement);
                    cchTotalAdded += cch;
                }
                else
                {
                    while (i)
                    {
                        delete m_ElementList.RemoveTail();
                        i--;
                    }
                    cchTotalAdded = 0;
                    break;
                }
                pPrevElement = pNewElement;
            }
            m_cchElements += cchTotalAdded;
            m_pTopLevelRule->ulCountOfElements = m_ElementList.GetCount();
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::RecurseAddRule *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhrase::RecurseAddRule(CPhraseRule * pParent, const SPPHRASERULE * pRule, SPPHRASERULEHANDLE * phRule)
{
    SPDBG_FUNC("CPhrase::RecurseAddRule");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pRule))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ULONG cch;
        CPhraseRule * pNewRule;
        SPPHRASERULEHANDLE hNewRule = (SPPHRASERULEHANDLE)NewHandleValue();
        hr = pParent->AddChild(pRule, hNewRule, &pNewRule, &cch);
        if (SUCCEEDED(hr))
        {
            if (pRule->pNextSibling)
            {
                hr = RecurseAddRule(pParent, pRule->pNextSibling, NULL);
            }
            if (SUCCEEDED(hr) && pRule->pFirstChild)
            {
                hr = RecurseAddRule(pNewRule, pRule->pFirstChild, NULL);
            }
            if (SUCCEEDED(hr))
            {
                m_cRules++;
                m_cchRules += cch;
                if (phRule)
                {
                    *phRule = hNewRule;
                }
            }
            else
            {
                pParent->m_Children.Remove(pNewRule);
                delete pNewRule;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CPhrase::AddRules *
*-------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::AddRules(const SPPHRASERULEHANDLE hParent, const SPPHRASERULE * pRule, SPPHRASERULEHANDLE * phRule)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CPhrase::AddRule");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(phRule))
    {
        hr = E_POINTER;
    }
    else
    {
        if (phRule)
        {
            *phRule = NULL;     // In case of failure...
        }
        if (m_pTopLevelRule == NULL)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            CPhraseRule * pParent = m_pTopLevelRule->FindRuleFromHandle(hParent);
            if (pParent == NULL)
            {
                hr = SPERR_INVALID_HANDLE;
            }
            else
            {
                hr = RecurseAddRule(pParent, pRule, phRule);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::RecurseAddProperties *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CPhrase::RecurseAddProperty(CPropertyList * pParentPropList,
                                    ULONG ulParentFirstElement, 
                                    ULONG ulParentCountOfElements,
                                    const SPPHRASEPROPERTY * pProperty,
                                    SPPHRASEPROPERTYHANDLE * phProp)
{
    SPDBG_FUNC("CPhrase::RecurseAddProperties");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pProperty) ||
        (pProperty->ulCountOfElements && (pProperty->ulFirstElement < ulParentFirstElement ||
                                          pProperty->ulFirstElement + pProperty->ulCountOfElements > ulParentFirstElement + ulParentCountOfElements)))
        //(pProperty->ulCountOfElements == 0 && (pProperty->ulFirstElement != 0 || pProperty->pFirstChild)))) -- can't require this because of epsilon transitions -- PhilSch
    {
        SPDBG_ASSERT(FALSE);
        hr = E_INVALIDARG;
    }
    else
    {
        if (pProperty->ulCountOfElements)
        {
            ULONG ulLastElement = pProperty->ulFirstElement + pProperty->ulCountOfElements;
            for (CPhraseProperty * pSibling = pParentPropList->GetHead();
                 SUCCEEDED(hr) && pSibling && pSibling->ulFirstElement < ulLastElement;
                 pSibling = pSibling->m_pNext)
            {
                if (pSibling->ulFirstElement + pSibling->ulCountOfElements > pProperty->ulFirstElement)
                {
                    SPDBG_ASSERT(FALSE);
                    hr = E_INVALIDARG;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CPhraseProperty * pNewProp;
            SPPHRASEPROPERTYHANDLE hNewProp = (SPPHRASEPROPERTYHANDLE)NewHandleValue();
            ULONG cch;
            hr = CPhraseProperty::Allocate(pProperty, hNewProp, &pNewProp, &cch);
            if (SUCCEEDED(hr))
            {
                pParentPropList->InsertSorted(pNewProp);
                if (pProperty->pNextSibling)
                {
                    hr = RecurseAddProperty(pParentPropList, ulParentFirstElement, ulParentCountOfElements,
                                            pProperty->pNextSibling, NULL);
                }
                if (SUCCEEDED(hr) && pProperty->pFirstChild)
                {
                    hr = RecurseAddProperty(&pNewProp->m_Children, pNewProp->ulFirstElement, pNewProp->ulCountOfElements,
                                            pProperty->pFirstChild, NULL);
                }
                if (SUCCEEDED(hr))
                {
                    m_cProperties++;
                    m_cchProperties += cch;
                    if (phProp)
                    {
                        *phProp = hNewProp;
                    }
                }
                else
                {
                    pParentPropList->Remove(pNewProp);
                    delete pNewProp;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::FindPropHandleParentList *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CPhraseProperty * CPhrase::FindPropertyFromHandle(CPropertyList & List, const SPPHRASEPROPERTYHANDLE hParent)
{
    SPDBG_FUNC("CPhrase::FindPropHandleParentList");
    CPhraseProperty * pFound = NULL;
    for (CPhraseProperty * pProp = List.GetHead(); pProp && pFound == NULL; pProp = pProp->m_pNext)
    {
        if (pProp->m_hProperty == hParent)
        {
            pFound = pProp;
        }
        else
        {
            pFound = FindPropertyFromHandle(pProp->m_Children, hParent);
        }
    }
    return pFound;
}


/****************************************************************************
* CPhrase::AddProperties *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::AddProperties(const SPPHRASEPROPERTYHANDLE hParent, const SPPHRASEPROPERTY * pProperty, SPPHRASEPROPERTYHANDLE * phNewProp)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CPhrase::AddProperties");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(phNewProp))
    {
        hr = E_POINTER;
    }
    else
    {
        if (SP_IS_BAD_READ_PTR(pProperty))
        {
            hr = E_INVALIDARG;
        }
        if (SUCCEEDED(hr))
        {
            if (phNewProp)
            {
                *phNewProp = NULL;     // In case of failure...
            }
            if (m_pTopLevelRule == NULL)
            {
                hr = SPERR_UNINITIALIZED;
            }
            else
            {
                if (hParent)
                {
                    CPhraseProperty * pParent = FindPropertyFromHandle(m_PropertyList, hParent);
                    if (pParent)
                    {
                        if (SP_IS_BAD_READ_PTR(pProperty))
                        {
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            if (pProperty->pszName == NULL && pProperty->ulId == 0) // Indicates a property update
                            {
                                if (pParent->pszValue || pParent->vValue.vt != VT_EMPTY)
                                {
                                    hr = SPERR_ALREADY_INITIALIZED;
                                }
                                else
                                {
                                    hr = ValidateSemanticVariantType(pProperty->vValue.vt);
                                    if (SUCCEEDED(hr))
                                    {
                                        ULONG cchAdded;
                                        hr = pParent->SetValueString(pProperty->pszValue, &cchAdded);
                                        if (SUCCEEDED(hr))
                                        {
                                            pParent->vValue = pProperty->vValue;
                                            m_cchProperties += cchAdded;
                                        }
                                    }
                                }
                            }
                            else    // Normal add to a parent
                            {
                                hr = RecurseAddProperty(&pParent->m_Children, pParent->ulFirstElement, pParent->ulCountOfElements, pProperty, phNewProp);
                            }
                        }
                    }
                    else
                    {
                        hr = SPERR_INVALID_HANDLE;
                    }
                }
                else
                {
                    hr = RecurseAddProperty(&m_PropertyList, 0, m_pTopLevelRule->ulCountOfElements, pProperty, phNewProp);
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::AddReplacements *
*--------------------------*
*   Description:
*       Adds one or more text replacements to the phrase.  The object must have
*   been initialized by calling SetPhrase prior to calling this method or else
*   it will return SPERR_UNINITIALIZED.
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::AddReplacements(ULONG cReplacements, const SPPHRASEREPLACEMENT * pReplace)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CPhrase::AddReplacements");
    HRESULT hr = S_OK;

    if (cReplacements == 0 || SPIsBadReadPtr(pReplace, sizeof(*pReplace) * cReplacements))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_pTopLevelRule == NULL)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else
        {
            ULONG cchTotalAdded = 0;
            CPhraseReplacement ** pAllocThisCall = STACK_ALLOC(CPhraseReplacement *, cReplacements);
            for (ULONG i = 0; i < cReplacements; i++)
            {
                ULONG ulLastElement = pReplace[i].ulFirstElement + pReplace[i].ulCountOfElements;
                if (pReplace[i].ulCountOfElements == 0 || ulLastElement > m_ElementList.GetCount())
                {
                    hr = E_INVALIDARG;
                }
                for (CPhraseReplacement * pSibling = m_ReplaceList.GetHead();
                     SUCCEEDED(hr) && pSibling && pSibling->ulFirstElement < ulLastElement;
                     pSibling = pSibling->m_pNext)
                {
                    if (pSibling->ulFirstElement + pSibling->ulCountOfElements > pReplace[i].ulFirstElement)
                    {
                        hr = E_INVALIDARG;
                    }
                }
                CPhraseReplacement * pNewReplace;
                ULONG cch;
                if (SUCCEEDED(hr))
                {
                    hr = CPhraseReplacement::Allocate(pReplace + i, &pNewReplace, &cch);
                }
                if (SUCCEEDED(hr))
                {
                    pAllocThisCall[i] = pNewReplace;
                    m_ReplaceList.InsertSorted(pNewReplace);
                    cchTotalAdded += cch;
                }
                else
                {
                    for (ULONG j = 0; j < i; j++)
                    {
                        m_ReplaceList.Remove(pAllocThisCall[j]);
                        delete pAllocThisCall[j];
                    }
                    cchTotalAdded = 0;
                    break;
                }
            }
            m_cchReplacements += cchTotalAdded;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

//
//  _ISpCFGPhraseBuilder
//

/****************************************************************************
* CPhrase::InitFromCFG *
*----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::InitFromCFG(ISpCFGEngine * pEngine, const SPPARSEINFO * pParseInfo)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CPhrase::InitFromCFG");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pEngine))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        SPPHRASE Phrase;
        memset(&Phrase, 0, sizeof(Phrase));
        Phrase.cbSize = sizeof(Phrase);
        WCHAR * pszRuleName;
        hr = pEngine->GetRuleDescription(pParseInfo->hRule, &pszRuleName, &Phrase.Rule.ulId, &Phrase.LangID);
        if (SUCCEEDED(hr))
        {
            Phrase.Rule.pszName = pszRuleName;
            Phrase.Rule.Confidence = SP_NORMAL_CONFIDENCE; // This gets overwritten later
            Phrase.Rule.SREngineConfidence = -1.0f;
            Phrase.ullAudioStreamPosition = pParseInfo->ullAudioStreamPosition;
            Phrase.ulAudioSizeBytes = pParseInfo->ulAudioSize;
            Phrase.ulRetainedSizeBytes = 0;
            Phrase.SREngineID = pParseInfo->SREngineID;
            Phrase.ulSREnginePrivateDataSize = pParseInfo->ulSREnginePrivateDataSize;
            Phrase.pSREnginePrivateData = pParseInfo->pSREnginePrivateData;

            hr = InitFromPhrase(&Phrase);
            ::CoTaskMemFree(pszRuleName);
            if (SUCCEEDED(hr))
            {
                m_cpCFGEngine = pEngine;
                m_RuleHandle = pParseInfo->hRule;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::GetCFGInfo *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::GetCFGInfo(ISpCFGEngine ** ppEngine, SPRULEHANDLE * phRule)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CPhrase::GetCFGInfo");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(ppEngine) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(phRule))
    {
        hr = E_POINTER;
    }
    else
    {
        if (ppEngine)
        {
            *ppEngine = m_cpCFGEngine;
            if (*ppEngine)
            {
                (*ppEngine)->AddRef();
            }
        }
        if (phRule)
        {
            *phRule = m_RuleHandle;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CPhrase::SetTopLevelRuleConfidence *
*------------------------------------*
*   Description:
*       Simple function that overrides this value in the phrase.
*       Needed because top level rule is not directly accessible through the normal,
*       ISpPhrase interface.
*
*   Returns:
*
****************************************************************** davewood ***/

STDMETHODIMP CPhrase::SetTopLevelRuleConfidence(signed char Confidence)
{
    HRESULT hr = S_OK;
    if (m_pTopLevelRule == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else
    {
        m_pTopLevelRule->Confidence = Confidence;
    }
    return hr;
}

/****************************************************************************
* CPhrase::ReleaseCFGInfo *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CPhrase::ReleaseCFGInfo()
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CPhrase::ReleaseCFGInfo");
    HRESULT hr = S_OK;

    m_cpCFGEngine.Release();
    m_RuleHandle = NULL;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spobjectref.h ===
// SpObjectRef.h

#ifndef __SPOBJECTREF_H_
#define __SPOBJECTREF_H_

/////////////////////////////////////////////////////////////////////////////
// CSpCallParams
class CSpCallParams : public SPCALLPARAMS
{
public:
    CSpCallParams( DWORD dwMethodIdx,
                DWORD dwFlagsx,
                void * pCallFrame0, 
                ULONG ulCallFrameSize0, 
                void * pCallFrame1 = NULL,
                ULONG ulCallFrameSize1 = 0 )
    {
        dwMethodId = dwMethodIdx;
        dwFlags = dwFlagsx;
        ulParamBlocks = pCallFrame1 ? 2 : 1;
        paramlist[0].pParamData = pCallFrame0;
        paramlist[0].cbParamData = ulCallFrameSize0;
        paramlist[1].pParamData = pCallFrame1;
        paramlist[1].cbParamData = pCallFrame1 ? ulCallFrameSize1 : 0;
    }
};
                                
/////////////////////////////////////////////////////////////////////////////
// CSpObjectRef
class CSpObjectRef : public ISpObjectRef
{
private:
    ULONG m_cRef;
    CComPtr<ISpServer> m_cpServer;
    PVOID m_pObjPtr;

public:
	CSpObjectRef()
	{
        m_cRef = 1;
        m_pObjPtr = NULL;
	}
	CSpObjectRef(ISpServer *pServer, PVOID pObjPtr)
	{
        m_cRef = 1;
        m_pObjPtr = pObjPtr;
        m_cpServer = pServer;
	}

    HRESULT LinkInstance(ISpServer *pServer, PVOID pRefObj)
    {
        m_cpServer = pServer;
        m_pObjPtr = pRefObj;
        return S_OK;
    }

// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
    {
        if (riid == IID_ISpObjectRef || riid == IID_IUnknown) {
            *ppvObj = (ISpObjectRef*)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    virtual STDMETHODIMP_(ULONG) AddRef(void)
    {
        return ++m_cRef;
    }
    virtual STDMETHODIMP_(ULONG) Release(void);

// ISpObjectRef methods
    STDMETHODIMP Call(const SPCALLPARAMS *params)
    {
        return m_cpServer->CallObject(m_pObjPtr, params);
    }
};

// Helper function for making SpObjectRef calls


#endif //__SPOBJECTREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spphrase.h ===
/******************************************************************************
* SpPhrase.h *
*---------------*
*  This is the header file for the CSpPhrase implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** EDC ***/
#ifndef SpPhrase_h
#define SpPhrase_h

#ifndef _WIN32_WCE
#include <new.h>
#endif

class CPhrase;
class CPhraseElement;
class CPhraseRule;
class CPhraseProperty;
class CPhraseReplacement;

//
//  List type definitions
//
typedef CSpBasicQueue<CPhraseElement, TRUE, TRUE>       CElementList;
typedef CSpBasicQueue<CPhraseReplacement, TRUE, TRUE>   CReplaceList;
typedef CSpBasicQueue<CPhraseRule, TRUE, TRUE>          CRuleList;
typedef CSpBasicQueue<CPhraseProperty, TRUE, TRUE>      CPropertyList;



#pragma warning(disable : 4200)




class CPhraseElement : public SPPHRASEELEMENT
{
public:
    CPhraseElement *m_pNext;
    WCHAR           m_szText[0];

private:
    CPhraseElement(const SPPHRASEELEMENT * pElement);

public:
    static HRESULT Allocate(const SPPHRASEELEMENT * pElement, CPhraseElement ** ppNewElement, ULONG * pcch);
    void CopyTo(SPPHRASEELEMENT * pElement, WCHAR ** ppTextBuff, const BYTE * pIgnored) const;
    void CopyTo(SPSERIALIZEDPHRASEELEMENT * pElement, WCHAR ** ppTextBuff, const BYTE * pIgnored) const;
    ULONG Discard(DWORD dwDiscardFlags);
};


class CPhraseRule : public SPPHRASERULE
{
public:
    CPhraseRule   * m_pNext;
    CRuleList       m_Children;
    const SPPHRASERULEHANDLE  m_hRule;
    WCHAR           m_szText[0];

private:
    CPhraseRule(const SPPHRASERULE * pVal, const SPPHRASERULEHANDLE hRule);

public:
    static HRESULT Allocate(const SPPHRASERULE * pRule, const SPPHRASERULEHANDLE hRule, CPhraseRule ** ppNewRule, ULONG * pcch);
    void CopyTo(SPPHRASERULE * pRule, WCHAR ** ppTextBuff, const BYTE * pIgnored) const;
    void CopyTo(SPSERIALIZEDPHRASERULE * pRule, WCHAR ** ppText, const BYTE * pCoMem) const;
    static LONG Compare(const CPhraseRule * pElem1, const CPhraseRule * pElem2)
    {
        return(static_cast<LONG>(pElem1->ulFirstElement) - static_cast<LONG>(pElem2->ulFirstElement));
    }
    CPhraseRule * FindRuleFromHandle(const SPPHRASERULEHANDLE hRule);
    HRESULT AddChild(const SPPHRASERULE * pRule, SPPHRASERULEHANDLE hNewRule, CPhraseRule ** ppNewRule, ULONG * pcch);
};


//
//  NOTE ABOUT CPhraseProperty -- The pszValueString is in a seperate allocated buffer
//  from the rest of the structure.  This allows us to change the value string from empty
//  to non-empty through AddProperties.  This is different from all of the other data
//  structures, which store ALL of their string data in m_szText;
//
class CPhraseProperty : public SPPHRASEPROPERTY
{
public:
    CPhraseProperty   * m_pNext;
    CPropertyList       m_Children;
    const SPPHRASEPROPERTYHANDLE  m_hProperty;
    WCHAR           m_szText[0];

private:
    CPhraseProperty(const SPPHRASEPROPERTY * pProp, const SPPHRASEPROPERTYHANDLE hProperty, HRESULT * phr);
public:
    ~CPhraseProperty()
    {
        delete[] const_cast<WCHAR *>(pszValue);
    }
    static HRESULT Allocate(const SPPHRASEPROPERTY * pProperty, const SPPHRASEPROPERTYHANDLE hProperty, CPhraseProperty ** ppNewProperty, ULONG * pcch);
    void CopyTo(SPPHRASEPROPERTY * pProperty, WCHAR ** ppTextBuff, const BYTE * pIgnored) const;
    void CopyTo(SPSERIALIZEDPHRASEPROPERTY * pProp, WCHAR ** ppTextBuff, const BYTE * pCoMem) const;
    HRESULT SetValueString(const WCHAR * pszNewValue, ULONG * pcch)
    {
        SPDBG_ASSERT(pszValue == NULL);
        *pcch = wcslen(pszNewValue) + 1;
        pszValue = new WCHAR[*pcch];
        if (pszValue)
        {
            memcpy(const_cast<WCHAR *>(pszValue), pszNewValue, (*pcch) * sizeof(WCHAR));
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    static LONG Compare(const CPhraseProperty * pElem1, const CPhraseProperty * pElem2)
    {
        if (pElem1->ulFirstElement == pElem2->ulFirstElement)
        {
            return(static_cast<LONG>(pElem1->ulCountOfElements) - static_cast<LONG>(pElem2->ulCountOfElements));
        }
        return(static_cast<LONG>(pElem1->ulFirstElement) - static_cast<LONG>(pElem2->ulFirstElement));
    }
};


class CPhraseReplacement : public SPPHRASEREPLACEMENT
{
public:
    CPhraseReplacement  *   m_pNext;
    WCHAR                   m_szText[0];

private:
    CPhraseReplacement(const SPPHRASEREPLACEMENT * pReplace);

public:
    static HRESULT Allocate(const SPPHRASEREPLACEMENT * pReplace, CPhraseReplacement ** ppNewReplace, ULONG * pcch);
    void CopyTo(SPPHRASEREPLACEMENT * pReplace, WCHAR ** ppTextBuff, const BYTE * pIgnored) const;
    void CopyTo(SPSERIALIZEDPHRASEREPLACEMENT * pReplace, WCHAR ** ppTextBuff, const BYTE * pCoMem) const;
    static LONG Compare(const CPhraseReplacement * pElem1, const CPhraseReplacement * pElem2)
    {
        return(static_cast<LONG>(pElem1->ulFirstElement) - static_cast<LONG>(pElem2->ulFirstElement));
    }

};

#pragma warning(default : 4200)

class ATL_NO_VTABLE CPhrase :
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<CPhrase, &CLSID_SpPhraseBuilder>,
    public _ISpCFGPhraseBuilder
{
public:
DECLARE_REGISTRY_RESOURCEID(IDR_SPPHRASE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPhrase)
        COM_INTERFACE_ENTRY(ISpPhraseBuilder)
    COM_INTERFACE_ENTRY(_ISpCFGPhraseBuilder)
        COM_INTERFACE_ENTRY(ISpPhrase)
END_COM_MAP()

// Non-interface methods
public:
    CPhrase();
    ~CPhrase();

    inline DWORD_PTR NewHandleValue()
    {
        DWORD_PTR h = m_ulNextHandleValue;
        m_ulNextHandleValue += 2;   // Always inc by an even number so that we never get to zero
                                    // in the unlikely event we happen to roll over
        return h;
    }

    inline ULONG TotalCCH() const;

    void Reset();
    HRESULT RecurseAddRule(CPhraseRule * pParent, const SPPHRASERULE * pRule, SPPHRASERULEHANDLE * phRule);
    CPhraseProperty * FindPropertyFromHandle(CPropertyList & List, const SPPHRASEPROPERTYHANDLE hParent);
    HRESULT RecurseAddProperty(CPropertyList * pParentPropList, ULONG ulFirstElement, ULONG ulCountOfElements, const SPPHRASEPROPERTY * pProp, SPPHRASEPROPERTYHANDLE * phProp);

    HRESULT AddSerializedElements(const SPINTERNALSERIALIZEDPHRASE * pPhrase);
    HRESULT RecurseAddSerializedRule(const BYTE * pFirstByte,
                                     CPhraseRule * pParent,
                                     const SPSERIALIZEDPHRASERULE * pSerRule);
    HRESULT RecurseAddSerializedProperty(const BYTE * pFirstByte,
                                         CPropertyList * pParentPropList,
                                         ULONG ulParentFirstElement, 
                                         ULONG ulParentCountOfElements,
                                         const SPSERIALIZEDPHRASEPROPERTY * pSerProp);
    HRESULT AddSerializedReplacements(const SPINTERNALSERIALIZEDPHRASE * pPhrase);


    //
    //  ISpPhrase
    //
    STDMETHODIMP GetPhrase(SPPHRASE ** ppPhrase);
    STDMETHODIMP GetSerializedPhrase(SPSERIALIZEDPHRASE ** ppPhrase);
    STDMETHODIMP GetText(ULONG ulStart, ULONG ulCount, BOOL fUseTextReplacements, 
                            WCHAR ** ppszCoMemText, BYTE * pdwDisplayAttributes);
    STDMETHODIMP Discard(DWORD dwValueTypes);
    //
    //  ISpPhraseBuilder
    //
    STDMETHODIMP InitFromPhrase(const SPPHRASE * pPhrase);
    STDMETHODIMP InitFromSerializedPhrase(const SPSERIALIZEDPHRASE * pPhrase);
    STDMETHODIMP AddElements(ULONG cElements, const SPPHRASEELEMENT *pElement);
    STDMETHODIMP AddRules(const SPPHRASERULEHANDLE hParent, const SPPHRASERULE * pRule, SPPHRASERULEHANDLE * phNewRule);
    STDMETHODIMP AddProperties(const SPPHRASEPROPERTYHANDLE hParent, const SPPHRASEPROPERTY * pProperty, SPPHRASEPROPERTYHANDLE * phNewProperty);
    STDMETHODIMP AddReplacements(ULONG cReplacements, const SPPHRASEREPLACEMENT * pReplacement);

    //
    // _ISpCFGPhraseBuilder
    //
    STDMETHODIMP InitFromCFG(ISpCFGEngine * pEngine, const SPPARSEINFO * pParseInfo);
    STDMETHODIMP GetCFGInfo(ISpCFGEngine ** ppEngine, SPRULEHANDLE * phRule);
    STDMETHODIMP SetCFGInfo(ISpCFGEngine * pEngine, SPRULEHANDLE hRule) 
    { 
        m_cpCFGEngine = pEngine;
        m_RuleHandle = hRule;
        return S_OK; 
    }
    STDMETHODIMP ReleaseCFGInfo();
    STDMETHODIMP SetTopLevelRuleConfidence(signed char Confidence);

private:
    //
    //  This structure is only used by the GetText method.
    //
    struct STRINGELEMENT
    {
        ULONG           cchString;
        const WCHAR *   psz;
        ULONG           cSpaces;
    };


public:
    LANGID                  m_LangID;
    ULONGLONG               m_ullGrammarID;
    ULONGLONG               m_ftStartTime;
    ULONGLONG               m_ullAudioStreamPosition;
    ULONG                   m_ulAudioSizeBytes;
    ULONG                   m_ulRetainedSizeBytes;
    ULONG                   m_ulAudioSizeTime;
    CPhraseRule *           m_pTopLevelRule;
    CElementList            m_ElementList;
    CReplaceList            m_ReplaceList;
    CPropertyList           m_PropertyList;

    DWORD_PTR                   m_ulNextHandleValue;
    SPRULEHANDLE            m_RuleHandle;
    CComPtr<ISpCFGEngine>   m_cpCFGEngine;

    GUID                    m_SREngineID;
    ULONG                   m_ulSREnginePrivateDataSize;
    BYTE                  * m_pSREnginePrivateData;

    //
    //  Counters used to keep track of memory requirements.  Note that there is no m_cElements
    //  or m_cReplacements since the lists keep track of the counts of these, but for items
    //  in a tree structure, such as properties and rules, we keep track of them independently
    //
    ULONG                   m_cRules;
    ULONG                   m_cProperties;
    ULONG                   m_cchElements;
    ULONG                   m_cchRules;
    ULONG                   m_cchProperties;
    ULONG                   m_cchReplacements;
};


//
// --- Inline functions
//


/****************************************************************************
* CopyString *
*------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void inline CopyString(const WCHAR ** ppsz, WCHAR ** ppszDestBuffer)
{
    SPDBG_FUNC("CopyString");
    const WCHAR * pszSrc = *ppsz;
    if (pszSrc)
    {
        *ppsz = *ppszDestBuffer;
        WCHAR * pszDest = *ppszDestBuffer;
        WCHAR c;
        do
        {
            c = *pszSrc++;
            *pszDest++ = c;
        } while (c);
        *ppszDestBuffer = pszDest;
    }
}

/****************************************************************************
* SerializeString *
*-----------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline void SerializeString(SPRELATIVEPTR * pPtrDest, const WCHAR * pszSrc, WCHAR ** ppszDestBuffer, const BYTE * pCoMem)
{
    SPDBG_FUNC("SerializeString");
    if (pszSrc)
    {
        *pPtrDest = (SPRELATIVEPTR)(((BYTE *)(*ppszDestBuffer)) - pCoMem);
        WCHAR * pszDest = *ppszDestBuffer;
        WCHAR c;
        do
        {
            c = *pszSrc++;
            *pszDest++ = c;
        } while (c);
        *ppszDestBuffer = pszDest;
    }
    else
    { 
        *pPtrDest = 0;
    }
}

/****************************************************************************
* TotalCCH *
*----------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline ULONG TotalCCH(const WCHAR * psz)
{
    if (psz)
    {
        for (const WCHAR * pszTest = psz; *pszTest; pszTest++)
        {}
        return ULONG(pszTest - psz) + 1; // Include the null
    }
    else
    {
        return 0;
    }
}

/****************************************************************************
* TotalCCH *
*----------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline ULONG TotalCCH(const SPPHRASEELEMENT * pElem)
{
    ULONG cch = TotalCCH(pElem->pszDisplayText) + TotalCCH(pElem->pszPronunciation);
    if (pElem->pszDisplayText != pElem->pszLexicalForm)
    {
        cch += TotalCCH(pElem->pszLexicalForm);
    }
    return cch;
}

/****************************************************************************
* TotalCCH *
*----------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline ULONG TotalCCH(const SPPHRASERULE * pRule)
{
    return TotalCCH(pRule->pszName);
}

/****************************************************************************
* TotalCCH *
*----------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline ULONG TotalCCH(const SPPHRASEPROPERTY * pProp)
{
    return TotalCCH(pProp->pszName) + TotalCCH(pProp->pszValue);
}

/****************************************************************************
* TotalCCH *
*----------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline ULONG TotalCCH(const SPPHRASEREPLACEMENT * pReplacement)
{
    return TotalCCH(pReplacement->pszReplacementText);
}

/****************************************************************************
* TotalCCH *
*----------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline ULONG CPhrase::TotalCCH() const
{
    return m_cchElements + m_cchRules + m_cchProperties + m_cchReplacements;
}

/****************************************************************************
* OffsetToString *
*----------------*
*   Description:
*       Helper returns a const WCHAR pointer for a specified offset in a buffer.
*   If the offset is 0 then a NULL pointer is returned.
*
*   Returns:
*       Either NULL or pointer to a WCHAR Offset bytes into the buffer
*
********************************************************************* RAL ***/

inline const WCHAR * OffsetToString(const BYTE * pFirstByte, SPRELATIVEPTR Offset)
{
    return Offset ? (const WCHAR *)(pFirstByte + Offset) : NULL;
}


//
//  Template functions used for performing copy operations
//
/****************************************************************************
* CopyEnginePrivateData *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline void CopyEnginePrivateData(const BYTE ** ppDest, BYTE * pDestBuffer, const BYTE *pEngineData, const ULONG ulSize, const BYTE *)
{
    if (ulSize)
    {
        *ppDest = pDestBuffer;
        memcpy(pDestBuffer, pEngineData, ulSize);
    }
    else
    {
        *ppDest = NULL;
    }
}


/****************************************************************************
* CopyEnginePrivateData *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline void CopyEnginePrivateData(SPRELATIVEPTR * ppDest, BYTE * pDestBuffer, const BYTE *pEngineData, const ULONG ulSize, const BYTE * pCoMemBegin)
{
    if (ulSize)
    {
        *ppDest = SPRELATIVEPTR(pDestBuffer - pCoMemBegin);
        memcpy(pDestBuffer, pEngineData, ulSize);
    }
    else
    {
        *ppDest = 0;
    }
}



/****************************************************************************
* CopyTo *
*--------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

template <class T, class TDestStruct>
void CopyTo(const CSpBasicQueue<T, TRUE, TRUE> & List, const TDestStruct ** ppFirstDest, BYTE ** ppStructBuff, WCHAR ** ppTextBuff, const BYTE *)
{
    if (List.IsEmpty())
    {
        *ppFirstDest = NULL;
    }
    else
    {
        TDestStruct * pDest = (TDestStruct *)(*ppStructBuff);
        *ppFirstDest = pDest;
        for (T * pItem = List.GetHead(); pItem; pItem = pItem->m_pNext, pDest++)
        {
            pItem->CopyTo(pDest, ppTextBuff, NULL);
        }
        *ppStructBuff = (BYTE *)pDest;
    }
}

/****************************************************************************
* CopyTo *
*--------*
*   Description:
*
*   Returns:
*       Nothing
*
********************************************************************* RAL ***/

template <class T, class TDestStruct>
void CopyTo(const CSpBasicQueue<T, TRUE, TRUE> & List, SPRELATIVEPTR * ppFirstDest, BYTE ** ppStructBuff, WCHAR ** ppTextBuff, const BYTE * pCoMemBegin)
{
    if (List.IsEmpty())
    {
        *ppFirstDest = 0;
    }
    else
    {
        TDestStruct * pDest = (TDestStruct *)(*ppStructBuff);
        *ppFirstDest = SPRELATIVEPTR((*ppStructBuff) - pCoMemBegin);
        for (T * pItem = List.GetHead(); pItem; pItem = pItem->m_pNext, pDest++)
        {
            pItem->CopyTo(pDest, ppTextBuff, pCoMemBegin);
        }
        *ppStructBuff = (BYTE *)pDest;
    }
}

/****************************************************************************
* CopyToRecurse *
*---------------*
*   Description:
*
*   Returns:
*       Nothing
*
********************************************************************* RAL ***/

template <class T, class TDestStruct>
void CopyToRecurse(const CSpBasicQueue<T, TRUE, TRUE> & List, const TDestStruct ** ppFirstDest, BYTE ** ppStructBuff, WCHAR ** ppTextBuff, const BYTE *)
{
    if (List.IsEmpty())
    {
        *ppFirstDest = NULL;
    }
    else
    {
        TDestStruct * pFirst = (TDestStruct *)(*ppStructBuff);
        TDestStruct * pDest = pFirst;
        *ppFirstDest = pDest;
        for (T * pCopy = List.GetHead(); pCopy; pCopy = pCopy->m_pNext, pDest++)
        {
            pCopy->CopyTo(pDest, ppTextBuff, NULL);
            pDest->pNextSibling = pCopy->m_pNext ? (pDest + 1) : NULL;
        }
        *ppStructBuff = (BYTE *)pDest;
        pDest = pFirst;
        for (pCopy = List.GetHead(); pCopy; pCopy = pCopy->m_pNext, pDest++)
        {
            CopyToRecurse(pCopy->m_Children, &pDest->pFirstChild, ppStructBuff, ppTextBuff, NULL);
        }
    }
}

/****************************************************************************
* CopyToRecurse *
*---------------*
*   Description:
*
*   Returns:
*       Nothing
*
********************************************************************* RAL ***/

template <class T, class TDestStruct>
void CopyToRecurse(const CSpBasicQueue<T, TRUE, TRUE> & List, SPRELATIVEPTR * ppFirstDest, BYTE ** ppStructBuff, WCHAR ** ppTextBuff, const BYTE * pCoMemBegin)
{
    if (List.IsEmpty())
    {
        *ppFirstDest = 0;
    }
    else
    {
        TDestStruct * pDest = (TDestStruct *)(*ppStructBuff);
        TDestStruct * pFirst = pDest;
        *ppFirstDest = SPRELATIVEPTR((*ppStructBuff) - pCoMemBegin);
        for (T * pCopy = List.GetHead(); pCopy; pCopy = pCopy->m_pNext, pDest++)
        {
            pCopy->CopyTo(pDest, ppTextBuff, pCoMemBegin);
            pDest->pNextSibling = (SPRELATIVEPTR)(pCopy->m_pNext ? (((BYTE *)(pDest + 1)) - pCoMemBegin) : 0);
        }
        *ppStructBuff = (BYTE *)pDest;
        pDest = pFirst;
        for (pCopy = List.GetHead(); pCopy; pCopy = pCopy->m_pNext, pDest++)
        {
            CopyToRecurse<T, TDestStruct>(pCopy->m_Children, &pDest->pFirstChild, ppStructBuff, ppTextBuff, pCoMemBegin);
        }
    }
}



    
#endif  // ifdef SPPHRASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spphrasealt.h ===
/*******************************************************************************
* SpPhraseAlt.h *
*---------------*
*   Description:
*       This is the header file for the CSpAlternate implementation.
*-------------------------------------------------------------------------------
*  Created By: robch                          Date: 01/11/00
*  Copyright (C) 1998, 1999, 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

class ATL_NO_VTABLE CSpResult;

/****************************************************************************
* class CSpPhraseAlt *
******************************************************************** robch */
class ATL_NO_VTABLE CSpPhraseAlt :
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpPhraseAlt,
    //--- Automation
    public IDispatchImpl<ISpeechPhraseAlternate, &IID_ISpeechPhraseAlternate, &LIBID_SpeechLib, 5>
{
/*=== ATL Setup ===*/
public:

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpPhraseAlt)
        COM_INTERFACE_ENTRY(ISpPhraseAlt)
        COM_INTERFACE_ENTRY(ISpeechPhraseAlternate)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:

    /*--- Constructors/Destructors ---*/
    CSpPhraseAlt();
    
    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Regular methods ---*/
    HRESULT Init(CSpResult * pResult, ISpPhrase * pPhraseParent, SPPHRASEALT * pAlt);
    void Dead();

  /*=== Interfaces ====*/
  public:

    //--- ISpeechPhraseAlternate -------------------------------------------------
    STDMETHOD(get_RecoResult)( ISpeechRecoResult** ppRecoResult );
    STDMETHOD(get_StartElementInResult)( long* pParentStartElt );
    STDMETHOD(get_NumberOfElementsInResult)( long* pNumParentElts );
    //STDMETHOD(Commit)( void ); // Implemented by non-Automation version.
    // ** From ISpeechPhrase **
    STDMETHOD(get_PhraseInfo)( ISpeechPhraseInfo** ppPhraseInfo );

    //--- ISpPhrase -------------------------------------------------
    STDMETHOD(GetPhrase)(SPPHRASE ** ppCoMemPhrase);
    STDMETHOD(GetSerializedPhrase)(SPSERIALIZEDPHRASE ** ppCoMemPhrase);
    STDMETHOD(GetText)(ULONG ulStart, ULONG ulCount, BOOL fUseTextReplacements, 
                        WCHAR ** ppszCoMemText, BYTE * pbDisplayAttributes);
    STDMETHOD(Discard)(DWORD dwValueTypes);

    //--- ISpPhraseAlt ----------------------------------------------
    STDMETHOD(GetAltInfo)(ISpPhrase **ppParent, 
                    ULONG *pulStartElementInParent, ULONG *pcElementsInParent, 
                    ULONG *pcElementsInAlt);
    STDMETHOD(Commit)();

  /*=== Data ===*/
  public:
    SPPHRASEALT *   m_pAlt;
    VARIANT_BOOL    m_fUseTextReplacements;


  private:
    CSpResult *     m_pResultWEAK;
    ISpPhrase *     m_pPhraseParentWEAK;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spphrasealt.cpp ===
/*******************************************************************************
* SpPhraseAlt.cpp *
*-----------------*
*   Description:
*       This is the source file file for the CSpAlternate implementation.
*-------------------------------------------------------------------------------
*  Created By: robch                          Date: 01/11/00
*  Copyright (C) 1998, 1999, 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#include "stdafx.h"
#include "Sapi.h"
#include "recoctxt.h"
#include "SpResult.h"
#include "SpPhraseAlt.h"

/****************************************************************************
* CSpPhraseAlt::CSpPhraseAlt *
*----------------------------*
*   Description:  
*       Ctor
******************************************************************** robch */
CSpPhraseAlt::CSpPhraseAlt() : 
m_pResultWEAK(NULL),
m_pPhraseParentWEAK(NULL),
m_pAlt(NULL)
{
    SPDBG_FUNC("CSpPhraseAlt::CSpPhraseAlt");
}

/****************************************************************************
* CSpPhraseAlt::FinalConstruct *
*------------------------------*
*   Description:  
*       Final ATL ctor
*
*   Return:
*   <>
******************************************************************** robch */
HRESULT CSpPhraseAlt::FinalConstruct()
{
    SPDBG_FUNC("CSpPhraseAlt::FinalConstruct");
    return S_OK;
}

/****************************************************************************
* CSpPhraseAlt::FinalRelease *
*----------------------------*
*   Description:  
*       Final ATL dtor
*
*   Return:
*   <>
******************************************************************** robch */
void CSpPhraseAlt::FinalRelease()
{
    SPDBG_FUNC("CSPPhraseAlt::FinalRelease");

    Dead();
}

/****************************************************************************
* CSpPhraseAlt::Init *
*--------------------*
*   Description:  
*       Initialize this object with data passed from the result (see
*       CSpResult::GetAlternates). We hold weak pointers back to the result
*       and to the parent phrase. We keep them until they might change,
*       at which point the Result will call us on ::Dead. The SPPHRASEALT
*       content ownership is transfered to us from CSpReusult::GetAlternates.
******************************************************************** robch */
HRESULT CSpPhraseAlt::Init(CSpResult * pResult, ISpPhrase * pPhraseParentWEAK, SPPHRASEALT * pAlt)
{
    SPDBG_FUNC("CSpPhraseAlt::Init");
    HRESULT hr = S_OK;
    
    SPDBG_ASSERT(m_pResultWEAK == NULL);
    SPDBG_ASSERT(m_pPhraseParentWEAK == NULL);
    SPDBG_ASSERT(m_pAlt == NULL);

    m_fUseTextReplacements = VARIANT_TRUE;

    m_pAlt = new SPPHRASEALT;
    if (m_pAlt)
    {
        *m_pAlt = *pAlt;
        m_pResultWEAK = pResult;
        m_pPhraseParentWEAK = pPhraseParentWEAK;
        pAlt->pPhrase = NULL;
        pAlt->pvAltExtra = NULL;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpPhraseAlt::Dead *
*--------------------*
*   Description:  
*       Let go of the result and parent phrase. The result object calls us
*       when it's invalidating the alternates. From this point on, every
*       method on CSpPhraseAlt should return an error.
******************************************************************** robch */
void CSpPhraseAlt::Dead()
{
    SPDBG_FUNC("CSPPhraseAlt::Dead");
    
    // Tell the result to remove this alternate
    if (m_pResultWEAK != NULL)
    {
        m_pResultWEAK->RemoveAlternate(this);
        m_pResultWEAK = NULL;
    }
    
    m_pPhraseParentWEAK = NULL;
    
    //--- Cleanup SPPHRASEALT struct
    if( m_pAlt )
    {
        if( m_pAlt->pPhrase )
        {
            m_pAlt->pPhrase->Release();
        }

        if( m_pAlt->pvAltExtra )
        {
            ::CoTaskMemFree( m_pAlt->pvAltExtra );
            m_pAlt->pvAltExtra = NULL;
            m_pAlt->cbAltExtra = 0;
        }

        delete m_pAlt;
        m_pAlt = NULL;
    }
}

/****************************************************************************
* CSpPhraseAlt::GetPhrase *
*-------------------------*
*   Description:  
*       Delegate to the contained phrase
*
*   Return:
*   S_OK on success
*   SPERR_DEAD_ALTERNATE if we've previously been detatched from the result
******************************************************************** robch */
STDMETHODIMP CSpPhraseAlt::GetPhrase(SPPHRASE ** ppCoMemPhrase)
{
    SPDBG_FUNC("CSpPhraseAlt::GetPhrase");

    return m_pAlt == NULL || m_pAlt->pPhrase == NULL
        ? SPERR_DEAD_ALTERNATE
        : m_pAlt->pPhrase->GetPhrase(ppCoMemPhrase);
}

/****************************************************************************
* CSpPhraseAlt::GetSerializedPhrase *
*-----------------------------------*
*   Description:  
*       Delegate to the contained phrase
*
*   Return:
*   S_OK on success
*   SPERR_DEAD_ALTERNATE if we've previously been detatched from the result
******************************************************************** robch */
STDMETHODIMP CSpPhraseAlt::GetSerializedPhrase(SPSERIALIZEDPHRASE ** ppCoMemPhrase)
{
    SPDBG_FUNC("CSpPhraseAlt::GetSErializedPhrase");

    return m_pAlt == NULL || m_pAlt->pPhrase == NULL
        ? SPERR_DEAD_ALTERNATE
        : m_pAlt->pPhrase->GetSerializedPhrase(ppCoMemPhrase);
}

/****************************************************************************
* CSpPhraseAlt::GetText *
*-----------------------*
*   Description:  
*       Delegate to the contained phrase
*
*   Return:
*   S_OK on success
*   SPERR_DEAD_ALTERNATE if we've previously been detatched from the result
******************************************************************** robch */
STDMETHODIMP CSpPhraseAlt::GetText(ULONG ulStart, 
                                   ULONG ulCount, 
                                   BOOL fUseTextReplacements, 
                                   WCHAR ** ppszCoMemText, 
                                   BYTE * pbDisplayAttributes)
{
    SPDBG_FUNC("CSpPhraseAlt::GetText");

    return m_pAlt == NULL || m_pAlt->pPhrase == NULL
        ? SPERR_DEAD_ALTERNATE
        : m_pAlt->pPhrase->GetText(ulStart, ulCount, fUseTextReplacements, 
                                    ppszCoMemText, pbDisplayAttributes);
}

/****************************************************************************
* CSpPhraseAlt::Discard *
*-----------------------*
*   Description:  
*       You cannot discard anything from a phrase alternate
*
*   Return:
    E_NOTIMPL
******************************************************************** robch */
STDMETHODIMP CSpPhraseAlt::Discard(DWORD dwValueTypes)
{
    SPDBG_FUNC("CSpPhraseAlt::Discard");

    return E_NOTIMPL;
}

/****************************************************************************
* CSpPhraseAlt::GetAltInfo *
*--------------------------*
*   Description:  
*       Return the alternate info
*
*   Return:
*   S_OK on success
*   E_INVALIDARG on a bad argument
*   SPERR_NOT_FOUND if we don't have any information
******************************************************************** robch */
HRESULT CSpPhraseAlt::GetAltInfo(ISpPhrase **ppParent, 
                                 ULONG *pulStartElementInParent, 
                                 ULONG *pcElementsInParent, 
                                 ULONG *pcElementsInAlt)
{
    SPDBG_FUNC("CSpPhraseAlt::GetAltInfo");

    HRESULT hr = S_OK;
    
    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(ppParent) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pulStartElementInParent) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pcElementsInParent) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pcElementsInAlt))
    {
        hr = E_INVALIDARG;
    }
    else if (m_pResultWEAK == NULL || m_pPhraseParentWEAK == NULL || m_pAlt == NULL)
    {
        hr = SPERR_NOT_FOUND;
    }
    else
    {
        if (ppParent != NULL)
        {
            *ppParent = m_pPhraseParentWEAK;
            (*ppParent)->AddRef();
        }

        if (pulStartElementInParent != NULL)
        {
            *pulStartElementInParent = m_pAlt->ulStartElementInParent;
        }

        if (pcElementsInParent != NULL)
        {
            *pcElementsInParent = m_pAlt->cElementsInParent;
        }

        if (pcElementsInAlt != NULL)
        {
            *pcElementsInAlt = m_pAlt->cElementsInAlternate;
        }
    }

    return hr;
}

/****************************************************************************
* CSpPhraseAlt::Commit *
*----------------------*
*   Description:  
*       Commit the changes by updating the parent result, and sending
*       correction feedback back to the engine
*
*   Return:
*   S_OK on success
******************************************************************** robch */
HRESULT CSpPhraseAlt::Commit()
{
    SPDBG_FUNC("CSpPhraseAlt::Commit");

    HRESULT hr = S_OK;
    
    if (m_pResultWEAK == NULL || m_pPhraseParentWEAK == NULL || m_pAlt == NULL)
    {
        hr = SPERR_NOT_FOUND;
    }
    else
    {
        hr = m_pResultWEAK->CommitAlternate(m_pAlt);
    }

    SPDBG_REPORT_ON_FAIL(hr);
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spresmgr.cpp ===
/*******************************************************************************
* SpResMgr.cpp *
*--------------*
*   Description:
*       This module is the main implementation file for the CSpResourceManager class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 08/14/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "SpResMgr.h"

//
//  Declare the globals for the class factory.
//
CComObject<CSpResourceManager> * g_pResMgrObj = NULL;

//--- Local


/*****************************************************************************
* CSpResourceManager::FinalConstruct *
*------------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CSpResourceManager::FinalConstruct()
{
    SPDBG_FUNC( "CSpResourceManager::FinalConstruct" );
    HRESULT hr = S_OK;
    return hr;
} /* CSpResourceManager::FinalConstruct */

/*****************************************************************************
* CSpResourceManager::FinalRelease *
*----------------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
void CSpResourceManager::FinalRelease()
{
    SPDBG_FUNC( "CSpResourceManager::FinalRelease" );
    m_ServiceList.Purge();
    CComResourceMgrFactory::ResMgrIsDead();
} /* CSpResourceManager::FinalRelease */



//
//=== ISpResourceManager =====================================================
//

/*****************************************************************************
* CSpResourceManager::SetObject *
*-------------------------------*
*   Description:
*       Adds a service object to the current service list.
********************************************************************* EDC ***/
STDMETHODIMP CSpResourceManager::SetObject( REFGUID guidServiceId, IUnknown *pUnkObject )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpResourceManager::SetObject" );
    HRESULT hr = S_OK;

    if( pUnkObject && SPIsBadInterfacePtr( pUnkObject ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CServiceNode * pService = m_ServiceList.FindAndRemove(guidServiceId);
        if (pService)
        {
            if (pService->IsAggregate())
            {
                pService->ReleaseResMgr();
            }
            else
            {
                delete pService;
            }
        }

        if( pUnkObject )
        {
            pService = new CServiceNode( guidServiceId, pUnkObject );
            if (!pService)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                m_ServiceList.InsertHead(pService);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpResourceManager::SetService */

/*****************************************************************************
* CSpResourceManager::GetObject *
*-------------------------------*
*   Description:
*       Member function of ISpResourceManager
*       Gets a service object from the current service list.
********************************************************************* EDC ***/

STDMETHODIMP CSpResourceManager::
    GetObject( REFGUID guidServiceId, REFCLSID ObjectCLSID, REFIID ObjectIID, BOOL fReleaseWhenNoRefs, void** ppObject )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpResourceManager::GetObject" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppObject ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Look for existing object
        *ppObject = NULL;   // In case we fail
        CServiceNode * pService = m_ServiceList.Find(guidServiceId);

        //--- If we didn't find the object, make it
        if (pService)
        {
            hr = pService->QueryInterface(ObjectIID, ppObject);
        }
        else
        {
            if( ObjectCLSID == CLSID_NULL )
            {
                hr = REGDB_E_CLASSNOTREG;
            }
            else
            {
                pService = new CServiceNode(guidServiceId, ObjectCLSID, ObjectIID, fReleaseWhenNoRefs, this, ppObject, &hr);
                if (pService)
                {
                    if (SUCCEEDED(hr))
                    {
                        m_ServiceList.InsertHead(pService);
                    }
                    else
                    {
                        delete pService;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpResourceManager::GetObject */

//
//  Implementation of CServiceNode IUnknown
//
STDMETHODIMP CServiceNode::QueryInterface(REFIID riid, void ** ppv)
{
    if (m_fIsAggregate && riid == __uuidof(IUnknown))
    {
        *ppv = static_cast<IUnknown *>(this);
        ::InterlockedIncrement(&m_lRef);
        return S_OK;
    }
    else
    {
        return m_cpUnkService->QueryInterface(riid, ppv);
    }
}

STDMETHODIMP_(ULONG) CServiceNode::AddRef(void)
{
    SPDBG_ASSERT(m_fIsAggregate);
    return ::InterlockedIncrement(&m_lRef);
}

STDMETHODIMP_(ULONG) CServiceNode::Release(void)
{
    SPDBG_ASSERT(m_fIsAggregate);
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l)
    {
        return l;
    }
    CSpResourceManager * pResMgr = SpInterlockedExchangePointer(&m_pResMgr, NULL);
    if (pResMgr)
    {
        pResMgr->Lock();
        pResMgr->m_ServiceList.Remove(this);
        pResMgr->Unlock();
        pResMgr->Release();
    }
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spresmgr.h ===
/*******************************************************************************
* SpResMgr.h *
*------------*
*   Description:
*       This is the header file for the CSpResourceManager implementation.
*-------------------------------------------------------------------------------
*  Created By: EDC                            Date: 08/14/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef SpResMgr_h
#define SpResMgr_h

//--- Additional includes
#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifdef _WIN32_WCE
#include <servprov.h>
#endif

#include "resource.h"

class CComResourceMgrFactory;
class CSpResourceManager;



//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================
	
/*** CServiceNode
*
*/
class CServiceNode : public IUnknown
{
public:
    CServiceNode        * m_pNext;          // Used by list implementation so must be public

private:
    CComPtr<IUnknown>   m_cpUnkService;
    const GUID          m_guidService;
    CSpResourceManager *m_pResMgr;          // If non-NULL then we hold a ref to resource manager
    LONG                m_lRef;
    BOOL                m_fIsAggregate;

public:
    //
    //  This constructor used by SetService
    //
    inline CServiceNode(REFGUID guidService, IUnknown *pUnkService);
    //
    //  This constructor used by GetObject.  If *phr is not successful then the caller must
    //  delete this object.
    //
    inline CServiceNode(REFGUID guidService,
                        REFCLSID ObjectCLSID,
                        REFIID ObjectIID,
                        BOOL fIsAggregate,
                        CSpResourceManager * pResMgr,
                        void** ppObject,
                        HRESULT * phr);
    inline ~CServiceNode();
    inline BOOL IsAggregate();
    inline void ReleaseResMgr();
    inline BOOL operator==(REFGUID rguidService);
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
#ifdef _WIN32_WCE
    // Dummy Compare funcs and empty constructors are here because the CE compiler
    // is expanding templates for functions that aren't being called
    CServiceNode()
    {
    }

    static LONG Compare(const CServiceNode *, const CServiceNode *)
    {
        return 0;
    }
#endif
};

/*** CSpResourceManager
*
*/
class ATL_NO_VTABLE CSpResourceManager : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSpResourceManager, &CLSID_SpResourceManager>,
#ifdef _WIN32_WCE
    public IServiceProvider,
#endif
	public ISpResourceManager
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_CLASSFACTORY_EX(CComResourceMgrFactory)
    DECLARE_REGISTRY_RESOURCEID(IDR_SPRESOURCEMANAGER)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpResourceManager)
	    COM_INTERFACE_ENTRY(ISpResourceManager)
	    COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY_AUTOAGGREGATE(IID_ISpTaskManager, m_cpunkTaskMgr.p, CLSID_SpTaskManager)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
	HRESULT FinalConstruct();
	void FinalRelease();

  /*=== Interfaces ====*/
  public:
    //--- ISpServiceProvider --------------------------------------------------
    STDMETHOD( QueryService )( REFGUID guidService, REFIID riid, void** ppv );

    //--- ISpResourceManager --------------------------------------------------
    STDMETHOD( SetObject )( REFGUID guidServiceId, IUnknown *pUnkObject );
    STDMETHOD( GetObject )( REFGUID guidServiceId, REFCLSID ObjectCLSID, REFIID ObjectIID, BOOL fReleaseWhenLastExternalRefReleased, void** ppObject );

  /*=== Member Data ===*/
  public:
    CSpBasicQueue<CServiceNode> m_ServiceList;
    CComPtr<IUnknown>           m_cpunkTaskMgr;
};

//
//=== Inlines ========================================================
//

template<class T>
T * SpInterlockedExchangePointer(T ** pTarget, void * pNew) // Use VOID for pNew so NULL will work.
{
    return (T *)InterlockedExchangePointer((PVOID*)pTarget, (PVOID)pNew);
}

//
//  This constructor used by SetService
//
inline CServiceNode::CServiceNode(REFGUID guidService, IUnknown *pUnkService) :
    m_guidService(guidService),
    m_cpUnkService(pUnkService),
    m_fIsAggregate(FALSE),
    m_pResMgr(NULL),
    m_lRef(0)
{}

//
//  This constructor used by GetObject.  If *phr is not successful then the caller must
//  delete this object.
//
inline CServiceNode::CServiceNode(REFGUID guidService,
                                  REFCLSID ObjectCLSID,
                                  REFIID ObjectIID,
                                  BOOL fIsAggregate,
                                  CSpResourceManager * pResMgr,
                                  void** ppObject,
                                  HRESULT * phr) :
    m_guidService(guidService),
    m_fIsAggregate(fIsAggregate),
    m_lRef(0)
{
    IUnknown * punkOuter;
    if (m_fIsAggregate)
    {
        m_pResMgr = pResMgr;
        m_pResMgr->AddRef();
        punkOuter = this;
    }
    else
    {
        m_pResMgr = NULL;
        punkOuter = NULL;
    }
    *phr = m_cpUnkService.CoCreateInstance(ObjectCLSID, punkOuter);
    if (SUCCEEDED(*phr))
    {
        *phr = QueryInterface(ObjectIID, ppObject);
        if (SUCCEEDED(*phr) && m_fIsAggregate)
        {
            SPDBG_ASSERT(m_lRef == 1);
        }
    }
}

inline CServiceNode::~CServiceNode()
{
    if (m_pResMgr)
    {
        m_pResMgr->Release();
    }
}

inline BOOL CServiceNode::IsAggregate()
{
    return m_fIsAggregate;
}

inline void CServiceNode::ReleaseResMgr()
{
    CSpResourceManager * pResMgr = SpInterlockedExchangePointer(&m_pResMgr, NULL);
    if (pResMgr)
    {
        pResMgr->Release();
    }
}

inline BOOL CServiceNode::operator==(REFGUID rguidService)
{
    return m_guidService == rguidService;
}











inline STDMETHODIMP CSpResourceManager::
    QueryService( REFGUID guidService, REFIID riid, void** ppv )
{
    return GetObject( guidService, CLSID_NULL, riid, FALSE, ppv );
}



extern CComObject<CSpResourceManager> * g_pResMgrObj;

class CComResourceMgrFactory : public CComClassFactory
{
public:
	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// aggregation is not supported in Singletons
			SPDBG_ASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
			{
                ::EnterCriticalSection(&_Module.m_csObjMap);
                if (g_pResMgrObj == NULL)
                {
                    hRes = CComObject<CSpResourceManager>::CreateInstance(&g_pResMgrObj);
                }
                if (g_pResMgrObj)
                {
                    g_pResMgrObj->AddRef();
                    hRes = g_pResMgrObj->QueryInterface(riid, ppvObj);
                    g_pResMgrObj->Release();    // Could kill the obj if QI fails and it was just created!
                }
                ::LeaveCriticalSection(&_Module.m_csObjMap);
			}
		}
		return hRes;
	}
    static void ResMgrIsDead()
    {
        ::EnterCriticalSection(&_Module.m_csObjMap);
        g_pResMgrObj = NULL;
        ::LeaveCriticalSection(&_Module.m_csObjMap);
    }
};


#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spresult.cpp ===
// SpResult.cpp : Implementation of CSpResult
#include "stdafx.h"
#include "Sapi.h"
#include "recoctxt.h"
#include "spphrase.h"
#include "spphrasealt.h"
#include "resultheader.h"

// Using SP_TRY, SP_EXCEPT exception handling macros
#pragma warning( disable : 4509 )


/////////////////////////////////////////////////////////////////////////////
// CSpResult

/*****************************************************************************
* CSpResult::FinalRelease *
*-------------------------*
*   Description:
*       This method handles the release of the result object.  It simply frees
*       the actual result data block, if one is currently attached.
********************************************************************* RAP ***/
void CSpResult::FinalRelease()
{
    RemoveAllAlternates();
    
    ::CoTaskMemFree( m_pResultHeader );
    if (m_pCtxt && !m_fWeakCtxtRef)
    {
        m_pCtxt->GetControllingUnknown()->Release();
        m_pCtxt = NULL;
    }
}

/****************************************************************************
* CSpResult::RemoveAllAlternates *
*--------------------------------*
*   Description:  
*       Remove all the alternates from the result.
******************************************************************** robch */
void CSpResult::RemoveAllAlternates()
{
    SPAUTO_OBJ_LOCK;
    
    // Copy the list so when we're making the objects dead, and
    // they call us back on RemoveAlternate it doesn't screw up
    // our list iteration
    CSPList<CSpPhraseAlt*, CSpPhraseAlt*> listpAlts;
    SPLISTPOS pos = m_listpAlts.GetHeadPosition();
    for (int i = 0; i < m_listpAlts.GetCount(); i++)
    {
        listpAlts.AddHead(m_listpAlts.GetNext(pos));
    }
    m_listpAlts.RemoveAll();

    // Make all the alternates dead, so that they return 
    // SPERR_DEAD_ALTERNATE on all calls
    pos = listpAlts.GetHeadPosition();
    for (i = 0; i < listpAlts.GetCount(); i++)
    {
        listpAlts.GetNext(pos)->Dead();
    }

    // Get rid of the alternate request
    if (m_pAltRequest != NULL)
    {
        if (m_pAltRequest->pPhrase)
        {
            m_pAltRequest->pPhrase->Release();
        }
            
        if (m_pAltRequest->pRecoContext)
        {
            m_pAltRequest->pRecoContext->Release();
        }
        
        delete m_pAltRequest;
        m_pAltRequest = NULL;
    }
}

/****************************************************************************
* CSpResult::RemoveAlternate *
*----------------------------*
*   Description:  
*       Remove a specific alternate from the list of associated alternates
******************************************************************** robch */
void CSpResult::RemoveAlternate(CSpPhraseAlt *pAlt)
{
    SPAUTO_OBJ_LOCK;
    SPLISTPOS pos = m_listpAlts.Find(pAlt);
    if (pos)
    {
        m_listpAlts.RemoveAt(pos);
    }
}


/****************************************************************************
* CSpResult::CommitAlternate *
*----------------------------*
*   Description:  
*       Commit a specific alternate
******************************************************************** robch */
HRESULT CSpResult::CommitAlternate( SPPHRASEALT *pAlt )
{
    SPDBG_FUNC("CSpResult::CommitAlternate");
    SPAUTO_OBJ_LOCK;
    SPDBG_ASSERT(m_pResultHeader != NULL);
    SPSERIALIZEDPHRASE *pPhrase = NULL;
    void *pvResultExtra = NULL;
    ULONG cbResultExtra = 0;
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_READ_PTR( pAlt ) )
    {
        return E_INVALIDARG;
    }

    //--- Get the alterate in serialized form
    if( m_pResultHeader->ulNumPhraseAlts )
    {
        //--- C&C already has alternates, just look it up
        SPLISTPOS ListPos = m_listpAlts.GetHeadPosition();
        while( ListPos )
        {
            CSpPhraseAlt* pPhraseAlt = m_listpAlts.GetNext( ListPos );
            if( pPhraseAlt->m_pAlt == pAlt )
            {
                hr = pPhraseAlt->m_pAlt->pPhrase->GetSerializedPhrase( &pPhrase );
                break;
            }
        }
        if( !pPhrase )
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        SPDBG_ASSERT(m_pResultHeader->clsidAlternates != CLSID_NULL);
        // Create the analyzer (provided by the engine vendor)
        CComPtr<ISpSRAlternates> cpAlternates;
        hr = cpAlternates.CoCreateInstance(m_pResultHeader->clsidAlternates);

        // Retrieve the new result extra data from the analyzer
        if (SUCCEEDED(hr))
        {
            SR_TRY
            {
                hr = cpAlternates->Commit(m_pAltRequest, pAlt, &pvResultExtra, &cbResultExtra);
            }
            SR_EXCEPT;

            if(SUCCEEDED(hr) && ((cbResultExtra && !pvResultExtra) || 
                (!cbResultExtra && pvResultExtra)))
            {
                SPDBG_ASSERT(0);
                hr = SPERR_ENGINE_RESPONSE_INVALID;
            }

            if(FAILED(hr)) // If failed or exception make sure these are reset
            {
                pvResultExtra = NULL;
                cbResultExtra = 0;
            }
        }

        // Get the phrase's serialized form so we can stuff it in the result header
        if (SUCCEEDED(hr))
        {
            SPDBG_ASSERT(m_pAltRequest->pPhrase != NULL);
            hr = pAlt->pPhrase->GetSerializedPhrase(&pPhrase);
        }
    }
    
    // Create and initialize a new result header with the new sizes
    CResultHeader hdr;
    if (SUCCEEDED(hr))
    {
        hr = hdr.Init(
            pPhrase->ulSerializedSize,
            0,
            m_pResultHeader->ulRetainedDataSize, 
            cbResultExtra);
    }

    // Copy the appropriate information
    if (SUCCEEDED(hr))
    {
        hdr.m_pHdr->clsidEngine            = m_pResultHeader->clsidEngine;
        hdr.m_pHdr->clsidAlternates        = m_pResultHeader->clsidAlternates;
        hdr.m_pHdr->ulStreamNum            = m_pResultHeader->ulStreamNum;
        hdr.m_pHdr->ullStreamPosStart      = m_pResultHeader->ullStreamPosStart;
        hdr.m_pHdr->ullStreamPosEnd        = m_pResultHeader->ullStreamPosEnd;
        hdr.m_pHdr->times                  = m_pResultHeader->times;
        hdr.m_pHdr->fTimePerByte           = m_pResultHeader->fTimePerByte;
        hdr.m_pHdr->fInputScaleFactor      = m_pResultHeader->fInputScaleFactor;
        
        // Copy the phrases data
        CopyMemory(
            LPBYTE(hdr.m_pHdr) + hdr.m_pHdr->ulPhraseOffset, 
            LPBYTE(pPhrase),
            hdr.m_pHdr->ulPhraseDataSize );

        // Copy the audio data
		if (hdr.m_pHdr->ulRetainedDataSize)
		{
			CopyMemory(
				LPBYTE(hdr.m_pHdr) + hdr.m_pHdr->ulRetainedOffset,
				LPBYTE(m_pResultHeader) + m_pResultHeader->ulRetainedOffset,
				hdr.m_pHdr->ulRetainedDataSize);
		}

        // Copy the alternates data
        CopyMemory(
            LPBYTE(hdr.m_pHdr) + hdr.m_pHdr->ulDriverDataOffset,
            LPBYTE(pvResultExtra),
            hdr.m_pHdr->ulDriverDataSize);

    }

    // Do the stream position to time conversion and the audio format conversion if necessary
    if (SUCCEEDED(hr))
    {
        // Need to convert the stream offsets (currently in engine format) to time using engine fTimePerByte
        hr = hdr.StreamOffsetsToTime();
    }

    // Free the previous result and reinitialize ourselves
    if (SUCCEEDED(hr))
    {
        ::CoTaskMemFree(m_pResultHeader);
        m_pResultHeader = NULL;
        hr = Init(NULL, hdr.Detach());
    }

    // Free any memory we might have left around from above
    if (pvResultExtra != NULL)
    {
        ::CoTaskMemFree(pvResultExtra);
    }

    if (pPhrase != NULL)
    {
        ::CoTaskMemFree(pPhrase);
    }

    RemoveAllAlternates();

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpResult::Discard *
*--------------------*
*   Description:
******************************************************************* robch ***/
STDMETHODIMP CSpResult::Discard(DWORD dwFlags)
{
    SPDBG_FUNC("CSpResult::Discard");
    HRESULT hr = S_OK;
    
    if (dwFlags & (~SPDF_ALL))
    {
        hr = E_INVALIDARG;
    }
    else if ((dwFlags & SPDF_AUDIO) || (dwFlags & SPDF_ALTERNATES))
    {
        SPAUTO_OBJ_LOCK;
        if (dwFlags & SPDF_ALTERNATES)
        {
            RemoveAllAlternates();
        }

        CResultHeader hdr;
        hr = hdr.Init(
            m_pResultHeader->ulPhraseDataSize,
            0,
            (dwFlags & SPDF_AUDIO) 
                ? 0
                : m_pResultHeader->ulRetainedDataSize, 
            (dwFlags & SPDF_ALTERNATES)
                ? 0
                : m_pResultHeader->ulDriverDataSize);

        if (SUCCEEDED(hr))
        {
            hdr.m_pHdr->clsidEngine            = m_pResultHeader->clsidEngine;
            hdr.m_pHdr->clsidAlternates        = m_pResultHeader->clsidAlternates;
            hdr.m_pHdr->ulStreamNum            = m_pResultHeader->ulStreamNum;
            hdr.m_pHdr->ullStreamPosStart      = m_pResultHeader->ullStreamPosStart;
            hdr.m_pHdr->ullStreamPosEnd        = m_pResultHeader->ullStreamPosEnd;
            hdr.m_pHdr->times                  = m_pResultHeader->times;
            hdr.m_pHdr->fTimePerByte           = m_pResultHeader->fTimePerByte;
            hdr.m_pHdr->fInputScaleFactor      = m_pResultHeader->fInputScaleFactor;
            
            // Copy the phrases data
            CopyMemory(
                LPBYTE(hdr.m_pHdr) + hdr.m_pHdr->ulPhraseOffset, 
                LPBYTE(m_pResultHeader) + m_pResultHeader->ulPhraseOffset,
                hdr.m_pHdr->ulPhraseDataSize);

            // Copy the audio data
            CopyMemory(
                LPBYTE(hdr.m_pHdr) + hdr.m_pHdr->ulRetainedOffset,
                LPBYTE(m_pResultHeader) + m_pResultHeader->ulRetainedOffset,
                hdr.m_pHdr->ulRetainedDataSize);

            // Copy the alternates data
            CopyMemory(
                LPBYTE(hdr.m_pHdr) + hdr.m_pHdr->ulDriverDataOffset,
                LPBYTE(m_pResultHeader) + m_pResultHeader->ulDriverDataOffset,
                hdr.m_pHdr->ulDriverDataSize);

            CoTaskMemFree(m_pResultHeader);
            m_pResultHeader = NULL;
            
            Init(NULL, hdr.Detach());
        }
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_Phrase->Discard(dwFlags);
    }

    return hr;
}

/*****************************************************************************
* CSpResult::Init *
*-----------------*
*   Description:
*       If pCtxt is NULL then this is a second call to re-initialize this
*   object, so we don't initialize the member or addref() the context.
********************************************************************* RAP ***/
HRESULT CSpResult::Init( CRecoCtxt * pCtxt, SPRESULTHEADER *pResultHdr )
{
    HRESULT hr = S_OK;

    if( pCtxt )
    {
        SPDBG_ASSERT(m_pCtxt == NULL);
        m_pCtxt = pCtxt;
        pCtxt->GetControllingUnknown()->AddRef();
    }
    SPDBG_ASSERT(m_pCtxt);

    //--- Save the result header so we can access it later to construct alternates
    m_pResultHeader = pResultHdr;
    if (m_pResultHeader->ulRetainedDataSize != 0 && m_fRetainedScaleFactor == 0.0F)
    {
        CSpStreamFormat spTmpFormat;
        ULONG cbFormatHeader;
        hr = spTmpFormat.Deserialize(((BYTE*)m_pResultHeader) + m_pResultHeader->ulRetainedOffset, &cbFormatHeader);
        if (SUCCEEDED(hr))
        {
            m_fRetainedScaleFactor = (m_pResultHeader->ulRetainedDataSize - cbFormatHeader) / 
                                     (static_cast<float>(m_pResultHeader->ullStreamPosEnd - m_pResultHeader->ullStreamPosStart));
        }
    }
    else if (m_pResultHeader->ulRetainedDataSize == 0)
    {
        m_fRetainedScaleFactor = 0.0F;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_Phrase->InitFromPhrase(NULL);
    }

    //--- Construct the primary phrase object
    if( SUCCEEDED(hr) && pResultHdr->ulPhraseDataSize )
    {
        // CFG case
        SPSERIALIZEDPHRASE *pPhraseData = (SPSERIALIZEDPHRASE*)(((BYTE*)pResultHdr) +
                                                                 pResultHdr->ulPhraseOffset);
        hr = m_Phrase->InitFromSerializedPhrase(pPhraseData);
    }
    return hr;
} /* CSpResult::Init */

/**********************************************************************************
* CSpResult::WeakCtxtRef *
*------------------------*
*   Description:
*       Tell the result that it's reference to the context should be a weak one
*       (or not). When results are in the event queue, they need to have weak
*       references, otherwise, if an app forgets to service the queue before
*       releasing the context, the context will never go away due to the 
*       circular referecne.
************************************************************** robch **************/
void CSpResult::WeakCtxtRef(BOOL fWeakCtxtRef)
{
    SPDBG_FUNC("CSpResult::WeakCtxtRef");
    SPDBG_ASSERT(m_pCtxt);
    SPDBG_ASSERT(m_fWeakCtxtRef != fWeakCtxtRef);    
    
    m_fWeakCtxtRef = fWeakCtxtRef;
    if (fWeakCtxtRef)
    {
        m_pCtxt->GetControllingUnknown()->Release();
    }
    else
    {
        m_pCtxt->GetControllingUnknown()->AddRef();
    }
}



/**********************************************************************************
* CSpResult::GetResultTimes *
*---------------------------*
*   Description:
*       Get the time info for this result.
*
*   Return:
*       HRESULT -- S_OK -- E_POINTER if pdwGrammarId is not valid
*
************************************************************** richp **************/
STDMETHODIMP CSpResult::GetResultTimes(SPRECORESULTTIMES *pTimes)
{
    if (SP_IS_BAD_WRITE_PTR(pTimes))
    {
        return E_POINTER;
    }

    if (m_pResultHeader == NULL)
    {
        return SPERR_NOT_FOUND;
    }

    memcpy(pTimes, &m_pResultHeader->times, sizeof(SPRECORESULTTIMES));
    return S_OK;
}

/**********************************************************************************
* CSpResult::DeserializeCnCAlternates *
*-------------------------------------*
*   Description:
*       This method deserialized the command and control alternates that are in
*   the result header. It returns the requested number of alternate objects.
*
*************************************************************************** EDC ***/
HRESULT CSpResult::DeserializeCnCAlternates( ULONG ulRequestCount,
                                             ISpPhraseAlt** ppPhraseAlts,
                                             ULONG* pcAltsReturned )
{
    SPDBG_FUNC("CSpResult::DeserializeCnCAlternates");
    HRESULT hr = S_OK;
    ULONG i;

    *pcAltsReturned = 0;
    ulRequestCount  = min( ulRequestCount, m_pResultHeader->ulNumPhraseAlts );
    BYTE* pMem      = PBYTE(m_pResultHeader) + m_pResultHeader->ulPhraseAltOffset;

    //--- Get the parent
    CComQIPtr<ISpPhrase> cpParentPhrase( m_Phrase );
    SPDBG_ASSERT( cpParentPhrase );

    //--- Deserialize the requested count from the result header
    for( i = 0; SUCCEEDED( hr ) && (i < ulRequestCount); ++i )
    {
        SPPHRASEALT Alt;
        memset( &Alt, 0, sizeof( Alt ) );

        memcpy( &Alt.ulStartElementInParent, pMem,
                sizeof( Alt.ulStartElementInParent ) );
        pMem += sizeof( Alt.ulStartElementInParent );

        memcpy( &Alt.cElementsInParent, pMem,
                sizeof( Alt.cElementsInParent ) );
        pMem += sizeof( Alt.cElementsInParent );

        memcpy( &Alt.cElementsInAlternate, pMem, 
                sizeof( Alt.cElementsInAlternate ) );
        pMem += sizeof( Alt.cElementsInAlternate );

        memcpy( &Alt.cbAltExtra, pMem, sizeof( Alt.cbAltExtra ) );
        pMem += sizeof( Alt.cbAltExtra );

        //--- Create private data
        if( Alt.cbAltExtra )
        {
            Alt.pvAltExtra = ::CoTaskMemAlloc( Alt.cbAltExtra );
            if( Alt.pvAltExtra )
            {
                memcpy( Alt.pvAltExtra, pMem, Alt.cbAltExtra );
                pMem += Alt.cbAltExtra;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        //--- Create the alternate's phrase object
        CComObject<CPhrase> * pPhrase;
        hr = CComObject<CPhrase>::CreateInstance( &pPhrase );
        if( SUCCEEDED(hr) )
        {
            SPSERIALIZEDPHRASE* pSer = (SPSERIALIZEDPHRASE*)pMem;
            hr = pPhrase->InitFromSerializedPhrase( pSer );
            pMem += pSer->ulSerializedSize;
            if( SUCCEEDED( hr ) )
            {
                pPhrase->QueryInterface( IID_ISpPhraseBuilder, (void**)&Alt.pPhrase );
            }
            else
            {
                // Stupid thing, just to delete this object
                pPhrase->AddRef();
                pPhrase->Release();
            }
        }

        //--- Create the alternate
        if( SUCCEEDED(hr) )
        {
            CComObject<CSpPhraseAlt> * pPhraseAlt;
            hr = CComObject<CSpPhraseAlt>::CreateInstance( &pPhraseAlt );
            if( SUCCEEDED(hr) )
            {
                // This passes ownership of the content of the alt structure 
                // to the CSpPhraseAlt object
                pPhraseAlt->Init( this, cpParentPhrase, &Alt );
                pPhraseAlt->QueryInterface( IID_ISpPhraseAlt, (void**)&ppPhraseAlts[i] );
                (*pcAltsReturned)++;
            }
        }
    }

    //--- Free any altnerates that we already made
    if( FAILED( hr ) )
    {
        for( i = 0; i < *pcAltsReturned; ++i )
        {
            ppPhraseAlts[i]->Release();
        }
    }

    return hr;
} /* CSpResult::DeserializeCnCAlternates */

/**********************************************************************************
* CSpResult::GetAlternates *
*--------------------------*
*   Description:
*       Fill in the ppPhrases array with pointers to ISpPhraseAlt objects which hold
*       alternative phrases.  The time span between the start of the ulStartElement
*       element and the end of the ulStartElement+CElements element is the portion
*       that will change, slightly larger, or slightly smaller but the rest of the 
*       elements will also be included in each alternate phrase.  
*
*       pcPhrasesReturned returns the actual number of alternates
*       generated.
*
*   Return:
*       HRESULT -- S_OK if successful -- E_POINTER if ppPhrases or pcPhrasesReturned
*                  are not valid -- E_OUTOFMEMORY
*
************************************************************** richp **************/

STDMETHODIMP CSpResult::
    GetAlternates( ULONG ulStartElement, ULONG cElements, ULONG ulRequestCount,
                   ISpPhraseAlt **ppPhrases, ULONG *pcPhrasesReturned )
{
    HRESULT hr = S_OK;
    ULONG cAlts = 0;

    if ( SPPR_ALL_ELEMENTS == cElements )
    {
        if ( SPPR_ALL_ELEMENTS == ulStartElement )
        {
            ulStartElement = 0;
        }
        else
        {
            // Validate ulStartElement
            if ( ulStartElement > m_Phrase->m_ElementList.m_cElements )
            {
                return E_INVALIDARG;
            }
        }

        // Go from ulStartElement to the end
        cElements = m_Phrase->m_ElementList.m_cElements - ulStartElement;
    }

    if( ( ulRequestCount == 0 ) ||
        ( cElements == 0 ) ||
        ( ulStartElement >= m_Phrase->m_ElementList.m_cElements ) ||
        (ulStartElement + cElements) > m_Phrase->m_ElementList.m_cElements)
    {
        // Make sure the range is valid and that they want at least one alt.
        hr = E_INVALIDARG;
    }        
    else if( SP_IS_BAD_WRITE_PTR(pcPhrasesReturned) ||
             SPIsBadWritePtr(ppPhrases, ulRequestCount * sizeof(ISpPhraseAlt*)))
    {
        hr = E_POINTER;
    }
    else if( m_pResultHeader == NULL )
    {
        SPDBG_ASSERT(FALSE); 
        // This code is never reached - agarside
        hr = SPERR_NOT_FOUND;
    }
    else
    {
        //--- Remove any previous alternates and init return args
        RemoveAllAlternates();
        *ppPhrases         = NULL;
        *pcPhrasesReturned = 0;

        //--- See if we have any C&C alternates
        if( m_pResultHeader->ulNumPhraseAlts && ( ulStartElement == 0 ) &&
            ( cElements == m_Phrase->m_ElementList.m_cElements ) )
        {
            //--- For now we only do C&C alternates for the whole phrase
            hr = DeserializeCnCAlternates( ulRequestCount, ppPhrases, &cAlts );
        }
        else if( m_pResultHeader->clsidAlternates  == CLSID_NULL ||
                 m_pResultHeader->ulDriverDataSize == 0 )
        {
            // If we don't have an analyzer or there is no driver data,
            // we can't generate alternates
            hr = S_FALSE;
        }
        else
        {
            // Create the analyzer (provided by the engine vendor)
            CComPtr<ISpSRAlternates> cpAlternates;
            hr = cpAlternates.CoCreateInstance(m_pResultHeader->clsidAlternates);
    
            // Create the request for the analyzer
            if (SUCCEEDED(hr))
            {
                SPDBG_ASSERT(m_pAltRequest == NULL);
        
                m_pAltRequest = new SPPHRASEALTREQUEST;
                m_pAltRequest->ulStartElement = ulStartElement;
                m_pAltRequest->cElements = cElements;
                m_pAltRequest->ulRequestAltCount = ulRequestCount;
                m_pAltRequest->pvResultExtra = LPBYTE(m_pResultHeader) + m_pResultHeader->ulDriverDataOffset;
                m_pAltRequest->cbResultExtra = m_pResultHeader->ulDriverDataSize;
                m_pAltRequest->pRecoContext = NULL;
                hr = m_Phrase->QueryInterface(IID_ISpPhrase, (void**)&m_pAltRequest->pPhrase);
            }

            // Give the alternates analyzer the reco context so he can make a private call if
            // necessary, but only do this if the recognizer is running the same engine that
            // created the result
            CComPtr<ISpRecognizer> cpRecognizer;
            if (SUCCEEDED(hr))
            {
                hr = m_pCtxt->GetRecognizer(&cpRecognizer);
            }

            CComPtr<ISpObjectToken> cpRecognizerToken;
            if (SUCCEEDED(hr))
            {
                hr = cpRecognizer->GetRecognizer(&cpRecognizerToken);
            }

            CSpDynamicString dstrRecognizerCLSID;
            if (SUCCEEDED(hr))
            {
                hr = cpRecognizerToken->GetStringValue(SPTOKENVALUE_CLSID, &dstrRecognizerCLSID);
            }

            CLSID clsidRecognizer;
            if (SUCCEEDED(hr))
            {
                hr = ::CLSIDFromString(dstrRecognizerCLSID, &clsidRecognizer);
            }

            if (SUCCEEDED(hr) && clsidRecognizer == m_pResultHeader->clsidEngine)
            {
                CComPtr<ISpRecoContext> cpRecoContext;
                hr = m_pCtxt->GetControllingUnknown()->QueryInterface(&cpRecoContext);
                m_pAltRequest->pRecoContext = cpRecoContext.Detach();
            }

            // Get the alternates from the analyzer
            SPPHRASEALT *paAlts = NULL;
            cAlts = 0;
            if( SUCCEEDED(hr) )
            {
                SR_TRY
                {
                    hr = cpAlternates->GetAlternates(m_pAltRequest, &paAlts, &cAlts);
                }
                SR_EXCEPT;

                if(SUCCEEDED(hr))
                {
                    // Do some validation on returned alternates
                    if( (paAlts && !cAlts) ||
                        (!paAlts && cAlts) ||
                        (cAlts > m_pAltRequest->ulRequestAltCount) ||
                        (::IsBadReadPtr(paAlts, sizeof(SPPHRASEALT) * cAlts)) )
                    {
                        SPDBG_ASSERT(0);
                        hr = SPERR_ENGINE_RESPONSE_INVALID;
                    }
            
                    for(UINT i = 0; SUCCEEDED(hr) && i < cAlts; i++)
                    {
                        if(SP_IS_BAD_INTERFACE_PTR(paAlts[i].pPhrase))
                        {
                            SPDBG_ASSERT(0);
                            hr = SPERR_ENGINE_RESPONSE_INVALID;
                            break;
                        }
                        if( (paAlts[i].cbAltExtra && !paAlts[i].pvAltExtra) ||
                            (!paAlts[i].cbAltExtra && paAlts[i].pvAltExtra) ||
                            (::IsBadReadPtr(paAlts[i].pvAltExtra, paAlts[i].cbAltExtra)) )
                        {
                            SPDBG_ASSERT(0);
                            hr = SPERR_ENGINE_RESPONSE_INVALID;
                            break;
                        }

                        SPINTERNALSERIALIZEDPHRASE * pSerPhrase = NULL;
                        if(FAILED(paAlts[i].pPhrase->GetSerializedPhrase((SPSERIALIZEDPHRASE **)&pSerPhrase)))
                        {
                            SPDBG_ASSERT(0);
                            hr = SPERR_ENGINE_RESPONSE_INVALID;
                            break;
                        }
                        if( (paAlts[i].ulStartElementInParent + paAlts[i].cElementsInParent > m_Phrase->m_ElementList.m_cElements) ||
                            (paAlts[i].ulStartElementInParent + paAlts[i].cElementsInAlternate > pSerPhrase->Rule.ulCountOfElements) )
                        {
                            SPDBG_ASSERT(0);
                            hr = SPERR_ENGINE_RESPONSE_INVALID;
                        }
                        // Rescale alternates settings.
                        InternalScalePhrase(m_pResultHeader, pSerPhrase);
                        pSerPhrase->ullGrammarID = m_Phrase->m_ullGrammarID;     // Update the grammar ID
                        paAlts[i].pPhrase->InitFromSerializedPhrase((SPSERIALIZEDPHRASE *)pSerPhrase);
                        ::CoTaskMemFree(pSerPhrase);
                    }
                }

                //--- Make sure we don't return more alternates than requested
                if( cAlts > ulRequestCount )
                {
                    cAlts = ulRequestCount;
                }

                if( SUCCEEDED( hr ) && cAlts )
                {
                    //--- Create each of the alternates, and stuff them in the
                    //    array we're preparing to return
                    memset(ppPhrases, 0, sizeof(ISpPhraseAlt*) * cAlts);
                    UINT i;
                    for( i = 0; SUCCEEDED(hr) && i < cAlts; i++ )
                    {
                        CComObject<CSpPhraseAlt> * pPhraseAlt;
                        hr = CComObject<CSpPhraseAlt>::CreateInstance(&pPhraseAlt);
                        if (SUCCEEDED(hr))
                        {
                            pPhraseAlt->AddRef();
                            // This passes ownership of the content of the alt structure 
                            // to the CSpPhraseAlt object
                            hr = pPhraseAlt->Init(this, m_pAltRequest->pPhrase, &paAlts[i]);
                            if (SUCCEEDED(hr))
                            {
                                ppPhrases[i] = pPhraseAlt;
                            }
                            else
                            {
                                pPhraseAlt->Release();
                            }
                        }
                    }

                    //--- Free the alt structures if tranferring them to the CSpPhraseAlt
                    //    object failed for any reason. CSpPhraseAlt::Init will set members
                    //    that were successfully transferred to NULL.
                    for( i = 0; i < cAlts; i++ )
                    {
                        // If we still have a phrase, release it
                        if (paAlts[i].pPhrase)
                        {
                            paAlts[i].pPhrase->Release();
                        }
        
                        // If we still have alt extra data, free it
                        if (paAlts[i].pvAltExtra != NULL)
                        {
                            ::CoTaskMemFree(paAlts[i].pvAltExtra);
                        }
                    }
                    ::CoTaskMemFree( paAlts );
                    paAlts = NULL;
                }
                else
                {
                    //--- The analyzer is leaking if you get here
                    SPDBG_ASSERT( ( paAlts == NULL ) && ( cAlts == 0 ) );
                    paAlts = NULL;
                    cAlts  = 0;
                }
            }
        }

        //--- Add the PhraseAlts to our internal
        //    list so we can terminate them when we get released
        if( SUCCEEDED(hr) )
        {
            SPAUTO_OBJ_LOCK;
            *pcPhrasesReturned = cAlts;

            for (UINT i = 0; i < cAlts; i++)
            {
                m_listpAlts.AddHead((CSpPhraseAlt*)ppPhrases[i]);
            }
        }
    
        // If we haven't yet freed the phrase alts, or transfered ownership to the caller,
        // release them and free the array
        if (FAILED(hr))
        {
            for (UINT i = 0; i < cAlts; i++)
            {
                if (ppPhrases[i] != NULL)
                {
                    ppPhrases[i]->Release();
                    ppPhrases[i] = NULL;
                }
            }
        }
    }
        
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpResult::GetAlternates */

/*****************************************************************************
* CSpResult::GetAudio *
*---------------------*
*   Description:
*       This method creates an audio stream of the requested words from the audio
*       data in the result data block, if a block is currently attached and it
*       includes audio data.
********************************************************************* RAP ***/
STDMETHODIMP CSpResult::GetAudio(ULONG ulStartElement, ULONG cElements, ISpStreamFormat **ppStream)
{
    HRESULT hr = S_OK;

    if ( SPPR_ALL_ELEMENTS == cElements )
    {
        if ( SPPR_ALL_ELEMENTS == ulStartElement )
        {
            ulStartElement = 0;
        }
        else
        {
            // Validate ulStartElement
            if ( ulStartElement > m_Phrase->m_ElementList.m_cElements )
            {
                return E_INVALIDARG;
            }
        }

        // Go from ulStartElement to the end
        cElements = m_Phrase->m_ElementList.m_cElements - ulStartElement;
    }

    if (SP_IS_BAD_WRITE_PTR(ppStream))
    {
        hr =  E_POINTER;
    }
    else
    {
        *ppStream = NULL;               // Assume the worst...

        if (m_pResultHeader && m_pResultHeader->ulRetainedDataSize)
        {
            //
            //  Even if there are no elements, if ulStartElement = 0 and cElements = 0 then
            //  we'll play the audio.  There are "unrecognized" results that have no elements,
            //  but do have audio.
            //
            ULONG cTotalElems = m_Phrase->m_ElementList.GetCount();
            ULONG ulRetainedStartOffset = 0;
            ULONG ulRetainedSize = m_Phrase->m_ulRetainedSizeBytes;
            if (ulStartElement || cElements)
            {
                if (ulStartElement + cElements > cTotalElems || cElements == 0)
                {
                    hr = E_INVALIDARG;
                }
                else
                {
                    const CPhraseElement * pElement = m_Phrase->m_ElementList.GetHead();
                    // Skip to the first element
                    for (ULONG i = 0; i < ulStartElement; i++, pElement = pElement->m_pNext)
                    {}
                    ulRetainedStartOffset = pElement->ulRetainedStreamOffset;
                    // Skip up to the last element -- Note: Starting at 1 is correct.
                    for (i = 1; i < cElements; i++, pElement = pElement->m_pNext)
                    {}
                    ulRetainedSize = (pElement->ulRetainedStreamOffset - ulRetainedStartOffset) + pElement->ulRetainedSizeBytes;
                    if (ulRetainedSize == 0)
                    {
                        hr = SPERR_NO_AUDIO_DATA;
                    }
                }
            }
            else
            {
                cElements = cTotalElems;
            }

            if (SUCCEEDED(hr))
            {
                SPEVENT * pEvent = cElements ? STACK_ALLOC_AND_ZERO(SPEVENT, cElements) : NULL;
                if (cElements)
                {
                    const CPhraseElement * pElement = m_Phrase->m_ElementList.GetHead();
                    // Skip to the first element
                    for (ULONG i = 0; i < ulStartElement; i++, pElement = pElement->m_pNext)
                    {}
                    for (i = 0; i < cElements; i++, pElement = pElement->m_pNext)
                    {
                        pEvent[i].eEventId = SPEI_WORD_BOUNDARY;
                        pEvent[i].elParamType = SPET_LPARAM_IS_UNDEFINED;
                        pEvent[i].ullAudioStreamOffset = pElement->ulRetainedStreamOffset - ulRetainedStartOffset;
                        pEvent[i].lParam = i;
                        pEvent[i].wParam = 1;
                    }
                }
                CComObject<CSpResultAudioStream> * pStream;
                hr = CComObject<CSpResultAudioStream>::CreateInstance(&pStream);
                if (SUCCEEDED(hr))
                {
                    pStream->AddRef();

                    hr = pStream->Init(m_pResultHeader->ulRetainedDataSize,
                                       ((BYTE*)m_pResultHeader) + m_pResultHeader->ulRetainedOffset,
                                       ulRetainedStartOffset, ulRetainedSize,
                                       pEvent, cElements);
                }
                if (SUCCEEDED(hr))
                {
                    *ppStream = pStream;
                }
                else
                {
                    *ppStream = NULL;
                    pStream->Release();
                }
            }
        }
        else
        {
            hr = SPERR_NO_AUDIO_DATA;
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/*****************************************************************************
* CSpResult::SpeakAudio *
*-----------------------*
*   Description:
*       This method creates is a shortcut that calls GetAudio and then calls
*       SpeakStream on the context's associated voice.
*
********************************************************************* RAP ***/

STDMETHODIMP CSpResult::SpeakAudio(ULONG ulStartElement, ULONG cElements, DWORD dwFlags, ULONG * pulStreamNumber)
{
    HRESULT hr;
    CComPtr<ISpStreamFormat> cpStream;

    // Note: Parameter validation is done in CSpResult::GetAudio()
    hr = GetAudio(ulStartElement, cElements, &cpStream);
    if (SUCCEEDED(hr))
    {
        CComPtr<ISpVoice> cpVoice;
        hr = m_pCtxt->GetVoice(&cpVoice);
        if (SUCCEEDED(hr))
        {
            hr = cpVoice->SpeakStream(cpStream, dwFlags, pulStreamNumber);
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpResult::Serialize *
*----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CSpResult::Serialize(SPSERIALIZEDRESULT ** ppCoMemSerializedResult)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CSpResult::Serialize");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppCoMemSerializedResult))
    {
        hr = E_POINTER;
    }
    else
    {
        const ULONG cb = m_pResultHeader->ulSerializedSize;
        *ppCoMemSerializedResult = (SPSERIALIZEDRESULT *)::CoTaskMemAlloc(cb);
        if (*ppCoMemSerializedResult)
        {
            memcpy(*ppCoMemSerializedResult, m_pResultHeader, cb);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
 
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CSpResult::ScaleAudio *
*-----------------------*
*   Description:
*
*   Returns:
*
****************************************************************** YUNUSM ***/
STDMETHODIMP CSpResult::ScaleAudio(const GUID *pAudioFormatId, const WAVEFORMATEX *pWaveFormatEx)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CSpResult::ScaleAudio");
    HRESULT hr = S_OK;
  
    CSpStreamFormat cpValidateFormat;
    if (FAILED(cpValidateFormat.ParamValidateAssignFormat(*pAudioFormatId, pWaveFormatEx, TRUE)))
    {
        return E_INVALIDARG;
    }
    if( m_pResultHeader->ulPhraseDataSize == 0 ||
        m_pResultHeader->ulRetainedOffset    == 0 ||
        m_pResultHeader->ulRetainedDataSize  == 0 )
    {
        return SPERR_NO_AUDIO_DATA;
    }

    // Get the audio format of the audio currently in the result object
    ULONG cbFormatHeader;
    CSpStreamFormat cpStreamFormat;
    hr = cpStreamFormat.Deserialize(((BYTE*)m_pResultHeader) + m_pResultHeader->ulRetainedOffset, &cbFormatHeader);
    if (SUCCEEDED(hr))
    {
        if (FAILED(cpValidateFormat.ParamValidateAssignFormat(cpStreamFormat.FormatId(), cpStreamFormat.WaveFormatExPtr(), TRUE)))
        {
            hr = SPERR_UNSUPPORTED_FORMAT;
        }
    }
    if (m_listpAlts.GetCount() != 0)
    {
        // Cannot scale the audio whilst we have created alternates.
        // Their positioning information would get out of date.
        hr = SPERR_ALTERNATES_WOULD_BE_INCONSISTENT;
    }
    if (SUCCEEDED(hr) &&
        memcmp(cpStreamFormat.WaveFormatExPtr(), pWaveFormatEx, sizeof(WAVEFORMATEX)))
    {
        ULONG cElems = m_Phrase->m_ElementList.GetCount();
        BYTE *pConvertedAudio = NULL;
        CComPtr <ISpStreamFormatConverter> cpFmtConv;
        hr = cpFmtConv.CoCreateInstance(CLSID_SpStreamFormatConverter);
        if (SUCCEEDED(hr))
        {
            // Allocate a bigger buffer just in case
            pConvertedAudio = new BYTE [static_cast<int>(2 * m_pResultHeader->ulRetainedDataSize * ((float)pWaveFormatEx->nAvgBytesPerSec/(float)cpStreamFormat.WaveFormatExPtr()->nAvgBytesPerSec))];
            if (!pConvertedAudio)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        CComObject<CSpResultAudioStream> * pResultAudioStream;
        hr = CComObject<CSpResultAudioStream>::CreateInstance(&pResultAudioStream);
        if (SUCCEEDED(hr))
        {
            hr = pResultAudioStream->Init(m_pResultHeader->ulRetainedDataSize, 
                ((BYTE*)m_pResultHeader) + m_pResultHeader->ulRetainedOffset,
                0, m_pResultHeader->ulRetainedDataSize - cbFormatHeader, NULL, 0);
        }
        if (SUCCEEDED(hr))
        {
            // Need the explicit AddRef and a Release at the end
            pResultAudioStream->AddRef();
            hr = cpFmtConv->SetBaseStream(pResultAudioStream, FALSE, FALSE);
        }
        if (SUCCEEDED(hr))
        {
            hr = cpFmtConv->SetFormat(*pAudioFormatId, pWaveFormatEx);
        }

        ULONG ulConvertedAudioSize = 0; // does not include the audio stream header
        if (SUCCEEDED(hr))
        {
            // Do the audio format conversion
            hr = cpFmtConv->Read(pConvertedAudio, 
                                static_cast<int>(2 * m_pResultHeader->ulRetainedDataSize * ((float)pWaveFormatEx->nAvgBytesPerSec/(float)cpStreamFormat.WaveFormatExPtr()->nAvgBytesPerSec)), 
                                &ulConvertedAudioSize);
        }
        SPRESULTHEADER * pNewPhraseHdr = NULL;
        if (SUCCEEDED(hr))
        {
            // (m_pResultHeader->ullStreamPosEnd - m_pResultHeader->ullStreamPosStart) gives the true audio size while
            // m_pResultHeader->ulAudioDataSize includes the size of header (ULONG + Format GUID + WAVEFORMATEX == 40 bytes)
            // Need to correct for extra data (cbSize = this).
            ULONG ulNewPhraseHdrSize = m_pResultHeader->ulSerializedSize +
                        (ulConvertedAudioSize - (m_pResultHeader->ulRetainedDataSize - cbFormatHeader)) +
                        (pWaveFormatEx->cbSize - cpStreamFormat.WaveFormatExPtr()->cbSize);
            // Need the new overall scale factor to calculate the new internal header size correctly.
            pNewPhraseHdr = (SPRESULTHEADER *)::CoTaskMemAlloc(ulNewPhraseHdrSize);
            if (!pNewPhraseHdr)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                // Copy over the old SPRECORESULT and make the required changes
                CopyMemory(pNewPhraseHdr, m_pResultHeader, sizeof(SPRESULTHEADER));
                pNewPhraseHdr->ulSerializedSize = ulNewPhraseHdrSize;
                // Leave phrase header stream start and end unscaled so they are always in engine format for reference.
                // Need to add in header size (not necessarily 40 bytes).
                pNewPhraseHdr->ulRetainedDataSize = ulConvertedAudioSize + 
                                                    cbFormatHeader +
                                                    (pWaveFormatEx->cbSize - cpStreamFormat.WaveFormatExPtr()->cbSize);

                m_fRetainedScaleFactor = (float)((double)(ulConvertedAudioSize) / 
                                                 (double)(m_pResultHeader->ullStreamPosEnd - m_pResultHeader->ullStreamPosStart));

                // Copy over the old SPSERIALIZEDPHRASE and make the required changes
                SPSERIALIZEDPHRASE *pPhrase;
                hr = m_Phrase->GetSerializedPhrase(&pPhrase);
                if (SUCCEEDED(hr))
                {
                    SPSERIALIZEDPHRASE *pNewPhraseData = (SPSERIALIZEDPHRASE*)(((BYTE*)pNewPhraseHdr) + pNewPhraseHdr->ulPhraseOffset);
                    // SPSERIALIZEDPHRASE and SPINTERNALSERIALIZEDPHRASE are same
                    CopyMemory(pNewPhraseData, pPhrase, reinterpret_cast<SPINTERNALSERIALIZEDPHRASE*>(pPhrase)->ulSerializedSize);
                    ::CoTaskMemFree(pPhrase);
    
                    // Copy the converted audio to the SPRECORESULT. But first write the updated audio stream header.
                    BYTE *pbAudio = ((BYTE*)pNewPhraseHdr) + pNewPhraseHdr->ulRetainedOffset;
                    hr = pResultAudioStream->m_StreamFormat.AssignFormat(*pAudioFormatId, pWaveFormatEx);
                    if (SUCCEEDED(hr))
                    {
                        hr = pResultAudioStream->m_StreamFormat.Serialize(pbAudio);
                    }
                    if (SUCCEEDED(hr))
                    {
                        // Copy the actual PCM data
                        UINT cbCopied = pResultAudioStream->m_StreamFormat.SerializeSize();
                        CopyMemory(pbAudio + cbCopied, pConvertedAudio, ulConvertedAudioSize);
                        if (pNewPhraseHdr->ulDriverDataSize)
                        {
                            pNewPhraseHdr->ulDriverDataOffset = m_pResultHeader->ulRetainedOffset + ulConvertedAudioSize + cbCopied;
                            CopyMemory(((BYTE*)pNewPhraseHdr) + pNewPhraseHdr->ulDriverDataOffset,
                                ((BYTE*)m_pResultHeader) + m_pResultHeader->ulDriverDataOffset, m_pResultHeader->ulDriverDataSize);
                        }
                    }
                }
            }
        }
        // Convert the values in SPSERIALIZEDPHRASE
        if (SUCCEEDED(hr))
        {
            InternalScalePhrase(pNewPhraseHdr);

            // Do release and reassignment in the end
            ::CoTaskMemFree(m_pResultHeader);
            m_pResultHeader = NULL;
            hr = Init(NULL, pNewPhraseHdr);
        }
        pResultAudioStream->Release();
        delete [] pConvertedAudio;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpResult::ScalePhrase *
*------------------------*
*   Description:
*
*   Returns:
*
****************************************************************** YUNUSM ***/
STDMETHODIMP CSpResult::ScalePhrase(void)
{
    SPDBG_FUNC("CSpResult::ScalePhrase");
    HRESULT hr = S_OK;

    // Rescale the phrase audio settings if necessary.
    hr = InternalScalePhrase(m_pResultHeader);

    if (SUCCEEDED(hr))
    {
        hr = Init(NULL, m_pResultHeader);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpResult::InternalScalePhrase *
*--------------------------------*
*   Description:
*
*   Returns:
*
****************************************************************** YUNUSM ***/
STDMETHODIMP CSpResult::InternalScalePhrase(SPRESULTHEADER *pNewPhraseHdr)
{
    SPDBG_FUNC("CSpResult::InternalScalePhrase");
    HRESULT hr = S_OK;

    if( pNewPhraseHdr->ulPhraseDataSize )
    {
        SPINTERNALSERIALIZEDPHRASE *pPhraseData = reinterpret_cast<SPINTERNALSERIALIZEDPHRASE*>((reinterpret_cast<BYTE*>(pNewPhraseHdr)) + pNewPhraseHdr->ulPhraseOffset);
        hr = InternalScalePhrase(pNewPhraseHdr, pPhraseData);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CSpResult::InternalScalePhrase *
*--------------------------------*
*   Description:
*
*   Returns:
*
****************************************************************** YUNUSM ***/
STDMETHODIMP CSpResult::InternalScalePhrase(SPRESULTHEADER *pNewPhraseHdr, SPINTERNALSERIALIZEDPHRASE *pPhraseData)
{
    SPDBG_FUNC("CSpResult::InternalScalePhrase");
    HRESULT hr = S_OK;

    pPhraseData->ftStartTime = FT64(pNewPhraseHdr->times.ftStreamTime);
    // Calculate input stream position and size from engine stream position and size.
    pPhraseData->ullAudioStreamPosition = static_cast<ULONGLONG>(static_cast<LONGLONG>(pNewPhraseHdr->ullStreamPosStart) * pNewPhraseHdr->fInputScaleFactor);
    pPhraseData->ulAudioSizeBytes = static_cast<ULONG>(static_cast<LONGLONG>(pNewPhraseHdr->ullStreamPosEnd - pNewPhraseHdr->ullStreamPosStart) * pNewPhraseHdr->fInputScaleFactor);
    if (pNewPhraseHdr->ulRetainedDataSize != 0)
    {
        CSpStreamFormat spTmpFormat;
        ULONG cbFormatHeader;
        hr = spTmpFormat.Deserialize(((BYTE*)pNewPhraseHdr) + pNewPhraseHdr->ulRetainedOffset, &cbFormatHeader);
        if (SUCCEEDED(hr))
        {
            pPhraseData->ulRetainedSizeBytes = pNewPhraseHdr->ulRetainedDataSize - cbFormatHeader;
        }
    }
    else
    {
        pPhraseData->ulRetainedSizeBytes = 0;
    }
    if (SUCCEEDED(hr))
    {
        pPhraseData->ulAudioSizeTime = static_cast<ULONG>(pNewPhraseHdr->times.ullLength);

        SPSERIALIZEDPHRASEELEMENT *pElems = reinterpret_cast<SPSERIALIZEDPHRASEELEMENT*>((reinterpret_cast<BYTE*>(pPhraseData)) + pPhraseData->pElements);
        ULONG cElems = pPhraseData->Rule.ulCountOfElements;
        for (UINT i = 0; i < cElems; i++)
        {
            // Calculate retained stream offsets/sizes from engine-set stream offsets/sizes.
            if (pPhraseData->ulRetainedSizeBytes != 0)
            {
                // We are going to align every stream position to a 4-byte boundary. This means all
                //  PCM formats will be aligned correctly on sample boundaries.
                // However for ADPCM and other formats with larger size samples this won't necessarily work
                //  - really we should be looking at the block align value of the retained format and aligning to that.
                pElems[i].ulRetainedStreamOffset = static_cast<ULONG>(static_cast<float>(pElems[i].ulAudioStreamOffset) * m_fRetainedScaleFactor);
                pElems[i].ulRetainedStreamOffset -= pElems[i].ulRetainedStreamOffset % 4;
                pElems[i].ulRetainedSizeBytes = static_cast<ULONG>(pElems[i].ulAudioSizeBytes * m_fRetainedScaleFactor);
                pElems[i].ulRetainedSizeBytes -= pElems[i].ulRetainedSizeBytes % 4;
            }
            else
            {
                // Audio discarded. Alternate elements need 0 audio data.
                pElems[i].ulRetainedStreamOffset = 0;
                pElems[i].ulRetainedSizeBytes = 0;
            }
            // Convert engine-set stream offsets/sizes to equivalent input format settings.
            pElems[i].ulAudioStreamOffset = static_cast<ULONG>(static_cast<float>(pElems[i].ulAudioStreamOffset) * pNewPhraseHdr->fInputScaleFactor);
            pElems[i].ulAudioSizeBytes = static_cast<ULONG>(pElems[i].ulAudioSizeBytes * pNewPhraseHdr->fInputScaleFactor);
            // Calculate input/engine/retained time offsets/sizes from engine-set stream offsets/sizes.
            pElems[i].ulAudioTimeOffset = static_cast<ULONG>(pElems[i].ulAudioStreamOffset * pNewPhraseHdr->fTimePerByte);
            pElems[i].ulAudioSizeTime = static_cast<ULONG>(pElems[i].ulAudioSizeBytes * pNewPhraseHdr->fTimePerByte);
        }
        // Take care of rounding errors in the last element
        if ( cElems != 0 &&
             ((pElems[cElems-1].ulRetainedStreamOffset + pElems[cElems-1].ulRetainedSizeBytes) 
              > pPhraseData->ulRetainedSizeBytes) )
        {
            pElems[cElems-1].ulRetainedSizeBytes = pPhraseData->ulRetainedSizeBytes - pElems[cElems-1].ulRetainedStreamOffset;
            pElems[cElems-1].ulRetainedSizeBytes -= pElems[cElems-1].ulRetainedSizeBytes % 4;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpResult::GetRecoContext *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CSpResult::GetRecoContext(ISpRecoContext ** ppRecoContext)
{
    SPDBG_FUNC("CSpResult::GetRecoContext");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppRecoContext))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppRecoContext = m_pCtxt;
        (*ppRecoContext)->AddRef();
    }
    

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CSpResultAudioStream::Init *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSpResultAudioStream::Init(ULONG cbAudioSizeIncFormat, const BYTE * pAudioDataIncFormat,
                                   ULONG ulAudioStartOffset, ULONG ulAudioSize,
                                   const SPEVENT * pEvents, ULONG cEvents)
{
    SPDBG_FUNC("CSpResultAudioStream::Init");
    HRESULT hr = S_OK;

    ULONG cbFormatHeader;
    hr = m_StreamFormat.Deserialize(pAudioDataIncFormat, &cbFormatHeader);
    if (SUCCEEDED(hr))
    {
        const BYTE * pAudio = pAudioDataIncFormat + cbFormatHeader + ulAudioStartOffset;
        m_pData = new BYTE[ulAudioSize];
        if (m_pData)
        {
            m_cbDataSize = ulAudioSize;
            memcpy(m_pData, pAudio, ulAudioSize);
            if (cEvents)
            {
                hr = m_SpEventSource._AddEvents(pEvents, cEvents);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        // On failure, destructor will clean up for us..
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}




/****************************************************************************
* CSpResultAudioStream::Read *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CSpResultAudioStream::Read(void * pv, ULONG cb, ULONG * pcbRead)
{
    SPDBG_FUNC("CSpResultAudioStream::Read");
    HRESULT hr = S_OK;

    if (SPIsBadWritePtr(pv, cb) || SP_IS_BAD_OPTIONAL_WRITE_PTR(pcbRead))
    {
        hr = STG_E_INVALIDPOINTER;
    }
    else
    {
        ULONG cbRead = m_cbDataSize - m_ulCurSeekPos;
        if (cbRead > cb)
        {
            cbRead = cb;
        }
        memcpy(pv, m_pData + m_ulCurSeekPos, cbRead);
        m_ulCurSeekPos += cbRead;
        if (pcbRead)
        {
            *pcbRead = cbRead;
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpResultAudioStream::Seek *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CSpResultAudioStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    SPDBG_FUNC("CSpResultAudioStream::Seek");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(plibNewPosition))
    {
        hr = STG_E_INVALIDPOINTER;
    }
    else
    {
        LONGLONG llOrigin;
        switch (dwOrigin)
        {
        case STREAM_SEEK_SET:
            llOrigin = 0;
            break;
        case STREAM_SEEK_CUR:
            llOrigin = m_ulCurSeekPos;
            break;
        case STREAM_SEEK_END:
            llOrigin = m_cbDataSize;
            break;
        default:
            hr = STG_E_INVALIDFUNCTION;
        }
        if (SUCCEEDED(hr))
        {
            LONGLONG llPos = llOrigin + dlibMove.QuadPart;
            if (llPos < 0 || llPos > m_cbDataSize)
            {
                hr = STG_E_INVALIDFUNCTION;
            }
            else
            {
                m_ulCurSeekPos = static_cast<ULONG>(llPos);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpResultAudioStream::Stat *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CSpResultAudioStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SPDBG_FUNC("CSpResultAudioStream::Stat");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pstatstg))
    {
        hr = STG_E_INVALIDPOINTER;
    }
    else
    {
        if (grfStatFlag & (~STATFLAG_NONAME))
        {
            hr = STG_E_INVALIDFLAG;
        }
        else
        {
            //
            //  It is acceptable to simply fill in the size and type fields and zero the rest.
            //  This is what streams created by CreateStreamOnHGlobal return.
            //
            ZeroMemory(pstatstg, sizeof(*pstatstg));
            pstatstg->type = STGTY_STREAM;
            pstatstg->cbSize.LowPart = m_cbDataSize;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpResultAudioStream::GetFormat *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSpResultAudioStream::GetFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CSpResultAudioStream::GetFormat");
    HRESULT hr = S_OK;

    hr = m_StreamFormat.CopyTo(pFormatId, ppCoMemWaveFormatEx);    

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spresult.h ===
// SpResult.h : Declaration of the CSpResult

#ifndef __SPRESULT_H_
#define __SPRESULT_H_

#include "resource.h"       // main symbols
#include "speventq.h"
#include "spphrase.h"
#include "spcollec.h"
#include "StreamHlp.h"

///interface SpContextPrivate; // defined in recoctxt.h

class CRecoCtxt;

////////////////////////////////////////////////////////////////////////////
// CSpResult
class ATL_NO_VTABLE CSpResult;
class ATL_NO_VTABLE CSpPhraseAlt;
class ATL_NO_VTABLE CRecoContext;

typedef CComObject<CSpResult> CSpResultObject;

class ATL_NO_VTABLE CSpResult : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpRecoResult
#ifdef SAPI_AUTOMATION
    , public IDispatchImpl<ISpeechRecoResult, &IID_ISpeechRecoResult, &LIBID_SpeechLib, 5>
#endif SAPI_AUTOMATION

{
private:
    float               m_fRetainedScaleFactor;

public:
    CSpResultObject *   m_pNext;           // weak reference
    SPRESULTHEADER *    m_pResultHeader;
    BOOL                m_fWeakCtxtRef;
    CRecoCtxt      *    m_pCtxt;
    CComPtr<CPhrase>    m_Phrase;

    CSpResult() : m_pNext(NULL), m_pResultHeader(NULL), m_pAltRequest(NULL), m_pCtxt(NULL)
    {
        CComObject<CPhrase> *pPhrase;
        CComObject<CPhrase>::CreateInstance(&pPhrase);
        m_Phrase = pPhrase;
        m_fWeakCtxtRef = FALSE;
        m_fRetainedScaleFactor = 0.0F;
        m_fUseTextReplacements = VARIANT_TRUE;
    }

    void FinalRelease();

    void RemoveAllAlternates();
    void RemoveAlternate(CSpPhraseAlt *pAlt);

    HRESULT CommitAlternate(SPPHRASEALT *pAlt);
    HRESULT DeserializeCnCAlternates( ULONG ulRequestCount, ISpPhraseAlt **ppAlts, ULONG *pcAltsReturned );
    
DECLARE_GET_CONTROLLING_UNKNOWN();
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSpResult)
	COM_INTERFACE_ENTRY(ISpPhrase)
	COM_INTERFACE_ENTRY(ISpRecoResult)
#ifdef SAPI_AUTOMATION
    COM_INTERFACE_ENTRY(ISpeechRecoResult)
    COM_INTERFACE_ENTRY(IDispatch)
#endif // SAPI_AUTOMATION
END_COM_MAP()

    //
    // ISpRecoResult
    //
    STDMETHODIMP GetResultTimes(SPRECORESULTTIMES *pTimes);
    STDMETHODIMP GetAlternates(ULONG ulAltCount, ULONG ulStartElement, ULONG cElements,
                            ISpPhraseAlt **ppPhrases, ULONG *pcPhrasesReturned);
    STDMETHODIMP Serialize(SPSERIALIZEDRESULT ** ppCoMemSerializedResult);
    STDMETHODIMP GetAudio(ULONG ulStartElement, ULONG cElements, ISpStreamFormat **ppStream);
    STDMETHODIMP SpeakAudio(ULONG ulStartElement, ULONG cElements, DWORD dwFlags, ULONG * pulStreamNumber);
    STDMETHODIMP ScaleAudio(const GUID *pAudioFormatId, const WAVEFORMATEX *pWaveFormatEx);

    //
    //  ISpPhrase
    //
    STDMETHODIMP GetPhrase(SPPHRASE ** ppPhrase)
    {
        return m_Phrase->GetPhrase(ppPhrase);
    }

    STDMETHODIMP GetSerializedPhrase(SPSERIALIZEDPHRASE ** ppPhrase)
    {
        return m_Phrase->GetSerializedPhrase(ppPhrase);
    }

    STDMETHODIMP GetText(ULONG ulStart, ULONG ulCount, BOOL fUseTextReplacements, 
                        WCHAR ** ppszCoMemText, BYTE * pbDisplayAttributes)
    {
        return m_Phrase->GetText(ulStart, ulCount, fUseTextReplacements, 
                                    ppszCoMemText, pbDisplayAttributes);
    }

    STDMETHODIMP Discard(DWORD dwFlags);
    STDMETHODIMP GetRecoContext(ISpRecoContext ** ppRecoContext);

#ifdef SAPI_AUTOMATION
    //--- ISpeechRecoResult -----------------------------------------------------
    STDMETHODIMP get_RecoContext( ISpeechRecoContext** RecoContext );
    STDMETHODIMP get_Times( ISpeechRecoResultTimes** Times );
    STDMETHODIMP putref_AudioFormat( ISpeechAudioFormat* pFormat );
    STDMETHODIMP get_AudioFormat( ISpeechAudioFormat** ppFormat );
    STDMETHODIMP get_PhraseInfo( ISpeechPhraseInfo** ppPhraseInfo );
    STDMETHODIMP Alternates( long lRequestCount, long lStartElement, 
                             long cElements, ISpeechPhraseAlternates** Alternates );
    STDMETHODIMP Audio( long lStartElement, long cElements, ISpeechMemoryStream **Stream );
    STDMETHODIMP SpeakAudio( long lStartElement, long cElements, SpeechVoiceSpeakFlags eFlags, long* StreamNumber );
    STDMETHODIMP SaveToMemory( VARIANT* ResultBlock );
    STDMETHODIMP DiscardResultInfo( SpeechDiscardType DiscardTypes );
#endif // SAPI_AUTOMATION

#ifdef _WIN32_WCE
    // Dummy Compare funcs are here because the CE compiler
    // is expanding templates for functions that aren't being called

    static LONG Compare(const CSpResult *, const CSpResult *)
    {
        return 0;
    }
#endif

    HRESULT Init(CRecoCtxt * pParent, SPRESULTHEADER *pPhrase);
    void WeakCtxtRef(BOOL fWeakCtxtRef);

    STDMETHODIMP ScalePhrase(void);
    
private:
    STDMETHODIMP InternalScalePhrase(SPRESULTHEADER *pNewPhraseHdr);
    STDMETHODIMP InternalScalePhrase(SPRESULTHEADER *pNewPhraseHdr, SPINTERNALSERIALIZEDPHRASE *pPhraseData);

    // We hold a pointer to the latest request, for correction
    SPPHRASEALTREQUEST * m_pAltRequest;
    
    // We hold the list of alternates we've passed out so we can kill
    // them when we're released
    CSPList<CSpPhraseAlt*, CSpPhraseAlt*> m_listpAlts;

    VARIANT_BOOL    m_fUseTextReplacements;
};




class ATL_NO_VTABLE CSpResultAudioStream : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public ISpStreamFormat,
    public ISpEventSource
#ifdef SAPI_AUTOMATION
    , public IDispatchImpl<ISpeechMemoryStream, &IID_ISpeechMemoryStream, &LIBID_SpeechLib, 5>
#endif SAPI_AUTOMATION
{
public:
    CSpEventSource  m_SpEventSource;
    CSpStreamFormat m_StreamFormat;
    ULONG           m_cbDataSize;
    ULONG           m_ulCurSeekPos;
    BYTE *          m_pData;

BEGIN_COM_MAP(CSpResultAudioStream)
	COM_INTERFACE_ENTRY(IStream)
    COM_INTERFACE_ENTRY(ISpStreamFormat)
    COM_INTERFACE_ENTRY(ISpEventSource)
    COM_INTERFACE_ENTRY(ISpNotifySource)
#ifdef SAPI_AUTOMATION
    COM_INTERFACE_ENTRY(ISpeechMemoryStream)
    COM_INTERFACE_ENTRY(ISpeechBaseStream)
    COM_INTERFACE_ENTRY(IDispatch)
#endif // SAPI_AUTOMATION
END_COM_MAP()

DECLARE_SPEVENTSOURCE_METHODS(m_SpEventSource)

    CSpResultAudioStream() :
        m_SpEventSource(this),
        m_cbDataSize(0),
        m_ulCurSeekPos(0),
        m_pData(NULL)
    {
        m_SpEventSource._SetInterest(SPFEI(SPEI_WORD_BOUNDARY), SPFEI(SPEI_WORD_BOUNDARY));
    }

    ~CSpResultAudioStream()
    {
        delete[] m_pData;
    }

    HRESULT Init(ULONG cbAudioSizeIncFormat, const BYTE * pAudioDataIncFormat,
                 ULONG ulAudioStartOffset, ULONG ulAudioSize,
                 const SPEVENT * pEvents, ULONG cEvents);

    //
    //  IStream
    //
    STDMETHODIMP Read(void * pv, ULONG cb, ULONG * pcbRead);
    STDMETHODIMP Write(const void * pv, ULONG cb, ULONG * pcbWritten)
    {
        return STG_E_ACCESSDENIED;
    }
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) 
    {
        return STG_E_ACCESSDENIED;
    }
    STDMETHODIMP CopyTo(IStream *pStreamDest, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
        return SpGenericCopyTo(this, pStreamDest, cb, pcbRead, pcbWritten);
    }
    STDMETHODIMP Commit(DWORD grfCommitFlags)
    {
        return S_OK;
    }
    STDMETHODIMP Revert(void) 
    {
        return E_NOTIMPL; 
    }
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) 
    {
        return E_NOTIMPL;  
    }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        return E_NOTIMPL; 
    }
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream ** ppstm)
    {
        return E_NOTIMPL;
    }
    //
    //  ISpStreamFormat
    //
    STDMETHODIMP GetFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);

#ifdef SAPI_AUTOMATION
    //--- ISpeechMemoryStream -------------------------------------------------------
    STDMETHODIMP get_Format(ISpeechAudioFormat** StreamFormat);
    STDMETHODIMP putref_Format(ISpeechAudioFormat* StreamFormat) { return E_FAIL; };
    STDMETHODIMP Read(VARIANT* Buffer, long NumBytes, long* BytesRead);
    STDMETHODIMP Write(VARIANT Buffer, long* BytesWritten) { return STG_E_ACCESSDENIED; };
    STDMETHODIMP Seek(VARIANT Position, SpeechStreamSeekPositionType Origin, VARIANT* NewPosition);
    STDMETHODIMP SetData(VARIANT Data) { return STG_E_ACCESSDENIED; };
    STDMETHODIMP GetData(VARIANT* pData);

#endif // SAPI_AUTOMATION
};


#endif //__SPRESULT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spsapiserver.h ===
/****************************************************************************
*   SpSapiServer.h
*       Represent our sever process
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------
#include "sapi.h"
#include "resource.h"

//--- Class, Struct and Union Definitions -----------------------------------

class CSpSapiServer :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpSapiServer, &CLSID_SpSapiServer>,
    public ISpSapiServer,
    public ISpThreadTask
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_SPSAPISERVER)

    BEGIN_COM_MAP(CSpSapiServer)
        COM_INTERFACE_ENTRY(ISpSapiServer)
    END_COM_MAP()

//=== Public methods ===
public:

    //---  ctor, dtor
    CSpSapiServer();
    ~CSpSapiServer();

    //--- ATL methods
    HRESULT FinalConstruct();
    void FinalRelease();
    
    //--- ISpThreadTask -----------------------------------------------------
    STDMETHODIMP InitThread(
                     void * pvTaskData,
                     HWND hwnd);
    STDMETHODIMP ThreadProc(
                     void *pvTaskData,
                     HANDLE hExitThreadEvent,
                     HANDLE hNotifyEvent,
                     HWND hwndWorker,
                     volatile const BOOL * pfContinueProcessing);
    LRESULT STDMETHODCALLTYPE WindowMessage(
                     void *pvTaskData,
                     HWND hWnd,
                     UINT Msg,
                     WPARAM wParam,
                     LPARAM lParam);

    //--- Server connection -------------------------------------------------
    static HRESULT CreateServerObjectFromClient(REFCLSID clsidServerObj, HWND hwndClient, UINT uMsgToSendToClient);

//=== Public Interfaces ===
public:

    //--- ISpSapiServer -----------------------------------------------------
    STDMETHODIMP Run();

    STDMETHODIMP StartTrackingObject(IUnknown * punk);
    STDMETHODIMP StopTrackingObject(IUnknown * punk);
    
//=== Private methods ===
private:

    static HRESULT ObtainStartingOrConnectingToServerMutex(HANDLE * phmutex);
    static void ReleaseStartingOrConnectingToServerMutex(HANDLE hmutex);
    static HRESULT StartServerFromClient(HWND * phwndServer);
    
    HRESULT CreateServerObjectFromServer(PCOPYDATASTRUCT pcds);
    HRESULT AttemptShutdown();
    
//=== Private data ===
private:

    HANDLE m_hmutexRun ;
    HANDLE m_heventIsServerAlive;
    HANDLE m_heventStopServer;
    
    ULONG m_cObjects;
    
    HWND m_hwnd;
    CComPtr<ISpThreadControl> m_cpThreadControl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spserverpr.cpp ===
// SpServerPr.cpp : Implementation of CSpServerPr
#include "stdafx.h"
#include "SpServerPr.h"

#include "SpObjectRef.h"

/////////////////////////////////////////////////////////////////////////////
// CSpObjectRef

/*****************************************************************************
* CSpObjectRef::Release *
*-----------------------*
*   Description:
*       This is an IUnknown method.  It decrements the object's ref count and
*       if the count goes to 0, then it calls the server proxy object to
*       release the linked stub object which exists in the local server's
*       process.
********************************************************************* RAP ***/
ULONG STDMETHODCALLTYPE CSpObjectRef::Release(void)
{
    ULONG l;

    l = --m_cRef;
    if (l == 0)
    {
        if (m_cpServer)
        {
            m_cpServer->ReleaseObject(m_pObjPtr);
            m_cpServer.Release();
        }
        delete this;
    }
    return l;
}


/////////////////////////////////////////////////////////////////////////////
// CSpServerPr

// IMarshal methods
/*****************************************************************************
* CSpServerPr::UnmarshalInterface *
*---------------------------------*
*   Description:
*       This is an IMarshal method.  It is called when this proxy object gets
*       created inproc to allow the stub object in the local server process to
*       pass information in an IStream.  In our case the stub passes 3 items:
*       the server's receiver hWnd, a link to the server object (CSpServer),
*       and the server's process id.  We simply save these away in member
*       variables so they can be retrieved with our
*       ISpServerConnection::GetConnection method.
********************************************************************* RAP ***/
STDMETHODIMP CSpServerPr::UnmarshalInterface(
    /*[in], unique]*/ IStream *pStm,
    /*[in]*/ REFIID riid,
    /*[out]*/ void **ppv)
{
    HRESULT hr;
    DWORD read;

    hr = pStm->Read(&m_hServerWnd, sizeof(m_hServerWnd), &read);
    if (FAILED(hr) || read != sizeof(m_hServerWnd))
        return RPC_E_INVALID_DATA;

    hr = pStm->Read(&m_pServerHalf, sizeof(m_pServerHalf), &read);
    if (FAILED(hr) || read != sizeof(m_pServerHalf))
        return RPC_E_INVALID_DATA;

	hr = pStm->Read(&m_dwServerProcessID, sizeof(m_dwServerProcessID), &read);
    if (FAILED(hr) || read != sizeof(m_dwServerProcessID))
        return RPC_E_INVALID_DATA;

    return QueryInterface(riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spsemaphore.h ===
#pragma once

#ifndef _WIN32_WCE
class CSpSemaphore
{
public:
    HANDLE      m_hSemaphore;
    CSpSemaphore() : m_hSemaphore(NULL) {}
    ~CSpSemaphore()
    {
        if (m_hSemaphore)
        {
            ::CloseHandle(m_hSemaphore);
        }
    }
    void Close()
    {
        if (m_hSemaphore)
        {
            ::CloseHandle(m_hSemaphore);
            m_hSemaphore = NULL;
        }
    }
    HRESULT Init(LONG lInitialCount)
    {
        SPDBG_ASSERT(!m_hSemaphore);
        m_hSemaphore = ::CreateSemaphore(NULL, lInitialCount, 0x7FFFFFFF, NULL);
        if (!m_hSemaphore)
        {
            return SpHrFromLastWin32Error();
        }
        return S_OK;
    }
    void Wait(ULONG msTimeOut)
    {
        ::WaitForSingleObject(m_hSemaphore, msTimeOut);
    }
    void ReleaseSemaphore(LONG lReleaseCount)
    {
        ::ReleaseSemaphore(m_hSemaphore, lReleaseCount, NULL);
    }
};
#else
class CSpSemaphore
{
public:
    HANDLE      m_hEvent;
    LONG        m_lCount;
    CRITICAL_SECTION m_CritSec;
    CSpSemaphore()
    {
        m_hEvent = NULL;
        ::InitializeCriticalSection(&m_CritSec);
    }
    ~CSpSemaphore()
    {
        if (m_hEvent)
        {
            ::CloseHandle(m_hEvent);
        }
        ::DeleteCriticalSection(&m_CritSec);
    }
    void Close()
    {
        if (m_hEvent)
        {
            ::CloseHandle(m_hEvent);
            m_hEvent = NULL;
        }
    }
    HRESULT Init(LONG lInitialCount)
    {
        SPDBG_ASSERT(!m_hEvent);
        m_lCount = lInitialCount;
        m_hEvent = ::CreateEvent(NULL, FALSE, (lInitialCount > 0), NULL);
        if (!m_hEvent)
        {
            return SpHrFromLastWin32Error();
        }
        return S_OK;
    }
    DWORD Wait(ULONG msTimeOut)
    {
        DWORD dwWaitResult = ::WaitForSingleObject(m_hEvent, msTimeOut);
        if (dwWaitResult == WAIT_OBJECT_0)
        {
            ::EnterCriticalSection(&m_CritSec);
            m_lCount--;
            BOOL bWakeSomeoneUp = (m_lCount > 0);
            ::LeaveCriticalSection(&m_CritSec);
            if (bWakeSomeoneUp)
            {
                ::SetEvent(m_hEvent);
            }
        }
        return dwWaitResult;
    }
    void ReleaseSemaphore(LONG lReleaseCount)
    {
        ::EnterCriticalSection(&m_CritSec);
        m_lCount += lReleaseCount;
        BOOL bWakeSomeoneUp = (m_lCount > 0);
        ::LeaveCriticalSection(&m_CritSec);
        if (bWakeSomeoneUp)
        {
            ::SetEvent(m_hEvent);
        }
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spserverpr.h ===
// SpServerPr.h : Declaration of the CSpServerPr

#ifndef __SPSERVERPR_H_
#define __SPSERVERPR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSpServerPr
class ATL_NO_VTABLE CSpServerPr : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSpServerPr, &CLSID_SpServerPr>,
    public IMarshal,
	public ISpServerConnection
{
private:
    PVOID  m_pServerHalf;       // server process address for base object
    HWND   m_hServerWnd;        // server receiver window handle
	DWORD  m_dwServerProcessID;	// server process id

public:
    CSpServerPr() : m_pServerHalf(NULL), m_hServerWnd(NULL)
    {}

DECLARE_REGISTRY_RESOURCEID(IDR_SPSERVERPR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSpServerPr)
	COM_INTERFACE_ENTRY(ISpServerConnection)
    COM_INTERFACE_ENTRY(IMarshal)
END_COM_MAP()

// IMarshal
    STDMETHODIMP GetUnmarshalClass
    (
        /*[in]*/ REFIID riid,
        /*[in], unique]*/ void *pv,
        /*[in]*/ DWORD dwDestContext,
        /*[in], unique]*/ void *pvDestContext,
        /*[in]*/ DWORD mshlflags,
        /*[out]*/ CLSID *pCid
    )
    {
	    ATLTRACENOTIMPL(_T("GetUnmarshalClass"));
    }

    STDMETHODIMP GetMarshalSizeMax
    (
        /*[in]*/ REFIID riid,
        /*[in], unique]*/ void *pv,
        /*[in]*/ DWORD dwDestContext,
        /*[in], unique]*/ void *pvDestContext,
        /*[in]*/ DWORD mshlflags,
        /*[out]*/ DWORD *pSize
    )
    {
	    ATLTRACENOTIMPL(_T("GetMarshalSizeMax"));
    }

    STDMETHODIMP MarshalInterface
    (
        /*[in], unique]*/ IStream *pStm,
        /*[in]*/ REFIID riid,
        /*[in], unique]*/ void *pv,
        /*[in]*/ DWORD dwDestContext,
        /*[in], unique]*/ void *pvDestContext,
        /*[in]*/ DWORD mshlflags
    )
    {
	    ATLTRACENOTIMPL(_T("MarshalInterface"));
    }

    STDMETHODIMP UnmarshalInterface
    (
        /*[in], unique]*/ IStream *pStm,
        /*[in]*/ REFIID riid,
        /*[out]*/ void **ppv
    );

    STDMETHODIMP ReleaseMarshalData
    (
        /*[in], unique]*/ IStream *pStm
    )
    {
	    ATLTRACENOTIMPL(_T("ReleaseMarshalData"));
    }

    STDMETHODIMP DisconnectObject
    (
        /*[in]*/ DWORD dwReserved
    )
    {
	    ATLTRACENOTIMPL(_T("DisconnectObject"));
    }

// ISpServerConnection
public:
  	STDMETHODIMP GetConnection(void **ppServerHalf, HWND *phServerWnd, DWORD *pdwServerProcessID)
    {
        *ppServerHalf = m_pServerHalf;
        *phServerWnd = m_hServerWnd;
		*pdwServerProcessID = m_dwServerProcessID;
        return S_OK;
    }
};

#endif //__SPSERVERPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spsapiserver.cpp ===
/****************************************************************************
*   SpSapiServer.cpp
*       Represent our sever process
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "SpSapiServer.h"
#include "spsapiserverhelper.inl"

#define SERVER_RECEIVE_THREAD_STOP_TIMEOUT  500

#define STARTING_OR_CONNECTING_TO_SERVER_MUTEX_NAME _T("SapiServerStartingOrConnecting")
#define STARTING_OR_CONNECTING_TO_SERVER_MUTEX_TIMEOUT 5000

#define SPCCDS_SAPISVR_CREATE_SERVER_OBJECT -3

#define WM_SAPISVR_STOP_TRACKING_OBJECT (WM_USER + 100)

#define ATTEMPT_SHUTDOWN_TIMER_ID   1
#define ATTEMPT_SHUTDOWN_TIMER_TIME 100

#define STOP_RUNNING_TIMEOUT    5000

#define SERVER_RUN_MUTEX_NAME   _T("SapiServerRun")

const TCHAR * g_pszSapiServerReceiverWindowText = _T("SapiServerReciever");
const TCHAR * g_pszSapiServerReceiverWindowClass = _T("CSpThreadTask Window"); // From taskmgr.cpp, szClassName

typedef struct SPCREATESERVEROBJECT
{
    HWND hwndClient;
    UINT uMsgClient;
    CLSID clsidServerObject;
    DWORD dwClientProcessId;
} SPCREATESERVEROBJECT;
    
CSpSapiServer::CSpSapiServer()
{
    m_cObjects = 0;
    m_hwnd = NULL;

    m_hmutexRun = NULL;
    m_heventIsServerAlive = NULL;
    m_heventStopServer = NULL;
}

CSpSapiServer::~CSpSapiServer()
{
}

HRESULT CSpSapiServer::FinalConstruct()
{
    SPDBG_FUNC("CSpSapiServer::FinalConstruct");
    HRESULT hr = S_OK;

    // Create the events and the mutex we'll use to control running the server
    if (SUCCEEDED(hr))
    {
        hr = SpCreateIsServerAliveEvent(&m_heventIsServerAlive);
    }

    if (SUCCEEDED(hr))
    {
        m_heventStopServer = ::CreateEvent(NULL, TRUE, FALSE, NULL);
        if (m_heventStopServer == NULL)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    if (SUCCEEDED(hr))
    {
        m_hmutexRun = ::CreateMutex(NULL, FALSE, SERVER_RUN_MUTEX_NAME);
        if (m_hmutexRun == NULL)
        {
            hr = SpHrFromLastWin32Error();
        }
    }

    // Now we need to obtain the run mutex. If we can't, that means that
    // there's another sapi server running, and we should not construct
    // this one

    if (SUCCEEDED(hr))
    {
        if (::WaitForSingleObject(m_hmutexRun, 0) != WAIT_OBJECT_0)
        {
            hr = SPERR_REMOTE_PROCESS_ALREADY_RUNNING;
        }
    }

    // Create the task manager
    CComPtr<ISpTaskManager> cpTaskManager;
    if (SUCCEEDED(hr))
    {
        hr = cpTaskManager.CoCreateInstance(CLSID_SpResourceManager);
    }

    // Create the thread and get it started
    if (SUCCEEDED(hr))
    {
        hr = cpTaskManager->CreateThreadControl(this, NULL, THREAD_PRIORITY_NORMAL, &m_cpThreadControl);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpThreadControl->StartThread(0, &m_hwnd);
    }

    // We're ready to roll now, so signal our we're alive event
    if (SUCCEEDED(hr))
    {
        ::SetEvent(m_heventIsServerAlive);        
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

void CSpSapiServer::FinalRelease()
{
    SPDBG_FUNC("CSpSapiServer::FinalRelease");

    // The thread should have already been shutdown in Run
    SPDBG_ASSERT(m_cpThreadControl == NULL);
}

HRESULT CSpSapiServer::InitThread(
    void * pvTaskData,
    HWND hwnd)
{
    SPDBG_FUNC("CSpSapiServer::InitThread");
    HRESULT hr = S_OK;
    
    if (!SetWindowText(hwnd, g_pszSapiServerReceiverWindowText))
    {
        hr = SpHrFromLastWin32Error();
    }
    
    return S_OK;
}

HRESULT CSpSapiServer::ThreadProc(
    void *pvTaskData,
    HANDLE hExitThreadEvent,
    HANDLE hNotifyEvent,
    HWND hwndWorker,
    volatile const BOOL * pfContinueProcessing)
{
    SPDBG_FUNC("CSpSapiServer::ThreadProc");
    HRESULT hr = S_OK;
    
    while (*pfContinueProcessing && SUCCEEDED(hr))
    {
        DWORD dwWaitId = ::MsgWaitForMultipleObjects(
                                    1, 
                                    &hExitThreadEvent, 
                                    FALSE, 
                                    1000, 
                                    QS_ALLINPUT);    
        switch (dwWaitId)
        {
        case WAIT_OBJECT_0:
            SPDBG_ASSERT(!*pfContinueProcessing);
            break;

        default:
        case WAIT_OBJECT_0 + 1:
            MSG Msg;
            while (::PeekMessage(&Msg, NULL, 0, 0, TRUE))
            {
                ::DispatchMessage(&Msg);
            }
            break;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

LRESULT CSpSapiServer::WindowMessage(
    void *pvTaskData,
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
    SPDBG_FUNC("CSpSapiServer::WindowMessage");
    HRESULT hr = S_OK;
    LRESULT lret = 0;

    switch (Msg)
    {
        case WM_COPYDATA:
            hr = CreateServerObjectFromServer((PCOPYDATASTRUCT)lParam);
            lret = SUCCEEDED(hr);
            break;

        case WM_SAPISVR_STOP_TRACKING_OBJECT:
            LPUNKNOWN(lParam)->Release();
            if (--m_cObjects == 0)
            {
                ::SetTimer(m_hwnd, ATTEMPT_SHUTDOWN_TIMER_ID, ATTEMPT_SHUTDOWN_TIMER_TIME, NULL);
            }
            break;

        case WM_TIMER:
            SPDBG_ASSERT(wParam == ATTEMPT_SHUTDOWN_TIMER_ID);
            hr = AttemptShutdown();
            break;
            
        default:
            lret = DefWindowProc(hWnd, Msg, wParam, lParam);
            break;

    }

    SPDBG_REPORT_ON_FAIL(hr);
    return lret;
}

HRESULT CSpSapiServer::CreateServerObjectFromClient(REFCLSID clsidServerObj, HWND hwndClient, UINT uMsgToSendToClient)
{
    SPDBG_FUNC("CSpSapiServer::CreateServerObjectFromClient");
    HRESULT hr = S_OK;

    // When we start or connect to the server, we need to be inside 
    // a mutex so multiple people don't try to start the server
    // at the same time
    
    HANDLE hmutexStartingOrConnectingToServer = NULL;
    hr = ObtainStartingOrConnectingToServerMutex(&hmutexStartingOrConnectingToServer);

    // Now start the server
    HWND hwndServer;
    if (SUCCEEDED(hr))
    {
        hr = StartServerFromClient(&hwndServer);
    }

    // Now send the message to the server
    if (SUCCEEDED(hr))
    {
        // Build up the structure to send across
        SPCREATESERVEROBJECT cso;
        cso.clsidServerObject = clsidServerObj;
        cso.hwndClient = hwndClient;
        cso.uMsgClient = uMsgToSendToClient;
        cso.dwClientProcessId = ::GetCurrentProcessId();

        // Put it into a copydatastruct
        COPYDATASTRUCT cds;
        cds.dwData = SPCCDS_SAPISVR_CREATE_SERVER_OBJECT;
        cds.cbData = sizeof(cso);
        cds.lpData = &cso;

        // Send it
        BOOL fHandled = (INT)::SendMessage(hwndServer, WM_COPYDATA, (WPARAM)hwndClient, (LPARAM)&cds);
        if (!fHandled)
        {
            hr = SPERR_REMOTE_PROCESS_TERMINATED;
        }
    }

    // No matter what happend, we need to release the server mutex
    ReleaseStartingOrConnectingToServerMutex(hmutexStartingOrConnectingToServer);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpSapiServer::Run()
{
    SPDBG_FUNC("CSpSapiServer::Run");
    HRESULT hr = S_OK;

    // Just wait around until the stop server event is signaled
    if (::WaitForSingleObject(m_heventStopServer, INFINITE) != WAIT_OBJECT_0)
    {
        hr = SpHrFromLastWin32Error();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpThreadControl->WaitForThreadDone(TRUE, NULL, STOP_RUNNING_TIMEOUT);
    }

    if (SUCCEEDED(hr))
    {
        m_cpThreadControl.Release();
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpSapiServer::StartTrackingObject(IUnknown * punk)
{
    SPDBG_FUNC("CSpSapiServer::StartTrackingObject");
    HRESULT hr = S_OK;

    m_cObjects++;
    punk->AddRef();
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpSapiServer::StopTrackingObject(IUnknown * punk)
{
    SPDBG_FUNC("CSpSapiServer::StopTrackingObject");
    HRESULT hr = S_OK;

    ::PostMessage(m_hwnd, WM_SAPISVR_STOP_TRACKING_OBJECT, NULL, (LPARAM)punk);
        
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpSapiServer::ObtainStartingOrConnectingToServerMutex(HANDLE * phmutex)
{
    SPDBG_FUNC("CSpSapiServer::ObtainStartingOrConnectinToServerMutex");
    HRESULT hr = S_OK;

    // Create the named mutex
    *phmutex = CreateMutex(NULL, FALSE, STARTING_OR_CONNECTING_TO_SERVER_MUTEX_NAME);
    if (*phmutex == NULL)
    {
        hr = SpHrFromLastWin32Error();
        SPDBG_ASSERT(FAILED(hr));
    }

    // Wait for it
    if (SUCCEEDED(hr))
    {
        DWORD dwWait = ::WaitForSingleObject(*phmutex, STARTING_OR_CONNECTING_TO_SERVER_MUTEX_TIMEOUT);
        switch (dwWait)
        {
            case WAIT_TIMEOUT:
                hr = SPERR_REMOTE_CALL_TIMED_OUT;
                break;
        }
    }

    // Close the mutex if the wait failed. This prevents
    // the mutex from being Released inadvertantly
    if (FAILED(hr) && *phmutex != NULL)
    {
        ::CloseHandle(*phmutex);
        *phmutex = NULL;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

void CSpSapiServer::ReleaseStartingOrConnectingToServerMutex(HANDLE hmutex)
{
    SPDBG_FUNC("CSpSapiServer::ReleaseStartingOrConnectingToServerMutex");

    if (hmutex != NULL)
    {
        ::ReleaseMutex(hmutex);
        ::CloseHandle(hmutex);
    }
}

HRESULT CSpSapiServer::StartServerFromClient(HWND * phwndServer)
{
    SPDBG_FUNC("CSpSapiServer::StartServerFromClient");
    HRESULT hr = S_OK;

    USES_CONVERSION;

    // Get the "Is the server alive" event
    HANDLE heventIsServerAlive = NULL;
    hr = SpCreateIsServerAliveEvent(&heventIsServerAlive);

    // See if the server is really alive
    if (SUCCEEDED(hr))
    {
        DWORD dwWait = ::WaitForSingleObject(heventIsServerAlive, 0);
        if (dwWait == WAIT_TIMEOUT)
        {
            // It's not alive yet, so we'll start it...

            // Figure out where sapi.dll is
            WCHAR szSapiDir[MAX_PATH + 1];
            if (SUCCEEDED(hr))
            {
                if (g_Unicode.GetModuleFileName(_Module.GetModuleInstance(), szSapiDir, sp_countof(szSapiDir)) == 0)
                {
                    hr = SpHrFromLastWin32Error();
                }
            }

            WCHAR * pszLastSlash;
            if (SUCCEEDED(hr))
            {
                pszLastSlash = wcsrchr(szSapiDir, '\\');
                if (pszLastSlash == NULL)
                {
                    hr = E_UNEXPECTED;
                }
                else
                {
                    *pszLastSlash = '\0';
                }
            }
            
            if (SUCCEEDED(hr))
            {
                const WCHAR szSapiSvrExe[] = L"\\sapisvr.exe";
                WCHAR szApplication[MAX_PATH + 1 + sp_countof(szSapiSvrExe) + 1];
                
                wcscpy(szApplication, szSapiDir);
                wcscat(szApplication, szSapiSvrExe);
                
                STARTUPINFO si;
                memset(&si, 0, sizeof(si));
                si.cb = sizeof(si);

                PROCESS_INFORMATION pi;

                BOOL fProcessCreated = ::CreateProcess(
                                            W2T(szApplication), 
                                            NULL,
                                            NULL,
                                            NULL,
                                            FALSE, 
#ifndef _WIN32_WCE
                                            NORMAL_PRIORITY_CLASS,
#else
                                            0,
#endif
                                            NULL,
                                            NULL,
                                            &si,
                                            &pi);
                if (!fProcessCreated)
                {
                    hr = SpHrFromLastWin32Error();
                    SPDBG_ASSERT(FAILED(hr));
                }
                else
                {
                    ::CloseHandle(pi.hProcess);
                    ::CloseHandle(pi.hThread);
                }
            }

            if (SUCCEEDED(hr))
            {
                dwWait = ::WaitForSingleObject(heventIsServerAlive, SERVER_IS_ALIVE_EVENT_TIMEOUT);
                if (dwWait != WAIT_OBJECT_0)
                {
                    hr = SPERR_REMOTE_CALL_TIMED_OUT;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *phwndServer = FindWindow(
                                g_pszSapiServerReceiverWindowClass, 
                                g_pszSapiServerReceiverWindowText);
            
            if (*phwndServer == NULL)
            {
                hr = E_FAIL;
            }
        }
    }

    // Close the event, no matter what
    if (heventIsServerAlive != NULL)
    {
        ::CloseHandle(heventIsServerAlive);
    }    

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpSapiServer::CreateServerObjectFromServer(PCOPYDATASTRUCT pcds)
{
    SPDBG_FUNC("CSpSapiServer::CreateServerObjectFromServer");
    HRESULT hr = S_OK;

    SPCREATESERVEROBJECT cso;
    if (pcds->dwData == SPCCDS_SAPISVR_CREATE_SERVER_OBJECT &&
        pcds->cbData == sizeof(cso))
    {
        cso = *(SPCREATESERVEROBJECT*)pcds->lpData;

        CComPtr<ISpCommunicatorInit> cpCommunicatorInit;
        hr = cpCommunicatorInit.CoCreateInstance(cso.clsidServerObject);

        if (SUCCEEDED(hr))
        {
            hr = cpCommunicatorInit->AttachToClient(this, cso.hwndClient, cso.uMsgClient, cso.dwClientProcessId);
        }
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSpSapiServer::AttemptShutdown()
{
    SPDBG_FUNC("CSpSapiServer::AttempShutdown");
    HRESULT hr;

    // When we start or connect to the server, we need to be inside 
    // a mutex so multiple people don't try to start the server
    // at the same time

    // Therefore, we also need to obtain the mutex when we're attempting
    // to shutdown the server

    HANDLE hmutexStartingOrConnectingToServer = NULL;
    hr = ObtainStartingOrConnectingToServerMutex(&hmutexStartingOrConnectingToServer);

    if (SUCCEEDED(hr))
    {
        if (m_cObjects == 0)
        {
            // We're now dying, so reset the alive event, and tell
            // the main thread that we're done
            ::ResetEvent(m_heventIsServerAlive);           
            ::SetEvent(m_heventStopServer);
        }

        ::KillTimer(m_hwnd, ATTEMPT_SHUTDOWN_TIMER_ID);
    }

    // No matter what, release the mutex
    ReleaseStartingOrConnectingToServerMutex(hmutexStartingOrConnectingToServer);
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

#ifndef _WIN32_WCE
void CALLBACK RunSapiServer(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
#else
STDAPI RunSapiServer(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
#endif
{
    SPDBG_FUNC("RunSapiServer");
    HRESULT hr;

    SPDBG_DEBUG_SERVER_ON_START();

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        CComPtr<ISpSapiServer> cpSapiServer;
        hr = cpSapiServer.CoCreateInstance(CLSID_SpSapiServer);

        if (SUCCEEDED(hr))
        {
            hr = cpSapiServer->Run();
        }
    }

    CoUninitialize();

    SPDBG_REPORT_ON_FAIL(hr);    
#ifdef _WIN32_WCE
    return hr;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spvoice.cpp ===
/*******************************************************************************
* SpVoice.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpVoice class and
*   it's associated event management logic. This is the main SAPI5 COM object
*   for all of TTS.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 08/14/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "SpVoice.h"
#include "commonlx.h"
#include "a_helpers.h"


//#define _EVENT_DEBUG_

//--- Local
static const SPVPITCH g_InitialPitch = { 0, 0 };
static const SPVCONTEXT g_InitialContext = { NULL, NULL, NULL };

/*****************************************************************************
* CSpVoice::FinalConstruct *
*--------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CSpVoice::FinalConstruct()
{
    SPDBG_FUNC( "CSpVoice::FinalConstruct" );
    HRESULT hr = S_OK;

    //--- Init member variables
    m_fThreadRunning      = FALSE;
    m_fQueueSpeaks        = FALSE;
    m_fAudioStarted       = FALSE;
    m_ulSyncSpeakTimeout  = 10000;
    m_eVoicePriority      = SPVPRI_NORMAL;
    m_fUseDefaultVoice    = TRUE;
    m_fUseDefaultRate     = TRUE;
    m_lCurrRateAdj        = 0;
    m_usCurrVolume        = 100;
    m_lSkipCount          = 0;
    m_pCurrSI             = NULL;
    m_eAlertBoundary      = SPEI_WORD_BOUNDARY;
    m_ulPauseCount        = 0;
    m_eActionFlags        = SPVES_CONTINUE;
    m_lSkipCount          = 0;
    m_lNumSkipped         = 0;
    m_fAutoPropAllowOutFmtChanges = true;
    m_fCreateEngineFromToken      = true;
    m_fRestartSpeak               = false;
    m_fSerializeAccess    = false;
    m_ullAlertInsertionPt = UNDEFINED_STREAM_POS;
    ResetVoiceStatus();
    m_fHandlingEvent = FALSE;

    if ( SUCCEEDED( hr ) )
    {
        GetDefaultRate();
    }

    //--- Get the task manager
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpTaskMgr.CoCreateInstance( CLSID_SpResourceManager );
    }
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpTaskMgr->CreateThreadControl( this, NULL, THREAD_PRIORITY_NORMAL, &m_cpThreadCtrl);
    }

    //--- Create the format converter
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpFormatConverter.CoCreateInstance( CLSID_SpStreamFormatConverter );
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_autohPendingSpeaks.InitEvent(NULL, TRUE, FALSE, NULL);
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_ahPauseEvent.InitEvent( NULL, TRUE, TRUE, NULL );
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_ahSkipDoneEvent.InitEvent( NULL, true, false, NULL );
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_AsyncCtrlMutex.InitMutex( NULL, false, NULL );
    }

    return hr;
} /* CSpVoice::FinalConstruct */

/*****************************************************************************
* CSpVoice::FinalRelease *
*------------------------*
*   Description:
*       destructor
********************************************************************* EDC ***/
void CSpVoice::FinalRelease()
{
    SPDBG_FUNC( "CSpVoice::FinalRelease" );

    m_GlobalStateStack.Release();

    //--- Kill any pending work
    m_SpEventSource.m_cpNotifySink.Release();
    PurgeAll( );

    //--- Disconnect from receiving output event callbacks
    _ReleaseOutRefs();

} /* CSpVoice::FinalRelease */

/*****************************************************************************
* CSpVoice::_ReleaseOutRefs *
*---------------------------*
*   Description:
*       Simple helper releases all references to output streams and queues.
********************************************************************* RAL ***/
void CSpVoice::_ReleaseOutRefs()
{
    if (m_cpOutputEventSource)
    {
        m_cpOutputEventSource->SetNotifySink(NULL);
    }
    m_cpOutputStream.Release();
    m_cpFormatConverter->SetBaseStream(NULL, FALSE, TRUE);
    m_cpAudioOut.Release();
    m_cpOutputEventSink.Release();
    m_cpOutputEventSource.Release();
    m_AlertMagicMutex.Close();
    m_NormalMagicMutex.Close();
    m_AudioMagicMutex.Close();
} /* CSpVoice::_ReleaseOutRefs */

/*****************************************************************************
* CSpVoice::LazyInit *
*--------------------*
*   Description:
*      This method is used to lazily create the Engine voice and initialize
*   the XML state stacks.
********************************************************************* EDC ***/
HRESULT CSpVoice::LazyInit( void )
{
    SPDBG_FUNC( "CSpVoice::LazyInit" );
    HRESULT hr = S_OK;

    if( m_fCreateEngineFromToken )
    {
        //--- Set the default values if this is the first time
        GLOBALSTATE NewGlobalState;
        if( m_GlobalStateStack.GetCount() == 0 )
        {
            memset( &NewGlobalState, 0, sizeof(GLOBALSTATE) );
            NewGlobalState.Volume        = 100;
            NewGlobalState.PitchAdj      = g_InitialPitch;
            NewGlobalState.Context       = g_InitialContext;
            NewGlobalState.ePartOfSpeech = SPPS_Unknown;
        }
        else
        {
            //--- Otherwise preserve current settings except voice
            NewGlobalState = m_GlobalStateStack.GetBaseVal();
            NewGlobalState.cpVoice.Release();
            NewGlobalState.cpPhoneConverter.Release();
        }

        //--- Create the default voice
        if( !m_cpVoiceToken )
        {
            hr = SpGetDefaultTokenFromCategoryId( SPCAT_VOICES, &m_cpVoiceToken );
        }

        if( SUCCEEDED( hr ) )
        {
            hr = SpCreateObjectFromToken( m_cpVoiceToken, &NewGlobalState.cpVoice );
        }

        //--- Create the default phoneme converter
        if( SUCCEEDED( hr ) )
        {
            //--- Need to use m_cpVoiceToken to get LCID of default voice, and then load 
            //--- appropriate phoneme converter...
            LANGID langid;
            hr = SpGetLanguageFromVoiceToken(m_cpVoiceToken, &langid);

            if (SUCCEEDED(hr))
            {
                hr = SpCreatePhoneConverter(langid, NULL, NULL, &NewGlobalState.cpPhoneConverter);
            }
        }

        //--- All Values are set - push NewGlobalState onto GlobalStateStack[0]
        if( SUCCEEDED( hr ) )
        {
            m_GlobalStateStack.SetBaseVal( NewGlobalState );
            m_fCreateEngineFromToken = false;
        }
    }

    return hr;
} /* CSpVoice::LazyInit */

/*****************************************************************************
* CSpVoice::PurgeAll *
*--------------------*
*   Description:
*       This method synchronously purges all data that is currently in the
*   rendering pipeline.
*
*   This method must be called with the critical section unowned to ensure that
*   tasks can be killed successfully.
*
********************************************************************* EDC ***/
HRESULT CSpVoice::PurgeAll( )
{
    SPDBG_FUNC( "CSpVoice::PurgeAll" );
    HRESULT hr = S_OK;

    //--- Set the abort flag
    m_AsyncCtrlMutex.Wait();
    m_eActionFlags = SPVES_ABORT;
    m_AsyncCtrlMutex.ReleaseMutex();

    //--- Purge audio buffers
    if( m_cpAudioOut )
    {
        hr = m_cpAudioOut->SetState( SPAS_CLOSED, 0 );
        m_fAudioStarted = false;
    }

    //--- Stop the thread in any case
    if( m_cpThreadCtrl->WaitForThreadDone( TRUE, NULL, 5000 ) == S_FALSE )
    {
        //--- If we timeout, there is a problem with the TTS engine. It is not
        //    stopping within the compliance time frame.
        //    We have to just kill the thing because the thread could be hung
        //    and we don't want to hang the app. The bad thing about this is that
        //    resources will leak.
        SPDBG_DMSG1( "Timeout on Thread: 0x%X\n", m_cpThreadCtrl->ThreadId() );

        //--- We know the thread isn't doing something that will hang here, we're
        //    going to take the lock because m_pCurrSI gets updated by the thread.
        Lock();
        m_cpThreadCtrl->TerminateThread();
        delete m_pCurrSI;
        m_pCurrSI = NULL;
        Unlock();
    }

    //--- Purge all pending speak requests and reset the voice
    m_PendingSpeakList.Purge();
    m_autohPendingSpeaks.ResetEvent();

    //--- If the end stream event was lost in the audio device
    //    we force the voice status to done.
    if ((m_VoiceStatus.dwRunningState & SPRS_DONE) == 0)
    {
        // If we are in the done state, the event has been sent.
        // As we aren't, it has been lost and needs to be sent.
        InjectEvent( SPEI_END_INPUT_STREAM );
        m_SpEventSource._CompleteEvents();
    }
    ResetVoiceStatus();

    //--- Set the continue flag
    m_AsyncCtrlMutex.Wait();
    m_eActionFlags = SPVES_CONTINUE;
    m_AsyncCtrlMutex.ReleaseMutex();

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpVoice::PurgeAll */

/*****************************************************************************
* CSpVoice::ResetVoiceStatus *
*----------------------------*
*   Description:
*       
********************************************************************* RAL ***/
void CSpVoice::ResetVoiceStatus()
{
    ZeroMemory(&m_VoiceStatus, sizeof(m_VoiceStatus));
    m_VoiceStatus.dwRunningState = SPRS_DONE;
    m_dstrLastBookmark = L"";       // Set to empty string, NOT a NULL pointer.
} /* CSpVoice::ResetVoiceStatus */

/*****************************************************************************
* CSpVoice::LoadStreamIntoMem *
*-----------------------------*
*   Description:
*       This method loads and parses the stream specified in the render info
*   structure. This method must be called prior to rendering.
********************************************************************* EDC ***/
HRESULT CSpVoice::LoadStreamIntoMem( IStream* pStream, WCHAR** ppText )
{
    SPDBG_FUNC( "CSpVoice::LoadStreamIntoMem" );
    HRESULT hr = S_OK;
    WCHAR Signature = 0;
    STATSTG Stat;
    ULONG ulTextLen;

    //--- Get stream size
    hr = pStream->Stat( &Stat, STATFLAG_NONAME );

    //--- Check for unicode signature
    if( SUCCEEDED( hr ) )
    {
        hr = pStream->Read( &Signature, sizeof( WCHAR ), NULL );
    }

    if( SUCCEEDED( hr ) )
    {
        //--- Unicode source
        if( 0xFEFF == Signature )
        {
            //--- Allocate buffer for text (less the size of the signature)
            ulTextLen = (Stat.cbSize.LowPart - 1) / sizeof( WCHAR );
            *ppText = new WCHAR[ulTextLen+1];
            if( *ppText == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                //--- Load and terminate input stream
                hr = pStream->Read( *ppText, Stat.cbSize.LowPart, NULL );
                (*ppText)[ulTextLen] = 0;
            }
        }
        else //--- MBCS source
        {
            //--- Allocate buffer for text
            ulTextLen  = Stat.cbSize.LowPart;
            *ppText = new WCHAR[ulTextLen+1];
            if( *ppText == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                //--- Load the data into the upper half of the buffer
                LARGE_INTEGER li; li.QuadPart = 0;
                char* pStr = (char*)((*ppText) + (ulTextLen/2));
                pStream->Seek( li, STREAM_SEEK_SET, NULL );
                hr = pStream->Read( pStr, ulTextLen, NULL );

                //--- Convert inplace
                if( SUCCEEDED( hr ) )
                {
                    int iStat = MultiByteToWideChar( CP_ACP, 0, pStr, ulTextLen,
                                                     (*ppText), ulTextLen );
                    iStat;
                    (*ppText)[ulTextLen] = 0;
                }
            }
        }
    }

    return hr;
} /* CSpVoice::LoadStreamIntoMem */


/*****************************************************************************
* CSpVoice::Speak *
*-----------------*
*   Description:
*       This method is used to speak a text buffer.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::Speak( const WCHAR* pwcs, DWORD dwFlags, ULONG* pulStreamNum )
{
    SPDBG_FUNC( "CSpVoice::Speak" );
    HRESULT hr = S_OK;

    //---  If the text pointer is NULL, the caller must specify SPF_PURGEBEFORESPEAK
    if( ( pwcs && SPIsBadStringPtr( pwcs ) ) ||
        ( pwcs == NULL && ( dwFlags & SPF_PURGEBEFORESPEAK ) == 0) )
    {
        hr = E_INVALIDARG;
    }
    else if( dwFlags & SPF_UNUSED_FLAGS )
    {
        hr = SPERR_INVALID_FLAGS;
    }
    else if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pulStreamNum ) )
    {
        hr = E_POINTER;
    }
    else if( pwcs == NULL && ( dwFlags & SPF_PURGEBEFORESPEAK ) )
    {
        //--- Just clear the current queue and return
        ENTER_VOICE_STATE_CHANGE_CRIT( dwFlags & SPF_PURGEBEFORESPEAK )
    }
    else
    {
        // If we're supposed to use the default voice, let's do it
        if (m_fUseDefaultVoice && m_cpVoiceToken)
        {
            hr = SetVoiceToken(NULL);
        }

        // If we're supposed to use the default rate, let's do it
        if ( m_fUseDefaultRate && SUCCEEDED( hr ) )
        {
            GetDefaultRate();
        }
        
        if( SUCCEEDED( hr ) &&
            dwFlags & SPF_IS_FILENAME ) 
        {
            CComPtr<ISpStream> cpStream;
            hr = cpStream.CoCreateInstance(CLSID_SpStream);
            if (SUCCEEDED(hr))
            {
                hr = cpStream->BindToFile( pwcs, SPFM_OPEN_READONLY, NULL, NULL, 
                                           m_SpEventSource.m_ullEventInterest | SPFEI_ALL_TTS_EVENTS | m_eAlertBoundary );
            }
            if( SUCCEEDED( hr ) )
            {
                hr = SpeakStream( cpStream, dwFlags, pulStreamNum );
            }
        }
        else if ( SUCCEEDED( hr ) )
        {
            //--- Copy source. The memory allocated will be freed by
            //    _SpeakBuffer. This is necessary to handle async calls.
            ULONG ulTextLen = wcslen( pwcs );
            size_t NumBytes = (ulTextLen + 1) * sizeof( WCHAR );
            WCHAR* pText    = new WCHAR[NumBytes];
            if( !pText )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memcpy( pText, pwcs, NumBytes );
            }

            hr = QueueNewSpeak( NULL, pText, dwFlags, pulStreamNum );
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
        return hr;
} /* CSpVoice::Speak */

/*****************************************************************************
* CSpVoice::SpeakStream *
*-----------------------*
*   Description:
*       This method queues a stream for rendering. If it is wav data it will
*   be sent directly to the destination stream. If the stream is text it will
*   involve the TTS Engine.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SpeakStream( IStream* pStream, DWORD dwFlags, ULONG* pulStreamNum )
{
    SPDBG_FUNC( "CSpVoice::SpeakStream" );
    HRESULT hr = S_OK;

    //--- Check args
    if( ( dwFlags & SPF_UNUSED_FLAGS ) ||
        ( (dwFlags & SPF_IS_XML) && (dwFlags & SPF_IS_NOT_XML) ) )
    {
        hr = SPERR_INVALID_FLAGS;
    }
    else if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pulStreamNum ) )
    {
        hr = E_POINTER;
    }
    else if( ( pStream == NULL ) && ( dwFlags & SPF_PURGEBEFORESPEAK ) )
    {
        hr = Speak( NULL, dwFlags, pulStreamNum );
    }
    else if( SP_IS_BAD_INTERFACE_PTR(pStream) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_READ_PTR( pStream ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Purge if needed
        if( dwFlags & SPF_PURGEBEFORESPEAK )
        {
            hr = Speak( NULL, dwFlags, pulStreamNum );
        }
    
        //--- Determine format of source stream
        CComQIPtr<ISpStreamFormat> cpStreamFormat(pStream);
        CSpStreamFormat InFmt;

        if (cpStreamFormat == NULL)
        {
            hr = InFmt.AssignFormat(SPDFID_Text, NULL);
        }
        else
        {
            hr = InFmt.AssignFormat(cpStreamFormat);
            if (SUCCEEDED(hr) && InFmt.FormatId() == GUID_NULL)
            {
                InFmt.AssignFormat(SPDFID_Text, NULL);
            }
        }

        if( SUCCEEDED( hr ) )
        {
            //--- Load text/xml stream into memory
            WCHAR* pText = NULL;
            if( InFmt.FormatId() == SPDFID_Text )
            {
                hr = LoadStreamIntoMem( pStream, &pText );
                cpStreamFormat.Release();
            }

            if( SUCCEEDED( hr ) )
            {
                //--- Add the wav stream to the pending list
                hr = QueueNewSpeak( cpStreamFormat, pText, dwFlags, pulStreamNum );
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
        return hr;
} /* CSpVoice::SpeakStream */

/*****************************************************************************
* CSpVoice::QueueNewSpeak *
*-------------------------*
*   Description:
*       This method queues the specified speak info structure and kicks
*   off execution.
*
*   The ownership of the object pointed to by pSI is passed from the caller to
*   this function.  Even if this function fails, the caller should no longer
*   use pSI or attempt to delete the object.
*
*   This method must be called with the object's critical section owned exactly one 
*   time, and the m_StateChangeCritSec owned.
*
*   If pInFmt is NULL then the format is assumed to be text.
*   
********************************************************************* EDC ***/
HRESULT CSpVoice::QueueNewSpeak( ISpStreamFormat * pWavStrm, WCHAR* pText,
                                 DWORD dwFlags, ULONG * pulStreamNum )
{
    ENTER_VOICE_STATE_CHANGE_CRIT( dwFlags & SPF_PURGEBEFORESPEAK )
    SPDBG_FUNC( "CSpVoice::QueueNewSpeak" );
    SPDBG_ASSERT( pWavStrm || pText );   // can't both be NULL
    HRESULT hr = S_OK;

    //--- Make sure we have an output stream
    if( !m_cpOutputStream )
    {
        hr = SetOutput( NULL, TRUE );
    }
    else if( m_cpAudioOut )
    {
        //--- Get the current output audio format. We do this each
        //    time because it may change externally.
        hr = m_OutputStreamFormat.AssignFormat(m_cpAudioOut);
    }

    //--- Auto detect parse -- Note that pText can be NULL if speaking a stream
    if( pText && !( dwFlags & ( SPF_IS_XML | SPF_IS_NOT_XML ) ) )
    {
                dwFlags |= ( *wcskipwhitespace(pText) == L'<' )?( SPF_IS_XML ):( SPF_IS_NOT_XML );
    }

    //--- Free the caller allocated text buffer if we've failed
    if( FAILED( hr ) && pText )
    {
        delete pText;
        pText = NULL;
    }

    //--- Create the speak info
    CSpeakInfo* pSI = NULL;
    if( SUCCEEDED( hr ) )
    {
        pSI = new CSpeakInfo( pWavStrm, pText, m_OutputStreamFormat, dwFlags, &hr);
        if( !pSI )
        {
            hr = E_OUTOFMEMORY;
        }
        else if( SUCCEEDED(hr) && pText )
        {
            //--- Make sure we have a voice defined by now
            if( SUCCEEDED( hr = LazyInit() ) )
            {
                if( dwFlags & SPF_IS_NOT_XML )
                {
                    //--- Create a single speak info structure for all the text
                    CSpeechSeg* pSeg;
                    hr = pSI->AddNewSeg( (m_GlobalStateStack.GetVal()).cpVoice, &pSeg );
                    WCHAR* pText = pSI->m_pText;

                    if( SUCCEEDED( hr ) &&
                        !pSeg->AddFrag( this, pText, pText, pText + wcslen(pText) ) )
                    {
                        hr = E_OUTOFMEMORY;
                    }                    
                }
                else
                {
                    //--- Parse the text
                    hr = ParseXML( *pSI );
                }
            }
        }

        //--- Free the speak info block if prep failed,
        //    Note: Caller allocated text buffer will be freed by SI destructor.
        if( FAILED( hr ) && pSI )
        {
            delete pSI;
            pSI = NULL;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        //--- Add the Speak info to the pending TTS rendering list
        BOOL fBlockIo = ((pSI->m_dwSpeakFlags & SPF_ASYNC) == 0);
        BOOL fDoItOnClientThread = fBlockIo && (!m_fThreadRunning);

        m_PendingSpeakList.InsertTail( pSI );
        m_autohPendingSpeaks.SetEvent();
        //
        //  If we're queueing a new speak, and we were done with the previous one, reset the status
        //  BEFORE returning so that word boundaries, etc are updated correctly.
        //
        if( m_VoiceStatus.dwRunningState & SPRS_DONE )
        {
            ResetVoiceStatus();
        }

        m_VoiceStatus.dwRunningState &= ~SPRS_DONE;
        pSI->m_ulStreamNum = ++m_VoiceStatus.ulLastStreamQueued;
        if( pulStreamNum )
        {
            *pulStreamNum = m_VoiceStatus.ulLastStreamQueued;
        }

        if ((!fDoItOnClientThread) && (!m_fThreadRunning))
        {
            hr = m_cpThreadCtrl->StartThread(0, NULL);
        }

        //--- Wait?
        if( SUCCEEDED( hr ) && fBlockIo )
        {
            Unlock();
            if( fDoItOnClientThread )
            {   
                const static BOOL bContinue = TRUE;
                hr = ThreadProc( NULL, NULL, NULL, NULL, &bContinue );
            }
            else
            {
                hr = m_cpThreadCtrl->WaitForThreadDone( FALSE, NULL, INFINITE );
            }
            Lock(); 
        }
    }

    return hr;
} /* CSpVoice::QueueNewSpeak */

/*****************************************************************************
* CSpVoice::SetOutput *
*---------------------*
*   Description:
*       This method sets the output stream and output format. If the output
*   stream supports ISpStreamFormat, the format of the stream must match
*   the specified format Id. pOutFormatId may be NULL. pOutFormatId will be used
*   in the case where pOutStream is not self describing. Values of NULL, NULL
*   will create the default audio device using the TTS engines preferred rendering
*   format.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SetOutput( IUnknown * pUnkOutput, BOOL fAllowFormatChanges )
{
    ENTER_VOICE_STATE_CHANGE_CRIT( TRUE )
    SPDBG_FUNC( "CSpVoice::SetOutput" );
    HRESULT hr = S_OK;
    BOOL fNegotiateFormat = TRUE;

    //--- Check args
    HRESULT tmphr = LazyInit(); // If we fail, we fail.
    if (FAILED(tmphr))
    {
        fNegotiateFormat = FALSE;
    }

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pUnkOutput ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Release our current outputs
        _ReleaseOutRefs();
        //--- Assume we are not going to queue calls to speak with other voices
        m_fQueueSpeaks = FALSE;

        CComQIPtr<ISpObjectToken> cpToken(pUnkOutput);  // QI for object token
        if ( pUnkOutput == NULL )
        {
            hr = SpGetDefaultTokenFromCategoryId(SPCAT_AUDIOOUT, &cpToken);
        }

        if (SUCCEEDED(hr))
        {
            if (cpToken)
            {
                // NOTE:  In the token case, we'll attempt to create the stream interface first
                //        and then QI for the audio interface.  This would allow some future code
                //        to create a token for a stream object that is not an audio device.
                hr = SpCreateObjectFromToken(cpToken, &m_cpOutputStream);
            }
            else
            {
                // It had better be a stream, and if not, then it's an invalid arg
                if (FAILED(pUnkOutput->QueryInterface(&m_cpOutputStream)))
                {
                    hr = E_INVALIDARG;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // Don't fail if QI fails for AudioOutput.  Simply having a stream is good enough
            m_cpOutputStream.QueryInterface(&m_cpAudioOut);

            if (m_cpAudioOut == NULL || (!fAllowFormatChanges) || (!fNegotiateFormat))
            {
                //--- The format of the specified stream will be used.
                hr = m_OutputStreamFormat.AssignFormat(m_cpOutputStream);
            }
            else 
            {
                //--- Use Engine's preferred wav voice format as the default
                m_OutputStreamFormat.Clear();
                hr = (m_GlobalStateStack.GetBaseVal()).cpVoice->
                        GetOutputFormat( NULL, NULL,
                                         &m_OutputStreamFormat.m_guidFormatId,
                                         &m_OutputStreamFormat.m_pCoMemWaveFormatEx );
                SPDBG_ASSERT( hr == S_OK );
            }
        }

        //--- Adjust the format of the audio device if we're allowed to
        if( SUCCEEDED( hr ) && m_cpAudioOut && fAllowFormatChanges)
        {
            hr = m_cpAudioOut->SetFormat( m_OutputStreamFormat.FormatId(), m_OutputStreamFormat.WaveFormatExPtr() );
            if (FAILED(hr))
            {
                m_OutputStreamFormat.Clear();
                hr = m_cpAudioOut->GetDefaultFormat(&m_OutputStreamFormat.m_guidFormatId, &m_OutputStreamFormat.m_pCoMemWaveFormatEx);
                if (SUCCEEDED(hr))
                {
                    hr = m_cpAudioOut->SetFormat(m_OutputStreamFormat.FormatId(), m_OutputStreamFormat.WaveFormatExPtr());
                }
            }
        }

        //--- Setup the format converter and set for pass-through (format will be changed later if necessary)
        if( SUCCEEDED( hr ) )
        {        
            hr = m_cpFormatConverter->SetBaseStream( m_cpOutputStream, TRUE, TRUE );
        }

        //--- Setup event routing
        if( SUCCEEDED( hr ) )
        {        
            //--- Get the event sink interface if there is one
            m_cpFormatConverter.QueryInterface( &m_cpOutputEventSource );
            m_cpFormatConverter.QueryInterface( &m_cpOutputEventSink   );

            m_fSerializeAccess = FALSE; // Default

            //--- We only do the following for audio devices
            if( m_cpAudioOut )
            {
                if( m_cpOutputEventSource && m_cpOutputEventSink )
                {
                    //--- Notify the output queue of our event interest
                    hr = m_cpOutputEventSource->
                        SetInterest( SPFEI_ALL_TTS_EVENTS | m_SpEventSource.m_ullEventInterest,
                                     SPFEI_ALL_TTS_EVENTS | m_SpEventSource.m_ullQueuedInterest );
                }
                else
                {
                    //--- We don't like this! Output audio devices MUST be both
                    //    event sinks and event sources
                    hr = E_INVALIDARG;
                }

                //--- Now register with the connection point for our events.
                if( SUCCEEDED( hr ) )
                {
                    hr = m_cpOutputEventSource->SetNotifySink(&m_SpContainedNotify);
                }

                //=== Create objects for voice queuing
                //    Create 2 mutexes
                //    If for any reason the audio device does not support ISpObjectWithToken
                //    or if it does not have a token, don't error out -- Just don't use a queue.
                CSpDynamicString dstrObjectId;
                if (SUCCEEDED(hr))
                {
                    CComQIPtr<ISpObjectWithToken> cpObjWithToken(m_cpAudioOut);
                    if (cpObjWithToken)
                    {
                        CComPtr<ISpObjectToken> cpToken;
                        hr = cpObjWithToken->GetObjectToken(&cpToken);
                        if (SUCCEEDED(hr) && cpToken)
                        {
                            BOOL fNoSerialize = FALSE;
                            hr = cpToken->MatchesAttributes(L"NoSerializeAccess", &fNoSerialize);
                            if(SUCCEEDED(hr) && !fNoSerialize)
                            {
                                hr = cpToken->GetId(&dstrObjectId);
                                if(SUCCEEDED(hr) && dstrObjectId)
                                {
                                    m_fSerializeAccess = TRUE;
                                }
                            }
                        }
                    }
                }
                if (SUCCEEDED(hr) && m_fSerializeAccess)
                {
                    //
                    //  Convert all "\" characters to "-" since CreateMutex doesn't like them
                    //
                    for (WCHAR * pc = dstrObjectId; *pc; pc++)
                    {
                        if (*pc == L'/' || *pc == L'\\')
                        {
                            *pc = L'-';
                        }
                    }
                    CSpDynamicString dstrWaitObjName;
                    if (dstrWaitObjName.Append2(L"0SpWaitObj-", dstrObjectId))
                    {
                        hr = m_NormalMagicMutex.InitMutex( dstrWaitObjName );
                        if (SUCCEEDED(hr))
                        {
                            *dstrWaitObjName = L'1';
                            hr = m_AlertMagicMutex.InitMutex( dstrWaitObjName );
                        }
                        if (SUCCEEDED(hr))
                        {
                            *dstrWaitObjName = L'2';
                            hr = m_AudioMagicMutex.InitMutex( dstrWaitObjName );
                        }
                        if (SUCCEEDED(hr))
                        {
                            m_fQueueSpeaks = TRUE;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        } // end event routing if 
    }

    //--- Put the voice in a safe state on failure
    if( FAILED( hr ) )
    {
        _ReleaseOutRefs();
    }

    SPDBG_REPORT_ON_FAIL( hr );
        return hr;
} /* CSpVoice::SetOutput */

/*****************************************************************************
* CSpVoice::GetOutputStream *
*---------------------------*
*   Description:
*   
*   Returns:
*       S_OK - *ppOutStream contatains the stream interface pointer
*       SPERR_NOT_FOUND
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetOutputStream( ISpStreamFormat ** ppOutStream )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::GetOutput" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( ppOutStream  ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Make sure we have an output
        if( !m_cpOutputStream )
        {
            hr = SetOutput( NULL, TRUE );
        }

        if (SUCCEEDED(hr)) 
        {
            m_cpOutputStream.CopyTo(ppOutStream);
        }
        else
        {
            *ppOutStream = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
        return hr;
} /* CSpVoice::GetOutputStream */

/****************************************************************************
* CSpVoice::GetOutputObjectToken *
*--------------------------------*
*   Description:
*
*   Returns:
*       S_OK - *ppObjToken contains a valid pointer
*       S_FALSE - *ppObjToken is NULL.
*
********************************************************************* RAL ***/

STDMETHODIMP CSpVoice::GetOutputObjectToken( ISpObjectToken ** ppObjToken )
{
    SPDBG_FUNC("CSpVoice::GetOutputObjectToken");
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( ppObjToken ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Make sure we have an output
        if( !m_cpOutputStream )
        {
            SetOutput( NULL, TRUE );   // Ignore errors -- Just return S_FALSE if this fails
        }

        *ppObjToken = NULL;
        CComQIPtr<ISpObjectWithToken> cpObjWithToken(m_cpOutputStream);
        if (cpObjWithToken)
        {
            hr = cpObjWithToken->GetObjectToken(ppObjToken);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/*****************************************************************************
* CSpVoice::Pause *
*-----------------*
*   Description:
*       This method pauses the voice and closes the output device.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::Pause( void )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::Pause" );
    HRESULT hr = S_OK;

    if( ++m_ulPauseCount == 1 )
    {
        hr = m_ahPauseEvent.HrResetEvent();
    }

    return hr;
} /* CSpVoice::Pause */

/*****************************************************************************
* CSpVoice::Resume *
*------------------*
*   Description:
*   This method sets the output device to the RUN state and resumes rendering.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::Resume( void )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::Resume" );
    HRESULT hr = S_OK;

    if( m_ulPauseCount && ( --m_ulPauseCount == 0 ) )
    {
        hr = m_ahPauseEvent.HrSetEvent();
    }

    return hr;
} /* CSpVoice::Resume */

/*****************************************************************************
* CSpVoice::SetVoiceToken *
*-------------------------*
*   Description:
*       This is a helper method used to update the current voice token. We take
*   the AsyncCtrlMutex here and in GetVoice, because it is updated during a
*   speak call if there are XML voice changes. The token isn't bound until
*   the next speak request is taken from the pending queue.
********************************************************************* EDC ***/
HRESULT CSpVoice::SetVoiceToken( ISpObjectToken * pNewVoiceToken )
{
    SPDBG_FUNC("CSpVoice::SetVoiceToken");
    HRESULT hr = S_OK;

    m_AsyncCtrlMutex.Wait();

    // By default we'll update; only if the token ids for the current
    // voice and the new voice are the same will we not
    BOOL fUpdate = TRUE;
    
    // If we already have a token...
    if (m_cpVoiceToken != NULL)
    {
        // Get the current default voice's token id
        CSpDynamicString dstrNewTokenId;
        if (pNewVoiceToken)
        {
            hr = pNewVoiceToken->GetId(&dstrNewTokenId);
        }
        else
        {
            hr = SpGetDefaultTokenIdFromCategoryId(SPCAT_VOICES, &dstrNewTokenId);
        }

        // Get the token id of the voice we're currently using
        CSpDynamicString dstrTokenId;
        if (SUCCEEDED(hr))
        {
            hr = m_cpVoiceToken->GetId(&dstrTokenId);
        }

        // Now if the tokens are the same, we shouldn't update
        if (SUCCEEDED(hr) && wcscmp(dstrTokenId, dstrNewTokenId) == 0)
        {
            fUpdate = FALSE;
        }
    }

    if (fUpdate)
    {
        m_cpVoiceToken = pNewVoiceToken;
        m_fCreateEngineFromToken = true;
    }
    m_AsyncCtrlMutex.ReleaseMutex();

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* CSpVoice::SetVoice *
*--------------------*
*   Description:
*       This method sets the token of the voice to be created when
*   LazyInit is called.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SetVoice( ISpObjectToken * pVoiceToken )
{
    ENTER_VOICE_STATE_CHANGE_CRIT( FALSE )
    SPDBG_FUNC( "CSpVoice::SetVoice" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pVoiceToken ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // If the caller specified a voice, don't automatically
        // use the default from now on
        m_fUseDefaultVoice = (pVoiceToken == NULL);
        
        hr = SetVoiceToken( pVoiceToken );
    }

    SPDBG_REPORT_ON_FAIL( hr );
        return hr;
} /* CSpVoice::SetVoice */

/*****************************************************************************
* CSpVoice::GetVoice *
*--------------------*
*   Description:
*       This method gets the token of the Engine voice to be created when
*   _LazyInit is called.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetVoice( ISpObjectToken ** ppVoiceToken )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::GetVoice" );
    HRESULT hr = S_OK;

    if( !m_cpVoiceToken && FAILED( hr = LazyInit() ) )
    {
        return hr;
    }
    else if( SP_IS_BAD_WRITE_PTR( ppVoiceToken ) )
    {
        hr = E_POINTER;
    }
    else
    {
        m_AsyncCtrlMutex.Wait();
        m_cpVoiceToken.CopyTo( ppVoiceToken );
        m_AsyncCtrlMutex.ReleaseMutex();
    }

    SPDBG_REPORT_ON_FAIL( hr );
        return hr;
} /* CSpVoice::GetVoice */

/*****************************************************************************
* CSpVoice::GetStatus *
*---------------------*
*   Description:
*       This method returns the current rendering and event status for
*   this voice. Note: this method does not take the object lock, it takes
*   the lock of the event queue which is used to arbitrate access to this
*   structure.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetStatus( SPVOICESTATUS *pStatus, WCHAR ** ppszBookmark )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::GetStatus" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pStatus ) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR( ppszBookmark ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( pStatus )
        {
            *pStatus = m_VoiceStatus;
        }

        if( ppszBookmark )
        {
            *ppszBookmark = m_dstrLastBookmark.Copy();
            if (*ppszBookmark == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
        return hr;
} /* CSpVoice::GetStatus */

/*****************************************************************************
* CSpVoice::Skip *
*----------------*
*   Description:
*       This method tells the engine to skip ahead the specified number of
*   of items within the current speak request.
*   Note: At this time only sentence items are supported.
*
*       S_OK - This skip was completed.
*       E_INVALIDARG - An invalid skip type was specified
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::Skip( WCHAR* pItemType, long lNumItems, ULONG* pulNumSkipped )
{
    SPDBG_FUNC( "CSpVoice::Skip" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_STRING_PTR( pItemType ) || _wcsicmp( pItemType, L"SENTENCE") )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pulNumSkipped ) )
    {
        hr = E_POINTER;
    }
    else if( m_ahPauseEvent.Wait( 0 ) == WAIT_TIMEOUT )
    {
        //--- Trying to skip when the voice is paused is an error
        //    This is to prevent a single threaded app from hanging itself.
        hr = SPERR_VOICE_PAUSED;
    }
    else
    {
        //--- Only allow one skip at a time
        m_SkipSec.Lock();

        //--- Setup for skip
        m_AsyncCtrlMutex.Wait();
        m_lSkipCount   = lNumItems;
        m_eSkipType    = SPVST_SENTENCE;
        m_eActionFlags = (SPVESACTIONS)(m_eActionFlags | SPVES_SKIP);
        m_AsyncCtrlMutex.ReleaseMutex();
        m_ahSkipDoneEvent.ResetEvent();

        //--- Wait until Skip is done or thread is complete
        //    this covers engines that forget to skip or exit on error
        ULONG ulSkipped = 0;
        HANDLE aHandles[] = { m_ahSkipDoneEvent, m_cpThreadCtrl->ThreadCompleteEvent() };
        if( ::WaitForMultipleObjects( 2, aHandles, false, INFINITE ) == WAIT_OBJECT_0 )
        {
            //--- If the skip complete caused us to be done, return what it did
            ulSkipped = m_lNumSkipped;
        }

        //--- Clear skip args in any case
        m_AsyncCtrlMutex.Wait();
        m_eActionFlags = (SPVESACTIONS)(m_eActionFlags & ~SPVES_SKIP);
        m_lNumSkipped  = 0;
        m_lSkipCount   = 0;
        m_AsyncCtrlMutex.ReleaseMutex();

        //--- Return how many were done
        if( pulNumSkipped )
        {
            *pulNumSkipped = ulSkipped;
        }
        m_SkipSec.Unlock();
    }

    return hr;
} /* CSpVoice::Skip */

/*****************************************************************************
* CSpVoice::SetPriority *
*-----------------------*
*   Description:
*       This method sets the voices queueing priority. Calling this method
*   purges all pending speaks.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SetPriority( SPVPRIORITY ePriority )
{
    ENTER_VOICE_STATE_CHANGE_CRIT( TRUE )
    SPDBG_FUNC( "CSpVoice::SetPriority" );
    HRESULT hr = S_OK;

    if( ( ePriority != SPVPRI_NORMAL ) &&
        ( ePriority != SPVPRI_ALERT  ) &&
        ( ePriority != SPVPRI_OVER   ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_eVoicePriority = ePriority;
    }

    return hr;
} /* CSpVoice::SetPriority */

/*****************************************************************************
* CSpVoice::GetPriority *
*-----------------------*
*   Description:
*       This method gets the voices current priority level
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetPriority( SPVPRIORITY* pePriority )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::GetPriority" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( pePriority ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pePriority = m_eVoicePriority;
    }

    return hr;
} /* CSpVoice::GetPriority */

/*****************************************************************************
* CSpVoice::SetAlertBoundary *
*----------------------------*
*   Description:
*       This method specifies what event should be used as the insertion
*   point for alerts.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SetAlertBoundary( SPEVENTENUM eBoundary )
{
    ENTER_VOICE_STATE_CHANGE_CRIT( false )
    SPDBG_FUNC( "CSpVoice::SetAlertBoundary" );
    HRESULT hr = S_OK;

    if( ( eBoundary > SPEI_MAX_TTS ) || ( eBoundary < SPEI_MIN_TTS ) || ( eBoundary == SPEI_UNDEFINED ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_eAlertBoundary = eBoundary;
    }

    return hr;
} /* CSpVoice::SetAlertBoundary */

/*****************************************************************************
* CSpVoice::GetPriority *
*-----------------------*
*   Description:
*       This method gets the voices current priority level
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetAlertBoundary( SPEVENTENUM* peBoundary )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::GetPriority" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( peBoundary ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *peBoundary = m_eAlertBoundary;
    }

    return hr;
} /* CSpVoice::GetPriority */

/*****************************************************************************
* CSpVoice::SetRate *
*-------------------*
*   Description:
*       This method sets the Engine's current spoken text units per minute rate.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SetRate( long RateAdjust )
{
    SPDBG_FUNC( "CSpVoice::SetRate" );
    HRESULT hr = S_OK;
    m_AsyncCtrlMutex.Wait();
    m_lCurrRateAdj = RateAdjust;
    m_eActionFlags = (SPVESACTIONS)(m_eActionFlags | SPVES_RATE);
    m_AsyncCtrlMutex.ReleaseMutex();
    m_fUseDefaultRate = FALSE;
    return hr;
} /* CSpVoice::SetRate */

/*****************************************************************************
* CSpVoice::GetRate *
*-------------------*
*   Description:
*       This method gets the Engine's current spoken text units per minute rate.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetRate( long* pRateAdjust )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::GetRate" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( pRateAdjust ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pRateAdjust = m_lCurrRateAdj;
    }

    return hr;
} /* CSpVoice::GetRate */

/*****************************************************************************
* CSpVoice::SetVolume *
*---------------------*
*   Description:
*       Sets the Engine's current volume level, which ranges from 0 - 100 percent.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SetVolume( USHORT usVolume )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::SetVolume" );
    HRESULT hr = S_OK;

    //--- Check args
    if( usVolume > SPMAX_VOLUME )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_AsyncCtrlMutex.Wait();
        m_usCurrVolume = usVolume;
        m_eActionFlags = (SPVESACTIONS)(m_eActionFlags | SPVES_VOLUME);
        m_AsyncCtrlMutex.ReleaseMutex();
    }

    return hr;
} /* CSpVoice::SetVolume */

/*****************************************************************************
* CSpVoice::GetVolume *
*---------------------*
*   Description:
*       Gets the Engine's current volume level, which ranges from 0 - 100 percent.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetVolume( USHORT* pusVolume )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::GetVolume" );
    HRESULT hr = S_OK;

    //--- Check args
    if( SP_IS_BAD_WRITE_PTR( pusVolume ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pusVolume = m_usCurrVolume;
    }

    return hr;
} /* CSpVoice::GetVolume */

/*****************************************************************************
* CSpVoice::WaitUntilDone *
*-------------------------*
*   Description:
*       Waits for the specified time limit or until the speech queue is empty.
*   If the speech queue empties then this function returns S_OK.  Otherwise it
*   returns S_FALSE if the wait times-out.
********************************************************************* RAL ***/
STDMETHODIMP CSpVoice::WaitUntilDone( ULONG msTimeOut )
{
    return m_cpThreadCtrl->WaitForThreadDone( FALSE, NULL, msTimeOut );
} /* CSpVoice::GetVolume */


/*****************************************************************************
* CSpVoice::SetSyncSpeakTimeout *
*-------------------------------*
*   Description:
*       Sets the timeout value for synchronous speak calls.
********************************************************************* RAL ***/
STDMETHODIMP CSpVoice::SetSyncSpeakTimeout( ULONG msTimeout )
{
    m_ulSyncSpeakTimeout = msTimeout;
    return S_OK;
} /* CSpVoice::SetSyncSpeakTimeout */


/*****************************************************************************
* CSpVoice::GetSyncSpeakTimeout *
*-------------------------------*
*   Description:
*       Gets the timeout value for synchronous speak calls.
********************************************************************* RAL ***/
STDMETHODIMP CSpVoice::GetSyncSpeakTimeout( ULONG * pmsTimeout )
{
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pmsTimeout ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pmsTimeout = m_ulSyncSpeakTimeout;
    }
    return hr;
} /* CSpVoice::GetSyncSpeakTimeout */


/****************************************************************************
* CSpVoice::SpeakCompleteEvent *
*------------------------------*
*   Description:
*       Returns an event handle that the caller can use to wait until the voice
*   has completed speaking.  This is similar to the functionality provided by
*   WaitUntilDone, but allows the caller to wait on the event handle themselves.
*   NOTE:  The event handle is owned by this object and is NOT duplicated.  The
*          caller must NOT call CloseHandle(), nor should the caller ever use
*          the handle after releasing the COM reference to this object.
*
*   Returns:
*       Event handle (this call can not fail).
*
********************************************************************* RAL ***/
STDMETHODIMP_(HANDLE) CSpVoice::SpeakCompleteEvent()
{
    return m_cpThreadCtrl->ThreadCompleteEvent();
}


/****************************************************************************
* CSpVoice::IsUISupported *
*-------------------------*
*   Description:
*       Checks to see if the specified type of UI is supported
*   Returns:
*       S_OK on success,
*       FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpVoice::IsUISupported(const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData, BOOL *pfSupported)
{
    CComPtr<ISpObjectToken> cpObjToken;
    HRESULT hr = S_OK;
    BOOL fSupported = FALSE;
    
    if (pvExtraData != NULL && SPIsBadReadPtr(pvExtraData, cbExtraData))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(pfSupported))
    {
        hr = E_POINTER;
    }
    
    // See if the voice supports the UI
    if (SUCCEEDED(hr))
    {
        hr = GetVoice(&cpObjToken);
        if (SUCCEEDED(hr))
        {
            hr = cpObjToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, (ISpVoice*)this, &fSupported);
        }
    }
    
    // See if the audio object supports the UI
    if (SUCCEEDED(hr) && !fSupported)
    {
        CComPtr<ISpObjectToken> cpAudioToken;
        if (GetOutputObjectToken(&cpAudioToken) == S_OK)
        {
            hr = cpAudioToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, m_cpAudioOut, &fSupported);
        }
    }
    
    // Copy the result back
    if (SUCCEEDED(hr))
    {
        *pfSupported = fSupported;
    }

    return hr;
}


/****************************************************************************
* CSpVoice::DisplayUI *
*---------------------*
*   Description:
*       Displays the requested UI
*   Returns:
*       S_OK on success
*       FAILED(hr) otherwise
******************************************************************* robch ***/
STDMETHODIMP CSpVoice::DisplayUI(HWND hwndParent, const WCHAR * pszTitle, const WCHAR * pszTypeOfUI, void * pvExtraData, ULONG cbExtraData)
{
    CComPtr<ISpObjectToken> cpObjToken;
    BOOL fSupported = FALSE;
    HRESULT hr = S_OK;
    
    // Validate the parms
    if (!IsWindow(hwndParent) ||
        SP_IS_BAD_OPTIONAL_STRING_PTR(pszTitle) ||
        (pvExtraData != NULL && SPIsBadReadPtr(pvExtraData, cbExtraData)))
    {
        hr = E_INVALIDARG;
    }
    
    // See if the voice supports the UI
    if (SUCCEEDED(hr))
    {
        hr = GetVoice(&cpObjToken);
        if (SUCCEEDED(hr))
        {
            hr = cpObjToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, (ISpVoice*)this, &fSupported);
            if (SUCCEEDED(hr) && fSupported)
            {
                hr = cpObjToken->DisplayUI(hwndParent, pszTitle, pszTypeOfUI, pvExtraData, cbExtraData, (ISpVoice*)this);
            }
        }
    }
    
    // See if the audio output supports the UI
    if (SUCCEEDED(hr) && !fSupported)
    {
        CComPtr<ISpObjectToken> cpAudioToken;
        if (GetOutputObjectToken(&cpAudioToken) == S_OK)
        {
            hr = cpAudioToken->IsUISupported(pszTypeOfUI, pvExtraData, cbExtraData, m_cpAudioOut, &fSupported);
            if (SUCCEEDED(hr) && fSupported)
            {
                hr = cpAudioToken->DisplayUI(hwndParent, pszTitle, pszTypeOfUI, pvExtraData, cbExtraData, m_cpAudioOut);
            }
        }
    }
    
    // If nobody supported, we should consider the pszTypeOfUI to be a bad parameter
    if (SUCCEEDED(hr) && !fSupported)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//
//=== ISpTTSEngineSite =======================================================
//

/*****************************************************************************
* CSpVoice::EsWrite *
*-------------------*
*   Description:
*       This method redirects the incoming wav data from the TTS Engine to
*   the appropriate output stream doing any wav format conversion that is
*   necessary.
********************************************************************* EDC ***/
HRESULT CSpVoice::EsWrite( const void* pBuff, ULONG cb, ULONG *pcbWritten )
{
    SPDBG_FUNC( "CSpVoice::Write" );
    HRESULT hr = S_OK;

    GUID guidFormatId;
    WAVEFORMATEX *pCoMemWaveFormatEx = NULL;

    m_cpFormatConverter->GetFormat( &guidFormatId, &pCoMemWaveFormatEx );

    if( SPIsBadReadPtr( (BYTE*)pBuff, cb ) ||
        //--- Make sure that the data being written is a multiple of the sample size...
        ( guidFormatId == SPDFID_WaveFormatEx ? 
          cb % pCoMemWaveFormatEx->nBlockAlign : 0 ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pcbWritten ) )
    {
        hr = E_POINTER;
    }
    else if( !m_cpOutputStream )
    {
        hr = SPERR_UNINITIALIZED;
    }
    else
    {
        HANDLE hExit = m_cpThreadCtrl->ExitThreadEvent();
        DWORD dwWait = ( hExit )?( INFINITE ):( m_ulSyncSpeakTimeout );
        BOOL fVoiceIsNotNormal  = ( m_eVoicePriority != SPVPRI_NORMAL );
        BOOL fInsertPtUndefined = ( m_ullAlertInsertionPt == UNDEFINED_STREAM_POS );

        //--- Check for pause state
        if( !fInsertPtUndefined &&
            m_ahPauseEvent.Wait( 0 ) == WAIT_TIMEOUT )
        {
            hr = DoPause( hExit, dwWait, pBuff, cb, pcbWritten );
        }
        //--- Don't worry about checking for alert interruptions unless this is a
        //    NORMAL priority voice, the audio device needs to be synchronized, and
        //    the insertion point is defined.  
        else if( !m_fSerializeAccess || fVoiceIsNotNormal || fInsertPtUndefined )
        {
            //--- Normal write
            hr = m_cpFormatConverter->Write( pBuff, cb, pcbWritten );
        }
        else
        {
            //=== This whole section is only for a NORMAL voice
            //    when queued speaking is going on and we have a known insertion point

            //--- Check the alert queue status
            switch( m_AlertMagicMutex.Wait( hExit, 0 ) )
            {
                case WAIT_OBJECT_0:
                    m_AlertMagicMutex.ReleaseMutex();
                    hr = m_cpFormatConverter->Write( pBuff, cb, pcbWritten );
                    break;
                case WAIT_OBJECT_0 + 1:
                    //--- Everything's OK, we're just exiting the thread
                    hr = S_OK;  
                    break;
                case WAIT_TIMEOUT:
                    hr = InsertAlerts( hExit, dwWait, pBuff, cb, pcbWritten );
                    break;
                default:
                    hr = SpHrFromLastWin32Error();
                    break;
            }
        }
    }

    if ( pCoMemWaveFormatEx != NULL )
    {
        ::CoTaskMemFree( pCoMemWaveFormatEx );
    }

    return hr;
} /* CSpVoice::EsWrite */

/*****************************************************************************
* CSpVoice::WaitForQueue *
*------------------------*
*   Description:
*       This function is used to generically wait for a set of objects.
********************************************************************* EDC ***/
HRESULT WaitForQueue( DWORD dwCount, HANDLE ah[], DWORD dwWait, BOOL* pDoExit )
{
    HRESULT hr = S_OK;
    *pDoExit = false;
    switch( ::WaitForMultipleObjects( dwCount, ah, false, dwWait ) )
    {
      case WAIT_OBJECT_0:
        break;
      //=== Audio device flush did not complete ================
      case WAIT_OBJECT_0 + 1:
        //--- Everything's OK, we're just exiting the thread
        *pDoExit = true;
        break;
      case WAIT_TIMEOUT:
        hr = SPERR_DEVICE_BUSY;
        break;
      default:
        hr = SpHrFromLastWin32Error();
        break;
    }
    return hr;
} /* WaitForQueue */

/****************************************************************************
* CSpVoice::DoPause *
*-------------------*
*   Description:
*       
********************************************************************* EDC ***/
HRESULT CSpVoice::DoPause( HANDLE hExit, DWORD dwWait, const void* pBuff,
                           ULONG cb, ULONG *pcbWritten )
{
    SPDBG_FUNC( "CSpVoice::DoPause" );
    HRESULT hr = S_OK;

    BOOL fThreadExiting = false;
    DWORD dwResult = 0, dwCount = ( hExit ) ? 2 : 1;
    static const LARGE_INTEGER liMove = { 0, 0 };
    ULARGE_INTEGER uliCurPos;
    ULONG ulBeforeCount = 0, ulBeforeWritten = 0;

    //--- Write data up to the alert insertion point
    hr = m_cpFormatConverter->Seek( liMove, STREAM_SEEK_CUR, &uliCurPos );
    
    if( SUCCEEDED( hr ) )
    {
        if( uliCurPos.QuadPart <= m_ullAlertInsertionPt )
        {
            ulBeforeCount = (ULONG)(m_ullAlertInsertionPt - uliCurPos.QuadPart);

            if( cb < ulBeforeCount )
            {
                //--- The insertion point wasn't in this buffer
                return m_cpFormatConverter->Write( pBuff, cb, pcbWritten );
            }

            hr = m_cpFormatConverter->Write( pBuff, ulBeforeCount, &ulBeforeWritten );
        }
        else if ( m_ullAlertInsertionPt )
        {
            //--- Alert insertion point is behind current position - reset and exit!
            m_ullAlertInsertionPt = UNDEFINED_STREAM_POS;
            return m_cpFormatConverter->Write( pBuff, cb, pcbWritten );
        }
    }

    //--- Commit the audio device
    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpFormatConverter->Commit( STGC_DEFAULT );
    }

    if ( SUCCEEDED( hr ) && m_cpAudioOut )
    {
        //--- Flush the audio buffer
        HANDLE aHandles[] = {m_cpAudioOut->EventHandle(), hExit};
        hr = WaitForQueue( dwCount, aHandles, dwWait, &fThreadExiting );
        if ( SUCCEEDED( hr ) && !fThreadExiting )
        {
            //--- Yield the audio device
            m_VoiceStatus.dwRunningState &= ~SPRS_IS_SPEAKING;
            m_cpAudioOut->SetState( SPAS_CLOSED, 0 );
            m_fAudioStarted = false;
        }
    }
    else if ( SUCCEEDED( hr ) )
    {
        //--- m_cpAudioOut is NULL - just reset the voice status
        m_VoiceStatus.dwRunningState &= ~SPRS_IS_SPEAKING;
    }

    //--- Determine which queue to release and release it
    CSpMagicMutex *pMutex = NULL;

    if ( SUCCEEDED( hr )    &&
         !fThreadExiting    &&
         m_fSerializeAccess && 
         ( m_eVoicePriority != SPVPRI_OVER ) )
    {
        m_AudioMagicMutex.ReleaseMutex();
        pMutex = ( m_eVoicePriority == SPVPRI_NORMAL ) ? ( &m_NormalMagicMutex ) : ( &m_AlertMagicMutex );
        pMutex->ReleaseMutex();
    }

    if ( SUCCEEDED( hr ) && !fThreadExiting )
    {
        //--- Wait for voice to be resumed
        HANDLE aHandles[] = { m_ahPauseEvent, hExit };
        hr = WaitForQueue( dwCount, aHandles, dwWait, &fThreadExiting );

        if ( SUCCEEDED( hr ) && pMutex && !fThreadExiting )
        {
            //--- Reclaim the appropriate queue
            dwResult = pMutex->Wait( hExit, dwWait );
            switch ( dwResult )
            {
            case WAIT_OBJECT_0:
                //--- Successfully reclaimed queue - now claim the audio mutex
                dwResult = m_AudioMagicMutex.Wait( hExit, dwWait );
                switch ( dwResult )
                {
                case WAIT_OBJECT_0:
                    break;
                case WAIT_OBJECT_0 + 1:
                    //--- Everything is OK - thread is exiting
                    fThreadExiting = true;
                    pMutex->ReleaseMutex();
                    break;
                case WAIT_TIMEOUT:
                    hr = SPERR_DEVICE_BUSY;
                    pMutex->ReleaseMutex();
                    break;
                default:
                    hr = SpHrFromLastWin32Error();
                    pMutex->ReleaseMutex();
                    break;
                }
                break;
            case WAIT_OBJECT_0 + 1:
                //--- Everything is OK - thread is exiting
                fThreadExiting = true;
                break;
            case WAIT_TIMEOUT:
                hr = SPERR_DEVICE_BUSY;
                break;
            default:
                hr = SpHrFromLastWin32Error();
                break;
            }
        }

        if ( SUCCEEDED( hr ) && !fThreadExiting )
        {
            if ( m_cpAudioOut )
            {
                hr = StartAudio( hExit, dwWait );
            }

            if ( SUCCEEDED( hr ) )
            {
                m_VoiceStatus.dwRunningState &= SPRS_IS_SPEAKING;

                //--- Write the remainder of the buffer
                pBuff = ((BYTE*)pBuff) + ulBeforeCount;
                hr = m_cpFormatConverter->Write( pBuff, cb - ulBeforeCount, pcbWritten );
                if( pcbWritten )
                {
                    *pcbWritten += ulBeforeWritten;
                }
            }            
        }
    }

    return hr;
} /* CSpVoice::DoPause */

/*****************************************************************************
* CSpVoice::InsertAlerts *
*------------------------*
*   Description:
*       This method insert writes the specified buffer up to the insertion
*   point, yields to the alert queue, then resumes writing the rest of the
*   buffer.
********************************************************************* EDC ***/
HRESULT CSpVoice::InsertAlerts( HANDLE hExit, DWORD dwWait, const void* pBuff,
                                ULONG cb, ULONG *pcbWritten )
{
    SPDBG_FUNC( "CSpVoice::InsertAlerts" );
    HRESULT hr = S_OK;

    DWORD dwResult = 0, dwCount = ( hExit )?( 2 ):( 1 );
    static const LARGE_INTEGER liMove = { 0, 0 };
    ULARGE_INTEGER uliCurPos;
    ULONG ulBeforeCount = 0, ulBeforeWritten = 0;

    //--- Write data up to the alert insertion point
    hr = m_cpFormatConverter->Seek( liMove, STREAM_SEEK_CUR, &uliCurPos );

    if( SUCCEEDED( hr ) )
    {
        if( uliCurPos.QuadPart <= m_ullAlertInsertionPt )
        {
            ulBeforeCount = (ULONG)(m_ullAlertInsertionPt - uliCurPos.QuadPart);

            if( cb < ulBeforeCount )
            {
                //--- The insertion point wasn't in this buffer
                return m_cpFormatConverter->Write( pBuff, cb, pcbWritten );
            }
            hr = m_cpFormatConverter->Write( pBuff, ulBeforeCount, &ulBeforeWritten );
        }
        else if ( m_ullAlertInsertionPt )
        {
            //--- Alert insertion point is behind current position - reset and exit!
            m_ullAlertInsertionPt = UNDEFINED_STREAM_POS;
            return m_cpFormatConverter->Write( pBuff, cb, pcbWritten );
        }
    }

    //--- Commit the audio device
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpFormatConverter->Commit( STGC_DEFAULT );
    }

    //--- Flush the audio buffer
    BOOL fThreadExiting = false;
    HANDLE aHandles[] = {m_cpAudioOut->EventHandle(), hExit};
    hr = WaitForQueue( dwCount, aHandles, dwWait, &fThreadExiting );

    if( SUCCEEDED( hr ) && !fThreadExiting )
    {
        //--- Yield the audio device
        SPDBG_ASSERT( m_fAudioStarted );
        m_cpAudioOut->SetState( SPAS_CLOSED, 0 );
        m_fAudioStarted = false;
        m_VoiceStatus.dwRunningState &= ~SPRS_IS_SPEAKING;
        m_AudioMagicMutex.ReleaseMutex();

        //--- Make sure all alerts are finished and reclaim the audio
        while( SUCCEEDED( hr ) && !m_fAudioStarted && !fThreadExiting )
        {
            //--- Wait till alerts are complete before we continue
            dwResult = m_AlertMagicMutex.Wait( hExit, dwWait );
            switch( dwResult )
            {
            case WAIT_OBJECT_0:
                break;
            case WAIT_OBJECT_0 + 1:
                fThreadExiting = true;
                break;
            case WAIT_TIMEOUT:
                hr = SPERR_DEVICE_BUSY;
                break;
            default:
                hr = SpHrFromLastWin32Error();
                break;
            }

            if( SUCCEEDED( hr ) && !fThreadExiting )
            {
                //--- Make sure that any alerts that came during the last alert
                //    happen before we resume.
                bool fDoWrite = true;

                m_AlertMagicMutex.ReleaseMutex();
                if( m_AlertMagicMutex.Wait( NULL, 0 ) == WAIT_OBJECT_0 )
                {
                    //--- If we got the Alert queue then we are guarenteed to be able
                    //    to get the audio queue.
                    m_AudioMagicMutex.Wait( NULL, INFINITE );
                }
                else
                {
                    fDoWrite = false;
                }

                //--- Write the remainder of the buffer
                if( fDoWrite && SUCCEEDED( hr = StartAudio( hExit, dwWait ) ) )
                {
                    pBuff = ((BYTE*)pBuff) + ulBeforeCount;
                    hr = m_cpFormatConverter->Write( pBuff, cb - ulBeforeCount, pcbWritten );
                    if( pcbWritten )
                    {
                        *pcbWritten += ulBeforeWritten;
                    }
                }
            } 
        } //--- end while - trying to obtain queues to complete write
    } //--- end wait - audio buffer flush

    return hr;
} /* CSpVoice::InsertAlerts */

/*****************************************************************************
* CSpVoice::EsAddEvents *
*-----------------------*
*   Description:
*       This method is exposed through ISpTTSEngineSite.  It fills in the
*   stream number, adjusts offsets if necessary and then forwards the events
*   to the appropriate event sink.
********************************************************************* EDC ***/
HRESULT CSpVoice::EsAddEvents( const SPEVENT* pEventArray, ULONG ulCount )
{
    SPDBG_FUNC( "CSpVoice::EsAddEvents" );
    HRESULT hr = S_OK;

    if( !ulCount || SPIsBadReadPtr( pEventArray, sizeof( SPEVENT ) * ulCount ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Assign stream numbers and, validate event structures
        CSpEvent * pCopy = STACK_ALLOC_AND_COPY(CSpEvent, ulCount, pEventArray);
        for( ULONG i = 0; SUCCEEDED(hr) && i < ulCount; i++ )
        {
            //--- Copy and patch in the stream number
            pCopy[i].ulStreamNum = m_ulCurStreamNum;

            //--- Event ID range
            if( ( pCopy[i].eEventId < SPEI_MIN_TTS ) ||
                ( pCopy[i].eEventId > SPEI_MAX_TTS ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                hr = SpValidateEvent(&pCopy[i]);
            }
        }

        if( SUCCEEDED( hr ) )
        {
            //--- Protect access to m_ulPauseCount...
            Lock();

            //--- Only update if not both (a) Paused, and (b) Possessed of a valid alert
            //      insertion point...
            if ( !( m_ulPauseCount &&
                    m_ullAlertInsertionPt != UNDEFINED_STREAM_POS ) )
            {
                //--- Make sure to unlock!
                Unlock();

                //--- Update the alert position if it's on the alert boundary
                for( ULONG i = 0; i < ulCount; i++ )
                {
                    if( pCopy[i].eEventId == m_eAlertBoundary )
                    {
                        GUID guidFormatId;
                        WAVEFORMATEX *pCoMemWaveFormatEx = NULL;

                        m_cpFormatConverter->GetFormat( &guidFormatId, &pCoMemWaveFormatEx );

                        if ( guidFormatId == SPDFID_WaveFormatEx )
                        {
                            //---   Having an alert position which is not on a sample
                            //---   boundary is bogus, and used to cause a hang if the Pause(...)
                            //---   function was called...

                            //--- Assert to try and force engines to give proper offsets...
                            SPDBG_ASSERT( !( pCopy[i].ullAudioStreamOffset % pCoMemWaveFormatEx->nBlockAlign ) );

                            //--- ... but handle it in Release if they don't
                            if ( pCopy[i].ullAudioStreamOffset % pCoMemWaveFormatEx->nBlockAlign )
                            {
                                m_ullAlertInsertionPt = pCopy[i].ullAudioStreamOffset + 
                                                        ( pCoMemWaveFormatEx->nBlockAlign -
                                                          pCopy[i].ullAudioStreamOffset % 
                                                          pCoMemWaveFormatEx->nBlockAlign );
                            }
                            else
                            {
                                m_ullAlertInsertionPt = pCopy[i].ullAudioStreamOffset;
                            }
                        }
                        else
                        {
                            m_ullAlertInsertionPt = pCopy[i].ullAudioStreamOffset;
                        }

                        if ( pCoMemWaveFormatEx != NULL )
                        {
                            ::CoTaskMemFree( pCoMemWaveFormatEx );
                        }
                    }
                }
            }
            else
            {
                //--- Make sure to unlock!
                Unlock();
            }

            //--- Forward the events
            if( m_cpOutputEventSink )
            {
                hr = m_cpOutputEventSink->AddEvents( pCopy, ulCount );
            }
            else
            {
                for (ULONG i = 0; i < ulCount; i++)
                {
                    m_cpFormatConverter->ScaleConvertedToBaseOffset(pCopy[i].ullAudioStreamOffset, &pCopy[i].ullAudioStreamOffset);
                }
                hr = EventsCompleted( pCopy, ulCount );
            }
        }
    }

    return hr;
} /* CSpVoice::EsAddEvents */

/****************************************************************************
* CSpVoice::EsGetEventInterest *
*------------------------------*
*   Description:
*       Returns the event interest for this voice.
********************************************************************* RAL ***/
HRESULT CSpVoice::EsGetEventInterest( ULONGLONG * pullEventInterest )
{
    SPDBG_FUNC("CSpVoice::EsGetEventInterest");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pullEventInterest))
    {
        hr = E_POINTER;
    }
    else
    {
        //--- We want all events plus any private events the client might have set.
        //    We need the standard ones to update status and to detect Alert boundaries.
        *pullEventInterest = m_SpEventSource.m_ullEventInterest |
                             SPFEI_ALL_TTS_EVENTS | m_eAlertBoundary;
    }

    return hr;
} /* CSpVoice::EsGetEventInterest */

/*****************************************************************************
* CSpVoice::EsGetActions *
*------------------------*
*   Description:
*       This method is exposed through ISpTTSEngineSite. The engine calls it
*   to poll whether it is supposed to make a pseudo-real time change.
********************************************************************* EDC ***/
DWORD CSpVoice::EsGetActions( void )
{
    SPDBG_FUNC( "CSpVoice::EsGetActions" );
    m_AsyncCtrlMutex.Wait();
    DWORD dwFlags = (DWORD)m_eActionFlags;
    m_AsyncCtrlMutex.ReleaseMutex();
    return dwFlags;
} /* CSpVoice::EsGetActions */

/*****************************************************************************
* CSpVoice::EsGetRate *
*---------------------*
*   Description:
*       This method is exposed through ISpTTSEngineSite. The engine calls it
*   to find out the new rendering rate.
********************************************************************* EDC ***/
HRESULT CSpVoice::EsGetRate( long* pRateAdjust )
{
    SPDBG_FUNC( "CSpVoice::EsGetRate" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pRateAdjust ) )
    {
        hr = E_POINTER;
    }
    else
    {
        m_AsyncCtrlMutex.Wait();
        *pRateAdjust = m_lCurrRateAdj;
        m_eActionFlags = (SPVESACTIONS)(m_eActionFlags & ~SPVES_RATE);
        m_AsyncCtrlMutex.ReleaseMutex();
    }

    return hr;
} /* CSpVoice::EsGetRate */

/*****************************************************************************
* CSpVoice::EsGetVolume *
*-----------------------*
*   Description:
*       This method is exposed through ISpTTSEngineSite. The engine calls it
*   to find out the new rendering rate.
********************************************************************* EDC ***/
HRESULT CSpVoice::EsGetVolume( USHORT* pusVolume )
{
    SPDBG_FUNC( "CSpVoice::EsGetVolume" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pusVolume ) )
    {
        hr = E_POINTER;
    }
    else
    {
        m_AsyncCtrlMutex.Wait();
        *pusVolume = m_usCurrVolume;
        m_eActionFlags = (SPVESACTIONS)(m_eActionFlags & ~SPVES_VOLUME);
        m_AsyncCtrlMutex.ReleaseMutex();
    }

    return hr;
} /* CSpVoice::EsGetVolume */

/*****************************************************************************
* CSpVoice::EsGetSkipInfo *
*-------------------------*
*   Description:
*       This method is exposed through ISpTTSEngineSite. The engine calls it
*   to find out what to skip.
********************************************************************* EDC ***/
HRESULT CSpVoice::EsGetSkipInfo( SPVSKIPTYPE* peType, long* plNumItems )
{
    SPDBG_FUNC( "CSpVoice::EsGetSkipInfo" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( peType ) || SP_IS_BAD_WRITE_PTR( plNumItems ))
    {
        hr = E_POINTER;
    }
    else
    {
        m_AsyncCtrlMutex.Wait();
        *peType     = m_eSkipType;
        *plNumItems = m_lSkipCount;
        m_AsyncCtrlMutex.ReleaseMutex();
    }
    return hr;
} /* CSpVoice::EsGetSkipInfo */

/*****************************************************************************
* CSpVoice::EsCompleteSkip *
*--------------------------*
*   Description:
*       This method is exposed through ISpTTSEngineSite. The engine calls it
*   to notify SAPI that the skip operation is complete.
********************************************************************* EDC ***/
HRESULT CSpVoice::EsCompleteSkip( long lNumSkipped )
{
    SPDBG_FUNC( "CSpVoice::EsCompleteSkip" );
    HRESULT hr = S_OK;
    m_AsyncCtrlMutex.Wait();
    //--- Validate
    if( m_lSkipCount < 0 )
    {
        if( ( lNumSkipped < m_lSkipCount ) || ( lNumSkipped > 0 ) )
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        if( ( lNumSkipped > m_lSkipCount ) || ( lNumSkipped < 0 ) )
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Update
    if( SUCCEEDED( hr ) )
    {
        m_lSkipCount  -= lNumSkipped;
        m_lNumSkipped  = lNumSkipped;
    }
    else
    {
        m_lSkipCount  = 0;
        m_lNumSkipped = 0;
    }
    m_eActionFlags = (SPVESACTIONS)(m_eActionFlags & ~SPVES_SKIP);
    if( m_lSkipCount < 0 ) m_fRestartSpeak = true;
    m_AsyncCtrlMutex.ReleaseMutex();
    m_ahSkipDoneEvent.SetEvent();
    return hr;
} /* CSpVoice::EsCompleteSkip */

//
//============================================================================
//

/*****************************************************************************
* CSpVoice::EventsCompleted *
*---------------------------*
*   Description:
*       This method is called when events are completed.  It will be called
*       either as a result of an audio device notification or when events are
*       added and there is no audio object.
********************************************************************* EDC ***/
HRESULT CSpVoice::EventsCompleted( const CSpEvent * pEvents, ULONG ulCount )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpVoice::EventsCompleted");
    SPDBG_PMSG1( "Incoming event count: %lu\n", ulCount );
    HRESULT hr = S_OK;
    ULONG i;

    //--- Look for audio events
    for( i = 0; i < ulCount; ++i )
    {
        //--- Dump event
#ifdef _EVENT_DEBUG_
        SPDBG_DMSG1( "EventId: %X\n"   , pEvents[i].eEventId );
        SPDBG_DMSG1( " Offset: %I64X\n", pEvents[i].ullAudioStreamOffset );
        SPDBG_DMSG1( " wParam: %lu\n"  , pEvents[i].wParam );
        SPDBG_DMSG1( " lParam: %lu\n"  , pEvents[i].lParam );
#endif
        //--- We are not doing a switch here because the event ids are
        //    not contiguous values (they are mask flags)
        switch( pEvents[i].eEventId )
        {
          case SPEI_PHONEME:
            m_VoiceStatus.PhonemeId = pEvents[i].Phoneme();
            break;
          case SPEI_VISEME:
            m_VoiceStatus.VisemeId = pEvents[i].Viseme();
            break;
          case SPEI_WORD_BOUNDARY:
            m_VoiceStatus.ulInputWordPos = pEvents[i].InputWordPos();
            m_VoiceStatus.ulInputWordLen = pEvents[i].InputWordLen();
            break;
          case SPEI_TTS_BOOKMARK:
            SPDBG_ASSERT(pEvents[i].elParamType == SPET_LPARAM_IS_STRING);
            SPDBG_ASSERT(pEvents[i].wParam == (WPARAM)_wtol(pEvents[i].BookmarkName()));
            m_dstrLastBookmark = pEvents[i].BookmarkName();
            m_VoiceStatus.lBookmarkId = (long)pEvents[i].wParam;
            break;
          case SPEI_VOICE_CHANGE:
            break;
          case SPEI_SENTENCE_BOUNDARY:
            m_VoiceStatus.ulInputSentPos = pEvents[i].InputSentPos();
            m_VoiceStatus.ulInputSentLen = pEvents[i].InputSentLen();
            break;
          case SPEI_START_INPUT_STREAM:
            ++m_VoiceStatus.ulCurrentStream;
            break;
          case SPEI_END_INPUT_STREAM:
            if( pEvents[i].ulStreamNum == m_VoiceStatus.ulLastStreamQueued )
            {
                m_VoiceStatus.dwRunningState |= SPRS_DONE;  
            }
            break;
        } // end switch()
    } // End for()

    //--- Forward the events
    if( SUCCEEDED( hr ) )
    {
        if( SUCCEEDED( hr = m_SpEventSource._AddEvents( pEvents, ulCount ) ) )
        {
            hr = m_SpEventSource._CompleteEvents();
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpVoice::EventsCompleted */

/*****************************************************************************
* CSpVoice::OnNotify *
*--------------------*
*   Description:
*       This method is called from the CSpContainedNotify object when the audio
*   object calls Notify().  We remove the events from the audio event queue and
*   add them to our event queue.
*
*   WARNING:  Be sure to only do "quick" operations within this callback since
*   the audio device is in a critical section.  Furthermore, only call non-state
*   changing methods on the audio device (get methods) to prevent deadlocks.
********************************************************************* RAL ***/
HRESULT CSpVoice::OnNotify()
{
    ULONG ulFetched;
    SPEVENT aEvents[20];
    do
    {
        m_cpOutputEventSource->GetEvents(sp_countof(aEvents), aEvents, &ulFetched);
        if( ulFetched )
        {
            EventsCompleted(static_cast<CSpEvent *>(aEvents), ulFetched);
            for( ULONG i = 0; i < ulFetched; i++)
            {
                SpClearEvent(aEvents + i);
            }
        }
    } while( ulFetched == sp_countof(aEvents) );
    return S_OK;
} /* CSpVoice::OnNotify */

//
//=== ISpNotifyCallback =======================================================
//  This section contains the methods to implement firing of events to a
//  connection point client.

/*****************************************************************************
* CSpVoice::NotifyCallback *
*--------------------------*
*   Description:
*       This method is used to fire events to the connection point client.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::NotifyCallback( WPARAM wParam, LPARAM lParam )
{
    HRESULT hr = S_OK;
    CSpEvent Event;
    ULONG NumFetched;

    // If we are re-entering ourselves then just bail.  We'll pick up any new
    // event on the next iteration of the while loop.
    if ( m_fHandlingEvent )
    {
        return hr;
    }

    m_fHandlingEvent = TRUE;

    //AddRef so that when you debug in vb, the recocontext object won't go away while you are in this function.
    this->AddRef();
    while( ((hr = Event.GetFrom(this)) == S_OK ) )
    {

        CComVariant varStreamPos;

        ULongLongToVariant( Event.ullAudioStreamOffset, &varStreamPos );

        switch( Event.eEventId )
        {
          case SPEI_START_INPUT_STREAM:
            Fire_StartStream( Event.ulStreamNum, varStreamPos );
            break;
          case SPEI_END_INPUT_STREAM:
            Fire_EndStream( Event.ulStreamNum, varStreamPos );
            break;
          case SPEI_VOICE_CHANGE:
            if( Event.elParamType == SPET_LPARAM_IS_TOKEN )
            {
                CComQIPtr<ISpeechObjectToken> cpTok( Event.VoiceToken() );
                Fire_VoiceChange( Event.ulStreamNum, varStreamPos, cpTok );
            }
            else
            {
                SPDBG_ASSERT(0);    // Engine sent bad parameter
            }
            break;
          case SPEI_TTS_BOOKMARK:
            Fire_Bookmark( Event.ulStreamNum, varStreamPos, CComBSTR( Event.BookmarkName() ), (long)Event.wParam );
            break;
          case SPEI_WORD_BOUNDARY:
            Fire_Word( Event.ulStreamNum, varStreamPos, Event.InputWordPos(), Event.InputWordLen() );
            break;
          case SPEI_SENTENCE_BOUNDARY:
            Fire_Sentence( Event.ulStreamNum, varStreamPos, Event.InputSentPos(), Event.InputSentLen() );
            break;
          case SPEI_PHONEME:
            Fire_Phoneme( Event.ulStreamNum, varStreamPos, HIWORD(Event.wParam), LOWORD(Event.wParam), (SpeechVisemeFeature)HIWORD(Event.lParam), Event.Phoneme() );
            break;          
          case SPEI_VISEME:
            Fire_Viseme( Event.ulStreamNum, varStreamPos, HIWORD(Event.wParam), (SpeechVisemeType)LOWORD(Event.wParam), (SpeechVisemeFeature)HIWORD(Event.lParam), (SpeechVisemeType)Event.Viseme() );
            break;
          case SPEI_TTS_AUDIO_LEVEL:
	        Fire_AudioLevel( Event.ulStreamNum, varStreamPos, (long)Event.wParam );
	        break;
          case SPEI_TTS_PRIVATE:
            {
                CComVariant varLParam;

                hr = FormatPrivateEventData( Event.AddrOf(), &varLParam );

                if ( SUCCEEDED( hr ) )
                {
                    Fire_EnginePrivate(Event.ulStreamNum, varStreamPos, varLParam);
                }
                else
                {
                    SPDBG_ASSERT(0);    // We failed handling lParam data
                }
            }
	        break;
        } // end switch()

        SpClearEvent( Event.AddrOf() );
    }

    //Release the object which has been AddRef earlier in this function.
    this->Release();

    m_fHandlingEvent = FALSE;

    return hr;
} /* CSpVoice::NotifyCallback */

#ifdef SAPI_AUTOMATION
/*****************************************************************************
* CSpVoice::Advise *
*------------------*
*   Description:
*       This method is called when a client is making a connection.
********************************************************************* EDC ***/
HRESULT CSpVoice::Advise( IUnknown* pUnkSink, DWORD* pdwCookie )
{
    HRESULT hr = S_OK;

    hr = CProxy_ISpeechVoiceEvents<CSpVoice>::Advise( pUnkSink, pdwCookie );
    if( SUCCEEDED( hr ) && ( m_vec.GetSize() == 1 ) )
    {
        hr = SetNotifyCallbackInterface( this, NULL, NULL );

        if( SUCCEEDED( hr ) )
        {
            //--- Save previous interest so we can restore during unadvise
            m_ullPrevEventInterest  = m_SpEventSource.m_ullEventInterest;
            m_ullPrevQueuedInterest = m_SpEventSource.m_ullQueuedInterest;

            // Set all interests except SPEI_TTS_AUDIO_LEVEL
            hr = SetInterest( (ULONGLONG)(SVEAllEvents & ~SVEAudioLevel) | SPFEI_FLAGCHECK,
                              (ULONGLONG)(SVEAllEvents & ~SVEAudioLevel) | SPFEI_FLAGCHECK );
        }
    }

    return hr;
} /* CSpVoice::Advise */

/*****************************************************************************
* CSpVoice::Unadvise *
*--------------------*
*   Description:
*       This method is called when a client is breaking a connection.
********************************************************************* EDC ***/
HRESULT CSpVoice::Unadvise( DWORD dwCookie )
{
    HRESULT hr = S_OK;

    hr = CProxy_ISpeechVoiceEvents<CSpVoice>::Unadvise( dwCookie );
    if( SUCCEEDED( hr ) && ( m_vec.GetSize() == 0 ) )
    {
        hr = SetNotifySink( NULL );

        if( SUCCEEDED( hr ) )
        {
            hr = SetInterest( m_ullPrevEventInterest, m_ullPrevQueuedInterest );
        }
    }

    return hr;
} /* CSpVoice::Unadvise */

#endif // SAPI_AUTOMATION

//
//=== ISpThreadTask ================================================================
//
//  These methods implement the ISpThreadTask interface.  They will all be called on
//  a worker thread.

/*****************************************************************************
* CSpVoice::InitThread *
*----------------------*
*   Description:
*       This call is synchronous with StartThread(), so set the m_fThreadRunning
*   flag to TRUE and return.
********************************************************************* RAL ***/
STDMETHODIMP CSpVoice::InitThread(void *, HWND)
{
    m_fThreadRunning = TRUE;
    return S_OK;
}

/*****************************************************************************
* CSpVoice::ThreadProc *
*----------------------*
*   Description:
*       This method is the task proc used for text rendering and for event
*   forwarding.  It may be called on a worker thread for asynchronous speaking, or
*   it may be called on the client thread for synchronous speaking.  If it is
*   called on the client thread, the hExitThreadEvent handle will be NULL.
********************************************************************* RAL ***/
STDMETHODIMP CSpVoice::ThreadProc( void*, HANDLE hExitThreadEvent, HANDLE, HWND,
                                   volatile const BOOL * pfContinueProcessing )
{ 
    SPDBG_FUNC( "CSpVoice::ThreadProc" );
    HRESULT hr = S_OK;
    CSpMagicMutex *pMutex = NULL;

    Lock();
    do
    {
        //--- Get the next speak item
        m_pCurrSI = GetNextSpeakElement( hExitThreadEvent );
        if( m_pCurrSI == NULL )
        {
            //--- Make sure any blocked skip is cleared in case the engine missed it.
            m_AsyncCtrlMutex.Wait();
            long lCompleted = m_lSkipCount;
            m_AsyncCtrlMutex.ReleaseMutex();
            EsCompleteSkip( lCompleted );
            break;
        }

        Unlock();

        //--- Claim the audio the first time through, if we are writing to an audio device.
        //    If synchronization is not desired, pMutex will be NULL.
        if ( pMutex == NULL && m_cpAudioOut)
        {
            hr = ClaimAudioQueue( hExitThreadEvent, &pMutex );
        }

        if (SUCCEEDED(hr))
        {
            m_ulCurStreamNum = m_pCurrSI->m_ulStreamNum;
            hr = InjectEvent( SPEI_START_INPUT_STREAM );
        }

        if (SUCCEEDED(hr))
        {
            if (m_pCurrSI->m_cpInStream)
            {
                hr = PlayAudioStream( pfContinueProcessing );
            }
            else
            {
                hr = SpeakText( pfContinueProcessing );
            }
        }

        //--- Always inject the end of stream and complete even on failure
        //    Note: we're not getting the return codes from these so we
        //          don't overwrite a possible error from above. Also we
        //          really don't care about these errors.
        InjectEvent( SPEI_END_INPUT_STREAM );
        m_SpEventSource._CompleteEvents();

        Lock();     // Always start the loop with the crit section owned and always
                    // fall out of the loop with the critical section owned.
        delete m_pCurrSI;
        m_pCurrSI = NULL;
    } while (*pfContinueProcessing && SUCCEEDED(hr));

    // This must be modified only when in the critical section
    m_fThreadRunning = FALSE;
    Unlock();

    //--- Make sure any blocked skip is cleared in case the engine
    //    missed it and we were terminated mid stream.
    EsCompleteSkip( 0 );

    //--- Restore the audio state
    if( m_fAudioStarted )
    {
        m_cpAudioOut->SetState( SPAS_CLOSED, 0 );
        m_fAudioStarted = false;
        m_VoiceStatus.dwRunningState &= ~SPRS_IS_SPEAKING;
    }

    //--- Release the queues if we had them
    if ( pMutex )
    {
        pMutex->ReleaseMutex();
        m_AudioMagicMutex.ReleaseMutex();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpVoice::ThreadProc */


/****************************************************************************
* CSpVoice::GetNextSpeakElement *
*-------------------------------*
*   Description:
*       Must be called with the critical section owned exactly one time.  This method
*   may release and reclaim the critical section, but it will always return with the
*   critical section owned exactly one time.    
*
*   Returns:
*       NULL if main speak loop should exit otherwise, a pointer to the next CSpeakInfo
*
********************************************************************* RAL ***/
CSpeakInfo * CSpVoice::GetNextSpeakElement( HANDLE hExitThreadEvent )
{
    CSpeakInfo * pSI = m_PendingSpeakList.RemoveHead();
    if( pSI == NULL )
    {   
        m_autohPendingSpeaks.ResetEvent();
        if( m_fAudioStarted )
        {
            Unlock();                             // Unlock BEFORE commit() since EventNotification holds audio crit section
            m_cpAudioOut->Commit(STGC_DEFAULT);   // Force the audio device to start writing
            //
            //  hExitThreadEvent will be NULL if we're called synchronously, so place it at
            //  the end of the array and don't include it if it's null.
            //
            HANDLE ah[] = {m_autohPendingSpeaks, m_cpAudioOut->EventHandle(), hExitThreadEvent};
            const ULONG cObjs = (ULONG)(hExitThreadEvent ? sp_countof(ah) : sp_countof(ah)-1);
            ::WaitForMultipleObjects(cObjs, ah, FALSE, INFINITE);
            Lock();
            //
            //  No matter why we wake up, we should remove the head.  One of three possible
            //  events fired:  EndThread, PendingSpeaks, or AudioDone.  In the case of AudioDone
            //  being set first, there is a possible race condition where just as the audio
            //  completes, something new is added to the speak queue.  So, if we simply
            //  relied on the event which woke us up to determine if we should remove the
            //  head of the queue, we could cause the voice to hang.
            //
            pSI = m_PendingSpeakList.RemoveHead();
        }
    }
    return pSI;
} /* CSpVoice::GetNextSpeakElement */

/****************************************************************************
* CSpVoice::StartAudio *
*----------------------*
*   Description:
*       This method is used to start the audio device if needed.
******************************************************************** EDC ***/
HRESULT CSpVoice::StartAudio( HANDLE hExitThreadEvent, DWORD dwWait )
{
    SPDBG_FUNC("CSpVoice::StartAudio");
    HRESULT hr = S_OK;

    if( m_cpAudioOut && !m_fAudioStarted )
    {
        hr = m_cpAudioOut->SetState(SPAS_RUN , 0);
        while (hr == SPERR_DEVICE_BUSY)
        {
            ULONG ulWait = min( dwWait, 1000 );
            if( hExitThreadEvent )
            {
                if( ::WaitForSingleObject(hExitThreadEvent, ulWait) == WAIT_OBJECT_0 )
                {
                    break;
                }
            }
            else
            {
                Sleep(ulWait);
                dwWait -= ulWait;
            }
            hr = m_cpAudioOut->SetState(SPAS_RUN, 0);
            if( ulWait == 0 )
            {
                break;
            }
        }
        if( SUCCEEDED(hr) )
        {
            m_fAudioStarted = TRUE;
            m_VoiceStatus.dwRunningState |= SPRS_IS_SPEAKING;
        }
    }

    return hr;
} /* CSpVoice::StartAudio */

/****************************************************************************
* CSpVoice::ClaimAudioQueue *
*---------------------------*
*   Description:
*       This method is used to claim the appropriate mutex based on the
*   current voice priority, and start the audio device if needed.
******************************************************************** EDC ***/
HRESULT CSpVoice::ClaimAudioQueue( HANDLE hExitThreadEvent, CSpMagicMutex **ppMutex )
{
    SPDBG_FUNC("CSpVoice::ClaimAudioQueue");
    HRESULT hr = S_OK;
    DWORD dwWaitResult = WAIT_OBJECT_0, dwMaxWait, dwCount;

    //--- Get the queues ( do nothing for OVER case )
    if( m_fSerializeAccess && m_eVoicePriority != SPVPRI_OVER )
    {
        if ( m_eVoicePriority == SPVPRI_NORMAL )
        { 
            *ppMutex = &m_NormalMagicMutex;
        }
        else
        {
            *ppMutex = &m_AlertMagicMutex;
        }

        if( hExitThreadEvent )
        {
            dwMaxWait = INFINITE;
            dwCount   = 2;
        }
        else
        {
            dwMaxWait = m_ulSyncSpeakTimeout;
            dwCount   = 1;
        }

        dwWaitResult = (*ppMutex)->Wait( hExitThreadEvent, (hExitThreadEvent)?(INFINITE):(m_ulSyncSpeakTimeout) );
        switch ( dwWaitResult )
        {
        case WAIT_OBJECT_0:
            dwWaitResult = m_AudioMagicMutex.Wait( hExitThreadEvent, (hExitThreadEvent)?(INFINITE):(m_ulSyncSpeakTimeout) );
            if( dwWaitResult != WAIT_OBJECT_0 )
            {
                (*ppMutex)->ReleaseMutex();
                switch( dwWaitResult )
                {
                case WAIT_TIMEOUT:
                    hr = SPERR_DEVICE_BUSY;
                    break;
                case WAIT_OBJECT_0 + 1:
                    hr = S_OK;  // Everything's OK, we're just exiting the thread
                    break;
                default:
                    hr = SpHrFromLastWin32Error();
                    break;
                }
            }
            break;
        case WAIT_OBJECT_0 + 1:
            hr = S_OK;  // Everything's OK, we're just exiting the thread
            break;
        case WAIT_TIMEOUT:
            hr = SPERR_DEVICE_BUSY;
            break;
        default:
            hr = SpHrFromLastWin32Error();
            break;
        }
    }
    else
    {
        *ppMutex = NULL;
    }

    //--- Start the audio device if necessary and if we successfully claimed the queue
    if( SUCCEEDED( hr ) && ( dwWaitResult == WAIT_OBJECT_0 ) )
    {
        hr = StartAudio( hExitThreadEvent, dwMaxWait );
    }

    return hr;
} /* CSpVoice::ClaimAudio */

/****************************************************************************
* CSpVoice::PlayAudioStream *
*---------------------------*
*   Description:
*       This method is used to copy a wav stream to the output device.
********************************************************************* EDC ***/
HRESULT CSpVoice::PlayAudioStream( volatile const BOOL* pfContinue )
{
    SPDBG_FUNC("CSpVoice::PlayAudioStream");
    HRESULT hr = S_OK;

    hr = m_cpFormatConverter->SetFormat(m_pCurrSI->m_InStreamFmt.FormatId(), m_pCurrSI->m_InStreamFmt.WaveFormatExPtr());

    if( SUCCEEDED( hr ) )
    {
        //---  First, suck out any events and stick them in the the event queue.
        CComQIPtr<ISpEventSource> cpEventSource(m_pCurrSI->m_cpInStream);
        if( cpEventSource )
        {
            //--- Init the alert insertion point
            m_ullAlertInsertionPt = 0;

            while( TRUE )
            {
                SPEVENT aEvents[10];
                ULONG ulFetched;
                hr = cpEventSource->GetEvents(sp_countof(aEvents), aEvents, &ulFetched);
                if( SUCCEEDED( hr ) && ulFetched )
                {
                    hr = EsAddEvents( aEvents, ulFetched );
                    for (ULONG i = 0; i < ulFetched; i++)
                    {
                        SpClearEvent(aEvents + i);
                    }
                }
                else
                {
                    SPDBG_ASSERT( SUCCEEDED( hr ) );
                    break;
                }
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        //--- We don't want to use CopyTo() because we need to exit if
        //    the output stream has stopped. We call the Engine site
        //    write to pick up any wav format conversions necessary.
        BYTE aBuffer[0x1000];   // Do 4k reads
        do
        {
            ULONG cbActuallyRead = 0;
            hr = m_pCurrSI->m_cpInStream->Read( aBuffer, sizeof(aBuffer), &cbActuallyRead );
            if( SUCCEEDED( hr ) )
            {
                if( cbActuallyRead )
                {
                    hr = EsWrite( aBuffer, cbActuallyRead, NULL );    // Could return STOPPED
                }
                else
                {
                    break;
                }
            }
        } while ( SUCCEEDED(hr) );
    }

    return hr;
} /* CSpVoice::PlayAudioStream */

/****************************************************************************
* CSpVoice::SpeakText *
*---------------------*
*   Description:
*       This method renders the current speak info structure. It may be
*   made up of one or more speech segements, each intended for a different
*   voice/engine.
*
*   Note: We are safely using SEH and destructors within this function so
*         we can disable the warning.
******************************************************************** EDC ***/
#pragma warning( disable : 4509 )
HRESULT CSpVoice::SpeakText( volatile const BOOL* pfContinue )
{
    SPDBG_FUNC("CSpVoice::SpeakText");
    HRESULT hr = S_OK;

    //=== Main processing loop ===========================================
    CSpeechSeg* pSeg = m_pCurrSI->m_pSpeechSegList;
    while( *pfContinue && pSeg && SUCCEEDED(hr) )
    {
        //--- Update the current rendering engine
        Lock();
        m_cpCurrEngine = pSeg->GetVoice();
        Unlock();

        //--- Fire voice change event
        //    Note: scoped to free COM pointers
        if (SUCCEEDED(hr))
        {
            CComPtr<ISpObjectToken> cpVoiceToken;
            CComQIPtr<ISpObjectWithToken> cpObj( m_cpCurrEngine );
            if( SUCCEEDED( hr = cpObj->GetObjectToken( &cpVoiceToken ) ) )
            {
                //--- Check whether to continue using default voice (if a voice change
                //    has been made via XML with the SPF_PERSIST_XML flag, stop getting
                //    the default from the registry)
                if ( m_pCurrSI->m_dwSpeakFlags & SPF_PERSIST_XML )
                {
                    m_fUseDefaultVoice = FALSE;
                    hr = SetVoiceToken( cpVoiceToken );
                }
                if ( SUCCEEDED( hr ) )
                {
                    hr = InjectEvent( SPEI_VOICE_CHANGE, cpVoiceToken );
                }
            }
        }

        //--- Check whether to continue using default rate
        if ( SUCCEEDED( hr ) &&
             m_fUseDefaultRate )
        {
            if ( pSeg->fRateFlagIsSet() &&
                 m_pCurrSI->m_dwSpeakFlags & SPF_PERSIST_XML )
            {
                m_fUseDefaultRate = FALSE;
            }
        }

        //--- We only do segements that have fragment lists
        if( SUCCEEDED(hr) && pSeg->GetFragList() && *pfContinue)
        {
            if (SUCCEEDED(hr) && pSeg->VoiceFormat().FormatId() != SPDFID_Text )
            {
                // The format converter doesn't understand GUID = SPDFID_Text
                hr = m_cpFormatConverter->SetFormat( pSeg->VoiceFormat().FormatId(), pSeg->VoiceFormat().WaveFormatExPtr() );
            }

            //--- Set the action flags so that the engine gets the
            //    current real time rate and volume
            m_AsyncCtrlMutex.Wait();
            m_eActionFlags = (SPVESACTIONS)(m_eActionFlags | SPVES_RATE | SPVES_VOLUME );
            m_AsyncCtrlMutex.ReleaseMutex();

            //--- Speak the segment
            if( SUCCEEDED( hr ) )
            {
                //--- We are going to protect against faults in external components.
                //    during release builds only.
                TTS_TRY
                {
                    while(1)
                    {
                        //--- Init the alert insertion point
                        m_ullAlertInsertionPt = 0;

                        hr = m_cpCurrEngine->Speak( m_pCurrSI->m_dwSpeakFlags & SPF_NLP_MASK,
                                                    pSeg->VoiceFormat().FormatId(),
                                                    pSeg->VoiceFormat().WaveFormatExPtr(),
                                                    pSeg->GetFragList(),
                                                    &m_SpEngineSite );

                        //=== For SAPI5, we do not backup across speak calls. So
                        //    if the engine couldn't back up enough, we set the
                        //    count to zero and start the current speak again.
                        if( m_fRestartSpeak )
                        {
                            m_fRestartSpeak = false;
                            m_cpFormatConverter->ResetSeekPosition();
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                TTS_EXCEPT;

                //--- Record the speak result in the voice status
                m_VoiceStatus.hrLastResult = hr;
            }
        } // end if we have a frag list

        //--- Advance to next segment
        pSeg = pSeg->GetNextSeg();
    } // end while

    //--- Set the current engine back to NULL
    Lock();
    m_cpCurrEngine.Release();
    Unlock();

    return hr;
} /* CSpVoice::SpeakText */
#pragma warning( default : 4509 )

/*****************************************************************************
* CSpVoice::WindowMessage *
*-------------------------*
*   Description:
*       Get the user's default rate from the registry
********************************************************************* AARONHAL ***/
void CSpVoice::GetDefaultRate( void )
{
    //--- Read the current user's default rate
    CComPtr<ISpObjectTokenCategory> cpCategory;
    if (SUCCEEDED(SpGetCategoryFromId(SPCAT_VOICES, &cpCategory)))
    {
        CComPtr<ISpDataKey> cpDataKey;
        if (SUCCEEDED(cpCategory->GetDataKey(SPDKL_CurrentUser, &cpDataKey)))
        {
            cpDataKey->GetDWORD(SPVOICECATEGORY_TTSRATE, (ULONG*)&m_lCurrRateAdj);
        }
    }
} /* CSpVoice::GetDefaultRate */

  
/*****************************************************************************
* CSpVoice::WindowMessage *
*-------------------------*
*   Description:
*       Since we don't allocate a window handle this should never be called.
********************************************************************* RAL ***/
STDMETHODIMP_(LRESULT) CSpVoice::WindowMessage(void *, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_ASSERT(0); // How the heck did we get here!?
    return ::DefWindowProc(hWnd, Msg, wParam, lParam);
}

/*****************************************************************************
* CSpVoice::InjectEvent *
*-----------------------*
*   Description:
*       Simple helper that adds an event to the event queue.  If the pToken is NULL,
*   then it is assumed that the lparam is undefined.
********************************************************************* RAL ***/
HRESULT CSpVoice::InjectEvent( SPEVENTENUM eEventId, ISpObjectToken * pToken, WPARAM wParam )
{
    HRESULT hr = S_OK;
    m_cpFormatConverter->ResetSeekPosition();

    //--- We don't use CSpEvent here to avoid unnecessary
    //    addref/release of token pointers
    SPEVENT Event;
    SpInitEvent(&Event);        // Zero the structure.
    Event.eEventId    = eEventId;
    Event.wParam      = wParam;
    Event.ulStreamNum = m_ulCurStreamNum;

    if( pToken )
    {
        Event.lParam      = (LPARAM)pToken;
        Event.elParamType = SPET_LPARAM_IS_TOKEN;
    }

    return EsAddEvents( &Event, 1 );
} /* CSpVoice::InjectEvent */


/*****************************************************************************
* CSpVoice::GetInterests *
*-----------------------*
*   Description:
*       Simple helper that gets the currently set event interests on the SpVoice.
*
********************************************************************* Leonro ***/
HRESULT CSpVoice::GetInterests(ULONGLONG* pullInterests, ULONGLONG* pullQueuedInterests)
{
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pullInterests ) || SP_IS_BAD_OPTIONAL_WRITE_PTR( pullQueuedInterests ))
    {
        hr = E_POINTER;
    }
    else
    {
        if( pullInterests )
        {
            *pullInterests = m_SpEventSource.m_ullEventInterest;
        }

        if( pullQueuedInterests )
        {
            *pullQueuedInterests = m_SpEventSource.m_ullQueuedInterest;
        }
    }

    return hr;
} /* CSpVoice::GetInterests */

/*****************************************************************************
* CSpEngineSite Delegation *
*--------------------------*
*   Description:
*       Set of methods that delegate everything except QI to the voice
********************************************************************* EDC ***/
HRESULT CSpEngineSite::QueryInterface( REFIID iid, void** ppvObject )
{
    HRESULT hr = S_OK;
    if ( SP_IS_BAD_WRITE_PTR(ppvObject) )
    {
        hr = E_POINTER;
    }
    else 
    {
        if (iid == IID_IUnknown ||
            iid == IID_ISpEventSink ||
            iid == IID_ISpTTSEngineSite )
        {
            *ppvObject = this;
            AddRef();
        } 
        else 
        {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}

ULONG CSpEngineSite::AddRef(void)
    { return m_pVoice->AddRef(); }
ULONG CSpEngineSite::Release(void)
    { return m_pVoice->Release(); }
HRESULT CSpEngineSite::AddEvents(const SPEVENT* pEventArray, ULONG ulCount )
    { return m_pVoice->EsAddEvents(pEventArray, ulCount); }
HRESULT CSpEngineSite::GetEventInterest( ULONGLONG * pullEventInterest )
    { return m_pVoice->EsGetEventInterest (pullEventInterest); }
HRESULT CSpEngineSite::Write( const void* pBuff, ULONG cb, ULONG *pcbWritten )
    { return m_pVoice->EsWrite(pBuff, cb, pcbWritten); }
DWORD CSpEngineSite::GetActions( void )
    { return m_pVoice->EsGetActions(); }
HRESULT CSpEngineSite::GetRate( long* pRateAdjust )
    { return m_pVoice->EsGetRate( pRateAdjust ); }
HRESULT CSpEngineSite::GetVolume( USHORT* pusVolume )
    { return m_pVoice->EsGetVolume( pusVolume ); }
HRESULT CSpEngineSite::GetSkipInfo( SPVSKIPTYPE* peType, long* plNumItems )
    { return m_pVoice->EsGetSkipInfo( peType, plNumItems ); }
HRESULT CSpEngineSite::CompleteSkip( long lNumSkipped )
    { return m_pVoice->EsCompleteSkip( lNumSkipped ); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spvoice.h ===
/*******************************************************************************
* SpVoice.h *
*-----------*
*   Description:
*       This is the header file for the CSpVoice implementation. This object
*   controls all TTS functionality in SAPI.
*-------------------------------------------------------------------------------
*  Created By: EDC                            Date: 08/14/98
*  Copyright (C) 1998, 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#ifndef SpVoice_h
#define SpVoice_h

//--- Additional includes
#include "SpMagicMutex.h"
#include "SpVoiceXML.h"
#include "a_voice.h"

#include <stdio.h>

#ifndef SPEventQ_h
#include <SPEventQ.h>
#endif

#include "resource.h"
#include "a_voiceCP.h"
#include "SpContainedNotify.h"

//=== Constants ====================================================
#define UNDEFINED_STREAM_POS    0xFFFFFFFFFFFFFFFF

//  This macro is used to take the state-change critical section for the duration of a call
//  and will also optionally call _PurgeAll() if bPurge is TRUE, and then will take the object
//  lock.
//
//  It is used on all public member functions that change the state of the voice, such as
//  Speak, SpeakStream, Pause/Resume, SetOutput, etc...
//
#define ENTER_VOICE_STATE_CHANGE_CRIT( bPurge ) \
    CSPAutoCritSecLock statelck( &m_StateChangeCritSec ); \
    if( bPurge ) PurgeAll(); \
    CSPAutoObjectLock lck(this);

//=== Class, Enum, Struct and Union Declarations ===================
class CSpVoice;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================
        
/*** CSpeakInfo
*   This structure is used to maintain queued rendering information
*/
class CSpeakInfo
{
public:
    CSpeakInfo      *m_pNext;
    ULONG            m_ulStreamNum;        // Input stream number
    CComPtr<ISpStreamFormat> m_cpInStream; // Input stream
    WCHAR*           m_pText;              // Input text buffer
    CSpeechSeg*      m_pSpeechSegList;     // Engine arguments
    CSpeechSeg*      m_pSpeechSegListTail; // Engine arguments
    CSpStreamFormat  m_InStreamFmt;        // Input stream format
    CSpStreamFormat  m_OutStreamFmt;       // Output stream format
    DWORD            m_dwSpeakFlags;       // Original flags passed to Speak()
    HRESULT          m_hr;                 // [out]Return code

    CSpeakInfo( ISpStreamFormat* pWavStrm, WCHAR* pText,
                const CSpStreamFormat & OutFmt,
                DWORD dwSpeakFlags, HRESULT * phr ) 
    {
        m_pNext              = NULL;
        m_ulStreamNum        = 0;
        m_pText              = pText;
        m_cpInStream         = pWavStrm;
        m_hr                 = S_OK;
        m_dwSpeakFlags       = dwSpeakFlags;
        m_pSpeechSegList     = NULL;
        m_pSpeechSegListTail = NULL;
        if (pWavStrm)
        {
            *phr = m_InStreamFmt.AssignFormat(pWavStrm);
        }
        else
        {
            *phr = m_InStreamFmt.AssignFormat(SPDFID_Text, NULL);
        }
        if (SUCCEEDED(*phr))
        {
            *phr = m_OutStreamFmt.AssignFormat(OutFmt);
        }
    }

    ~CSpeakInfo()
    {
        delete m_pText;
        CSpeechSeg *pNext;
        while( m_pSpeechSegList )
        {
            pNext = m_pSpeechSegList->GetNextSeg();
            delete m_pSpeechSegList;
            m_pSpeechSegList = pNext;
        }
        m_pSpeechSegList = NULL;
    }

    HRESULT AddNewSeg( ISpTTSEngine* pCurrVoice, CSpeechSeg** ppNew );
    ULONG   DetermineVoiceFmtIndex( ISpTTSEngine* pVoice );

#ifdef _WIN32_WCE
    CSpeakInfo() {}
    static LONG Compare(const CSpeakInfo *, const CSpeakInfo *)
    {
        return 0;
    }
#endif
};

/*** CSpEngineSite COM object ********************************
*
*/
class CSpVoice; // forward declaration

class CSpEngineSite : public ISpTTSEngineSite
{
private:
    CSpVoice* m_pVoice;

public:
    CSpEngineSite (CSpVoice* pVoice) { m_pVoice = pVoice; };

    //--- IUnknown  --------------------------------------
    STDMETHOD(QueryInterface) ( REFIID iid, void** ppvObject );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release) (void);

    //--- ISpTTSEngineSite --------------------------------------
    STDMETHOD(AddEvents)(const SPEVENT* pEventArray, ULONG ulCount );
    STDMETHOD(GetEventInterest)( ULONGLONG * pullEventInterest );
    STDMETHOD_(DWORD, GetActions)( void );
    STDMETHOD(Write)( const void* pBuff, ULONG cb, ULONG *pcbWritten );
    STDMETHOD(GetRate)( long* pRateAdjust );
    STDMETHOD(GetVolume)( USHORT* pusVolume );
    STDMETHOD(GetSkipInfo)( SPVSKIPTYPE* peType, long* plNumItems );
    STDMETHOD(CompleteSkip)( long lNumSkipped );
};

/*** CSpVoice COM object ********************************
*
*/
class ATL_NO_VTABLE CSpVoice : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpVoice, &CLSID_SpVoice>,
    public ISpVoice,
    public ISpThreadTask
    //--- Automation
    #ifdef SAPI_AUTOMATION
    , public ISpNotifyCallback,
    public IDispatchImpl<ISpeechVoice, &IID_ISpeechVoice, &LIBID_SpeechLib, 5>,
    public CProxy_ISpeechVoiceEvents<CSpVoice>,
    public IProvideClassInfo2Impl<&CLSID_SpVoice, NULL, &LIBID_SpeechLib, 5>,
    public IConnectionPointContainerImpl<CSpVoice>
    #endif
{
    friend CSpeakInfo;
    friend CSpeechSeg;
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SPVOICE)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpVoice)
        COM_INTERFACE_ENTRY(ISpVoice)
        COM_INTERFACE_ENTRY(ISpEventSource)
        COM_INTERFACE_ENTRY(ISpNotifySource)
        //--- Automation
        #ifdef SAPI_AUTOMATION
        COM_INTERFACE_ENTRY(ISpeechVoice)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IConnectionPointContainer)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        #endif // SAPI_AUTOMATION
    END_COM_MAP()

    //--- Automation
    #ifdef SAPI_AUTOMATION
    BEGIN_CONNECTION_POINT_MAP(CSpVoice)
        CONNECTION_POINT_ENTRY(DIID__ISpeechVoiceEvents)
    END_CONNECTION_POINT_MAP()
    #endif // SAPI_AUTOMATION

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CSpVoice() :
        m_SpEventSource(this),
        m_SpContainedNotify(this),
        m_SpEngineSite(this) {}

	HRESULT FinalConstruct();
	void FinalRelease();
    void _ReleaseOutRefs();

    /*--- Non interface methods ---*/
    HRESULT OnNotify( void );
    HRESULT LazyInit( void );
    HRESULT PurgeAll( void ); 
    HRESULT QueueNewSpeak( ISpStreamFormat* pWavStrm, WCHAR* pText, 
                           DWORD dwFlags, ULONG * pulStreamNum );
    HRESULT LoadStreamIntoMem( IStream* pStream, WCHAR** ppText );
    HRESULT InjectEvent( SPEVENTENUM eEventId, ISpObjectToken * pToken = NULL, WPARAM wParam = 0 );
    HRESULT EventsCompleted( const CSpEvent * pEvents, ULONG ulCount );
    HRESULT PopXMLState( void );
    void    ResetVoiceStatus();
    void    FireAutomationEvent( SPEVENTENUM eEventId );
    HRESULT SetVoiceToken( ISpObjectToken * pVoiceToken );
    ISpTTSEngine* GetCurrXMLVoice( void )
        { return (m_GlobalStateStack.GetVal()).pVoiceEntry->m_cpVoice; }
    HRESULT GetInterests(ULONGLONG* pullInterests, ULONGLONG* pullQueuedInterests);

    //--- XML support methods
    HRESULT ParseXML( CSpeakInfo& SI );
    HRESULT SetXMLVoice( XMLTAG& Tag, CVoiceNode* pVoiceNode, CPhoneConvNode* pPhoneConvNode );
    HRESULT SetXMLLanguage( XMLTAG& Tag, CVoiceNode* pVoiceNode, CPhoneConvNode* pPhoneConvNode );
    HRESULT ConvertPhonStr2Bin( XMLTAG& Tag, int AttrIndex, SPVTEXTFRAG* pFrag );

    //--- Methods used by ThreadProc
    CSpeakInfo* GetNextSpeakElement(HANDLE hExitThreadEvent );
    HRESULT ClaimAudioQueue( HANDLE hExitThreadEvent, CSpMagicMutex **ppMutex );
    HRESULT StartAudio( HANDLE hExitThreadEvent, DWORD dwWait );
    HRESULT DoPause( HANDLE hExit, DWORD dwWait, const void* pBuff, ULONG cb, ULONG *pcbWritten );
    HRESULT InsertAlerts( HANDLE hExit, DWORD dwWait, const void* pBuff, ULONG cb, ULONG *pcbWritten );
    HRESULT PlayAudioStream( volatile const BOOL* pfContinueProcessing );
    HRESULT SpeakText( volatile const BOOL* pfContinueProcessing );

#ifdef SAPI_AUTOMATION
    // Override this to fix the jscript problem passing NULL objects.
    STDMETHOD(Invoke) ( DISPID          dispidMember,
                        REFIID          riid,
                        LCID            lcid,
                        WORD            wFlags,
                        DISPPARAMS 		*pdispparams,
                        VARIANT 		*pvarResult,
                        EXCEPINFO 		*pexcepinfo,
                        UINT 			*puArgErr);

    //--- IConnectionPointImpl overrides
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
#endif // SAPI_AUTOMATION

    //--- ISpTTSEngineSite delegates --------------------------------
    HRESULT EsAddEvents(const SPEVENT* pEventArray, ULONG ulCount );
    HRESULT EsGetEventInterest( ULONGLONG * pullEventInterest );
    HRESULT EsWrite( const void* pBuff, ULONG cb, ULONG *pcbWritten );
    DWORD   EsGetActions( void );
    HRESULT EsGetRate( long* pRateAdjust );
    HRESULT EsGetVolume( USHORT* pusVolume );
    HRESULT EsGetSkipInfo( SPVSKIPTYPE* peType, long* plNumItems );
    HRESULT EsCompleteSkip( long lNumSkipped );

  private:
    void GetDefaultRate( void );

  /*=== Interfaces ====*/
  public:
    //--- Forward interface ISpEventSource ----------------------
    DECLARE_SPEVENTSOURCE_METHODS(m_SpEventSource)

    //--- ISpVoice ----------------------------------------------
	STDMETHOD(SetOutput)( IUnknown * pUnkOutput, BOOL fAllowFormatChanges );
	STDMETHOD(GetOutputObjectToken)( ISpObjectToken ** ppToken );
	STDMETHOD(GetOutputStream)( ISpStreamFormat ** ppOutputStream );
	STDMETHOD(Pause)( void );
	STDMETHOD(Resume)( void );
	STDMETHOD(SetVoice)( ISpObjectToken * pVoiceToken );
	STDMETHOD(GetVoice)( ISpObjectToken ** ppVoiceToken );
    STDMETHOD(Speak)( const WCHAR* pwcs, DWORD dwFlags, ULONG* pulStreamNum );
	STDMETHOD(SpeakStream)( IStream* pStream, DWORD dwFlags, ULONG * pulStreamNum );
	STDMETHOD(GetStatus)( SPVOICESTATUS *pStatus, WCHAR** ppszBookmark );
    STDMETHOD(Skip)( WCHAR* pItemType, long lNumItems, ULONG* pulNumSkipped );
    STDMETHOD(SetPriority)( SPVPRIORITY ePriority );
    STDMETHOD(GetPriority)( SPVPRIORITY* pePriority );
    STDMETHOD(SetAlertBoundary)( SPEVENTENUM eBoundary );
    STDMETHOD(GetAlertBoundary)( SPEVENTENUM* peBoundary );
	STDMETHOD(SetRate)( long RateAdjust );
    STDMETHOD(GetRate)( long* pRateAdjust );
	STDMETHOD(SetVolume)( USHORT usVolume );
	STDMETHOD(GetVolume)( USHORT* pusVolume );
    STDMETHOD(WaitUntilDone)( ULONG msTimeOut );
    STDMETHOD(SetSyncSpeakTimeout)( ULONG msTimeout );
    STDMETHOD(GetSyncSpeakTimeout)( ULONG * pmsTimeout );
    STDMETHOD_(HANDLE, SpeakCompleteEvent)(void);
    STDMETHOD(IsUISupported)(const WCHAR *pszTypeOfUI, void * pvExtraData, ULONG cbExtraData, BOOL *pfSupported);
    STDMETHOD(DisplayUI)(HWND hwndParent, const WCHAR * pszTitle, const WCHAR * pszTypeOfUI, void * pvExtraDAta, ULONG cbExtraData);

    //--- ISpThreadTask -----------------------------------------
    STDMETHOD(InitThread)( void *pvTaskData, HWND hwnd );
	STDMETHOD(ThreadProc)( void *pvTaskData, HANDLE hExitThreadEvent, HANDLE hIgnored, HWND hwndIgnored, volatile const BOOL * pfContinueProcessing );
    STDMETHOD_(LRESULT, WindowMessage) (void *, HWND, UINT, WPARAM, LPARAM);

    //--- ISpNotifyCallback -----------------------------------
    STDMETHOD(NotifyCallback)( WPARAM wParam, LPARAM lParam );

#ifdef SAPI_AUTOMATION
    //--- ISpeechVoice ----------------------------------------
	STDMETHOD(get_Status)( ISpeechVoiceStatus** Status );
    STDMETHOD(get_Voice)( ISpeechObjectToken ** Voice );
  	STDMETHOD(putref_Voice)( ISpeechObjectToken * Voice );
  	STDMETHOD(get_AudioOutput)( ISpeechObjectToken** AudioOutput );
  	STDMETHOD(putref_AudioOutput)( ISpeechObjectToken* AudioOutput );
    STDMETHOD(get_AudioOutputStream)( ISpeechBaseStream** AudioOutputStream );
    STDMETHOD(putref_AudioOutputStream)( ISpeechBaseStream* AudioOutputStream );
  	STDMETHOD(get_Rate)( long* Rate );
  	STDMETHOD(put_Rate)( long Rate );
  	STDMETHOD(get_Volume)( long* Volume );
	STDMETHOD(put_Volume)( long Volume );
    STDMETHOD(put_AllowAudioOutputFormatChangesOnNextSet)( VARIANT_BOOL Allow );
    STDMETHOD(get_AllowAudioOutputFormatChangesOnNextSet)( VARIANT_BOOL* Allow );
    STDMETHOD(put_EventInterests)( SpeechVoiceEvents EventInterestFlags );
    STDMETHOD(get_EventInterests)( SpeechVoiceEvents* EventInterestFlags );
    STDMETHOD(put_Priority)( SpeechVoicePriority Priority );
    STDMETHOD(get_Priority)( SpeechVoicePriority* Priority );
    STDMETHOD(put_AlertBoundary)( SpeechVoiceEvents Boundary );
    STDMETHOD(get_AlertBoundary)( SpeechVoiceEvents* Boundary );
    STDMETHOD(put_SynchronousSpeakTimeout)( long msTimeout );
    STDMETHOD(get_SynchronousSpeakTimeout)( long* msTimeout );
    STDMETHOD(Speak)( BSTR Text, SpeechVoiceSpeakFlags Flags, long* pStreamNumber );
    STDMETHOD(SpeakStream)( ISpeechBaseStream* pStream, SpeechVoiceSpeakFlags Flags, long* pStreamNumber );
	STDMETHOD(Skip)( const BSTR Type, long NumItems, long* NumSkipped );
    STDMETHOD(GetVoices)( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens );
    STDMETHOD(GetAudioOutputs)( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens );
    STDMETHOD(WaitUntilDone)( long msTimeout, VARIANT_BOOL * pDone );
    STDMETHOD(SpeakCompleteEvent)( long* Handle );
    STDMETHOD(IsUISupported)( const BSTR TypeOfUI, const VARIANT* ExtraData, VARIANT_BOOL* Supported );
    STDMETHOD(DisplayUI)( long hWndParent, BSTR Title, const BSTR TypeOfUI, const VARIANT* ExtraData );
    // Use ISpVoice implementation for these.
	//STDMETHOD(Pause)( void );
	//STDMETHOD(Resume)( void );
#endif // SAPI_AUTOMATION


  /*=== Member Data ===*/
  protected:
    CComPtr<ISpTaskManager>      m_cpTaskMgr;
    BOOL                         m_fThreadRunning:1;
    BOOL                         m_fQueueSpeaks:1;
    CSpEngineSite                m_SpEngineSite;

    //--- Events
    CSpEventSource               m_SpEventSource;
    CSpContainedNotify<CSpVoice> m_SpContainedNotify;
    CComPtr<ISpEventSink>        m_cpOutputEventSink;
    CComPtr<ISpEventSource>      m_cpOutputEventSource;
    ULONGLONG                    m_ullPrevEventInterest;        // Only used to restore interest
    ULONGLONG                    m_ullPrevQueuedInterest;       // after connection points removed

    //--- Handles for audio synchronization
    BOOL                         m_fSerializeAccess;
    CSpMagicMutex                m_AlertMagicMutex;
    CSpMagicMutex                m_NormalMagicMutex;
    CSpMagicMutex                m_AudioMagicMutex;
    CSpAutoEvent                 m_autohPendingSpeaks;
    ULONG                        m_ulSyncSpeakTimeout;

    //--- Engine / Output
    BOOL                         m_fCreateEngineFromToken;
    CComPtr<ISpTTSEngine>        m_cpCurrEngine;

    //--- Audio
    CSpStreamFormat              m_OutputStreamFormat;
    CComPtr<ISpStreamFormatConverter>   m_cpFormatConverter;
    CComPtr<ISpStreamFormat>     m_cpOutputStream;
    CComPtr<ISpAudio>            m_cpAudioOut;
    BOOL                         m_fAudioStarted:1;
    BOOL                         m_fAutoPropAllowOutFmtChanges:1;   // for automation only

    //--- Voice / Queue 
    CSpeakInfo*                  m_pCurrSI;
    CSpBasicQueue<CSpeakInfo>    m_PendingSpeakList;
    CComAutoCriticalSection      m_StateChangeCritSec;
    CComPtr<ISpThreadControl>    m_cpThreadCtrl;
    SPVOICESTATUS                m_VoiceStatus;
    CSpDynamicString             m_dstrLastBookmark;
    ULONG                        m_ulCurStreamNum;
    SPVPRIORITY                  m_eVoicePriority;
    ULONGLONG                    m_ullAlertInsertionPt;
    SPEVENTENUM                  m_eAlertBoundary;
    ULONG                        m_ulPauseCount;
    CSpAutoEvent                 m_ahPauseEvent;

    //--- Async control
    CComAutoCriticalSection      m_SkipSec;
    CSpAutoMutex                 m_AsyncCtrlMutex;
    CSpAutoEvent                 m_ahSkipDoneEvent;
    BOOL                         m_fUseDefaultVoice;
    BOOL                         m_fUseDefaultRate;
    CComPtr<ISpObjectToken>      m_cpVoiceToken;
    long                         m_lCurrRateAdj;
    USHORT                       m_usCurrVolume;
    long                         m_lSkipCount;
    SPVSKIPTYPE                  m_eSkipType;
    long                         m_lNumSkipped;
    SPVESACTIONS                 m_eActionFlags;
    bool                         m_fRestartSpeak;
    BOOL                         m_fHandlingEvent;

    //--- XML state
    CGlobalStateStack            m_GlobalStateStack;
};


//
//=== Inlines =================================================================
//

/*****************************************************************************
* wctoupper *
*-----------*
*   Converts the specified ANSI character to upper case.
********************************************************************* EDC ***/
inline WCHAR wctoupper( WCHAR wc )
{
    return (WCHAR)(( wc >= L'a' && wc <= 'z' )?( wc + ( L'A' - L'a' )):( wc ));
}

extern ULONG wcatol( WCHAR* pStr, long* pVal );

/*****************************************************************************
* wcisspace *
*-----------*
*   Returns true if the character is a space, tab, carriage return, or line feed.
********************************************************************* EDC ***/
inline BOOL wcisspace( WCHAR wc )
{
    return ( ( wc == 0x20 ) || ( wc == 0x9 ) || ( wc == 0xD  ) ||
             ( wc == 0xA ) || ( wc == SP_ZWSP ) );
}

/*****************************************************************************
* wcskipwhitespace *
*------------------*
*   Returns the position of the next non-whitespace character.
********************************************************************* EDC ***/
inline WCHAR* wcskipwhitespace( WCHAR* pPos )
{
    while( wcisspace( *pPos ) ) ++pPos;
    return pPos;
}

/*****************************************************************************
* wcskipwhitespace *
*------------------*
*   Returns the position of the previous non-whitespace character.
********************************************************************* AH ****/
inline WCHAR* wcskiptrailingwhitespace( WCHAR* pPos )
{
    while( wcisspace( *pPos ) ) --pPos;
    return pPos;
}

/*****************************************************************************
* PopXMLState *
*-------------*
*   Pops the xml state returning an error if its the base state.
********************************************************************* EDC ***/
inline HRESULT CSpVoice::PopXMLState( void )
{
    HRESULT hr = S_OK;
    if( m_GlobalStateStack.GetCount() > 1 )
    {
        m_GlobalStateStack.Pop();
    }
    else
    {
        //--- Unbalanced scopes in XML source
        hr = E_INVALIDARG;
    }
    return hr;
}

inline HRESULT SpGetLanguageFromVoiceToken(ISpObjectToken * pToken, LANGID * plangid)
{
    SPDBG_FUNC("SpGetLanguageFromToken");
    HRESULT hr = S_OK;
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    hr = pToken->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpDataKeyAttribs);

    CSpDynamicString dstrLanguage;
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->GetStringValue(L"Language", &dstrLanguage);
    }

    LANGID langid;
    if (SUCCEEDED(hr))
    {
        if (!swscanf(dstrLanguage, L"%hx", &langid))
        {
            hr = E_UNEXPECTED;
        }
    }

    if (SUCCEEDED(hr))
    {
        *plangid = langid;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
} /* SpGetLanguageFromVoiceToken */

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\sraudio.cpp ===
#include "stdafx.h"
#include "Sapi.h"
#include "sraudio.h"
#ifndef _WIN32_WCE
#include "new.h"
#endif

// Using SP_TRY, SP_EXCEPT exception handling macros
#pragma warning( disable : 4509 )


/****************************************************************************
* CAudioQueue::CAudioQueue *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CAudioQueue::CAudioQueue()
{
    m_ullQueueStartPos  = 0;
    m_cClients          = 0;
    m_cbTotalQueueSize  = 0;
    m_StreamAudioState  = SPAS_CLOSED;
    m_fNewStream        = TRUE;
    m_ullInitialSeekPos = 0;
    m_ullCurSeekPos     = 0;
    m_ullLastTimeUpdatePos = 0;
    m_dwTickCount = 0;
    m_fTimePerByte = 0;
    m_fEndOfStream = false;
    m_hrLastRead = S_OK;
    m_ullAudioEventInterest = 0;
    m_fInputScaleFactor = 1.0F;
    memset(&m_ftLastTime, 0, sizeof(m_ftLastTime));
}

/****************************************************************************
* CAudioQueue::FinalConstruct *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::FinalConstruct(ISpNotifySink * pAudioEventSink)
{
    SPDBG_FUNC("CAudioQueue::FinalConstruct");
    HRESULT hr = S_OK;

    m_cpAudioEventNotify = pAudioEventSink;

    hr = m_autohAlwaysSignaledEvent.InitEvent(NULL, TRUE, TRUE, NULL);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CAudioQueue::ReleaseAll *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CAudioQueue::ReleaseAll()
{
    SPDBG_FUNC("CAudioQueue::ReleaseAll");
    // Releases m_cpInputStream, m_cpInputAudio, and resets and releases m_cpInputEventSource
    ResetNegotiatedStreamFormat();  
    // Now release the original stream information too...
    m_cpInputToken.Release();
    m_cpOriginalInputStream.Release();
    m_cpOriginalInputAudio.Release();
}

/****************************************************************************
* CAudioQueue::PurgeQueue *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CAudioQueue::PurgeQueue()
{
    SPDBG_FUNC("CAudioQueue::PurgeQueue");

    m_ullQueueStartPos = m_ullCurSeekPos - m_ullInitialSeekPos;
    m_cbTotalQueueSize = 0;
    m_Queue.Purge();
}


/****************************************************************************
* CAudioQueue::AddRefBufferClient *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::AddRefBufferClient()
{
    SPDBG_FUNC("CAudioQueue::AddRefBufferClient");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_CritSec);
    m_cClients++;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CAudioQueue::ReleaseBufferClient *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::ReleaseBufferClient()
{
    SPDBG_FUNC("CAudioQueue::ReleaseBufferClient");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_CritSec);
    m_cClients--;
    if (m_cClients == 0)
    {
        PurgeQueue();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::DataAvailable *
*----------------------------*
*   Description:
*       This method MUST be called while the critical section is owned or else
*   the data in the queue could change.
*
*   Returns:
*       True if the requested data is in the queue, else false
*
********************************************************************* RAL ***/


BOOL CAudioQueue::DataAvailable(ULONGLONG ullStreamPos, ULONG cb) const
{
    SPDBG_FUNC("CAudioQueue::DataAvailable");
    return (ullStreamPos >= m_ullQueueStartPos && ullStreamPos + cb <= m_ullQueueStartPos + m_cbTotalQueueSize);
}


/****************************************************************************
* CAudioQueue::GetData *
*----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

BOOL CAudioQueue::GetData(void * pv, ULONGLONG ullStreamPosition, ULONG cb)
{
    SPDBG_FUNC("CAudioQueue::GetData");

    SPAUTO_SEC_LOCK(&m_CritSec);
    BOOL fHaveData = DataAvailable(ullStreamPosition, cb);
    if (fHaveData)
    {
        CAudioBuffer * pNode = m_Queue.GetHead();
#ifdef _DEBUG
        CAudioBuffer * pTest = pNode;
        ULONGLONG count = 0;
        while (pTest)
        {
            count += pTest->m_cb;
            pTest = pTest->m_pNext;
        }
        SPDBG_ASSERT(count == m_cbTotalQueueSize);
#endif
        ULONGLONG ullPos = m_ullQueueStartPos;
        while (ullPos + pNode->m_cb < ullStreamPosition)
        {
            ullPos += pNode->m_cb;
            pNode = pNode->m_pNext;
        }
        ULONG ulOffset = static_cast<ULONG>(ullStreamPosition - ullPos);
        BYTE * pDest = (BYTE *)pv;
        while (cb)
        {
            ULONG cbThisBlock = pNode->m_cb - ulOffset;
            if (cbThisBlock > cb)
            { 
                cbThisBlock = cb;
            }
            memcpy(pDest, pNode->m_Data + ulOffset, cbThisBlock);
            cb -= cbThisBlock;
            pDest += cbThisBlock;
            pNode = pNode->m_pNext; // Warning!  Could become NULL
            ulOffset = 0;           // Set to 0 so next block always starts at first byte
        }
    }
    return fHaveData;
}

/****************************************************************************
* CAudioQueue::DiscardData *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::DiscardData(ULONGLONG ullStreamPosition)
{
    SPDBG_FUNC("CAudioQueue::DiscardData");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_CritSec);
    if (ullStreamPosition > m_ullQueueStartPos + m_cbTotalQueueSize)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ULONGLONG ullCur = m_ullQueueStartPos;
        for (CAudioBuffer * pNode = m_Queue.GetHead(); 
             pNode && m_ullQueueStartPos + pNode->m_cb < ullStreamPosition;
                m_ullQueueStartPos += pNode->m_cb, m_cbTotalQueueSize -= pNode->m_cb,
                pNode = pNode->m_pNext, delete m_Queue.RemoveHead())
         {
         }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::SerializeSize *
*----------------------------*
*   Description:
*
*   Returns:
*       0 if no data is available to be serialized
*       Non-zero if data is available
*
********************************************************************* RAL ***/

ULONG CAudioQueue::SerializeSize(ULONGLONG ullStreamPos, ULONG cbAudioBytes) const
{
    ULONG cb = 0;
    if (DataAvailable(ullStreamPos, cb))
    {
        cb = cbAudioBytes + m_EngineFormat.SerializeSize();
    }
    return cb;
}


/****************************************************************************
* CAudioQueue::Serialize *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CAudioQueue::Serialize(BYTE * pBuffer, ULONGLONG ullStartOffset, ULONG cbAudioBytes) 
{
    SPDBG_FUNC("CAudioQueue::Serialize");
    
    SPDBG_ASSERT(cbAudioBytes + m_EngineFormat.SerializeSize() == SerializeSize(ullStartOffset, cbAudioBytes));

    pBuffer += m_EngineFormat.Serialize(pBuffer);
    GetData(pBuffer, ullStartOffset, cbAudioBytes);
}

/****************************************************************************
* CAudioQueue::UpdateRealTime *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CAudioQueue::UpdateRealTime()
{
    SPDBG_FUNC("CAudioQueue::UpdateRealTime");
    HRESULT hr = S_OK;
    SPAUDIOSTATUS AudioStatus;
    SYSTEMTIME st;
    FILETIME ct;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ct);
    m_dwTickCount = GetTickCount();

    // update real times, if input is a live input
    if (m_cpInputAudio && m_cpInputAudio->GetStatus(&AudioStatus) == S_OK)
    {
        LONGLONG deltatime = FT64(ct) - FT64(m_ftLastTime);
        LONGLONG deltapos = AudioStatus.CurDevicePos - m_ullLastTimeUpdatePos;
        if (deltatime && deltapos)
        {
            if (EngineFormat().WaveFormatExPtr() &&
                EngineFormat().WaveFormatExPtr()->nAvgBytesPerSec != 0)
            {
                // Use audio settings.
                m_fTimePerByte = (float)10000000 / (float)(EngineFormat().WaveFormatExPtr()->nAvgBytesPerSec);
            }
            else
            {
                // Proprietary format. Calculate average as best we can.
                float fTimePerByte = (float)deltatime / (float)deltapos;
                if (m_fTimePerByte)
                {
                    // If we have a previous time per byte, then average it with the newly calculated
                    m_fTimePerByte = (m_fTimePerByte + fTimePerByte) / 2;
                    // NTRAID#SPEECH-0000-2000/08/22-agarside
                    // This is a strange average system. Is this really the desired behaviour. This
                    // is called whenever we have a result and hence will average the bytes from two results
                    // together. Each result should contain enough audio to be used by itself and give a more
                    // accurate conversion for this result. Which I believe is more what is wanted - AJG.
                    // Initially leave unchanged.
                }
                else
                {
                    m_fTimePerByte = fTimePerByte;
                }
            }
            m_ullLastTimeUpdatePos = AudioStatus.CurDevicePos;
        }
    }
    else
    {
        // No input audio - just an input stream. Use engine format if it exists to determine stream times.
        if (EngineFormat().WaveFormatExPtr() &&
            EngineFormat().WaveFormatExPtr()->nAvgBytesPerSec != 0)
        {
            // Use audio settings.
            m_fTimePerByte = (float)10000000 / (float)(EngineFormat().WaveFormatExPtr()->nAvgBytesPerSec);
        }
    }
    m_ftLastTime = ct;
}





/****************************************************************************
* CAudioQueue::SRSiteRead *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::SRSiteRead(void * pv, ULONG cb, ULONG * pcbRead)
{
    SPDBG_FUNC("CAudioQueue::SRSiteRead");
    HRESULT hr = S_OK;

    if (m_cpInputStream && (!m_fEndOfStream))
    {
        hr = m_cpInputStream->Read(pv, cb, pcbRead);
   
        SPAUTO_SEC_LOCK(&m_CritSec);
        if (SUCCEEDED(hr))
        {
            if (*pcbRead)
            {
                m_ullCurSeekPos += *pcbRead;
                if (m_cClients)
                {
                    BYTE * pBuff = new BYTE[sizeof(CAudioBuffer) + *pcbRead];
                    if (pBuff)
                    {
                        CAudioBuffer * pAudioBuff = new(pBuff) CAudioBuffer(*pcbRead);
                        memcpy(pAudioBuff->m_Data, pv, *pcbRead);
                        m_Queue.InsertTail(pAudioBuff);
                        m_cbTotalQueueSize += *pcbRead;
                    }
                    else
                    {
                        SPDBG_ASSERT(FALSE);
                        PurgeQueue();   // If we're out of memory, so get rid of the queue
                        // We don't return an error from read in the hope that the engine
                        // will continue normally now that more memory is free.
                    }
                }
                else
                {
                    m_ullQueueStartPos = m_ullCurSeekPos - m_ullInitialSeekPos;
                }
            }
            if (*pcbRead < cb)
            {
                m_fEndOfStream = TRUE;
            }
        }
        else
        {
            m_fEndOfStream = TRUE;
            m_hrLastRead = hr;
        }
    }
    else
    {
        *pcbRead = 0;
        SPDBG_ASSERT(FALSE);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CAudioQueue::SRSiteDataAvailable *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::SRSiteDataAvailable(ULONG * pcb)
{
    SPDBG_FUNC("CAudioQueue::SRSiteDataAvailable");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pcb))
    {
        hr = E_POINTER;
    }
    else
    {
        if (m_cpInputAudio)
        {
            SPAUDIOSTATUS Status;
            hr = m_cpInputAudio->GetStatus(&Status);
            *pcb = SUCCEEDED(hr) ? Status.cbNonBlockingIO : 0;
        }
        else
        {
            *pcb = INFINITE;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::DataAvailableEvent *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HANDLE CAudioQueue::DataAvailableEvent()
{
    SPDBG_FUNC("CAudioQueue::DataAvailableEvent");

    if (m_cpInputAudio)
    {
        return m_cpInputAudio->EventHandle();
    }
    else
    {
        return m_autohAlwaysSignaledEvent;
    }
}


/****************************************************************************
* CAudioQueue::SetInput *
*-----------------------*
*   Description:
*       The caller must set ONLY ONE of either pToken or pStream, or both can
*   be NULL to indicate that no stream is to be used (release the input stream).
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CAudioQueue::SetInput( ISpObjectToken * pToken, ISpStreamFormat * pStream,
                               BOOL fAllowFormatChanges )
{
    SPAUTO_SEC_LOCK(&m_CritSec);
    SPDBG_FUNC("CAudioQueue::SetInput");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(!(pToken && pStream)); // Only one or the other is allowed

    ReleaseAll();
    if (pToken || pStream)
    {
        m_cpInputToken = pToken;
        m_cpOriginalInputStream = pStream;

        if (SUCCEEDED(hr) && m_cpInputToken)
        {
            // NOTE:  In the token case, we'll attempt to create the stream interface first
            //        and then QI for the audio interface.  This would allow some future code
            //        to create a token for a stream object that is not an audio device.
            hr = SpCreateObjectFromToken(m_cpInputToken, &m_cpOriginalInputStream);
        }

        // NOTE:  We must store the token. We can't rely on the m_cpInStream to be the
        //        original stream in cases where the format convert is used.
        //        So, we'll either use the token passed in, or we'll ask the object
        //        for the token
    
        if (SUCCEEDED(hr) && !m_cpInputToken)
        {
            CComQIPtr<ISpObjectWithToken> cpObjWithToken(m_cpOriginalInputStream);
            if (cpObjWithToken)
            {
                hr = cpObjWithToken->GetObjectToken(&m_cpInputToken);
            }
        }

        //--- Get the audio interface
        if (SUCCEEDED(hr))
        {
            m_cpOriginalInputStream.QueryInterface(&m_cpOriginalInputAudio);
        }

        if (SUCCEEDED(hr))
        {
            this->m_fNewStream    = TRUE;
            m_fAllowFormatChanges = fAllowFormatChanges;
        }
        else
        {
            ReleaseAll();
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::GetEngineFormat *
*------------------------------*
*   Description:
*       Helper function calls the engine to get the desired engine format
*   and updates the m_EngineFormat member.  If pInputFormat is NULL then
*   the engine will be asked for it's default format, otherwise it will be
*   asked for a format to match the input format.
*
*   Returns:
*       HRESULT
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::GetEngineFormat(_ISpRecoMaster * pEngine, const CSpStreamFormat * pInputFormat)
{
    SPDBG_FUNC("CAudioQueue::GetEngineFormat");
    HRESULT hr = S_OK;

    const GUID * pInputFmtId = NULL;
    const WAVEFORMATEX * pInputWFEX = NULL;
    if (pInputFormat)
    {
        pInputFmtId = &pInputFormat->FormatId();
        pInputWFEX = pInputFormat->WaveFormatExPtr();
    }

    GUID OutputFmt = GUID_NULL;
    WAVEFORMATEX * pCoMemWFEXOutput = NULL;

    hr = pEngine->GetInputAudioFormat(pInputFmtId, pInputWFEX,
                                         &OutputFmt, &pCoMemWFEXOutput);

    // Check return parameters
    if(SUCCEEDED(hr))
    {
        if(OutputFmt == GUID_NULL ||
           FAILED(m_EngineFormat.ParamValidateAssignFormat(OutputFmt, pCoMemWFEXOutput)))
        {
            SPDBG_ASSERT(0);
            hr = SPERR_ENGINE_RESPONSE_INVALID;
        }
    }

    if (FAILED(hr))
    {
        m_EngineFormat.Clear();
    }

    ::CoTaskMemFree(pCoMemWFEXOutput);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::SetEventInterest *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::SetEventInterest(ULONGLONG ullEventInterest)
{
    SPAUTO_SEC_LOCK(&m_CritSec);
    SPDBG_FUNC("CAudioQueue::SetEventInterest");
    HRESULT hr = S_OK;

    m_ullAudioEventInterest = ullEventInterest;
    if (m_cpInputEventSource)
    {
        hr = m_cpInputEventSource->SetInterest(m_ullAudioEventInterest, m_ullAudioEventInterest);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::GetAudioEvent *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::GetAudioEvent(CSpEvent * pEvent)
{
    SPAUTO_SEC_LOCK(&m_CritSec);
    SPDBG_FUNC("CAudioQueue::GetAudioEvent");
    HRESULT hr = S_OK;

    if (m_cpInputEventSource)
    {
        hr = pEvent->GetFrom(m_cpInputEventSource);
        if (hr == S_OK)
        {
            pEvent->ullAudioStreamOffset -= this->m_ullInitialSeekPos;
        }
    }
    else
    {
        pEvent->Clear();
        hr = S_FALSE;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CAudioQueue::ResetNegotiatedStreamFormat *
*------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CAudioQueue::ResetNegotiatedStreamFormat()
{
    SPDBG_FUNC("CAudioQueue::ResetNegotiatedStreamFormat");
    SPAUTO_SEC_LOCK(&m_CritSec);
    m_EngineFormat.Clear();
    m_InputFormat.Clear();
    m_cpInputStream.Release();
    m_cpInputAudio.Release();
    if (m_cpInputEventSource)
    {
        m_cpInputEventSource->SetInterest(0, 0);
        m_cpInputEventSource->SetNotifySink(NULL);
        m_cpInputEventSource.Release();
    }
}


/****************************************************************************
* CAudioQueue::NegotiateInputStreamFormat *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::NegotiateInputStreamFormat(_ISpRecoMaster * pEngine)
{
    SPDBG_FUNC("CAudioQueue::NegotiateInputStreamFormat");
    HRESULT hr = S_OK;

    SPAUTO_SEC_LOCK(&m_CritSec);
    if (!m_cpInputStream)       // If the m_cpInputStream is set then we've already negotiated the format
    {
        m_fUsingConverter = false;

        if (!m_cpOriginalInputStream)
        {
            SPDBG_ASSERT(false);
            hr = SPERR_UNINITIALIZED;
        }
    
        if (SUCCEEDED(hr))
        {
            hr = m_InputFormat.AssignFormat(m_cpOriginalInputStream);
        }

        if (SUCCEEDED(hr))
        {
            if (m_cpOriginalInputAudio == NULL || (!m_fAllowFormatChanges))
            {
                hr = GetEngineFormat(pEngine, &m_InputFormat);
            }
            else
            {
                hr = GetEngineFormat(pEngine, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = m_cpOriginalInputAudio->SetFormat(m_EngineFormat.FormatId(), m_EngineFormat.WaveFormatExPtr());
                    if (SUCCEEDED(hr))
                    {
                        hr = m_EngineFormat.CopyTo(m_InputFormat);
                    }
                }
                if (FAILED(hr))
                {
                    hr = m_cpOriginalInputAudio->SetFormat(m_InputFormat.FormatId(), m_InputFormat.WaveFormatExPtr());
                    if (SUCCEEDED(hr))
                    {
                        hr = GetEngineFormat(pEngine, &m_InputFormat);
                    }
                }
            }
        }

        // At this point, m_InputFormat = format of input stream and
        // m_EngineFormat == Format of stream data engine is expecting.

        if (SUCCEEDED(hr))
        {
            if (m_EngineFormat == m_InputFormat)
            {
                m_cpInputStream = m_cpOriginalInputStream;
                m_cpInputAudio = m_cpOriginalInputAudio;
            }
            else
            {
                CComPtr<ISpStreamFormatConverter> cpConvertedStream;
                // we need to instantiate a format converter on the input stream
                hr = cpConvertedStream.CoCreateInstance(CLSID_SpStreamFormatConverter);
                if (SUCCEEDED(hr))
                {
                    hr = cpConvertedStream->SetFormat(m_EngineFormat.FormatId(), m_EngineFormat.WaveFormatExPtr());
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpConvertedStream->SetBaseStream(m_cpOriginalInputStream, FALSE, FALSE);
                }
                if (SUCCEEDED(hr))
                {
                    // Set scale factor to be change from engine format.
                    m_fInputScaleFactor = (float)m_InputFormat.WaveFormatExPtr()->nAvgBytesPerSec /
                                          (float)m_EngineFormat.WaveFormatExPtr()->nAvgBytesPerSec;
                    cpConvertedStream.QueryInterface(&m_cpInputStream);
                    cpConvertedStream.QueryInterface(&m_cpInputAudio);
                    m_fUsingConverter = true;
                }
            }
        }
        if (SUCCEEDED(hr) &&
            m_cpInputAudio && 
            SUCCEEDED(m_cpInputAudio.QueryInterface(&m_cpInputEventSource)))
        {
            hr = m_cpInputEventSource->SetNotifySink(m_cpAudioEventNotify);
            if (SUCCEEDED(hr))
            {
                hr = m_cpInputEventSource->SetInterest(m_ullAudioEventInterest, m_ullAudioEventInterest);
            }
        }

    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CAudioQueue::AdjustAudioVolume *
*--------------------------------*
*   Description:
*       This method should be called when we have either changed reco contexts
*       or are starting a new stream.  It will set the audio volume to the
*       level indicated by the reco context (if there is one).
*
*   Returns:
*       HRESULT -- Failure should not be considered a fatal error by the caller.
*       the volume setting may not exist in the reco profile.
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::AdjustAudioVolume(ISpObjectToken * pRecoProfileToken, REFCLSID rclsidEngine)
{
    SPDBG_FUNC("CAudioQueue::AdjustAudioVolume");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(pRecoProfileToken);
    if (m_cpInputToken && m_cpInputAudio)
    {
        CSpDynamicString dstrAudioTokenId;
        CSpDynamicString dstrSubKey;
        CComPtr<ISpDataKey> cpVolKey;
        hr = m_cpInputToken->GetId(&dstrAudioTokenId);
        if (SUCCEEDED(hr))
        {
            hr = ::StringFromCLSID(rclsidEngine, &dstrSubKey);
        }
        if (SUCCEEDED(hr))
        {
            if (dstrSubKey.Append(L"\\Volume") == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = pRecoProfileToken->OpenKey(dstrSubKey, &cpVolKey);
        }
        if (SUCCEEDED(hr))
        {
            DWORD dwVolLevel;
            hr = cpVolKey->GetDWORD(dstrAudioTokenId, &dwVolLevel);
            if (hr == S_OK)
            {
                hr = m_cpInputAudio->SetVolumeLevel(dwVolLevel);
            }
        }
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }
    
    return hr;
}


/****************************************************************************
* CAudioQueue::StartStream *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::StartStream(_ISpRecoMaster * pEngine,
                        ISpObjectToken * pRecoProfile,
                        REFCLSID rcidEngine,
                        BOOL * pfNewStream)
{
    SPAUTO_SEC_LOCK(&m_CritSec);

    SPDBG_FUNC("CAudioQueue::StartStream");
    HRESULT hr = S_OK;
    ULARGE_INTEGER CurPos;

    hr = NegotiateInputStreamFormat(pEngine);

    if (SUCCEEDED(hr))
    {
        LARGE_INTEGER Org;
        Org.QuadPart = 0;
        hr = m_cpInputStream->Seek(Org, STREAM_SEEK_CUR, &CurPos);
    }

    if (SUCCEEDED(hr))
    {
        m_ullLastTimeUpdatePos = CurPos.QuadPart;
        m_ullInitialSeekPos = CurPos.QuadPart;
        m_ullCurSeekPos = CurPos.QuadPart;
        SYSTEMTIME st;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftLastTime);
        m_dwTickCount = GetTickCount();
        m_fTimePerByte = 0;
    }

    if (m_cpInputAudio)
    {
        AdjustAudioVolume(pRecoProfile, rcidEngine);
        hr = m_cpInputAudio->SetState(SPAS_RUN, 0);
    }

    if (SUCCEEDED(hr))
    {
        this->m_StreamAudioState = SPAS_RUN;
        m_ullQueueStartPos = 0;
        *pfNewStream = this->m_fNewStream;
        this->m_fNewStream = FALSE;
        m_fEndOfStream = false;
        m_hrLastRead = S_OK;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::EndStream *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::EndStream(HRESULT * pFinalReadHResult, BOOL *pfReleasedStream)
{
    SPDBG_FUNC("CAudioQueue::EndStream");
    HRESULT hr = S_OK;

    *pFinalReadHResult = m_hrLastRead;

    hr = StopStream();
    PurgeQueue();

    //  Now check for an end of stream condition.  Release the stream if either:
    //      1. The stream is not an audio device
    //      2. It is an audio device, but returns an error code, that isn't one of the ones
    //			we recognize as being non-terminal and sensible to restart streams with.
    //  In SAPI 5.0/5.1 the behavior was different and caused any audio device stream to be released
    //  if it ran out of data. We now allow this as long as the device returns a success code from its Read calls.
    //	In this case logic in srrecomaster.cpp::StartStream sets the reco state to inactive,
    //	to allow an application to restart with the same stream.
    if ((m_fEndOfStream && m_cpInputAudio == NULL) ||
        (FAILED(m_hrLastRead) && 
         !IsStreamRestartHresult(m_hrLastRead)))
    {
        *pfReleasedStream = TRUE;
        ReleaseAll();
    }
    else
    {
        *pfReleasedStream = FALSE;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::StopStream *
*-------------------------*
*   Description:
*       This function is called to force the current audio stream to stop.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::StopStream()
{
    SPDBG_FUNC("CAudioQueue::StopStream");
    HRESULT hr = S_OK;

    m_StreamAudioState = SPAS_STOP;
    if (m_cpInputAudio)
    {
        hr = m_cpInputAudio->SetState(SPAS_STOP, 0);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::SetBufferNotifySize *
*----------------------------------*
*   Description:
*
*   Returns:
*       S_OK - Function succeeded
*       SP_UNSUPPORTED_ON_STREAM_FORMAT - Success, but function has no effect
*           since input is not a live audio source.
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::SetBufferNotifySize(ULONG cb)
{
    SPAUTO_SEC_LOCK(&m_CritSec);

    SPDBG_FUNC("CAudioQueue::SetBufferNotifySize");
    HRESULT hr = S_OK;

    if (m_cpInputAudio)
    {
        hr = m_cpInputAudio->SetBufferNotifySize(cb);
    }
    else
    {
        hr = SP_UNSUPPORTED_ON_STREAM_INPUT;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CAudioQueue::CloseStream *
*-------------------------*
*   Description:
*       This function is called to force the current audio stream to close.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::CloseStream()
{
    SPDBG_FUNC("CAudioQueue::CloseStream");
    HRESULT hr = S_OK;

    m_StreamAudioState = SPAS_CLOSED;
    if (m_cpInputAudio)
    {
        hr = m_cpInputAudio->SetState(SPAS_CLOSED, 0);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::PauseStream *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::PauseStream()
{
    SPDBG_FUNC("CAudioQueue::PauseStream");
    HRESULT hr = S_OK;

    m_StreamAudioState = SPAS_PAUSE;
    if (m_cpInputAudio)
    {
        hr = m_cpInputAudio->SetState(SPAS_PAUSE, 0);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CAudioQueue::GetAudioStatus *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CAudioQueue::GetAudioStatus(SPAUDIOSTATUS * pStatus)
{
    SPDBG_FUNC("CAudioQueue::GetAudioStatus");
    HRESULT hr = S_OK;

    if (m_cpInputAudio)
    {
        hr = m_cpInputAudio->GetStatus(pStatus);
    }
    else
    {
        memset(pStatus, 0, sizeof(*pStatus)); 
        pStatus->State = this->m_StreamAudioState;
        pStatus->CurSeekPos = this->m_ullCurSeekPos;
        pStatus->CurDevicePos = this->m_ullCurSeekPos;
    }

    pStatus->CurSeekPos -= this->m_ullInitialSeekPos;
    pStatus->CurDevicePos -= this->m_ullInitialSeekPos;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CAudioQueue::DelayStreamPos *
*-----------------------------*
*   Description:
*
*   Returns:
*       0 if task should not be delayed, else stream offset
*
********************************************************************* RAL ***/

ULONGLONG CAudioQueue::DelayStreamPos()
{
    SPDBG_FUNC("CAudioQueue::DelayStreamPos");

    ULONGLONG ullPos = 0;
    if (m_StreamAudioState == SPAS_RUN)
    {
        if (m_cpInputAudio)
        {
            SPAUDIOSTATUS AudioStatus;
            m_cpInputAudio->GetStatus(&AudioStatus);
            ullPos = AudioStatus.CurDevicePos - this->m_ullInitialSeekPos;
        }
        else
        {
            ullPos = this->m_ullCurSeekPos - this->m_ullInitialSeekPos;
        }
    }

    return ullPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\spvoicexml.h ===
/*******************************************************************************
* SpVoiceXML.h *
*--------------*
*   Description:
*       This is the header file for the CSpVoice XML definitions.
*-------------------------------------------------------------------------------
*  Created By: EDC                            Date: 06/17/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#ifndef SpVoiceXML_h
#define SpVoiceXML_h

//--- Additional includes
#ifndef __sapi_h__
#include <sapi.h>
#endif

//=== Constants ====================================================
#define MAX_ATTRS   10
#define KEY_ATTRIBUTES  L"Attributes"

//=== Class, Enum, Struct and Union Declarations ===================
class CSpVoice;

//=== Enumerated Set Definitions ===================================
typedef enum XMLTAGID
{
    TAG_ILLEGAL = -3,
    TAG_TEXT    = -2,
    TAG_UNKNOWN = -1,
    TAG_VOLUME  =  0,
    TAG_EMPH,
    TAG_SILENCE,
    TAG_PITCH,
    TAG_RATE,
    TAG_BOOKMARK,
    TAG_PRON,
    TAG_SPELL,
    TAG_LANG,
    TAG_VOICE,
    TAG_CONTEXT,
    TAG_PARTOFSP,
    TAG_SECT,
    TAG_XMLDOC,         // Put low frequency tags at end
    TAG_XMLCOMMENT,
    TAG_XMLDOCTYPE,
    TAG_SAPI,
    NUM_XMLTAGS
} XMLTAGID;

typedef enum XMLATTRID
{
    ATTR_ID,
    ATTR_SYM,
    ATTR_LANGID,
    ATTR_LEVEL,
    ATTR_MARK,
    ATTR_MIDDLE,
    ATTR_MSEC,
    ATTR_OPTIONAL,
    ATTR_RANGE,
    ATTR_REQUIRED,
    ATTR_SPEED,
    ATTR_BEFORE,
    ATTR_AFTER,
    ATTR_PART,
    ATTR_ABSMIDDLE,
    ATTR_ABSRANGE,
    ATTR_ABSSPEED,
    NUM_XMLATTRS
} XMLATTRID;

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CVoiceNode
*   This is a simple class used to track the voices used during the current parse
*/
class CVoiceNode
{
  public:
    CVoiceNode() { m_pAttrs = NULL; m_pNext = NULL; }
    ~CVoiceNode() { delete m_pNext; delete m_pAttrs; }
    CVoiceNode*             m_pNext;
    CComPtr<ISpTTSEngine>   m_cpVoice;
    CSpDynamicString        m_dstrVoiceTokenId;
    WCHAR*                  m_pAttrs;
};

class CPhoneConvNode
{
  public:
      CPhoneConvNode() { m_pNext = NULL; }
      ~CPhoneConvNode() { delete m_pNext; }
      CPhoneConvNode*               m_pNext;
      CComPtr<ISpPhoneConverter>    m_cpPhoneConverter;
      LANGID                        m_LangID;
};

//
//  String handling and conversion classes
//
/*** SPLSTR
*   This structure is for managing strings with known lengths
*/
struct SPLSTR
{
    WCHAR*  pStr;
    int     Len;
};
#define DEF_SPLSTR( s ) { L##s , sp_countof( s ) - 1 }

/***
*   These structures are used to manage XML document state
*/
struct XMLATTRIB
{
    XMLATTRID eAttr;
    SPLSTR     Value;
};

struct XMLTAG
{
    XMLTAGID  eTag;
    XMLATTRIB Attrs[MAX_ATTRS];
    int       NumAttrs;
    bool      fIsStartTag;
    bool      fIsGlobal;
};

struct GLOBALSTATE : public SPVSTATE
{
    BOOL                        fDoSpellOut;
    CVoiceNode*                 pVoiceEntry;
    CComPtr<ISpTTSEngine>       cpVoice;
    CComPtr<ISpPhoneConverter>  cpPhoneConverter;
};

/*** CSpeechSeg
*   This class is used to describe a list of parsed XML fragments
*   ready for the associated voice to speak. The speak info structure
*   will have several of these in a multi voice situation.
*/
class CSpeechSeg
{
  public:
    CSpeechSeg()
        { m_pNextSeg = NULL; m_pFragHead = m_pFragTail = NULL; m_fRate = false; }

    ~CSpeechSeg()
    {
        SPVTEXTFRAG *pNext;
        while( m_pFragHead )
        {
            pNext = m_pFragHead->pNext;
            delete m_pFragHead;
            m_pFragHead = pNext;
        }
        m_pFragHead = NULL;
    }
    BOOL IsEmpty( void ) { return ( m_pFragHead == NULL ); }
    SPVTEXTFRAG *GetFragList( void ) { return m_pFragHead; }
    SPVTEXTFRAG *GetFragListTail( void ) { return m_pFragTail; }
    ISpTTSEngine *GetVoice( void ) { return m_cpVoice; }
    HRESULT Init( ISpTTSEngine * pCurrVoice, const CSpStreamFormat & OutFormat );
    const CSpStreamFormat & VoiceFormat( void ) { return m_VoiceFormat; }
    HRESULT SetVoiceFormat( const CSpStreamFormat & Fmt );
    CSpeechSeg* GetNextSeg( void ) { return m_pNextSeg; }
    void SetNextSeg( CSpeechSeg* pNext ) { m_pNextSeg = pNext; }
    SPVTEXTFRAG* AddFrag( CSpVoice* pVoice, WCHAR* pStart, WCHAR* pPos, WCHAR* pNext );
    void SetRateFlag() { m_fRate = true; }
    BOOL fRateFlagIsSet() { return m_fRate; }

  //--- Member data ---*/
  private:
    CComPtr<ISpTTSEngine> m_cpVoice;
    CSpStreamFormat       m_VoiceFormat;
    SPVTEXTFRAG*          m_pFragHead;
    SPVTEXTFRAG*          m_pFragTail;
    CSpeechSeg*           m_pNextSeg;
    BOOL                  m_fRate;
};

/*** CGlobalStateStack *************************************************
*   These classes are used to maintain voice control values
*   during XML scope changes.
*/
class CGlobalStateStack
{
  public:
    /*--- Methods ---*/
    CGlobalStateStack() { m_StackPtr = -1; }
    int GetCount( void ) { return m_StackPtr + 1; }
    virtual const GLOBALSTATE& GetBaseVal( void ) { SPDBG_ASSERT( m_StackPtr > -1 ); return GetValAt( 0 ); }
    virtual const GLOBALSTATE& GetValAt( int Index ) { return m_Stack[Index]; }
    virtual const GLOBALSTATE& GetVal( void ) { return m_Stack[m_StackPtr]; }
    virtual GLOBALSTATE& GetValRef( void ) { return m_Stack[m_StackPtr]; }
    virtual int Pop( void ) 
    { 
        SPDBG_ASSERT( m_StackPtr > -1 ); 
        if( m_StackPtr >= 0 )
        {
            m_Stack[m_StackPtr].cpVoice = NULL;
            m_Stack[m_StackPtr].cpPhoneConverter = NULL;
            --m_StackPtr;
        }
        return GetCount();
    }
    virtual HRESULT DupAndPushVal( void ) { return SetVal( GetVal(), true ); }
    virtual HRESULT SetVal( const GLOBALSTATE& val, BOOL fDoPush )
    {
        if( fDoPush ) ++m_StackPtr;
        return m_Stack.SetAtGrow( m_StackPtr, val );
    }
    virtual void SetBaseVal( const GLOBALSTATE& val ) { m_Stack.SetAtGrow( 0, val ); if( m_StackPtr < 0 ) m_StackPtr = 0; }
    virtual void Reset( void ) 
    { 
        while ( m_StackPtr > 0 )
        {
            m_Stack[m_StackPtr].cpVoice = NULL;
            m_Stack[m_StackPtr].cpPhoneConverter = NULL;
            m_StackPtr--;
        }
    }
    virtual void Release( void )
    {
        while ( m_StackPtr >= 0 )
        {
            m_Stack[m_StackPtr].cpVoice = NULL;
            m_Stack[m_StackPtr].cpPhoneConverter = NULL;
            m_StackPtr--;
        }
    }

  protected:
    /*--- Member data ---*/
    CSPArray<GLOBALSTATE,GLOBALSTATE>  m_Stack;
    int                                m_StackPtr;
};

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srevent.cpp ===
/******************************************************************************
* SREvent.cpp *
*-------------*
*  This is the implementation of CSREvent.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#include "stdafx.h"
#include "SREvent.h"


/****************************************************************************
* CSREvent::CSREvent *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CSREvent::CSREvent()
{
    SPDBG_FUNC("CSREvent::CSREvent");

    m_pEvent = NULL;
    m_hContext = NULL;
    m_pResultHeader = NULL;
    m_RecoFlags = 0;
}

/****************************************************************************
* CSREvent::~CSREvent *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CSREvent::~CSREvent()
{
    SPDBG_FUNC("CSREvent::~CSREvent");
    if (m_pEvent)
    {
        ::CoTaskMemFree(m_pEvent);
    }
    if (m_pResultHeader)
    {
        ::CoTaskMemFree(m_pResultHeader);
    }
}
/****************************************************************************
* CSREvent::Init *
*----------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSREvent::Init(const SPEVENT * pSrcEvent, SPRECOCONTEXTHANDLE hContext)
{
    SPDBG_FUNC("CSREvent::Init");
    HRESULT hr = S_OK;

    hr = static_cast<const CSpEvent *>(pSrcEvent)->Serialize(&m_pEvent, &m_cbEvent);
    if (SUCCEEDED(hr))
    {
        m_hContext = hContext;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CSREvent::Init *
*----------------*
*   Description:
*
*   Returns:
*       Nothing.  This method can not fail.  The result header is constructed by
*       the caller and this object assumes ownership of it.
*
********************************************************************* RAL ***/

void CSREvent::Init(SPRESULTHEADER * pCoMemResultHeader, SPEVENTENUM eRecognitionId, WPARAM RecoFlags,
                    SPRECOCONTEXTHANDLE hContext)
{
    SPDBG_FUNC("CSREvent::Init");

    m_pResultHeader = pCoMemResultHeader;
    m_eRecognitionId = eRecognitionId;
    m_RecoFlags = RecoFlags;
    m_hContext = hContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srgrammar.cpp ===
/*******************************************************************************
* SrGrammr.cpp *
*--------------*
*   Description:
*       This file is the implementation of the SpRecoGrammar object.
*-------------------------------------------------------------------------------
*  Created By: RAL                              Date: 01/17/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#include "stdafx.h"
#include "RecoCtxt.h"
#include "SrGrammar.h"
#include "Recognizer.h"
#include "SrTask.h"
#include "a_srgrammar.h"
#include "a_helpers.h"



/****************************************************************************
* CRecoGrammar::CRecoGrammar *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRecoGrammar::CRecoGrammar() 
{
    m_pParent = NULL;
    m_fCmdLoaded = FALSE;
    m_fProprietaryCmd = FALSE;
    m_DictationState = SPRS_INACTIVE;
    m_hRecoInstGrammar = NULL;  
    m_GrammarState = SPGS_ENABLED;
    m_pCRulesWeak = NULL;
}


/****************************************************************************
* CRecoGrammar::~CRecoGrammar *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRecoGrammar::~CRecoGrammar()
{
    SPDBG_ASSERT( m_pCRulesWeak == NULL );

    if (m_pParent)
    {
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));
        Task.eTask = EGT_DELETEGRAMMAR;
        CallEngine(&Task);
        m_pParent->GetControllingUnknown()->Release();
    }
}

/****************************************************************************
* CRecoGrammar::FinalConstruct *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoGrammar::FinalConstruct()
{
    SPDBG_FUNC("CRecoGrammar::FinalConstruct");

    return m_autohPendingEvent.InitEvent(NULL, FALSE, FALSE, NULL);
}


/****************************************************************************
* CRecoGrammar::Init *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/


HRESULT CRecoGrammar::Init(CRecoCtxt * pParent, ULONGLONG ullGrammarId)
{
    SPDBG_FUNC("CRecoGrammar::Init");
    HRESULT hr = S_OK;

    m_pParent = pParent;
    m_ullGrammarId = ullGrammarId;

    hr = CRCT_CREATEGRAMMAR::CreateGrammar(pParent, ullGrammarId, &this->m_hRecoInstGrammar);

    if (SUCCEEDED(hr))
    {
        pParent->GetControllingUnknown()->AddRef();
    }
    else
    {
        m_pParent = NULL;       // Forces destructor to not attempt to ET_DELETEGRAMMAR.
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::CallEngine *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoGrammar::CallEngine(ENGINETASK * pTask)
{
    SPDBG_FUNC("CRecoGrammar::CallEngine");
    HRESULT hr = S_OK;

    pTask->hRecoInstContext = m_pParent->m_hRecoInstContext;
    pTask->hRecoInstGrammar = m_hRecoInstGrammar;
    pTask->Response.__pCallersTask = pTask;

    hr = m_pParent->m_cpRecognizer->PerformTask(pTask);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::ClearRule *
*----------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** ToddT ***/
STDMETHODIMP CRecoGrammar::ClearRule(SPSTATEHANDLE hState) 
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = (m_cpCompiler) ? m_cpCompiler->ClearRule(hState) : SPERR_NOT_DYNAMIC_GRAMMAR;

    // Make sure we mark our automation rule object as invalid.
    if ( SUCCEEDED( hr ) && m_pCRulesWeak )
    {
        m_pCRulesWeak->InvalidateRuleStates(hState);
    }

    return hr;
}

/****************************************************************************
* CRecoGrammar::ResetGrammar *
*----------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

struct EMPTYHEADER : public SPCFGSERIALIZEDHEADER
{
    WCHAR   aEmptyChars[2];
    SPCFGARC    BogusArc[1];
};

STDMETHODIMP CRecoGrammar::ResetGrammar(LANGID NewLanguage) 
{ 
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::ResetGrammar");
    HRESULT hr = S_OK;
    if (NewLanguage)
    {
        EMPTYHEADER h;   
        memset(&h, 0, sizeof(h));
        h.FormatId = SPGDF_ContextFree;
        hr = ::CoCreateGuid(&h.GrammarGUID);
        h.LangID = NewLanguage;
        h.cchWords = 1;
        h.cWords = 1;
        h.pszWords = offsetof(EMPTYHEADER, aEmptyChars);
        h.cchSymbols = 1;
        h.pszSymbols = offsetof(EMPTYHEADER, aEmptyChars);
        h.pArcs = offsetof(EMPTYHEADER, BogusArc);
        h.cArcs = 1;
        h.ulTotalSerializedSize = sizeof(h);
    
        hr = LoadCmdFromMemory(&h, SPLO_DYNAMIC);
    }
    else
    {
        hr = UnloadCmd();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::GetRule *
*-----------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

STDMETHODIMP CRecoGrammar::GetRule(const WCHAR * pszName, DWORD dwRuleId, DWORD dwAttributes, 
                                   BOOL fCreateIfNotExist, SPSTATEHANDLE * phInitialState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::GetRule");
    HRESULT hr = S_OK;

    if (!m_cpCompiler)
    {
        if (m_fCmdLoaded)
        {
            hr = SPERR_NOT_DYNAMIC_GRAMMAR;
        }
        else
        {
            CComQIPtr<ISpRecognizer> cpRecognizer(m_pParent->m_cpRecognizer);
            SPRECOGNIZERSTATUS Status;
            hr = cpRecognizer->GetStatus(&Status);
            if (SUCCEEDED(hr))
            {
                hr = ResetGrammar(Status.aLangID[0]);
            }
            SPDBG_ASSERT( SUCCEEDED(hr) && m_cpCompiler);
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpCompiler->GetRule(pszName, dwRuleId, dwAttributes, fCreateIfNotExist, phInitialState);
    }

    SPDBG_REPORT_ON_FAIL ( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::Commit *
*----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::Commit(DWORD dwReserved)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::Commit");
    HRESULT hr = S_OK;

    if (!m_cpCompiler)
    {
        if (m_fCmdLoaded)
        {
            hr = SPERR_NOT_DYNAMIC_GRAMMAR;
        }
        // return S_OK if they call commit on an empty grammar
    }
    else
    {
        HGLOBAL hg;
        CComPtr<IStream> cpStream;
        if (dwReserved)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = ::CreateStreamOnHGlobal(NULL, TRUE, &cpStream);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_cpCompiler->SetSaveObjects(cpStream, NULL);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_cpCompiler->Commit(SPGF_RESET_DIRTY_FLAG);
            m_cpCompiler->SetSaveObjects(NULL, NULL);
        }
        if (SUCCEEDED(hr))
        {
            hr = ::GetHGlobalFromStream(cpStream, &hg);
        }
        if (SUCCEEDED(hr))
        {
            BYTE * pStreamData = (BYTE *)GlobalLock(hg);
            if (pStreamData)
            {
                ENGINETASK Task;
                memset(&Task, 0, sizeof(Task));

                Task.eTask = EGT_RELOADCMD;
                Task.pvAdditionalBuffer = pStreamData;
                Task.cbAdditionalBuffer = ((SPCFGSERIALIZEDHEADER *)pStreamData)->ulTotalSerializedSize;

                hr = CallEngine(&Task);
                GlobalUnlock(hg);
            }
            else
            {
                hr = SpHrFromLastWin32Error();
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}




/****************************************************************************
* CRecoGrammar::GetGrammarId *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::GetGrammarId(ULONGLONG * pullGrammarId)
{
    SPDBG_FUNC("CRecoGrammar::GetGrammarId");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pullGrammarId))
    {
        hr = E_POINTER;
    }
    else
    {
        *pullGrammarId = m_ullGrammarId;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::GetRecoContext *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::GetRecoContext(ISpRecoContext ** ppContext)
{
    SPDBG_FUNC("CRecoGrammar::GetRecoContext");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppContext))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pParent->GetControllingUnknown()->QueryInterface(ppContext);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::InitCompilerBackend *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CRecoGrammar::InitCompilerBackend()
{
    SPDBG_FUNC("CRecoGrammar::InitCompilerBackend");
    HRESULT hr = S_OK;

    hr = m_cpCompiler.CoCreateInstance(CLSID_SpGramCompBackend);
    if (SUCCEEDED(hr))
    {
        hr = m_cpCompiler->InitFromBinaryGrammar(Header());
    }
    if (FAILED(hr))
    {
        m_cpCompiler.Release();
        CBaseGrammar::Clear();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::LoadCmdFromFile *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::LoadCmdFromFile(const WCHAR * pszFileName, SPLOADOPTIONS Options)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("LoadCmdFromFile");
    HRESULT hr = S_OK;

    if (SPIsBadStringPtr(pszFileName, MAX_PATH) ||
        (Options != SPLO_STATIC && Options != SPLO_DYNAMIC))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // Fully qualify filename here. Required so grammar name is always fully qualified.
        WCHAR pszFullName[MAX_PATH];
        WCHAR *pszFile;
        if (!wcsstr(pszFileName, L"://") ||
            wcsstr(pszFileName, L"/") != (wcsstr(pszFileName, L"://")+1) )
        {
            // If it not a filename of the form 'prot://'
            DWORD dwLen = g_Unicode.GetFullPathName(const_cast<WCHAR *>(pszFileName), MAX_PATH, pszFullName, &pszFile);
            if(dwLen == 0)
            {
                hr = SpHrFromLastWin32Error();
                UnloadCmd();
                return hr;
            }
            else if(dwLen > MAX_PATH)
            {
                UnloadCmd();
                return E_INVALIDARG;
            }
        }
        else
        {
            // If it is, simply copy.
            wcscpy(pszFullName, pszFileName);
        }

        //
        //  If the extension of the file is ".xml" then attempt to compile it
        //
        ULONG cch = wcslen(pszFullName);
        if (cch > 4 && _wcsicmp(pszFullName + cch - 4, L".xml") == 0)
        {
            // NTRAID#SPEECH-7255-2000/08/22-agarside - protocol:// will always fail here.
            CComPtr<ISpStream> cpSrcStream;
            CComPtr<IStream> cpDestMemStream;
            CComPtr<ISpGrammarCompiler> m_cpCompiler;
            
            hr = SPBindToFile(pszFullName, SPFM_OPEN_READONLY, &cpSrcStream);
            if (SUCCEEDED(hr))
            {
                hr = ::CreateStreamOnHGlobal(NULL, TRUE, &cpDestMemStream);
            }
            if (SUCCEEDED(hr))
            {
                hr = m_cpCompiler.CoCreateInstance(CLSID_SpGrammarCompiler);
            }
            if (SUCCEEDED(hr))
            {
                hr = m_cpCompiler->CompileStream(cpSrcStream, cpDestMemStream, NULL, NULL, NULL, 0);
            }
            if (SUCCEEDED(hr))
            {
                HGLOBAL hGlobal;
                hr = ::GetHGlobalFromStream(cpDestMemStream, &hGlobal);
                if (SUCCEEDED(hr))
                {
#ifndef _WIN32_WCE
                    SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )::GlobalLock(hGlobal);
#else
                    SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )GlobalLock(hGlobal);
#endif // _WIN32_WCE
                    if (pBinaryData)
                    {
                        // Adapt filename to fully qualify protocol.
                        CSpDynamicString dstrName;
                        if ( !wcsstr(pszFullName, L"://") ||
                             wcsstr(pszFullName, L"/") != (wcsstr(pszFullName, L"://")+1) )
                        {
                            dstrName.Append2(L"file://", pszFullName);
                        }
                        else
                        {
                            dstrName = pszFullName;
                        }

                        hr = InternalLoadCmdFromMemory(pBinaryData, Options, dstrName);
#ifndef _WIN32_WCE
                        ::GlobalUnlock(hGlobal);
#else
                        GlobalUnlock(hGlobal);
#endif // _WIN32_WCE
                    }
                }
            }
        }
        else
        {
            UnloadCmd();
            if (Options == SPLO_DYNAMIC)
            {
                // NTRAID#SPEECH-7255-2000/08/22-agarside - file:// or http:// will break this!
                hr = InitFromFile(pszFullName);
                if (SUCCEEDED(hr))
                {
                    hr = InitCompilerBackend();
                }
            }
            if (SUCCEEDED(hr))
            {
                ENGINETASK Task;
                memset(&Task, 0, sizeof(Task));
                Task.eTask = EGT_LOADCMDFROMFILE;
                ::wcscpy(Task.szFileName, pszFullName);
                hr = CallEngine(&Task);
            }
            if (SUCCEEDED(hr))
            {
                m_fCmdLoaded = TRUE;
            }
            else
            {
                UnloadCmd();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = SetGrammarState(m_GrammarState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::LoadCmdFromObject *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::LoadCmdFromObject(REFCLSID rcid, const WCHAR * pszGrammarName, SPLOADOPTIONS Options)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::LoadCmdFromObject");
    HRESULT hr = S_OK;

    if (pszGrammarName && SPIsBadStringPtr(pszGrammarName, MAX_PATH) ||
        (Options != SPLO_STATIC && Options != SPLO_DYNAMIC))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        UnloadCmd();
        if (Options == SPLO_DYNAMIC)
        {
            hr = InitFromCLSID(rcid, pszGrammarName);
            if (SUCCEEDED(hr))
            {
                hr = InitCompilerBackend();
            }
        }
        if (SUCCEEDED(hr))
        {
            ENGINETASK Task;
            memset(&Task, 0, sizeof(Task));

            Task.eTask = EGT_LOADCMDFROMOBJECT;
            Task.clsid = rcid;
            ::wcscpy(Task.szGrammarName, pszGrammarName);
            hr = CallEngine(&Task);
        }
        if (SUCCEEDED(hr))
        {
            m_fCmdLoaded = TRUE;
        }
        else
        {
            UnloadCmd();
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = SetGrammarState(m_GrammarState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CRecoGrammar::LoadCmdFromResource *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::LoadCmdFromResource(HMODULE hModule,
                                               const WCHAR * pszResourceName,
                                               const WCHAR * pszResourceType,
                                               WORD wLanguage,
                                               SPLOADOPTIONS Options)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::LoadCmdFromResource");
    HRESULT hr = S_OK;

    if ((HIWORD(pszResourceName) && SPIsBadStringPtr(pszResourceName, MAX_PATH)) ||
        (HIWORD(pszResourceType) && SPIsBadStringPtr(pszResourceType, MAX_PATH)) ||
        (Options != SPLO_STATIC && Options != SPLO_DYNAMIC))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        WCHAR szFileName[MAX_PATH];

        if (g_Unicode.GetModuleFileName(hModule, szFileName, MAX_PATH))
        {
            UnloadCmd();
            if (Options == SPLO_DYNAMIC)
            {
                hr = InitFromResource(szFileName, pszResourceName, pszResourceType, wLanguage);
                if (SUCCEEDED(hr))
                {
                    hr = InitCompilerBackend();
                }
            }
            if (SUCCEEDED(hr))
            {
                ENGINETASK Task;
                memset(&Task, 0, sizeof(Task));

                Task.eTask = EGT_LOADCMDFROMRSRC;
                Task.wLanguage = wLanguage;
                ::wcscpy(Task.szModuleName, szFileName);
                if (HIWORD(pszResourceName))
                {
                    ::wcscpy(Task.szResourceName, pszResourceName);
                    Task.fResourceNameValid = 1;
                }
                else
                {
                    Task.fResourceNameValid = 0;
                    Task.dwNameInt = LOWORD(pszResourceName);
                }
                if (HIWORD(pszResourceType))
                {
                    Task.fResourceTypeValid = 1;
                    ::wcscpy(Task.szResourceType, pszResourceType);
                }
                else
                {
                    Task.fResourceTypeValid = 0;
                    Task.dwTypeInt = LOWORD(pszResourceType);
                }
                hr = CallEngine(&Task);
            }
            if (SUCCEEDED(hr))
            {
                m_fCmdLoaded = TRUE;
            }
            else
            {
                UnloadCmd();
            }
        }
        else
        {
            // failed to get file name for hModule
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = SetGrammarState(m_GrammarState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::LoadCmdFromMemory *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
STDMETHODIMP CRecoGrammar::LoadCmdFromMemory(const SPBINARYGRAMMAR * pBinaryData, SPLOADOPTIONS Options)
{
    WCHAR szAppPath[MAX_PATH];
    g_Unicode.GetModuleFileName(NULL, szAppPath, MAX_PATH);
    return InternalLoadCmdFromMemory(pBinaryData, Options,szAppPath);
}

/****************************************************************************
* CRecoGrammar::LoadCmdFromMemory *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CRecoGrammar::InternalLoadCmdFromMemory(const SPBINARYGRAMMAR * pBinaryData, SPLOADOPTIONS Options, const WCHAR *pszFileName)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::LoadCmdFromMemory");
    HRESULT hr = S_OK;

    const SPCFGSERIALIZEDHEADER * pSerializedHeader = (const SPCFGSERIALIZEDHEADER *) pBinaryData;

    if (SPIsBadReadPtr(pBinaryData, sizeof(SPBINARYGRAMMAR)) ||
        SPIsBadReadPtr(pBinaryData, pBinaryData->ulTotalSerializedSize) ||
        pSerializedHeader->FormatId != SPGDF_ContextFree ||
        (Options != SPLO_STATIC && Options != SPLO_DYNAMIC) ||
        (pszFileName && SP_IS_BAD_STRING_PTR(pszFileName)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        UnloadCmd();
        if (Options == SPLO_DYNAMIC)
        {
            hr = InitFromMemory((SPCFGSERIALIZEDHEADER*)(pBinaryData), pszFileName);
            if (SUCCEEDED(hr))
            {
                hr = InitCompilerBackend();
            }
        }
        if (SUCCEEDED(hr))
        {
            ENGINETASK Task;
            memset(&Task, 0, sizeof(Task));
            Task.eTask = EGT_LOADCMDFROMMEMORY;
            Task.pvAdditionalBuffer = (void *)pBinaryData;
            Task.cbAdditionalBuffer = pBinaryData->ulTotalSerializedSize;
            if (pszFileName)
            {
                wcscpy(Task.szFileName, pszFileName);
            }
            hr = CallEngine(&Task);
        }
        if (SUCCEEDED(hr))
        {
            m_fCmdLoaded = TRUE;
        }
        else
        {
            UnloadCmd();
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = SetGrammarState(m_GrammarState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::LoadCmdFromPropritaryGrammar *
*--------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::LoadCmdFromProprietaryGrammar(REFGUID rguidParam,
                                                         const WCHAR * pszStringParam,
                                                         const void * pvDataParam,
                                                         ULONG cbDataSize,
                                                         SPLOADOPTIONS Options)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::LoadCmdFromPropritaryGrammar");
    HRESULT hr = S_OK;

    if (pszStringParam && SPIsBadStringPtr(pszStringParam, MAX_PATH) ||
        (pvDataParam && SPIsBadReadPtr(pvDataParam, cbDataSize)) ||
        Options != SPLO_STATIC)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        UnloadCmd();
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));

        Task.eTask = EGT_LOADCMDPROPRIETARY;
        Task.guid = rguidParam;
        Task.pvAdditionalBuffer = (void *)pvDataParam;
        Task.cbAdditionalBuffer = cbDataSize;
        if (pszStringParam)
        {
            ::wcscpy(Task.szStringParam, pszStringParam);
        }
        else
        {
            Task.szStringParam[0] = 0;
        }
        
        hr = CallEngine(&Task);
        if (SUCCEEDED(hr))
        {
            m_fProprietaryCmd = TRUE;
            m_fCmdLoaded = TRUE;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = SetGrammarState(m_GrammarState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRecoGrammar::SaveCmd *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::SaveCmd(IStream * pSaveStream, WCHAR ** ppCoMemErrorText)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::SaveCmd");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pSaveStream))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SP_IS_BAD_OPTIONAL_WRITE_PTR(ppCoMemErrorText))
        {
            hr = E_POINTER;
        }
        else
        {
            if (ppCoMemErrorText)
            {
                *ppCoMemErrorText = NULL;
            }
            if (!m_cpCompiler)
            {
                if (m_fCmdLoaded)
                {
                    hr = SPERR_NOT_DYNAMIC_GRAMMAR;
                }
                else
                {
                    hr = SPERR_UNINITIALIZED;
                }
            }
            else
            {
                CSpBasicErrorLog ErrorLog;
                hr = m_cpCompiler->SetSaveObjects(pSaveStream, &ErrorLog);
                if (SUCCEEDED(hr))
                {
                    hr = m_cpCompiler->Commit(0);
                    m_cpCompiler->SetSaveObjects(NULL, NULL);
                }
                if (ppCoMemErrorText)
                {
                    *ppCoMemErrorText = ErrorLog.m_dstrText.Detach();
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::UnloadCmd *
*-------------------------*
*   Description:
*       This function is called from various LoadCmdxxx functions both to clear
*   an existing grammar and in the failure case.  It is important that we only
*   tell the engine that we're unloading a grammar if we have successfully loaded
*   one, but we should always release the grammar compiler and reset the base
*   grammar since we could have loaded one, but m_fCmdLoaded is not set since
*   the engine failed to load it.
*
*   Returns:
*       The only possible failure case is when the engine fails the unload call    
*
********************************************************************* RAL ***/
                         
HRESULT CRecoGrammar::UnloadCmd()
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::UnloadCmd");
    HRESULT hr = S_OK;

    // Make sure we mark our automation objects invalid here.
    if ( m_pCRulesWeak )
    {
        m_pCRulesWeak->InvalidateRules();
    }
    //  Do this always - See note above
    m_cpCompiler.Release();
    CBaseGrammar::Clear();

    // If the engine thinks there is a loaded grammar, then tell it about it
    if (m_fCmdLoaded)
    {
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));
        Task.eTask = EGT_UNLOADCMD;
        hr = CallEngine(&Task);

        m_fProprietaryCmd = FALSE;
        m_fCmdLoaded = FALSE;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::InternalSetRuleState *
*------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoGrammar::InternalSetRuleState(const WCHAR * pszRuleName, void * pReserved, DWORD dwRuleId, SPRULESTATE NewState)
{
    SPDBG_FUNC("CRecoGrammar::InternalSetRuleState");
    HRESULT hr = S_OK;

    if (NewState != SPRS_INACTIVE && NewState != SPRS_ACTIVE && NewState != SPRS_ACTIVE_WITH_AUTO_PAUSE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));

        Task.eTask = EGT_SETCMDRULESTATE;

        if (pszRuleName)
        {
            wcscpy(Task.szRuleName, pszRuleName);
        }
        else
        {
            Task.szRuleName[0] = 0;
        }

        Task.dwRuleId = dwRuleId;
        Task.RuleState = NewState;

        hr = CallEngine(&Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::SetRuleState *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::SetRuleState(const WCHAR * pszName, void * pReserved, SPRULESTATE NewState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::SetRuleState");
    HRESULT hr = S_OK;

    if (pszName && SPIsBadStringPtr(pszName, MAX_PATH) ||
        (pReserved != NULL))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = InternalSetRuleState(pszName, pReserved, 0, NewState);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CRecoGrammar::SetRuleIdState *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::SetRuleIdState(DWORD dwRuleId, SPRULESTATE NewState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::SetRuleIdState");
    HRESULT hr = S_OK;
    
    hr = InternalSetRuleState(NULL, NULL, dwRuleId, NewState);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::LoadDictation *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::LoadDictation(const WCHAR * pszTopicName, SPLOADOPTIONS Options)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::LoadDictation");
    HRESULT hr = S_OK;

    if (pszTopicName && SPIsBadStringPtr(pszTopicName, MAX_PATH) ||
        Options != SPLO_STATIC)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));
        Task.eTask = EGT_LOADDICTATION;
        if (pszTopicName)
        {
            wcscpy(Task.szTopicName, pszTopicName);
        }
        else
        {
            Task.szTopicName[0] = 0;
        }
        hr = CallEngine(&Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::UnloadDictation *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::UnloadDictation()
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::UnloadDictation");
    HRESULT hr = S_OK;

    ENGINETASK Task;
    memset(&Task, 0, sizeof(Task));
    Task.eTask = EGT_UNLOADDICTATION;
    hr = CallEngine(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::SetDictationState *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::SetDictationState(SPRULESTATE NewState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::SetDictationState");
    HRESULT hr = S_OK;

    if (NewState != SPRS_INACTIVE && NewState != SPRS_ACTIVE && NewState != SPRS_ACTIVE_WITH_AUTO_PAUSE)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr) && m_DictationState != NewState)
    {
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));
        Task.eTask = EGT_SETDICTATIONRULESTATE;
        Task.RuleState = NewState;
        hr = CallEngine(&Task);
        if (SUCCEEDED(hr))
        {
            m_DictationState = NewState;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::InternalSetTextSel *
*----------------------------------*
*   Description:
*       This method is used by both SetWordSequenceData and by SetTextSelection.
*   Both methods call the engine with a shared engine task structure, but some
*   fields are ignored for EGT_SETTEXTSELECTION.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoGrammar::InternalSetTextSel(ENGINETASKENUM EngineTask, const WCHAR * pText, ULONG cchText, const SPTEXTSELECTIONINFO * pInfo)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CRecoGrammar::InternalSetTextSel");
    HRESULT hr = S_OK;

    if ((pText && (cchText == 0 || SPIsBadReadPtr(pText, sizeof(*pText) * cchText))) ||
        (pText == NULL && cchText) ||
        SP_IS_BAD_OPTIONAL_READ_PTR(pInfo))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));

        Task.eTask = EngineTask;
        Task.pvAdditionalBuffer = (void *)pText;
	    Task.cbAdditionalBuffer = cchText * sizeof(*pText);
        if (pInfo)
        {
            Task.fSelInfoValid = true;
            Task.TextSelInfo = *pInfo;
        }
        else
        {
            Task.fSelInfoValid = false;
        }

        hr = CallEngine(&Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::SetWordSequenceData *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::SetWordSequenceData(const WCHAR * pText, ULONG cchText, const SPTEXTSELECTIONINFO * pInfo)
{
    return InternalSetTextSel(EGT_SETWORDSEQUENCEDATA, pText, cchText, pInfo);
}

/****************************************************************************
* CRecoGrammar::SetTextSelection *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::SetTextSelection(const SPTEXTSELECTIONINFO * pInfo)
{
    return InternalSetTextSel(EGT_SETTEXTSELECTION, NULL, 0, pInfo);
}


/****************************************************************************
* CRecoGrammar::IsPronounceable *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::IsPronounceable(const WCHAR * pszWord, SPWORDPRONOUNCEABLE * pWordPronounceable)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::IsPronounceable");
    HRESULT hr = S_OK;

    if (SPIsBadLexWord(pszWord) || SP_IS_BAD_WRITE_PTR(pWordPronounceable))
    {
        hr = E_POINTER;
    }
    else
    {
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));

        Task.eTask = EGT_ISPRON;
	    wcscpy(Task.szWord, pszWord);

        hr = CallEngine(&Task);
        if (SUCCEEDED(hr))
        {
            *pWordPronounceable = Task.Response.WordPronounceable;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoGrammar::SetGrammarState *
*-------------------------------*
*   Description:
*       This method can set the grammar mode to SPGM_DISABLED, which temporarely
*       turns off all the rules in this grammar, but remembers their activation
*       state, so that when the grammar gets SPGM_ENABLED, it restores the desired
*       grammar activation state. While the grammar is SPGM_DISABLED, the 
*       application can still activate and deactivate rule. The effect is not 
*       communicated to the SR engine until the grammar is enabled again.
*
*   Returns:
*
***************************************************************** PhilSch ***/

STDMETHODIMP CRecoGrammar::SetGrammarState(SPGRAMMARSTATE eGrammarState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::SetGrammarState");
    HRESULT hr = S_OK;

    if (eGrammarState != SPGS_DISABLED &&
        eGrammarState != SPGS_ENABLED &&
        eGrammarState != SPGS_EXCLUSIVE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (eGrammarState != m_GrammarState)
        {
            ENGINETASK Task;
            memset(&Task, 0, sizeof(Task));

            Task.eTask = EGT_SETGRAMMARSTATE;
            Task.eGrammarState = eGrammarState;
            hr = CallEngine(&Task);
            if (SUCCEEDED(hr))
            {
                m_GrammarState = eGrammarState;
            }
        }
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoGrammar::GetGrammarState *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoGrammar::GetGrammarState(SPGRAMMARSTATE * peGrammarState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoGrammar::GetGrammarState");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(peGrammarState))
    {
        hr = E_POINTER;
    }
    else
    {
        *peGrammarState = m_GrammarState;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


#ifdef SAPI_AUTOMATION

//
//=== ISpeechRecoGrammar interface ==================================================
//

/*****************************************************************************
* CRecoGrammar::get_Id *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::get_Id( VARIANT* pGrammarId )
{
    SPDBG_FUNC( "CRecoGrammar::get_Id" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pGrammarId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ULONGLONG ullId;
        hr = GetGrammarId(&ullId);
        if (SUCCEEDED( hr ))
        {
            hr = ULongLongToVariant( ullId, pGrammarId );
        }
    }

    return hr;
} /* CRecoGrammar::get_Id */

/*****************************************************************************
* CRecoGrammar::get_RecoContext *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::get_RecoContext( ISpeechRecoContext** ppRecoCtxt )
{
    SPDBG_FUNC( "CRecoGrammar::get_RecoContext" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRecoCtxt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpRecoContext> cpContext;
        hr = GetRecoContext(&cpContext);
        if ( SUCCEEDED( hr ) )
        {
	        hr = cpContext.QueryInterface( ppRecoCtxt );
        }
    }

    return hr;
} /* CRecoGrammar::get_RecoContext */


/*****************************************************************************
* CRecoGrammar::put_State *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::put_State( SpeechGrammarState eGrammarState )
{
    SPDBG_FUNC( "CRecoGrammar::put_State" );

    return SetGrammarState( (SPGRAMMARSTATE)eGrammarState );
} /* CRecoGrammar::put_State */


/*****************************************************************************
* CRecoGrammar::get_State *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::get_State( SpeechGrammarState* peGrammarState )
{
    SPDBG_FUNC( "CRecoGrammar::get_State" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( peGrammarState ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetGrammarState( (SPGRAMMARSTATE*)peGrammarState );
    }

    return hr;
} /* CRecoGrammar::get_State */


/*****************************************************************************
* CRecoGrammar::DefaultToDynamicGrammar *
*-----------------------------*
*       
********************************************************************* TODDT ***/
HRESULT CRecoGrammar::DefaultToDynamicGrammar()
{
    SPDBG_FUNC( "CRecoGrammar::DefaultToDynamicGrammar" );
    HRESULT hr = S_OK;

    if ( !m_cpCompiler && !m_fCmdLoaded )
    {
        // This is the same code that lives in CRecoGrammar::GetRule().
        CComQIPtr<ISpRecognizer> cpRecognizer(m_pParent->m_cpRecognizer);
        SPRECOGNIZERSTATUS Status;
        hr = cpRecognizer->GetStatus(&Status);
        if (SUCCEEDED(hr))
        {
            hr = ResetGrammar(Status.aLangID[0]);
        }

        SPDBG_ASSERT( SUCCEEDED(hr) && m_cpCompiler);
        if ( SUCCEEDED(hr) && !m_cpCompiler )
        {
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

/*****************************************************************************
* CRecoGrammar::get_Rules *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::get_Rules( ISpeechGrammarRules** ppRules )
{
    SPDBG_FUNC( "CRecoGrammar::get_Rules" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRules ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if ( m_pCRulesWeak )
        {
            *ppRules = m_pCRulesWeak;
            (*ppRules)->AddRef();
        }
        else
        {
            *ppRules = NULL;

            // We've got to make sure we've got a grammar compiler object created first if we don't have
            // a static grammar already loaded.  If we do we are going to return a NULL rules collection.
            hr = DefaultToDynamicGrammar();

            if ( SUCCEEDED(hr) )
            {
                //--- Create the CSpeechGrammarRules object
                CComObject<CSpeechGrammarRules> *pRules;
                hr = CComObject<CSpeechGrammarRules>::CreateInstance( &pRules );
                if ( SUCCEEDED( hr ) )
                {
                    pRules->AddRef();
                    pRules->m_pCRecoGrammar = this;    // need to keep ref on Grammar
                    pRules->m_pCRecoGrammar->AddRef();
                    *ppRules = pRules;
                    m_pCRulesWeak = pRules;
                }
            }
        }
    }

    return hr;
} /* CRecoGrammar::get_Rules */


/*****************************************************************************
* CRecoGrammar::Reset *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::Reset( SpeechLanguageId NewLanguage )
{
    SPDBG_FUNC( "CRecoGrammar::Reset" );

    return ResetGrammar( (LANGID)NewLanguage );
} /* CRecoGrammar::Reset */


/*****************************************************************************
* CRecoGrammar::CmdLoadFromFile *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::CmdLoadFromFile( const BSTR FileName, SpeechLoadOption LoadOption )
{
    SPDBG_FUNC( "CRecoGrammar::CmdLoadFromFile" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_STRING_PTR( FileName ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = LoadCmdFromFile(FileName, (SPLOADOPTIONS)LoadOption );
    }

    return hr;
} /* CRecoGrammar::CmdLoadFromFile */

/*****************************************************************************
* CRecoGrammar::CmdLoadFromObject *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::CmdLoadFromObject(  const BSTR ClassId,
                                               const BSTR GrammarName,
                                               SpeechLoadOption LoadOption )
{
    SPDBG_FUNC( "CRecoGrammar::CmdLoadFromObject" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_STRING_PTR( ClassId ) || SP_IS_BAD_STRING_PTR( GrammarName ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CLSID   clsid;

        hr = ::CLSIDFromString(ClassId, &clsid);

        if (SUCCEEDED(hr))
        {
            hr = LoadCmdFromObject(clsid, (const WCHAR*)GrammarName, (SPLOADOPTIONS)LoadOption );
        }
    }

    return hr;
} /* CRecoGrammar::CmdLoadFromObject */


/*****************************************************************************
* GetResourceValue *
*-------------------------------*
* Helper routine for CmdLoadFromResource below.      
********************************************************************* TODDT ***/
STDMETHODIMP GetResourceValue(  VARIANT * pResource, WCHAR** ppResValue )
{
    SPDBG_FUNC( "CRecoGrammar::CmdLoadFromResource" );
    HRESULT hr = S_OK;

    if ( !pResource )
    {
        return E_INVALIDARG;
    }

    if ( (pResource->vt == (VT_BYREF | VT_BSTR)) || (pResource->vt == VT_BSTR) )
    {
        *ppResValue  = ((pResource->vt & VT_BYREF) ? 
                        (pResource->pbstrVal ? *(pResource->pbstrVal) : NULL) : 
                         pResource->bstrVal );
    }
    else
    {
        ULONGLONG ull;
        hr = VariantToULongLong( pResource, &ull );
        if ( SUCCEEDED( hr ) )
        {
            // See if it's a valid resource ID.
            if ( (ull >> 16) == 0 )
            {
                *ppResValue = MAKEINTRESOURCEW( (ULONG_PTR)ull );
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }

    return hr;
}

/*****************************************************************************
* CRecoGrammar::CmdLoadFromResource *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::CmdLoadFromResource(  long hModule,
                                                 VARIANT ResourceName,
                                                 VARIANT ResourceType,
                                                 SpeechLanguageId LanguageId,
                                                 SpeechLoadOption LoadOption )
{
    SPDBG_FUNC( "CRecoGrammar::CmdLoadFromResource" );
    HRESULT hr = S_OK;

    WCHAR* pResName = NULL;
    WCHAR* pResType = NULL;

    hr = GetResourceValue( &ResourceName, &pResName );

    if ( SUCCEEDED( hr ) )
    {
        hr = GetResourceValue( &ResourceType, &pResType );
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = LoadCmdFromResource((HMODULE)LongToHandle(hModule), 
                                 (const WCHAR *)pResName, 
                                 (const WCHAR *)pResType, 
                                 (LANGID)LanguageId, 
                                 (SPLOADOPTIONS)LoadOption );
    }

    return hr;
} /* CRecoGrammar::CmdLoadFromResource */

/*****************************************************************************
* CRecoGrammar::CmdLoadFromMemory *
*-------------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecoGrammar::CmdLoadFromMemory( VARIANT GrammarData, SpeechLoadOption LoadOption )
{
    SPDBG_FUNC( "CRecoGrammar::CmdLoadFromMemory" );
    HRESULT             hr = S_OK;
    SPBINARYGRAMMAR*    pBinaryGrammar;
    
    hr = AccessVariantData( &GrammarData, (BYTE **)&pBinaryGrammar );

    if( SUCCEEDED( hr ) )
    {
        hr = LoadCmdFromMemory( pBinaryGrammar, (SPLOADOPTIONS)LoadOption );

        UnaccessVariantData( &GrammarData, (BYTE *)pBinaryGrammar );
    }

    return hr;
} /* CRecoGrammar::CmdLoadFromMemory */
 
/*****************************************************************************
* CRecoGrammar::CmdLoadFromProprietaryGrammar *
*-------------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecoGrammar::CmdLoadFromProprietaryGrammar(  const BSTR ProprietaryGuid,
                                                           const BSTR ProprietaryString,
                                                           VARIANT ProprietaryData,
                                                           SpeechLoadOption LoadOption )
{
    SPDBG_FUNC( "CRecoGrammar::CmdLoadFromProprietaryGrammar" );
    HRESULT         hr = S_OK;
    CLSID           clsid;
    BYTE *          pData;
    ULONG           ulSize;

    if( SP_IS_BAD_STRING_PTR( ProprietaryGuid ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ::CLSIDFromString( ProprietaryGuid, &clsid );

        if( SUCCEEDED( hr ) )
        {
            hr = AccessVariantData( &ProprietaryData, &pData, &ulSize );
        }

        if( SUCCEEDED( hr ) )
        {
            hr = LoadCmdFromProprietaryGrammar( clsid, ProprietaryString, pData, ulSize, (SPLOADOPTIONS)LoadOption );

            UnaccessVariantData( &ProprietaryData, pData );
        }
    }

    return hr;
} /* CRecoGrammar::CmdLoadFromProprietaryGrammar */


/*****************************************************************************
* CRecoGrammar::CmdSetRuleState *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::CmdSetRuleState( const BSTR Name, SpeechRuleState State )
{
    SPDBG_FUNC( "CRecoGrammar::CmdSetRuleState" );

    return SetRuleState(Name, NULL, (SPRULESTATE)State );
} /* CRecoGrammar::CmdSetRuleState */

/*****************************************************************************
* CRecoGrammar::CmdSetRuleIdState *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::CmdSetRuleIdState( long lRuleId, SpeechRuleState State )
{
    SPDBG_FUNC( "CRecoGrammar::CmdSetRuleIdState" );

    return SetRuleIdState(lRuleId, (SPRULESTATE)State );
} /* CRecoGrammar::CmdSetRuleIdState */

/*****************************************************************************
* CRecoGrammar::DictationLoad *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::DictationLoad( const BSTR bstrTopicName, SpeechLoadOption LoadOption )
{
    SPDBG_FUNC( "CRecoGrammar::DictationLoad" );

    return LoadDictation(EmptyStringToNull(bstrTopicName), (SPLOADOPTIONS)LoadOption );
} /* CRecoGrammar::DictationLoad */

/*****************************************************************************
* CRecoGrammar::DictationUnload *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::DictationUnload( void )
{
    SPDBG_FUNC( "CRecoGrammar::DictationUnload" );

    return UnloadDictation();
} /* CRecoGrammar::DictationUnload */

/*****************************************************************************
* CRecoGrammar::DictationSetState *
*-------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoGrammar::DictationSetState( SpeechRuleState State )
{
    SPDBG_FUNC( "CRecoGrammar::DictationSetState" );

    return SetDictationState((SPRULESTATE)State);
} /* CRecoGrammar::DictationSetState */


/*****************************************************************************
* CRecoGrammar::SetWordSequenceData *
*-------------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecoGrammar::SetWordSequenceData( const BSTR Text, long TextLen, ISpeechTextSelectionInformation* Info )
{
    SPDBG_FUNC( "CRecoGrammar::SetWordSequenceData" );
    HRESULT     hr = S_OK;
    SPTEXTSELECTIONINFO     TextSelectionInfo;

    if( SP_IS_BAD_INTERFACE_PTR( Info ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ZeroMemory( &TextSelectionInfo, sizeof(TextSelectionInfo) );

        hr = Info->get_ActiveOffset( (long*)&TextSelectionInfo.ulStartActiveOffset );

        if( SUCCEEDED( hr ) )
        {
            hr = Info->get_ActiveLength( (long*)&TextSelectionInfo.cchActiveChars );
        }
        
        if( SUCCEEDED( hr ) )
        {
            hr = Info->get_SelectionOffset( (long*)&TextSelectionInfo.ulStartSelection );
        }
        
        if( SUCCEEDED( hr ) )
        {
            hr = Info->get_SelectionLength( (long*)&TextSelectionInfo.cchSelection );
        }

        if( SUCCEEDED( hr ) )
        {
            hr = SetWordSequenceData( Text, TextLen, &TextSelectionInfo );
        }
    }
    
    return hr;
} /* CRecoGrammar::SetWordSequenceData */

/*****************************************************************************
* CRecoGrammar::SetTextSelection *
*-------------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecoGrammar::SetTextSelection( ISpeechTextSelectionInformation* Info )
{
    SPDBG_FUNC( "CRecoGrammar::SetTextSelection" );
    HRESULT                 hr = S_OK;
    SPTEXTSELECTIONINFO     TextSelectionInfo;

    if( SP_IS_BAD_INTERFACE_PTR( Info ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ZeroMemory( &TextSelectionInfo, sizeof(TextSelectionInfo) );

        hr = Info->get_ActiveOffset( (long*)&TextSelectionInfo.ulStartActiveOffset );

        if( SUCCEEDED( hr ) )
        {
            hr = Info->get_ActiveLength( (long*)&TextSelectionInfo.cchActiveChars );
        }
        
        if( SUCCEEDED( hr ) )
        {
            hr = Info->get_SelectionOffset( (long*)&TextSelectionInfo.ulStartSelection );
        }
        
        if( SUCCEEDED( hr ) )
        {
            hr = Info->get_SelectionLength( (long*)&TextSelectionInfo.cchSelection );
        }

        if( SUCCEEDED( hr ) )
        {
            hr = SetTextSelection( &TextSelectionInfo );
        }
    }

    return hr;
} /* CRecoGrammar::SetTextSelection */

/*****************************************************************************
* CRecoGrammar::IsPronounceable *
*-------------------------------*
*       
********************************************************************* ToddT ***/
STDMETHODIMP CRecoGrammar::IsPronounceable( const BSTR Word, SpeechWordPronounceable *pWordPronounceable )
{
    SPDBG_FUNC( "CRecoGrammar::IsPronounceable" );

    // Param validation done by C++ version of IsPronounceable.
    return IsPronounceable( (const WCHAR *)Word, (SPWORDPRONOUNCEABLE*)pWordPronounceable );
}

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srevent.h ===
/******************************************************************************
* SREvent.h *
*----------*
*  This is the header file for the CSREvent implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#ifndef __SREvent_h__
#define __SREvent_h__


class CSREvent
{
public:
    CSREvent            * m_pNext;
    SPRECOCONTEXTHANDLE   m_hContext;
    ULONG                 m_cbEvent;
    SPSERIALIZEDEVENT64 * m_pEvent;         // Only used for non-recognition events  
    SPEVENTENUM           m_eRecognitionId; // Only used for recognition events
    SPRESULTHEADER      * m_pResultHeader;  // Only used for recognition events
    WPARAM                m_RecoFlags;      // Only used for recognition events

    CSREvent();
    ~CSREvent();
    HRESULT Init(const SPEVENT * pSrcEvent, SPRECOCONTEXTHANDLE hContext);
    void Init(SPRESULTHEADER * pCoMemResultHeader, SPEVENTENUM eRecognitionId, WPARAM RecoFlags, SPRECOCONTEXTHANDLE hContext);
    operator ==(const SPRECOCONTEXTHANDLE h) const 
    {
        return m_hContext == h;
    }
};


typedef CSpProducerConsumerQueue<CSREvent>      CSREventQueue;


#endif  // #ifndef __SREvent_h__ - Keep as the last line of the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\sraudio.h ===
// SrAudio.h : Declaration of the CBuffDataNode

#ifndef __SrAudio_H_
#define __SrAudio_H_

#include "resource.h"       // main symbols

#define FT64(/*FILETIME*/ filetime) (*((LONGLONG*)&(filetime)))

#pragma warning(disable:4200)
class CAudioBuffer
{
public:
    CAudioBuffer(ULONG cb) : m_cb(cb) {}
    CAudioBuffer *  m_pNext;
    ULONG           m_cb;
    BYTE            m_Data[];
};
#pragma warning(default:4200)


//
//  This simple inline function returns TRUE if the HRESULT returned from a stream read operation
//  should result in a stream restart.  Audio streams will be restarted if the final read operation
//  fails with an overflow, underflow, or if the audio device has been stopped.
//
inline bool IsStreamRestartHresult(HRESULT hr)
{
    return (hr == SPERR_AUDIO_BUFFER_OVERFLOW ||
            hr == SPERR_AUDIO_BUFFER_UNDERFLOW ||
            hr == SPERR_AUDIO_STOPPED);
}

class CAudioQueue
{
private:
    void PurgeQueue();

public:
    CAudioQueue();
    void ReleaseAll();
    HRESULT GetEngineFormat(_ISpRecoMaster * pEngine, const CSpStreamFormat * pInputFormat);
    HRESULT FinalConstruct(ISpNotifySink * pAudioEventNotify);
    HRESULT Reset(const CSpStreamFormat * pFmt);
    HRESULT SRSiteRead(void * pv, ULONG cb, ULONG * pcbRead);
    HRESULT SRSiteDataAvailable(ULONG * pcb);
    HRESULT AddRefBufferClient();
    HRESULT ReleaseBufferClient();
    HRESULT SetInput(ISpObjectToken * pToken, ISpStreamFormat * pStream, BOOL fAllowFormatChanges);
    BOOL    GetData(void * pv, ULONGLONG ullStreamPosition, ULONG cb);
    HRESULT DiscardData(ULONGLONG ullStreamPosition);
    BOOL    DataAvailable(ULONGLONG ullStreamPosition, ULONG cb) const;
    HRESULT GetAudioStatus(SPAUDIOSTATUS * pStatus);
    HRESULT NegotiateInputStreamFormat(_ISpRecoMaster * pEngine);
    void ResetNegotiatedStreamFormat();
    HRESULT SetBufferNotifySize(ULONG cb);
    HRESULT GetAudioEvent(CSpEvent * pSpEvent);
    ULONGLONG   LastPosition() const
    {
        return m_ullCurSeekPos - m_ullInitialSeekPos;
    }
    BOOL HaveInputStream()
    {
        return m_cpOriginalInputStream != NULL;
    }
    ULONG SerializeSize(ULONGLONG ullStreamPosition, ULONG cbAudioBytes) const;
    void Serialize(BYTE * pBuffer, ULONGLONG ullStartOffset, ULONG cbAudioBytes);
    const CSpStreamFormat & EngineFormat() const
    {
        return m_EngineFormat;
    }
    const CSpStreamFormat & InputFormat() const
    {
        return m_InputFormat;
    }
    HRESULT CopyOriginalInputStreamTo(ISpStreamFormat ** ppStream)
    {
        return m_cpOriginalInputStream.CopyTo(ppStream);
    }
    ISpObjectToken * InputToken()
    {
        return m_cpInputToken;
    }
    HRESULT SetEventInterest(ULONGLONG ullEventInterest);
    ULONGLONG DelayStreamPos();
    void UpdateRealTime();
    HRESULT AdjustAudioVolume(ISpObjectToken * pRecoProfileToken, REFCLSID clsidEngine);
    HANDLE  DataAvailableEvent();

    HRESULT StartStream(_ISpRecoMaster * pEngine,
                        ISpObjectToken * pRecoProfile,
                        REFCLSID rcidEngine,
                        BOOL * pfNewStream);
    HRESULT StopStream();   
    HRESULT EndStream(HRESULT * pFinalReadHResult, BOOL *pfReleasedStream);
    HRESULT CloseStream();   
    HRESULT PauseStream();

    BOOL IsRealTimeAudio()
    {
        return m_cpOriginalInputAudio != NULL;
    }
        
    // NOTE:  This method does NOT ADDREF!  
    ISpObjectToken * InputObjectToken()
    {
        return m_cpInputToken;
    }
    void CalculateTimes(ULONGLONG ullStreamPosStart, ULONGLONG ullStreamPosEnd, SPRECORESULTTIMES *pTimes)
    {
        SPAUDIOSTATUS AudioStatus;

        // Set up real time info.
        UpdateRealTime();

        // Be sure to add the m_ullInitialStreamPos below. Otherwise the stream pos returned by the
        // engine would get out of sync with the stream pos maintained by sapi when the audio state is changed.
        if (m_cpInputAudio && m_cpInputAudio->GetStatus(&AudioStatus) == S_OK)
        {

            LONGLONG deltapos = m_ullInitialSeekPos + ullStreamPosStart - m_ullLastTimeUpdatePos;
            LONGLONG deltatime = (LONGLONG)((float)deltapos * m_fTimePerByte);

            // calculate new point time from last time + deltatime
            FT64((pTimes->ftStreamTime)) = FT64(m_ftLastTime) + deltatime;
            SPDBG_ASSERT(FT64(pTimes->ftStreamTime));
            // backup tick count by # of milliseconds between current time and calculate min point time
            pTimes->dwTickCount = m_dwTickCount + (DWORD)(deltatime / 10000);

        }
        else
        {
            ZeroMemory(pTimes, sizeof(SPRECORESULTTIMES));
        }

        pTimes->ullLength = (ULONGLONG)((float)(ullStreamPosEnd - ullStreamPosStart) * m_fTimePerByte);
        pTimes->ullStart = (ULONGLONG)((float)(LONGLONG)ullStreamPosStart * m_fTimePerByte);


#if 0
        ATLTRACE(_T("times last %x:%x, result %x:%x, tick %d, length %d\n"),
                 m_ftLastTime.dwHighDateTime, m_ftLastTime.dwLowDateTime,
                 pTimes->ftStreamTime.dwHighDateTime, pTimes->ftStreamTime.dwLowDateTime,
                 pTimes->dwTickCount, (DWORD)pTimes->ullLength);
#endif
    }
    float TimePerByte(void)
    {
        return m_fTimePerByte;
    }
    float InputScaleFactor(void)
    {
        return m_fInputScaleFactor;
    }

    SPAUDIOSTATE GetStreamAudioState(void)
    {
	    return m_StreamAudioState;
    }

private:
    CComAutoCriticalSection     m_CritSec;
    CSpAutoEvent                m_autohAlwaysSignaledEvent;
    CSpBasicQueue<CAudioBuffer> m_Queue;
    ULONGLONG                   m_ullQueueStartPos;
    ULONG                       m_cbTotalQueueSize;
    ULONG                       m_cClients;

    CComPtr<ISpObjectToken>     m_cpInputToken;     // Token of input object (if any)
    CComPtr<ISpStreamFormat>    m_cpOriginalInputStream;    // Actual stream interface of input object
    CComPtr<ISpAudio>           m_cpOriginalInputAudio;     // If audio, then interface of intput object

    CComPtr<ISpStreamFormat>    m_cpInputStream;    // Actual stream interface of input object
    CComPtr<ISpAudio>           m_cpInputAudio;     // If audio, then interface of intput object
    CComPtr<ISpEventSource>     m_cpInputEventSource;   // EventSource connected to audio object

    CComPtr<ISpNotifySink>      m_cpAudioEventNotify;   // Pointer to notify for audio volume events

    SPAUDIOSTATE                m_StreamAudioState;    
    BOOL                        m_fUsingConverter;
    BOOL                        m_fAllowFormatChanges;
    BOOL                        m_fNewStream;       // This is reset on a sucessfull StartStream()
    BOOL                        m_fEndOfStream;
    HRESULT                     m_hrLastRead;    

    CSpStreamFormat             m_InputFormat;
    CSpStreamFormat             m_EngineFormat;

    FILETIME                    m_ftLastTime;
    ULONGLONG                   m_ullLastTimeUpdatePos;
    ULONGLONG                   m_ullInitialSeekPos;
    ULONGLONG                   m_ullCurSeekPos;
    ULONGLONG                   m_ullAudioEventInterest;

    DWORD                       m_dwTickCount;
    float                       m_fTimePerByte;
    float                       m_fInputScaleFactor;
};



#endif //__SrAudio_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srproxies.h ===
// srproxies.h : Declaration of the CRecoCtxtPr & CRecoEnginePr classes

#ifndef __SRPROXIES_H_
#define __SRPROXIES_H_

#include "resource.h"       // main symbols

//
//  Structures for method calls.
//
enum SPENGMC
{
    MC_RECOGNITION = SPEI_RECOGNITION,              // Make sure these line up so we can
    MC_HYPOTHESIS = SPEI_HYPOTHESIS,                // directly cast from a SPENGMC to an event
    MC_FALSE_RECOGNITION = SPEI_FALSE_RECOGNITION,  // enum type.
    MC_DISCONNECT,
    MC_SETMAXALTERNATES,
    MC_PERFORMTASK,
    MC_PERFORMTASK_ND,   // no data version
    MC_SETINTEREST,
    MC_EVENTNOTIFY,
    MC_GETFORMAT,
    MC_GETRECOEXTENSION,
    MC_CALLENGINE,
    MC_TASKNOTIFY,
    MC_GETPROFILE,
    MC_SETPROFILE,
    MC_SETRECOSTATE,
    MC_GETSTATUS,
    MC_GETRECOGNIZER,
    MC_GETINPUTTOKEN,
    MC_GETRECOINSTFORMAT,
    MC_SETRETAINAUDIO,
    MC_SETPROPNUM,
    MC_GETPROPNUM,
    MC_SETPROPSTRING,
    MC_GETPROPSTRING,
    MC_EMULRECO
};


typedef struct _CF_GETRECOEXTENSION {
    GUID    ctxtCLSID;              //[out]
} CF_GETRECOEXTENSION;

typedef struct _CF_RECOGNIZER {
    WCHAR       szRecognizerName[MAX_PATH];
} CF_RECOGNIZER;

typedef struct _CF_INPUTTOKEN {
    WCHAR       szInputToken[MAX_PATH];
} CF_INPUTTOKEN;

typedef struct _CF_PROFILE {
    WCHAR       szProfileId[MAX_PATH];
} CF_PROFILE;

typedef struct _CF_GETFORMAT {
    BYTE        aSerializedData[1000];
} CF_GETFORMAT;

struct CF_SETGETNUM
{
    WCHAR Name[MAX_PATH];
    LONG lValue;
};

struct CF_SETGETSTRING
{
    WCHAR Name[MAX_PATH];
    WCHAR Value[MAX_PATH];
};

class ATL_NO_VTABLE CRecoCtxtPr : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CRecoCtxtPr, &CLSID__RecoCtxtPr>,
    public _ISpRecoCtxtPrivate,
	public ISpIPCObject,
    public ISpIPC
{
private:
    CComPtr<ISpObjectRef>      m_cpClientObject;
    CComPtr<_ISpEnginePrivate> m_cpEngine;
    SPRECOCONTEXTHANDLE         m_hRecoInstCtxt;
    CComPtr<ISpResourceManager> m_cpResMgr; // we have to hold onto the ResMgr
// so that it holds a reference to the default Engine object since we only want one of these!
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_RECOCTXTPR)

BEGIN_COM_MAP(CRecoCtxtPr)
    COM_INTERFACE_ENTRY(_ISpRecoCtxtPrivate)
    COM_INTERFACE_ENTRY(ISpIPC)
    COM_INTERFACE_ENTRY(ISpIPCObject)
END_COM_MAP()

    HRESULT FinalConstruct();
    void FinalRelease();

// _ISpRecoCtxtPrivate
    STDMETHODIMP SetRecoInstContextHandle(SPRECOCONTEXTHANDLE h)
    {
        m_hRecoInstCtxt = h;
        return S_OK;
    }
    STDMETHODIMP RecognitionNotify(SPRESULTHEADER *pPhrase, SPEVENTENUM eEventId);

    STDMETHODIMP EventNotify(const SPSERIALIZEDEVENT * pEvent, ULONG cbSerializedSize);

    STDMETHODIMP TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse);

    STDMETHODIMP StreamChangedNotify(void)
    {
        return S_OK; // Stream format changes don't interest shared contexts
    }

// ISpIPCObject
    STDMETHODIMP SetOppositeHalf(ISpObjectRef *pSOR)
    {
        m_cpClientObject = pSOR;
        return S_OK;
    }

// ISpIPC
	STDMETHODIMP MethodCall(DWORD dwMethod,
					        ULONG ulCallFrameSize, void *pCallFrame,
					        ULONG paramblocks, void * paramarray[]);
};


class ATL_NO_VTABLE CRecoEnginePr :
	public CComObjectRootEx<CComMultiThreadModel>,
    public _ISpEnginePrivate,
    public ISpIPC
{
private:
    _ISpRecoCtxtPrivate  *m_pRecoObject; // weak pointer
    CComPtr<ISpObjectRef> m_cpSrvObject;
public:

BEGIN_COM_MAP(CRecoEnginePr)
    COM_INTERFACE_ENTRY(_ISpEnginePrivate)
END_COM_MAP()

    void _Init(_ISpRecoCtxtPrivate *pCtxtPtr, ISpObjectRef *pObjRef)
    {
        m_pRecoObject = pCtxtPtr;
        m_cpSrvObject = pObjRef;
    }

    //
    //  _ISpEnginePrivate
    //
    STDMETHODIMP PerformTask(ENGINETASK *pTask);

    STDMETHODIMP SetMaxAlternates(SPRECOCONTEXTHANDLE h, ULONG cAlternates);
    STDMETHODIMP SetRetainAudio(SPRECOCONTEXTHANDLE h, BOOL fRetainAudio);
    STDMETHODIMP GetAudioFormat(GUID *pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);
    STDMETHODIMP GetRecoExtension(GUID *pCtxtCLSID);

    STDMETHODIMP CallEngine(SPRECOCONTEXTHANDLE h, PVOID pCallFrame, ULONG ulCallFrameSize);
    STDMETHODIMP RequestInputState(SPAUDIOSTATE oldState, SPAUDIOSTATE newState)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP _LazyInit(BOOL bSharedCase)
    {
        return S_OK;
    }
    STDMETHODIMP _AddRecoCtxt(_ISpRecoCtxtPrivate * pRecoObject, BOOL bSharedCase)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP _SetEventInterest(SPRECOCONTEXTHANDLE h, ULONGLONG ullEventInterest);
    STDMETHODIMP _Disconnect(SPRECOCONTEXTHANDLE h);

// ISpIPC
	STDMETHODIMP MethodCall(DWORD dwMethod,
					        ULONG ulCallFrameSize, void *pCallFrame,
					        ULONG paramblocks, void * paramarray[]);
};

class ATL_NO_VTABLE CSharedRecoInstanceStub :
	public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSharedRecoInstanceStub, &CLSID__SharedRecoInstStub>,
	public ISpIPCObject,
    public ISpIPC
{
private:
    CComPtr<ISpObjectRef>        m_cpClientObject;
    CComPtr<ISpRecognizer>     m_cpEngine;
    CComQIPtr<_ISpEnginePrivate> m_cqipEnginePrivate;
    CComPtr<ISpResourceManager>  m_cpResMgr; // we have to hold onto the ResMgr
// so that it holds a reference to the default Engine object since we only want one of these!
    SPAUDIOSTATE                 m_audioState;

public:

    DECLARE_REGISTRY_RESOURCEID(IDR_RECOINSTSTUB)

BEGIN_COM_MAP(CSharedRecoInstanceStub)
    COM_INTERFACE_ENTRY(ISpIPC)
    COM_INTERFACE_ENTRY(ISpIPCObject)
END_COM_MAP()

    HRESULT FinalConstruct();

// ISpIPCObject
    STDMETHODIMP SetOppositeHalf(ISpObjectRef *pSOR)
    {
        m_cpClientObject = pSOR;
        return S_OK;
    }

// ISpIPC
	STDMETHODIMP MethodCall(DWORD dwMethod,
					        ULONG ulCallFrameSize, void *pCallFrame,
					        ULONG paramblocks, void * paramarray[]);
};
#endif //__SRPROXIES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecoinst.h ===
/******************************************************************************
* RecoInst.h *
*--------------*
*  This is the header file for the CRecoInst implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#ifndef __RecoInst_h__
#define __RecoInst_h__

#include "handletable.h"

#define SHAREDRECO_PERFORM_TASK_METHOD          1
#define SHAREDRECO_EVENT_NOTIFY_METHOD          2
#define SHAREDRECO_RECO_NOTIFY_METHOD           3
#define SHAREDRECO_TASK_COMPLETED_NOTIFY_METHOD 4

struct SHAREDRECO_PERFORM_TASK_DATA
{
    ENGINETASK task;
    // task.pvAdditionalBuffer = this + sizeof(SHAREDRECO_PERFORM_TASK_DATA)
};

struct SHAREDRECO_EVENT_NOTIFY_DATA
{
    SPRECOCONTEXTHANDLE hContext;
    ULONG cbSerializedSize;
    // SPSERIALIZEDEVENT * pEvent = this + sizeof(SHAREDRECO_EVENT_NOTIFY);
};

struct SHAREDRECO_RECO_NOTIFY_DATA
{
    SPRECOCONTEXTHANDLE hContext;
    WPARAM wParamEvent;
    SPEVENTENUM eEventId;
    // SPRESULTHEADER * pCoMemPhraseNowOwnedByCtxt = this + sizeof(SHAREDRECO_RECO_NOTIFY);
};

class CRecoMaster;

//
//  Abstract class that the master communicates with
//


class CRecognizer;

class CRecoInst
{
public:
    CRecoInst           *   m_pNext;        // Used by RecoMaster to insert into list.
    CComPtr<_ISpRecoMaster> m_cpRecoMaster; // CComPtr holds strong reference
    CRecoMaster         *   m_pRecoMaster;  // Pointer to actual class object

    void FinalRelease();
    HRESULT ExecuteTask(ENGINETASK * pTask);
    HRESULT ExecuteFirstPartTask(ENGINETASK * pTask);
    HRESULT BackOutTask(ENGINETASK * pTask);
    inline CRecoMaster * Master()
    {
        return m_pRecoMaster;
    }

    HRESULT PerformTask(ENGINETASK * pTask);

    virtual HRESULT EventNotify(SPRECOCONTEXTHANDLE hContext, const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize) = 0;
    virtual HRESULT RecognitionNotify(SPRECOCONTEXTHANDLE hContext, SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, WPARAM wParamEvent, SPEVENTENUM eEventId) = 0;
    virtual HRESULT TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalBuffer, ULONG cbAdditionalBuffer) = 0;
};

class CInprocRecoInst : public CRecoInst
{
    CRecognizer               * m_pRecognizer;
public:
    HRESULT FinalConstruct(CRecognizer * pRecognizer);

    HRESULT EventNotify(SPRECOCONTEXTHANDLE hContext, const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize);
    HRESULT RecognitionNotify(SPRECOCONTEXTHANDLE hContext, SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, WPARAM wParamEvent, SPEVENTENUM eEventId);
    HRESULT TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalBuffer, ULONG cbAdditionalBuffer);

};


class ATL_NO_VTABLE CSharedRecoInst :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSharedRecoInst, &CLSID__SpSharedRecoInst>,
    public CRecoInst,
    public ISpCallReceiver
{
public:

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_REGISTRY_RESOURCEID(IDR_SHAREDRECOINST)

    BEGIN_COM_MAP(CSharedRecoInst)
        COM_INTERFACE_ENTRY(ISpCallReceiver)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkCommunicator.p)
    END_COM_MAP()

    HRESULT FinalConstruct();
    void FinalRelease();

    STDMETHODIMP ReceiveCall(
                    DWORD dwMethodId,
                    PVOID pvData,
                    ULONG cbData,
                    PVOID * ppvDataReturn,
                    ULONG * pcbDataReturn);

    HRESULT ReceivePerformTask(
                PVOID pvData,
                ULONG cbData,
                PVOID * ppvDataReturn,
                ULONG * pcbDataReturn);

    HRESULT EventNotify(SPRECOCONTEXTHANDLE hContext, const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize);
    HRESULT RecognitionNotify(SPRECOCONTEXTHANDLE hContext, SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, WPARAM wParamEvent, SPEVENTENUM eEventId);
    HRESULT TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalBuffer, ULONG cbAdditionalBuffer);

    CComPtr<IUnknown>           m_cpunkCommunicator;
    ISpCommunicatorInit *       m_pCommunicator;
    
    CComPtr<ISpResourceManager> m_cpResMgr;
    CSpAutoEvent                m_autohTaskComplete;

};


#endif  // #ifndef __RecoInst_h__ - Keep as the last line of the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecoinst.cpp ===
/******************************************************************************
* SrRecoInst.cpp *
*----------------*
*  This is the implementation of CRecoInst.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#include "stdafx.h"
#include "SrRecoInst.h"
#include "SrRecoMaster.h"




/****************************************************************************
* CRecoInst::FinalRelease *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CRecoInst::FinalRelease()
{
    SPDBG_FUNC("CInprocRecoInst::FinalRelease");

    if (m_cpRecoMaster)
    {
        CSpAutoEvent Event;
        Event.InitEvent(NULL, FALSE, FALSE, NULL);
        ENGINETASK Task;
        memset(&Task, 0, sizeof(Task));
    
        Task.eTask = ERMT_REMOVERECOINST;
        Task.hCompletionEvent = Event;
        m_cpRecoMaster->PerformTask(this, &Task);

        // Although ugly, we must wait FOREVER here since the reco master has a
        // pointer to this object and could call back on it at any point.
        // This could be fixed at some later date by giving the reco master a pointer
        // to another object (not this, but owned by this) that we orphan at this point.
        Event.Wait(INFINITE);

        m_cpRecoMaster.Release();
    }
}

/****************************************************************************
* CRecoInst::ExecuteTask *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInst::ExecuteTask(ENGINETASK * pTask)
{
    SPDBG_FUNC("CRecoInst::ExecuteTask");
    HRESULT hr = S_OK;

    switch (pTask->eTask)
    {
        EXEC_RECO_INST_TASK(SETPROFILE)
        EXEC_RECO_INST_TASK(GETPROFILE)
        EXEC_RECO_INST_TASK(SETRECOSTATE)
        EXEC_RECO_INST_TASK(GETRECOINSTSTATUS)
        EXEC_RECO_INST_TASK(GETAUDIOFORMAT)
        EXEC_RECO_INST_TASK(GETRECOSTATE)
        EXEC_RECO_INST_TASK(EMULATERECOGNITION)
        EXEC_RECO_INST_TASK(SETRECOGNIZER)
        EXEC_RECO_INST_TASK(GETRECOGNIZER)
        EXEC_RECO_INST_TASK(SETINPUT)
        EXEC_RECO_INST_TASK(GETPROPERTYNUM)
        EXEC_RECO_INST_TASK(SETPROPERTYNUM)
        EXEC_RECO_INST_TASK(GETPROPERTYSTRING)
        EXEC_RECO_INST_TASK(SETPROPERTYSTRING)
        EXEC_RECO_INST_TASK(GETINPUTTOKEN)
        EXEC_RECO_INST_TASK(GETINPUTSTREAM)
        EXEC_RECO_INST_TASK(CREATECONTEXT)

        default:
            SPDBG_ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;

    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInst::ExecuteFirstPartTask *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInst::ExecuteFirstPartTask(ENGINETASK * pTask)
{
    SPDBG_FUNC("CRecoInst::ExecuteTask");
    HRESULT hr = S_OK;

    switch (pTask->eTask)
    {
        EXEC_FIRSTPART_RECO_INST_TASK(CREATECONTEXT)
        EXEC_FIRSTPART_RECO_INST_TASK(GETRECOGNIZER)
        EXEC_FIRSTPART_RECO_INST_TASK(GETRECOSTATE)
        EXEC_FIRSTPART_RECO_CTXT_TASK(CREATEGRAMMAR)

        default:
            SPDBG_ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;

    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInst::BackOutTask *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInst::BackOutTask(ENGINETASK * pTask)
{
    SPDBG_FUNC("CRecoInst::BackOutTask");
    HRESULT hr = S_OK;

    switch (pTask->eTask)
    {
        BACK_OUT_RECO_INST_TASK(SETRECOSTATE)
        BACK_OUT_RECO_INST_TASK(SETINPUT)

        default:
            SPDBG_ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



HRESULT CRecoInst::PerformTask(ENGINETASK * pTask)
{
    SPDBG_FUNC("CInprocRecoInst::PerformTask");
    HRESULT hr = S_OK;

    hr = m_cpRecoMaster->PerformTask(this, pTask);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CInprocRecoInst::FinalConstruct *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CInprocRecoInst::FinalConstruct(CRecognizer * pRecognizer)
{
    SPDBG_FUNC("CInprocRecoInst::FinalConstruct");
    HRESULT hr = S_OK;

    m_pRecognizer = pRecognizer;

    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoMaster.CoCreateInstance(CLSID__SpRecoMaster);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoMaster->AddRecoInst(this, false, &m_pRecoMaster);
    }

    if (FAILED(hr))
    {
        m_cpRecoMaster.Release();  
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* Forward interface to Recognizer
********************************************************************* RAL ***/

HRESULT CInprocRecoInst::EventNotify(SPRECOCONTEXTHANDLE hContext, const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize)
{
    return m_pRecognizer->EventNotify(hContext, pEvent, cbSerializedSize);
}


HRESULT CInprocRecoInst::RecognitionNotify(SPRECOCONTEXTHANDLE hContext, SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, WPARAM wParamEvent, SPEVENTENUM eEventId)
{
    return m_pRecognizer->RecognitionNotify(hContext, pCoMemPhraseNowOwnedByCtxt, wParamEvent, eEventId);
}

HRESULT CInprocRecoInst::TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalBuffer, ULONG cbAdditionalBuffer)
{
    return m_pRecognizer->TaskCompletedNotify(pResponse, pvAdditionalBuffer, cbAdditionalBuffer);
}


// ---- SHARED RECO INST IMPLEMENTATION -------------------------------------

HRESULT CSharedRecoInst::FinalConstruct()
{
    SPDBG_FUNC("CSharedRecoInst::FinalConstruct");
    HRESULT hr = S_OK;

    // Create the communicator as an contained aggregate object
    hr = m_cpunkCommunicator.CoCreateInstance(CLSID_SpCommunicator, (ISpCallReceiver*)this);

    if (SUCCEEDED(hr))
    {
        hr = m_cpunkCommunicator->QueryInterface(&m_pCommunicator);
    }

    if (SUCCEEDED(hr))
    {
        m_pCommunicator->Release();
    }

    // Create the resource manager, and get the reco master from it
    if (SUCCEEDED(hr))
    {
        hr = m_cpResMgr.CoCreateInstance(CLSID_SpResourceManager);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpResMgr->GetObject(CLSID__SpRecoMaster, CLSID__SpRecoMaster, __uuidof(m_cpRecoMaster),
                                   TRUE, (void **)&m_cpRecoMaster);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpRecoMaster->AddRecoInst(this, TRUE, &m_pRecoMaster);
    }

    if (FAILED(hr))
    {
        m_cpRecoMaster.Release();  
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

void CSharedRecoInst::FinalRelease()
{
    CRecoInst::FinalRelease();
    m_cpunkCommunicator.Release();
}

HRESULT CSharedRecoInst::EventNotify(SPRECOCONTEXTHANDLE hContext, const SPSERIALIZEDEVENT64 * pEvent, ULONG cbSerializedSize)
{
    SPDBG_FUNC("CSharedRecoInst::EventNotify");
    HRESULT hr = S_OK;

    ULONG cbData = sizeof(SHAREDRECO_EVENT_NOTIFY_DATA) + cbSerializedSize;
    SHAREDRECO_EVENT_NOTIFY_DATA * pdata = 
        (SHAREDRECO_EVENT_NOTIFY_DATA*)new BYTE[cbData];
    
    if (pdata == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        pdata->cbSerializedSize = cbSerializedSize;
        pdata->hContext = hContext;
        memcpy((BYTE*)pdata + sizeof(*pdata), pEvent, cbSerializedSize);

        hr = m_pCommunicator->SendCall(
                SHAREDRECO_EVENT_NOTIFY_METHOD,
                pdata,
                cbData,
                FALSE,
                NULL,
                NULL);
    }

    if (pdata)
    {
        delete pdata;
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSharedRecoInst::RecognitionNotify(SPRECOCONTEXTHANDLE hContext, SPRESULTHEADER *pCoMemPhraseNowOwnedByCtxt, WPARAM wParamEvent, SPEVENTENUM eEventId)
{
    SPDBG_FUNC("CSharedRecoInst::RecognitionNotify");
    HRESULT hr = S_OK;

    ULONG cbData = sizeof(SHAREDRECO_RECO_NOTIFY_DATA) + pCoMemPhraseNowOwnedByCtxt->ulSerializedSize;
    SHAREDRECO_RECO_NOTIFY_DATA * pdata = 
        (SHAREDRECO_RECO_NOTIFY_DATA*)new BYTE[cbData];
    
    if (pdata == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        pdata->hContext = hContext;
        pdata->wParamEvent = wParamEvent;
        pdata->eEventId = eEventId;
        memcpy(
            (BYTE*)pdata + sizeof(*pdata), 
            pCoMemPhraseNowOwnedByCtxt, 
            pCoMemPhraseNowOwnedByCtxt->ulSerializedSize);

        hr = m_pCommunicator->SendCall(
                SHAREDRECO_RECO_NOTIFY_METHOD,
                pdata,
                cbData,
                FALSE,
                NULL,
                NULL);
    }

    if (pdata)
    {
        delete pdata;
    }

    ::CoTaskMemFree(pCoMemPhraseNowOwnedByCtxt);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSharedRecoInst::TaskCompletedNotify(const ENGINETASKRESPONSE *pResponse, const void * pvAdditionalData, ULONG cbAdditionalData)
{
    SPDBG_FUNC("CSharedRecoInst::TaskCompletedNotify");
    HRESULT hr = S_OK;

    if (cbAdditionalData == 0)
    {
        hr = m_pCommunicator->SendCall(
                SHAREDRECO_TASK_COMPLETED_NOTIFY_METHOD,
                const_cast<ENGINETASKRESPONSE *>(pResponse),
                sizeof(*pResponse),
                FALSE,
                NULL,
                NULL);
    }
    else
    {
        ULONG cb = sizeof(*pResponse) + cbAdditionalData;
        void * pBuffer = ::CoTaskMemAlloc(cb);
        if (pBuffer)
        {
            memcpy(pBuffer, pResponse, sizeof(*pResponse));
            memcpy(((BYTE *)pBuffer) + sizeof(*pResponse), pvAdditionalData, cbAdditionalData);
            hr = m_pCommunicator->SendCall(
                    SHAREDRECO_TASK_COMPLETED_NOTIFY_METHOD,
                    pBuffer,
                    cb,
                    FALSE,
                    NULL,
                    NULL);
            ::CoTaskMemFree(pBuffer);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

STDMETHODIMP CSharedRecoInst::ReceiveCall(
    DWORD dwMethodId,
    PVOID pvData,
    ULONG cbData,
    PVOID * ppvDataReturn,
    ULONG * pcbDataReturn)
{
    SPDBG_FUNC("CSharedRecoInst::ReceiveCall");
    HRESULT hr = S_OK;

    switch (dwMethodId)
    {
        case SHAREDRECO_PERFORM_TASK_METHOD:
            hr = ReceivePerformTask(pvData, cbData, ppvDataReturn, pcbDataReturn);
            break;

        default:
            hr = E_FAIL;
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

HRESULT CSharedRecoInst::ReceivePerformTask(
    PVOID pvData,
    ULONG cbData,
    PVOID * ppvDataReturn,
    ULONG * pcbDataReturn)
{
    SPDBG_FUNC("CSharedRecoInst::ReceivePerformTask");
    HRESULT hr = S_OK;

    SHAREDRECO_PERFORM_TASK_DATA * pdata = 
        (SHAREDRECO_PERFORM_TASK_DATA*)pvData;

    if (cbData < sizeof(SHAREDRECO_PERFORM_TASK_DATA) ||
        cbData != sizeof(SHAREDRECO_PERFORM_TASK_DATA) + pdata->task.cbAdditionalBuffer)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        if (pdata->task.cbAdditionalBuffer > 0)
        {
            pdata->task.pvAdditionalBuffer = 
                LPBYTE(pdata) + sizeof(SHAREDRECO_PERFORM_TASK_DATA);
        }
        
        hr = PerformTask(&pdata->task);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srgrammar.h ===
/*******************************************************************************
* SrGrammr.h *
*------------*
*   Description:
*       This is the header file for the CRecoGrammar implementation.  This object
*   is created by the Recognizer object and is not directly CoCreate-able
*-------------------------------------------------------------------------------
*  Created By: RAL                              Date: 01/17/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#ifndef SrGrammar_h
#define SrGrammar_h

class ATL_NO_VTABLE CSpeechGrammarRules;

/////////////////////////////////////////////////////////////////////////////
// CRecoGrammar

typedef CComObject<CRecoGrammar> CRecoGrammarObject;

/****************************************************************************
*
* CRecoGrammar
*
********************************************************************** RAL */

class ATL_NO_VTABLE CRecoGrammar : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public CBaseGrammar,
    public ISpRecoGrammar
    //--- Automation
    #ifdef SAPI_AUTOMATION
    , public IDispatchImpl<ISpeechRecoGrammar, &IID_ISpeechRecoGrammar, &LIBID_SpeechLib, 5>
    #endif
{
public:
    CRecoCtxt *                 m_pParent;
    ULONGLONG                   m_ullGrammarId;
    SPGRAMMARHANDLE             m_hRecoInstGrammar;
    CSpAutoEvent                m_autohPendingEvent;
    BOOL                        m_fCmdLoaded;
    BOOL                        m_fProprietaryCmd;
    SPRULESTATE                 m_DictationState;
    SPGRAMMARSTATE              m_GrammarState;

    CSpeechGrammarRules *       m_pCRulesWeak; // For automation

    CComPtr<ISpGramCompBackendPrivate> m_cpCompiler;

    DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRecoGrammar)
    COM_INTERFACE_ENTRY(ISpRecoGrammar)
    COM_INTERFACE_ENTRY(ISpGrammarBuilder)
#ifdef SAPI_AUTOMATION
    COM_INTERFACE_ENTRY(ISpeechRecoGrammar)
    COM_INTERFACE_ENTRY(IDispatch)
#endif // SAPI_AUTOMATION

END_COM_MAP()

    CRecoGrammar();
    ~CRecoGrammar();

    HRESULT FinalConstruct();
    HRESULT Init(CRecoCtxt * pParent, ULONGLONG ullGrammarId);

    HRESULT InternalLoadCmdFromMemory(const SPBINARYGRAMMAR * pBinaryData, SPLOADOPTIONS Options, const WCHAR *pszFileName);
    HRESULT InternalSetTextSel(ENGINETASKENUM EngineTask, const WCHAR * pText, ULONG cchText, const SPTEXTSELECTIONINFO * pInfo);
    HRESULT InternalSetRuleState(const WCHAR * pszRuleName, void * pReserved, DWORD dwRuleId, SPRULESTATE NewState);
    inline HRESULT InitCompilerBackend();
    HRESULT UnloadCmd();

    HRESULT CallEngine(ENGINETASK * pTask);

    ULONGLONG GrammarId()
    {
        return m_ullGrammarId;
    }

    HANDLE EventHandle()
    {
        return m_autohPendingEvent;
    }

    _ISpRecognizerBackDoor * Recognizer()
    {
        return m_pParent->m_cpRecognizer;
    }


public:

#ifdef SAPI_AUTOMATION

    // Helper routine
    HRESULT DefaultToDynamicGrammar();

    //--- ISpeechRecoGrammar -----------------------------------------------------
    STDMETHODIMP get_Id( VARIANT* pId );
    STDMETHODIMP get_RecoContext( ISpeechRecoContext** RecoCtxt );
    STDMETHODIMP put_State( SpeechGrammarState eGrammarState );
    STDMETHODIMP get_State( SpeechGrammarState* peGrammarState);
    STDMETHODIMP get_Rules( ISpeechGrammarRules** ppGrammarRules);
    STDMETHODIMP Reset(SpeechLanguageId NewLanguage);
    STDMETHODIMP CmdLoadFromFile( const BSTR FileName, SpeechLoadOption LoadOption );
    STDMETHODIMP CmdLoadFromObject(const BSTR ClassId,
                                   const BSTR GrammarName,
                                   SpeechLoadOption LoadOption );
    STDMETHODIMP CmdLoadFromResource(long hModule,
                                     VARIANT ResourceName,
                                     VARIANT ResourceType,
                                     SpeechLanguageId LanguageId,
                                     SpeechLoadOption LoadOption );
    STDMETHODIMP CmdLoadFromMemory( VARIANT GrammarData, SpeechLoadOption LoadOption );
    STDMETHODIMP CmdLoadFromProprietaryGrammar(const BSTR ProprietaryGuid,
                                               const BSTR ProprietaryString,
                                               VARIANT ProprietaryData,
                                               SpeechLoadOption LoadOption);
    STDMETHODIMP CmdSetRuleState( const BSTR Name, SpeechRuleState State );
    STDMETHODIMP CmdSetRuleIdState( long lRuleId, SpeechRuleState State );
    STDMETHODIMP DictationLoad( const BSTR TopicName, SpeechLoadOption LoadOption );
    STDMETHODIMP DictationUnload( void );
    STDMETHODIMP DictationSetState( SpeechRuleState State );
    STDMETHODIMP SetWordSequenceData( const BSTR Text, long TextLen, ISpeechTextSelectionInformation* Info );
    STDMETHODIMP SetTextSelection( ISpeechTextSelectionInformation* Info );
    STDMETHODIMP IsPronounceable( const BSTR Word, SpeechWordPronounceable *pWordPronounceable );
#endif // SAPI_AUTOMATION

// ISpGrammarBuilder
    STDMETHODIMP ResetGrammar(
                        LANGID NewLanguage);
    STDMETHODIMP GetRule(
                        const WCHAR * pszName, DWORD dwRuleId, DWORD dwAttributes,
                        BOOL fCreateIfNotExist, SPSTATEHANDLE * phInitialState);
    STDMETHODIMP ClearRule(SPSTATEHANDLE hState);
    STDMETHODIMP CreateNewState(
                        SPSTATEHANDLE hState, SPSTATEHANDLE * phState)
    {
        SPAUTO_OBJ_LOCK;
        return (m_cpCompiler) ? m_cpCompiler->CreateNewState(hState, phState) : SPERR_NOT_DYNAMIC_GRAMMAR;
    }
                        
    STDMETHODIMP AddWordTransition(
                        SPSTATEHANDLE hFromState,
                        SPSTATEHANDLE hToState,
                        const WCHAR * psz,           // if NULL then SPEPSILONTRANS
                        const WCHAR * pszSeparators, // if NULL then psz contains single word
                        SPGRAMMARWORDTYPE eWordType,
                        float flWeight,
                        const SPPROPERTYINFO * pPropInfo)
    {
        SPAUTO_OBJ_LOCK;
        return (m_cpCompiler) ? m_cpCompiler->AddWordTransition(hFromState, hToState,
                                    psz, pszSeparators, eWordType, flWeight, pPropInfo) : SPERR_NOT_DYNAMIC_GRAMMAR;
    }
    STDMETHODIMP AddRuleTransition(
                        SPSTATEHANDLE hFromState,
                        SPSTATEHANDLE hToState,
                        SPSTATEHANDLE hRule,        // must be initial state of rule
                        float flWeight,
                        const SPPROPERTYINFO * pPropInfo)
    {
        SPAUTO_OBJ_LOCK;
        return (m_cpCompiler) ? m_cpCompiler->AddRuleTransition(hFromState, hToState,
                                    hRule, flWeight, pPropInfo) : SPERR_NOT_DYNAMIC_GRAMMAR;
    }
    STDMETHODIMP AddResource(
                        SPSTATEHANDLE hRuleState,
                        const WCHAR * pszResourceName,
                        const WCHAR * pszResourceValue)
    {
        SPAUTO_OBJ_LOCK;
        return (m_cpCompiler) ? m_cpCompiler->AddResource(hRuleState, pszResourceName, pszResourceValue) : SPERR_NOT_DYNAMIC_GRAMMAR;
    }

    STDMETHODIMP Commit(DWORD dwReserved);


    STDMETHODIMP GetGrammarId(ULONGLONG * pullGrammarId);
    STDMETHODIMP GetRecoContext(ISpRecoContext **ppRecoCtxt);

    // Command and control interfaces
    STDMETHODIMP LoadCmdFromFile( const WCHAR * pszFileName, SPLOADOPTIONS Options);
    STDMETHODIMP LoadCmdFromObject(REFCLSID rcid,  const WCHAR * pszGrammarName, SPLOADOPTIONS Options);
    STDMETHODIMP LoadCmdFromResource(HMODULE hModule,
                                 const WCHAR * pszResourceName,
                                 const WCHAR * pszResourceType,
                                 WORD wLanguage,
                                 SPLOADOPTIONS Options);
    STDMETHODIMP LoadCmdFromMemory(const SPBINARYGRAMMAR * pBinaryData, SPLOADOPTIONS Options);
    STDMETHODIMP LoadCmdFromProprietaryGrammar(REFGUID rguidParam,
                                               const WCHAR * pszStringParam,
                                               const void * pvDataPrarm,
                                               ULONG cbDataSize,
                                               SPLOADOPTIONS Options);
    STDMETHODIMP SetRuleState( const WCHAR * pszName, void * pReserved,
                               SPRULESTATE NewState);
    STDMETHODIMP SetRuleIdState(ULONG ulRuleId, SPRULESTATE NewState);

    // Dictation / statistical language model
    STDMETHODIMP LoadDictation(const WCHAR * pszTopicName, SPLOADOPTIONS Options);
    STDMETHODIMP UnloadDictation();
    STDMETHODIMP SetDictationState(SPRULESTATE NewState);

    // Word sequence buffer
    STDMETHODIMP SetWordSequenceData(const WCHAR * pText, ULONG cchText, const SPTEXTSELECTIONINFO * pInfo);
    STDMETHODIMP SetTextSelection(const SPTEXTSELECTIONINFO * pInfo);

	STDMETHODIMP IsPronounceable( const WCHAR * pszWord, SPWORDPRONOUNCEABLE *pWordPronounceable);
    STDMETHODIMP SetGrammarState(SPGRAMMARSTATE eGrammarState);
    STDMETHODIMP SaveCmd(IStream * pSaveStream, WCHAR ** ppCoMemErrorText);
    STDMETHODIMP GetGrammarState(SPGRAMMARSTATE * peGrammarState);
};

#endif  // #ifndef SrGrammar_h -- Must be the last line of the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecoinstctxt.cpp ===
/*******************************************************************************
* SrRecoInstCtxt.cpp *
*--------------------*
*   Description:
*       Implementation of C++ object used by CRecoEngine to represent a loaded
*   recognition context.
*-------------------------------------------------------------------------------
*  Created By: RAL                              Date: 01/17/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/


#include "stdafx.h"
#include "srrecomaster.h"
#include "srrecoinstctxt.h"
#include "srrecoinstgrammar.h"


/****************************************************************************
* CRecoInstCtxt::CRecoInstCtxt *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRecoInstCtxt::CRecoInstCtxt(CRecoInst * pRecoInst) :
    m_pRecoMaster(NULL),
    m_pRecoInst(pRecoInst),
    m_pvDrvCtxt(NULL),
    m_ullEventInterest(0),
    m_fRetainAudio(false),
    m_ulMaxAlternates(0),
    m_hUnloadEvent(NULL),
    m_hThis(NULL),
    m_cPause(0),
    m_State(SPCS_ENABLED),
    m_hrCreation(S_OK)
{
}


/****************************************************************************
* CRecoInstCtxt::~CRecoInstCtxt *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRecoInstCtxt::~CRecoInstCtxt()
{
    if (m_pRecoMaster)  // If this is set to NULL, then we never succeeded in telling the
    {               // driver about the creation, so don't call OnDelete()    
        SetRetainAudio(FALSE);

        HRESULT hr = m_pRecoMaster->OnDeleteRecoContext(m_pvDrvCtxt);

        m_pRecoMaster->m_cPause -= m_cPause;

        m_pRecoMaster->m_PendingTaskQueue.FindAndDeleteAll(m_hThis);
        m_pRecoMaster->m_CompletedTaskQueue.FindAndDeleteAll(m_hThis);
        m_pRecoMaster->m_DelayedTaskQueue.FindAndDeleteAll(m_hThis);
        m_pRecoMaster->m_EventQueue.FindAndDeleteAll(m_hThis);

        m_pRecoMaster->UpdateAudioEventInterest();

        SPDBG_ASSERT(SUCCEEDED(hr));
    }
}

/****************************************************************************
* CRecoInstCtxt::ExecuteTask *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstCtxt::ExecuteTask(ENGINETASK *pTask)
{
    SPDBG_FUNC("CRecoInstCtxt::ExecuteTask");
    HRESULT hr = S_OK;

    switch (pTask->eTask)
    {
    EXEC_RECO_CTXT_TASK(PAUSECONTEXT)
    EXEC_RECO_CTXT_TASK(RESUMECONTEXT)
    EXEC_RECO_CTXT_TASK(BOOKMARK)
    EXEC_RECO_CTXT_TASK(CALLENGINE)
    EXEC_RECO_CTXT_TASK(CALLENGINEEX)
    EXEC_RECO_CTXT_TASK(DELETECONTEXT)
    EXEC_RECO_CTXT_TASK(SETEVENTINTEREST)
    EXEC_RECO_CTXT_TASK(SETMAXALTERNATES)
    EXEC_RECO_CTXT_TASK(SETRETAINAUDIO)
    EXEC_RECO_CTXT_TASK(ADAPTATIONDATA)
    EXEC_RECO_CTXT_TASK(CREATEGRAMMAR)
    EXEC_RECO_CTXT_TASK(SETCONTEXTSTATE)

    default:
        SPDBG_ASSERT(FALSE);
        hr = E_INVALIDARG;
        break;
    }


    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInstCtxt::BackOutTask *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstCtxt::BackOutTask(ENGINETASK * pTask)
{
    SPDBG_FUNC("CRecoInstCtxt::BackOutTask");
    HRESULT hr = S_OK;

    switch (pTask->eTask)
    {
    BACK_OUT_RECO_CTXT_TASK(RESUMECONTEXT)
    BACK_OUT_RECO_CTXT_TASK(SETCONTEXTSTATE)

    default:
        SPDBG_ASSERT(FALSE);
        hr = E_INVALIDARG;
        break;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoInstCtxt::SetRetainAudio *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstCtxt::SetRetainAudio(BOOL fRetainAudio)
{
    SPDBG_FUNC("CRecoInstCtxt::SetRetainAudio");
    HRESULT hr = S_OK;

    if ((m_fRetainAudio && (!fRetainAudio)) ||
        ((!m_fRetainAudio) && fRetainAudio))
    {
        m_fRetainAudio = fRetainAudio;
        if (fRetainAudio)
        {
            m_pRecoMaster->m_AudioQueue.AddRefBufferClient();
        }
        else
        {
            m_pRecoMaster->m_AudioQueue.ReleaseBufferClient();
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecoinstctxt.h ===
/*******************************************************************************
* SrRecoInstCtxt.h *
*------------------*
*   Description:
*       Definition of C++ object used by CRecoEngine to represent a loaded
*   recognition context.
*-------------------------------------------------------------------------------
*  Created By: RAL                              Date: 01/17/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#ifndef CRecoInstCtxt_h
#define CRecoInstCtxt_h

#include "srrecoinstgrammar.h"

class CRecoInst;
class CRecoInstCtxt; 
class CRecoMaster;

typedef CSpHandleTable<CRecoInstCtxt, SPRECOCONTEXTHANDLE> CRecoInstCtxtHandleTable;

class CRecoInstCtxt
{
public: // All public so tasks can access members
    CRecoMaster         *   m_pRecoMaster;
    CRecoInst           *   m_pRecoInst;    
    void                *   m_pvDrvCtxt;
    ULONGLONG               m_ullEventInterest;
    HANDLE                  m_hUnloadEvent;
    BOOL                    m_fRetainAudio;
    ULONG                   m_ulMaxAlternates;
    SPRECOCONTEXTHANDLE     m_hThis;    // Handle for this reco context
    ULONG                   m_cPause;
    SPCONTEXTSTATE          m_State;
    HRESULT                 m_hrCreation; // This will be S_OK until OnCreateRecoContext has been called


public:
    CRecoInstCtxt(CRecoInst * pRecoInst);
    ~CRecoInstCtxt();

    HRESULT ExecuteTask(ENGINETASK *pTask);
    HRESULT BackOutTask(ENGINETASK *pTask);
    HRESULT SetRetainAudio(BOOL fRetainAudio);
    HRESULT SetMaxAlternates(ULONG cMaxAlternates);

    //
    //  Used by handle table implementation to find contexts associated with a specific instance
    //  
    operator ==(const CRecoInst * pRecoInst)
    {
        return m_pRecoInst == pRecoInst;
    }
};


#endif  // #ifndef CRecoInstCtxt_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecoinstgrammar.cpp ===
/*******************************************************************************
* SrRecoInstGrammar.cpp *
*-----------------------*
*   Description:
*       Implementation of C++ object used by CRecoEngine to represent a loaded grammar.
*-------------------------------------------------------------------------------
*  Created By: RAL                              Date: 01/17/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#include "stdafx.h"
#include "recognizer.h"
#include "SrRecoInst.h"
#include "srrecoinstgrammar.h"
#include "srrecomaster.h"


/****************************************************************************
* CRecoInstGrammar::AddActiveRules *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void inline CRecoInstGrammar::AddActiveRules(ULONG cRules)
{
    m_ulActiveCount += cRules;
    if (m_fRulesCounted)
    {
        m_pRecoMaster->m_Status.ulNumActive += cRules;
    }
}

/****************************************************************************
* CRecoInstGrammar::SubtractActiveRules *
*---------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void inline CRecoInstGrammar::SubtractActiveRules(ULONG cRules)
{
    m_ulActiveCount -= cRules;
    if (m_fRulesCounted)
    {
        m_pRecoMaster->m_Status.ulNumActive -= cRules;
    }
}


/****************************************************************************
* CRecoInstGrammar::UpdateCFGState *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::UpdateCFGState()
{
    HRESULT hr = S_OK;
    SPDBG_FUNC("CRecoInstGrammar::UpdateCFGState");

    // If another grammar is exclusive then disable this CFG
    if (!m_fRulesCounted && m_cpCFGGrammar)
    {
        hr = m_cpCFGGrammar->SetGrammarState(SPGS_DISABLED);
    }

    // Now see if this CFG has some dictation tags. If so we want to make sure dictation is loaded
    ULONG ulDictationTags = 0;
    if(SUCCEEDED(hr) && m_cpCFGGrammar)
    {
        hr = m_cpCFGGrammar->GetNumberDictationTags(&ulDictationTags);
        if(SUCCEEDED(hr) && ulDictationTags && !m_fDictationLoaded)
        {
            hr = m_pRecoMaster->LoadSLM(m_pvDrvGrammarCookie, NULL);
            if (SUCCEEDED(hr))
            {
                m_fDictationLoaded = TRUE;
            }
        }
    }

    // Now see if we're in a state where neither the app nor the grammar want dictation loaded
    if(m_fDictationLoaded && !m_fAppLoadedDictation
        && ulDictationTags == 0)
    {
        UnloadDictation(); // Ignore HRESULT as we are only unloading
    }

    // Reset the grammar state if we failed
    if(FAILED(hr))
    {
        UnloadCmd(); 
    }

    return hr;
}

/****************************************************************************
* CRecoInstGrammar::CFGEngine *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline ISpCFGEngine * CRecoInstGrammar::CFGEngine()
{
    return m_pRecoMaster->m_cpCFGEngine;
}


/****************************************************************************
* CRecoInstGrammar::CRecoInstGrammar *
*------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRecoInstGrammar::CRecoInstGrammar(CRecoInstCtxt * pCtxt, ULONGLONG ullApplicationGrammarId)
{
    SPDBG_FUNC("CRecoInstGrammar::CRecoInstGrammar");
    
    m_pRecoMaster = NULL; // Initialized when successfully created
    m_pRecoInst = pCtxt->m_pRecoInst;
    m_pCtxt = pCtxt;
    m_pvDrvGrammarCookie = NULL;
    m_ulActiveCount = 0;
    m_DictationState = SPRS_INACTIVE;
    m_fDictationLoaded = FALSE;
    m_fAppLoadedDictation = FALSE;
    m_fProprietaryLoaded = FALSE;
    m_fRulesCounted = TRUE;
    m_GrammarState = SPGS_ENABLED;
    m_hThis = NULL;
    m_ullApplicationGrammarId = ullApplicationGrammarId;
    m_hrCreation = S_OK;
}

/****************************************************************************
* CRecoInstGrammar::~CRecoInstGrammar *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRecoInstGrammar::~CRecoInstGrammar()
{
    SPDBG_FUNC("CRecoInstGrammar::~CRecoInstGrammar");

    if (m_pRecoMaster)
    {
        m_pRecoMaster->SetGrammarState(this, SPGS_DISABLED);
        UnloadCmd();
        UnloadDictation();
        SetWordSequenceData(NULL, 0, NULL);
        m_pRecoMaster->OnDeleteGrammar(m_pvDrvGrammarCookie);

        m_pRecoMaster->m_PendingTaskQueue.FindAndDeleteAll(m_hThis);
        m_pRecoMaster->m_DelayedTaskQueue.FindAndDeleteAll(m_hThis);
        // NOTE:  Do NOT remove completed events here since there could be an
        // auto-pause result which needs to get to the reco context.
    }
}


/****************************************************************************
* CRecoInstGrammar::ExecuteTask *
*-------------------------------*
*   Description:
*       This method is called by the CRecoEngine object when a task for a grammar
*   is received.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::ExecuteTask(ENGINETASK *pTask)
{
    SPDBG_FUNC("CRecoInstGrammar::ExecuteTask");
    HRESULT hr = S_OK;
    const WCHAR * psz;

    switch (pTask->eTask)
    {
        case EGT_LOADDICTATION:
            if(m_fDictationLoaded)
            {
                // This unloads the current dictation in case we want to switch to a different topic or if 
                //  the CFG contained dictation tags and the app wants to use a different topic to the default.
                // This function could be cleverer and only reload if the topic name changed.
                hr = UnloadDictation();
            }
            if(SUCCEEDED(hr) && !m_fDictationLoaded)
            {
                psz = &pTask->szTopicName[0];   // if not empty, then pass it otherwise NULL
                hr = m_pRecoMaster->LoadSLM(m_pvDrvGrammarCookie, (*psz ? psz : NULL));

                if (SUCCEEDED(hr))
                {
                    m_fDictationLoaded = TRUE;
                    m_fAppLoadedDictation = TRUE;
                }
            }
            break;

        case EGT_UNLOADDICTATION:
            if(m_fDictationLoaded)
            {
                ULONG ulDictationTags = 0;
                // See if the CFG has some dictation tags, in which case we shouldn't unload
                if(m_cpCFGGrammar)
                {
                    hr = m_cpCFGGrammar->GetNumberDictationTags(&ulDictationTags);
                }
                if(SUCCEEDED(hr) && ulDictationTags == 0)
                {
                    hr = UnloadDictation();
                }
            }
            
            if(SUCCEEDED(hr))
            {
                m_fAppLoadedDictation = FALSE;
            }
            break;

        case EGT_LOADCMDPROPRIETARY:
            UnloadCmd();
            psz = &pTask->szStringParam[0]; // if not empty, then pass it otherwise NULL

            hr = m_pRecoMaster->LoadProprietaryGrammar(m_pvDrvGrammarCookie, pTask->guid,
                                                    (*psz ? psz : NULL),
                                                    pTask->pvAdditionalBuffer, pTask->cbAdditionalBuffer,
                                                    SPLO_STATIC);

            if (SUCCEEDED(hr))
            {
                hr = UpdateCFGState(); // So that dictation gets unloaded if needed
            }
            if (SUCCEEDED(hr))
            {
                m_fProprietaryLoaded = TRUE;
            }
            break;

        case EGT_LOADCMDFROMMEMORY:
            UnloadCmd();
            hr = CFGEngine()->LoadGrammarFromMemory((const SPBINARYGRAMMAR *)pTask->pvAdditionalBuffer, this->m_hThis, m_pvDrvGrammarCookie, &m_cpCFGGrammar, pTask->szFileName);
            if(SUCCEEDED(hr))
            {
                hr = UpdateCFGState();
            }
            break;

        case EGT_LOADCMDFROMFILE:
            UnloadCmd();
            hr = CFGEngine()->LoadGrammarFromFile(pTask->szFileName, this->m_hThis, m_pvDrvGrammarCookie, &m_cpCFGGrammar);
            if(SUCCEEDED(hr))
            {
                hr = UpdateCFGState();
            }
            break;

        case EGT_LOADCMDFROMOBJECT:
            UnloadCmd();
            hr = CFGEngine()->LoadGrammarFromObject(pTask->clsid, pTask->szGrammarName,
                                                      this->m_hThis, m_pvDrvGrammarCookie, &m_cpCFGGrammar);
            if(SUCCEEDED(hr))
            {
                hr = UpdateCFGState();
            }
            break;

        case EGT_UNLOADCMD:
            UnloadCmd();
            UpdateCFGState();
            hr = S_OK;
            break;

        case EGT_LOADCMDFROMRSRC:
            {
                UnloadCmd();
                const WCHAR *pszName = pTask->fResourceNameValid ?
                                                &pTask->szResourceName[0] :
                                                MAKEINTRESOURCEW(pTask->dwNameInt);
                const WCHAR *pszType = pTask->fResourceTypeValid ?
                                                &pTask->szResourceType[0] :
                                                MAKEINTRESOURCEW(pTask->dwTypeInt);
                hr = CFGEngine()->LoadGrammarFromResource(pTask->szModuleName, pszName, pszType, pTask->wLanguage,
                                                            this->m_hThis, m_pvDrvGrammarCookie, &m_cpCFGGrammar);
                if(SUCCEEDED(hr))
                {
                    hr = UpdateCFGState();
                }
            }
            break;

        case EGT_RELOADCMD:
            if (m_cpCFGGrammar)
            {
                hr = m_cpCFGGrammar->Reload((SPBINARYGRAMMAR *)pTask->pvAdditionalBuffer);
                if(SUCCEEDED(hr))
                {
                    UpdateCFGState();
                }
            }
            else
            {
                hr = SPERR_UNINITIALIZED;
            }
            break;

        case EGT_SETCMDRULESTATE:
            {
                psz = &pTask->szRuleName[0];   // if not empty, then pass it otherwise NULL
                if (*psz == 0)
                {
                    psz = NULL;
                }
                if (pTask->RuleState == SPRS_INACTIVE)
                {
                    hr = DeactivateRule(psz, NULL, pTask->dwRuleId);
                }
                else
                {
                    hr = ActivateRule(psz, NULL, pTask->dwRuleId, pTask->RuleState);
                }
                return hr;
            }

        case EGT_SETGRAMMARSTATE:
            hr = this->m_pRecoMaster->SetGrammarState(this, pTask->eGrammarState);
            break;

        case EGT_SETDICTATIONRULESTATE:
            SPDBG_ASSERT(pTask->RuleState != m_DictationState);

            if(pTask->RuleState != SPRS_INACTIVE && !m_fDictationLoaded)
            {
                hr = m_pRecoMaster->LoadSLM(m_pvDrvGrammarCookie, NULL);

                if (SUCCEEDED(hr))
                {
                    m_fDictationLoaded = TRUE;
                    m_fAppLoadedDictation = TRUE;
                }
            }

            if (m_fRulesCounted)
            {
                hr = m_pRecoMaster->SetSLMState(m_pvDrvGrammarCookie, pTask->RuleState);
            }

            if (SUCCEEDED(hr))
            {
                // Note:  This logic is correct in checking for explicit transitions to/from INACTIVE
                // since we could transition from ACTIVE to ACTIVE_WITH_AUTO_PAUSE which should not
                // add or subtract one from the active rules.
                if (m_DictationState == SPRS_INACTIVE)
                {
                    AddActiveRules(1);
                }
                else
                {
                    if (pTask->RuleState == SPRS_INACTIVE)
                    {
                        SubtractActiveRules(1);
                    }
                }
                m_DictationState = pTask->RuleState;
            }
            break;

		case EGT_ISPRON:
            hr = m_pRecoMaster->IsPronounceable(m_pvDrvGrammarCookie, pTask->szWord, &(pTask->Response.WordPronounceable));
            break;

        case EGT_SETWORDSEQUENCEDATA:
            hr = m_pRecoMaster->SetWordSequenceData(m_pvDrvGrammarCookie, (const WCHAR *)pTask->pvAdditionalBuffer, pTask->cbAdditionalBuffer / sizeof(WCHAR),
                                               pTask->fSelInfoValid ? &pTask->TextSelInfo : NULL);
            break;

        case EGT_SETTEXTSELECTION:
            hr = m_pRecoMaster->SetTextSelection(m_pvDrvGrammarCookie,
                                            pTask->fSelInfoValid ? &pTask->TextSelInfo : NULL);
            break;


        case EGT_DELETEGRAMMAR:
            m_pRecoMaster->m_GrammarHandleTable.Delete(m_hThis);
            return S_OK;    // Just return right here since this is dead!

        default:
            SPDBG_ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInstGrammar::BackOutTask *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::BackOutTask(ENGINETASK * pTask)
{
    SPDBG_FUNC("CRecoInstGrammar::BackOutTask");
    HRESULT hr = S_OK;
    switch (pTask->eTask)
    {
        case EGT_LOADDICTATION:
            UnloadDictation();
            break;


        case EGT_SETCMDRULESTATE:
            {
                WCHAR * psz = &pTask->szRuleName[0];   // if not empty, then pass it otherwise NULL
                if (*psz == 0)
                {
                    psz = NULL;
                }
                hr = DeactivateRule(psz, NULL, pTask->dwRuleId);           
            }
            break;

        case EGT_SETGRAMMARSTATE:
            hr = this->m_pRecoMaster->SetGrammarState(this, SPGS_DISABLED);
            break;

        case EGT_SETDICTATIONRULESTATE:
            if (m_DictationState != SPRS_INACTIVE)
            {
                if (m_fRulesCounted)
                {
                    hr = m_pRecoMaster->SetSLMState(m_pvDrvGrammarCookie, SPRS_INACTIVE);
                }

                m_DictationState = SPRS_INACTIVE;
                SubtractActiveRules(1);
            }
            break;

        default:
            SPDBG_ASSERT(FALSE);
            hr = E_INVALIDARG;
            break;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;

}


/****************************************************************************
* CRecoInstGrammar::UnloadCmd *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::UnloadCmd()
{
    SPDBG_FUNC("CRecoInstGrammar::UnloadCmd");
    HRESULT hr = S_OK;

    DeactivateRule(NULL, NULL, 0);
    if (m_fProprietaryLoaded)
    {
        hr = m_pRecoMaster->UnloadProprietaryGrammar(m_pvDrvGrammarCookie);
        m_fProprietaryLoaded = FALSE;
    }

    if(SUCCEEDED(hr))
    {
        m_cpCFGGrammar.Release();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInstGrammar::UnloadDictation *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::UnloadDictation()
{
    SPDBG_FUNC("CRecoInstGrammar::UnloadDictation");
    HRESULT hr = S_OK;

    if (m_fDictationLoaded)
    {
        if (m_DictationState != SPRS_INACTIVE)
        {
            if (m_fRulesCounted)
            {
                hr = m_pRecoMaster->SetSLMState(m_pvDrvGrammarCookie, SPRS_INACTIVE);
                SPDBG_ASSERT(SUCCEEDED(hr));
            }
            m_DictationState = SPRS_INACTIVE;
            SubtractActiveRules(1);
        }
        hr = m_pRecoMaster->UnloadSLM(m_pvDrvGrammarCookie);

        if(SUCCEEDED(hr))
        {
            m_fDictationLoaded = FALSE;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}





/****************************************************************************
* CRecoInstGrammar::ActivateRule *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::ActivateRule(const WCHAR * pszRuleName, void * pReserved, DWORD dwRuleId, SPRULESTATE NewState)
{
    SPDBG_FUNC("CRecoInstGrammar::ActivateRule");
    HRESULT hr = S_OK;

    ULONG ulRulesChanged = 1;

    if (m_cpCFGGrammar)
    {
        hr = m_cpCFGGrammar->ActivateRule(pszRuleName, dwRuleId, NewState, &ulRulesChanged);
    }
    else
    {
        if (m_fProprietaryLoaded)
        {
            if (dwRuleId)
            {
                hr = m_pRecoMaster->SetProprietaryRuleIdState(m_pvDrvGrammarCookie, dwRuleId, NewState);
                if (hr == S_OK)
                {
                    ulRulesChanged = 1;
                }
            }
            else
            {
                hr = m_pRecoMaster->SetProprietaryRuleState(m_pvDrvGrammarCookie, pszRuleName, pReserved, NewState, &ulRulesChanged);
            }
        }
        else
        {
            hr = SPERR_UNINITIALIZED;
        }
    }
    if (hr == S_OK && ulRulesChanged)
    {
        AddActiveRules(ulRulesChanged);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInstGrammar::DeactivateRule *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::DeactivateRule(const WCHAR * pszRuleName, void * pReserved, DWORD dwRuleId)
{
    SPDBG_FUNC("CRecoInstGrammar::DeactivateRule");
    HRESULT hr = S_OK;
    ULONG ulRulesChanged = 0;

    {
        if (m_cpCFGGrammar)
        {
            hr = m_cpCFGGrammar->DeactivateRule(pszRuleName, dwRuleId, &ulRulesChanged);
        }
        else
        {
            if (m_fProprietaryLoaded)
            {
                if(dwRuleId)
                {
                    hr = m_pRecoMaster->SetProprietaryRuleIdState(m_pvDrvGrammarCookie, dwRuleId, SPRS_INACTIVE);
                }
                else
                {
                    hr = m_pRecoMaster->SetProprietaryRuleState(m_pvDrvGrammarCookie, pszRuleName, pReserved, SPRS_INACTIVE, &ulRulesChanged);
                }

                if (hr == S_OK && dwRuleId)
                {
                    ulRulesChanged = 1;
                }
            }
            else
            {
                hr = SPERR_UNINITIALIZED;
            }
        }
    }
    if (ulRulesChanged)
    {
        SubtractActiveRules(ulRulesChanged);
    }

    if (hr != SPERR_UNINITIALIZED)
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }

    return hr;
}



/****************************************************************************
* CRecoInstGrammar::SetWordSequenceData *
*---------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::SetWordSequenceData(WCHAR * pCoMemText, ULONG cchText, const SPTEXTSELECTIONINFO * pInfo)
{
    SPDBG_FUNC("CRecoInstGrammar::SetWordSequenceData");
    HRESULT hr;

    hr = m_pRecoMaster->SetWordSequenceData(m_pvDrvGrammarCookie, pCoMemText, cchText, pInfo);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInstGrammar::AdjustActiveRuleCount *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoInstGrammar::AdjustActiveRuleCount()
{
    SPDBG_FUNC("CRecoInstGrammar::AdjustActiveRuleCount");
    HRESULT hr = S_OK;
    HRESULT hrEngine = S_OK;

    BOOL fShouldCount = RulesShouldCount();
    if (fShouldCount)
    {
        if (!m_fRulesCounted)
        {
            m_fRulesCounted = true;
            m_pRecoMaster->m_Status.ulNumActive += m_ulActiveCount;
            if (m_cpCFGGrammar)
            {
                hr = m_cpCFGGrammar->SetGrammarState(SPGS_ENABLED);
            }
            if (m_fDictationLoaded && m_DictationState != SPRS_INACTIVE)
            {
                hrEngine = m_pRecoMaster->SetSLMState(m_pvDrvGrammarCookie, m_DictationState);
            }
        }
    }
    else
    {
        if (m_fRulesCounted)
        {
            m_fRulesCounted = false;
            m_pRecoMaster->m_Status.ulNumActive -= m_ulActiveCount;
            if (m_cpCFGGrammar)
            {
                hr = this->m_cpCFGGrammar->SetGrammarState(SPGS_DISABLED);
            }
            if (m_fDictationLoaded && m_DictationState != SPRS_INACTIVE)
            {
                hrEngine = m_pRecoMaster->SetSLMState(m_pvDrvGrammarCookie, SPRS_INACTIVE);
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        hr = hrEngine;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoInstGrammar::RulesShouldCount *
*------------------------------------*
*   Description:
*       A grammars rules should count only if the context state is enabled and
*       either the grammar is exclusive, or there is no exclusive grammar and
*       this grammar is enabled.
*
*   Returns:
*       TRUE if the grammar is in a state such that the grammar rules should 
*       be enabled, otherwise, FALSE.
*
********************************************************************* RAL ***/

BOOL CRecoInstGrammar::RulesShouldCount()
{
    return (m_pCtxt->m_State == SPCS_ENABLED && 
            (m_GrammarState == SPGS_EXCLUSIVE ||
             (m_GrammarState == SPGS_ENABLED && (!m_pRecoMaster->IsActiveExclusiveGrammar()))));
}


BOOL CRecoInstGrammar::HasActiveDictation()
{
    return (m_fRulesCounted && m_fDictationLoaded && (m_DictationState != SPRS_INACTIVE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecoinstgrammar.h ===
/*******************************************************************************
* SrRecoInstGrammar.h *
*---------------------*
*   Description:
*       Definition of C++ object used by CRecoEngine to represent a loaded grammar.
*-------------------------------------------------------------------------------
*  Created By: RAL                              Date: 01/17/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#ifndef CRecoInstGrammar_h
#define CRecoInstGrammar_h

#include "HandleTable.h"


class   CRecoInst;
class   CRecoInstCtxt;
class   CRecoInstGrammar;
class   CRecoMaster;

typedef CSpHandleTable<CRecoInstGrammar, SPGRAMMARHANDLE> CRecoInstGrammarHandleTable;


class CRecoInstGrammar
{
    friend CRecoInst;
    friend CRecoInstCtxt;
    friend CRecoMaster;

public:
    CRecoMaster              *  m_pRecoMaster;
    CRecoInstCtxt            *  m_pCtxt;
    CRecoInst                *  m_pRecoInst;
    CComPtr<ISpCFGGrammar>      m_cpCFGGrammar;
    void                     *  m_pvDrvGrammarCookie;
    ULONG                       m_ulActiveCount;
    SPRULESTATE                 m_DictationState;
    BOOL                        m_fDictationLoaded; // If true, engine has loaded dictation
    BOOL                        m_fAppLoadedDictation; // Has the app given a specific LoadDictation command
    BOOL                        m_fProprietaryLoaded;
    BOOL                        m_fRulesCounted;    // If true then m_ulActiveCount plus m_DictationState
                                                    // are added to the reco master's active count.
    SPGRAMMARSTATE              m_GrammarState;     // Current state of this grammar.
    SPGRAMMARHANDLE             m_hThis;            // Handle to self
    ULONGLONG                   m_ullApplicationGrammarId;
    HRESULT                     m_hrCreation;       // This will be S_OK until OnCreateRecoContext has been called

public:
    CRecoInstGrammar(CRecoInstCtxt * pCtxt, ULONGLONG ullApplicationGrammarId);
    ~CRecoInstGrammar();

    inline ISpCFGEngine * CFGEngine();

    HRESULT ActivateRule(const WCHAR * pszRuleName, void * pReserved, DWORD dwRuleId, SPRULESTATE NewState);
    HRESULT DeactivateRule(const WCHAR * pszRuleName, void * pReserved, DWORD dwRuleId);
    HRESULT UnloadCmd();
    HRESULT UnloadDictation();
    HRESULT SetWordSequenceData(WCHAR * pCoMemText, ULONG cchText, const SPTEXTSELECTIONINFO * pInfo);
    HRESULT SetTextSelection(const SPTEXTSELECTIONINFO * pInfo);

    HRESULT ExecuteTask(ENGINETASK *pTask);
    HRESULT BackOutTask(ENGINETASK *pTask);

    HRESULT AdjustActiveRuleCount();
    BOOL HasActiveDictation();

    void inline AddActiveRules(ULONG cRules);
    void inline SubtractActiveRules(ULONG cRules);
    HRESULT UpdateCFGState();

    BOOL    RulesShouldCount();

    //
    //  Used by handle table implementation to find contexts associated with a specific instance
    //  
    operator ==(const CRecoInst * pRecoInst)
    {
        return m_pRecoInst == pRecoInst;
    }
};

#endif  // #ifndef SrRecoInstGrammar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecomaster.cpp ===
/******************************************************************************
* SrRecoMaster.cpp *
*------------------*
*  This is the implementation of CRecoMaster.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#include "stdafx.h"
#include "spphrase.h"
#include "SrRecoMaster.h"
#include "ResultHeader.h"

// Using SP_TRY, SP_EXCEPT exception handling macros
#pragma warning( disable : 4509 )


/****************************************************************************
* CRecoMaster::CRecoMaster *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRecoMaster::CRecoMaster()
{
    SPDBG_FUNC("CRecoMaster::CRecoMaster");
    m_clsidAlternates = GUID_NULL;
    m_fInStream = false;
    m_fInSynchronize = false;
    m_fInFinalRelease = false;
    m_cPause = 0;
    m_fBookmarkPauseInPending = false;
    m_fInSound = false;
    m_fInPhrase = false;
    m_ullLastSyncPos = 0;
    m_ullLastSoundStartPos = 0;
    m_ullLastSoundEndPos = 0;
    m_ullLastPhraseStartPos = 0;
    m_ullLastRecoPos = 0;
    m_RecoState = SPRST_ACTIVE;
    m_fShared = false;
    m_fIsActiveExclusiveGrammar = false;
    ::memset(&m_Status, 0, sizeof(m_Status));
}

/****************************************************************************
* CRecoMaster::FinalConstruct *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::FinalConstruct()
{
    SPDBG_FUNC("CRecoMaster::FinalConstruct");
    HRESULT hr = S_OK;


    CComPtr<ISpTaskManager> cpTaskMgr;

    if (SUCCEEDED(hr))
    {
        hr = m_autohRequestExit.InitEvent(NULL, TRUE, FALSE, NULL);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_cpCFGEngine.CoCreateInstance(CLSID_SpCFGEngine);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpTaskMgr.CoCreateInstance( CLSID_SpResourceManager );
    }
    if (SUCCEEDED(hr))
    {
        hr = cpTaskMgr->CreateThreadControl(this, (void *)TID_IncomingData, THREAD_PRIORITY_NORMAL, &m_cpIncomingThread);
    }
    if (SUCCEEDED(hr))
    {
        m_cpIncomingThread->StartThread(0, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpTaskMgr->CreateThreadControl(this, (void *)TID_OutgoingData, THREAD_PRIORITY_NORMAL, &m_cpOutgoingThread);
    }
    if (SUCCEEDED(hr))
    {
        m_cpOutgoingThread->StartThread(0, NULL);
    }
    if (SUCCEEDED(hr))
    {
        CComObject<CRecoMasterSite> *pSite;

        hr = CComObject<CRecoMasterSite>::CreateInstance(&pSite);
        if (SUCCEEDED(hr))
        {
            m_cpSite = pSite;
            pSite->Init(this);
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_AudioQueue.FinalConstruct(m_cpOutgoingThread);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::FinalRelease *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CRecoMaster::FinalRelease()
{
    SPDBG_FUNC("CRecoMaster::FinalRelease");
    HRESULT hr;

    m_fInFinalRelease = true;
    m_autohRequestExit.SetEvent();
    if(m_fInStream)
    {
        m_AudioQueue.CloseStream();
    }
    m_cpOutgoingThread->WaitForThreadDone(TRUE, NULL, 0); // Bump this thread first

    // Give the task thread some time to exit. Since we won't get here
    // unless all engine pending tasks are completed this should return almost instantly.
    hr = m_cpIncomingThread->WaitForThreadDone(TRUE, NULL, 10000);
    if(hr != S_OK)
    {
        SPDBG_ASSERT(0); // If it doesn't exit then assert.
    }
    
    // Give the notify thread some time to exit. This should
    // be almost instantaneous unless the app is using free-threaded callback
    // and is not returning from the callback.
    hr = m_cpOutgoingThread->WaitForThreadDone(TRUE, NULL, 10000);
    if(hr != S_OK)
    {
        SPDBG_ASSERT(0); // If it doesn't exit then assert.
    }
}


/****************************************************************************
* CRecoMaster::PerformTask *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoMaster::PerformTask(CRecoInst * pSender, ENGINETASK * pTask)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CRecoMaster::PerformTask");
    HRESULT hr = S_OK;

    CSRTask * pTaskNode = new CSRTask();
    if (pTaskNode)
    {
        bool fDelayed = false;
        hr = pTaskNode->Init(pSender, pTask);
        if (SUCCEEDED(hr) && pTaskNode->IsDelayedTask() && pTask->ullStreamPosition > 0 && 
                            (m_fInStream || pTask->ullStreamPosition != SP_STREAMPOS_REALTIME))
        {
            if (pTask->ullStreamPosition == SP_STREAMPOS_REALTIME)
            {
                pTaskNode->m_ullStreamPos = m_AudioQueue.DelayStreamPos();
            }
            else
            {
                pTaskNode->m_ullStreamPos = pTask->ullStreamPosition;
            }
            fDelayed = pTaskNode->m_ullStreamPos > m_Status.ullRecognitionStreamPos;
        }
        //
        //  Now respond immediately to any commands that we want to...
        //
        if (SUCCEEDED(hr) && (fDelayed || (m_fInStream && m_cPause == 0 && (pTaskNode->IsAsyncTask() || (pTaskNode->IsTwoPartAsyncTask() && (!pTaskNode->ChangesOutgoingState() || m_OutgoingWorkCrit.TryLock()))))))
        {
            if(pTaskNode->IsTwoPartAsyncTask())
            {
                hr = pSender->ExecuteFirstPartTask(&pTaskNode->m_Task);

                //  If we took the outgoing thread's critical section then we can release it here
                if (pTaskNode->ChangesOutgoingState())
                {
                    m_OutgoingWorkCrit.Unlock();
                }
            }

            if(SUCCEEDED(hr))
            {
                CSRTask * pResponse;
                hr = pTaskNode->CreateResponse(&pResponse);
                if (SUCCEEDED(hr))
                {
                    this->m_CompletedTaskQueue.InsertTail(pResponse);
                }
            }
        }




        if (SUCCEEDED(hr) && pTaskNode->m_Task.eTask == EIT_SETRECOSTATE && m_fInStream &&
            (pTaskNode->m_Task.NewState == SPRST_INACTIVE || pTaskNode->m_Task.NewState == SPRST_INACTIVE_WITH_PURGE))
        {
            if (pTaskNode->m_Task.NewState == SPRST_INACTIVE)
            {
                m_AudioQueue.PauseStream();
            }
            else  
            {
                SPDBG_ASSERT(pTaskNode->m_Task.NewState == SPRST_INACTIVE_WITH_PURGE);
                m_AudioQueue.StopStream();
                m_autohRequestExit.SetEvent();
            }
        }
        if (SUCCEEDED(hr))
        {
            if (fDelayed)
            {
                m_DelayedTaskQueue.InsertSorted(pTaskNode);
            }
            else
            {
                m_PendingTaskQueue.InsertTail(pTaskNode);
            }
        }
        else
        {
            // No point waiting 3 minutes -- set m_Task.hCompletionEvent?
            delete pTaskNode;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::AddRecoInst *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoMaster::AddRecoInst(CRecoInst * pRecoInst, BOOL fShared, CRecoMaster ** ppThis)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CRecoMaster::AddRecoInst");
    HRESULT hr = S_OK;

    m_fShared = fShared;   
    m_InstList.InsertHead(pRecoInst);
    *ppThis = this;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::RemoveRecoInst *
*-----------------------------*
*   Description:
*       This internal function is only called from ProcessPendingTasks which
*       has already claimed both the object lock and the outgoing work lock
*       so we are in a safe state to remove this reco instance from our list.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::RemoveRecoInst(CRecoInst * pInst)
{
    SPDBG_FUNC("CRecoMaster::RemoveRecoInst");
    HRESULT hr = S_OK;

    this->m_GrammarHandleTable.FindAndDeleteAll(pInst);
    this->m_RecoCtxtHandleTable.FindAndDeleteAll(pInst);

    this->m_PendingTaskQueue.FindAndDeleteAll(pInst);
    this->m_CompletedTaskQueue.FindAndDeleteAll(pInst);
    this->m_DelayedTaskQueue.FindAndDeleteAll(pInst);

    m_InstList.Remove(pInst);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoMaster::UpdateAudioEventInterest *
*---------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::UpdateAudioEventInterest()
{
    SPDBG_FUNC("CRecoMaster::UpdateAudioEventInterest");
    HRESULT hr = S_OK;

    CRecoInstCtxt * p;
    SPRECOCONTEXTHANDLE h;
    ULONGLONG ullEventInt = SPFEI(0);
    this->m_RecoCtxtHandleTable.First(&h, &p);
    while (p)
    {
        if ((p->m_ullEventInterest & SPFEI(SPEI_SR_AUDIO_LEVEL)) == SPFEI(SPEI_SR_AUDIO_LEVEL))
        {
            ullEventInt = SPFEI(SPEI_SR_AUDIO_LEVEL);
        }
        this->m_RecoCtxtHandleTable.Next(h, &h, &p);
    }
    hr = m_AudioQueue.SetEventInterest(ullEventInt);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRecoMaster::SetInput *
*-----------------------*
*   Description:
*       This method makes sure that the input stream has been initialized.
*
********************************************************************* EDC ***/

HRESULT CRecoMaster::SetInput(ISpObjectToken * pToken, ISpStreamFormat * pStream, BOOL fAllowFormatChanges)
{
    SPDBG_FUNC("CRecoMaster::SetInput");
    HRESULT hr = S_OK;

    if (m_fInStream)  
    {
        hr = SPERR_ENGINE_BUSY;
    }
    else
    {
        // If we are running in the shared case, this will always be called with NULL, NULL
        // so we'll create the default token.  Otherwise, pass the pointers directly to
        // the audio queue.
        if (m_fShared)
        {
            CComPtr<ISpObjectToken> cpDefaultAudioToken;
            hr = SpGetDefaultTokenFromCategoryId(SPCAT_AUDIOIN, &cpDefaultAudioToken);
            if (SUCCEEDED(hr))
            {
                hr = m_AudioQueue.SetInput(cpDefaultAudioToken, NULL, TRUE);
            }
        }
        else
        {
            hr = m_AudioQueue.SetInput(pToken, pStream, fAllowFormatChanges);
        }
    }
    
    return hr;
} /* CRecoMaster::SetInput */


/****************************************************************************
* CRecoMaster::ReleaseEngine *
*----------------------------*
*   Description:
*       Internal function called by CRIT_SETRECOGNIZER::Execute method to release
*   any existing engine.  To do this properly, we need to release the engine,
*   tell the CFG engine to set the client to NULL (since the engine is the client),
*   and inform the audio queue that any format that it has negotiated with the
*   current engine needs to be forgotten about.  We also need to forget about the]
*   current engine token and reset the status.
*
*   Returns:
*
********************************************************************* RAL ***/

void CRecoMaster::ReleaseEngine()
{
    SPDBG_FUNC("CRecoMaster::ReleaseEngine");

    if (m_cpEngine)
    {
        memset(&m_Status, 0, sizeof(m_Status));
        m_cpEngine.Release();
        m_cpEngineToken.Release();
        m_AudioQueue.ResetNegotiatedStreamFormat();
    }
}


/****************************************************************************
* CRecoMaster::LazyInitEngine *
*-----------------------------*
*   Description:
*       This method makes sure that we have a driver loaded.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::LazyInitEngine()
{
    SPDBG_FUNC("CRecoMaster::LazyInitEngine");
    HRESULT hr = S_OK;

    if (!m_cpEngine)
    {
        if (!m_cpEngineToken)
        {
            hr = SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &m_cpEngineToken);
        }

        if (SUCCEEDED(hr))
        {
            hr = SpCreateObjectFromToken(m_cpEngineToken, &m_cpEngine);
        }

        if (SUCCEEDED(hr))
        {
            hr = InitEngineStatus();
        }

        if (SUCCEEDED(hr))
        {
            hr = m_cpCFGEngine->SetClient(this);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_cpCFGEngine->SetLanguageSupport(m_Status.aLangID, m_Status.cLangIDs);
        }

        if (SUCCEEDED(hr))
        {
            hr = SetSite(m_cpSite);
        }

        if (SUCCEEDED(hr) && !m_cpRecoProfileToken)
        {
            hr = SpGetOrCreateDefaultProfile(&m_cpRecoProfileToken);
        }

        if (SUCCEEDED(hr))
        {
            CComPtr<ISpObjectToken> cpRecoProfileTokenCopy;
            CSpDynamicString dstrId;
            hr = m_cpRecoProfileToken->GetId(&dstrId);

            if (SUCCEEDED(hr))
            {
                hr = SpGetTokenFromId(dstrId, &cpRecoProfileTokenCopy);
            }
            if (SUCCEEDED(hr))
            {
                hr = SetRecoProfile(cpRecoProfileTokenCopy);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::InitEngineStatus *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::InitEngineStatus()
{
    SPDBG_FUNC("CRecoMaster::InitEngineStatus");
    HRESULT hr = S_OK;

    CComPtr<ISpDataKey> cpAttribKey;
    CSpDynamicString dstrLanguages;

    memset(&m_Status, 0, sizeof(m_Status));

    InitGUID(SPALTERNATESCLSID, &m_clsidAlternates);   // OK if there isn't one

    hr = InitGUID(SPTOKENVALUE_CLSID, &m_Status.clsidEngine);

    if (SUCCEEDED(hr))
    {
        hr = m_cpEngineToken->OpenKey(SPTOKENKEY_ATTRIBUTES, &cpAttribKey);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpAttribKey->GetStringValue(L"Language", &dstrLanguages);
    }

    if (SUCCEEDED(hr))
    {
        const WCHAR szSeps[] = L";";
        const WCHAR * pszLang = wcstok(dstrLanguages, szSeps);
        
        while (SUCCEEDED(hr) && pszLang && m_Status.cLangIDs < sp_countof(m_Status.aLangID))
        {
            if (swscanf(pszLang, L"%hx", &m_Status.aLangID[m_Status.cLangIDs]))
            {
                m_Status.cLangIDs++;
                pszLang = wcstok(NULL, szSeps);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
    }
    if (SUCCEEDED(hr) && m_Status.cLangIDs == 0)
    {
        hr = E_UNEXPECTED;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::InitGUID *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::InitGUID(const WCHAR * pszValueName, GUID * pDestGUID)
{
    SPDBG_FUNC("CRecoMaster::InitGUID");
    HRESULT hr = S_OK;

    CSpDynamicString dstrGUID;

    hr = m_cpEngineToken->GetStringValue(pszValueName, &dstrGUID);
    if (SUCCEEDED(hr))
    {
        hr = CLSIDFromString(dstrGUID, pDestGUID);
    }
    if (FAILED(hr))
    {
        memset(pDestGUID, 0, sizeof(*pDestGUID));
    }

    if (SPERR_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }
    return hr;
}

/****************************************************************************
* CRecoMaster::InitThread *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::InitThread(void *, HWND)
{
    return S_OK;
}


/****************************************************************************
* CRecoMaster::ThreadProc *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CRecoMaster::ThreadProc(void * pvThreadId, HANDLE hExitThreadEvent,
                                     HANDLE hNotifyEvent, HWND hwndIgnored,
                                     volatile const BOOL * pfContinueProcessing)
{
    SPDBG_FUNC("CRecoMaster::ThreadProc");
    HRESULT hr = S_OK;

    switch ((DWORD_PTR)pvThreadId)
    {
    case TID_IncomingData:
        hr = IncomingDataThreadProc(hExitThreadEvent);
        break;

    case TID_OutgoingData:
        hr = OutgoingDataThreadProc(hExitThreadEvent, hNotifyEvent);
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::WindowMessage *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

LRESULT CRecoMaster::WindowMessage(void *, HWND, UINT, WPARAM, LPARAM)
{
    SPDBG_ASSERT(FALSE);
    return 0;
}


/****************************************************************************
* CRecoMaster::IncomingDataThreadProc *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::IncomingDataThreadProc(HANDLE hExitThreadEvent)
{
    SPDBG_FUNC("CRecoMaster::IncomingDataThreadProc");
    HRESULT hr = S_OK;

    HANDLE aEvents[] = {hExitThreadEvent, m_PendingTaskQueue};
    bool fContinue = true;

    while (fContinue)
    {
        DWORD dwWait = ::WaitForMultipleObjects(sp_countof(aEvents), aEvents, FALSE, INFINITE);
        switch (dwWait)
        {
        case WAIT_OBJECT_0: // Exit thread
            hr = S_OK;
            fContinue = false;
            break;
        case WAIT_OBJECT_0 + 1:     // Event
            {
                SPAUTO_OBJ_LOCK;
                hr = ProcessPendingTasks();
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoMaster::BackOutTask *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::BackOutTask(CSRTask * pTask)
{
    SPDBG_FUNC("CRecoMaster::BackOutTask");
    HRESULT hr = S_OK;

    if (pTask->m_Task.hRecoInstGrammar)
    {
        CRecoInstGrammar * pGrammar;
        hr = m_GrammarHandleTable.GetHandleObject(pTask->m_Task.hRecoInstGrammar, &pGrammar);
        if (SUCCEEDED(hr))
        {
            hr = pGrammar->BackOutTask(&pTask->m_Task);
        }
    }
    else if (pTask->m_Task.hRecoInstContext)
    {
        CRecoInstCtxt * pCtxt;
        hr = m_RecoCtxtHandleTable.GetHandleObject(pTask->m_Task.hRecoInstContext, &pCtxt);   
        if (SUCCEEDED(hr))
        {
            hr = pCtxt->BackOutTask(&pTask->m_Task);
        }
    }
    else
    {
        hr = pTask->m_pRecoInst->BackOutTask(&pTask->m_Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::ShouldStartStream *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

BOOL CRecoMaster::ShouldStartStream()
{
    SPDBG_FUNC("CRecoMaster::ShouldStartStream");
    return ((!m_fInStream) &&
             (m_RecoState == SPRST_ACTIVE_ALWAYS ||
              (m_RecoState == SPRST_ACTIVE &&
               m_cPause == 0 &&
               m_Status.ulNumActive != 0)));
}


/****************************************************************************
* CRecoMaster::ProcessPendingTasks *
*--------------------------------*
*   Description:
*       This method removes tasks from the pending task queue and processes
*       them.  IT MUST BE CALLED WITH THE OBJECT CRITICAL SECTION OWNED EXACTLY
*       ONE TIME!
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::ProcessPendingTasks()
{
    SPDBG_FUNC("CRecoMaster::ProcessPendingTasks");
    HRESULT hr = S_OK;

    for (CSRTask * pTask = m_PendingTaskQueue.RemoveHead();
         pTask;
         pTask = m_PendingTaskQueue.RemoveHead())
    {
        BOOL fTookOutgoingCrit = false;
        if (pTask->ChangesOutgoingState())
        {
            fTookOutgoingCrit = true;
            Unlock();
            m_OutgoingWorkCrit.Lock();
            Lock();
        }
        if (pTask->m_Task.hRecoInstGrammar)
        {
            CRecoInstGrammar * pGrammar;

            hr = m_GrammarHandleTable.GetHandleObject(pTask->m_Task.hRecoInstGrammar, &pGrammar);

            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(pGrammar->m_hrCreation))
                {
                    hr = pGrammar->ExecuteTask(&pTask->m_Task);
                }
                else
                {
                    hr = pGrammar->m_hrCreation;
                }
            }
        }
        else if (pTask->m_Task.hRecoInstContext)
        {
            CRecoInstCtxt * pCtxt;
            hr = m_RecoCtxtHandleTable.GetHandleObject(pTask->m_Task.hRecoInstContext, &pCtxt);   
            SPDBG_ASSERT(SUCCEEDED(hr) && pCtxt);
            
            // Execute the task if the context is in an initialized state.
            // The creation of the context may have failed asynchronously,
            // in which case we return the error.
            // Note: We could add similar logic to PerformTask so we don't even bother
            // adding the task if the creation has already failed.
            if (SUCCEEDED(hr))
            {
                // Context initalized successfully
                if(pCtxt->m_pRecoMaster && SUCCEEDED(pCtxt->m_hrCreation))
                {
                    hr = pCtxt->ExecuteTask(&pTask->m_Task);
                }
                // Context initialization failed
                else if(FAILED(pCtxt->m_hrCreation))
                {
                    hr = pCtxt->m_hrCreation;
                }
                else
                {
                    // Context initialization has not yet happened, which should be impossible
                    SPDBG_ASSERT(FALSE);
                }
            }
        }
        else
        {
            if (pTask->m_Task.eTask == ERMT_REMOVERECOINST)
            {
                this->RemoveRecoInst(pTask->m_pRecoInst);
                SPDBG_ASSERT(pTask->m_Task.hCompletionEvent);
                ::SetEvent(pTask->m_Task.hCompletionEvent);
                pTask->m_Task.hCompletionEvent = NULL;
            }
            else
            {
                hr = pTask->m_pRecoInst->ExecuteTask(&pTask->m_Task);
            }
        }

        //
        //  If we took the outgoing thread's critical section then we can release it here
        //
        if (fTookOutgoingCrit)
        {
            m_OutgoingWorkCrit.Unlock();
        }

        //
        //  We special-case the SetRecoState event 
        //  If we have no contexts, we have the special case required to allow SetRecognizer to work without
        //  deadlocking when we immediately transition from ACTIVE_ALWAYS before calling SetRecognizer.
        // 
        if (m_fInStream && pTask->m_Task.eTask == EIT_SETRECOSTATE &&
            ((m_RecoCtxtHandleTable.NumActiveHandles() == 0 && m_RecoState == SPRST_ACTIVE_ALWAYS && pTask->m_Task.NewState != SPRST_ACTIVE_ALWAYS) ||
            (pTask->m_Task.NewState == SPRST_INACTIVE || pTask->m_Task.NewState == SPRST_INACTIVE_WITH_PURGE)))
        {
            m_DelayedInactivateQueue.InsertTail(pTask);
        }
        else
        {
            // By definition, tasks that complete asynchronously do not START the audio
            // stream, so we only need to check for the stream start when there is a
            // completion event.
            if (pTask->m_Task.hCompletionEvent)
            {
                pTask->m_Task.Response.hr = hr; // Set up the response HRESULT first...
                if (ShouldStartStream())
                {
                    if ( (!m_fShared) && (!m_AudioQueue.HaveInputStream()) )
                    {
                        if (S_OK == hr && pTask->IsStartStreamTask())
                        {
                            pTask->m_Task.Response.hr = SP_STREAM_UNINITIALIZED ;
                        }
                        m_CompletedTaskQueue.InsertTail(pTask);
                    }
                    else
                    {
                          StartStream(pTask); // Let StartStream complete this task since we may need to
                                              // fail the operation.  We can't wait for this to return S_OK
                                              // since it stays in the stream for a long, long time if
                                              // it works.  So, this method completes the task.
                    }
                }
                else
                {
                    m_CompletedTaskQueue.InsertTail(pTask);
                }
            }
            else
            {
                delete pTask;
            }
        }

        // WARNING!   Do not access pTask past this point.
        pTask = NULL;

    }    

    //
    //  Now check for stream stop state changes.  NOTE:  WARNING!  Do not check for this
    //  inside of the above loop!  We need to complete all pending tasks BEFORE we stop 
    //  the stream so that if we get into a situation where there is a completed pending
    //  task that would have re-started a stream, we just never stop it.  For example,
    //  a SetGrammarState(DISABLED) SetRuleState(whatever) SetGrammarState(ENABLED) would
    //  work since the stream would not stop, and therefore the SetGrammarState(ENABLED)
    //  would not have to re-start the stream
    //
    if (m_fInStream && 
        (m_RecoState == SPRST_INACTIVE ||
         (m_RecoState == SPRST_ACTIVE && m_Status.ulNumActive == 0 && m_cPause == 0)))
    {
        m_AudioQueue.PauseStream();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::CompleteDelayedRecoInactivate *
*--------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::CompleteDelayedRecoInactivate()
{
    SPDBG_FUNC("CRecoMaster::CompleteDelayedRecoInactivate");
    HRESULT hr = S_OK;

    CSRTask * pTask = m_DelayedInactivateQueue.RemoveHead();
    if (pTask)
    {
        SPDBG_ASSERT(m_RecoState == SPRST_INACTIVE);
        hr = AddRecoStateEvent();
        do
        {
            m_CompletedTaskQueue.InsertTail(pTask);
        } while (NULL != (pTask = m_DelayedInactivateQueue.RemoveHead()));
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::AddRecoStateEvent *
*--------------------------------*
*   Description:
*       Broadcasts a state change event to all contexts.
*
*   Returns:
*       Result of AddEvent call    
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::AddRecoStateEvent()
{
    SPDBG_FUNC("CRecoMaster::AddRecoStateEvent");
    HRESULT hr = S_OK;

    SPEVENT Event;
    Event.eEventId = SPEI_RECO_STATE_CHANGE;
    Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
    Event.ulStreamNum = m_Status.ulStreamNumber;
    Event.ullAudioStreamOffset = m_Status.ullRecognitionStreamPos;
    Event.ulStreamNum = 0;
    Event.wParam = m_RecoState;
    Event.lParam = 0;
    hr = InternalAddEvent(&Event, NULL);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::CleanUpPairedEvents *
*----------------------------------*
*   Description:
*       If the engine returns from RecognizeStream with an un-paired sound start
*   or a phrase start, we cram the appropriate event in the queue here    
*
*   Returns:
*       HRESULT from add event, but this will be ignored (used for debugging only)
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::CleanUpPairedEvents()
{
    SPDBG_FUNC("CRecoMaster::CleanUpPairedEvents");
    HRESULT hr = S_OK;

    SPEVENT Event;

    if (m_fInSound)
    {
        SPDBG_ASSERT(FALSE);
        m_fInSound = FALSE;
        memset(&Event, 0, sizeof(Event));
        Event.eEventId = SPEI_SOUND_END;
        Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
        Event.ullAudioStreamOffset = m_AudioQueue.LastPosition();
        hr = InternalAddEvent(&Event, NULL);
    }
    //
    //  This one's kind of a pain since we can't really construct a false recognition 
    //  since it requires a result object (perhaps with audio).  So we'll tell everyone
    //  that there was a recognition for another context.
    //
    if (m_fInPhrase)
    {
        SPDBG_ASSERT(FALSE);
        m_fInPhrase = false;
        memset(&Event, 0, sizeof(Event));
        Event.eEventId = SPEI_RECO_OTHER_CONTEXT;
        Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
        Event.ullAudioStreamOffset = m_AudioQueue.LastPosition();
        hr = InternalAddEvent(&Event, NULL);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoMaster::StartStream *
*--------------------------*
*   Description:
*       This method starts the audio stream and calls the engine's RecognizeStream()
*       method.  This function must be called with the object critical section
*       claimed exactly one time.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::StartStream(CSRTask * pTaskThatStartedStream)
{
    SPDBG_FUNC("CRecoMaster::StartStream");
    HRESULT hr = S_OK;
    BOOL fNewStream;

    // Set up the engine if not done so already
    hr = LazyInitEngine();
    
    if ( SUCCEEDED(hr) && !m_AudioQueue.HaveInputStream())
    {
        if (m_fShared)
        {
            // Get the default audio stream
            hr = SetInput(NULL, NULL, TRUE);
        }
        else
        {
            SPDBG_ASSERT(false);
            hr = E_UNEXPECTED;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_AudioQueue.StartStream(this, m_cpRecoProfileToken, m_Status.clsidEngine, &fNewStream);
    }

    if (SUCCEEDED(hr))
    {
        BOOL fRestartStream = FALSE;
        // Complete the task that started the stream successfully...
        m_CompletedTaskQueue.InsertTail(pTaskThatStartedStream);
        do
        {
            m_Status.ulStreamNumber++;
            m_Status.ullRecognitionStreamPos = 0;

            SPEVENT Event;
            Event.eEventId = SPEI_START_SR_STREAM;
            Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
            Event.ullAudioStreamOffset = 0;
            Event.ulStreamNum = 0;  // Filled in by AddEvent
            Event.wParam = 0;
            Event.lParam = 0;
            InternalAddEvent(&Event, NULL);

            m_fInStream = true;
            m_fInSound = false;
            m_fInPhrase = false;
            m_ullLastSyncPos = 0;
            m_ullLastSoundStartPos = 0;
            m_ullLastSoundEndPos = 0;
            m_ullLastPhraseStartPos = 0;
            m_ullLastRecoPos = 0;

            HRESULT hrRecoStream;
            m_autohRequestExit.ResetEvent();
            hrRecoStream = RecognizeStream(m_AudioQueue.EngineFormat().FormatId(), 
                                             m_AudioQueue.EngineFormat().WaveFormatExPtr(),
                                             static_cast<HANDLE>(m_PendingTaskQueue),
                                             m_AudioQueue.DataAvailableEvent(),
                                             m_autohRequestExit,
                                             fNewStream,
                                             m_AudioQueue.IsRealTimeAudio(),
                                             m_AudioQueue.InputObjectToken());

            CleanUpPairedEvents();       // Force proper cleanup of mismatched sound start and phrase start

            m_DelayedTaskQueue.Purge(); //Purge the queue so that the tasks won't be requeued to pendingqueue next time the stream restarts

            // See if the recognition stopped for an expected or unexpected reason by seeing if 
            // the audio queue thinks it should still be running.
            BOOL fStreamEndedBySAPI = (m_AudioQueue.GetStreamAudioState() != SPAS_RUN);
            
            HRESULT hrFinalRead;
            BOOL fReleasedStream;
           
            m_AudioQueue.EndStream(&hrFinalRead, &fReleasedStream);


            //  Force a fake "synchronize" after calling the engine, but with m_fInStream
            //  still set to true to avoid a recursive call to this function.  Later we'll
            //  check to see if the stream should be restarted.
            ProcessPendingTasks();

            m_fInStream = false;

            // We leave the reco state as it if everything has completed normally,
            // or if the audio stream errored but with a known error such that we want to restart it.
            // Otherwise we deactivate the reco state to prevent it from being restarted immediately.
            // Additionally, if everything completed normally but a real time audio stream ran out of data, we
            // also deactivate, so that an application can potentially reactivate if it knows the stream has more data.
            BOOL fLeaveStreamState = 
                ( SUCCEEDED(hrRecoStream) && SUCCEEDED(hrFinalRead) && (fReleasedStream || fStreamEndedBySAPI) ) ||
                ( IsStreamRestartHresult(hrFinalRead) && (SUCCEEDED(hrRecoStream) || hrFinalRead == hrRecoStream) );
            
            if (!fLeaveStreamState)
            {
                if (m_RecoState != SPRST_INACTIVE)
                {
                    m_RecoState = SPRST_INACTIVE;
                    AddRecoStateEvent();
                }
                hr = hrRecoStream;
            }
            
            if (m_RecoState == SPRST_INACTIVE)
            {
                m_AudioQueue.CloseStream();     // Note: Closed below in loop again, but that's OK
                                                // we need to close the device before completing a
                                                // SetReocState(INACTIVE) to make sure that when it
                                                // returns that the device is truly closed.
                CompleteDelayedRecoInactivate();
                fRestartStream = false;
            }
            else
            {
                fRestartStream = ShouldStartStream() && m_AudioQueue.HaveInputStream();
            }

            //
            //  If the RecognizeStream call returns a non-S_OK result then that will be the one
            //  that is placed in the END_SR_STREAM event, otherwise, the HRESULT from the 
            //  final stream read will be returned.
            //
            HRESULT hrEvent = hrRecoStream;
            if (hrEvent == S_OK)
            {
                hrEvent = hrFinalRead;
            }

            Event.eEventId = SPEI_END_SR_STREAM;
            Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
            Event.ullAudioStreamOffset = m_AudioQueue.LastPosition();
            Event.ulStreamNum = 0;  // Filled in by AddEvent
            Event.wParam = fReleasedStream ? SPESF_STREAM_RELEASED : SPESF_NONE;
            Event.lParam = hrEvent;
            InternalAddEvent(&Event, NULL);

            m_Status.ulStreamNumber++;
            m_Status.ullRecognitionStreamPos = 0;

            if (fRestartStream)
            {
                if (m_fInFinalRelease)
                {
                    fRestartStream = FALSE;
                }
                else
                {
                    hr = m_AudioQueue.StartStream(this, m_cpRecoProfileToken, m_Status.clsidEngine, &fNewStream);
                    SPDBG_ASSERT(SUCCEEDED(hr));
                }
            }
        } while (fRestartStream);
        m_AudioQueue.CloseStream();
    }
    else    // Failed to start the stream...
    {
        BackOutTask(pTaskThatStartedStream);
        pTaskThatStartedStream->m_Task.Response.hr = hr;             // Fail task
        m_CompletedTaskQueue.InsertTail(pTaskThatStartedStream);     // And complete it
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::GetAltSerializedPhrase *
*-------------------------------------*
*   Description:
*       Gets a serialized phrase for an alternate and updates the ullGrammarID
*   field as appropriate.  If the result is not from the CFG engine then we
*   assume that the alternate is from the same grammar
*
*   Returns:
*       HRESULT
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::GetAltSerializedPhrase(ISpPhrase * pAlt, SPSERIALIZEDPHRASE ** ppSerPhrase, ULONGLONG ullBestPathGrammarID)
{
    SPDBG_FUNC("CRecoMaster::GetAltSerializedPhrase");
    HRESULT hr = S_OK;

    hr = pAlt->GetSerializedPhrase(ppSerPhrase);
    if (SUCCEEDED(hr))
    {
        SPINTERNALSERIALIZEDPHRASE * pInternalPhrase = (SPINTERNALSERIALIZEDPHRASE *)(*ppSerPhrase);
        pInternalPhrase->ullGrammarID = ullBestPathGrammarID;
        CComQIPtr<_ISpCFGPhraseBuilder> cpBuilder(pAlt);
        if (cpBuilder)
        {
            SPRULEHANDLE hRule;
            CComPtr<ISpCFGEngine> cpEngine;
            if (S_OK == cpBuilder->GetCFGInfo(&cpEngine, &hRule) &&
                hRule && (cpEngine == m_cpCFGEngine || cpEngine.IsEqualObject(m_cpCFGEngine)))
            {
                SPGRAMMARHANDLE hGrammar;
                CRecoInstGrammar * pGrammar;
                if (SUCCEEDED(m_cpCFGEngine->GetOwnerCookieFromRule(hRule, (void **)&hGrammar)) &&
                    SUCCEEDED(m_GrammarHandleTable.GetHandleObject(hGrammar, &pGrammar)))
                {
                    pInternalPhrase->ullGrammarID = pGrammar->m_ullApplicationGrammarId;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoMaster::SendResultToCtxt *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CRecoMaster::
    SendResultToCtxt( SPEVENTENUM eEventId, const SPRECORESULTINFO * pResult,
                      CRecoInstCtxt* pCtxt, ULONGLONG ullApplicationGrammarID, BOOL fPause, BOOL fEmulated )
{
    SPDBG_FUNC("CRecoMaster::SendResultToCtxt");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(pResult->pPhrase);

    if (pCtxt->m_ullEventInterest & (1i64 << eEventId))
    {
        // confirm phrase audio positions correspond with sprecoresultinfo
        SPPHRASE *pPhrase;
        hr = pResult->pPhrase->GetPhrase(&pPhrase);

        // check phrase posn end not ahead of reco end pos
        // check phrase posn start is 0 or not behind reco start pos
        if(SUCCEEDED(hr))
        {
            if(pPhrase->ullAudioStreamPosition && (pPhrase->ullAudioStreamPosition < pResult->ullStreamPosStart ||
                (pPhrase->ullAudioStreamPosition + pPhrase->ulAudioSizeBytes > pResult->ullStreamPosEnd)))
            {
                SPDBG_ASSERT(0);
                hr = SPERR_STREAM_POS_INVALID;
            }

            ULONG ulPosition = 0;
            for(ULONG i = 0; SUCCEEDED(hr) && i < pPhrase->Rule.ulCountOfElements; i++)
            {
                if(static_cast<LONG>(pPhrase->pElements[i].ulAudioStreamOffset) < static_cast<LONG>(ulPosition))
                {
                    SPDBG_ASSERT(0);
                    hr = SPERR_STREAM_POS_INVALID;
                }
                ulPosition = pPhrase->pElements[i].ulAudioStreamOffset + pPhrase->pElements[i].ulAudioSizeBytes;
            }
            if(ulPosition > pPhrase->ulAudioSizeBytes)
            {
                SPDBG_ASSERT(0);
                hr = SPERR_STREAM_POS_INVALID;
            }

            ::CoTaskMemFree(pPhrase);
        }

        ULONGLONG ullAudioPosition = pResult->ullStreamPosStart;
        ULONG ulAudioSize = static_cast<ULONG>(pResult->ullStreamPosEnd - pResult->ullStreamPosStart);
        ULONG cbAudioSerializeSize = 0;
        SPINTERNALSERIALIZEDPHRASE * pSerPhrase = NULL;
        CResultHeader hdr;

        // if the app requested audio, then calculate needed size for the data
        // note that emulated results will have an audio size of 0, so do nothing.
        if (SUCCEEDED(hr) && ulAudioSize &&
            (!pResult->fHypothesis) && pCtxt->m_fRetainAudio )
        {
            cbAudioSerializeSize = m_AudioQueue.SerializeSize(ullAudioPosition, ulAudioSize);
        }

        //--- Get the primary phrase
        if(SUCCEEDED(hr))
        {
            hr = pResult->pPhrase->GetSerializedPhrase((SPSERIALIZEDPHRASE **)&pSerPhrase);
        }

        if (SUCCEEDED(hr))
        {
            pSerPhrase->ullGrammarID = ullApplicationGrammarID;
        }

        //--- Get the alternate phrases
        SPSERIALIZEDPHRASE **SerAlts = NULL;
        ULONG ulAltSerializeSize = 0;
        if( SUCCEEDED(hr) && pResult->ulNumAlts )
        {
            SerAlts = (SPSERIALIZEDPHRASE **)alloca( pResult->ulNumAlts *
                                                     sizeof(SPSERIALIZEDPHRASE*) );

            for( ULONG i = 0; SUCCEEDED(hr) && (i < pResult->ulNumAlts); ++i )
            {
                hr = GetAltSerializedPhrase(pResult->aPhraseAlts[i].pPhrase, SerAlts + i, ullApplicationGrammarID);
                if( SUCCEEDED(hr) )
                {
                    ulAltSerializeSize += SerAlts[i]->ulSerializedSize +
                                          sizeof( pResult->aPhraseAlts[i].ulStartElementInParent ) +
                                          sizeof( pResult->aPhraseAlts[i].cElementsInParent    ) +
                                          sizeof( pResult->aPhraseAlts[i].cElementsInAlternate ) +
                                          sizeof( pResult->aPhraseAlts[i].cbAltExtra ) +
                                          pResult->aPhraseAlts[i].cbAltExtra;
                }
            }
        }

        //--- Initialize the result header
        if( SUCCEEDED(hr) )
        {
            hr = hdr.Init( pSerPhrase->ulSerializedSize, ulAltSerializeSize, cbAudioSerializeSize,
                           pResult->fHypothesis ? 0 : pResult->ulSizeEngineData );
        }

        if (SUCCEEDED(hr))
        {
            // Get the stream offsets
            m_AudioQueue.CalculateTimes(pResult->ullStreamPosStart, pResult->ullStreamPosEnd, &hdr.m_pHdr->times);

            hdr.m_pHdr->clsidEngine            = m_Status.clsidEngine;
            hdr.m_pHdr->clsidAlternates        = m_clsidAlternates;
            hdr.m_pHdr->ulStreamNum            = m_Status.ulStreamNumber; 
            hdr.m_pHdr->ullStreamPosStart      = pResult->ullStreamPosStart;
            hdr.m_pHdr->ullStreamPosEnd        = pResult->ullStreamPosEnd;
            hdr.m_pHdr->fTimePerByte           = m_AudioQueue.TimePerByte();
            hdr.m_pHdr->fInputScaleFactor      = m_AudioQueue.InputScaleFactor();

            //--- Copy the phrase
            memcpy( hdr.m_pbPhrase, pSerPhrase, pSerPhrase->ulSerializedSize );
            ::CoTaskMemFree(pSerPhrase);

            //--- Copy/serialize the alternates
            if( ulAltSerializeSize )
            {
                BYTE* pMem = hdr.m_pbPhraseAlts; 
                for( ULONG i = 0; i < pResult->ulNumAlts; ++i )
                {
                    memcpy( pMem, &pResult->aPhraseAlts[i].ulStartElementInParent,
                            sizeof( pResult->aPhraseAlts[i].ulStartElementInParent ) );
                    pMem += sizeof( pResult->aPhraseAlts[i].ulStartElementInParent );

                    memcpy( pMem, &pResult->aPhraseAlts[i].cElementsInParent,
                            sizeof( pResult->aPhraseAlts[i].cElementsInParent ) );
                    pMem += sizeof( pResult->aPhraseAlts[i].cElementsInParent );

                    memcpy( pMem, &pResult->aPhraseAlts[i].cElementsInAlternate,
                            sizeof( pResult->aPhraseAlts[i].cElementsInAlternate ) );
                    pMem += sizeof( pResult->aPhraseAlts[i].cElementsInAlternate );

                    memcpy( pMem, &pResult->aPhraseAlts[i].cbAltExtra,
                            sizeof( pResult->aPhraseAlts[i].cbAltExtra ) );
                    pMem += sizeof( pResult->aPhraseAlts[i].cbAltExtra );

                    memcpy( pMem, pResult->aPhraseAlts[i].pvAltExtra,
                            pResult->aPhraseAlts[i].cbAltExtra );
                    pMem += pResult->aPhraseAlts[i].cbAltExtra;

                    memcpy( pMem, SerAlts[i], SerAlts[i]->ulSerializedSize );
                    pMem += SerAlts[i]->ulSerializedSize;

                    ::CoTaskMemFree(SerAlts[i]);
                }
                hdr.m_pHdr->ulNumPhraseAlts = pResult->ulNumAlts;

                //--- Check if something went wrong in serialization calculations
                SPDBG_ASSERT( (ULONG)(pMem - hdr.m_pbPhraseAlts) <= ulAltSerializeSize );
            }

            // add audio data to the blob if required
            if (cbAudioSerializeSize)
            {
                m_AudioQueue.Serialize(hdr.m_pbAudio, ullAudioPosition, ulAudioSize);
            }

            // add the driver specific data to the blob if required
            if (hdr.m_pbDriverData)
            {
                memcpy(hdr.m_pbDriverData, pResult->pvEngineData, pResult->ulSizeEngineData);
            }

            // Initialize the waveformat and convert the stream positions to time positions
            hr = hdr.StreamOffsetsToTime(); // Ignore returned result
            SPDBG_ASSERT(SUCCEEDED(hr)); // What do we do if this fails?

            //
            //  Now stick it in the event queue.
            //
            CSREvent * pNode = new CSREvent();
            if (pNode)
            {
                WPARAM RecoFlags = 0;
                if(fPause)
                {
                    RecoFlags += SPREF_AutoPause;
                }
                if(fEmulated)
                {
                    RecoFlags += SPREF_Emulated;
                }

                pNode->Init(hdr.Detach(), eEventId, RecoFlags, pCtxt->m_hThis);
                m_EventQueue.InsertTail(pNode);
                if (fPause)
                {
                    pCtxt->m_cPause++;
                    this->m_cPause++;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::SendFalseReco *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::SendFalseReco(const SPRECORESULTINFO * pResult, BOOL fEmulated, CRecoInstCtxt *pCtxtIgnore)
{
    SPDBG_FUNC("CRecoMaster::SendFalseReco");
    HRESULT hr = S_OK;

    SPRECORESULTINFO FakeResult;
    FakeResult = *pResult;

    CComPtr<ISpPhraseBuilder> cpEmptyPhrase;
    SPPHRASE Phrase;
    memset(&Phrase, 0, sizeof(Phrase));

    Phrase.cbSize = sizeof(Phrase);
    Phrase.LangID = m_Status.aLangID[0];
    Phrase.ullAudioStreamPosition = pResult->ullStreamPosStart;
    Phrase.ulAudioSizeBytes = static_cast<ULONG>(pResult->ullStreamPosEnd - pResult->ullStreamPosStart);
    // All other elements should be 0

    hr = cpEmptyPhrase.CoCreateInstance(CLSID_SpPhraseBuilder);
   
    if (SUCCEEDED(hr))
    {
        hr = cpEmptyPhrase->InitFromPhrase(&Phrase);
    }

    if (SUCCEEDED(hr))
    {
        FakeResult.pPhrase = cpEmptyPhrase;
        SPRECOCONTEXTHANDLE h;
        CRecoInstCtxt * pCtxt;
        m_RecoCtxtHandleTable.First(&h, &pCtxt);
        while (pCtxt)
        {
            if (pCtxt != pCtxtIgnore)
            {
                // Ignore errors in this loop since there's nothing we can do about it...
                HRESULT hrSendResult = SendResultToCtxt(SPEI_FALSE_RECOGNITION, &FakeResult, pCtxt, 0, FALSE, fEmulated);
                SPDBG_ASSERT(SUCCEEDED(hrSendResult));
                if (FAILED(hrSendResult) && SUCCEEDED(hr))
                {
                    hr = hrSendResult;  // We'll still return failure, but keep on going
                }
            }
            m_RecoCtxtHandleTable.Next(h, &h, &pCtxt);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::InternalAddEvent *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::InternalAddEvent(const SPEVENT* pEvent, SPRECOCONTEXTHANDLE hContext)
{
    SPDBG_FUNC("CRecoMaster::InternalAddEvent");
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        CSREvent * pNode = new CSREvent();
        if (pNode)
        {
            hr = pNode->Init(pEvent, hContext);
            if (SUCCEEDED(hr))
            {
                pNode->m_pEvent->ulStreamNum = m_Status.ulStreamNumber;
                m_EventQueue.InsertTail(pNode);
            }
            else
            {
                delete pNode;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::AddEvent *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::AddEvent(const SPEVENT* pEvent, SPRECOCONTEXTHANDLE hContext)
{
    SPDBG_FUNC("CRecoMaster::AddEvent");
    HRESULT hr = S_OK;

    // Check arguments
    if (SP_IS_BAD_READ_PTR(pEvent) ||
        (hContext && !this->m_RecoCtxtHandleTable.IsValidHandle(hContext)))
    {
        SPDBG_ASSERT(0);
        hr = E_INVALIDARG;
    }
    else
    {
        // Check event valid lParam, wParam
        hr = SpValidateEvent(pEvent);
    }

    // Check event stream position
    if(SUCCEEDED(hr))
    {
        if(m_fInStream)
        {
            if((pEvent->eEventId != SPEI_REQUEST_UI && pEvent->eEventId != SPEI_ADAPTATION) ||
                pEvent->ullAudioStreamOffset != 0)
            {
                SPAUDIOSTATUS Status;
                hr = m_AudioQueue.GetAudioStatus(&Status);
                if(SUCCEEDED(hr) && (pEvent->ullAudioStreamOffset > Status.CurSeekPos ||
                    pEvent->ullAudioStreamOffset < m_ullLastSyncPos))
                {
                    SPDBG_ASSERT(0);
                    hr = SPERR_STREAM_POS_INVALID;
                }
            }
        }
        else if(pEvent->ullAudioStreamOffset != 0)
        {
            SPDBG_ASSERT(0);
            hr = SPERR_STREAM_POS_INVALID;
        }
    }

    // Check eventId is valid
    if(SUCCEEDED(hr))
    {
        switch(pEvent->eEventId)
        {
        case SPEI_SOUND_START:
            if(!m_fInStream || m_fInSound)
            {
                SPDBG_ASSERT(0);
                hr = E_INVALIDARG;
            }
            else if(pEvent->ullAudioStreamOffset < m_ullLastSoundEndPos)
            {
                SPDBG_ASSERT(0);
                hr = SPERR_STREAM_POS_INVALID;
            }
            break;

        case SPEI_SOUND_END:
            if(!m_fInStream || !m_fInSound)
            {
                SPDBG_ASSERT(0);
                hr = E_INVALIDARG;
            }
            else if(pEvent->ullAudioStreamOffset < m_ullLastSoundStartPos)
            {
                SPDBG_ASSERT(0);
                hr = SPERR_STREAM_POS_INVALID;
            }
            break;

        case SPEI_PHRASE_START:
            if(!m_fInStream || m_fInPhrase)
            {
                SPDBG_ASSERT(0);
                hr = E_INVALIDARG;
            }
            else if(pEvent->ullAudioStreamOffset < m_ullLastRecoPos)
            {
                SPDBG_ASSERT(0);
                hr = SPERR_STREAM_POS_INVALID;
            }
            break;

        case SPEI_INTERFERENCE:
            if(pEvent->elParamType != SPET_LPARAM_IS_UNDEFINED) 
            {
                SPDBG_ASSERT(0);
                hr = E_INVALIDARG;
            }
            break;

        case SPEI_REQUEST_UI:
            if(pEvent->elParamType != SPET_LPARAM_IS_STRING
                || (pEvent->lParam && wcslen((WCHAR*)pEvent->lParam) >= 255)) // 255 is length of RECOCONTEXTSTATUS::szRequestTypeOfUI
            {
                SPDBG_ASSERT(0);
                hr = E_INVALIDARG;
            }
            break;

        case SPEI_ADAPTATION:
        case SPEI_MAX_SR - 1: // private events
        case SPEI_MAX_SR:
            // No special checking on these events yet
            break;

        default:
            SPDBG_ASSERT(0);
            hr = E_INVALIDARG;
            break;
        }
    }

    // Actually add event
    if(SUCCEEDED(hr))
    {
        hr = InternalAddEvent(pEvent, hContext);
    }

    // Update state info if successful
    if(SUCCEEDED(hr))
    {
        if(pEvent->eEventId == SPEI_SOUND_START)
        {
            m_fInSound = true;
            m_ullLastSoundStartPos = pEvent->ullAudioStreamOffset;
        }
        else if(pEvent->eEventId == SPEI_SOUND_END)
        {
            m_fInSound = false;
            m_ullLastSoundEndPos = pEvent->ullAudioStreamOffset;
        }
        else if(pEvent->eEventId == SPEI_PHRASE_START)
        {
            m_fInPhrase = true;
            m_ullLastPhraseStartPos = pEvent->ullAudioStreamOffset;
        }
        else if(pEvent->eEventId == SPEI_REQUEST_UI)
        {
            // It's a UI event so deserialize event and add store copy of string.
            m_dstrRequestTypeOfUI = (WCHAR*)pEvent->lParam;
        }
    }

    return hr;
 }


/****************************************************************************
* CRecoMaster::Recognition *
*--------------------------*
*   Description:
*       This is the implementation of the ISpSREngineSite method Recognition().
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::Recognition(const SPRECORESULTINFO * pResult)
{
    SPDBG_FUNC("CRecoMaster::Recognition");
    HRESULT hr = S_OK;

    if(!m_fInStream)
    {
        SPDBG_ASSERT(0);
        hr = SPERR_STREAM_NOT_ACTIVE;
    }
    else if(!m_fInPhrase)
    {
        SPDBG_ASSERT(0);
        hr = E_INVALIDARG;
    }
    else if(pResult->ullStreamPosStart > pResult->ullStreamPosEnd ||
        pResult->ullStreamPosStart < m_ullLastSyncPos ||
        pResult->ullStreamPosStart < m_ullLastPhraseStartPos)
    {
        SPDBG_ASSERT(0);
        hr = SPERR_STREAM_POS_INVALID;
    }
    else if (SP_IS_BAD_READ_PTR(pResult) ||
        pResult->cbSize != sizeof(*pResult) ||
        (pResult->pPhrase && SP_IS_BAD_INTERFACE_PTR(pResult->pPhrase)) ||
        (pResult->pvEngineData && (pResult->ulSizeEngineData == 0 || SPIsBadReadPtr(pResult->pvEngineData, pResult->ulSizeEngineData))) ||
        (pResult->pvEngineData == NULL && pResult->ulSizeEngineData != NULL) ||
        SPIsBadReadPtr( pResult->aPhraseAlts, pResult->ulNumAlts ) )
    {
        SPDBG_ASSERT(0);
        hr = E_INVALIDARG;
    }
    else if((((pResult->eResultType & ~SPRT_FALSE_RECOGNITION) != SPRT_CFG) &&
        ((pResult->eResultType & ~SPRT_FALSE_RECOGNITION) != SPRT_SLM) &&
        ((pResult->eResultType & ~SPRT_FALSE_RECOGNITION) != SPRT_PROPRIETARY)) ||
        ((pResult->eResultType & SPRT_FALSE_RECOGNITION) && pResult->fHypothesis) ||
        (!(pResult->eResultType & SPRT_FALSE_RECOGNITION) && !pResult->pPhrase))
    {
        SPDBG_ASSERT(0);
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr))
    {
        SPAUDIOSTATUS Status;
        hr = m_AudioQueue.GetAudioStatus(&Status);
        if(SUCCEEDED(hr) && (
            pResult->ullStreamPosStart > Status.CurSeekPos ||
            pResult->ullStreamPosEnd > Status.CurSeekPos))
        {
            SPDBG_ASSERT(0);
            hr = SPERR_STREAM_POS_INVALID;
        }
    }

    //--- Make sure the alts are good
    if( SUCCEEDED( hr ) && pResult->aPhraseAlts )
    {
        for( ULONG i = 0; i < pResult->ulNumAlts; ++i )
        {
            if( ( pResult->aPhraseAlts[i].pvAltExtra &&
                  SPIsBadReadPtr( pResult->aPhraseAlts[i].pvAltExtra, pResult->aPhraseAlts[i].cbAltExtra ) ) ||
                ( !pResult->aPhraseAlts[i].pvAltExtra && pResult->aPhraseAlts[i].cbAltExtra ) )
            {
                hr = E_INVALIDARG;
                break;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if(!pResult->fHypothesis)
        {
            m_fInPhrase = false;
        }

        hr = InternalRecognition(pResult, TRUE, FALSE);

        if(FAILED(hr) && !pResult->fHypothesis)
        {
            m_fInPhrase = true;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

    
/****************************************************************************
* CRecoMaster::InternalRecognition *
*----------------------------------*
*   Description:
*       Recognition call without parameter checking.  The caller of this method
*       must have claimed the object lock exactly one time.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::InternalRecognition(const SPRECORESULTINFO * pResult, BOOL fCallSynchronize, BOOL fEmulated)
{
    HRESULT hr = S_OK;
    SPDBG_FUNC("CRecoMaster::InternalRecognition");

    if ((pResult->eResultType & SPRT_FALSE_RECOGNITION) && pResult->pPhrase == NULL)
    {
        hr = SendFalseReco(pResult, fEmulated);
        if(SUCCEEDED(hr))
        {
            m_ullLastRecoPos = pResult->ullStreamPosEnd;
        }
    }
    else
    {
        BOOL fPause = FALSE;    // Assume we will not do an auto-pause
        SPEVENTENUM eType;
        if(pResult->eResultType & SPRT_FALSE_RECOGNITION)
        {
            eType = SPEI_FALSE_RECOGNITION;
        }
        else
        {
            eType = (pResult->fHypothesis) ? SPEI_HYPOTHESIS : SPEI_RECOGNITION;
        }

        CRecoInstGrammar * pGrammar = NULL;
        switch (pResult->eResultType & ~SPRT_FALSE_RECOGNITION)
        {
        case SPRT_SLM:
            hr = this->m_GrammarHandleTable.GetHandleObject(pResult->hGrammar, &pGrammar);
            if (SUCCEEDED(hr))
            {
                fPause = (eType != SPEI_HYPOTHESIS && pGrammar->m_DictationState == SPRS_ACTIVE_WITH_AUTO_PAUSE);
                // make sure that the pszDisplayText is set so that GetText will work properly
                SPPHRASE * pSPPhrase = NULL;
                hr = pResult->pPhrase->GetPhrase(&pSPPhrase);
                if (SUCCEEDED(hr))
                {
                    for (ULONG i = 0; i < pSPPhrase->Rule.ulCountOfElements; i++)
                    {
                        SPPHRASEELEMENT * pElem = const_cast<SPPHRASEELEMENT*>(pSPPhrase->pElements);
                        if (!pSPPhrase->pElements[i].pszDisplayText)
                        {
                            pElem[i].pszDisplayText = pSPPhrase->pElements[i].pszLexicalForm;
                        }
                    }
                    hr = pResult->pPhrase->InitFromPhrase( pSPPhrase  );
                    ::CoTaskMemFree(pSPPhrase );
                }
            }
            break;

        case SPRT_PROPRIETARY:
            hr = this->m_GrammarHandleTable.GetHandleObject(pResult->hGrammar, &pGrammar);
            fPause = (eType != SPEI_HYPOTHESIS && pResult->fProprietaryAutoPause);
            break;

        case SPRT_CFG:
            {
                // the SR engine has given us a result built with the CFGEngine, so get the grammar from
                // the rule handle
                SPRULEHANDLE hRule;
                CComPtr<ISpCFGEngine> cpEngine;
                CComQIPtr<_ISpCFGPhraseBuilder> cpBuilder(pResult->pPhrase);
                if (cpBuilder)
                {
                    hr = cpBuilder->GetCFGInfo(&cpEngine, &hRule); 
                    if (hr == S_OK && hRule && (cpEngine == m_cpCFGEngine || cpEngine.IsEqualObject(m_cpCFGEngine)))
                    {
                        SPGRAMMARHANDLE hGrammar;
                        hr = m_cpCFGEngine->GetOwnerCookieFromRule(hRule, (void **)&hGrammar);
                        if (SUCCEEDED(hr))
                        {
                            hr = this->m_GrammarHandleTable.GetHandleObject(hGrammar, &pGrammar);
                        }
                        if (SUCCEEDED(hr) && eType != SPEI_HYPOTHESIS)
                        {
                            SPRULEENTRY RuleInfo;
                            RuleInfo.hRule = hRule;
                            if (SUCCEEDED(m_cpCFGEngine->GetRuleInfo(&RuleInfo, SPRIO_NONE)))
                            {
                                fPause = ((RuleInfo.Attributes & SPRAF_AutoPause) != 0);
                            }
                            else
                            {
                                SPDBG_ASSERT(false);    // Strange, but keep on going
                            }
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            break;
        default:
            hr = E_INVALIDARG;
            SPDBG_ASSERT(false);
            break;
        }


        if (SUCCEEDED(hr))
        {
            hr = SendResultToCtxt(eType, pResult, pGrammar->m_pCtxt, pGrammar->m_ullApplicationGrammarId, fPause, fEmulated);
        }

        if (SUCCEEDED(hr))
        {
            if (!pResult->fHypothesis)
            {
                HRESULT hr2;
                if (pResult->eResultType & SPRT_FALSE_RECOGNITION)
                {
                    hr = SendFalseReco(pResult, fEmulated, pGrammar->m_pCtxt);
                }
                else
                {
                    SPEVENT Event;
                    memset(&Event, 0, sizeof(Event));
                    Event.eEventId = SPEI_RECO_OTHER_CONTEXT;
                    Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
                    Event.ullAudioStreamOffset = pResult->ullStreamPosStart;
                    // Stream number filled in by AddEvent.
                    SPRECOCONTEXTHANDLE h;
                    CRecoInstCtxt * pCtxt;
                    m_RecoCtxtHandleTable.First(&h, &pCtxt);
                    while (pCtxt)
                    {
                        if (pCtxt != pGrammar->m_pCtxt)
                        {
                            // Ignore errors here since there's not much that we can do about it...
                            hr2 = InternalAddEvent(&Event, pCtxt->m_hThis);
                            SPDBG_ASSERT(SUCCEEDED(hr2));
                        }
                        m_RecoCtxtHandleTable.Next(h, &h, &pCtxt);
                    }
                }
                if(fCallSynchronize)
                {
                    hr2 = InternalSynchronize(pResult->ullStreamPosEnd);
                    if(SUCCEEDED(hr2))
                    {
                        hr = hr2; // Copy S_OK / S_FALSE
                    }
                }
                m_ullLastRecoPos = pResult->ullStreamPosEnd;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::SendEmulateRecognition *
*-------------------------------------*
*   Description:
*       Because this method is only called from PerformPendingTasks(), we know
*       that the critical section for the object is owned exactly one time.
*
*   Returns:
******************************************************************** EDC ***/

HRESULT CRecoMaster::SendEmulateRecognition(SPRECORESULTINFO *pResult, ENGINETASK *pTask, CRecoInst * pRecoInst)
{
    HRESULT hr = S_OK;

    bool fStartedStream = false;
    SPEVENT Event;
    Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
    Event.ullAudioStreamOffset = 0;
    Event.ulStreamNum = 0;
    Event.wParam = 0;
    Event.lParam = 0;

    if(m_fInPhrase)
    {
        // NTRAID#SPEECH-7382-2000/08/31-ralphl (postponed for 5.0)
        // This is an unresolved case that only occurs on engines which call Synchronize within streams
        // We should add a task onto a new queue and return.
        // Then in Recognition() remove from queue and add
        //  to head of pending queue (after real recognition method is fired).
        SPDBG_ASSERT(false);
        return SPERR_ENGINE_BUSY;
    }

    if(!m_fInStream)
    {
        m_Status.ulStreamNumber++;
        m_Status.ullRecognitionStreamPos = 0;
        m_ullLastSyncPos = 0;

        Event.eEventId = SPEI_START_SR_STREAM;
        InternalAddEvent(&Event, NULL);

        m_fInStream = true;
        fStartedStream = true;
    }

    Event.ullAudioStreamOffset = m_ullLastSyncPos;
    pResult->ullStreamPosStart = m_ullLastSyncPos;
    pResult->ullStreamPosEnd = m_ullLastSyncPos;

    if(!m_fInSound)
    {
        Event.eEventId = SPEI_SOUND_START;
        InternalAddEvent(&Event, NULL);
    }

    if(!m_fInPhrase)
    {
        Event.eEventId = SPEI_PHRASE_START;
        InternalAddEvent(&Event, NULL);
    }

    hr = InternalRecognition(pResult, FALSE, TRUE);
    
    if(SUCCEEDED(hr))
    {
        // We need to release the calling thread now or the app will hang if engine paused.
        // Do the same as PerformTask on Async events.
        CSRTask * pResponse = new CSRTask();
        if (pResponse)
        {
            pResponse->m_pNext = NULL;
            pResponse->m_pRecoInst = pRecoInst;
            pResponse->m_Task = *pTask;
            pResponse->m_ullStreamPos = m_ullLastSyncPos;
            pResponse->m_Task.pvAdditionalBuffer = NULL;
            pResponse->m_Task.cbAdditionalBuffer = 0;
            pResponse->m_Task.Response.hr = hr;
            pTask->Response.hr = S_OK;
            pTask->hCompletionEvent = NULL;
            if (SUCCEEDED(hr))
            {
                this->m_CompletedTaskQueue.InsertTail(pResponse);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            SPDBG_ASSERT(FALSE);
        }

        InternalSynchronize(m_ullLastSyncPos);
    }

    if(!m_fInSound)
    {
        Event.eEventId = SPEI_SOUND_END;
        InternalAddEvent(&Event, NULL);
    }

    if(fStartedStream) // The stream was artificially started, so stop it
    {
        m_fInStream = false;

        Event.eEventId = SPEI_END_SR_STREAM;
        InternalAddEvent(&Event, NULL);

        m_Status.ulStreamNumber++;
        m_Status.ullRecognitionStreamPos = 0;
    }

    return hr;
}


/****************************************************************************
* CRecoMaster::GetMaxAlternates *
*-------------------------------*
*   Description:
*       This method is used to return the maximum number of alternates that
*   should be generated for the specified rule.
*
*   Returns:
*       S_OK = the function succeeded
*
******************************************************************** EDC ***/

HRESULT CRecoMaster::GetMaxAlternates( SPRULEHANDLE hRule, ULONG* pulNumAlts )
{
    SPDBG_FUNC("CRecoMaster::GetMaxAlternates");
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pulNumAlts ) )
    {
        hr = E_POINTER;
    }
    else
    {
        SPGRAMMARHANDLE hGrammar;
        hr = m_cpCFGEngine->GetOwnerCookieFromRule( hRule, (void **)&hGrammar );
        if( SUCCEEDED( hr ) )
        {
            CRecoInstGrammar *pGrammar;
            hr = m_GrammarHandleTable.GetHandleObject( hGrammar, &pGrammar );
            if( SUCCEEDED( hr ) )
            {
                *pulNumAlts = pGrammar->m_pCtxt->m_ulMaxAlternates;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CRecoMaster::GetMaxAlternates */

/****************************************************************************
* CRecoMaster::GetContextMaxAlternates *
*--------------------------------------*
*   Description:
*       This method is used to return the maximum number of alternates that
*   should be generated for the specified recognition context.  Engines that
*   support proprietary grammars need to call this to determine how many
*   alternates to generate.  For SAPI grammars, it is usually easier to use
*   the GetMaxAlternates() method.
*
*   Returns:
*       S_OK = the function succeeded
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::GetContextMaxAlternates(SPRECOCONTEXTHANDLE hContext, ULONG * pulNumAlts)
{
    SPDBG_FUNC("CRecoMaster::GetContextMaxAlternates");
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pulNumAlts ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CRecoInstCtxt *pCtxt;
        hr = this->m_RecoCtxtHandleTable.GetHandleObject( hContext, &pCtxt );
        if( SUCCEEDED( hr ) )
        {
            *pulNumAlts = pCtxt->m_ulMaxAlternates;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoMaster::IsAlternate *
*--------------------------*
*   Description:
*       This method is used to determine whether one rule is an alternate
*   of the other.
*
*   Returns:
*       S_OK    = hAltRule is an alternate of hRule
*       S_FALSE = hAltRule is not an alternate of hRule
*
******************************************************************** EDC ***/
HRESULT CRecoMaster::IsAlternate( SPRULEHANDLE hPriRule, SPRULEHANDLE hAltRule )
{
    SPDBG_FUNC("CRecoMaster::IsAlternate");
    HRESULT hr = S_OK;
    SPGRAMMARHANDLE hPriGrammar, hAltGrammar;

    hr = m_cpCFGEngine->GetOwnerCookieFromRule( hPriRule, (void **)&hPriGrammar );
    if( ( hr == S_OK ) && ( hPriRule != hAltRule ) )
    {
        hr = m_cpCFGEngine->GetOwnerCookieFromRule( hAltRule, (void **)&hAltGrammar );
        if( SUCCEEDED( hr ) )
        {
            if( hPriGrammar == hAltGrammar )
            {
                hr = S_OK;
            }
            else
            {
                CRecoInstGrammar *pPriGrammar, *pAltGrammar;
                hr = m_GrammarHandleTable.GetHandleObject( hPriGrammar, &pPriGrammar );
                if( SUCCEEDED( hr ) )
                {
                    hr = m_GrammarHandleTable.GetHandleObject( hAltGrammar, &pAltGrammar );
                    if( hr == S_OK && ( pPriGrammar->m_pCtxt != pAltGrammar->m_pCtxt ) )
                    {
                        hr = S_FALSE;
                    }
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CRecoMaster::IsAlternate */

/****************************************************************************
* CRecoMaster::Synchronize *
*--------------------------*
*   Description:
*
*   Returns:
*       S_OK if continue processing
*       S_FALSE if all rules have been deactivated
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::Synchronize(ULONGLONG ullStreamPos)
{
    SPDBG_FUNC("CRecoMaster::Synchronize");
    HRESULT hr = S_OK;

    if (m_fInSynchronize)
    {
        hr = SPERR_REENTER_SYNCHRONIZE;
    }
    else
    {
        m_fInSynchronize = true;

        if (!m_fInStream)
        {
            SPDBG_ASSERT(0);
            hr = SPERR_STREAM_NOT_ACTIVE;
        }

        if (SUCCEEDED(hr))
        {
            SPAUDIOSTATUS Status;
            hr = m_AudioQueue.GetAudioStatus(&Status);

            if(SUCCEEDED(hr) && (
                ullStreamPos > Status.CurSeekPos ||
                ullStreamPos < m_ullLastSyncPos ))
            {
                SPDBG_ASSERT(0);
                hr = SPERR_STREAM_POS_INVALID;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = InternalSynchronize(ullStreamPos);
        }

        m_fInSynchronize = false;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::InternalSynchronize *
*--------------------------*
*   Description:
*       Synchronize call without parameter checking.  The caller of this method
*       must have claimed the object lock exactly one time.
*   Returns:
*       S_OK if continue processing
*       S_FALSE if all rules have been deactivated
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::InternalSynchronize(ULONGLONG ullStreamPos)
{
    SPDBG_FUNC("CRecoMaster::InternalSynchronize");
    HRESULT hr = S_OK;

    hr = UpdateRecoPos(ullStreamPos);

    if (SUCCEEDED(hr))
    {
        m_AudioQueue.DiscardData(ullStreamPos);
        m_ullLastSyncPos = ullStreamPos;
        hr = ProcessPendingTasks();

        //
        //  If we're in the pause state then we need to wait here until we become un-paused
        //
        HANDLE aEvents[] = {m_PendingTaskQueue, m_autohRequestExit};
        while (m_cPause > 0 && 
            (m_RecoState == SPRST_ACTIVE || m_RecoState == SPRST_ACTIVE_ALWAYS))
        {
            Unlock();
            DWORD dwWaitResult = ::WaitForMultipleObjects(sp_countof(aEvents), aEvents, false, INFINITE);
            Lock();
            switch (dwWaitResult)
            {
            case WAIT_OBJECT_0:
                hr = ProcessPendingTasks();
                break;
            case WAIT_OBJECT_0 + 1:
                break;
            default:
                SPDBG_ASSERT(FALSE);
            }
        }
    }

    m_fBookmarkPauseInPending = false;

    if (SUCCEEDED(hr))
    {
        if(m_Status.ulNumActive || m_RecoState == SPRST_ACTIVE_ALWAYS)
        {
            hr = S_OK; // The recognizer should carry on
        }
        else
        {
             // The recognizer can stop
            m_autohRequestExit.SetEvent();
            hr = S_FALSE;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::UpdateRecoPos *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::UpdateRecoPos(ULONGLONG ullStreamPos)
{
    SPDBG_FUNC("CRecoMaster::UpdateRecoPos");
    HRESULT hr = S_OK;

    if (ullStreamPos > m_Status.ullRecognitionStreamPos)
    {
        m_Status.ullRecognitionStreamPos = ullStreamPos;
    }
    CSRTask * pNode;
    while (pNode = m_DelayedTaskQueue.RemoveHead())
    {
        if (pNode->m_ullStreamPos > m_Status.ullRecognitionStreamPos)
        {
            m_DelayedTaskQueue.InsertSorted(pNode);
            break;
        }
        else
        {
            //We need to process the non pause bookmark event
            if (pNode->m_Task.eTask == ECT_BOOKMARK && pNode->m_Task.BookmarkOptions == SPBO_NONE && !m_fBookmarkPauseInPending)
            {
                CRecoInstCtxt * pCtxt;
                hr = m_RecoCtxtHandleTable.GetHandleObject(pNode->m_Task.hRecoInstContext, &pCtxt);
                SPDBG_ASSERT(SUCCEEDED(hr) && pCtxt);
                
                if (SUCCEEDED(hr))
                {
                    // Context initalized successfully
                    if(pCtxt->m_pRecoMaster && SUCCEEDED(pCtxt->m_hrCreation))
                    {
                        hr = pCtxt->ExecuteTask(&pNode->m_Task);

                        if (pNode->m_Task.hCompletionEvent)
                        {
                            pNode->m_Task.Response.hr = hr; // Set up the response HRESULT first...
                            m_CompletedTaskQueue.InsertTail(pNode);
                        }
                        else
                        {
                            delete pNode;
                        }
                    }
                    // else not yet initialized, so add to the pending queue 
                    // - the context creation will be on this queue also so by the time this is processed the context must be iniutalized
                    else if(SUCCEEDED(pCtxt->m_hrCreation))
                    {
                       m_PendingTaskQueue.InsertTail(pNode);
                    }
                    // initialization failed and context is in a zombie state
                    else
                    {
                        if (pNode->m_Task.hCompletionEvent)
                        {
                            pNode->m_Task.Response.hr = pCtxt->m_hrCreation;
                            m_CompletedTaskQueue.InsertTail(pNode);
                        }
                        else
                        {
                            delete pNode;
                        }
                    }
                }
            }
            else
            {
                if (!m_fBookmarkPauseInPending && pNode->m_Task.eTask == ECT_BOOKMARK && pNode->m_Task.BookmarkOptions == SPBO_PAUSE)
                {
                    //The flag is set so that we know there is at least a bookmark pause task in the pending queue
                    //We can't use m_cPause because it is possible that m_cPause is equal to zero when there is still a bookmark pause task in the queue
                    m_fBookmarkPauseInPending = true;
                }
                m_PendingTaskQueue.InsertTail(pNode);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRecoMaster::Read *
*-------------------*
*   Description:
*       Simple helper function that checks recomaster status in a thread-safe way
*
*   Returns:
*
*************************************************************** DAVEWOOD */

HRESULT CRecoMaster::Read(void * pv, ULONG cb, ULONG * pcbRead)
{
    SPDBG_FUNC("CRecoMaster::Read");
    HRESULT hr = S_OK;

    if (m_fInStream)
    {
        hr = m_AudioQueue.SRSiteRead(pv, cb, pcbRead);
        
        // If we encountered an error, turn recognition off
        if (!IsStreamRestartHresult(hr) &&
            FAILED(hr))
        {
            SPAUTO_OBJ_LOCK;
            m_RecoState = SPRST_INACTIVE;
            AddRecoStateEvent();
        }
    }
    else
    {
        SPDBG_ASSERT(0);
        hr = SPERR_STREAM_NOT_ACTIVE;
    }

    if (!IsStreamRestartHresult(hr))
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }

    return hr;
}

/****************************************************************************
* CRecoMaster::DataAvailable *
*----------------------------*
*   Description:
*       Simple helper function that checks recomaster status in a thread-safe way
*
*   Returns:
*
*************************************************************** DAVEWOOD */

HRESULT CRecoMaster::DataAvailable(ULONG * pcb)
{
    SPDBG_FUNC("CRecoMaster::DataAvailable");
    HRESULT hr = S_OK;

    if(m_fInStream)
    {
        hr = m_AudioQueue.SRSiteDataAvailable(pcb);
    }
    else
    {
        SPDBG_ASSERT(0);
        hr = SPERR_STREAM_NOT_ACTIVE;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::ProcessEventNotification *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::ProcessEventNotification(CSREvent * pEvent)
{
    SPDBG_FUNC("CRecoMaster::ProcessEventNotification");
    HRESULT hr = S_OK;

    CRecoInstCtxt * p;
    if (pEvent->m_pEvent)
    {
        if (pEvent->m_hContext)
        {
            if (SUCCEEDED(m_RecoCtxtHandleTable.GetHandleObject(pEvent->m_hContext, &p)) &&
                (p->m_ullEventInterest & (1i64 << pEvent->m_pEvent->eEventId)) )
            {
                p->m_pRecoInst->EventNotify(p->m_hThis, pEvent->m_pEvent, pEvent->m_cbEvent);
            }
        }
        else
        {
            SPRECOCONTEXTHANDLE h;
            m_RecoCtxtHandleTable.First(&h, &p);
            while (p)
            {
                // Always pass request UI events upwards to contexts as they need the information
                // to update the recocontext status.
                if ((p->m_ullEventInterest & (1i64 << pEvent->m_pEvent->eEventId)) ||
                    (pEvent->m_pEvent->eEventId == SPEI_REQUEST_UI))
                {
                    p->m_pRecoInst->EventNotify(p->m_hThis, pEvent->m_pEvent, pEvent->m_cbEvent);
                }
                m_RecoCtxtHandleTable.Next(h, &h, &p);
            }
        }
    }
    else    // Must be a recognition event
    {
        hr = m_RecoCtxtHandleTable.GetHandleObject(pEvent->m_hContext, &p);
        if (SUCCEEDED(hr))
        {
            hr = p->m_pRecoInst->RecognitionNotify(p->m_hThis, pEvent->m_pResultHeader,
                pEvent->m_RecoFlags,
                pEvent->m_eRecognitionId);
            // NOTE:  Even if RecognitionNotify fails for some reason, it is the responsibility of
            //        RecognitionNotify to free the memory.  We must NULL this member so we will
            //        not try to CoTaskMemFree it twice.
            SPDBG_ASSERT(SUCCEEDED(hr));
            pEvent->m_pResultHeader = NULL;  // Now ownership was given to the context.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::ProcessTaskCompleteNotification *
*--------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::ProcessTaskCompleteNotification(CSRTask * pTask)
{
    SPDBG_FUNC("CRecoMaster::ProcessTaskCompleteNotification");
    HRESULT hr = S_OK;

    if (pTask->m_Task.fAdditionalBufferInResponse)
    {
        hr = pTask->m_pRecoInst->TaskCompletedNotify(&pTask->m_Task.Response, pTask->m_Task.pvAdditionalBuffer, pTask->m_Task.cbAdditionalBuffer);
    }
    else
    {
        if (pTask->m_Task.fExpectCoMemResponse)
        {
            hr = pTask->m_pRecoInst->TaskCompletedNotify(&pTask->m_Task.Response, pTask->m_Task.Response.pvCoMemResponse, pTask->m_Task.Response.cbCoMemResponse);
        }
        else
        {
            hr = pTask->m_pRecoInst->TaskCompletedNotify(&pTask->m_Task.Response, NULL, 0);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRecoMaster::OutgoingDataThreadProc *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::OutgoingDataThreadProc(HANDLE hExitThreadEvent, HANDLE hNotifyEvent)
{
    SPDBG_FUNC("CRecoMaster::OutgoingDataThreadProc");
    HRESULT hr = S_OK;

    HANDLE aEvents[] = {hExitThreadEvent, hNotifyEvent, m_EventQueue, m_CompletedTaskQueue};
    bool fContinue = true;

    while (fContinue)
    {
        DWORD dwWait = ::WaitForMultipleObjects(sp_countof(aEvents), aEvents, FALSE, INFINITE);
        m_OutgoingWorkCrit.Lock();
        switch (dwWait)
        {
        case WAIT_OBJECT_0: // Exit thread
            hr = S_OK;
            fContinue = false;
            break;
        case WAIT_OBJECT_0 + 1: // Notify -- Process any events from the audio object
            {
                CSpEvent SpEvent;
                while(TRUE)
                {
                    hr = m_AudioQueue.GetAudioEvent(SpEvent.AddrOf());
                    if(hr != S_OK)
                    {
                        break;
                    }
            
                    // Audio input doesn't know about streams so add
                    SpEvent.ulStreamNum = m_Status.ulStreamNumber;
                    CSREvent CEvent;
                    hr = CEvent.Init(&SpEvent, NULL);
                    if(SUCCEEDED(hr))
                    {
                        hr = ProcessEventNotification(&CEvent);
                    }
                }
            }
            break;
        case WAIT_OBJECT_0 + 2:     // Event
            {
                for (CSREvent * pNode = m_EventQueue.RemoveHead(); pNode; pNode = m_EventQueue.RemoveHead())
                {
                    hr = ProcessEventNotification(pNode);
                    delete pNode;
                }
            }
            break;
        case WAIT_OBJECT_0 + 3:     // Task completed
            {
                for (CSRTask * pNode = m_CompletedTaskQueue.RemoveHead();
                     pNode;
                     pNode = m_CompletedTaskQueue.RemoveHead())
                {
                    hr = ProcessTaskCompleteNotification(pNode);
                    delete pNode;
                }
            }
        }
        m_OutgoingWorkCrit.Unlock();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRecoMaster::UpdateAllGrammarStates *
*-------------------------------------*
*   Description:
*       This method walks all of the grammars, and first checks for active
*   exclusive grammars.  After updating the m_fIsActiveExclusiveGrammar
*   member variable, it calls every grammar to update their rule state.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::UpdateAllGrammarStates()
{
    SPDBG_FUNC("CRecoMaster::UpdateAllGrammarStates");
    HRESULT hr = S_OK;

    SPGRAMMARHANDLE h;
    CRecoInstGrammar * pGrammar;

    this->m_fIsActiveExclusiveGrammar = false;
    this->m_GrammarHandleTable.First(&h, &pGrammar);
    while (pGrammar)
    {
        if (pGrammar->m_pRecoMaster &&
            pGrammar->m_GrammarState == SPGS_EXCLUSIVE &&
            pGrammar->m_pCtxt->m_State == SPCS_ENABLED)
        {
            this->m_fIsActiveExclusiveGrammar = true;
            break;
        }
        m_GrammarHandleTable.Next(h, &h, &pGrammar);
    }

    this->m_GrammarHandleTable.First(&h, &pGrammar);
    while (pGrammar)
    {
        if(pGrammar->m_pRecoMaster)
        {
            HRESULT hrEngine = pGrammar->AdjustActiveRuleCount();
            if (hr == S_OK && FAILED(hrEngine))
            {
                hr = hrEngine;
            }
        }
        m_GrammarHandleTable.Next(h, &h, &pGrammar);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRecoMaster::SetGrammarState *
*------------------------------*
*   Description:
*       This method is imlemented here in the RecoMaster because setting the
*   state of a single grammar can change rule settings for other grammars.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::SetGrammarState(CRecoInstGrammar * pGrammar, SPGRAMMARSTATE NewState)
{
    SPDBG_FUNC("CRecoMaster::SetGrammarState");
    HRESULT hr = S_OK;
    
    if (pGrammar->m_GrammarState != NewState)
    {
        //
        //  Adjust our internal state prior to calling the engine so that the method
        //  IsGrammarActive() will return the appropriate information.
        //
        // If we're transitioning either to or from the exclusive state while our
        // context is active, we need to adjust all of the grammar states, otherwise
        // just adjust our own.
        //
        SPGRAMMARSTATE OldState = pGrammar->m_GrammarState;
        pGrammar->m_GrammarState = NewState;

        if (pGrammar->m_pCtxt->m_State == SPCS_ENABLED)
        {
            if (OldState == SPGS_EXCLUSIVE || NewState == SPGS_EXCLUSIVE)
            {
                hr = UpdateAllGrammarStates();
            }
            else
            {
                hr = pGrammar->AdjustActiveRuleCount();
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = SetGrammarState(pGrammar->m_pvDrvGrammarCookie, NewState);
        }

        if (FAILED(hr))
        {
            pGrammar->m_GrammarState = OldState;
            UpdateAllGrammarStates();
        }

    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRecoMaster::IsGrammarActive *
*------------------------------*
*   Description:
*       This method is only useful for engines that support proprietary
*       grammars.  If the rules in a grammar should be active, then this
*       function will return S_OK.  If they are inactive, it will return S_FALSE.
*       If an engine does not use propritary grammars there is no need to call
*       this method since SAPI automatically sets individual rule states to
*       active or inactive when grammar or context states change.
*
*   Returns:
*       S_OK - Proprietary grammar rules should be active for this grammar
*       S_FALSE - Grammar rules should not be active
*       SPERR_INVALID_HANDLE - hGrammar is invalid
*
********************************************************************* RAL ***/

HRESULT CRecoMaster::IsGrammarActive(SPGRAMMARHANDLE hGrammar)
{
    SPDBG_FUNC("CRecoMaster::IsGrammarActive");
    HRESULT hr = S_OK;

    CRecoInstGrammar * pGrammar;
    hr = this->m_GrammarHandleTable.GetHandleObject(hGrammar, &pGrammar);
    if (SUCCEEDED(hr))
    {
        if (pGrammar->m_fRulesCounted)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srrecomaster.h ===
/******************************************************************************
* RecoMaster.h *
*--------------*
*  This is the header file for the CRecoMaster implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#ifndef __RecoMaster_h__
#define __RecoMaster_h__



#include "recognizer.h"
#include "srtask.h"
#include "srevent.h"
#include "sraudio.h"
#include "srRecoInst.h"
#include "srRecoInstCtxt.h"
#include "srRecoInstgrammar.h"
#include "srRecoInst.h"
#include "SpTryCritSec.h"

class CRecoMasterSite;

//
//  NOTE:  Everything is public in this class since the various tasks need access and it's
//         just too much of a pain to make them all friends.
//

class ATL_NO_VTABLE CRecoMaster :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CRecoMaster, &CLSID__SpRecoMaster>,
    public _ISpRecoMaster,
    public ISpThreadTask
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SRRECOMASTER)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CRecoMaster)
        COM_INTERFACE_ENTRY(_ISpRecoMaster)
        COM_INTERFACE_ENTRY(ISpSREngine)
    END_COM_MAP()

    enum ThreadId
    {
        TID_OutgoingData,
        TID_IncomingData
    };

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CRecoMaster();
    HRESULT FinalConstruct();
    void FinalRelease();
    BOOL ShouldStartStream();

    // --- Internal helper functions
    BOOL    IsActiveExclusiveGrammar()
    {
        return m_fIsActiveExclusiveGrammar;
    }
    HRESULT CleanUpPairedEvents(void);
    HRESULT UpdateAudioEventInterest(void);
    HRESULT IncomingDataThreadProc(HANDLE hExitThreadEvent);
    HRESULT OutgoingDataThreadProc(HANDLE hExitThreadEvent, HANDLE hNotifyEvent);
    HRESULT ProcessPendingTasks();
    HRESULT ProcessEventNotification(CSREvent * pEvent);
    HRESULT ProcessTaskCompleteNotification(CSRTask * pTask);
    void    ReleaseEngine();
    HRESULT LazyInitEngine();
    HRESULT InitEngineStatus();
    HRESULT InitGUID(const WCHAR * pszValueName, GUID * pDestGUID);
    HRESULT StartStream(CSRTask * pTaskThatStartedStream);
    HRESULT BackOutTask(CSRTask * pTask);
    HRESULT InitInputStream( void );
    HRESULT GetAltSerializedPhrase(ISpPhrase * pAlt, SPSERIALIZEDPHRASE ** ppSerPhrase, ULONGLONG ullBestPathGrammarID);
    HRESULT SendResultToCtxt(SPEVENTENUM eEventId, const SPRECORESULTINFO * pResult, CRecoInstCtxt * pCtxt, ULONGLONG ullApplicationGrammarId, BOOL fPause, BOOL fEmulated);
    HRESULT SendFalseReco(const SPRECORESULTINFO * pResult, BOOL fEmulated, CRecoInstCtxt *pCtxtIgnore = NULL);
    HRESULT SetInput(ISpObjectToken * pToken, ISpStreamFormat * pStream, BOOL fAllowFormatChanges);
    HRESULT Read(void * pv, ULONG cb, ULONG * pcbRead);
    HRESULT DataAvailable(ULONG * pcb);
    HRESULT InternalAddEvent(const SPEVENT* pEvent, SPRECOCONTEXTHANDLE hContext);
    HRESULT InternalRecognition(const SPRECORESULTINFO * pResultInfo, BOOL fCallSynchronize, BOOL fEmulated);
    HRESULT InternalSynchronize(ULONGLONG ullStreamPos);
    HRESULT SetGrammarState(CRecoInstGrammar * pGrammar, SPGRAMMARSTATE NewState);
    HRESULT UpdateAllGrammarStates();
    HRESULT CompleteDelayedRecoInactivate();
    HRESULT AddRecoStateEvent();
    HRESULT SendEmulateRecognition(SPRECORESULTINFO *pResult, ENGINETASK *pTask, CRecoInst * pRecoInst);
    HRESULT RemoveRecoInst(CRecoInst * pInstToRemove);

    //--- _ISpRecognizerPrivate ---------------------------------------------------
    STDMETHODIMP PerformTask(CRecoInst * pSenderInst, ENGINETASK *pTask);
    STDMETHODIMP AddRecoInst(CRecoInst * pNewInst, BOOL fShared, CRecoMaster ** ppThis);

    //--- ISpSREngineSite -- Note, we implement these, but the CEngineSite calls them directly.
    HRESULT Synchronize(ULONGLONG ullProcessedThruPos);
    HRESULT UpdateRecoPos(ULONGLONG ullRecoPos);
    HRESULT Recognition(const SPRECORESULTINFO * pResultInfo);
    HRESULT AddEvent(const SPEVENT* pEvent, SPRECOCONTEXTHANDLE hContext);
    HRESULT IsAlternate( SPRULEHANDLE hRule, SPRULEHANDLE hAltRule );
    HRESULT GetMaxAlternates( SPRULEHANDLE hRule, ULONG* pulNumAlts );
    HRESULT GetContextMaxAlternates( SPRECOCONTEXTHANDLE hContext, ULONG * pulNumAlts);
    HRESULT IsGrammarActive(SPGRAMMARHANDLE hGrammar);

    //--- ISpThreadTask -------------------------------------------------------
    STDMETHODIMP InitThread(void *, HWND);
    STDMETHODIMP ThreadProc(void * pvThreadId, HANDLE hExitThreadEvent,
                            HANDLE hNotifyEvent, HWND hwndIgnored,
                            volatile const BOOL * pfContinueProcessing);
    STDMETHODIMP_(LRESULT) WindowMessage(void *, HWND, UINT, WPARAM, LPARAM);

    //--- ISpSREngine -------------------------------------------------------
    STDMETHODIMP SetRecoProfile(ISpObjectToken * pProfileToken)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetRecoProfile(pProfileToken);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetSite(ISpSREngineSite *pSite)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetSite(pSite);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP GetInputAudioFormat(const GUID * pSrcFormatId, const WAVEFORMATEX * pSrcWFEX, GUID * pDesiredFormatId, WAVEFORMATEX ** ppCoMemDesiredWFEX)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->GetInputAudioFormat(pSrcFormatId, pSrcWFEX, pDesiredFormatId, ppCoMemDesiredWFEX);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP OnCreateRecoContext(SPRECOCONTEXTHANDLE hSAPIRecoContext, void ** ppvDrvCtxt)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->OnCreateRecoContext(hSAPIRecoContext, ppvDrvCtxt);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP OnDeleteRecoContext(void * pvDrvCtxt)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->OnDeleteRecoContext(pvDrvCtxt);
        } SR_EXCEPT; Lock(); return hr;
    }
	STDMETHODIMP OnCreateGrammar(void * pvEngineRecoContext, SPGRAMMARHANDLE hSAPIGrammar, void ** ppvEngineGrammar)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->OnCreateGrammar(pvEngineRecoContext, hSAPIGrammar, ppvEngineGrammar);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP OnDeleteGrammar(void * pvEngineGrammar)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->OnDeleteGrammar(pvEngineGrammar);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP WordNotify(SPCFGNOTIFY Action, ULONG cWords, const SPWORDENTRY * pWords)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->WordNotify(Action, cWords, pWords);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP RuleNotify(SPCFGNOTIFY Action, ULONG cRules, const SPRULEENTRY * pRules)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->RuleNotify(Action, cRules, pRules);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP LoadProprietaryGrammar(void * pvEngineGrammar, REFGUID rguidParam, const WCHAR * pszStringParam, const void * pvDataParam, ULONG ulDataSize, SPLOADOPTIONS Options)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->LoadProprietaryGrammar(pvEngineGrammar, rguidParam, pszStringParam, pvDataParam, ulDataSize, Options);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP UnloadProprietaryGrammar(void * pvEngineGrammar)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->UnloadProprietaryGrammar(pvEngineGrammar);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetProprietaryRuleState(void * pvEngineGrammar, const WCHAR * pszName, void * pvReserved, SPRULESTATE NewState, ULONG * pcRulesChanged)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetProprietaryRuleState(pvEngineGrammar, pszName, pvReserved, NewState, pcRulesChanged);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetProprietaryRuleIdState(void * pvEngineGrammar, DWORD dwRuleId, SPRULESTATE NewState)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetProprietaryRuleIdState(pvEngineGrammar, dwRuleId, NewState);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetGrammarState(void * pvEngineGrammar, SPGRAMMARSTATE eGrammarState)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetGrammarState(pvEngineGrammar, eGrammarState);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetContextState(void * pvEngineContxt, SPCONTEXTSTATE eCtxtState)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetContextState(pvEngineContxt, eCtxtState);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP LoadSLM(void * pvEngineGrammar, const WCHAR * pszTopicName)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->LoadSLM(pvEngineGrammar, pszTopicName);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP UnloadSLM(void * pvEngineGrammar)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->UnloadSLM(pvEngineGrammar);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetSLMState(void * pvEngineGrammar, SPRULESTATE NewState)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetSLMState(pvEngineGrammar, NewState);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP IsPronounceable(void *pDrvGrammar, const WCHAR *pszWord, SPWORDPRONOUNCEABLE * pWordPronounceable)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->IsPronounceable(pDrvGrammar, pszWord, pWordPronounceable);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetWordSequenceData(void * pvEngineGrammar, const WCHAR * pText, ULONG cchText, const SPTEXTSELECTIONINFO * pInfo)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetWordSequenceData(pvEngineGrammar, pText, cchText, pInfo);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetTextSelection(void * pvEngineGrammar, const SPTEXTSELECTIONINFO * pInfo)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetTextSelection( pvEngineGrammar, pInfo);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetAdaptationData(void * pvEngineCtxtCookie, const WCHAR * pText, const ULONG cch)    
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetAdaptationData(pvEngineCtxtCookie, pText, cch);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetPropertyNum(SPPROPSRC eSrc, void* pvSrcObj, const WCHAR* pName, LONG lValue)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetPropertyNum(eSrc, pvSrcObj, pName, lValue);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP GetPropertyNum(SPPROPSRC eSrc, void* pvSrcObj, const WCHAR* pName, LONG * plValue)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->GetPropertyNum(eSrc, pvSrcObj, pName, plValue);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP SetPropertyString(SPPROPSRC eSrc, void* pvSrcObj, const WCHAR* pName, const WCHAR* pValue)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->SetPropertyString(eSrc, pvSrcObj, pName, pValue);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP GetPropertyString(SPPROPSRC eSrc, void* pvSrcObj, const WCHAR* pName, WCHAR** ppCoMemValue)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->GetPropertyString(eSrc, pvSrcObj, pName, ppCoMemValue);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP RecognizeStream(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx, HANDLE hRequestSync, HANDLE hDataAvailable, HANDLE hExit, BOOL fNewAudioStream, BOOL fRealTimeAudio, ISpObjectToken * pAudioObjectToken)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->RecognizeStream(rguidFmtId, pWaveFormatEx, hRequestSync, hDataAvailable, hExit, fNewAudioStream, fRealTimeAudio, pAudioObjectToken);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP PrivateCall(void * pvEngineContext, void * pCallFrame, ULONG ulCallFrameSize)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->PrivateCall( pvEngineContext, pCallFrame, ulCallFrameSize);
        } SR_EXCEPT; Lock(); return hr;
    }
    STDMETHODIMP PrivateCallEx(void * pvEngineContext, const void * pInCallFrame, ULONG ulCallFrameSize, void ** ppvCoMemResponse, ULONG * pcbResponse)
    {
        HRESULT hr; Unlock(); SR_TRY {
            hr = m_cpEngine->PrivateCallEx(pvEngineContext, pInCallFrame, ulCallFrameSize, ppvCoMemResponse, pcbResponse);
        } SR_EXCEPT; Lock(); return hr;
    }



  //=== Member data ===
  public:
    CTryableCriticalSection         m_OutgoingWorkCrit;
    CLSID                           m_clsidAlternates;    
    BOOL                            m_fShared;
    CAudioQueue                     m_AudioQueue;
    SPRECOSTATE                     m_RecoState;
    ULONG                           m_cPause;
    bool                           m_fBookmarkPauseInPending;
    bool                            m_fInStream;

    bool                            m_fInFinalRelease;
    bool                            m_fInSynchronize;

    // Data used to make sure events etc. happen in correct order
    bool                            m_fInSound;
    bool                            m_fInPhrase;
    ULONGLONG                       m_ullLastSyncPos;
    ULONGLONG                       m_ullLastSoundStartPos;
    ULONGLONG                       m_ullLastSoundEndPos;
    ULONGLONG                       m_ullLastPhraseStartPos;
    ULONGLONG                       m_ullLastRecoPos;

    CSpAutoEvent                    m_autohRequestExit;    
    CRecoInstCtxtHandleTable        m_RecoCtxtHandleTable;
    CRecoInstGrammarHandleTable     m_GrammarHandleTable;
    BOOL                            m_fIsActiveExclusiveGrammar;
    CSREventQueue                   m_EventQueue;
    CSRTaskQueue                    m_CompletedTaskQueue;
    CSRTaskQueue                    m_PendingTaskQueue;
    CSRTaskQueue                    m_DelayedTaskQueue;
    CSRTaskQueue                    m_DelayedInactivateQueue;
    CComPtr<ISpThreadControl>       m_cpIncomingThread; 
    CComPtr<ISpThreadControl>       m_cpOutgoingThread; 
    CComPtr<ISpCFGEngine>           m_cpCFGEngine;
    CComPtr<ISpSREngineSite>        m_cpSite;
    CComPtr<ISpSREngine>            m_cpEngine;
    CComPtr<ISpObjectToken>         m_cpRecoProfileToken;
    CComPtr<ISpObjectToken>         m_cpEngineToken;
    SPRECOGNIZERSTATUS              m_Status;
    CSpBasicQueue<CRecoInst>        m_InstList;
    CSpDynamicString                m_dstrRequestTypeOfUI;
};


class ATL_NO_VTABLE CRecoMasterSite :
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpSREngineSite
{
private:
    CRecoMaster     *m_pRecoMaster;   // weak pointer

public:

BEGIN_COM_MAP(CRecoMasterSite)
    COM_INTERFACE_ENTRY(ISpSREngineSite)
END_COM_MAP()

    void Init(CRecoMaster *pParent)
    {
        m_pRecoMaster = pParent;
    }

    //
    //  ISpSREngineSite
    //
    STDMETHODIMP GetWordInfo(SPWORDENTRY * pWordEntry, SPWORDINFOOPT Options)
    { 
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->GetWordInfo(pWordEntry, Options);
    }

    STDMETHODIMP SetWordClientContext(SPWORDHANDLE hWord, void * pvClientContext)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->SetWordClientContext(hWord, pvClientContext);
    }

    STDMETHODIMP GetRuleInfo(SPRULEENTRY * pRuleEntry, SPRULEINFOOPT Options)
    { 
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->GetRuleInfo(pRuleEntry, Options);
    }

    STDMETHODIMP SetRuleClientContext(SPRULEHANDLE hRule, void * pvClientContext)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->SetRuleClientContext(hRule, pvClientContext);
    }

    STDMETHODIMP GetStateInfo(SPSTATEHANDLE hState, SPSTATEINFO * pStateInfo)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->GetStateInfo(hState, pStateInfo);
    }

    STDMETHODIMP ParseFromTransitions(const SPPARSEINFO * pParseInfo,
                                      ISpPhraseBuilder ** ppPhraseBuilder)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->ParseFromTransitions(pParseInfo, ppPhraseBuilder);
    }
            
    STDMETHODIMP GetResource(SPRULEHANDLE hRule, const WCHAR *pszResourceName, WCHAR ** ppsz)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->GetResourceValue(hRule, pszResourceName, ppsz);
    }

    STDMETHODIMP Synchronize(ULONGLONG ullProcessedThruPos)
    { 
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->Synchronize(ullProcessedThruPos);
    }

    STDMETHODIMP Recognition(const SPRECORESULTINFO * pResultInfo)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->Recognition(pResultInfo); 
    }

    STDMETHODIMP AddEvent(const SPEVENT* pEvent, SPRECOCONTEXTHANDLE hSAPIRecoContext)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->AddEvent(pEvent, hSAPIRecoContext); 
    }

    STDMETHODIMP Read(void * pv, ULONG cb, ULONG * pcbRead)
    {
        // NOTE:  We do NOT take the object lock on this site method since it blocks
        return m_pRecoMaster->Read(pv, cb, pcbRead); 
    }

    STDMETHODIMP DataAvailable(ULONG * pcb)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->DataAvailable(pcb);
    }

    STDMETHODIMP SetBufferNotifySize(ULONG cb)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_AudioQueue.SetBufferNotifySize(cb);
    }

    STDMETHODIMP GetTransitionProperty(SPTRANSITIONID ID, SPTRANSITIONPROPERTY **ppCoMemProperty)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->m_cpCFGEngine->GetTransitionProperty(ID, ppCoMemProperty);
    }

    STDMETHODIMP IsAlternate( SPRULEHANDLE hRule, SPRULEHANDLE hAltRule )
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->IsAlternate( hRule, hAltRule );
    }
    STDMETHODIMP GetMaxAlternates( SPRULEHANDLE hRule, ULONG* pulNumAlts )
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->GetMaxAlternates( hRule, pulNumAlts );
    }
    STDMETHODIMP GetContextMaxAlternates( SPRECOCONTEXTHANDLE hContext, ULONG * pulNumAlts )
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->GetContextMaxAlternates( hContext, pulNumAlts );
    }
    STDMETHODIMP UpdateRecoPos(ULONGLONG ullRecoPos)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->UpdateRecoPos(ullRecoPos);
    }
    STDMETHODIMP IsGrammarActive(SPGRAMMARHANDLE hGrammar)
    {
        SPAUTO_OBJ_LOCK_OBJECT(m_pRecoMaster);
        return m_pRecoMaster->IsGrammarActive(hGrammar);
    }
};

#endif  // #ifndef __RecoMaster_h__ - Keep as the last line of the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srtask.cpp ===
/******************************************************************************
* SRTask.cpp *
*------------*
*  This is the implementation of CSRTask.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#include "stdafx.h"
#include "recognizer.h"
#include "SrTask.h"
#include "SrRecoMaster.h"


/*****************************************************************************
* CSRTask::Init *
*---------------*
*   Description:
*       Initialize a CSRTask by making a copy of the ENGINETASK structure
*       and if this is an async task, then copy any other data that might
*       not be present when we're ready to process this task.
********************************************************************* RAL ***/

HRESULT CSRTask::Init(CRecoInst * pSender, const ENGINETASK *pSrcTask)
{
    SPDBG_FUNC("CSRTask::Init");
    HRESULT hr = S_OK;

    m_pRecoInst = pSender;
    m_Task = *pSrcTask;

    if (m_Task.cbAdditionalBuffer)
    {
        m_Task.pvAdditionalBuffer = ::CoTaskMemAlloc(m_Task.cbAdditionalBuffer);
        if (m_Task.pvAdditionalBuffer)
        {
            memcpy((void *)m_Task.pvAdditionalBuffer, pSrcTask->pvAdditionalBuffer, m_Task.cbAdditionalBuffer);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        SPDBG_ASSERT(m_Task.pvAdditionalBuffer == NULL);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSRTask::CreateResponse *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSRTask::CreateResponse(CSRTask ** ppResponseTask)
{
    SPDBG_FUNC("CSRTask::CreateResponse");
    HRESULT hr = S_OK;

    *ppResponseTask = new CSRTask();
    if (*ppResponseTask)
    {
        this->m_Task.Response.hr = S_OK;
        **ppResponseTask = *this;
        (*ppResponseTask)->m_Task.pvAdditionalBuffer = NULL;
        (*ppResponseTask)->m_Task.cbAdditionalBuffer = 0;
        this->m_Task.hCompletionEvent = NULL;  // Indicate that we should not respond to this one
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/*****************************************************************************
* CSRTask::~CSRTask *
*-------------------*
*   Description:
*       Destructor needs to release any extra data blocks that were allocated
*       if this was an async task.
********************************************************************* RAL ***/

CSRTask::~CSRTask()
{
    ::CoTaskMemFree(m_Task.pvAdditionalBuffer);

    if (m_Task.fExpectCoMemResponse)
  	{
    	::CoTaskMemFree(m_Task.Response.pvCoMemResponse);
    }
}


/****************************************************************************
* CRIT_GETRECOINSTSTATUS::GetStatus *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETRECOINSTSTATUS::GetStatus(_ISpRecognizerBackDoor * pRecognizer, SPRECOGNIZERSTATUS * pStatus)
{
    SPDBG_FUNC("CRIT_GETRECOINSTSTATUS::GetStatus");
    HRESULT hr = S_OK;

    CRIT_GETRECOINSTSTATUS Task;
    hr = pRecognizer->PerformTask(&Task);
    *pStatus = Task.Response.RecoInstStatus;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETRECOINSTSTATUS::Execute *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETRECOINSTSTATUS::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETRECOINSTSTATUS::Execute");
    HRESULT hr = S_OK;

    hr = pRecoInst->Master()->LazyInitEngine();
    if (SUCCEEDED(hr))
    {
        this->Response.RecoInstStatus = pRecoInst->Master()->m_Status;
        hr = pRecoInst->Master()->m_AudioQueue.GetAudioStatus(&this->Response.RecoInstStatus.AudioStatus);
    }
    else
    {
        memset(&this->Response.RecoInstStatus, 0, sizeof(this->Response.RecoInstStatus));
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETAUDIOFORMAT::GetFormat *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETAUDIOFORMAT::GetFormat(_ISpRecognizerBackDoor * pRecognizer, SPSTREAMFORMATTYPE FormatType, GUID *pFormatId, WAVEFORMATEX **ppCoMemWFEX)
{
    SPDBG_FUNC("CRIT_GETAUDIOFORMAT::GetFormat");
    HRESULT hr = S_OK;

    CRIT_GETAUDIOFORMAT Task;
    Task.AudioFormatType = FormatType;
    Task.fExpectCoMemResponse = TRUE;
    hr = pRecognizer->PerformTask(&Task);

    *pFormatId = GUID_NULL;
    *ppCoMemWFEX = NULL;
    if (SUCCEEDED(hr))
    {
        CSpStreamFormat Fmt;
        ULONG cbUsed;
        hr = Fmt.Deserialize(static_cast<BYTE *>(Task.Response.pvCoMemResponse), &cbUsed);
        if (SUCCEEDED(hr))
        {
            Fmt.DetachTo(pFormatId, ppCoMemWFEX);
        }
        ::CoTaskMemFree(Task.Response.pvCoMemResponse);
    }   

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}




/****************************************************************************
* CRIT_GETAUDIOFORMAT::Execute *
*------------------------------*
*   Description:
*       Returns the format for either the SR engine or for the input stream.
*       If there is no input stream in the shared case, this 
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETAUDIOFORMAT::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETAUDIOFORMAT::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();

    hr = pMaster->LazyInitEngine();

    if (SUCCEEDED(hr) && !pMaster->m_AudioQueue.HaveInputStream())
    {
        if (pMaster->m_fShared)
        {
            // Get the default audio stream
            hr = pRecoInst->Master()->SetInput(NULL, NULL, TRUE);
        }
        else
        {
            if (this->AudioFormatType == SPWF_INPUT)
            {
                hr = SPERR_UNINITIALIZED;
            }
            // else we'll get engine's default format below...
        }
    }
    
    if(SUCCEEDED(hr))
    {
        if (pMaster->m_AudioQueue.HaveInputStream())
        {
            hr = pRecoInst->Master()->m_AudioQueue.NegotiateInputStreamFormat(pMaster);
        }
        else
        {
            SPDBG_ASSERT(this->AudioFormatType == SPWF_SRENGINE);
            hr = pMaster->m_AudioQueue.GetEngineFormat(pMaster, NULL);
        }
    }
    
    if( SUCCEEDED( hr ) )
    {
        const CSpStreamFormat & Fmt = (this->AudioFormatType == SPWF_INPUT) ? 
            pRecoInst->Master()->m_AudioQueue.InputFormat() :
            pRecoInst->Master()->m_AudioQueue.EngineFormat();

        ULONG cb = Fmt.SerializeSize();
        this->Response.pvCoMemResponse = ::CoTaskMemAlloc(cb);
        if (this->Response.pvCoMemResponse)
        {
            Fmt.Serialize(static_cast<BYTE *>(this->Response.pvCoMemResponse));
            this->Response.cbCoMemResponse = cb;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETRECOSTATE::SetState *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETRECOSTATE::SetState(_ISpRecognizerBackDoor * pRecognizer, SPRECOSTATE NewState)
{
    SPDBG_FUNC("CRIT_SETRECOSTATE::SetState");
    HRESULT hr = S_OK;

    CRIT_SETRECOSTATE Task;
    Task.NewState = NewState;
    hr = pRecognizer->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETRECOSTATE::Execute *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETRECOSTATE::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETRECOSTATE::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();

    SPRECOSTATE FinalState = (this->NewState == SPRST_INACTIVE_WITH_PURGE) ? SPRST_INACTIVE : this->NewState;

    if (pMaster->m_RecoState != FinalState)
    {
        pMaster->CompleteDelayedRecoInactivate();   // Do this BEFORE setting new state
        pMaster->m_RecoState = FinalState;
        //
        //  Deactivations while in a stream will be completed when the stream
        //  stops and the event will be sent then, so only send reco state change
        //  events if we're not inactive or we're not in a stream.
        //
        if (FinalState != SPRS_INACTIVE || (!pMaster->m_fInStream))
        {
            pMaster->AddRecoStateEvent();
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETRECOSTATE::BackOut *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETRECOSTATE::BackOut(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETRECOSTATE::BackOut");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();

    pMaster->m_RecoState = SPRST_INACTIVE;
    hr = pMaster->AddRecoStateEvent();

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRIT_GETRECOSTATE::GetState *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETRECOSTATE::GetState(_ISpRecognizerBackDoor * pRecognizer, SPRECOSTATE * pState)
{
    SPDBG_FUNC("CRIT_GETRECOSTATE::GetState");
    HRESULT hr = S_OK;

    CRIT_GETRECOSTATE Task;
    hr = pRecognizer->PerformTask(&Task);
    *pState = Task.Response.RecoState;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETRECOSTATE::ExecuteFirstPart *
*----------------------------*
*   Description:
*
*   Returns:
*
**************************************************************** DAVEWOOD ***/

HRESULT CRIT_GETRECOSTATE::ExecuteFirstPart(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETRECOSTATE::ExecuteFirstPart");
    HRESULT hr = S_OK;

    this->Response.RecoState = pRecoInst->Master()->m_RecoState;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETRECOSTATE::Execute *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETRECOSTATE::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETRECOSTATE::Execute");

    // Normally we would check if the first part had already been executed (i.e. when doing
    //  asynch tasks while in stream, and not do again. Since this result will be discarded
    //  in that case, and we don't currently have a good way of telling if the first part is done,
    //  we repeat the call.
    HRESULT hr = ExecuteFirstPart(pRecoInst);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_EMULATERECOGNITION::EmulateReco *
*--------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_EMULATERECOGNITION::EmulateReco(_ISpRecognizerBackDoor * pRecognizer, ISpPhrase * pPhrase)
{
    SPDBG_FUNC("CRIT_EMULATERECOGNITION::EmulateReco");
    HRESULT hr = S_OK;

    CSpCoTaskMemPtr<SPSERIALIZEDPHRASE> cpSerData;
    hr = pPhrase->GetSerializedPhrase(&cpSerData);

    if (SUCCEEDED(hr))
    {
        CRIT_EMULATERECOGNITION Task;
        Task.pvAdditionalBuffer = cpSerData;
        Task.cbAdditionalBuffer = cpSerData->ulSerializedSize;
        hr = pRecognizer->PerformTask(&Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_EMULATERECOGNITION::EmulateReco *
*--------------------------------------*
*   Description:
*
*   Returns:
*       S_OK - Phrase parsed completely and recognition was emulated
*       SP_NO_PARSE_FOUND - Phrase did not match any active rules
*       SP_RECOGNIZER_INACTIVE - Recognition is not currently active, so emulation
*                                can't complete.
*       or other error code.
*
********************************************************************* RAL ***/

HRESULT CRIT_EMULATERECOGNITION::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_EMULATERECOGNITION::EmulateReco");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();
    CComPtr<ISpPhraseBuilder> cpPhrase;
    BOOL fIsDictation = FALSE;
    SPGRAMMARHANDLE hGrammar;

    hr = cpPhrase.CoCreateInstance(CLSID_SpPhraseBuilder);
    if (SUCCEEDED(hr))
    {
        hr = cpPhrase->InitFromSerializedPhrase((const SPSERIALIZEDPHRASE *)this->pvAdditionalBuffer);
    }
    if (SUCCEEDED(hr))
    {
        ULONG ulWordsParsed = 0;
        SPPHRASE *pSPPhrase = NULL;
        hr = cpPhrase->GetPhrase(&pSPPhrase);
        if (SUCCEEDED(hr))
        {
            hr = pMaster->m_cpCFGEngine->ParseFromPhrase(cpPhrase, pSPPhrase, 0, FALSE/* fIsITN */, &ulWordsParsed);
        }
        if (S_FALSE == hr && pSPPhrase) // we require all words to parse
        {
            hr = cpPhrase->InitFromPhrase(pSPPhrase);
            if (SUCCEEDED(hr))
            {
                hr = SP_NO_PARSE_FOUND;
            }
        }
        ::CoTaskMemFree(pSPPhrase);
        if (S_OK != hr)
        {
            // do we have dictation active??
            CRecoInstGrammar * pGrammar = NULL;
            pMaster->m_GrammarHandleTable.First(&hGrammar, &pGrammar);
            while (pGrammar)
            {
                if (pGrammar->HasActiveDictation())
                {
                    fIsDictation = TRUE;
                    hr = S_OK;
                    break;
                }
                pMaster->m_GrammarHandleTable.Next(hGrammar, &hGrammar, &pGrammar);
            }
        }
    }
    if (S_OK == hr)
    {
        SPRECORESULTINFO Result;
        memset( &Result, 0, sizeof(Result) );
        // Build the RecoPhrase structure
        Result.cbSize = sizeof(Result);
        Result.eResultType = fIsDictation ? SPRT_SLM : SPRT_CFG;
        Result.fHypothesis = FALSE;
        Result.fProprietaryAutoPause = FALSE;
        Result.hGrammar = fIsDictation ? hGrammar : NULL;
        Result.ulSizeEngineData = 0;
        Result.pvEngineData = NULL;
        Result.pPhrase = cpPhrase;
        hr = pMaster->SendEmulateRecognition(&Result, this, pRecoInst);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRIT_SETRECOGNIZER::SetRecognizer *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETRECOGNIZER::SetRecognizer(_ISpRecognizerBackDoor * pRecognizer, ISpObjectToken * pToken)
{
    SPDBG_FUNC("CRIT_SETRECOGNIZER::SetRecognizer");
    HRESULT hr = S_OK;

    CRIT_SETRECOGNIZER Task;
    if (pToken)
    {
        CSpDynamicString dstrId;
        hr = pToken->GetId(&dstrId);
        if (SUCCEEDED(hr))
        {
            hr = SpSafeCopyString(Task.szRecognizerTokenId, dstrId);
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = pRecognizer->PerformTask(&Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETRECOGNIZER::Execute *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETRECOGNIZER::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETRECOGNIZER::Execute");
    HRESULT hr = S_OK;
    CRecoMaster * pMaster = pRecoInst->Master();

    if (pMaster->m_cpEngine)
    {
        if (pMaster->m_RecoCtxtHandleTable.NumActiveHandles() > 0 ||
            pMaster->m_fInStream)
        {
            // We cannot release if we have active contexts.
            // or
            // If we are in the stream, we are in the engine synchronization at this point. We cannot
            // release the engine since it's audio handling thread cannot be released.
            hr = SPERR_ENGINE_BUSY;
        }
        else
        {
            pMaster->ReleaseEngine();
        }
    }
    if (SUCCEEDED(hr))
    {
        if (this->szRecognizerTokenId[0] == 0)
        {
            hr = ::SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &pMaster->m_cpEngineToken);
        }
        else
        {
            hr = SpGetTokenFromId(this->szRecognizerTokenId, &pMaster->m_cpEngineToken);
        }

        if (SUCCEEDED(hr))
        {
            hr = pMaster->LazyInitEngine();  // LazyInit uses the pMaster->m_cpEngineToken to initialize
            if (FAILED(hr))
            {
                pMaster->ReleaseEngine();
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETRECOGNIZER::GetRecognizer *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETRECOGNIZER::GetRecognizer(_ISpRecognizerBackDoor * pRecognizer, ISpObjectToken ** ppObjectToken)
{
    SPDBG_FUNC("CRIT_GETRECOGNIZER::GetRecognizer");
    HRESULT hr = S_OK;

    CRIT_GETRECOGNIZER Task;

    hr = pRecognizer->PerformTask(&Task);
    *ppObjectToken = NULL;
    if (SUCCEEDED(hr))
    {
        hr = ::SpGetTokenFromId(Task.Response.szRecognizerTokenId, ppObjectToken);
    }


    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETRECOGNIZER::ExecuteFirstPart *
*--------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETRECOGNIZER::ExecuteFirstPart(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETRECOGNIZER::Execute");
    HRESULT hr = S_OK;

    // Note: We can only get away with GetRecognizer being two-part
    // because when we're in-stream, all SetRecognizer calls will fail.
    // The 'current' recognizer will be the last one that successfully
    // executed with LazyInitEngine, or the default recognizer.
    
    CComPtr<ISpObjectToken> cpRecoToken(pRecoInst->Master()->m_cpEngineToken);
    
    if (!cpRecoToken)
    {
        hr = SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &cpRecoToken);
    }
    if (SUCCEEDED(hr))
    {
        CSpDynamicString dstrTokenId;
        hr = cpRecoToken->GetId(&dstrTokenId);
        if (SUCCEEDED(hr))  
        {
            hr = SpSafeCopyString(this->Response.szRecognizerTokenId, dstrTokenId);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETRECOGNIZER::Execute *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETRECOGNIZER::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETRECOGNIZER::Execute");
    HRESULT hr = S_OK;

    if (!this->Response.szRecognizerTokenId[0])
    {
        hr = ExecuteFirstPart(pRecoInst);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_CREATECONTEXT::CreateContext *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_CREATECONTEXT::CreateContext(_ISpRecognizerBackDoor * pRecognizer, SPRECOCONTEXTHANDLE * phContext, WCHAR **pszRequestTypeOfUI)
{
    SPDBG_FUNC("CRIT_CREATECONTEXT::CreateContext");
    HRESULT hr = S_OK;

    CRIT_CREATECONTEXT Task;
    hr = pRecognizer->PerformTask(&Task);

    *phContext = Task.Response.hCreatedRecoCtxt;
    SPDBG_ASSERT(FAILED(hr) || *phContext != (void*)NULL);
    
    *pszRequestTypeOfUI = (WCHAR*)::CoTaskMemAlloc((wcslen(Task.Response.wszRequestTypeOfUI) + 1) * sizeof(WCHAR));
    if(*pszRequestTypeOfUI)
    {
        wcscpy(*pszRequestTypeOfUI, Task.Response.wszRequestTypeOfUI);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}




/****************************************************************************
* CRIT_CREATECONTEXT::ExecuteFirstPart *
*--------------------------------------*
*   Description:
*       Execute the first stage of creating a context. This involves
*       creating a new CRecoInstCtxt class and adding to the context handle table.
*       However no calls to the SR engine are made at this point. This allows
*       this portion of the task to run on the client thread and prevent it blocking.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_CREATECONTEXT::ExecuteFirstPart(CRecoInst *pRecoInst)
{
    HRESULT hr = S_OK;

    CRecoInstCtxt * pNew = new CRecoInstCtxt(pRecoInst);
    if (pNew)
    {
        hr = pRecoInst->m_pRecoMaster->m_RecoCtxtHandleTable.Add(pNew, &pNew->m_hThis);
        if(SUCCEEDED(hr))
        {
            Response.hCreatedRecoCtxt = pNew->m_hThis;
        }
        else
        {
            delete pNew;
        }

        if(SUCCEEDED(hr) && pRecoInst->m_pRecoMaster->m_dstrRequestTypeOfUI.m_psz)
        {
            hr = SpSafeCopyString(Response.wszRequestTypeOfUI, pRecoInst->m_pRecoMaster->m_dstrRequestTypeOfUI); 
        }
        else
        {
            Response.wszRequestTypeOfUI[0] = L'\0';
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************************************
* CRIT_CREATECONTEXT::Execute *
*-----------------------------*
*   Description:
*
*       This will do the remaining work to create a context, and like all other Execute
*       methods is only called on the engine's thread. If ExecuteFirstPart has not been
*       called yet (e.g. the engine isn't running) then it is called. Then calls to the engine
*       (e.g. OnCreateRecoContext) are made. If these fail we record the failure so subsequent
*       calls to this context will fail.
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_CREATECONTEXT::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_CREATECONTEXT::Execute");
    HRESULT hr = S_OK;

    CRecoInstCtxt *pCtxt;

    // We use the hCreatedRecoCtxt to see if we have called this before.
    // Note: We could generalize this for other tasks so a flag is stored 
    // in the CSRTask to indicate if the first part was executed.
    if((void*)Response.hCreatedRecoCtxt == NULL)
    {
        hr = ExecuteFirstPart(pRecoInst);
    }

    if(SUCCEEDED(hr))
    {
        hr = pRecoInst->m_pRecoMaster->m_RecoCtxtHandleTable.GetHandleObject(Response.hCreatedRecoCtxt, &pCtxt);
        SPDBG_ASSERT(SUCCEEDED(hr) && pCtxt != NULL && pCtxt->m_pRecoMaster == NULL);
    }

    if(SUCCEEDED(hr))
    {
        hr = pRecoInst->m_pRecoMaster->LazyInitEngine();

        if (SUCCEEDED(hr))
        {
            hr = pRecoInst->m_pRecoMaster->OnCreateRecoContext(Response.hCreatedRecoCtxt, &pCtxt->m_pvDrvCtxt);
        }

        if (SUCCEEDED(hr))
        {
            pCtxt->m_pRecoMaster = pRecoInst->m_pRecoMaster;
            pCtxt->m_hrCreation = S_OK;
        }
        else
        {
            pCtxt->m_hrCreation = hr;

            // Note: We could delete the CRecoCtxtInst here in sync cases (but not async).
        }
    }

    // Recopy this information over in case engine altered it during its calls
    if(SUCCEEDED(hr) && pRecoInst->m_pRecoMaster->m_dstrRequestTypeOfUI.m_psz)
    {
        hr = SpSafeCopyString(Response.wszRequestTypeOfUI, pRecoInst->m_pRecoMaster->m_dstrRequestTypeOfUI); 
    }
    else
    {
        Response.wszRequestTypeOfUI[0] = L'\0';
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETPROFILE::SetProfile *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETPROFILE::SetProfile(_ISpRecognizerBackDoor * pRecognizer, ISpObjectToken * pToken)
{
    SPDBG_FUNC("CRIT_SETPROFILE::SetProfile");
    HRESULT hr = S_OK;

    CRIT_SETPROFILE Task;
    CSpDynamicString dstrId;
    hr = pToken->GetId(&dstrId);
    if (SUCCEEDED(hr))
    {
        hr = SpSafeCopyString(Task.szProfileTokenId, dstrId);
    }
    if (SUCCEEDED(hr))
    {
        hr = pRecognizer->PerformTask(&Task);    
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETPROFILE::Execute *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETPROFILE::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETPROFILE::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();

    CComPtr<ISpObjectToken> cpProfileToken;

    hr = SpGetTokenFromId(this->szProfileTokenId, &cpProfileToken);
    if (SUCCEEDED(hr) && pMaster->m_cpEngine)
    {
        hr = pMaster->SetRecoProfile(cpProfileToken);
    }
    if (SUCCEEDED(hr))
    {
        pMaster->m_cpRecoProfileToken.Attach(cpProfileToken.Detach());
    }
    if (pMaster->m_fInStream)
    {
        pMaster->m_AudioQueue.AdjustAudioVolume(pMaster->m_cpRecoProfileToken, pMaster->m_Status.clsidEngine);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETPROFILE::GetProfile *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETPROFILE::GetProfile(_ISpRecognizerBackDoor * pRecognizer, ISpObjectToken ** ppProfileToken)
{
    SPDBG_FUNC("CRIT_GETPROFILE::GetProfile");
    HRESULT hr = S_OK;

    CRIT_GETPROFILE Task;
    hr = pRecognizer->PerformTask(&Task);

    *ppProfileToken = NULL;
    if (SUCCEEDED(hr))
    {
        hr = ::SpGetTokenFromId(Task.Response.szProfileTokenId, ppProfileToken);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRIT_GETPROFILE::Execute *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETPROFILE::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETPROFILE::Execute");
    HRESULT hr = S_OK;

    this->Response.szProfileTokenId[0] = 0; // In case of failure
    CComPtr<ISpObjectToken> cpProfileToken(pRecoInst->Master()->m_cpRecoProfileToken);
    if (!cpProfileToken)
    {
        hr = SpGetOrCreateDefaultProfile(&cpProfileToken);
    }
    if (SUCCEEDED(hr))
    {
        CSpDynamicString dstrTokenId;
        hr = cpProfileToken->GetId(&dstrTokenId);
        if (SUCCEEDED(hr))  
        {
            hr = SpSafeCopyString(this->Response.szProfileTokenId, dstrTokenId);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRIT_SETINPUT::SetInput *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETINPUT::SetInput(_ISpRecognizerBackDoor * pRecognizer,ISpObjectToken * pToken, ISpStreamFormat * pStream, BOOL fAllowFormatChanges)
{
    SPDBG_FUNC("CRIT_SETINPUT::SetInput");
    HRESULT hr = S_OK;

    CRIT_SETINPUT Task;

    if (pToken)
    {
        CSpDynamicString dstrId;
        hr = pToken->GetId(&dstrId);
        if (SUCCEEDED(hr))
        {
            hr = SpSafeCopyString(Task.szInputTokenId, dstrId);
        }
    }
    if (SUCCEEDED(hr))
    {
        Task.fAllowFormatChanges = fAllowFormatChanges;
        Task.pInputObject = pStream;
        hr = pRecognizer->PerformTask(&Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETINPUT::Execute *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETINPUT::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETINPUT::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();

    CComPtr<ISpObjectToken> cpToken;
    if (this->szInputTokenId[0] != 0)
    {
        hr = SpGetTokenFromId(this->szInputTokenId, &cpToken);
    }
	if (SUCCEEDED(hr))
    {
		hr = pMaster->SetInput(cpToken, this->pInputObject, this->fAllowFormatChanges);
	}        

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETINPUT::BackOut *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETINPUT::BackOut(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETINPUT::BackOut");
    HRESULT hr = S_OK;

    pRecoInst->Master()->m_AudioQueue.ReleaseAll();

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETPROPERTYNUM::GetPropertyNum *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETPROPERTYNUM::GetPropertyNum(_ISpRecognizerBackDoor * pRecognizer, const WCHAR * pszName, LONG * plValue)
{
    SPDBG_FUNC("CRIT_GETPROPERTYNUM::GetPropertyNum");
    HRESULT hr = S_OK;

    CRIT_GETPROPERTYNUM Task;
    hr = SpSafeCopyString(Task.szPropertyName, pszName);
    if( SUCCEEDED(hr) )
    {
        hr = pRecognizer->PerformTask(&Task);
        if( hr == S_OK )
        {
            *plValue = Task.Response.lPropertyValue;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETPROPERTYNUM::Execute *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETPROPERTYNUM::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETPROPERTYNUM::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();
    hr = pMaster->LazyInitEngine();
    if (SUCCEEDED(hr))
    {
        hr = pMaster->GetPropertyNum( SPPROPSRC_RECO_INST, NULL, this->szPropertyName, &this->Response.lPropertyValue );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETPROPERTYNUM::SetPropertyNum *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETPROPERTYNUM::SetPropertyNum(_ISpRecognizerBackDoor * pRecognizer, const WCHAR * pszProperty, LONG lValue)
{
    SPDBG_FUNC("CRIT_SETPROPERTYNUM::SetPropertyNum");
    HRESULT hr = S_OK;

    CRIT_SETPROPERTYNUM Task;
    Task.lPropertyValue = lValue;
    hr = SpSafeCopyString(Task.szPropertyName, pszProperty);
    if (SUCCEEDED(hr))
    {
        hr = pRecognizer->PerformTask(&Task);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETPROPERTYNUM::Execute *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETPROPERTYNUM::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETPROPERTYNUM::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();
    hr = pMaster->LazyInitEngine();
    if (SUCCEEDED(hr))
    {
        hr = pMaster->SetPropertyNum( SPPROPSRC_RECO_INST, NULL, this->szPropertyName, this->lPropertyValue );

        // If the engine returns S_FALSE then it does NOT want an event to be broadcast
        // about this attribute change.  If S_OK then it does want it broadcast.
        if (hr == S_OK)
        {
            SPEVENT Event;
            Event.eEventId = SPEI_PROPERTY_NUM_CHANGE;
            Event.elParamType = SPET_LPARAM_IS_STRING;
            Event.ullAudioStreamOffset = pMaster->m_Status.ullRecognitionStreamPos;
            Event.ulStreamNum = 0;  // Initialized by AddEvent()
            Event.wParam = this->lPropertyValue;
            Event.lParam = (LPARAM)this->szPropertyName;
            pMaster->InternalAddEvent(&Event, NULL);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETPROPERTYSTRING::GetPropertyString *
*-------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETPROPERTYSTRING::GetPropertyString(_ISpRecognizerBackDoor * pRecognizer, const WCHAR * pszProperty, WCHAR ** ppCoMemValue)
{
    SPDBG_FUNC("CRIT_GETPROPERTYSTRING::GetPropertyString");
    HRESULT hr = S_OK;

    CRIT_GETPROPERTYSTRING Task;
    hr = SpSafeCopyString(Task.szPropertyName, pszProperty);
    if (SUCCEEDED(hr))
    {
        hr = pRecognizer->PerformTask(&Task);
    }
    *ppCoMemValue = NULL;
    if (SUCCEEDED(hr) && Task.Response.szStringValue[0])
    {
        CSpDynamicString dstrVal(Task.Response.szStringValue);
        if (dstrVal)
        {
            *ppCoMemValue = dstrVal.Detach();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETPROPERTYSTRING::Execute *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETPROPERTYSTRING::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETPROPERTYSTRING::Execute");
    HRESULT hr = S_OK;

    this->Response.szStringValue[0] = 0;  // In case of failure

    CRecoMaster * pMaster = pRecoInst->Master();
    hr = pMaster->LazyInitEngine();
    if (SUCCEEDED(hr))
    {
        CSpDynamicString dstrProp;
        hr = pMaster->GetPropertyString(SPPROPSRC_RECO_INST, NULL, this->szPropertyName, &dstrProp);

        if (SUCCEEDED(hr) && dstrProp)
        {
            if(SP_IS_BAD_STRING_PTR(dstrProp) 
                || wcslen(dstrProp) >= sp_countof(this->Response.szStringValue))
            {
                SPDBG_ASSERT(0);
                hr = SPERR_ENGINE_RESPONSE_INVALID;
            }
            else
            {
                hr = SpSafeCopyString(this->Response.szStringValue, dstrProp);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETPROPERTYSTRING::SetPropertyString *
*-------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETPROPERTYSTRING::SetPropertyString(_ISpRecognizerBackDoor * pRecognizer, const WCHAR * pszProperty, const WCHAR * pszValue)
{
    SPDBG_FUNC("CRIT_SETPROPERTYSTRING::SetPropertyString");
    HRESULT hr = S_OK;

    CRIT_SETPROPERTYSTRING Task;
    hr = SpSafeCopyString(Task.szPropertyName, pszProperty);
    if (SUCCEEDED(hr))
    {
        hr = SpSafeCopyString(Task.szPropertyValue, pszValue);
    }
    if (SUCCEEDED(hr))
    {
        hr = pRecognizer->PerformTask(&Task);
    }


    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_SETPROPERTYSTRING::Execute *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_SETPROPERTYSTRING::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_SETPROPERTYSTRING::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pRecoInst->Master();
    hr = pMaster->LazyInitEngine();
    if (SUCCEEDED(hr))
    {
        hr = pMaster->SetPropertyString(SPPROPSRC_RECO_INST, NULL, this->szPropertyName, this->szPropertyValue);

        // If the engine returns S_FALSE then it does NOT want an event to be broadcast
        // about this attribute change.  If S_OK then it does want it broadcast.
        if (hr == S_OK)
        {
            // All character counts include the 0 string terminator character
            ULONG cchName = wcslen(this->szPropertyName) + 1;
            ULONG cchValue = wcslen(this->szPropertyValue) + 1;
            ULONG cchTotal = cchName + cchValue;    // One char for the each of the NULLS

            WCHAR * psz = STACK_ALLOC(WCHAR, cchTotal);
            memcpy(psz, this->szPropertyName, cchName * sizeof(*psz));
            memcpy((psz + cchName), this->szPropertyValue, cchValue * sizeof(*psz));   // Copy the NULL too...

            SPEVENT Event;
            Event.eEventId = SPEI_PROPERTY_STRING_CHANGE;
            Event.elParamType = SPET_LPARAM_IS_POINTER;
            Event.ullAudioStreamOffset = pMaster->m_Status.ullRecognitionStreamPos;
            Event.ulStreamNum = 0;  // Initialized by AddEvent()
            Event.wParam = cchTotal * sizeof(WCHAR);
            Event.lParam = (LPARAM)psz;
            pMaster->InternalAddEvent(&Event, NULL);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRIT_GETINPUTSTREAM::GetInputStream *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETINPUTSTREAM::GetInputStream(_ISpRecognizerBackDoor * pRecognizer, ISpStreamFormat ** ppStream)
{
    SPDBG_FUNC("CRIT_GETINPUTSTREAM::GetInputStream");
    HRESULT hr = S_OK;

    CRIT_GETINPUTSTREAM Task;
    hr = pRecognizer->PerformTask(&Task);
    *ppStream = Task.Response.pInputStreamObject;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETINPUTSTREAM::Execute *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETINPUTSTREAM::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETINPUTSTREAM::Execute");
    HRESULT hr = S_OK;

    hr = pRecoInst->Master()->m_AudioQueue.CopyOriginalInputStreamTo(&this->Response.pInputStreamObject);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRIT_GETINPUTTOKEN::GetInputToken *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETINPUTTOKEN::GetInputToken(_ISpRecognizerBackDoor * pRecognizer, ISpObjectToken ** ppObjectToken)
{
    SPDBG_FUNC("CRIT_GETINPUTTOKEN::GetInputToken");
    HRESULT hr = S_OK;

    CRIT_GETINPUTTOKEN Task;
    hr = pRecognizer->PerformTask(&Task);
    *ppObjectToken = NULL;
    if (SUCCEEDED(hr))
    {
        hr = Task.Response.hrGetInputToken;
        if (S_OK == hr)
        {
            hr = ::SpGetTokenFromId(Task.Response.szInputTokenId, ppObjectToken);
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRIT_GETINPUTTOKEN::Execute *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRIT_GETINPUTTOKEN::Execute(CRecoInst * pRecoInst)
{
    SPDBG_FUNC("CRIT_GETINPUTTOKEN::Execute");
    HRESULT hr = S_OK;
    CRecoMaster * pMaster = pRecoInst->Master();

    this->Response.hrGetInputToken = S_OK;
    this->Response.szInputTokenId[0] = 0;

    CComPtr<ISpObjectToken> cpAudioToken;
    if (pMaster->m_AudioQueue.HaveInputStream())
    {
        cpAudioToken = pMaster->m_AudioQueue.InputToken();
        if (!cpAudioToken)
        {
            this->Response.hrGetInputToken = S_FALSE;
        }
    }
    else
    {
        // In the shared case, 
        if (pMaster->m_fShared)
        {
            hr = SpGetDefaultTokenFromCategoryId(SPCAT_AUDIOIN, &cpAudioToken);
            if (FAILED(hr))
            {
                this->Response.hrGetInputToken = hr;
            }
        }
        else
        {
            this->Response.hrGetInputToken = SPERR_UNINITIALIZED;
        }
    }
    if (cpAudioToken)
    {
        SPDBG_ASSERT(this->Response.hrGetInputToken == S_OK);
        CSpDynamicString dstrTokenId;
        hr = cpAudioToken->GetId(&dstrTokenId);
        if (SUCCEEDED(hr))  
        {
            hr = SpSafeCopyString(this->Response.szInputTokenId, dstrTokenId);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



// ----- CONTEXT TASKS

/****************************************************************************
* CRCT_PAUSECONTEXT::Pause *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_PAUSECONTEXT::Pause(CRecoCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_PAUSECONTEXT::Pause");
    HRESULT hr = S_OK;

    CRCT_PAUSECONTEXT Task;
    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_PAUSECONTEXT::Execute *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_PAUSECONTEXT::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_PAUSECONTEXT::Execute");
    HRESULT hr = S_OK;

    pCtxt->m_cPause++;
    pCtxt->m_pRecoMaster->m_cPause++;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_RESUMECONTEXT::Resume *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_RESUMECONTEXT::Resume(CRecoCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_RESUMECONTEXT::Resume");
    HRESULT hr = S_OK;

    CRCT_RESUMECONTEXT Task;
    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_RESUMECONTEXT::Execute *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_RESUMECONTEXT::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_RESUMECONTEXT::Execute");
    HRESULT hr = S_OK;

    if (pCtxt->m_cPause)
    {
        pCtxt->m_cPause--;
        pCtxt->m_pRecoMaster->m_cPause--;
    }
    else
    {
        hr = S_FALSE;   
    }


    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_RESUMECONTEXT::BackOut *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_RESUMECONTEXT::BackOut(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_RESUMECONTEXT::BackOut");
    HRESULT hr = S_OK;

    pCtxt->m_cPause++;
    pCtxt->m_pRecoMaster->m_cPause++;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRCT_BOOKMARK::Bookmark *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_BOOKMARK::Bookmark(CRecoCtxt * pCtxt, SPBOOKMARKOPTIONS Options, ULONGLONG ullStreamPosition, LPARAM lParamEvent)
{
    SPDBG_FUNC("CRCT_BOOKMARK::Bookmark");
    HRESULT hr = S_OK;

    CRCT_BOOKMARK Task;
    Task.BookmarkOptions = Options;
    Task.ullStreamPosition = ullStreamPosition;
    Task.lParamEvent = lParamEvent;

    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRCT_BOOKMARK::Execute *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_BOOKMARK::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_BOOKMARK::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pCtxt->m_pRecoMaster;

    SPEVENT Event;

    Event.eEventId = SPEI_SR_BOOKMARK;
    Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
    Event.ullAudioStreamOffset = pMaster->m_Status.ullRecognitionStreamPos;
    Event.wParam = (this->BookmarkOptions == SPBO_PAUSE) ? SPREF_AutoPause : 0;
    Event.lParam = this->lParamEvent;
    Event.ulStreamNum = 0;  // Filled in by AddEvent()

    hr = pMaster->InternalAddEvent(&Event, pCtxt->m_hThis);
    SPDBG_ASSERT(SUCCEEDED(hr));

    if (this->BookmarkOptions == SPBO_PAUSE)
    {
        pCtxt->m_cPause++;
        pCtxt->m_pRecoMaster->m_cPause++;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CRCT_SETCONTEXTSTATE::SetContextState *
*---------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETCONTEXTSTATE::SetContextState(CRecoCtxt * pCtxt, SPCONTEXTSTATE eState)
{
    SPDBG_FUNC("CRCT_SETCONTEXTSTATE::SetContextState");
    HRESULT hr = S_OK;

    CRCT_SETCONTEXTSTATE Task;
    Task.eContextState = eState;
    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_SETCONTEXTSTATE::Execute *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETCONTEXTSTATE::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_SETCONTEXTSTATE::Execute");
    HRESULT hr = S_OK;

    //
    //  NOTE:  We set the state BEFORE calling then engine so that the site
    //  method IsGrammarActive will work correctly.
    //
    SPDBG_ASSERT(pCtxt->m_State != this->eContextState);

    pCtxt->m_State = this->eContextState;
    hr = pCtxt->m_pRecoMaster->UpdateAllGrammarStates();

    if (SUCCEEDED(hr))
    {
        hr = pCtxt->m_pRecoMaster->SetContextState(pCtxt->m_pvDrvCtxt, this->eContextState);
    }

    if (FAILED(hr))
    {
        BackOut(pCtxt);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_SETCONTEXTSTATE::BackOut *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETCONTEXTSTATE::BackOut(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_SETCONTEXTSTATE::BackOut");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(this->eContextState == SPCS_ENABLED);
    pCtxt->m_State = SPCS_DISABLED;
    pCtxt->m_pRecoMaster->UpdateAllGrammarStates();
    hr = pCtxt->m_pRecoMaster->SetContextState(pCtxt->m_pvDrvCtxt, SPCS_DISABLED);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRCT_CALLENGINE::CallEngine *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_CALLENGINE::CallEngine(CRecoCtxt * pCtxt, void * pvData, ULONG cbData)
{
    SPDBG_FUNC("CRCT_CALLENGINE::CallEngine");
    HRESULT hr = S_OK;

    CRCT_CALLENGINE Task;
    Task.cbAdditionalBuffer = cbData;
    Task.pvAdditionalBuffer = pvData;
    Task.fAdditionalBufferInResponse = TRUE;
    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_CALLENGINE::Execute *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_CALLENGINE::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_CALLENGINE::Execute");
    HRESULT hr;

    hr = pCtxt->m_pRecoMaster->PrivateCall( pCtxt->m_pvDrvCtxt,
                                                        pvAdditionalBuffer, 
                                                        cbAdditionalBuffer);
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_CALLENGINEEX::CallEngineEx *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_CALLENGINEEX::CallEngineEx(CRecoCtxt * pCtxt, const void * pvInData, ULONG cbInData,
                                        void ** ppvCoMemOutData, ULONG * pcbOutData)
{
    SPDBG_FUNC("CRCT_CALLENGINE::CallEngineEx");
    HRESULT hr = S_OK;

    CRCT_CALLENGINEEX Task;
    Task.cbAdditionalBuffer = cbInData;
    Task.pvAdditionalBuffer = const_cast<void *>(pvInData);
    Task.fExpectCoMemResponse = TRUE;
    hr = pCtxt->PerformTask(&Task);

    *ppvCoMemOutData = Task.Response.pvCoMemResponse;
    *pcbOutData = Task.Response.cbCoMemResponse;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_CALLLENGINEEX::Execute *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_CALLENGINEEX::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_CALLLENGINEEX::Execute");
    HRESULT hr = S_OK;

    hr = pCtxt->m_pRecoMaster->PrivateCallEx( pCtxt->m_pvDrvCtxt,
                                                              this->pvAdditionalBuffer, 
                                                              this->cbAdditionalBuffer,
                                                              &this->Response.pvCoMemResponse,
                                                              &this->Response.cbCoMemResponse);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRCT_DELETECONTEXT::DeleteContext *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_DELETECONTEXT::DeleteContext(CRecoCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_DELETECONTEXT::DeleteContext");
    HRESULT hr = S_OK;

    CRCT_DELETECONTEXT Task;
    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_DELETECONTEXT::Execute *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_DELETECONTEXT::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_DELETECONTEXT::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pCtxt->m_pRecoMaster;
    pMaster->m_RecoCtxtHandleTable.Delete(pCtxt->m_hThis); // This object is now dead!!!

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_SETEVENTINTEREST::SetEventInterest *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETEVENTINTEREST::SetEventInterest(CRecoCtxt * pCtxt, ULONGLONG ullEventInterest)
{
    SPDBG_FUNC("CRCT_SETEVENTINTEREST::SetEventInterest");
    HRESULT hr = S_OK;

    CRCT_SETEVENTINTEREST Task;
    Task.ullEventInterest = ullEventInterest;
    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_SETEVENTINTEREST::Execute *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETEVENTINTEREST::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_SETEVENTINTEREST::Execute");
    HRESULT hr = S_OK;

    CRecoMaster * pMaster = pCtxt->m_pRecoMaster;

    if(((this->ullEventInterest & SPFEI(SPEI_REQUEST_UI)) == SPFEI(SPEI_REQUEST_UI)) &&
        ((pCtxt->m_ullEventInterest & SPFEI(SPEI_REQUEST_UI)) != SPFEI(SPEI_REQUEST_UI)))
    {
        // Previously this context not interested in RequestUI, but now is, so send event back
        if(pMaster->m_dstrRequestTypeOfUI.m_psz)
        {
            SPEVENT Event;
            Event.eEventId = SPEI_REQUEST_UI;
            Event.elParamType = SPET_LPARAM_IS_STRING;
            Event.ulStreamNum = 0;
            Event.ullAudioStreamOffset = pMaster->m_Status.ullRecognitionStreamPos;
            Event.wParam = 0;
            Event.lParam = (LPARAM)pMaster->m_dstrRequestTypeOfUI.m_psz;

            hr = pMaster->AddEvent(&Event, pCtxt->m_hThis);
        }
    }

    if(SUCCEEDED(hr))
    {
        pCtxt->m_ullEventInterest = this->ullEventInterest;
    }

    if(SUCCEEDED(hr))
    {
        hr = pMaster->UpdateAudioEventInterest();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRCT_SETRETAINAUDIO::SetRetainAudio *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETRETAINAUDIO::SetRetainAudio(CRecoCtxt * pRecoCtxt, BOOL fRetainAudio)
{
    SPDBG_FUNC("CRCT_SETRETAINAUDIO::SetRetainAudio");
    HRESULT hr = S_OK;

    CRCT_SETRETAINAUDIO Task;
    Task.fRetainAudio = fRetainAudio;
    hr = pRecoCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_SETRETAINAUDIO::Execute *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETRETAINAUDIO::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_SETRETAINAUDIO::Execute");
    HRESULT hr = S_OK;

    hr = pCtxt->SetRetainAudio(this->fRetainAudio);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CRCT_SETMAXALTERNATES::SetMaxAlternates *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETMAXALTERNATES::SetMaxAlternates(CRecoCtxt * pCtxt, ULONG cMaxAlternates)
{
    SPDBG_FUNC("CRCT_SETMAXALTERNATES::SetMaxAlternates");
    HRESULT hr = S_OK;

    CRCT_SETMAXALTERNATES Task;
    Task.ulMaxAlternates = cMaxAlternates;
    hr = pCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_SETMAXALTERNATES::Execute *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_SETMAXALTERNATES::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_SETMAXALTERNATES::Execute");
    HRESULT hr = S_OK;

    pCtxt->m_ulMaxAlternates = this->ulMaxAlternates;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_ADAPTATIONDATA::SetAdaptationData *
*----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_ADAPTATIONDATA::SetAdaptationData(CRecoCtxt * pRecoCtxt, const WCHAR * pszData, ULONG cch)
{
    SPDBG_FUNC("CRCT_ADAPTATIONDATA::SetAdaptationData");
    HRESULT hr = S_OK;

    CRCT_ADAPTATIONDATA Task;
    Task.pvAdditionalBuffer = const_cast<WCHAR *>(pszData);
    Task.cbAdditionalBuffer = cch * sizeof(WCHAR);
    hr = pRecoCtxt->PerformTask(&Task);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_ADAPTATIONDATA::Execute *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_ADAPTATIONDATA::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_ADAPTATIONDATA::Execute");
    HRESULT hr = S_OK;

    hr = pCtxt->m_pRecoMaster->SetAdaptationData(
                pCtxt->m_pvDrvCtxt, (const WCHAR *)this->pvAdditionalBuffer, this->cbAdditionalBuffer / sizeof(WCHAR));

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRCT_CREATEGRAMMAR::CreateGrammar *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_CREATEGRAMMAR::CreateGrammar(CRecoCtxt * pRecoCtxt, ULONGLONG ullAppGrammarId, SPGRAMMARHANDLE * phRecoInstGrammar)
{
    SPDBG_FUNC("CRCT_CREATEGRAMMAR::CreateGrammar");
    HRESULT hr = S_OK;

    CRCT_CREATEGRAMMAR Task;
    Task.ullApplicationGrammarId = ullAppGrammarId;
    hr = pRecoCtxt->PerformTask(&Task);

    *phRecoInstGrammar = Task.Response.hRecoInstGrammar;
    SPDBG_ASSERT(FAILED(hr) || *phRecoInstGrammar != (void*)NULL);

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CRCT_CREATEGRAMMAR::ExecuteFirstPart *
*--------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_CREATEGRAMMAR::ExecuteFirstPart(CRecoInst *pRecoInst)
{
    SPDBG_FUNC("CRCT_CREATEGRAMMAR::ExecuteFirstPart");

    HRESULT hr = S_OK;

    CRecoMaster * pRecoMaster = pRecoInst->m_pRecoMaster;
    CRecoInstCtxt * pCtxt = NULL;
    CRecoInstGrammar * pNew = NULL;

    hr = pRecoMaster->m_RecoCtxtHandleTable.GetHandleObject(this->hRecoInstContext, &pCtxt);

    if (SUCCEEDED(hr))
    {
        pNew = new CRecoInstGrammar(pCtxt, this->ullApplicationGrammarId);

        hr = pNew ? S_OK : E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        SPGRAMMARHANDLE hNew = NULL;

        hr = pRecoMaster->m_GrammarHandleTable.Add(pNew, &hNew);

        if (SUCCEEDED(hr))
        {
            SPDBG_ASSERT(hNew != NULL);
            
            Response.hRecoInstGrammar = hNew;
            pNew->m_hThis = hNew;
        }
        else
        {
            delete pNew;
        }            
    }
    
    SPDBG_REPORT_ON_FAIL(hr);

    return hr;
}

/****************************************************************************
* CRCT_CREATEGRAMMAR::Execute *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRCT_CREATEGRAMMAR::Execute(CRecoInstCtxt * pCtxt)
{
    SPDBG_FUNC("CRCT_CREATEGRAMMAR::Execute");

    HRESULT hr = S_OK;

    SPDBG_ASSERT(pCtxt);
    
    if (NULL == Response.hRecoInstGrammar)
    {
        hr = ExecuteFirstPart(pCtxt->m_pRecoInst);
    }

    CRecoInstGrammar * pGrm;

    if (SUCCEEDED(hr))
    {
        hr = pCtxt->m_pRecoMaster->m_GrammarHandleTable.GetHandleObject(Response.hRecoInstGrammar, &pGrm);
    }

    if (SUCCEEDED(hr))
    {
        SPDBG_ASSERT(pGrm);
        
        hr = pCtxt->m_pRecoMaster->OnCreateGrammar(pCtxt->m_pvDrvCtxt, Response.hRecoInstGrammar, &pGrm->m_pvDrvGrammarCookie);

        pGrm->m_hrCreation = hr;

        if (SUCCEEDED(hr))
        {
            pGrm->m_pRecoMaster = pCtxt->m_pRecoMaster;

            // Our rules only count if there's not an exclusive grammar
            pGrm->m_fRulesCounted = pGrm->RulesShouldCount();
        }
    }

    if (FAILED(hr))
    {
        Response.hRecoInstGrammar = NULL;
    }
    
    SPDBG_REPORT_ON_FAIL( hr );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\stringhlp.h ===
#pragma once

inline HRESULT SpCoTaskMemAllocString(const WCHAR * pszSrc, WCHAR ** ppszOutputString)
{
    ULONG cbNeeded = (wcslen(pszSrc) + 1) * sizeof(WCHAR);
    *ppszOutputString = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
    if (*ppszOutputString)
    {
        memcpy(*ppszOutputString, pszSrc, cbNeeded);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\srtask.h ===
/******************************************************************************
* SRTask.h *
*----------*
*  This is the header file for the CSRTask implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 04/18/00
*  All Rights Reserved
*
*********************************************************************** RAL ***/

#ifndef __SRTask_h__
#define __SRTask_h__

#include "recoctxt.h"

class CSRTask
{
public:
    CSRTask *   m_pNext;
    CRecoInst * m_pRecoInst;
    ENGINETASK  m_Task;
    ULONGLONG   m_ullStreamPos;

    HRESULT Init(CRecoInst * pSender, const ENGINETASK *pTask);
    HRESULT CreateResponse(CSRTask ** ppResponseTask);
    ~CSRTask();

#ifdef _WIN32_WCE
    CSRTaskNode() {}
#endif
    static Compare(const CSRTask * p1, const CSRTask * p2)
    {
        if (p1->m_ullStreamPos < p2->m_ullStreamPos)
        {
            return -1;
        }
        if (p1->m_ullStreamPos > p2->m_ullStreamPos)
        {
            return 1;
        }
        return 0;
    }

    BOOL IsDelayedTask()
    {
        return (m_Task.eTask == ECT_BOOKMARK);   // only bookmarks delayed for now
    }
    BOOL IsAsyncTask()
    {
        switch (m_Task.eTask)
        {
            case ECT_SETCONTEXTSTATE:
            case ECT_BOOKMARK:
            case EGT_LOADCMDFROMMEMORY:
            case EGT_LOADCMDFROMFILE:
            case EGT_LOADCMDFROMOBJECT:
            case EGT_LOADCMDFROMRSRC:
            case EGT_RELOADCMD:
            case EGT_SETCMDRULESTATE:    
            case EGT_SETGRAMMARSTATE:
            case EGT_LOADDICTATION:
            case EGT_UNLOADDICTATION:
            case EGT_SETDICTATIONRULESTATE:
            case EGT_SETWORDSEQUENCEDATA:
            case EGT_SETTEXTSELECTION:
            case ECT_SETEVENTINTEREST:
            case ECT_SETRETAINAUDIO:
                return TRUE;
            default:
                return FALSE;
        }
    }
    BOOL IsTwoPartAsyncTask()
    {
        switch (m_Task.eTask)
        {
            case EIT_CREATECONTEXT:
            case EIT_GETRECOGNIZER:
            case EIT_GETRECOSTATE:
            case ECT_CREATEGRAMMAR:
                return TRUE;
            default:
                return FALSE;
        }
    }
    BOOL IsStartStreamTask()
    {
        switch (m_Task.eTask)
        {
        case EGT_SETDICTATIONRULESTATE:
        case EGT_SETCMDRULESTATE:
            return (this->m_Task.RuleState != SPRS_INACTIVE);

        case EGT_SETGRAMMARSTATE:
            return (this->m_Task.eGrammarState != SPGS_DISABLED);
        
        case EIT_SETINPUT:
            return (this->m_Task.pInputObject != NULL || this->m_Task.szInputTokenId[0] != 0);

        case EIT_SETRECOSTATE:
            return (this->m_Task.NewState != SPRST_INACTIVE && this->m_Task.NewState != SPRST_INACTIVE_WITH_PURGE);

        case ECT_RESUMECONTEXT:
            return TRUE;

        case ECT_SETCONTEXTSTATE:
            return (this->m_Task.eContextState == SPCS_ENABLED);

        default:
            return FALSE;
        }
    }

    // Returns TRUE if outgoing thread critical section must be taken for the task
    // These tasks all add or remove items from handle tables or lists.
    BOOL ChangesOutgoingState()
    {
        switch (m_Task.eTask)
        {
        case ERMT_REMOVERECOINST:
        case ECT_DELETECONTEXT:
        case EIT_CREATECONTEXT:
            return TRUE;

        default:
            return FALSE;
        }
    }

    operator ==(const SPRECOCONTEXTHANDLE h) const
    {
        return m_Task.hRecoInstContext == h;
    }
    operator ==(const SPGRAMMARHANDLE h) const
    {
        return m_Task.hRecoInstGrammar == h;
    }
    operator ==(const CRecoInst * pRecoInst)
    {
        return m_pRecoInst == pRecoInst;
    }

};


typedef CSpProducerConsumerQueue<CSRTask>  CSRTaskQueue;


//
//  These are somwhat unrealted
//
//inline InitTask(ENGINETASKENUM eTask, ENGINETASK * pTask, const CRecoCtxt * pRecoCtxt)
//{
//    memset(pTask, 0, sizeof(*pTask));
//    pTask->hRecoInstContext = pRecoCtxt->m_hRecoInstContext;
//    pTask->eTask = eTask;
//}

inline void InitTask(ENGINETASKENUM eTask, ENGINETASK * pTask)
{
    memset(pTask, 0, sizeof(*pTask));
    pTask->eTask = eTask;
}






//class CSRTask_SetMaxAlternates : public ENGINETASK/
//{
//public:
//    HRESULT SetMaxAlternates(const CRecoCtxt * pRecoCtxt, ULONG ulMaxAlternates)
//    {
//        InitTask(ET_SETMAXALTERNATES, this, pRecoCtxt);
//        this->ulMaxAlternates = ulMaxAlternates;
//        return pRecoCtxt->m_cpRecognizer->PerformTask(this);
//    }
//};



#define EXEC_RECO_INST_TASK(ID) case (EIT_##ID): hr = ((CRIT_##ID *)pTask)->Execute(this); break;
#define EXEC_FIRSTPART_RECO_INST_TASK(ID) case (EIT_##ID): hr = ((CRIT_##ID *)pTask)->ExecuteFirstPart(this); break;
#define BACK_OUT_RECO_INST_TASK(ID) case (EIT_##ID): hr = ((CRIT_##ID *)pTask)->BackOut(this); break;

#define DECLARE_RECO_INST_TASK1(ID, FCTN, P1) \
class CRIT_##ID : public ENGINETASK \
{ \
    CRIT_##ID() { InitTask(EIT_##ID, this); } \
public: \
    static HRESULT FCTN(_ISpRecognizerBackDoor *, P1); \
    HRESULT ExecuteFirstPart(CRecoInst *); \
    HRESULT BackOut(CRecoInst *); \
    HRESULT Execute(CRecoInst *); \
};

#define DECLARE_RECO_INST_TASK2(ID, FCTN, P1, P2) \
class CRIT_##ID : public ENGINETASK \
{ \
    CRIT_##ID() { InitTask(EIT_##ID, this); } \
public: \
    static HRESULT FCTN(_ISpRecognizerBackDoor *, P1, P2); \
    HRESULT ExecuteFirstPart(CRecoInst *); \
    HRESULT Execute(CRecoInst *); \
    HRESULT BackOut(CRecoInst *); \
};

#define DECLARE_RECO_INST_TASK3(ID, FCTN, P1, P2, P3) \
class CRIT_##ID : public ENGINETASK \
{ \
    CRIT_##ID() { InitTask(EIT_##ID, this); } \
public: \
    static HRESULT FCTN(_ISpRecognizerBackDoor *, P1, P2, P3); \
    HRESULT ExecuteFirstPart(CRecoInst *); \
    HRESULT Execute(CRecoInst *); \
    HRESULT BackOut(CRecoInst *); \
};


DECLARE_RECO_INST_TASK1(SETPROFILE, SetProfile, ISpObjectToken * pProfile)
DECLARE_RECO_INST_TASK1(GETPROFILE, GetProfile, ISpObjectToken ** pProfile)
DECLARE_RECO_INST_TASK1(SETRECOSTATE, SetState, SPRECOSTATE NewState)
DECLARE_RECO_INST_TASK1(GETRECOINSTSTATUS, GetStatus, SPRECOGNIZERSTATUS * pStatus)
DECLARE_RECO_INST_TASK3(GETAUDIOFORMAT, GetFormat, SPSTREAMFORMATTYPE FormatType, GUID * pFormatId, WAVEFORMATEX ** ppCoMemWFEX)
DECLARE_RECO_INST_TASK1(GETRECOSTATE, GetState, SPRECOSTATE * pState)
DECLARE_RECO_INST_TASK1(EMULATERECOGNITION, EmulateReco, ISpPhrase * pPhrase)
DECLARE_RECO_INST_TASK1(SETRECOGNIZER, SetRecognizer, ISpObjectToken * pRecognizer)
DECLARE_RECO_INST_TASK1(GETRECOGNIZER, GetRecognizer, ISpObjectToken ** ppRecognizer)
DECLARE_RECO_INST_TASK3(SETINPUT, SetInput, ISpObjectToken * pToken, ISpStreamFormat * pStream, BOOL fAllowFormatChanges)
DECLARE_RECO_INST_TASK2(GETPROPERTYNUM, GetPropertyNum, const WCHAR * pszProperty, LONG * plValue)
DECLARE_RECO_INST_TASK2(SETPROPERTYNUM, SetPropertyNum, const WCHAR * pszProperty, LONG lValue)
DECLARE_RECO_INST_TASK2(GETPROPERTYSTRING, GetPropertyString, const WCHAR * pszProperty, WCHAR ** ppszCoMemValue)
DECLARE_RECO_INST_TASK2(SETPROPERTYSTRING, SetPropertyString, const WCHAR * pszProperty, const WCHAR * pszValue)
DECLARE_RECO_INST_TASK1(GETINPUTTOKEN, GetInputToken, ISpObjectToken ** ppInputObjToken)
DECLARE_RECO_INST_TASK1(GETINPUTSTREAM, GetInputStream, ISpStreamFormat ** ppStream)
// This task is special -- Not an API, but called from the context when created
DECLARE_RECO_INST_TASK2(CREATECONTEXT, CreateContext, SPRECOCONTEXTHANDLE * phContext, WCHAR **pszRequestTypeOfUI)


class CRecoInstCtxt;

#define EXEC_RECO_CTXT_TASK(ID) case (ECT_##ID): hr = ((CRCT_##ID *)pTask)->Execute(this); break;
#define EXEC_FIRSTPART_RECO_CTXT_TASK(ID) case (ECT_##ID): hr = ((CRCT_##ID *)pTask)->ExecuteFirstPart(this); break;
#define BACK_OUT_RECO_CTXT_TASK(ID) case (ECT_##ID): hr = ((CRCT_##ID *)pTask)->BackOut(this); break;

#define DECLARE_RECO_CTXT_TASK0(ID, FCTN) \
class CRCT_##ID : public ENGINETASK \
{ \
    CRCT_##ID() { InitTask(ECT_##ID, this); } \
public: \
    static HRESULT FCTN(CRecoCtxt *); \
    HRESULT Execute(CRecoInstCtxt *); \
    HRESULT BackOut(CRecoInstCtxt *); \
};


#define DECLARE_RECO_CTXT_TASK1(ID, FCTN, P1) \
class CRCT_##ID : public ENGINETASK \
{ \
    CRCT_##ID() { InitTask(ECT_##ID, this); } \
public: \
    static HRESULT FCTN(CRecoCtxt *, P1); \
    HRESULT ExecuteFirstPart(CRecoInst *); \
    HRESULT Execute(CRecoInstCtxt *); \
    HRESULT BackOut(CRecoInstCtxt *); \
};

#define DECLARE_RECO_CTXT_TASK2(ID, FCTN, P1, P2) \
class CRCT_##ID : public ENGINETASK \
{ \
    CRCT_##ID() { InitTask(ECT_##ID, this); } \
public: \
    static HRESULT FCTN(CRecoCtxt *, P1, P2); \
    HRESULT ExecuteFirstPart(CRecoInst *); \
    HRESULT Execute(CRecoInstCtxt *); \
    HRESULT BackOut(CRecoInstCtxt *); \
};

#define DECLARE_RECO_CTXT_TASK3(ID, FCTN, P1, P2, P3) \
class CRCT_##ID : public ENGINETASK \
{ \
    CRCT_##ID() { InitTask(ECT_##ID, this); } \
public: \
    static HRESULT FCTN(CRecoCtxt *, P1, P2, P3); \
    HRESULT ExecuteFirstPart(CRecoInst *); \
    HRESULT Execute(CRecoInstCtxt *); \
    HRESULT BackOut(CRecoInstCtxt *); \
};

#define DECLARE_RECO_CTXT_TASK4(ID, FCTN, P1, P2, P3, P4) \
class CRCT_##ID : public ENGINETASK \
{ \
    CRCT_##ID() { InitTask(ECT_##ID, this); } \
public: \
    static HRESULT FCTN(CRecoCtxt *, P1, P2, P3, P4); \
    HRESULT ExecuteFirstPart(CRecoInst *); \
    HRESULT Execute(CRecoInstCtxt *); \
    HRESULT BackOut(CRecoInstCtxt *); \
};


DECLARE_RECO_CTXT_TASK0(PAUSECONTEXT, Pause)
DECLARE_RECO_CTXT_TASK0(RESUMECONTEXT, Resume)
DECLARE_RECO_CTXT_TASK3(BOOKMARK, Bookmark, SPBOOKMARKOPTIONS Options, ULONGLONG ullStreamPosition, LPARAM lParamEvent)
DECLARE_RECO_CTXT_TASK2(CALLENGINE, CallEngine, void * pvData, ULONG cbData)
DECLARE_RECO_CTXT_TASK4(CALLENGINEEX, CallEngineEx, const void * pvInData, ULONG cbData, void ** pvCoMemOutData, ULONG * pcbOutData)
DECLARE_RECO_CTXT_TASK0(DELETECONTEXT, DeleteContext)
DECLARE_RECO_CTXT_TASK1(SETEVENTINTEREST, SetEventInterest, ULONGLONG ullEventInterest)
DECLARE_RECO_CTXT_TASK1(SETRETAINAUDIO, SetRetainAudio, BOOL fRetainAudio)
DECLARE_RECO_CTXT_TASK1(SETMAXALTERNATES, SetMaxAlternates, ULONG cMaxAlternates)
DECLARE_RECO_CTXT_TASK2(ADAPTATIONDATA, SetAdaptationData, const WCHAR * pszData, ULONG cchData)
DECLARE_RECO_CTXT_TASK2(CREATEGRAMMAR, CreateGrammar, ULONGLONG ullAppGrammarId, SPGRAMMARHANDLE * phRecoInstGrammar)
DECLARE_RECO_CTXT_TASK1(SETCONTEXTSTATE, SetContextState, SPCONTEXTSTATE eState)


#endif  // #ifndef __SrTask_h__ - Keep as the last line of the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\taskmgr.cpp ===
/*******************************************************************************
* TaskMgr.cpp *
*-------------*
*   Description:
*       This module contains the implementation for the CSpTaskManager,
*   CSpThreadTask, and CSpReoccurringTask classes. These classes are a
*   general faciltiy used to optimize thread usage by SAPI. The task manager
*   is the main object used to create and mangage user defined tasks.
*-------------------------------------------------------------------------------
*  Created By: EDC                                         Date: 09/14/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include <SPHelper.h>
#include <memory.h>
#include <stdlib.h>
#ifndef _WIN32_WCE
#include <process.h>
#endif
#include <limits.h>

#ifndef TaskMgr_h
#include "TaskMgr.h"
#endif

//--- Local data
static const TCHAR szClassName[] = _T("CSpThreadTask Window");


/*****************************************************************************
* CSpTaskManager::FinalConstruct *
*--------------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CSpTaskManager::FinalConstruct()
{
    SPDBG_FUNC( "CSpTaskManager::FinalConstruct" );
    HRESULT hr = S_OK;

    //--- Init vars
    m_fInitialized      = false;
    m_hIOCompPort       = NULL;
    m_ThreadHandles.SetSize( 0 );

    //--- Init the thread pool info
    SYSTEM_INFO SysInfo;
    GetSystemInfo( &SysInfo );
    m_ulNumProcessors = SysInfo.dwNumberOfProcessors;
    m_PoolInfo.lPoolSize          = m_ulNumProcessors * 2;
    m_PoolInfo.lPriority          = THREAD_PRIORITY_NORMAL;
    m_PoolInfo.ulConcurrencyLimit = 0;
    m_PoolInfo.ulMaxQuickAllocThreads = 4;

    m_hTerminateTaskEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    if( m_hTerminateTaskEvent == NULL )
    {   
        hr = SpHrFromLastWin32Error();
    }

    return hr;
} /* CSpTaskManager::FinalConstruct */

/*****************************************************************************
* CSpTaskManager::FinalRelease *
*------------------------------*
*   Description:
*       The CSpTaskManager destructor
********************************************************************* EDC ***/
void CSpTaskManager::FinalRelease( void )
{
    SPDBG_FUNC( "CSpTaskManager::FinalRelease" );

    //--- Do a synchronized stop
    _StopAll();
    if( m_hTerminateTaskEvent )
    {
        ::CloseHandle( m_hTerminateTaskEvent );
    }
} /* CSpTaskManager::FinalRelease */

/*****************************************************************************
* CSpTaskManager::_StartAll *
*---------------------------*
*   Description:
*       This method starts and initializes all of the threads based on the
*   current settings.
********************************************************************* EDC ***/
HRESULT CSpTaskManager::_StartAll( void )
{
    SPDBG_FUNC( "CSpTaskManager::_StartAll" );
    HRESULT hr = S_OK;
    m_fThreadsShouldRun = true;
    m_dwNextGroupId = 1;
    m_dwNextTaskId  = 1;

    if( m_PoolInfo.lPoolSize > 0 )
    {
        //--- Create the completion port
#ifndef _WIN32_WCE
        // IO Completion ports are not supported for CE. So we take the Win95/98 path.
        m_hIOCompPort = ::CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL,
                                                  0, m_PoolInfo.ulConcurrencyLimit );
#endif

        //--- If we cannot create the completion port then we will use
        //    a simple semaphore object. This is the normal case on Win95/98
        if( !m_hIOCompPort )
        {
            hr = m_SpWorkAvailSemaphore.Init(0);
        }
        m_ThreadHandles.SetSize( 0 );
    }
    //--- We'll delay the actual thread creation until 
    m_fInitialized = TRUE;
    return hr;
} /* CSpTaskManager::_StartAll */

/*****************************************************************************
* CSpTaskManager::_StopAll *
*--------------------------*
*   Description:
*       This method waits for all the threads in the pool to stop.
********************************************************************* EDC ***/
HRESULT CSpTaskManager::_StopAll( void )
{
    SPDBG_FUNC( "CSpTaskManager::_StopAll" );
    HRESULT hr = S_OK;
    DWORD i;

    //--- Get the number of threads that were successfully created
    //  Note: in a creation error condition this may be less than
    //        the thread pool size
    DWORD NumThreads = m_ThreadHandles.GetSize();

    if( NumThreads > 0 )
    {
        //--- Notify threads to terminate
        m_fThreadsShouldRun = false;

        //--- Post one dummy work item for each thread to unblock it
#ifndef _WIN32_WCE
        // IO Completion ports are not supported for CE. So we take the Win95/98 path.
        if( m_hIOCompPort )
        {
            for( i = 0; i < NumThreads; ++i )
            {
                ::PostQueuedCompletionStatus( m_hIOCompPort, 0, 0, NULL );
            }
        }
        else
#endif
        {
            m_SpWorkAvailSemaphore.ReleaseSemaphore( NumThreads );
        }

        //--- Wait till all the threads terminate
        ::WaitForMultipleObjects( NumThreads, &m_ThreadHandles[0],
                                  true, INFINITE );

        //--- Close the handles
        for( i = 0; i < NumThreads; ++i )
        {
            ::CloseHandle( m_ThreadHandles[i] );
        }
        m_ThreadHandles.SetSize( 0 );
    }
    //--- Free completion port
    if( m_hIOCompPort )
    {
        ::CloseHandle( m_hIOCompPort );
        m_hIOCompPort = NULL;
    }

    m_SpWorkAvailSemaphore.Close();

    m_fInitialized = FALSE;

    return hr;
} /* CSpTaskManager::_StopAll */

/*****************************************************************************
* CSpTaskManager::_NotifyWorkAvailable *
*--------------------------------------*
*   Description:
*       This function removes the head of the queue and executes it.
********************************************************************* EDC ***/
HRESULT CSpTaskManager::_NotifyWorkAvailable( void )
{
    HRESULT hr = S_OK;

    //--- If there are not enough threads in the pool, start one now.
    ULONG cThreads = m_ThreadHandles.GetSize();
    if (cThreads < (ULONG)m_PoolInfo.lPoolSize && cThreads < m_TaskQueue.GetCount())
    {
        unsigned int ThreadAddr;
        HANDLE hThread = (HANDLE)_beginthreadex( NULL, 0, &TaskThreadProc, this, 0, &ThreadAddr );
        if( hThread )
        {
            hr = m_ThreadHandles.SetAtGrow(cThreads, hThread);

            //--- Set the priority class
            if( SUCCEEDED( hr ) && ( m_PoolInfo.lPriority != THREAD_PRIORITY_NORMAL ) )
            {
                if( !::SetThreadPriority( hThread, m_PoolInfo.lPriority ) )
                {
                    SPDBG_ASSERT(FALSE);  // Ignore this particular error
                }
            }
        }
        else
        {
            SPDBG_ASSERT(FALSE);
            if (cThreads == 0)
            {
                return E_OUTOFMEMORY;
            }
        }
    }

    //--- Signal the thread pool that there is something to do
    if( SUCCEEDED( hr ) )
    {
    #ifndef _WIN32_WCE
        // IO Completion ports are not supported for CE. So we take the Win95/98 path.
        if( m_hIOCompPort )
        {
            if( !::PostQueuedCompletionStatus( m_hIOCompPort, 0, 0, NULL ) )
            {
                hr = SpHrFromLastWin32Error();
            }
        }
        else
    #endif
        {
            m_SpWorkAvailSemaphore.ReleaseSemaphore(1);
        }
    }
    return hr;
} /* CSpTaskManager::_NotifyWorkAvailable */

/*****************************************************************************
* CSpTaskManager::_WaitForWork *
*------------------------------*
*   Description:
*       This function blocks the thread until there is some work to do in
*   one of the queues.
********************************************************************* EDC ***/
HRESULT CSpTaskManager::_WaitForWork( void )
{
    HRESULT hr = S_OK;
#ifndef _WIN32_WCE
    // IO Completion ports are not supported for CE. So we take the Win95/98 path.
    DWORD dwNBT;
    ULONG_PTR ulpCK;
    LPOVERLAPPED pO;
    if( m_hIOCompPort )
    {
        if( !::GetQueuedCompletionStatus( m_hIOCompPort, &dwNBT, &ulpCK, &pO, INFINITE ) )
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    else
#endif
    {
        m_SpWorkAvailSemaphore.Wait(INFINITE);
    }
    return hr;
} /* CSpTaskManager::_WaitForWork */

/*****************************************************************************
* CSpTaskManager::_QueueReoccTask *
*---------------------------------*
*   Description:
*       This function queues the specified reoccurring task for exectuion.
*       THE TASK MANAGER'S CRITICAL SECTION MUST BE OWNED!
********************************************************************* EDC ***/
void CSpTaskManager::_QueueReoccTask( CSpReoccTask* pReoccTask )
{
    pReoccTask->m_TaskNode.fContinue            = true;
    pReoccTask->m_TaskNode.ExecutionState       = TMTS_Pending;
    m_TaskQueue.InsertTail( &pReoccTask->m_TaskNode );
    _NotifyWorkAvailable();
} /* CSpTaskManager::_QueueReoccTask */


// We are intentionally doing multi-destructors with SEH
#pragma warning(disable:4509)

/*****************************************************************************
* TaskThreadProc *
*----------------*
*   Description:
*       This function removes the head of the queue and executes it.
********************************************************************* EDC ***/
unsigned int WINAPI TaskThreadProc( void* pvThis )
{
    SPDBG_FUNC( "CSpTaskManager::TaskThreadProc" );
    CSpTaskManager& TM = *((CSpTaskManager*)pvThis);
    SPLISTPOS TaskPos     = NULL;
    TMTASKNODE* pTaskNode = NULL;
    HRESULT hr = S_OK;
#ifdef _DEBUG
    DWORD TID = ::GetCurrentThreadId();
#endif

    //--- Allow work procs to call COM
    if (FAILED(::CoInitializeEx(NULL,COINIT_APARTMENTTHREADED)))  // COINIT_MULTITHREADED didn't work here
    {
        return -1;
    }

    //--- Main thread loop
    while(1)
    {
        //--- Wait till there is something to do
        if( FAILED( hr = TM._WaitForWork() ) )
        {
            SPDBG_REPORT_ON_FAIL( hr );
            continue;
        }

        //--- Check for termination request
        if( !TM.m_fThreadsShouldRun )
        {
            break;
        }

        //--- Get the next task, if the list was emptied
        //    by a terminate, we may not find a task to do.
        TM.Lock();
        pTaskNode = TM.m_TaskQueue.GetHead();
        while( pTaskNode )
        {
            if( pTaskNode->ExecutionState == TMTS_Pending )
            {
                //--- Clear the do execute flag on reoccurring
                //    Mark as running and break to execute
                if( pTaskNode->pReoccTask )
                {
                    pTaskNode->pReoccTask->m_fDoExecute = false;
                }
                pTaskNode->ExecutionState = TMTS_Running;
                break;
            }
            pTaskNode = pTaskNode->m_pNext;
        }
        TM.Unlock();

        //--- Execute
        if( pTaskNode )
        {
            //--- Execute
            SPDBG_DMSG2( "Executing Task: ThreadID = %lX, TaskPos = %lX\n", TID, TaskPos );
            pTaskNode->pTask->Execute( pTaskNode->pvTaskData, &pTaskNode->fContinue );

            //--- Remove the completed task description from the queue
            SPDBG_DMSG2( "Removing Finished Task From Queue: ThreadID = %lX, TaskPos = %lX\n", TID, TaskPos );
            TM.Lock();
            TM.m_TaskQueue.Remove( pTaskNode );
            if( pTaskNode->ExecutionState == TMTS_WaitingToDie ) 
            {
                ::SetEvent(TM.m_hTerminateTaskEvent);    
            }
            //--- Requeue the task if it is reoccuring and has been signaled
            if( pTaskNode->pReoccTask )
            {
                if ( pTaskNode->pReoccTask->m_fDoExecute  &&
                     pTaskNode->ExecutionState != TMTS_WaitingToDie )
                {
                    TM._QueueReoccTask( pTaskNode->pReoccTask );
                }
                else
                {
                    pTaskNode->ExecutionState = TMTS_Idle;
                }
            }
            else
            {
                pTaskNode->ExecutionState = TMTS_Idle;
                TM.m_FreeTaskList.AddNode( pTaskNode );
            }
            HANDLE hClientCompEvent = pTaskNode->hCompEvent;
            TM.Unlock();

            //--- Notify client that the task is complete
            if( hClientCompEvent )
            {
                ::SetEvent( hClientCompEvent );
            }
        } // end if we have a pTaskNode
    }

    ::CoUninitialize();

    _endthreadex(0);
    return 0;
} /* TaskThreadProc */

#pragma warning(default:4509)

//
//=== ISPTaskManager interface implementation ================================
//


/*****************************************************************************
* CSpTaskManager::CreateReoccurringTask *
*---------------------------------------*
*   Description:
*       The CreateReoccurringTask method is used to create a task entry that
*   will be executed on a high priority thread when the tasks "Execute" method
*   is called. These tasks are intended to support feeding of data to hardware
*   devices.
********************************************************************* EDC ***/
STDMETHODIMP CSpTaskManager::
    CreateReoccurringTask( ISpTask* pTask, void* pvTaskData,
                           HANDLE hCompEvent, ISpNotifySink** ppTaskCtrl )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpTaskManager::CreateReoccurringTask" );
    HRESULT hr = S_OK;
    _LazyInit();

    if( SPIsBadInterfacePtr( (IUnknown*)pTask ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_WRITE_PTR( ppTaskCtrl ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CSpReoccTask> *pReoccTask;
        hr = CComObject<CSpReoccTask>::CreateInstance( &pReoccTask );

        if( SUCCEEDED( hr ) )
        {
            pReoccTask->AddRef();
            pReoccTask->_SetTaskInfo( this, pTask, pvTaskData, hCompEvent );
            *ppTaskCtrl = pReoccTask;
            GetControllingUnknown()->AddRef();
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpTaskManager::CreateReoccurringTask */

/*****************************************************************************
* CSpTaskManager::SetThreadPoolInfo *
*-----------------------------------*
*   Description:
*       The SetThreadPoolInfo interface method is used to define the thread
*   pool attributes.
********************************************************************* EDC ***/
STDMETHODIMP CSpTaskManager::SetThreadPoolInfo( const SPTMTHREADINFO* pPoolInfo )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpTaskManager::SetThreadPoolInfo" );
    HRESULT hr = S_OK;

    //--- Validate args
    if( SP_IS_BAD_READ_PTR( pPoolInfo ) || ( pPoolInfo->lPoolSize < -1 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Kill the current set of tasks
        hr = _StopAll();

        if( SUCCEEDED( hr ) )
        {
            m_PoolInfo = *pPoolInfo;
            if (m_PoolInfo.lPoolSize == -1)
            {
                m_PoolInfo.lPoolSize = ( m_ulNumProcessors * 2 );
            }
            //--- Shrink the running list if necessary.
            while (m_RunningThreadList.GetCount() > m_PoolInfo.ulMaxQuickAllocThreads)
            {
                CSpThreadTask *pKillTask = m_RunningThreadList.RemoveHead();
                SPDBG_ASSERT(pKillTask == NULL || pKillTask->m_pOwner == NULL);
                delete pKillTask;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpTaskManager::SetThreadPoolSize */

/*****************************************************************************
* CSpTaskManager::GetThreadPoolInfo *
*-----------------------------------*
*   Description:
*       The GetThreadPoolInfo interface method is used to return the current
*   thread pool attributes.
********************************************************************* EDC ***/
STDMETHODIMP CSpTaskManager::GetThreadPoolInfo( SPTMTHREADINFO* pPoolInfo )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpTaskManager::GetThreadPoolSize" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pPoolInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pPoolInfo = m_PoolInfo;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpTaskManager::GetThreadPoolSize */

/*****************************************************************************
* CSpTaskManager::QueueTask *
*---------------------------*
*   Description:
*       The QueueTask interface method is used to add a task to
*   the FIFO queue for asynchronous execution.
********************************************************************* EDC ***/
STDMETHODIMP CSpTaskManager::
    QueueTask( ISpTask* pTask, void* pvTaskData, HANDLE hCompEvent,
               DWORD* pdwGroupId, DWORD* pTaskId )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC( "CSpTaskManager::QueueTask" );
    HRESULT hr = S_OK;
    _LazyInit();

    //--- Check formal args
    if( SPIsBadInterfacePtr( (IUnknown*)pTask ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pTaskId ) ||
             SP_IS_BAD_OPTIONAL_WRITE_PTR( pdwGroupId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Reset the event object
        if( hCompEvent && !::ResetEvent( hCompEvent ) )
        {
            //--- bad event object
            hr = SpHrFromLastWin32Error();
        }
        else
        {
            //--- If we don't have any threads in the pool then execute in place
            if( m_PoolInfo.lPoolSize == 0 )
            {
                //--- Give back a task ID
                if( pTaskId ) *pTaskId = m_dwNextTaskId++;;

                //--- Execute on the calling thread
                BOOL bContinue = true;
                pTask->Execute( pvTaskData, &bContinue );

                //--- Signal the callers event
                if( hCompEvent )
                {
                    if( !::SetEvent( hCompEvent ) )
                    {
                        hr = SpHrFromLastWin32Error();
                    }
                }
            }
            else
            {
                TMTASKNODE* pNode;
                hr = m_FreeTaskList.RemoveFirstOrAllocateNew(&pNode);
                if( SUCCEEDED(hr) )
                {
                    ZeroMemory( pNode, sizeof( *pNode ) );
                    pNode->pTask      = pTask;
                    pNode->pvTaskData = pvTaskData;
                    pNode->hCompEvent = hCompEvent;
                    pNode->fContinue  = true;
                    pNode->dwTaskId   = m_dwNextTaskId++;
                    pNode->ExecutionState = TMTS_Pending;
                    if( pdwGroupId )
                    {
                        //--- Assign a unique group Id if they didn't specify one
                        if( *pdwGroupId == 0 )
                        {
                            *pdwGroupId = m_dwNextGroupId++;
                        }
                        pNode->dwGroupId = *pdwGroupId;
                    }
                    //--- Return task Id if they want one
                    if( pTaskId )
                    {
                        *pTaskId = pNode->dwTaskId;
                    }
                    //--- Add Task to end of queue
                    m_TaskQueue.InsertTail(pNode);
                    _NotifyWorkAvailable();
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpTaskManager::QueueTask */

/*****************************************************************************
* CSpTaskManager::TerminateTaskGroup *
*------------------------------------*
*   Description:
*       The TerminateTaskGroup interface method is used to terminate a group
*   of tasks matching the specified group ID.
********************************************************************* EDC ***/
STDMETHODIMP CSpTaskManager::TerminateTaskGroup( DWORD dwGroupId, ULONG ulWaitPeriod )
{
    Lock(); // This must be first or the debug output can get confused
    SPDBG_FUNC( "CSpTaskManager::TerminateTaskGroup" );
    HRESULT hr = S_OK;
#ifdef _DEBUG
    DWORD TID = ::GetCurrentThreadId();
#endif

    if (m_ThreadHandles.GetSize())    // If no threads, no work to kill...
    {
        ULONG cExitIds = 0;
        DWORD * ExitIds = (DWORD *)alloca( m_TaskQueue.GetCount() * sizeof(DWORD) );
        //--- Search task queue
        for( TMTASKNODE* pNode = m_TaskQueue.GetHead(); pNode; pNode = pNode->m_pNext )
        {
            if( pNode->dwGroupId == dwGroupId )
            {
                pNode->fContinue = FALSE;
                ExitIds[cExitIds++] = pNode->dwTaskId;
            }
        }
        Unlock();   // We'd better not wait with the critical seciton owned!
        while (cExitIds && hr == S_OK)
        {
            --cExitIds;
            TerminateTask(ExitIds[cExitIds], ulWaitPeriod);
        }
    }
    else
    {
        Unlock();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpTaskManager::TerminateTaskGroup */

/*****************************************************************************
* CSpTaskManager::TerminateTask *
*-------------------------------*
*   The TerminateTask interface method is used to interrupt the specified task.
********************************************************************* EDC ***/
STDMETHODIMP CSpTaskManager::TerminateTask( DWORD dwTaskId, ULONG ulWaitPeriod )
{
    m_TerminateCritSec.Lock();
    Lock();
    SPDBG_FUNC( "CSpTaskManager::TerminateTask" );
    HRESULT hr = S_OK;
    HANDLE hSem = NULL;
#ifdef _DEBUG
    DWORD TID = ::GetCurrentThreadId();
#endif

    if (m_ThreadHandles.GetSize())    // If no threads, no work to kill...
    {
        BOOL bWait = FALSE;
        //--- Search task queue
        //    If the task is already waiting to die, it will be found,
        //    but not waited on again.
        TMTASKNODE* pNode = m_TaskQueue.GetHead();
        while( pNode )
        {
            if( pNode->dwTaskId == dwTaskId )
            {
                if( pNode->ExecutionState == TMTS_Pending )
                {
                    //--- If it's not running, just remove it
                    SPDBG_DMSG2( "Removing Non Running Queued Task: ThreadID = %lX, pNode = %lX\n", TID, pNode );
                    m_TaskQueue.MoveToList( pNode, m_FreeTaskList );
                }
                else if( pNode->ExecutionState == TMTS_Running )
                {
                    //--- It's running 
                    SPDBG_DMSG2( "Waiting to kill running Queued Task: ThreadID = %lX, pNode = %lX\n", TID, pNode );
                    pNode->ExecutionState = TMTS_WaitingToDie;
                    bWait = TRUE;
                }
                break;
            }
            pNode = pNode->m_pNext;
        }
        Unlock();

        //--- Wait till they've terminated if they had event objects
        if( bWait )
        {
            DWORD dwRes = ::WaitForSingleObject( m_hTerminateTaskEvent, ulWaitPeriod );
            if ( dwRes == WAIT_FAILED )
            {
                hr = SpHrFromLastWin32Error();
            }
            else if ( dwRes == WAIT_TIMEOUT )
            {
                hr = S_FALSE;
            }
        }
    }
    else
    {
        Unlock();
    }
    m_TerminateCritSec.Unlock();
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpTaskManager::TerminateTasks */


/*****************************************************************************
* CSpTaskManager::CreateThreadControl *
*-------------------------------------*
*   Description:
*       This method allocates a thread control object.  It does not allocate a thread.
*       Note that the task manager's controlling IUnknown is addref'd since the allocated
*       thread control object uses the thread pool in the task manager.
*   Parameters:
*       pTask
*           Pointer to a virtual interface (not a COM interface) used to
*           initialize and execute the task thread.
*       pvTaskData 
*           This parmeter can point to any data the caller wishes or can
*           be NULL.  It will be passed to all member functions of the
*           ISpThreadTask interface.
*       nPriority
*           The WIN32 thread priority for the allocated thread.
*       ppThreadCtrl
*           The returned thread control interface.
*   Return:
*       If successful, ppThreadCtrl contains a pointer to the newly created object.
*   Error returns:
*       E_INVALIDARG
*       E_POINTER
*       E_OUTOFMEMORY
********************************************************************* RAL ***/

STDMETHODIMP CSpTaskManager::CreateThreadControl(ISpThreadTask* pTask, void* pvTaskData, long nPriority, ISpThreadControl ** ppThreadCtrl)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_READ_PTR(pTask))  // not exactly right
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(ppThreadCtrl))
        {
            hr = E_POINTER;
        }
        else
        {
            CComObject<CSpThreadControl> * pThreadCtrl;
            hr = CComObject<CSpThreadControl>::CreateInstance(&pThreadCtrl);
            if (SUCCEEDED(hr))
            {
                pThreadCtrl->m_pTaskMgr = this;
                GetControllingUnknown()->AddRef();
                pThreadCtrl->m_pThreadTask = NULL;
                pThreadCtrl->m_pClientTaskInterface = pTask;
                pThreadCtrl->m_pvClientTaskData = pvTaskData;
                pThreadCtrl->m_nPriority = nPriority;
                pThreadCtrl->QueryInterface(ppThreadCtrl);
            }
        }
    }
    return hr;
}

//
//=== class CSpReoccTask ===========================================================
//
//  NOTE:  We never claim the critical section of the CSpReoccTask object.  Instead,
//  synchronization is accomplished using two critical sections in the task manager.
//

/*****************************************************************************
* CSpReoccTask constructor *
*----------------------------*
*   Description:
*       Resets the m_TaskNode member.
********************************************************************* EDC ***/

CSpReoccTask::CSpReoccTask()
{
    ZeroMemory(&m_TaskNode, sizeof(m_TaskNode));
    m_TaskNode.ExecutionState = TMTS_Idle;
}


/*****************************************************************************
* CSpReoccTask::FinalRelease *
*----------------------------*
*   Description:
*       The FinalRelease method is used to destroy this task.  Since there is
*   only a single event handle which is used for task termination, this function
*   claims the m_TerminateCritSec as well as the task manager critical section.
********************************************************************* RAL ***/
void CSpReoccTask::FinalRelease()
{
    SPDBG_FUNC( "CSpReoccTask::FinalRelease" );

    m_pTaskMgr->m_TerminateCritSec.Lock();
    m_pTaskMgr->Lock();
    //--- Make sure this task isn't currently executing
    if( m_TaskNode.ExecutionState == TMTS_Running )
    {
        m_TaskNode.ExecutionState = TMTS_WaitingToDie;
        m_pTaskMgr->Unlock();
        ::WaitForSingleObject( m_pTaskMgr->m_hTerminateTaskEvent, INFINITE );
        m_pTaskMgr->Lock();
    }
    //--- Remove this object from the reoccurring task list if it's on it.
    m_pTaskMgr->m_TaskQueue.Remove( &m_TaskNode );
    m_pTaskMgr->Unlock();
    m_pTaskMgr->m_TerminateCritSec.Unlock();

    //--- Remove ref from task manager
    m_pTaskMgr->GetControllingUnknown()->Release();     // Could bring the whole world down!
        
} /* CSpReoccTask::FinalRelease */

/*****************************************************************************
* CSpReoccTask::Notify *
*----------------------*
*   Description:
*       The Notify interface method is used to signal a reoccurring
*   task to execute.
********************************************************************* EDC ***/
STDMETHODIMP CSpReoccTask::Notify( void )
{
    SPAUTO_OBJ_LOCK_OBJECT( m_pTaskMgr );        // Just use TM crit section...
    SPDBG_FUNC( "CSpReoccTask::Notify" );
    HRESULT hr = S_OK;

    //--- Mark this task for execution
    m_fDoExecute = true;
    if( m_TaskNode.ExecutionState == TMTS_Idle )
    {
        m_pTaskMgr->_QueueReoccTask( this );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpReoccTask::Notify */

//
//=== class CSpReoccTask ===========================================================
//
//  NOTE:  We never claim the critical section of the CSpReoccTask object.  Instead,
//  synchronization is accomplished using two critical sections in the task manager.
//


//


/*      Use for logic of final release!
        if ( m_hThread && WaitForThreadDone(TRUE, NULL, 1000) == S_OK )
        {
            m_pTaskMgr->Lock();
            if (m_pTaskMgr->m_RunningThreadList.GetCount() < m_pTaskMgr->m_PoolInfo.ulMaxQuickAllocThreads)
            {
                bDeleteThis = FALSE;
                m_pTaskMgr->m_RunningThreadList.InsertHead( this );
            }
            m_pTaskMgr->Unlock();
        }
        m_pTaskMgr->GetControllingUnknown()->Release();       // This may kill us!
        if (bDeleteThis)
        {
            delete this;
        }
    }
    return l;
}
*/

HRESULT CSpThreadControl::FinalConstruct()
{
    HRESULT hr = S_OK;
    m_hrThreadResult = S_OK;
    m_pTaskMgr = NULL;

    hr = m_autohNotifyEvent.InitEvent(NULL, FALSE, FALSE, NULL);

    if (SUCCEEDED(hr))
    {
        hr = m_autohThreadDoneEvent.InitEvent(NULL, TRUE, TRUE, NULL);
    }

    return hr;
}

void CSpThreadControl::FinalRelease()
{
    WaitForThreadDone(TRUE, NULL, 5000);

    Lock(); // Prevent thread from freeing itself randomly.
    if (m_pThreadTask && !m_pThreadTask->m_fBeingDestroyed)
    {
        delete m_pThreadTask;   // Strange -- Did not clean up properly.  Kill it.
    }
    Unlock();
    if (m_pTaskMgr)
    {
        m_pTaskMgr->GetControllingUnknown()->Release();
    }
}
 
void CSpThreadControl::ThreadComplete()
{
    CSpThreadTask *pKillTask = NULL;

    Lock();
    m_pTaskMgr->Lock();
    m_pThreadTask->m_pOwner = NULL;
    //
    //  Don't delete this task since we're on the task thread at this point.  If the pool is too
    //  big then delete the "oldest" task in the list.
    //
    //  Even if the pool size is set to 0, we always will allow at least on (since we can't kill ourselves!)
    //
    ULONG c = m_pTaskMgr->m_RunningThreadList.GetCount();
    if (c && c >= m_pTaskMgr->m_PoolInfo.ulMaxQuickAllocThreads)
    {
        pKillTask = m_pTaskMgr->m_RunningThreadList.RemoveTail();
    }
    if(!m_pThreadTask->m_fBeingDestroyed)
    {
        m_pTaskMgr->m_RunningThreadList.InsertHead( m_pThreadTask );
    }
    m_pTaskMgr->Unlock();
    m_pThreadTask = NULL;
    m_autohThreadDoneEvent.SetEvent();
    Unlock();
    // Kill any other thread outside of the crit sections!
    SPDBG_ASSERT(pKillTask == NULL || pKillTask->m_pOwner == NULL);
    delete pKillTask;
}



//--- ISpNotifySink and ISpThreadNotifySink implementation --------------------------------
//
//  A note about critical secitons:  We never take a critical section.  If the thread is
//  ever killed, the handle is set to NULL by an interlocked exchange.  All other API
//  methods don't use the thread handle.
//

/*****************************************************************************
* CSpThreadControl::Notify *
*-----------------------*
*   Description:
*       Typically, this will only be called by a notify site.
********************************************************************* RAL ***/
STDMETHODIMP CSpThreadControl::Notify()
{
    HRESULT hr = S_OK;
    if (!::SetEvent(m_autohNotifyEvent))
    {
        hr = SpHrFromLastWin32Error();
    }
    return hr;
} /* CSpThreadControl::Notify */


/*****************************************************************************
* CSpThreadControl::StartThread *
*-------------------------------*
*   Description:
*   Parameters:
*       dwFlags
*           Unused (tbd).
*       phwnd
*           An optional pointer to an HWND.  If this parmeter is NULL then no window
*           will be created for the task.  If it is non-null then the newly created
*           window handle will be returned at *phwnd.
*                   
********************************************************************* RAL ***/
STDMETHODIMP CSpThreadControl::StartThread(DWORD dwFlags, HWND * phwnd)
{
    SPDBG_FUNC("CSpThreadControl::StartThread");
    HRESULT hr = S_OK;
    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(phwnd))
    {
        hr = E_POINTER;
    }
    else if (dwFlags)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        Lock();
        if (m_pThreadTask)
        {
            m_pThreadTask->m_bContinueProcessing = FALSE;
            m_pThreadTask->m_autohExitThreadEvent.SetEvent();
            Unlock();
            m_autohThreadDoneEvent.Wait(INFINITE);
            Lock();
            SPDBG_ASSERT(m_pThreadTask == NULL);
        }
        m_pTaskMgr->Lock();
        CSpThreadTask * pThreadTask = m_pTaskMgr->m_RunningThreadList.FindAndRemove(m_nPriority);
        if (pThreadTask == NULL)
        {
            pThreadTask = m_pTaskMgr->m_RunningThreadList.RemoveHead();
            if (pThreadTask == NULL)
            {
                pThreadTask = new CSpThreadTask();
            }
        }
        m_pTaskMgr->Unlock();
        if (pThreadTask == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pThreadTask->Init(this, phwnd);    
            if (FAILED(hr))
            {
                delete pThreadTask;
            }
            else
            {
                m_pThreadTask = pThreadTask;
            }
        }
        Unlock();
    }
    return hr;
}



/*****************************************************************************
* CSpThreadControl::TerminateThread *
*--------------------------------*
*   Description:
*       
********************************************************************* RAL ***/
STDMETHODIMP CSpThreadControl::TerminateThread()
{
    Lock();
    if (m_pThreadTask && !m_pThreadTask->m_fBeingDestroyed)
    {
        delete m_pThreadTask;
        m_pThreadTask = NULL;
    }
    Unlock();
    return S_OK;
} /* CSpThreadControl::TerminateThread */

/*****************************************************************************
* CSpThreadControl::WaitForThreadDone *
*----------------------------------*
*   Description:
*       
********************************************************************* RAL ***/
STDMETHODIMP CSpThreadControl::
    WaitForThreadDone( BOOL fForceStop, HRESULT * phrThreadResult, ULONG msTimeOut )
{
    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(phrThreadResult))
    {
        return E_POINTER;
    }

    Lock();
    HRESULT hr = S_OK;

    if (m_pThreadTask)
    {
        if (fForceStop)
        {
            m_pThreadTask->m_bContinueProcessing = FALSE;
            m_pThreadTask->m_autohExitThreadEvent.SetEvent();
        }
        Unlock();
        hr = m_autohThreadDoneEvent.HrWait(msTimeOut);
    }
    else
    {
        Unlock();
    }
    if (phrThreadResult)
    {
        *phrThreadResult = m_hrThreadResult;
    }
    return hr;
} /* CSpThreadControl::WaitForThreadDone */


/****************************************************************************
* CSpThreadControl Handle Access Methods *
*----------------------------------------*
*   Description:
*       The following are simple handle access methods.
********************************************************************* RAL ***/
STDMETHODIMP_(HANDLE) CSpThreadControl::ThreadHandle( void )
{
    Lock();
    HANDLE h = m_pThreadTask ? static_cast<HANDLE>(m_pThreadTask->m_autohThread) : NULL;
    Unlock();
    return h;
} /* CSpThreadControl::ThreadHandle */

STDMETHODIMP_(DWORD) CSpThreadControl::ThreadId( void )
{
    Lock();
    DWORD Id = m_pThreadTask ? m_pThreadTask->m_ThreadId : 0;
    Unlock();
    return Id;
} /* CSpThreadControl::ThreadId */

STDMETHODIMP_(HANDLE) CSpThreadControl::NotifyEvent( void )
{
    return m_autohNotifyEvent;
} /* CSpThreadControl::NotifyEvent */

STDMETHODIMP_(HWND) CSpThreadControl::WindowHandle( void )
{
    Lock();
    HWND h = m_pThreadTask ? m_pThreadTask->m_hwnd : NULL;
    Unlock();
    return h;
} /* CSpThreadControl::WindowHandle */

STDMETHODIMP_(HANDLE) CSpThreadControl::ThreadCompleteEvent( void )
{
    return m_autohThreadDoneEvent;
} /* CSpThreadControl::ThreadCompleteEvent */

STDMETHODIMP_(HANDLE) CSpThreadControl::ExitThreadEvent( void )
{
    Lock();
    HANDLE h = m_pThreadTask ?
         static_cast<HANDLE>(m_pThreadTask->m_autohExitThreadEvent) : NULL;
    Unlock();
    return h;
} /* CSpThreadControl::ThreadId */

//
//=== class CSpThreadTask ===========================================================
//
//  This class is not implemented as an ATL object so that the lifetime can be managed
//  by the task manager.  When the object is released for the final time, it will simply
//  be placed back into the task manager's list of available threads unless there are already
//  enough threads in the pool.
//
//  CSpThreadTask objects have four event objects.  Two are used by the client:
//      m_hNotifyEvent is an auto-reset event which is set every time the Notify() method
//      is called on this object.
//      m_hExitThreadEvent is a manual reset event that will be set when the Stop() method
//      is called or when this object is released for the final time (which calls Stop).
//  Both the m_hNotifyEvent and m_hExitThreadEvent are passed to the clients ThreadProc
//  method.
//  The other two events are used for internal synchronization.  These are:
//      m_hThreadDoneEvent is a manual reset event which indicates that the thread has
//      completed the specified operation.  Normally, this indicates that the ThreadProc
//      has exited.  During the Init() call this has a special use.  See Init() for details.
//      m_hRunThreadEvent is an auto-reset event that is used by the object's thread
//      to block until the thread should run.  This is used only in cleanup code, the Init
//      method, and the thread procedure.  See Init() for details.

/*****************************************************************************
* CSpThreadTask::(Constructor)*
*-----------------------------*
*   Description:
*       This object is created with a ref count of 0 and the parent is NOT addref'd
*   until the Init() method is successful.  The constructor simply resets the object
*   to a default uninitialzied state.
********************************************************************* RAL ***/

CSpThreadTask::CSpThreadTask() 
{
    m_bWantHwnd = FALSE;
    m_pOwner = NULL;
    m_hwnd = NULL;
    m_fBeingDestroyed = FALSE;
}

/*****************************************************************************
* CSpThreadTask::(Destructor) *
*----------------------------*
*   Description:
*       If the thread is currently not running (m_pOwner == NULL) then
*       attempt to close the thread in a clean manner by telling the thread to exit by setting m_autohRunThreadEvent.
*       If the thread is currently running we set the m_autohExitThreadEvent to tell the 
*       thread proc to exit. In either case, if the thread
*       does not exit within 5 seconds, we are in big trouble and have to hang, until the thread does exit.
*       However all well-behaved threads will exit.
*       The parent ThreadControl lock must be obtained before deleting a thread task,
*       if it is possible that the thread is running. Similarly must check the m_fBeingDestroyed before
*       deletion (but after obtaining lock) to prevent multiple deletions.
*
********************************************************************* RAL ***/

CSpThreadTask::~CSpThreadTask()
{
    m_fBeingDestroyed = TRUE; // Mark so no-one else will try and delete and so ThreadComplete does not add back into running list
    if (m_autohThread)
    {
        CSpThreadControl *pOwner = m_pOwner; // Keep local copy of this in case m_pOwner set to NULL elsewhere

        if (pOwner == NULL)  // Are we in a non-running state?
        {                                               // Yes: Try to exit gracefully...
            m_autohRunThreadEvent.SetEvent();           // Wake it up and it should die
        }
        else
        {   // We are deleting a thread task while thread is still running. Signal exit.
            m_autohExitThreadEvent.SetEvent();
            m_autohRunThreadEvent.SetEvent();
        }

        // Wait for the thread to exit

        // If this task has a running thread then we must unlock here or ThreadComplete() will hang.
        // Note we can only get here if m_pOwner non-null and must therefore be always locked.
        // You can hit this code from two places:
        //  - ThreadControl::FinalRelease - only one thread can be in this method
        //  - TerminateThread multiple threads can be here but not while in FinalRelease
        //  - All other places m_pOwner must be NULL
        // Thus the only issue seems to be calling TerminateThread on two different threads at once.
        // To avoid this we use fBeingDestroyed flag.
        if(pOwner)
        {
            pOwner->Unlock();
        }

        if (m_autohThread.Wait(5000) != WAIT_OBJECT_0)
        {
            // We were unable to exit - this indicates that the thread is not exiting
            // and may be hung.

            // We will potentially hang here. However there seems to be no sensible way
            // of either deleting (with TerminateThread), or leaving the thread running (in case in does eventually return).
            m_autohThread.Wait(INFINITE);
        }

        if(pOwner)
        {
            pOwner->Lock(); // We entered in a locked state so re-lock
        }

        m_autohThread.Close();

        //
        //  NOTE:  We can't destroy a window on another thread, but the system will clean up any
        //         resources used when we call TerminateThread.
        //
        m_hwnd = NULL;      // The window is definately gone now! 
        ////::SetEvent(m_hThreadDoneEvent);
    }
    m_autohExitThreadEvent.Close();
    m_autohRunThreadEvent.Close();

}



/*****************************************************************************
* CSpThreadTask::Init *
*---------------------*
*   Description:
*       
********************************************************************* RAL ***/
HRESULT CSpThreadTask::Init(CSpThreadControl * pOwner, HWND * phwnd)
{
    HRESULT hr = S_OK;
    m_pOwner = pOwner;
    if (phwnd)
    {
        m_bWantHwnd = TRUE;
        *phwnd = NULL;
    }
    else
    {
        m_bWantHwnd = FALSE;
    }
    m_bWantHwnd = (phwnd != NULL);
    pOwner->m_hrThreadResult = S_OK;
    if (!m_autohThread)
    {
        hr = m_autohExitThreadEvent.InitEvent(NULL, TRUE, FALSE, NULL);
        if (SUCCEEDED(hr))
        {
            hr = m_autohRunThreadEvent.InitEvent(NULL, FALSE, FALSE, NULL);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_autohInitDoneEvent.InitEvent(NULL, FALSE, FALSE, NULL);
        }
        if (SUCCEEDED(hr))
        {
            unsigned int ThreadId;
            m_autohThread = (HANDLE)_beginthreadex( NULL, 0, &ThreadProc, this, 0, &ThreadId );
            if (!m_autohThread)
            {
                hr = SpHrFromLastWin32Error();
            }
            else
            {
                // We know that thread ID's are always DWORDs in Win32 even on 64-bit platforms
                // so this is OK.
                m_ThreadId = ThreadId;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        m_bContinueProcessing = TRUE;
        ::ResetEvent(m_autohExitThreadEvent);
        ::ResetEvent(pOwner->m_autohThreadDoneEvent);
        //
        //  The thread is now started and blocked on hRunThreadEvent.  Change the priority
        //  if necessary.  If it fails for some reason, we set m_pOwner to NULL to indicate
        //  that the thread should exit.
        //
        if (::GetThreadPriority(m_autohThread) != pOwner->m_nPriority &&
            (!::SetThreadPriority(m_autohThread, pOwner->m_nPriority)))
        {
            hr = SpHrFromLastWin32Error();
            m_pOwner = NULL;    // Force the thread to exit.
            ::SetEvent(m_autohRunThreadEvent);
        }
        else
        {
            ::SetEvent(m_autohRunThreadEvent);
            m_autohInitDoneEvent.Wait(INFINITE);
            hr = pOwner->m_hrThreadResult;
        }
        if (SUCCEEDED(hr))
        {
            if (phwnd)
            {
                *phwnd = m_hwnd;
            }
            ::SetEvent(m_autohRunThreadEvent);  // Now wake the thread up and let it go
            m_autohInitDoneEvent.Wait(INFINITE); // Wait a second time to guarantee the thread really
                                                 // is running before we exit.
        }
        else
        {
            //
            //  Since we got a failure to initialize, we need to wait for the thread to exit
            //  and then we'll return the error.
            //
            ::WaitForSingleObject(m_autohThread, INFINITE);
        }
    }
    if (FAILED(hr))
    {
        m_pOwner = NULL;
    }

    return hr;
} /* CSpThreadTask::Init */



unsigned int WINAPI CSpThreadTask::ThreadProc( void* pvThis )
{
    SPDBG_FUNC( "CSpThreadTask::ThreadProc" );
    return ((CSpThreadTask *)pvThis)->MemberThreadProc();
}

/*****************************************************************************
* CSpThreadTask::MemberThreadProc *
*---------------------------------*
*   Description:
*       
********************************************************************* RAL ***/
DWORD CSpThreadTask::MemberThreadProc()
{
    //--- Allow work procs to call COM
    m_pOwner->m_hrThreadResult = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(m_pOwner->m_hrThreadResult))
    {
        while (TRUE)
        {
            ::WaitForSingleObject(m_autohRunThreadEvent, INFINITE);
            if (m_pOwner == NULL)      // If no owner then we're exiting
            {
                break;
            }
            if (m_bWantHwnd)
            {
                m_hwnd = ::CreateWindow(szClassName, szClassName,
                                               0, 0, 0, 0, 0, NULL, NULL,
                                               _Module.GetModuleInstance(), this);
                if (m_hwnd == NULL)
                {
                    m_pOwner->m_hrThreadResult = SpHrFromLastWin32Error();
                }
            }
            if (SUCCEEDED(m_pOwner->m_hrThreadResult))
            {
                m_pOwner->m_hrThreadResult = m_pOwner->m_pClientTaskInterface->InitThread(m_pOwner->m_pvClientTaskData, m_hwnd);
            }
            ::SetEvent(m_autohInitDoneEvent);
            //
            //  If we have failed to initialize for any reason, we'll kill the thread
            //
            if (FAILED(m_pOwner->m_hrThreadResult))
            {
                if (m_hwnd)
                {
                    ::DestroyWindow(m_hwnd);
                    m_hwnd = NULL;
                }
                break;
            }
            //
            //  The thread is happy, and initialized properly so call the thread proc when
            //  the RunThread event is set again.
            //
            m_autohRunThreadEvent.Wait(INFINITE);
            ::SetEvent(m_autohInitDoneEvent); // Set the initdone event a second time so Init() won't exit immediately
            m_pOwner->m_hrThreadResult = m_pOwner->m_pClientTaskInterface->ThreadProc(m_pOwner->m_pvClientTaskData, m_autohExitThreadEvent, m_pOwner->m_autohNotifyEvent, m_hwnd, &m_bContinueProcessing);
            if (m_hwnd)
            {
                ::DestroyWindow(m_hwnd);
                m_hwnd = NULL;
            }
            ///::SetEvent(m_hThreadDoneEvent);
            m_pOwner->ThreadComplete();   // This will return us to the free pool... and pOwner is now NULL!!!
        }
        ::CoUninitialize();
    }
    else
    {
        ::SetEvent(m_autohInitDoneEvent); // Initialization failed but we must always signal creating thread.
    }

//    ::SetEvent(m_hThreadDoneEvent);     // Always set this event at exit
    return 0;
} /* CSpThreadTask::MemberThreadProc */


//=== Window class registration =========================================

void CSpThreadTask::RegisterWndClass(HINSTANCE hInstance)
{
    WNDCLASS wc;
    ZeroMemory(&wc, sizeof(wc));
    wc.lpfnWndProc = CSpThreadTask::WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = szClassName;
    if (RegisterClass(&wc) == 0)
    {
        SPDBG_ASSERT(TRUE);
    }
}

void CSpThreadTask::UnregisterWndClass(HINSTANCE hInstance)
{
    ::UnregisterClass(szClassName, hInstance);
}

LRESULT CALLBACK CSpThreadTask::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSpThreadTask * pThis = (CSpThreadTask *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (uMsg == WM_CREATE)
    {
        pThis = (CSpThreadTask *)(((CREATESTRUCT *) lParam)->lpCreateParams);
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
    }
    if (pThis)
    {
        return pThis->m_pOwner->m_pClientTaskInterface->WindowMessage(pThis->m_pOwner->m_pvClientTaskData, hwnd, uMsg, wParam, lParam);
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\taskmgr.h ===
/*******************************************************************************
* TaskMgr.h *
*-----------*
*   Description:
*       This is the header file for the CSpTaskManager and CSpTaskQueue
*   implementations.
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 08/26/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef TaskMgr_h
#define TaskMgr_h

//--- Additional includes
#ifndef __sapi_h__
#include <sapi.h>
#endif

#include "resource.h"
#include "SpSemaphore.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CSpTaskManager;
class CSpReoccTask;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

typedef enum TMTASKSTATE
{
    TMTS_Pending,
    TMTS_Running,
    TMTS_WaitingToDie,
    TMTS_Idle            // Applies to reoccuring tasks only
};

//--- Task management types
struct TMTASKNODE
{
    TMTASKSTATE   ExecutionState;    // Execution state of this task
    ISpTask*      pTask;             // Caller's task
    void*         pvTaskData;        // Caller's task data
    HANDLE        hCompEvent;        // Caller's task completion event
    DWORD         dwGroupId;         // Task group Id, may be 0
    DWORD         dwTaskId;          // Execution instance Id
    BOOL          fContinue;         // true if the executing thread should continue
    CSpReoccTask* pReoccTask;        // Pointer to reoccuring task if it is one
    TMTASKNODE*   m_pNext;           // next node (note: m_ prefix required by queue template)
#ifdef _WIN32_WCE
    // This is here because the CE compiler is expanding templates for functions
    // that aren't being called
    static LONG Compare(const TMTASKNODE *, const TMTASKNODE *)
    {
        return 0;
    }
#endif
};



/*** CSpReoccTask
*   This object is used to represent a reoccurring high priority task
*   that is predefined and can be executed via its signal method.t
*/
class ATL_NO_VTABLE CSpReoccTask :
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpNotifySink
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CSpReoccTask)
        COM_INTERFACE_ENTRY(ISpNotifySink)
    END_COM_MAP()

  /*=== Member Data ===*/
    CSpTaskManager* m_pTaskMgr;
    BOOL            m_fDoExecute;
    TMTASKNODE      m_TaskNode;

  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    CSpReoccTask();
    void FinalRelease();

    /*--- Non interface methods ---*/
    void _SetTaskInfo( CSpTaskManager* pTaskMgr, ISpTask* pTask,
                       void* pvTaskData, HANDLE hCompEvent )
    {
        memset( &m_TaskNode, 0, sizeof( m_TaskNode ) );
        m_pTaskMgr            = pTaskMgr;
        m_fDoExecute          = false;
        m_TaskNode.pReoccTask = this;
        m_TaskNode.pTask      = pTask;
        m_TaskNode.pvTaskData = pvTaskData;
        m_TaskNode.hCompEvent = hCompEvent;
        m_TaskNode.ExecutionState = TMTS_Idle;
    }

    /*--- ISpNotify ---*/
    STDMETHOD( Notify )( void );
};


class CSpThreadControl;

//
//  This class is not a COM object
//
class CSpThreadTask 
{
public:
  /*=== Member Data ===*/
    BOOL            m_bWantHwnd;
    BOOL            m_bContinueProcessing;
    HWND            m_hwnd;
    DWORD           m_ThreadId;
    BOOL            m_fBeingDestroyed;
    CSpThreadControl * m_pOwner;
    CSpAutoEvent    m_autohExitThreadEvent;
    CSpAutoEvent    m_autohRunThreadEvent;
    CSpAutoEvent    m_autohInitDoneEvent;
    CSpAutoHandle   m_autohThread;
    CSpThreadTask * m_pNext;            // Used by queue template
////    CSpTaskManager * const m_pTaskMgr;  // When lRef != 0 this is addref'd, otherwise just a ptr.
//    long            m_lRef;

    /*=== Methods =======*/
    /*--- Constructors ---*/
    CSpThreadTask();
    ~CSpThreadTask();
 

    /*--- Static members ---*/
    static void RegisterWndClass(HINSTANCE hInstance);
    static void UnregisterWndClass(HINSTANCE hInstance);
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static unsigned int WINAPI ThreadProc( void* pvThis );

    /*--- Non interface methods ---*/
    HRESULT Init(CSpThreadControl * pOwner, HWND * phwnd);
    DWORD MemberThreadProc( void );
    void Cleanup( void );
    
    //
    //  Operator used for FindAndRemove() to find a thread with the appropriate priority
    //  Compares an int to the thread priority and returns TRUE if they are equal.
    //
    BOOL operator==(int nPriority)
    {
        return (::GetThreadPriority(m_autohThread) == nPriority);
    }
#ifdef _WIN32_WCE
    // This is here because the CE compiler is expanding templates for functions
    // that aren't being called
    static LONG Compare(const CSpThreadTask *, const CSpThreadTask *)
    {
        return 0;
    }
#endif
};


class ATL_NO_VTABLE CSpThreadControl :
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpThreadControl
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CSpThreadControl)
        COM_INTERFACE_ENTRY(ISpNotifySink)
        COM_INTERFACE_ENTRY(ISpThreadControl)
    END_COM_MAP()

  /*=== Member Data ===*/
    CSpTaskManager* m_pTaskMgr;
    CSpThreadTask * m_pThreadTask;
    long            m_nPriority;
    ISpThreadTask * m_pClientTaskInterface;
    void          * m_pvClientTaskData;
    CSpAutoEvent    m_autohNotifyEvent;
    CSpAutoEvent    m_autohThreadDoneEvent;
    HRESULT         m_hrThreadResult;

  /*=== Methods =======*/
    HRESULT FinalConstruct();
    void FinalRelease();
    void ThreadComplete();

  public:
    /*--- ISpNotifySink ---*/
    STDMETHOD( Notify )( void );

    /*--- ISpThreadControl ---*/
    STDMETHOD( StartThread )( DWORD dwFlags, HWND * phwnd );
    STDMETHOD( TerminateThread )( void );
    STDMETHOD_( DWORD, ThreadId )( void );
    STDMETHOD( WaitForThreadDone )( BOOL fForceStop, HRESULT * phrThreadResult, ULONG msTimeOut );
    STDMETHOD_( HANDLE, ThreadHandle )( void );
    STDMETHOD_( HANDLE, NotifyEvent )( void );
    STDMETHOD_( HWND, WindowHandle )( void );
    STDMETHOD_( HANDLE, ThreadCompleteEvent )( void );
    STDMETHOD_( HANDLE, ExitThreadEvent )( void );
};




typedef CSpBasicQueue<TMTASKNODE, TRUE, TRUE> CTaskQueue;
typedef CSpBasicList<TMTASKNODE> CTaskList;

typedef CSPArray<HANDLE,HANDLE> CTMHandleArray;
typedef CSpBasicQueue<CSpThreadTask, TRUE, TRUE> CTMRunningThreadList;

/*** CSpTaskManager
*
*/
class ATL_NO_VTABLE CSpTaskManager :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpTaskManager, &CLSID_SpTaskManager>,
    public ISpTaskManager
{
    friend unsigned int WINAPI TaskThreadProc( void* pThis );

  /*=== ATL Setup ===*/
  public:
    DECLARE_POLY_AGGREGATABLE(CSpTaskManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_SPTASKMANAGER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CSpTaskManager)
        COM_INTERFACE_ENTRY(ISpTaskManager)
    END_COM_MAP()

  /*=== Member Data ===*/
    //--- Task management data
    CComAutoCriticalSection m_TerminateCritSec;
    HANDLE                  m_hTerminateTaskEvent;
    BOOL                    m_fInitialized;
    CTaskQueue              m_TaskQueue;
    CTaskList               m_FreeTaskList;
    CTMRunningThreadList    m_RunningThreadList;
    CTMHandleArray          m_ThreadHandles;
    CTMHandleArray          m_ThreadCompEvents;
    HANDLE                  m_hIOCompPort;
    CSpSemaphore            m_SpWorkAvailSemaphore;
    SPTMTHREADINFO          m_PoolInfo;
    volatile BOOL           m_fThreadsShouldRun;
    DWORD                   m_dwNextTaskId;
    DWORD                   m_dwNextGroupId;
    ULONG                   m_ulNumProcessors;

  /*=== Methods =======*/
    /*--- Constructors ---*/
    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Non interface methods ---*/
    HRESULT _LazyInit( void );
    HRESULT _StartAll( void );
    HRESULT _StopAll( void );
    HRESULT _NotifyWorkAvailable( void );
    HRESULT _WaitForWork( void );
    void _QueueReoccTask( CSpReoccTask* pReoccTask );
    HANDLE _DupSemAndIncWaitOnTask(TMTASKNODE & tn);

    /*--- ISPTaskManager ---*/
    STDMETHOD( SetThreadPoolInfo )( const SPTMTHREADINFO* pPoolInfo );
    STDMETHOD( GetThreadPoolInfo )( SPTMTHREADINFO* pPoolInfo );
    STDMETHOD( QueueTask )( ISpTask* pTask, void* pvTaskData, HANDLE hCompEvent,
                            DWORD* pdwGroupId, DWORD* pTaskID );
    STDMETHOD( TerminateTask )( DWORD dwTaskID, ULONG ulWaitPeriod );
    STDMETHOD( TerminateTaskGroup )( DWORD dwGroupId, ULONG ulWaitPeriod );
    STDMETHOD( CreateReoccurringTask )( ISpTask* pTask, void* pvTaskData,
                                        HANDLE hCompEvent, ISpNotifySink** ppTaskCtrl );
    STDMETHOD( CreateThreadControl )( ISpThreadTask* pTask, void* pvTaskData, long nPriority,
                                      ISpThreadControl** ppThreadCtrl );
};

//=== Inline Function Definitions ==================================
inline HRESULT CSpTaskManager::_LazyInit( void )
{
    HRESULT hr = S_OK;
    if( !m_fInitialized )
    {
        hr = _StartAll();
        m_fInitialized = SUCCEEDED(hr);
    }
    return hr;
}


//=== Macro Definitions ============================================

//=== Global Data Declarations =====================================

//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED_)
#define AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#define _WIN32_WINNT 0x0600

//#define _ATL_DEBUG_QI

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include "mmsystem.h"
#include "mmreg.h"
#include "msacm.h"

#ifndef _WIN32_WCE
#pragma intrinsic( strcat, strlen, strcpy, memcpy )
#endif

#include "SAPIINT.h"
#include "SpUnicode.H"
#include "sapiarray.h"
#include "stringblob.h"
#include <SPDDKHlp.h>
#include "SpAutoHandle.h"
#include "SpAutoMutex.h"
#include "SpAutoEvent.h"
#include "SPINTHlp.h"
#include <SPCollec.h>
#include "SpATL.h"
#include "resource.h"
#include "SpAutoObjectLock.h"
#include "SpAutoCritSecLock.h"
#include "StringHlp.h"

extern CSpUnicodeSupport g_Unicode;

extern DWORD SpWaitForSingleObjectWithUserOverride(HANDLE, DWORD);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\vendorlx.cpp ===
/*******************************************************************************
* VendorLx.cpp *
*--------------*
*       Implements the vendor lexicon object for SR and TTS lookup lexicons
*
*  Owner: YUNUSM                                        Date: 06/18/99
*  Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

//--- Includes ----------------------------------------------------------------
#include "StdAfx.h"
#include "PhoneConv.h"
#include "VendorLx.h"
#include <initguid.h>

//--- Globals -----------------------------------------------------------------
// {12B545C3-3003-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(guidLkupValidationId, 
0x12b545c3, 0x3003, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

//--- Constructor, Initializer and Destructor functions ------------------------

/*******************************************************************************
* CCompressedLexicon::CCompressedLexicon *
*--------------------------------*
*
*   Description:
*       Constructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
CCompressedLexicon::CCompressedLexicon(void)
{
    SPDBG_FUNC("CCompressedLexicon::CCompressedLexicon");
    NullMembers();
}

/*******************************************************************************
* CCompressedLexicon::~CCompressedLexicon *
*---------------------------------*
*
*   Description:
*       Destructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
CCompressedLexicon::~CCompressedLexicon()
{
    SPDBG_FUNC("CCompressedLexicon::~CCompressedLexicon");
    CleanUp();
}

/*******************************************************************************
* CCompressedLexicon::CleanUp *
*-------------------------*
*
*   Description:
*       real destructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CCompressedLexicon::CleanUp(void)
{
    SPDBG_FUNC("CCompressedLexicon::CleanUp");
    
    delete m_pWordsDecoder;
    delete m_pPronsDecoder;
    delete m_pPosDecoder;

    UnmapViewOfFile(m_pLkup);
    CloseHandle(m_hLkupMap);
    CloseHandle(m_hLkupFile);
    NullMembers();
}
    
/*******************************************************************************
* CCompressedLexicon::NullMembers *
*-----------------------------*
*
*   Description:
*       null data
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CCompressedLexicon::NullMembers(void)
{
    SPDBG_FUNC("CCompressedLexicon::NullMembers");

    m_fInit = false;
    m_cpObjectToken = NULL;
    m_pLkupLexInfo = NULL;
    m_hLkupFile = NULL;
    m_hLkupMap = NULL;
    m_pLkup = NULL;
    m_pWordHash = NULL;
    m_pCmpBlock = NULL;
    m_pWordsDecoder = NULL;
    m_pPronsDecoder = NULL;
    m_pPosDecoder = NULL;
}

//--- ISpLexicon methods -------------------------------------------------------

/*****************************************************************************
* CCompressedLexicon::GetPronunciations *
*-----------------------------------*
*
*   Description:
*       Gets the pronunciations and POSs of a word
*
*   Return:
*       LEXERR_NOTINLEX
*       E_OUTOFMEMORY
*       S_OK
**********************************************************************YUNUSM*/
STDMETHODIMP CCompressedLexicon::GetPronunciations(const WCHAR * pwWord,                               // word
                                               LANGID LangID,                                          // lcid of the word
                                               DWORD dwFlags,                                      // lextype
                                               SPWORDPRONUNCIATIONLIST * pWordPronunciationList    // buffer to return prons in
                                               )
{
    SPDBG_FUNC("CCompressedLexicon::GetPronunciations");
    
    HRESULT hr = S_OK;
    if (!pwWord || !pWordPronunciationList)
    {
        return E_POINTER;
    }
    if (SPIsBadLexWord(pwWord) || (LangID != m_pLkupLexInfo->LangID && LangID) ||
        SPIsBadWordPronunciationList(pWordPronunciationList))
    {
        return E_INVALIDARG;
    }
    if (!m_fInit)
    {
        return SPERR_UNINITIALIZED;
    }

    WCHAR wszWord[SP_MAX_WORD_LENGTH];
    wcscpy(wszWord, pwWord);
    _wcslwr(wszWord);
    DWORD dHash = GetWordHashValue(wszWord, m_pLkupLexInfo->nLengthHashTable);
 
    // Cannot just index into hash table since each element in hash table is 
    // m_pLkupLexInfo->nBitsPerHashEntry long
    WCHAR wszReadWord[SP_MAX_WORD_LENGTH];
    DWORD dOffset = 0;
    while (SUCCEEDED(hr))
    {
        dOffset = GetCmpHashEntry (dHash);
        if (CompareHashValue (dOffset, (DWORD)-1))
        {
            hr = SPERR_NOT_IN_LEX;
            break;
        }
        if (SUCCEEDED(hr))
        {
            hr = ReadWord (&dOffset, wszReadWord);
        }
        // Use the vendor lexicon's lcid so that we dont use 0 if the passed in lcid is 0
        int nCmp = g_Unicode.CompareString(m_pLkupLexInfo->LangID, NORM_IGNORECASE, wszWord, -1, wszReadWord, -1);
        if (!nCmp)
        {
            hr = SpHrFromLastWin32Error(); // probably the lcid's language pack is not installed on machine
        }
        else
        {
            if (CSTR_EQUAL != nCmp)
            {
                dHash++;
                if (dHash == m_pLkupLexInfo->nLengthHashTable)
                {
                    dHash = 0;
                }
                continue;
            } 
            else
            {
                break;
            }
        }
    }
    DWORD dwInfoBytesNeeded = 0;
    DWORD dwNumInfoBlocks = 0;
    DWORD dwMaxInfoLen = 0;
    if (SUCCEEDED(hr))
    {
        hr = ReallocSPWORDPRONList(pWordPronunciationList, m_pLkupLexInfo->nMaxWordInfoLen);
    }
    SPWORDPRONUNCIATION *pWordPronPrev = NULL;
    SPWORDPRONUNCIATION *pWordPronReturned = NULL;
    WCHAR wszLkupPron[SP_MAX_PRON_LENGTH];
    bool fLast = false;
    bool fLastPron = false;
    if (SUCCEEDED(hr))
    {
        pWordPronReturned = ((UNALIGNED SPWORDPRONUNCIATIONLIST *)pWordPronunciationList)->pFirstWordPronunciation;
    }
    while (SUCCEEDED(hr) && (false == fLast))
    {
        // Read the control block (CBSIZE bits)
        // Length is 2 because of the way CopyBitsAsDWORDs works when the bits
        // to be copied straddle across DWORDs
        DWORD cb[4]; // Could just be 2 DWORDS...
        cb[0] = 0;
        SPDBG_ASSERT(CBSIZE <= 8);
        CopyBitsAsDWORDs (cb, m_pCmpBlock, dOffset, CBSIZE);
        dOffset += CBSIZE;
        
        if (cb[0] & (1 << (CBSIZE - 1)))
        {
            fLast = true;
        }
        int CBType = cb[0] & ~(-1 << (CBSIZE -1));
        switch  (CBType)
        {
        case ePRON:
            {
                if (fLastPron == true)
                {
                    // The last pron did not have a POS. Finalize this SPWORDPRONUNCIATION node
                    pWordPronReturned->eLexiconType = (SPLEXICONTYPE)dwFlags;
                    pWordPronReturned->ePartOfSpeech = SPPS_NotOverriden;
                    pWordPronReturned->LangID = m_pLkupLexInfo->LangID;
                    wcscpy(pWordPronReturned->szPronunciation, wszLkupPron);
                            
                    pWordPronPrev = pWordPronReturned;
                    pWordPronReturned = (SPWORDPRONUNCIATION*)(((BYTE*)pWordPronReturned) + sizeof(SPWORDPRONUNCIATION) + 
                                     wcslen(pWordPronReturned->szPronunciation) * sizeof(WCHAR));
                    pWordPronPrev->pNextWordPronunciation = pWordPronReturned;
                }
                else
                {
                    fLastPron = true;
                }
                DWORD dOffsetSave = dOffset;
                DWORD CmpLkupPron[SP_MAX_PRON_LENGTH]; // as DWORDS may be 4 times as big as it needs to be
                DWORD nCmpBlockLen;
                if (m_pLkupLexInfo->nCompressedBlockBits & 0x7)
                {
                    nCmpBlockLen = (m_pLkupLexInfo->nCompressedBlockBits >> 3) + 1;
                }
                else
                {
                    nCmpBlockLen = m_pLkupLexInfo->nCompressedBlockBits >> 3;
                }
                // Get the amount of compressed block after dOffset in bytes
                // We include the byte in which dOffset bit occurs if dOffset
                // is not a byte boundary
                DWORD nLenDecode = nCmpBlockLen - (dOffsetSave >> 3);
                if (nLenDecode > SP_MAX_PRON_LENGTH)
                {
                    nLenDecode = SP_MAX_PRON_LENGTH;
                }
                CopyBitsAsDWORDs (CmpLkupPron, m_pCmpBlock, dOffsetSave, (nLenDecode << 3));
                // Decode the pronunciation
                int iBit = (int)dOffset;
                PWSTR p = wszLkupPron;
                HUFFKEY k = 0;
                while (SUCCEEDED(hr = m_pPronsDecoder->Next(m_pCmpBlock, &iBit, &k)))
                {
                    *p++ = k;
                    if (!k)
                    {
                        break;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    SPDBG_ASSERT(!k && iBit);
                    // Increase the offset past the encoded pronunciation
                    dOffset = iBit;
                }
                break;
            }
        
        case ePOS:
            {
                fLastPron = false;
        
                DWORD CmpPos[4]; // Could be 2 DWORDs...
                CopyBitsAsDWORDs(CmpPos, m_pCmpBlock, dOffset, POSSIZE);
        
                int iBit = (int)dOffset;
                HUFFKEY k = 0;
                hr = m_pPosDecoder->Next(m_pCmpBlock, &iBit, &k);
                if (SUCCEEDED(hr))
                {
                    // Increase the offset past the encoded pronunciation
                    dOffset = iBit;
                    pWordPronReturned->eLexiconType = (SPLEXICONTYPE)dwFlags;
                    pWordPronReturned->LangID = m_pLkupLexInfo->LangID;
                    pWordPronReturned->ePartOfSpeech = (SPPARTOFSPEECH)k;
                    wcscpy(pWordPronReturned->szPronunciation, wszLkupPron);
        
                    pWordPronPrev = pWordPronReturned;
                    pWordPronReturned = CreateNextPronunciation (pWordPronReturned);
                    pWordPronPrev->pNextWordPronunciation = pWordPronReturned;
                }
                break;
            }
        
        default:
            SPDBG_ASSERT(0);
            hr = E_FAIL;
        } // switch (CBType)
    } // while (SUCCEEDED(hr) && (false == fLast))
    if (SUCCEEDED(hr))
    {
        if (fLastPron == true)
        {
            // The last pron did not have a POS. Finalize this SPWORDPRONUNCIATION node
            pWordPronReturned->eLexiconType = (SPLEXICONTYPE)dwFlags;
            pWordPronReturned->ePartOfSpeech = SPPS_NotOverriden;
            pWordPronReturned->LangID = m_pLkupLexInfo->LangID;
            wcscpy(pWordPronReturned->szPronunciation, wszLkupPron);
            pWordPronPrev = pWordPronReturned;
        }
 
        pWordPronPrev->pNextWordPronunciation = NULL;
    }
    return hr;
}

STDMETHODIMP CCompressedLexicon::AddPronunciation(const WCHAR *, LANGID, SPPARTOFSPEECH, const SPPHONEID *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CCompressedLexicon::RemovePronunciation(const WCHAR *, LANGID, SPPARTOFSPEECH, const SPPHONEID *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CCompressedLexicon::GetGeneration(DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CCompressedLexicon::GetGenerationChange(DWORD, DWORD*, SPWORDLIST *)
{
    return E_NOTIMPL;
}
                                  
STDMETHODIMP CCompressedLexicon::GetWords(DWORD, DWORD *, DWORD *, SPWORDLIST *)
{
    return E_NOTIMPL;
}

//--- ISpObjectToken methods ---------------------------------------------------

STDMETHODIMP CCompressedLexicon::GetObjectToken(ISpObjectToken **ppToken)
{
    return SpGenericGetObjectToken(ppToken, m_cpObjectToken);
}

/*******************************************************************************
* CCompressedLexicon::SetObjectToken *
*--------------------------------*
*
*   Description:
*       Initializes the CCompressedLexicon object
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
STDMETHODIMP CCompressedLexicon::SetObjectToken(ISpObjectToken * pToken // token pointer
                                            )
{
    SPDBG_FUNC("CCompressedLexicon::SetObjectToken");
    
    HRESULT hr = S_OK;
    CSpDynamicString dstrLexFile;
    if (!pToken)
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr) && SPIsBadInterfacePtr(pToken))
    {
        hr = E_INVALIDARG;
    }
    if (SUCCEEDED(hr))
    {
        hr = SpGenericSetObjectToken(pToken, m_cpObjectToken);
    }
    LOOKUPLEXINFO LkupInfo;
    // Get the lookup data file name
    if (SUCCEEDED(hr))
    {
        hr = m_cpObjectToken->GetStringValue(L"Datafile", &dstrLexFile);
    }
    // Read the lookup file header
    if (SUCCEEDED(hr))
    {
        m_hLkupFile = g_Unicode.CreateFile(dstrLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
        if (m_hLkupFile == INVALID_HANDLE_VALUE)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        DWORD dwRead;
        if (!ReadFile(m_hLkupFile, &LkupInfo, sizeof(LOOKUPLEXINFO), &dwRead, NULL) || dwRead != sizeof(LOOKUPLEXINFO))
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        if (LkupInfo.guidValidationId != guidLkupValidationId)
        {
            hr = E_INVALIDARG;
        }
    }
    /** WARNING **/
    // It is not recommended to do ReadFile/WriteFile and CreateFileMapping
    // on the same file handle. That is why we close the file handle and open it again and
    // create the map
    CloseHandle(m_hLkupFile);
    // Get the map name - We build the map name from the lexicon id
    OLECHAR szMapName[64];
    if (SUCCEEDED(hr))
    {
        if (!StringFromGUID2(LkupInfo.guidLexiconId, szMapName, sizeof(szMapName)/sizeof(OLECHAR)))
        {
            hr = E_FAIL;
        }
    }
    // open the datafile
    if (SUCCEEDED(hr))
    {
#ifdef _WIN32_WCE
        m_hLkupFile = g_Unicode.CreateFileForMapping(dstrLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
#else
        m_hLkupFile = g_Unicode.CreateFile(dstrLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
#endif
        if (m_hLkupFile == INVALID_HANDLE_VALUE)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    // Map the lookup lexicon
    if (SUCCEEDED(hr))
    {
        m_hLkupMap = g_Unicode.CreateFileMapping(m_hLkupFile, NULL, PAGE_READONLY | SEC_COMMIT, 0 , 0, szMapName);
        if (!m_hLkupMap) 
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pLkup = (PBYTE)MapViewOfFile(m_hLkupMap, FILE_MAP_READ, 0, 0, 0);
        if (!m_pLkup)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    PBYTE pWordCB = NULL;
    PBYTE pPronCB = NULL;
    PBYTE pPosCB = NULL;
    if (SUCCEEDED(hr))
    {
        PBYTE p = m_pLkup;
        // Header
        m_pLkupLexInfo = (PLOOKUPLEXINFO)p;
        p += sizeof (LOOKUPLEXINFO);
        // Words Codebook
        pWordCB = p;
        p += m_pLkupLexInfo->nWordCBSize;
        // Prons Codebook
        pPronCB = p;
        p += m_pLkupLexInfo->nPronCBSize;
        // Pos Codebook
        pPosCB = p;
        p += m_pLkupLexInfo->nPosCBSize;
        // Word hash table holding offsets into the compressed block
        m_pWordHash = p;
        p += (((m_pLkupLexInfo->nBitsPerHashEntry * m_pLkupLexInfo->nLengthHashTable) + 0x7) & (~0x7)) / 8;
        m_pCmpBlock = (PDWORD)p;
    }
    if (SUCCEEDED(hr))
    {
        m_pWordsDecoder = new CHuffDecoder(pWordCB);
        if (!m_pWordsDecoder)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pPronsDecoder = new CHuffDecoder(pPronCB);
        if (!m_pPronsDecoder)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pPosDecoder = new CHuffDecoder(pPosCB);
        if (!m_pPosDecoder)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_fInit = true;
    }
    return hr;
}

/*****************************************************************************
* CCompressedLexicon::GetCmpHashEntry *
*---------------------------------*
*
*   Description:
*       Get the entry in hash table at index dHash
*  
*   Return:
*       DWORD
**********************************************************************YUNUSM*/
inline DWORD CCompressedLexicon::GetCmpHashEntry(DWORD dHash     // hash value
                                             )
{
    SPDBG_FUNC("CCompressedLexicon::GetCmpHashEntry");
    
    DWORD d = 0;
    DWORD dBitStart = dHash * m_pLkupLexInfo->nBitsPerHashEntry;
    SPDBG_ASSERT(m_pLkupLexInfo->nBitsPerHashEntry < 8 * sizeof (d));
    for (DWORD i = 0; i < m_pLkupLexInfo->nBitsPerHashEntry; i++)
    {
        d <<= 1; // No change the first time since d is 0
        d |= ((m_pWordHash[dBitStart >> 3] >> (7 ^ (dBitStart & 7))) & 1);
        dBitStart++;
    }
    return d;
}

/*****************************************************************************
* CCompressedLexicon::CompareHashValue *
*----------------------------------*
*
*   Description:
*       Do a compare over the valid bit range
*
*   Return:
*       bool
**********************************************************************YUNUSM*/
inline bool CCompressedLexicon::CompareHashValue(DWORD dHash,    // hash value
                                             DWORD d         // value to compare against
                                             )
{
    SPDBG_FUNC("CCompressedLexicon::CompareHashValue");
    return (dHash == (d & ~(-1 << m_pLkupLexInfo->nBitsPerHashEntry)));
}

/*****************************************************************************
* CCompressedLexicon::CopyBitsAsDWORDs *
*----------------------------------*
*
*   Description:
*     Copy nBits from pSource at dSourceOffset bit to pDest
*
*   Return:
*       bool
**********************************************************************YUNUSM*/
inline void CCompressedLexicon::CopyBitsAsDWORDs(PDWORD pDest,         // destination buffer
                                             PDWORD pSource,       // source buffer
                                             DWORD dSourceOffset,  // offset in source buffer
                                             DWORD nBits           // nuber of bits to copy
                                             )
{
    SPDBG_FUNC("CCompressedLexicon::CopyBitsAsDWORDs");
    
    DWORD sDWORDs = dSourceOffset >> 5;
    DWORD sBit = dSourceOffset & 0x1f;
    // Figure out how many DWORDs dSourceOffset - dSourceOffset + nBits straddles
    DWORD nDWORDs = nBits ? 1 : 0;
    DWORD nNextDWORDBoundary = ((dSourceOffset + 0x1f) & ~0x1f);
    if (!nNextDWORDBoundary)
    {
        nNextDWORDBoundary = 32;
    }
    while (nNextDWORDBoundary < (dSourceOffset + nBits))
    {
        nDWORDs++;
        nNextDWORDBoundary += 32;
    }
    CopyMemory (pDest, pSource + sDWORDs, nDWORDs * sizeof (DWORD));
    if (sBit)
    {
        for (DWORD i = 0; i < nDWORDs; i++)
        {
            pDest[i] >>= sBit;
            if (i < nDWORDs - 1)
            {
                pDest[i] |= (pDest[i+1] << (32 - sBit));
            }
            else
            {
                pDest[i] &= ~(-1 << (32 - sBit));
            }
        }
    }
}

/*****************************************************************************
* CCompressedLexicon::ReadWord *
*--------------------------*
*
*   Description:
*       Read the (compressed) word at the dOffset bit and return the word and the new offset
*
*   Return:
*       E_FAIL
*       S_OK
**********************************************************************YUNUSM*/
inline HRESULT CCompressedLexicon::ReadWord(DWORD *dOffset,             // offset to read from, offset after word returned
                                        PWSTR pwWord                // Buffer to fill with word
                                        )
{
    SPDBG_FUNC("CCompressedLexicon::ReadWord");
    
    HRESULT hr = S_OK;
    // Get the length of the entire compressed block in bytes
    DWORD nCmpBlockLen;
    if (m_pLkupLexInfo->nCompressedBlockBits % 8)
    {
        nCmpBlockLen = (m_pLkupLexInfo->nCompressedBlockBits / 8) + 1;
    }
    else
    {
        nCmpBlockLen = m_pLkupLexInfo->nCompressedBlockBits / 8;
    }
    // Get the amount of compressed block after *dOffset in bytes
    // We include the byte in which *dOffset bit occurs if *dOffset
    // is not a byte boundary
    DWORD nLenDecode = nCmpBlockLen - ((*dOffset) / 8);
    if (nLenDecode > 2*SP_MAX_WORD_LENGTH)
    {
        nLenDecode = 2*SP_MAX_WORD_LENGTH;
    }
    // We dont know the length of the word. Just keep decoding and 
    // stop when you encounter a NULL. Since we allow words of maximum
    // length SP_MAX_WORD_LENGTH chars and the compressed word *can* theoretically be
    // longer than the word itself, a buffer of length 2*SP_MAX_WORD_LENGTH is used.
    BYTE BufToDecode[2*SP_MAX_WORD_LENGTH + 4];
    CopyBitsAsDWORDs ((DWORD*)BufToDecode, m_pCmpBlock, *dOffset, nLenDecode * 8);
    PWSTR pw = pwWord;
    int iBit = (int)*dOffset;
    HUFFKEY k = 0;
    while (SUCCEEDED(m_pWordsDecoder->Next (m_pCmpBlock, &iBit, &k)))
    {
        *pw++ = k;
        if (!k)
        {
            break;
        }
    }
    SPDBG_ASSERT(!k && iBit);
    *dOffset = iBit;
    if (pw == pwWord)
    {
        SPDBG_ASSERT(0);
        hr = E_FAIL;
    }
    return hr;
}

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\vendorlx.h ===
/*******************************************************************************
*   VendorLx.h
*       This is the header file for the CCompressedLexicon class that implements
*       the read-only vendor lexicons.
*   
*   Owner: yunusm                                               Date: 06/18/99
*   Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include "resource.h"
#include "HuffD.h"
#include "CommonLx.h"

//--- Class, Struct and Union Definitions -------------------------------------

/*******************************************************************************
*
*   CCompressedLexicon
*
****************************************************************** YUNUSM *****/
class ATL_NO_VTABLE CCompressedLexicon : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCompressedLexicon, &CLSID_SpCompressedLexicon>,
    public ISpLexicon,
    public ISpObjectWithToken
{
//=== ATL Setup ===
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_COMPRESSEDLEXICON)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CCompressedLexicon)
        COM_INTERFACE_ENTRY(ISpLexicon)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
    END_COM_MAP()

//=== Methods ===
public:
    //--- Ctor, dtor, etc
    CCompressedLexicon();
    ~CCompressedLexicon();

//=== Interfaces ===
public:
    //--- ISpLexicon
    STDMETHODIMP GetPronunciations(const WCHAR * pwWord, LANGID LangID, DWORD dwFlags, SPWORDPRONUNCIATIONLIST * pWordPronunciationList);
    STDMETHODIMP AddPronunciation(const WCHAR * pwWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciations);
    STDMETHODIMP RemovePronunciation(const WCHAR * pszWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciation);
    STDMETHODIMP GetGeneration(DWORD *pdwGeneration);
    STDMETHODIMP GetGenerationChange(DWORD dwFlags, DWORD *pdwGeneration, SPWORDLIST *pWordList);
    STDMETHODIMP GetWords(DWORD dwFlags, DWORD *pdwGeneration, DWORD *pdwCookie, SPWORDLIST *pWordList);

    //--- ISpObjectWithToken
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

//=== Private methods ===
private:
    void     CleanUp(void);
    void     NullMembers(void);
    DWORD    GetCmpHashEntry(DWORD dhash);
    bool     CompareHashValue(DWORD dhash, DWORD d);
    void     CopyBitsAsDWORDs(PDWORD pDest, PDWORD pSource, DWORD dSourceOffset, DWORD nBits);
    HRESULT  ReadWord(DWORD *dOffset, PWSTR pwWord);
    HRESULT  ReadWordInfo(PWSTR pWord, SPLEXWORDINFOTYPE Type, DWORD *dOffset,
                                              PBYTE pProns, DWORD dLen, DWORD *pdLenRequired);
    
//=== Private data ===    
private:
    bool              m_fInit;          // true if successfully inited
    CComPtr<ISpObjectToken> m_cpObjectToken; // Token object
    HANDLE            m_hLkupFile;      // Handle to lookup file
    HANDLE            m_hLkupMap;       // Handle to map on lookup file
    PBYTE             m_pLkup;          // Pointer to view on map on lookup file
    PBYTE             m_pWordHash;      // Word hash table holding offsets into the compressed block
    PDWORD            m_pCmpBlock;      // Pointer to compressed block holding words + CBs + prons
    LOOKUPLEXINFO     *m_pLkupLexInfo;  // Lookup lex info header
    CHuffDecoder      *m_pWordsDecoder; // Huffman decoder for words
    CHuffDecoder      *m_pPronsDecoder; // Huffman decoder for pronunciations
    CHuffDecoder      *m_pPosDecoder;   // Huffman decoder for part of speech
};

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\wavstream.cpp ===
// WavStream.cpp : Implementation of CWavStream
#include "stdafx.h"

#ifndef __sapi_h__
#include <sapi.h>
#endif

#include "WavStream.h"
#include "StreamHlp.h"

const FOURCC    g_fourccFormat      = mmioFOURCC('f','m','t',' ');
const FOURCC    g_fourccEvents      = mmioFOURCC('E', 'V', 'N', 'T');
const FOURCC    g_fourccTranscript  = mmioFOURCC('T','e','X','t');
const FOURCC    g_fourccWave        = mmioFOURCC('W','A','V','E');
const FOURCC    g_fourccData        = mmioFOURCC('d','a','t','a');

/////////////////////////////////////////////////////////////////////////////
// CWavStream


//
//  Inline helpers convert mmioxxx functions into standard HRESULT based methods
//

/****************************************************************************
* MMIORESULT_TO_HRESULT *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT _MMIORESULT_TO_HRESULT(MMRESULT mm)
{
    SPDBG_FUNC("_MMIORESULT_TO_HRESULT");

    switch (mm)
    {
    case MMSYSERR_NOERROR:
        return S_OK;

    case MMSYSERR_NOMEM:
    case MMIOERR_OUTOFMEMORY:
        return E_OUTOFMEMORY; 

    case MMIOERR_CANNOTSEEK:
        return STG_E_SEEKERROR;

    case MMIOERR_CANNOTWRITE:
        return STG_E_WRITEFAULT;

    case MMIOERR_CANNOTREAD:
        return STG_E_READFAULT;

    case MMIOERR_PATHNOTFOUND: 
        return STG_E_PATHNOTFOUND;

    case MMIOERR_FILENOTFOUND:
        return STG_E_FILENOTFOUND;

    case MMIOERR_ACCESSDENIED:
        return STG_E_ACCESSDENIED;

    case MMIOERR_SHARINGVIOLATION:
        return STG_E_SHAREVIOLATION;

    case MMIOERR_TOOMANYOPENFILES:
        return STG_E_TOOMANYOPENFILES;

    case MMIOERR_CANNOTCLOSE:
        return STG_E_CANTSAVE;

    case MMIOERR_INVALIDFILE:
    case MMIOERR_CHUNKNOTFOUND:         // Assume that a missing chunk is an invalid file
        return SPERR_INVALID_WAV_FILE;

    default:
        // MMIOERR_CANNOTOPEN
        // MMIOERR_CANNOTEXPAND  
        // MMIOERR_CHUNKNOTFOUND 
        // MMIOERR_UNBUFFERED    
        // MMIOERR_NETWORKERROR  
        // + any other unknown codes become...
        return STG_E_UNKNOWN;
    }
}


/****************************************************************************
* CWavStream::MMOpen *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CWavStream::MMOpen(const WCHAR * pszFileName, DWORD dwOpenFlags)
{
    SPDBG_FUNC("CWavStream::MMOpen");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_hFile == NULL);
    MMIOINFO mmioinfo;
    memset(&mmioinfo, 0, sizeof(mmioinfo));
    m_hFile = g_Unicode.mmioOpen(pszFileName, &mmioinfo, dwOpenFlags);
    if(m_hFile == NULL)
    {
        hr = _MMIORESULT_TO_HRESULT(mmioinfo.wErrorRet);
    }

    return hr;
}

inline HRESULT CWavStream::MMClose()
{
    SPDBG_ASSERT(m_hFile);
    HRESULT hr = _MMIORESULT_TO_HRESULT(::mmioClose(m_hFile, 0));
    m_hFile = NULL;
    return hr;
}

inline HRESULT CWavStream::MMSeek(LONG lOffset, int iOrigin, LONG * plNewPos)
{
    HRESULT hr = S_OK;
    *plNewPos = ::mmioSeek(m_hFile, lOffset, iOrigin);
    if (*plNewPos == -1)
    {
        hr = STG_E_SEEKERROR;
    }
    return hr;
}

inline HRESULT CWavStream::MMRead(void * pv, LONG cb, LONG * plBytesRead)
{
    HRESULT hr = S_OK;
    *plBytesRead = ::mmioRead(m_hFile, (HPSTR)pv, cb);
    if (*plBytesRead == -1)
    {
        *plBytesRead = 0;
        hr = STG_E_READFAULT;
    }
    return hr;
}

inline HRESULT CWavStream::MMReadExact(void * pv, LONG cb)
{
    LONG lReadSize;
    HRESULT hr = MMRead(pv, cb, &lReadSize);
    if (SUCCEEDED(hr) && lReadSize != cb)
    {
        hr = SPERR_INVALID_WAV_FILE;
    }
    return hr;
}

inline HRESULT CWavStream::MMWrite(const void * pv, LONG cb, LONG * plBytesWritten)
{
    HRESULT hr = S_OK;
    *plBytesWritten = ::mmioWrite(m_hFile, (const char *)pv, cb);
    if (*plBytesWritten == -1)
    {
        *plBytesWritten = 0;
        hr = STG_E_WRITEFAULT;
    }
    return hr;
}

inline HRESULT CWavStream::MMDescend(LPMMCKINFO lpck, const LPMMCKINFO lpckParent, UINT wFlags)
{
    return _MMIORESULT_TO_HRESULT(::mmioDescend(m_hFile, lpck, lpckParent, wFlags));
}

inline HRESULT CWavStream::MMAscend(LPMMCKINFO lpck)
{
    return _MMIORESULT_TO_HRESULT(::mmioAscend(m_hFile, lpck, 0));
}

inline HRESULT CWavStream::MMCreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    return _MMIORESULT_TO_HRESULT(::mmioCreateChunk(m_hFile, lpck, wFlags));
}


/****************************************************************************
* CWavStream::FinalConstruct *
*----------------------------*
*   Description:
*       Initializes the WavStream object and obtains a pointer to the resource
*   manager.
*
*   Returns:
*       Success code if object should be created
*
********************************************************************* RAL ***/

HRESULT CWavStream::FinalConstruct()
{
    SPDBG_FUNC("CWavStream::FinalConstruct");
    HRESULT hr = S_OK;

    m_hFile = NULL;
    m_hrStreamDefault = SPERR_UNINITIALIZED;

    m_fEventSource = 0;
    m_fEventSink = 0;
    m_fTranscript = 0;

    return hr;
}

/****************************************************************************
* CWavStream::FinalRelease *
*--------------------------*
*   Description:
*       This method is called when the object is released.  It will unconditinally
*   call Close() to close the file.
*
*   Returns:
*       void
*
********************************************************************* RAL ***/

void CWavStream::FinalRelease()
{
    SPDBG_FUNC("CWavStream::FinalRelease");
    Close();
}

/****************************************************************************
* CWavStream::QIExtendedInterfaces *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT WINAPI CWavStream::QIExtendedInterfaces(void* pv, REFIID riid, void ** ppv, DWORD_PTR dw)
{
    SPDBG_FUNC("CWavStream::QIExtendedInterfaces");

    *ppv = NULL;
    CWavStream * pThis = (CWavStream *)pv;

    if (pThis->m_fEventSource && (riid == IID_ISpEventSource || riid == IID_ISpNotifySource))
    {
        *ppv = static_cast<ISpEventSource *>(pThis);
    }
    else if (pThis->m_fEventSink && riid == IID_ISpEventSink)
    {
        *ppv = static_cast<ISpEventSink *>(pThis);
    }
    else if (pThis->m_fTranscript && riid == IID_ISpTranscript)
    {
        *ppv = static_cast<ISpTranscript *>(pThis);
    }

    if (*ppv)
    {
        ((IUnknown *)(*ppv))->AddRef();
        return S_OK;
    }
    else
    {
        return S_FALSE; // Tells ATL to continue searching COM_INTERFACE_ENTRY list
    }
}


/****************************************************************************
* CWavStream::Read *
*------------------*
*   Description:
*       Standard method of ISequentialStream interface.  This method reads the
*   specified number of bytes and returns the amount read.    
*
*   Returns:
*       S_OK                    Success
*       SPERR_UNINITIALIZED     The object has not been initialzed with Open() or Create()
*       STG_E_INVALIDPOINTER    Invalid pointer (Defined by ISequentialStream)
*       STG_E_READFAULT         Generic error if mmioRead fails.
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::Read(void * pv, ULONG cb, ULONG *pcbRead)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::Read");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (m_cpBaseStream)
        {
            hr = m_cpBaseStream->Read(pv, cb, pcbRead);
        }
        else
        {
            if (SPIsBadWritePtr(pv, cb) || SP_IS_BAD_OPTIONAL_WRITE_PTR(pcbRead))
            {
                hr = STG_E_INVALIDPOINTER;
            }
            else
            {
                LONG lRead = 0;
                hr = MMRead(pv, (m_cbSize - m_ulCurSeekPos >= cb) ? cb : (m_cbSize - m_ulCurSeekPos), &lRead);
                m_ulCurSeekPos += lRead;
                if (pcbRead)
                {
                    *pcbRead = lRead;
                }
            }
        }
    }
    return hr;
}

/****************************************************************************
* CWavStream::Write *
*-------------------*
*   Description:
*       Standard method of ISequentialStream interface.  This method writes the
*   specified number of bytes and returns the amount wriiten.    
*
*   Returns:
*       S_OK                    Success
*       SPERR_UNINITIALIZED     The object has not been initialzed with Open() or Create()
*       STG_E_INVALIDPOINTER    Invalid pointer (Defined by ISequentialStream)
*       STG_E_WRITEFAULT        Generic error if mmioWrite fails.
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::Write(const void * pv, ULONG cb, ULONG *pcbWritten)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::Write");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (m_cpBaseStream)
        {
            hr = m_cpBaseStream->Write(pv, cb, pcbWritten);
        }
        else
        {
            if (SPIsBadReadPtr(pv, cb) || SP_IS_BAD_OPTIONAL_WRITE_PTR(pcbWritten))
            {
                hr = STG_E_INVALIDPOINTER;
            }
            else
            {
                LONG lWritten = 0;
                if (m_hFile == NULL)
                {
                    hr = SPERR_UNINITIALIZED;
                }
                else
                {
                    if (!m_fWriteable)
                    {
                        hr = STG_E_ACCESSDENIED;
                    }
                    else
                    {
                        hr = MMWrite(pv, cb, &lWritten);
                        m_ulCurSeekPos += lWritten;
                        if(m_ulCurSeekPos > m_cbSize)
                        {
                            m_cbSize = m_ulCurSeekPos;
                        }
                    }
                }
                if (pcbWritten)
                {
                    *pcbWritten = lWritten;
                }
            }
        }
    }
    return hr;
}


/****************************************************************************
* CWavStream::Seek *
*------------------*
*   Description:
*       Standard method of IStream.  This method seeks the stream within the data
*   chunk of the wav file.
*
*   Returns:
*       S_OK                    Success
*       SPERR_UNINITIALIZED     The object has not been initialzed with Open() or Create()
*       STG_E_INVALIDPOINTER    Invalid pointer
*       STG_E_INVALIDFUNCTION   
*
********************************************************************* RAL ***/


//
//  Currently this function will not allow seeks past the end of the file.  This is an acceptable
//  limitation since wav files should always be treated as linear data.
//
STDMETHODIMP CWavStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    SPAUTO_OBJ_LOCK;    
    SPDBG_FUNC("CWavStream::Seek");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (m_cpBaseStream)
        {
            hr = m_cpBaseStream->Seek(dlibMove, dwOrigin, plibNewPosition);
        }
        else
        {
            if (SP_IS_BAD_OPTIONAL_WRITE_PTR(plibNewPosition))
            {
                hr = STG_E_INVALIDPOINTER;
            }
            else
            {
                if (dlibMove.HighPart != 0 && dlibMove.HighPart != 0xFFFFFFFF)
                {
                    hr = STG_E_INVALIDFUNCTION;
                }
                else
                {
                    LONG lDesiredPos;
                    switch (dwOrigin)
                    {
                    case SEEK_CUR:
                        lDesiredPos = ((LONG)m_ulCurSeekPos) + ((LONG)dlibMove.LowPart);
                        break;
                    case SEEK_SET:
                        lDesiredPos = (LONG)dlibMove.LowPart;
                        break;
                    case SEEK_END:
                        lDesiredPos = m_cbSize - (LONG)dlibMove.LowPart;
                        break;
                    default:
                        hr = STG_E_INVALIDFUNCTION;
                    }

                    if (SUCCEEDED(hr) && (ULONG)lDesiredPos != m_ulCurSeekPos)
                    {
                        if (lDesiredPos < 0 || (ULONG)lDesiredPos > m_cbSize)
                        {
                            hr = STG_E_INVALIDFUNCTION;
                        }
                        else
                        {
                            LONG lIgnored;
                            hr = MMSeek(lDesiredPos + m_lDataStart, SEEK_SET, &lIgnored);
                            if (SUCCEEDED(hr))
                            {
                                m_ulCurSeekPos = lDesiredPos;
                            }
                        }
                    }
                    if (plibNewPosition)
                    {
                        plibNewPosition->QuadPart = m_ulCurSeekPos;
                    }
                }
            }
        }
    }
    return hr;
}

/****************************************************************************
* CWavStream::SetSize *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::SetSize(ULARGE_INTEGER libNewSize)
{
    SPAUTO_OBJ_LOCK;    
    SPDBG_FUNC("CWavStream::SetSize");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr) && m_cpBaseStream)
    {
        hr = m_cpBaseStream->SetSize(libNewSize);
    }
    // Ignore this method for wav files.
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CWavStream::CopyTo *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::CopyTo(IStream * pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::CopyTo");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (m_cpBaseStream)
        {
            hr = m_cpBaseStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
        }
        else
        {
            hr = SpGenericCopyTo(this, pstm, cb, pcbRead, pcbWritten);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CWavStream::Revert *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::Revert()
{
    SPDBG_FUNC("CWavStream::Revert");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr) && m_cpBaseStream)
    {
        hr = m_cpBaseStream->Revert();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CWavStream::LockRegion *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    SPDBG_FUNC("CWavStream::LockRegion");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (m_cpBaseStream)
        {
            hr = m_cpBaseStream->LockRegion(libOffset, cb, dwLockType);
        }
        else
        {
            hr = STG_E_INVALIDFUNCTION;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CWavStream::UnlockRegion *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    SPDBG_FUNC("CWavStream::UnlockRegion");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (m_cpBaseStream)
        {
            hr = m_cpBaseStream->UnlockRegion(libOffset, cb, dwLockType);
        }
        else
        {
            hr = STG_E_INVALIDFUNCTION;
        }
    }


    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CWavStream::Commit *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::Commit(DWORD dwFlags)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::Commit");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr) && m_cpBaseStream)
    {
        hr = m_cpBaseStream->Commit(dwFlags);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CWavStream::Stat *
*------------------*
*   Description:
*       Standard method of IStream.  This method returns information about the
*   stream.  The only information returned by this method is the size of the
*   stream.  It is acceptable to simple zero the STATSTG structure and only
*   initialize the type and cbSize fields.  This is the same behaviour as streams
*   that were created using ::CreateStreamOnHGlobal().
*
*   Returns:
*       S_OK                    Success
*       SPERR_UNINITIALIZED     The object has not been initialzed with Open() or Create()
*       STG_E_INVALIDPOINTER    Invalid pointer
*       STG_E_INVALIDFLAG       Invalid flag in grfStatFlag
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SPAUTO_OBJ_LOCK;;
    SPDBG_FUNC("CWavStream::Stat");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (m_cpBaseStream)
        {
            hr = m_cpBaseStream->Stat(pstatstg, grfStatFlag);
        }
        else
        {
            if (SP_IS_BAD_WRITE_PTR(pstatstg))
            {
                hr = STG_E_INVALIDPOINTER;
            }
            else
            {
                if (grfStatFlag & (~STATFLAG_NONAME))
                {
                    hr = STG_E_INVALIDFLAG;
                }
                else
                {
                    ZeroMemory(pstatstg, sizeof(*pstatstg));
                    pstatstg->type = STGTY_STREAM;
                    pstatstg->cbSize.QuadPart = m_cbSize;
                }
            }
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CWavStream::GetFormat *
*-----------------------*
*   Description:
*       This method returns the format GUID for the stream.
*
*   Returns:
*       S_OK
*       E_POINTER
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::GetFormat(GUID * pFmtId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::GetFormat");
    HRESULT hr = m_hrStreamDefault;

    if(SUCCEEDED(hr) && m_cpBaseStreamFormat)
    {
        hr = m_StreamFormat.AssignFormat(m_cpBaseStreamFormat);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_StreamFormat.ParamValidateCopyTo(pFmtId, ppCoMemWaveFormatEx);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

#ifdef SAPI_AUTOMATION
/****************************************************************************
* CWavStream::SetFormat *
*-----------------------*
*   Description:
*       This method sets up the stream format without initializing the stream.
*       Needed for automation because we allow format setting independently
*       of when the basestream / file is set
*
*   Returns:
********************************************************************* DAVEWOOD ***/
STDMETHODIMP CWavStream::SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx)
{
    HRESULT hr = S_OK;

    if(m_hFile)
    {
        // Can't alter the format of an already created file.
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if(m_cpBaseStreamAccess)
    {
        // Set the format on the stream under this one.
        hr = m_cpBaseStreamAccess->SetFormat(rguidFmtId, pWaveFormatEx);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_StreamFormat.ParamValidateAssignFormat(rguidFmtId, pWaveFormatEx);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CWavStream::_GetFormat *
*-----------------------*
*   Description:
*       Version of GetFormat that works when the stream isn't initialized. Needed by automation
*
*   Returns:
********************************************************************* DAVEWOOD ***/
STDMETHODIMP CWavStream::_GetFormat(GUID * pFmtId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    HRESULT hr = S_OK;

    if(m_cpBaseStreamFormat)
    {
        hr = m_StreamFormat.AssignFormat(m_cpBaseStreamFormat);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_StreamFormat.ParamValidateCopyTo(pFmtId, ppCoMemWaveFormatEx);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

#endif
    
/****************************************************************************
* CWavStream::ReadFormatHeader *
*------------------------------*
*   Description:
*       This internal function is only used by the Open() method.  The lpckParent
*   must point to the WAVE chunk of the file.  When this function returns, the
*   current position of the file will be the point immediately past the 'fmt' chunk.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CWavStream::ReadFormatHeader(const LPMMCKINFO lpckParent)
{
    SPDBG_FUNC("CWavStream::ReadFormatHeader");
    HRESULT hr = S_OK;

    MMCKINFO mminfoFormat;

    mminfoFormat.ckid = g_fourccFormat;
    hr = MMDescend(&mminfoFormat, lpckParent, MMIO_FINDCHUNK);
    if (SUCCEEDED(hr))
    {
        if (mminfoFormat.cksize < sizeof(WAVEFORMAT))
        {
            hr = SPERR_INVALID_WAV_FILE;
        }
        else
        {
            WAVEFORMATEX * pwfex = (WAVEFORMATEX *)_alloca(mminfoFormat.cksize >= sizeof(WAVEFORMATEX) ? mminfoFormat.cksize : sizeof(WAVEFORMATEX));
            hr = MMReadExact(pwfex, mminfoFormat.cksize);
            if (SUCCEEDED(hr))
            {
                if (mminfoFormat.cksize < sizeof(WAVEFORMATEX))
                {
                    pwfex->cbSize = 0;
                }
                hr = m_StreamFormat.AssignFormat(pwfex);
            }
        }
        HRESULT hrAscend = MMAscend(&mminfoFormat);
        if (SUCCEEDED(hr))
        {
            hr = hrAscend;
        }
    }
    return hr;
}

/****************************************************************************
* CWavStream::ReadEvents *
*------------------------*
*   Description:
*       This internal function is only used by the Open() method.  The lpckParent
*   must point to the WAVE chunk of the file.  When this function returns, the
*   file position will point past the end of the event block (if there is any).
*
*   Returns:
*       S_OK if no events or if read successfully
*
********************************************************************* RAL ***/

HRESULT CWavStream::ReadEvents(const LPMMCKINFO lpckParent)
{
    SPDBG_FUNC("CWavStream::ReadEvents");
    HRESULT hr = S_OK;

    MMCKINFO mminfoEvent;
    mminfoEvent.ckid = g_fourccEvents;
    if (SUCCEEDED(MMDescend(&mminfoEvent, lpckParent, MMIO_FINDCHUNK)))
    {
        BYTE * pBuff = new BYTE[mminfoEvent.cksize];
        if (pBuff)
        {
            CSpEvent Event;
            hr = MMReadExact(pBuff, mminfoEvent.cksize);
            for (ULONG iCur = 0; SUCCEEDED(hr) && iCur < mminfoEvent.cksize; )
            {
                ULONG cbUsed;
                SPSERIALIZEDEVENT * pSerEvent = (SPSERIALIZEDEVENT *)(pBuff + iCur);
                if (SUCCEEDED(Event.Deserialize(pSerEvent, &cbUsed)))
                {
                    iCur += cbUsed;
                    hr = m_SpEventSource._AddEvent(Event);
                }
                else
                {
                    SPDBG_ASSERT(FALSE);    // Event did not deserialize properly
#ifndef _WIN32_WCE
                    iCur += SpSerializedEventSize(pSerEvent);
#else
                    iCur += SpSerializedEventSize(pSerEvent, sizeof(*pSerEvent));
#endif
                }
            }
            delete[] pBuff;
            if (SUCCEEDED(hr))
            {
                hr = m_SpEventSource._CompleteEvents();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        HRESULT hrAscend = MMAscend(&mminfoEvent);
        if (SUCCEEDED(hr))
        {
            hr = hrAscend;
        }
    }
    return hr;
}



/****************************************************************************
* CWavStream::ReadTranscript *
*----------------------------*
*   Description:
*       This internal function is only used by the Open() method.  The lpckParent
*   must point to the WAVE chunk of the file.  When this function returns, the
*   file position will point past the end of the transcript block (if there is any).
*
*   Returns:
*       S_OK if no transcript exists or if read successfully
*
********************************************************************* RAL ***/

HRESULT CWavStream::ReadTranscript(const LPMMCKINFO lpckParent)
{
    SPDBG_FUNC("CWavStream::ReadTranscript");
    HRESULT hr = S_OK;


    MMCKINFO mminfoTranscript;
    mminfoTranscript.ckid = g_fourccTranscript;
    if (SUCCEEDED(MMDescend(&mminfoTranscript, lpckParent, MMIO_FINDCHUNK)))
    {
        if (m_dstrTranscript.ClearAndGrowTo(mminfoTranscript.cksize/sizeof(WCHAR)))
        {
            hr = MMReadExact(static_cast<WCHAR *>(m_dstrTranscript), mminfoTranscript.cksize);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        HRESULT hrAscend = MMAscend(&mminfoTranscript);
        if (SUCCEEDED(hr))
        {
            hr = hrAscend;
        }
    }
    return hr;
}



//
//  NOTE:  Something is quite goofy about mmio routines.  When you create a chunk the chunk
//  structure is actually used by the service to maintain state.  For that reason, we have
//  member variables m_ckFile and m_ckData so that when we close the file we can Ascend back
//  out of these chunks.  Unbelieveable.......
//


/****************************************************************************
* CWavStream::Open *
*------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CWavStream::OpenWav(const WCHAR *pszFileName, ULONGLONG ullEventInterest)
{
    SPDBG_FUNC("CWavStream::OpenWav");
    HRESULT hr = S_OK;

    m_SpEventSource.m_ullEventInterest = m_SpEventSource.m_ullQueuedInterest = ullEventInterest;

    hr = MMOpen(pszFileName, MMIO_READ | MMIO_ALLOCBUF);
    if (SUCCEEDED(hr))
    {
        LONG lStartWaveChunk, lIgnored;
        MMCKINFO mminfoChunk;
        // search for wave type...
        mminfoChunk.fccType = g_fourccWave;
        hr = MMDescend(&mminfoChunk, NULL, MMIO_FINDRIFF);
        if (SUCCEEDED(hr))
        {
            hr = MMSeek(0, SEEK_CUR, &lStartWaveChunk);
        }
        if (SUCCEEDED(hr))
        {
            hr = ReadFormatHeader(&mminfoChunk);
        }
        if (SUCCEEDED(hr))
        {
            hr = ReadTranscript(&mminfoChunk);
        }
        if (SUCCEEDED(hr))
        {
            hr = MMSeek(lStartWaveChunk, SEEK_SET, &lIgnored);
        }
        if (SUCCEEDED(hr))
        {
            hr = ReadEvents(&mminfoChunk);
        }
        if (SUCCEEDED(hr))
        {
            hr = MMSeek(lStartWaveChunk, SEEK_SET, &lIgnored);
        }
        if (SUCCEEDED(hr))
        {
            MMCKINFO mminfoData;
            mminfoData.ckid = g_fourccData;
            hr = MMDescend(&mminfoData, &mminfoChunk, MMIO_FINDCHUNK);
            m_cbSize = mminfoData.cksize;
        }
        if (SUCCEEDED(hr))
        {
            hr = MMSeek(0, SEEK_CUR, &m_lDataStart);
        }
        if (SUCCEEDED(hr))
        {
            m_ulCurSeekPos = 0;
            m_fWriteable = FALSE;
            m_fEventSource = TRUE;
            m_fTranscript = TRUE;
        }
        else
        {
            MMClose();
        }
    }
    return hr;
}

/****************************************************************************
* CWavStream::Create *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CWavStream::CreateWav(const WCHAR *pszFileName, ULONGLONG ullEventInterest)
{
    SPAUTO_OBJ_LOCK;

    SPDBG_FUNC("CWavStream::Create");
    HRESULT hr = S_OK;

    if (m_StreamFormat.FormatId() != SPDFID_WaveFormatEx)
    {
        hr = SPERR_UNSUPPORTED_FORMAT;
    }
    else
    {
        m_SpEventSource.m_ullEventInterest = m_SpEventSource.m_ullQueuedInterest = ullEventInterest;

        hr = MMOpen(pszFileName, MMIO_CREATE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF );
        if (SUCCEEDED(hr))
        {
            ZeroMemory(&m_ckFile, sizeof(m_ckFile));
            m_ckFile.fccType = g_fourccWave;
            hr = MMCreateChunk(&m_ckFile, MMIO_CREATERIFF);
            if (SUCCEEDED(hr))
            {
                MMCKINFO ck;
                ZeroMemory(&ck, sizeof(ck));
                ck.ckid = g_fourccFormat;
                hr = MMCreateChunk(&ck, 0);
                if (SUCCEEDED(hr))
                {
                    LONG lIgnored;
                    const WAVEFORMATEX * pwfex = m_StreamFormat.WaveFormatExPtr();
                    hr = MMWrite(pwfex, sizeof(*pwfex) + pwfex->cbSize, &lIgnored);
                    MMAscend(&ck);
                }
                if (SUCCEEDED(hr))
                {
                    ZeroMemory(&m_ckData, sizeof(m_ckData));
                    m_ckData.ckid = g_fourccData;
                    hr = MMCreateChunk(&m_ckData, 0);
                }
                if (SUCCEEDED(hr))
                {
                    hr = MMSeek(0, SEEK_CUR, &m_lDataStart);
                }
            }
            if (SUCCEEDED(hr))
            {
                m_ulCurSeekPos = 0;
                m_fWriteable = TRUE;
                m_fEventSource = FALSE;
                m_fEventSink = TRUE;
                m_fTranscript = TRUE;
                m_cbSize = 0;
            }
            else
            { 
                MMClose();
            }
        }
    }
    return hr;
}


/****************************************************************************
* CWavStream::SerializeEvents *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CWavStream::SerializeEvents()
{
    SPDBG_FUNC("CWavStream::SerializeEvents");
    HRESULT hr = S_OK;
    
    if (m_SpEventSource.m_PendingList.GetCount())
    {
        MMCKINFO ck;
        ZeroMemory(&ck, sizeof(ck));
        ck.ckid = g_fourccEvents;
        hr = MMCreateChunk(&ck, 0);
        if (SUCCEEDED(hr))
        {
            ULONG cbSerializeSize = 0;
            CSpEventNode * pNode;
            for (pNode = m_SpEventSource.m_PendingList.GetHead(); pNode; pNode = pNode->m_pNext)
            {
// WCE compiler does not work propertly with template
#ifndef _WIN32_WCE
                cbSerializeSize += pNode->SerializeSize<SPSERIALIZEDEVENT>();
#else
                cbSerializeSize += SpEventSerializeSize(pNode, sizeof(SPSERIALIZEDEVENT));
#endif
            }
            BYTE * pBuff = new BYTE[cbSerializeSize];
            if (pBuff)
            {
                BYTE * pCur = pBuff;
                for (pNode = m_SpEventSource.m_PendingList.GetHead(); SUCCEEDED(hr) && pNode; pNode = pNode->m_pNext)
                {
                    pNode->Serialize((UNALIGNED SPSERIALIZEDEVENT *)pCur);
// WCE compiler does not work propertly with template
#ifndef _WIN32_WCE
                    pCur += pNode->SerializeSize<SPSERIALIZEDEVENT>();
#else
                    pCur += SpEventSerializeSize(pNode, sizeof(SPSERIALIZEDEVENT));
#endif
                }
                LONG lIgnored;
                hr = MMWrite(pBuff, cbSerializeSize, &lIgnored);
                delete[] pBuff;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            MMAscend(&ck);
        }
    }

    return hr;
}

/****************************************************************************
* CWavStream::SerializeTranscript *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CWavStream::SerializeTranscript()
{
    SPDBG_FUNC("CWavStream::SerializeTranscript");
    HRESULT hr = S_OK;

    ULONG cch = m_dstrTranscript.Length();
    if (cch)
    {
        MMCKINFO ck;
        ZeroMemory(&ck, sizeof(ck));
        ck.ckid = g_fourccTranscript;
        hr = MMCreateChunk(&ck, 0);
        if (SUCCEEDED(hr))
        {
            LONG lWritten;
            hr = MMWrite(static_cast<WCHAR *>(m_dstrTranscript), (cch+1) * sizeof(WCHAR), &lWritten);
            MMAscend(&ck);
        }
    }

    return hr;
}

/****************************************************************************
* CWavStream::SetBaseStream *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::SetBaseStream(IStream * pStream, REFGUID rguidFormat, const WAVEFORMATEX * pWaveFormatEx)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::SetBaseStream");
    HRESULT hr = m_hrStreamDefault;

    if (hr == SPERR_UNINITIALIZED)
    {
        if (SP_IS_BAD_INTERFACE_PTR(pStream))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = m_StreamFormat.ParamValidateAssignFormat(rguidFormat, pWaveFormatEx);
        }
        if (SUCCEEDED(hr))
        {
            if(pStream == this)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                m_cpBaseStream = pStream;
                m_cpBaseStreamFormat = pStream;
                m_cpBaseStreamAccess = pStream;
            }

            if(SUCCEEDED(hr) && m_cpBaseStreamAccess && !m_cpBaseStreamFormat)
            {
                // Can't have StreamAccess without format.
                hr = E_UNEXPECTED; 
            }

            if(m_cpBaseStreamFormat)
            {
                // If this BaseStream implements ISpStreamFormat, we should get format info from it
                hr = m_StreamFormat.AssignFormat(m_cpBaseStreamFormat);
            }

            if(SUCCEEDED(hr))
            {
                m_hrStreamDefault = S_OK;
                hr = S_OK;
            }
            else
            {
                m_cpBaseStreamAccess.Release();
                m_cpBaseStream.Release();
                m_cpBaseStream.Release();
            }
        }
    }
    else
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CWavStream::GetBaseStream *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CWavStream::GetBaseStream(IStream ** ppStream)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::GetBaseStream");
    HRESULT hr = m_hrStreamDefault;

    if (SUCCEEDED(hr))
    {
        if (SP_IS_BAD_WRITE_PTR(ppStream))
        {
            hr = E_POINTER;
        }
        else
        {
            *ppStream = m_cpBaseStream;
            if (*ppStream)
            {
                (*ppStream)->AddRef();
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CWavStream::BindToFile *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::BindToFile(const WCHAR * pszFileName, SPFILEMODE eMode,
                                    const GUID * pguidFormatId, const WAVEFORMATEX * pWaveFormatEx,
                                    ULONGLONG ullEventInterest)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::BindToFile");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszFileName) ||
        eMode >= SPFM_NUM_MODES ||
        SP_IS_BAD_OPTIONAL_READ_PTR(pguidFormatId))
    {
        hr = E_INVALIDARG;
    }
    else if (m_hrStreamDefault == S_OK)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if (pguidFormatId)
    {
        hr = m_StreamFormat.ParamValidateAssignFormat(*pguidFormatId, pWaveFormatEx);
    }

    if (SUCCEEDED(hr))
    {
        ULONG cchFileName = wcslen(pszFileName);
        if (cchFileName > 4 && (_wcsicmp(pszFileName + cchFileName - 4, L".wav") == 0))
        {
            if( SUCCEEDED( hr ) )
            {
                if( eMode == SPFM_OPEN_READONLY )
                {
                    hr = OpenWav( pszFileName, ullEventInterest );
                }
                else
                {
                    if ( eMode == SPFM_CREATE_ALWAYS && m_StreamFormat.FormatId() == SPDFID_WaveFormatEx )
                    {
                        hr = CreateWav( pszFileName, ullEventInterest );
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }

        }
        else    //=== Generic binding for text files
        {
            //--- Init vars
            m_StreamFormat.Clear();
            m_fWriteable   = TRUE;
            m_fEventSource = FALSE;
            m_fEventSink   = FALSE;
            m_fTranscript  = FALSE;

            if (eMode == SPFM_OPEN_READONLY)
            {
                m_fWriteable = FALSE;
                hr = ::URLOpenBlockingStreamW(NULL, pszFileName, &m_cpBaseStream, 0, NULL);
            }
            else
            {
                DWORD dwCreateDisp;
                switch (eMode)
                {
                case SPFM_OPEN_READWRITE:
                    dwCreateDisp = OPEN_EXISTING;
                    break;

                case SPFM_CREATE:
                    dwCreateDisp = OPEN_ALWAYS;
                    break;

                case SPFM_CREATE_ALWAYS:
                    dwCreateDisp = CREATE_ALWAYS;
                    break;
                }
                CSpFileStream * pNew = new CSpFileStream(&hr, pszFileName,
                                           GENERIC_WRITE | GENERIC_READ, 0, dwCreateDisp);
                if (pNew)
                {
                    if (SUCCEEDED(hr))
                    {
                        m_cpBaseStream = pNew;
                    }
                    pNew->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            m_hrStreamDefault = S_OK;
        }
        else
        {
            m_StreamFormat.Clear();
        }
    }


    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* SPBindToFile */


/****************************************************************************
* CWavStream::Close *
*-------------------*
*   Description:
*       This method is exposed as an interface so that clients can receive failure
*   codes that would otherwise not be available if they simply released the stream.
*   Upon release, streams are automatically closed (by calling this method from
*   FinalConstruct()).
*
*   Returns:
*       S_OK if successful.
*       SPERR_UNINITIALIZED if file is not opened
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::Close()
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::Close");
    HRESULT hr = m_hrStreamDefault;
 
    if (SUCCEEDED(hr))
    {
        m_cpBaseStream.Release();
        if (m_hFile)
        {
            if (m_fWriteable)
            {
                hr = MMAscend(&m_ckData);
                if (SUCCEEDED(hr))
                {
                    hr = SerializeEvents();
                }
                if (SUCCEEDED(hr))
                {
                    hr = SerializeTranscript();
                }
                if (SUCCEEDED(hr))
                {
                    hr = MMAscend(&m_ckFile);
                }
            }
            HRESULT hrClose = MMClose();
            if (SUCCEEDED(hr))
            {
                hr = hrClose;
            }
        }
        m_hrStreamDefault = SPERR_STREAM_CLOSED;
    }
    return hr;
}


/****************************************************************************
* CWavStream::AddEvents *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::AddEvents(const SPEVENT* pEventArray, ULONG ulCount)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::AddEvents");
    HRESULT hr = S_OK;

    if (SPIsBadReadPtr(pEventArray, sizeof(*pEventArray)*ulCount))       
    {                                                                           
        hr = E_INVALIDARG;                                                      
    }                                                                               
    else 
    {
        hr = m_SpEventSource._AddEvents(pEventArray, ulCount);
    }
    return hr;
}
/****************************************************************************
* CWavStream::GetEventInterest *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CWavStream::GetEventInterest(ULONGLONG * pullEventInterest)
{
    SPDBG_FUNC("CWavStream::GetEventInterest");
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(pullEventInterest))
    {
        hr = E_POINTER;
    }
    else
    {
        *pullEventInterest = m_SpEventSource.m_ullEventInterest;
    }

    return hr;
}


/****************************************************************************
* CWavStream::GetTranscript *
*---------------------------*
*   Description:
*
*   Returns:
*       S_OK if *ppszTranscript contains a CoTaskMemAllocated string
*       S_FALSE if object has no transcript
*       E_POINTER if ppszTranscript is invalid
*       SPERR_UNINITIALIZED if object has not been initialized
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::GetTranscript(WCHAR ** ppszTranscript)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::GetTranscription");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppszTranscript))
    {
        hr = E_POINTER;
    }
    else
    {
        if (m_dstrTranscript)
        {
            *ppszTranscript = m_dstrTranscript.Copy();
            if (*ppszTranscript == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            *ppszTranscript = NULL;
            hr = m_hFile ? S_FALSE : SPERR_UNINITIALIZED;
        }
    }
    return hr;
}

/****************************************************************************
* CWavStream::AppendTranscript *
*------------------------------*
*   Description:
*       If pszTranscript is NULL then the current transcript is deleted,
*       otherwise, the text is appended to the current transcript.
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CWavStream::AppendTranscript(const WCHAR * pszTranscript)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CWavStream::SetTranscript");
    HRESULT hr = m_hrStreamDefault;
    if (SUCCEEDED(hr))
    {
        if (pszTranscript)
        {
            if (SP_IS_BAD_STRING_PTR(pszTranscript))
            {
                hr = E_INVALIDARG;
            }
            else if (wcslen(pszTranscript) == 0)
            {
                hr = S_FALSE;
            }
            else
            {
                m_dstrTranscript.Append(pszTranscript);
                if (m_dstrTranscript == NULL)
                {  
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            m_dstrTranscript.Clear();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\wceiids.c ===
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

//=== Service Provider Ids ====================================================
// {6d5140c1-7436-11ce-8034-00aa006009fa}
const IID IID_IServiceProvider = { 0x6d5140c1, 0x7436, 0x11ce, { 0x80, 0x34, 0x0, 0xaa, 0x0, 0x60, 0x09, 0xfa } };

//=== Object Safety Ids ====================================================
// {CB5BDC81-93C1-11cf-8F20-00805F2CD064}
const IID IID_IObjectSafety = { 0xCB5BDC81, 0x93C1, 0x11cf, { 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\wavstream.h ===
// WavStream.h : Declaration of the CWavStream

#ifndef __WAVSTREAM_H_
#define __WAVSTREAM_H_

#include "resource.h"       // main symbols
#include "speventq.h"

static const SPSTREAMFORMAT g_DefaultWaveFormat = SPSF_22kHz16BitMono;

/////////////////////////////////////////////////////////////////////////////
// CWavStream
class ATL_NO_VTABLE CWavStream : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWavStream, &CLSID_SpStream>,
    public ISpStream,
    public ISpEventSource,
    public ISpEventSink,
    public ISpTranscript
#ifdef SAPI_AUTOMATION
    ,public ISpStreamAccess
#endif
{
  /*=== ATL Setup ===*/
  public:

    DECLARE_SPEVENTSOURCE_METHODS(m_SpEventSource)
    DECLARE_REGISTRY_RESOURCEID(IDR_WAVSTREAM)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CWavStream)
	    COM_INTERFACE_ENTRY(IStream)
        COM_INTERFACE_ENTRY(ISequentialStream)
        COM_INTERFACE_ENTRY(ISpStreamFormat)
        COM_INTERFACE_ENTRY(ISpStream)
#ifdef SAPI_AUTOMATION
	    COM_INTERFACE_ENTRY(ISpStreamAccess)
#endif
        // These interfaces should "appear" when stream initialized to a WAV file
        //      ISpNotifySource
        //      ISpEventSource
        //      ISpEventSink
        //      ISpTranscript
        COM_INTERFACE_ENTRY_FUNC_BLIND(0, CWavStream::QIExtendedInterfaces)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CWavStream() :
        m_SpEventSource(this)
	{
	}

	HRESULT FinalConstruct();
	void FinalRelease();

    /*--- Non interface methods ---*/
    HRESULT SerializeEvents(void);
    HRESULT SerializeTranscript(void);
    HRESULT ReadFormatHeader(const LPMMCKINFO lpckParent);
    HRESULT ReadEvents(const LPMMCKINFO lpckParent);
    HRESULT ReadTranscript(const LPMMCKINFO lpckParent);

    inline HRESULT MMOpen(const WCHAR * pszFileName, DWORD dwOpenFlags);
    inline HRESULT MMClose();
    inline HRESULT MMSeek(LONG lOffset, int iOrigin, LONG * plNewPos);
    inline HRESULT MMRead(void * pv, LONG cb, LONG * plBytesRead);
    inline HRESULT MMReadExact(void * pv, LONG cb);
    inline HRESULT MMWrite(const void * pv, LONG cb, LONG * plBytesWritten);
    inline HRESULT MMDescend(LPMMCKINFO lpck, const LPMMCKINFO lpckParent, UINT wFlags);
    inline HRESULT MMAscend(LPMMCKINFO lpck);
    inline HRESULT MMCreateChunk(LPMMCKINFO lpck, UINT wFlags);

    HRESULT OpenWav(const WCHAR * pszFileName, ULONGLONG ullEventInterest);
    HRESULT CreateWav(const WCHAR * pszFileName, ULONGLONG ullEventInterest);

    static HRESULT WINAPI QIExtendedInterfaces(void* pv, REFIID riid, void ** ppv, DWORD_PTR dw);



  /*=== Interfaces ====*/
  public:
    //--- IStream -------------------------------------------------------------
    STDMETHODIMP Read(void * pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void * pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    STDMETHODIMP SetSize( ULARGE_INTEGER libNewSize );
    STDMETHODIMP CopyTo( IStream __RPC_FAR *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER __RPC_FAR *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten);
    STDMETHODIMP Commit( DWORD grfCommitFlags);
    STDMETHODIMP Revert( void);
    STDMETHODIMP LockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat( STATSTG __RPC_FAR *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone( IStream __RPC_FAR *__RPC_FAR *ppstm ){ return E_NOTIMPL; }

    //--- ISpStreamFormat -----------------------------------------------------
    STDMETHODIMP GetFormat(GUID * pFmtId, WAVEFORMATEX ** ppCoMemWaveFormatEx);

    //--- ISpStream -----------------------------------------------------------
    STDMETHODIMP SetBaseStream(IStream * pStream, REFGUID rguidFormat, const WAVEFORMATEX * pWaveFormatEx);
    STDMETHODIMP GetBaseStream(IStream ** ppStream);
    STDMETHODIMP BindToFile(const WCHAR * pszFileName, SPFILEMODE eMode,
                            const GUID * pguidFormatId, const WAVEFORMATEX * pWaveformatEx,
                            ULONGLONG ullEventInterest);
    STDMETHODIMP Close();

    //--- ISpEventSink --------------------------------------------------------
    STDMETHODIMP AddEvents(const SPEVENT* pEventArray, ULONG ulCount);
    STDMETHODIMP GetEventInterest(ULONGLONG * pullEventInterest);

    //--- ISpTranscript -------------------------------------------------------
    STDMETHODIMP GetTranscript(WCHAR ** ppszTranscript);
    STDMETHODIMP AppendTranscript(const WCHAR * pszTranscript);

#ifdef SAPI_AUTOMATION
    STDMETHODIMP SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx);
    STDMETHODIMP _GetFormat(GUID * pFmtId, WAVEFORMATEX ** ppCoMemWaveFormatEx);
#endif // SAPI_AUTOMATION

  /*=== Member Data ===*/
  protected:
    CSpEventSource      m_SpEventSource;
    HRESULT             m_hrStreamDefault;
    HMMIO               m_hFile;
    CSpStreamFormat     m_StreamFormat;
    LONG                m_lDataStart;   // starting location of data block in file
    DWORD               m_cbSize;
    ULONG               m_ulCurSeekPos;
    MMCKINFO            m_ckFile;
    MMCKINFO            m_ckData;   
    CSpDynamicString    m_dstrTranscript;
    CComPtr<IStream>    m_cpBaseStream;
    CComQIPtr<ISpStreamFormat> m_cpBaseStreamFormat;
    CComQIPtr<ISpStreamAccess> m_cpBaseStreamAccess;
    BOOL                m_fEventSource : 1;
    BOOL                m_fEventSink : 1;
    BOOL                m_fTranscript : 1;
    BOOL                m_fWriteable : 1;
};

#ifdef SAPI_AUTOMATION

/*** CSpeechWavAudioFormat
*   This object is used to access the Format info for 
*   the associated stream.
*/
class ATL_NO_VTABLE CSpeechWavAudioFormat : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechAudioFormat, &IID_ISpeechAudioFormat, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechWavAudioFormat)
	    COM_INTERFACE_ENTRY(ISpeechAudioFormat)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  public:
    //--- ISpeechAudioFormat ----------------------------------
    STDMETHOD(get_Type)(SpeechAudioFormatType* AudioFormatType);
    STDMETHOD(put_Type)(SpeechAudioFormatType  AudioFormatType);
    STDMETHOD(get_Guid)(BSTR* Guid);
    STDMETHOD(put_Guid)(BSTR Guid);
    STDMETHOD(GetWaveFormatEx)(ISpeechWaveFormatEx** WaveFormatEx);
    STDMETHOD(SetWaveFormatEx)(ISpeechWaveFormatEx* WaveFormatEx);

    /*=== Member Data ===*/
    CComPtr<ISpStreamAccess>    m_cpStreamAccess;
};

#endif // SAPI_AUTOMATION

#endif //__WAVSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapisvr\makefile.inc ===
CopySapiServer :
	copy $(O)\sapisvr.exe ..\sapi\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapisvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sapisvr.rc
//
#define IDS_PROJNAME                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\xmlparser.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Thu Mar 04 16:31:06 1999
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    }	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    }	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_WHITESPACEORQUESTIONMARK	= XML_E_INVALID_UNICODE + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    }	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    }	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    }	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1,
	XMLNF_LASTEVENT	= XMLNF_DATAAVAILABLE
    }	XML_NODEFACTORY_EVENT;

typedef struct _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR __RPC_FAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    }	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
    /* [out] */ ULONG __RPC_FAR *pulLen,
    /* [out] */ ULONG __RPC_FAR *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PushData )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDTD )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExpandEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID __RPC_FAR *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParserState )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID __RPC_FAR *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEvent )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Error )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapi\xmlparse.cpp ===
/*******************************************************************************
* xmlparse.cpp *
*--------------*
*   Description:
*       This module is the main implementation file for the CSpVoice XML parser.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 12/09/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "spvoice.h"
#include "commonlx.h"

//--- Local

static const SPLSTR g_Tags[NUM_XMLTAGS] =
{
    DEF_SPLSTR( "VOLUME"   ),
    DEF_SPLSTR( "EMPH"     ),
    DEF_SPLSTR( "SILENCE"  ),
    DEF_SPLSTR( "PITCH"    ),
    DEF_SPLSTR( "RATE"     ),
    DEF_SPLSTR( "BOOKMARK" ),
    DEF_SPLSTR( "PRON"     ),
    DEF_SPLSTR( "SPELL"    ),
    DEF_SPLSTR( "LANG"     ),
    DEF_SPLSTR( "VOICE"    ),
    DEF_SPLSTR( "CONTEXT"  ),
    DEF_SPLSTR( "PARTOFSP" ),
    DEF_SPLSTR( "SECT"     ),
    DEF_SPLSTR( "?XML"     ),
    DEF_SPLSTR( "!--"      ),
    DEF_SPLSTR( "!DOCTYPE" ),
    DEF_SPLSTR( "SAPI"     )
};

static const SPLSTR g_Attrs[NUM_XMLATTRS] =
{
    DEF_SPLSTR( "ID"        ),
    DEF_SPLSTR( "SYM"       ),
    DEF_SPLSTR( "LANGID"    ),
    DEF_SPLSTR( "LEVEL"     ),
    DEF_SPLSTR( "MARK"      ),
    DEF_SPLSTR( "MIDDLE"    ),
    DEF_SPLSTR( "MSEC"      ),
    DEF_SPLSTR( "OPTIONAL"  ),
    DEF_SPLSTR( "RANGE"     ),
    DEF_SPLSTR( "REQUIRED"  ),
    DEF_SPLSTR( "SPEED"     ),
    DEF_SPLSTR( "BEFORE"    ),
    DEF_SPLSTR( "AFTER"     ),
    DEF_SPLSTR( "PART"      ),
    DEF_SPLSTR( "ABSMIDDLE" ),
    DEF_SPLSTR( "ABSRANGE"  ),
    DEF_SPLSTR( "ABSSPEED"  )
};

//--- Volume
#define NUM_VOLUME_LEVEL_VALS 4
static const SPLSTR g_VolumeLevelNames[NUM_VOLUME_LEVEL_VALS] =
{
    DEF_SPLSTR( "LOUDEST" ),
    DEF_SPLSTR( "LOUD"    ),
    DEF_SPLSTR( "MEDIUM"  ),
    DEF_SPLSTR( "QUIET"   )
};
static const long g_VolumeLevelVals[NUM_VOLUME_LEVEL_VALS] = { 100, 75, 50, 25 };

//--- Part of speech
static const long g_POSLevelVals[] =
{   SPPS_Unknown,
    SPPS_Noun,
    SPPS_Verb,
    SPPS_Modifier,
    SPPS_Function,
    SPPS_Interjection,
};

#define NUM_POS_LEVEL_VALS sp_countof(g_POSLevelVals)

static const SPLSTR g_POSLevelNames[NUM_POS_LEVEL_VALS] =
{
    DEF_SPLSTR( "UNKNOWN"         ),
    DEF_SPLSTR( "NOUN"            ),
    DEF_SPLSTR( "VERB"            ),
    DEF_SPLSTR( "MODIFIER"        ),
    DEF_SPLSTR( "FUNCTION"        ),
    DEF_SPLSTR( "INTERJECTION"    )
};

//--DEF_SPLSTR( "- Rate
#define NUM_RATE_SPEED_VALS 5
static const SPLSTR g_RateSpeedNames[NUM_RATE_SPEED_VALS] =
{
    DEF_SPLSTR( "FASTEST" ),
    DEF_SPLSTR( "FAST"    ),
    DEF_SPLSTR( "MEDIUM"  ),
    DEF_SPLSTR( "SLOW"    ),
    DEF_SPLSTR( "SLOWEST" )
};
static const long g_RateSpeedVals[NUM_RATE_SPEED_VALS] = { 10, 5, 0, -5, -10 };

//--- Emphasis
#define NUM_EMPH_LEVEL_VALS 4
static const SPLSTR g_EmphLevelNames[NUM_EMPH_LEVEL_VALS] =
{
    DEF_SPLSTR( "STRONG"   ),
    DEF_SPLSTR( "MODERATE" ),
    DEF_SPLSTR( "NONE"     ),
    DEF_SPLSTR( "REDUCED"  )
};
static const long g_EmphLevelVals[NUM_EMPH_LEVEL_VALS] = { 2, 1, 0, -1 };

//--- Pitch
#define NUM_PITCH_VALS 6
static const SPLSTR g_PitchNames[NUM_PITCH_VALS] =
{
    DEF_SPLSTR( "HIGHEST" ),
    DEF_SPLSTR( "HIGH"    ),
    DEF_SPLSTR( "MEDIUM"  ),
    DEF_SPLSTR( "LOW"     ),
    DEF_SPLSTR( "LOWEST"  ),
    DEF_SPLSTR( "DEFAULT" )
};
static const long g_PitchVals[NUM_PITCH_VALS] = { 10, 5, 0, -5, -10, 0 };

/*****************************************************************************
* wcatol *
*--------*
*   Converts the specified string into a long value. This function
*   returns the number of digits converted.
********************************************************************* EDC ***/
ULONG wcatol( WCHAR* pStr, long* pVal, bool fForceHex )
{
    SPDBG_ASSERT( pVal && pStr );
    long Sign = 1, Val = 0;
    ULONG NumConverted;
    pStr = wcskipwhitespace( pStr );
    WCHAR* pStart = pStr;

    //--- Check for a sign specification and skip any whitespace between sign and number
    if( *pStr == L'+' )
    {
        pStr = wcskipwhitespace( ++pStr );
    }
    else if( *pStr == L'-' )
    {
        Sign = -1;
        pStr = wcskipwhitespace( ++pStr );
    }

    if( fForceHex || (( pStr[0] == L'0' ) && ( wctoupper( pStr[1] ) == L'X' )) )
    {
        //--- Start hex conversion
        pStr  += 2;
        pStart = pStr;
        do
        {
            WCHAR wcDigit = wctoupper(*pStr);
            if( ( wcDigit >= L'0' ) && ( wcDigit <= L'9' ) )
            {
                Val *= 16;
                Val += wcDigit - L'0';
            }
            else if( ( wcDigit >= L'A' ) && ( wcDigit <= L'F' ) )
            {
                Val *= 16;
                Val += (wcDigit - L'A') + 10;
            }
            else
            {
                break; // end of conversion
            }
        } while( *(++pStr) );
    }
    else
    {
        //--- Start decimal conversion
        while( ( *pStr >= L'0' ) && ( *pStr <= L'9' ) )
        {
            Val *= 10;
            Val += *pStr - L'0';
            ++pStr;
        }
    }
    Val *= Sign;

    //--- Tell the caller whether there was any conversion done
    NumConverted = ULONG(pStr - pStart);

    //--- Return final value
    *pVal = Val;

    return NumConverted;
} /* wcatol */

/*****************************************************************************
* DoCharSubst *
*-------------*
*   Description:
*       This method performs XML control character substitution in the
*   specified string. Note: It is safe to look beyond pStr to do a match
*   because a NULL or a begin tag will cause the comparison to terminate early.
********************************************************************* EDC ***/
void DoCharSubst( WCHAR* pStr, WCHAR* pEnd )
{
    int i;

    while( pStr < pEnd )
    {
        if( pStr[0] == L'&' )
        {
            if( (pEnd - pStr >= 3) && (wctoupper( pStr[2] ) == L'T') )
            {
                if( wctoupper( pStr[1] ) == L'L' )
                {
                    *pStr++ = L'<';
                    for( i = 0; i < 2; ++i ) *pStr++ = SP_ZWSP;
                }
                else if( wctoupper( pStr[1] ) == L'G' )
                {
                    *pStr++ = L'>';
                    for( i = 0; i < 2; ++i ) *pStr++ = SP_ZWSP;
                }
                else
                {
                    ++pStr;
                }
            }
            else if( (pEnd - pStr >= 4) &&
                     ( wctoupper( pStr[1] ) == L'A' ) &&
                     ( wctoupper( pStr[2] ) == L'M' ) &&
                     ( wctoupper( pStr[3] ) == L'P' ) )
            {
                *pStr++ = L'&';
                for( i = 0; i < 3; ++i ) *pStr++ = SP_ZWSP;
            }
            else if ( (pEnd - pStr >= 5) &&
                      ( wctoupper( pStr[1] ) == L'A' ) &&
                      ( wctoupper( pStr[2] ) == L'P' ) &&
                      ( wctoupper( pStr[3] ) == L'O' ) &&
                      ( wctoupper( pStr[4] ) == L'S' ) )
            {
                *pStr++ = L'\'';
                for( i = 0; i < 4; ++i ) *pStr++ = SP_ZWSP;
            }
            else if ( (pEnd - pStr >= 5) &&
                      ( wctoupper( pStr[1] ) == L'Q' ) &&
                      ( wctoupper( pStr[2] ) == L'U' ) &&
                      ( wctoupper( pStr[3] ) == L'O' ) &&
                      ( wctoupper( pStr[4] ) == L'T' ) )
            {
                *pStr++ = L'\"';
                for( i = 0; i < 4; ++i ) *pStr++ = SP_ZWSP;
            }
            else if ( ( pStr[1] == L'#' ) && ( pStr[2] == L'x' ) )
            {
                *pStr++ = SP_ZWSP;
                pStr[0] = L'0';
                long Val, Num;

                Num = wcatol( pStr, &Val, false );
                if ( Val > 65535 ) Val = 65535;
                pStr[0] = (WCHAR)Val;
                
                // Special case check! Make sure we didn't
                // get a NULL char, so that we're not
                // prematurely terminating the string
                if (pStr[0] <= 0)
                {
                    pStr[0] = SP_ZWSP;
                }

                pStr++;
                for( i = 0; i < Num + 1; ++i ) *pStr++ = SP_ZWSP;
            }
            else
            {
                ++pStr;
            }
        }
        else
        {
            ++pStr;
        }
    }

} /* DoCharSubst */

/*****************************************************************************
* LookupNamedVal *
*----------------*
*   If the function succeeds the return value is "true"
********************************************************************* EDC ***/
HRESULT LookupNamedVal( const SPLSTR* Names, const long* Vals, int Count,
                        const SPLSTR* pLookFor, long* pVal )
{
    int i;

    //--- Convert attribute label to upper case
    for( i = 0; i < pLookFor->Len; ++i )
    {
        pLookFor->pStr[i] = wctoupper( pLookFor->pStr[i] );
    }

    //--- Compare
    for( i = 0; i < Count; ++i )
    {
        if( ( pLookFor->Len == Names[i].Len ) &&
            !wcsncmp( pLookFor->pStr, Names[i].pStr, Names[i].Len ) )
        {
            *pVal = Vals[i];
            break;
        }
    }
    return ( i != Count )?( S_OK ):( SPERR_XML_BAD_SYNTAX );
} /* LookupNamedVal */

/*****************************************************************************
* FindAttrVal *
*-------------*
*   Description:
*       This method starts at the current text position and parses the tag
*   to find the next attribute value string.
********************************************************************* EDC ***/
HRESULT FindAttrVal( WCHAR* pStart, WCHAR** ppAttrVal, int* pLen, WCHAR** ppNext )
{
    HRESULT hr = SPERR_XML_BAD_SYNTAX;
    *ppAttrVal = NULL;
    *pLen   = 0;
    pStart = wcskipwhitespace( pStart );
    if( *pStart == L'=' )
    {
        pStart = wcskipwhitespace( ++pStart );
        if( ( *pStart == L'"' ) || ( *pStart == L'\'' ) )
        {
            WCHAR* pEndTag = wcschr( pStart+1, L'>' );
            if( pEndTag )
            {
                WCHAR* pEnd = pStart+1;
                while( ( *pEnd != *pStart ) && ( pEndTag > pEnd ) )
                {
                    ++pEnd;
                }
                if( *pEnd == *pStart )
                {
                    *ppAttrVal = wcskipwhitespace( ++pStart );
                    *pLen      = (int)((wcskiptrailingwhitespace( pEnd - 1 ) + 1) - *ppAttrVal);
                    *ppNext    = pEnd + 1;
                    hr         = S_OK;
                }
            }
        }
    }
    return hr;
} /* FindAttrVal */

/*****************************************************************************
* FindAttr *
*----------*
*   Description:
*       This method starts at the current text position and parses the tag
*   into to find the next attribute.
*
*   S_OK                 = recognized attribute returned
*   S_FALSE              = unrecognized attribute skipped
*   SPERR_XML_BAD_SYNTAX = syntax error
********************************************************************* EDC ***/
HRESULT FindAttr( WCHAR* pStart, XMLATTRID* peAttr, WCHAR** ppNext )
{
    HRESULT hr = S_OK;
    WCHAR* pNext = NULL;

    //--- Advance past whitespace
    pStart = wcskipwhitespace( pStart );

    //--- Find end of tag
    WCHAR* pEndTag = wcschr( pStart+1, L'>' );
    if ( pEndTag )
    {
        //--- Convert token toupper case
        WCHAR* pEndToken = pStart;
        while( pEndToken < pEndTag && ( *pEndToken != L'=' ) && !wcisspace( *pEndToken ) )
        {
            *pEndToken++ = wctoupper( *pEndToken );
        }

        if ( pEndToken == pEndTag )
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else
        {
            //--- Compare
            int j;
            for( j = 0; j < NUM_XMLATTRS; ++j )
            {
                pNext = pStart + g_Attrs[j].Len;
                if( !wcsncmp( pStart, g_Attrs[j].pStr, g_Attrs[j].Len ) &&
                    ( wcisspace( *pNext ) || ( *pNext == L'=' ) ) 
                  )
                {
                    //--- Found valid attribute
                    *peAttr = (XMLATTRID)j;
                    break;
                }
            }

            //--- Skip unknown attribute
            if( j == NUM_XMLATTRS )
            {
                //--- Advance past the attributes value
                WCHAR* pEndVal;
                int LenVal;
                hr = FindAttrVal( pEndToken, &pEndVal, &LenVal, &pNext );
                if( hr == S_OK )
                {
                    hr = S_FALSE;
                }
            }

            if( SUCCEEDED( hr ) )
            {
                *ppNext = pNext;
            }
        }
    }
    else
    {
        hr = SPERR_XML_BAD_SYNTAX;
    }

    return hr;
} /* FindAttr */

/*****************************************************************************
* FindAfterTagPos *
*-----------------*
*   Description:
*       This method starts at the current text position and parses the tag
*   to find the next character position after the tag.
*
********************************************************************* EDC ***/
WCHAR* FindAfterTagPos( WCHAR* pStart )
{
    long lBracketCount = 1;
    while( *pStart )
    {
        if( *pStart == L'<' )
        {
            ++lBracketCount;
        }
        else if( *pStart == L'>' )
        {
            --lBracketCount;
        }

        ++pStart;
        if( lBracketCount == 0 )
        {
            break;
        }
    }
    return pStart;
} /* FindAfterTagPos */

/*****************************************************************************
* ParseTag *
*----------*
*   Description:
*       This method starts at the current text position and parses the tag
*   into it's pieces. It returns the position of the next character after
*   the tag in the buffer.
*
*   S_OK                 = Tag was recognized and parsed successfully
*   SPERR_XML_BAD_SYNTAX = Syntax error
********************************************************************* EDC ***/
HRESULT ParseTag( WCHAR* pStr, XMLTAG* pTag, WCHAR** ppNext )
{
    SPDBG_FUNC( "ParseTag" );
    HRESULT hr = S_OK;
    int i;
    pTag->fIsGlobal   = false;
    pTag->fIsStartTag = true;
    pTag->NumAttrs    = 0;

    //--- Validate that we have a whole tag to try and parse
    pStr = wcskipwhitespace( pStr );
    if( *pStr == L'<' )
    {
        if( !wcschr( pStr, L'>' ) )
        {
            //--- Missing tag end bracket
            return SPERR_XML_BAD_SYNTAX;
        }
    }
    else
    {
        //--- Simple text block, ppNext is next tag or end of string
        if( (*ppNext = wcschr( pStr, L'<' )) == NULL )
        {
            *ppNext = wcschr( pStr, 0 );
        }
        DoCharSubst( pStr, *ppNext );
        pTag->eTag = TAG_TEXT;
        return S_OK;
    }

    //--- Advance past opening bracket and check if this is an end tag
    pStr = wcskipwhitespace( ++pStr );
    if( *pStr == L'/' )
    {
        ++pStr;
        pTag->fIsStartTag = false;
    }

    //--- Convert tag token to upper case
    WCHAR* pUpper = pStr;
    while( !wcisspace( *pUpper ) && ( *pUpper != L'>' ) )
    {
        *pUpper++ = wctoupper( *pUpper );
    }

    //--- Compare tags
    for( i = 0; i < NUM_XMLTAGS; ++i )
    {
        WCHAR* pNext = pStr + g_Tags[i].Len;
        if( !wcsncmp( pStr, g_Tags[i].pStr, g_Tags[i].Len ) && 
            ( wcisspace( *pNext ) || ( *pNext == L'/' ) || ( *pNext == L'>' ) ) )
        {
            pTag->eTag = (XMLTAGID)i;
            pTag->NumAttrs = 0;
            if( *pNext == L'>' )
            {
                //--- Just point past end
                pStr = pNext + 1;
            }
            else if( ( pTag->eTag == TAG_XMLCOMMENT ) ||
                     ( pTag->eTag == TAG_XMLDOC     ) ||
                     ( pTag->eTag == TAG_XMLDOCTYPE ) )
            {
                pStr = FindAfterTagPos( pStr );
            }
            else //--- Get tag attributes
            {
                pStr = pNext;
                while( ( hr == S_OK ) && *pStr )
                {
                    //--- Check for tag termination
                    pStr = wcskipwhitespace( pStr );
                    if( *pStr == L'/' )
                    {
                        ++pStr;
                        pTag->fIsGlobal = true;
                        pStr = wcskipwhitespace( pStr );
                    }

                    //--- End of tag
                    if( *pStr == L'>' )
                    {
                        ++pStr;
                        break;
                    }

                    //--- Get next attribute name/val pair
                    WCHAR* pAttr = pStr;
                    hr = FindAttr( pStr, &pTag->Attrs[pTag->NumAttrs].eAttr, &pStr );
                    if( hr == S_OK )
                    {
                        hr = FindAttrVal( pStr, &pTag->Attrs[pTag->NumAttrs].Value.pStr,
                                         &pTag->Attrs[pTag->NumAttrs].Value.Len, &pStr );
                        if( hr == S_OK )
                        {
                            ++pTag->NumAttrs;
                        }
                    }
                    else if( hr == S_FALSE )
                    {
                        hr = S_OK;
                    #ifdef _DEBUG
                        WCHAR Buff[100];
						ULONG i;
                        for( i = 0;
                             ( i < sp_countof( Buff )) && ( pAttr[i] != 0 ) &&
                             ( pAttr[i] != L' ' ); ++i )
                        {
                            Buff[i] = pAttr[i];
                        }
                        Buff[i] = 0;
                        SPDBG_DMSG1( "\nUnknown attribute ignored => %s\n", Buff );
                    #endif
                    }
                }
            }

            //--- Exit tag search loop
            break;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        //--- If no match, mark as unknown so it can be skipped
        if( i == NUM_XMLTAGS )
        {
            pStr = FindAfterTagPos( pStr );
            pTag->eTag = TAG_UNKNOWN;
        }

        *ppNext = pStr;
    }

    return hr;
} /* CSpVoice::ParseTag */

/*****************************************************************************
* QueryVoiceAttributes *
*----------------------*
*   This returns a composite attribute string for the specified voice
********************************************************************* EDC ***/
HRESULT QueryVoiceAttributes( ISpTTSEngine* pVoice, WCHAR** ppAttrs )
{
    HRESULT hr = S_OK;
    static const SPLSTR ValKeys[] =
    {
        DEF_SPLSTR( "Language" ),
        DEF_SPLSTR( "Gender"   ),
        DEF_SPLSTR( "Name"     ),
        DEF_SPLSTR( "Vendor"   )
    };
    CComQIPtr<ISpObjectWithToken> cpObjWithToken( pVoice );
    CComPtr<ISpObjectToken> cpObjToken;
    hr = cpObjWithToken->GetObjectToken( &cpObjToken );
    if( SUCCEEDED( hr ) )
    {
        CComPtr<ISpDataKey> cpDataKey;
        hr = cpObjToken->OpenKey( KEY_ATTRIBUTES, &cpDataKey );
        if( SUCCEEDED( hr ) )
        {
            WCHAR* Composite = (WCHAR*)alloca( MAX_PATH * sizeof(WCHAR) );
            Composite[0]  = 0;
            ULONG CompLen = 0;

            //--- We loop through all of the attributes even if they are not found
            for( ULONG i = 0; i < sp_countof(ValKeys); ++i )
            {
                WCHAR* pcomemVal;
                hr = cpDataKey->GetStringValue( ValKeys[i].pStr, &pcomemVal );
                if( hr == S_OK )
                {
                    if( CompLen + (ValKeys[i].Len + 1) < MAX_PATH )
                    {
                        wcscat( wcscat( Composite, ValKeys[i].pStr ), L"=" );
                        CompLen += ValKeys[i].Len + 1;
                    }
                    
                    ULONG Len = wcslen( pcomemVal );
                    if( CompLen + (Len + 1) < MAX_PATH )
                    {
                        wcscat( wcscat( Composite, pcomemVal ), L";" );
                        CompLen += Len + 1;
                    }
                    ::CoTaskMemFree( pcomemVal );
                }
            }

            //--- The search is always okay
            hr = S_OK;

            if( CompLen )
            {
                ULONG NumChars = CompLen+1;
                *ppAttrs = new WCHAR[NumChars];
                if( *ppAttrs )
                {
                    memcpy( *ppAttrs, Composite, NumChars * sizeof(WCHAR) );
                }
            }
            else
            {
                //--- The voice had no attributes, this should never happen
                SPDBG_ASSERT(0);
                *ppAttrs = NULL;
            }
        }
    }
    return hr;
} /* QueryVoiceAttributes */

/*****************************************************************************
* GetVoiceAttr *
*--------------*
*   This finds the specified attribute, NULL terminates it in the buffer,
*   and returns a pointer to it.
********************************************************************* EDC ***/
WCHAR* GetVoiceAttr( XMLTAG& Tag, XMLATTRID eAttr )
{
    //--- Setup pointers to attributes
    LPWSTR pAttr = NULL;
    for( int i = 0; i < Tag.NumAttrs; ++i )
    {
        if( Tag.Attrs[i].eAttr == eAttr )
        {
            pAttr = Tag.Attrs[i].Value.pStr;
            pAttr[Tag.Attrs[i].Value.Len] = 0;
            break;
        }
    }
    return pAttr;
} /* GetVoiceAttr */

/*****************************************************************************
* CSpVoice::FindToken *
*---------------------*
*   This method finds the best matching object token
********************************************************************* EDC ***/
HRESULT FindToken( XMLTAG& Tag, const WCHAR* pCat,
                   WCHAR* pCurrVoiceAttrs, ISpObjectToken** ppTok )
{
    SPDBG_FUNC( "FindToken" );
    SPDBG_ASSERT( ppTok && ( *ppTok == NULL ) );
    HRESULT hr = S_OK;

    //--- Compose the optional attributes
    WCHAR* pOpt = GetVoiceAttr( Tag, ATTR_OPTIONAL );
    if( pOpt )
    {
        WCHAR* pNew = (WCHAR*)alloca( (wcslen(pOpt) + wcslen(pCurrVoiceAttrs) + 1) * sizeof(WCHAR) );
        wcscat( wcscat( wcscpy( pNew, pOpt ), L";" ), pCurrVoiceAttrs );
        pOpt = pNew;
    }
    else
    {
        pOpt = pCurrVoiceAttrs;
    }

    //--- Find token based on attributes
    CComPtr<IEnumSpObjectTokens> cpEnum;
    hr = SpEnumTokens( pCat, GetVoiceAttr( Tag, ATTR_REQUIRED ), pOpt, &cpEnum );
    if( SUCCEEDED(hr) )
    {
        hr = cpEnum->Next( 1, ppTok, NULL );
    }
    if( hr == S_FALSE )
    {
        hr = SPERR_XML_RESOURCE_NOT_FOUND;
    }

    return hr;
} /* FindToken */

/*****************************************************************************
* SetXMLVoice *
*-------------*
*   This sets the current voice. It has been moved to a separate function
*   so that the temp memory from alloca is freed on each iteration.
********************************************************************* EDC ***/
HRESULT CSpVoice::
    SetXMLVoice( XMLTAG& Tag, CVoiceNode* pVoiceNode, CPhoneConvNode* pPhoneConvNode )
{
    HRESULT hr = S_OK;
    if( Tag.fIsStartTag )
    {
        WCHAR* pCurrVoiceAttrs = (m_GlobalStateStack.GetVal()).pVoiceEntry->m_pAttrs;
        CComPtr<ISpObjectToken> cpObjToken;
        hr = FindToken( Tag, SPCAT_VOICES, pCurrVoiceAttrs, &cpObjToken );

        //--- See if we already have the specified voice loaded
        CSpDynamicString dstrDesiredId;
        if( SUCCEEDED( hr ) )
        {
            hr = cpObjToken->GetId( &dstrDesiredId.m_psz );
        }

        CVoiceNode* pLastNode           = NULL;
        GLOBALSTATE NewGlobalState      = m_GlobalStateStack.GetVal();
        NewGlobalState.cpPhoneConverter = NULL;
        NewGlobalState.cpVoice          = NULL;
        NewGlobalState.pVoiceEntry      = NULL;
        if( SUCCEEDED( hr ) )
        {
            while( pVoiceNode )
            {
                //--- Do case insensitive comparison of IDs
                if( !_wcsicmp( pVoiceNode->m_dstrVoiceTokenId.m_psz, dstrDesiredId.m_psz ) )
                {
                    NewGlobalState.pVoiceEntry = pVoiceNode;
                    NewGlobalState.cpVoice     = pVoiceNode->m_cpVoice;
                    break;
                }
                pLastNode  = pVoiceNode;
                pVoiceNode = pVoiceNode->m_pNext;
            }
        }

        //--- Create new voice if we didn't find it in the voice list
        if( SUCCEEDED( hr ) && !NewGlobalState.cpVoice )
        {
            hr = SpCreateObjectFromToken( cpObjToken, &NewGlobalState.cpVoice );

            //--- Add to cache list
            if( SUCCEEDED( hr ) )
            {
                pLastNode->m_pNext = new CVoiceNode;
                if( pLastNode->m_pNext )
                {
                    NewGlobalState.pVoiceEntry = pLastNode->m_pNext;
                    NewGlobalState.pVoiceEntry->m_cpVoice = NewGlobalState.cpVoice;
                    NewGlobalState.pVoiceEntry->m_dstrVoiceTokenId = dstrDesiredId;
                    hr = QueryVoiceAttributes( NewGlobalState.cpVoice,
                                              &NewGlobalState.pVoiceEntry->m_pAttrs );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        
        //--- Add new voice to stack
        if( SUCCEEDED( hr ) )
        {
            //--- Now need to add a new phone converter corresponding to the new voice
            LANGID langid;
            hr = SpGetLanguageFromVoiceToken(cpObjToken, &langid);
            if (SUCCEEDED(hr))
            {
                //--- See if we already have this phone converter loaded
                LANGID ExistingLangId = pPhoneConvNode->m_LangID;
                CPhoneConvNode *pLastPhoneConvNode = NULL;
                while ( pPhoneConvNode )
                {
                    if ( ExistingLangId == langid )
                    {
                        NewGlobalState.cpPhoneConverter = pPhoneConvNode->m_cpPhoneConverter;
                        break;
                    }
                    pLastPhoneConvNode = pPhoneConvNode;
                    pPhoneConvNode = pPhoneConvNode->m_pNext;
                }
                if ( !NewGlobalState.cpPhoneConverter )
                {
                    //--- Didn't find the phone converter in the list
                    hr = SpCreatePhoneConverter(langid, NULL, NULL, &NewGlobalState.cpPhoneConverter);
                    if ( SUCCEEDED( hr ) )
                    {
                        pLastPhoneConvNode->m_pNext = new CPhoneConvNode;
                        if ( pLastPhoneConvNode->m_pNext )
                        {
                            pLastPhoneConvNode->m_pNext->m_cpPhoneConverter = 
                                NewGlobalState.cpPhoneConverter;
                            pLastPhoneConvNode->m_pNext->m_LangID = langid;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
                //--- Add new stuff to the stacks
                if ( SUCCEEDED( hr ) )
                {
                    hr = m_GlobalStateStack.SetVal( NewGlobalState, true );
                }
            }
            //--- end section
        }
    }
    else
    {
        hr = PopXMLState();
    }

    return hr;
} /* CSpVoice::SetXMLVoice */

/*****************************************************************************
* SetXMLLanguage *
*----------------*
*   This sets the current Locale, which can change the current voice. It has 
*   been moved to a separate function so that the temp memory from alloca is 
*   freed on each iteration.
********************************************************************* AH ****/
HRESULT CSpVoice::SetXMLLanguage( XMLTAG& Tag, CVoiceNode* pVoiceNode,
                                  CPhoneConvNode* pPhoneConvNode )
{
    HRESULT hr = S_OK;
    long Value = 0;

    if( Tag.fIsStartTag )
    {
        //--- Find the LANGID attribute
        for( int AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
        {
            if( Tag.Attrs[AttrIndex].eAttr == ATTR_LANGID ) break;
        }

        if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0) )
        {
            hr = SPERR_XML_BAD_SYNTAX;
        }
        else
        {
            //--- Get lang id, which is spec'ed as hex without the leading 0x??
            wcatol( Tag.Attrs[AttrIndex].Value.pStr, &Value, true );

            //--- Compose the required string
            WCHAR Required[30];
            wcsncat( wcscpy( Required, L"Language=" ), 
                     Tag.Attrs[AttrIndex].Value.pStr,
                     min( (int) ( Tag.Attrs[AttrIndex].Value.Len ), 
                          (int) ( sp_countof( Required ) - wcslen(Required) )
                          ) 
                     );

            /* We'll create a voice selection tag with the LANGID being required
            *  and the attributes of the current voice being optional to get the
            *  closest match.
            */
            XMLTAG NewVoiceTag;
            memset( &NewVoiceTag, 0, sizeof(XMLTAG) );
            NewVoiceTag.fIsGlobal           = Tag.fIsGlobal;
            NewVoiceTag.fIsStartTag         = Tag.fIsStartTag;
            NewVoiceTag.eTag                = TAG_VOICE;
            NewVoiceTag.NumAttrs            = 2;
            NewVoiceTag.Attrs[0].eAttr      = ATTR_REQUIRED;
            NewVoiceTag.Attrs[0].Value.pStr = Required;
            NewVoiceTag.Attrs[0].Value.Len  = wcslen( Required );
            NewVoiceTag.Attrs[1].eAttr      = ATTR_OPTIONAL;
            NewVoiceTag.Attrs[1].Value.pStr = m_GlobalStateStack.GetVal().pVoiceEntry->m_pAttrs;
            NewVoiceTag.Attrs[1].Value.Len  = wcslen( NewVoiceTag.Attrs[1].Value.pStr );

            //--- Try to set a new voice
            hr = SetXMLVoice( NewVoiceTag, pVoiceNode, pPhoneConvNode );

            //--- If no voice matches request, we just set the new langid
            //    and let the current engine do its best.
            if( hr == SPERR_XML_RESOURCE_NOT_FOUND )
            {
                hr = S_OK;
                GLOBALSTATE NewGlobalState = m_GlobalStateStack.GetVal();
                NewGlobalState.LangID = (LANGID)Value;
                hr = m_GlobalStateStack.SetVal( NewGlobalState, true );
            }
        }
    }
    else
    {
        hr = PopXMLState();
    }

    return hr;
} /* CSpVoice::SetXMLLanguage */

/*****************************************************************************
* CSpVoice::ConvertPhonStr2Bin *
*------------------------------*
*   Description:
*       This method converts the alpha phoneme string to binary
*   in place.
********************************************************************* EDC ***/
HRESULT CSpVoice::ConvertPhonStr2Bin( XMLTAG& Tag, int AttrIndex, SPVTEXTFRAG* pFrag )
{
    HRESULT hr = S_OK;
    pFrag->State.eAction = SPVA_Pronounce;

    Tag.Attrs[AttrIndex].Value.pStr[Tag.Attrs[AttrIndex].Value.Len] = 0;
    hr = (m_GlobalStateStack.GetVal()).cpPhoneConverter->
         PhoneToId( Tag.Attrs[AttrIndex].Value.pStr, Tag.Attrs[AttrIndex].Value.pStr );
    if( SUCCEEDED(hr) )
    {
        pFrag->State.pPhoneIds = Tag.Attrs[AttrIndex].Value.pStr;
        pFrag->State.pPhoneIds[wcslen(Tag.Attrs[AttrIndex].Value.pStr)] = 0;
    }
    return hr;
} /* CSpVoice::ConvertPhonStr2Bin */

/*****************************************************************************
* CSpVoice::ParseXML *
*--------------------*
*   Description:
*       This method parses the text buffer and creates the text block array
*   for the specified render info structure. The voice has a global document
*   concept. You are always in an XML doc. The parser allows a single level
*   of XML document to be nested within the global document.
********************************************************************* EDC ***/
HRESULT CSpVoice::ParseXML( CSpeakInfo& SI )
{
    SPDBG_FUNC( "CSpVoice::ParseXML" );
    SPDBG_ASSERT( SI.m_pSpeechSegList == NULL );
    HRESULT hr = S_OK;
    LPWSTR pPos, pNext = SI.m_pText;
    SPVTEXTFRAG* pFrag;
    CSpeechSeg* pCurrSeg = NULL;
    GLOBALSTATE NewGlobalState, SavedState;
    XMLTAG Tag;
    long Val;
    int AttrIndex;

    //--- Save state unless caller wants to persist
    if( !(SI.m_dwSpeakFlags & SPF_PERSIST_XML) )
    {
        SavedState = m_GlobalStateStack.GetBaseVal();
    }

    //=== Initialize Voice usage list, this is only used during parsing
    CVoiceNode VoiceList;
    (m_GlobalStateStack.GetValRef()).pVoiceEntry = &VoiceList;
    VoiceList.m_cpVoice = (m_GlobalStateStack.GetVal()).cpVoice;
    hr = m_cpVoiceToken->GetId( &VoiceList.m_dstrVoiceTokenId.m_psz );
    if( SUCCEEDED( hr ) )
    {
        hr = QueryVoiceAttributes( VoiceList.m_cpVoice, &VoiceList.m_pAttrs );
    }

    //=== Initialize Phone converter usage list, this is only used during parsing
    CPhoneConvNode PhoneConvList;
    if( SUCCEEDED( hr ) )
    {
        CComPtr<ISpObjectWithToken> cpObjWithToken;
        CComPtr<ISpObjectToken> cpObjToken;
        CSpDynamicString dstrAttributes;
        
        PhoneConvList.m_cpPhoneConverter = (m_GlobalStateStack.GetBaseVal()).cpPhoneConverter;
        hr = PhoneConvList.m_cpPhoneConverter.QueryInterface( &cpObjWithToken );
        if ( SUCCEEDED ( hr ) )
        {
            hr = cpObjWithToken->GetObjectToken( &cpObjToken );
            if ( SUCCEEDED( hr ) )
            {
                LANGID langid;
                hr = SpGetLanguageFromVoiceToken(cpObjToken, &langid);
                
                if (SUCCEEDED(hr))
                {
                    PhoneConvList.m_LangID = langid;
                }
            }
        }
    }

    //--- Main parsing loop
    while( *pNext && ( hr == S_OK ) )
    {
        pPos = wcskipwhitespace( pNext );
        if( ( hr = ParseTag( pPos, &Tag, &pNext )) == S_OK )
        {
            switch( Tag.eTag )
            {
              //--- Use the current state to add a text info block to list
              case TAG_UNKNOWN:
              case TAG_TEXT:
              {
                if( !pCurrSeg )
                {
                    hr = SI.AddNewSeg( GetCurrXMLVoice(), &pCurrSeg );
                }

                if( SUCCEEDED( hr ) )
                {
                    //--- Add the text fragment
                    pFrag = pCurrSeg->AddFrag( this, SI.m_pText, pPos, pNext );
                    if( pFrag && ( Tag.eTag == TAG_UNKNOWN ) )
                    {
                        pFrag->State.eAction = SPVA_ParseUnknownTag;
                    }
                }
              }
              break;

              //--- Change voice --------------------------------------
              case TAG_VOICE:
              {
                //--- Set the new voice
                hr = SetXMLVoice( Tag, &VoiceList, &PhoneConvList );

                //--- Set the current seg to NULL to force a new segment to be created
                pCurrSeg = NULL;
              }
              break;

              //--- Set context --------------------------------------
              case TAG_CONTEXT:
              {
                if( Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else if( Tag.fIsStartTag )
                {
                    SPVCONTEXT Ctx = (m_GlobalStateStack.GetVal()).Context;

                    for( int i = 0; i < Tag.NumAttrs; ++i )
                    {
                        if( Tag.Attrs[i].eAttr == ATTR_ID )
                        {
                            Ctx.pCategory = Tag.Attrs[i].Value.pStr;
                        }
                        else if( Tag.Attrs[i].eAttr == ATTR_BEFORE )
                        {
                            Ctx.pBefore = Tag.Attrs[i].Value.pStr;
                        }
                        else if( Tag.Attrs[i].eAttr == ATTR_AFTER )
                        {
                            Ctx.pAfter = Tag.Attrs[i].Value.pStr;
                        }
                        else
                        {
                            continue;
                        }
                        //--- Terminate buffer strings
                        Tag.Attrs[i].Value.pStr[Tag.Attrs[i].Value.Len] = 0;
                    }
                    NewGlobalState = m_GlobalStateStack.GetVal();
                    NewGlobalState.Context = Ctx;
                    hr = m_GlobalStateStack.SetVal( NewGlobalState, !Tag.fIsGlobal );
                }
                else
                {
                    hr = PopXMLState();
                }
              }
              break;

              //--- Volume ------------------------------------------------------------
              case TAG_VOLUME:
              {
                if( Tag.fIsStartTag )
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( Tag.Attrs[AttrIndex].eAttr == ATTR_LEVEL ) break;
                    }

                    if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0))
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                    else
                    {
                        ULONG NumConv = wcatol( Tag.Attrs[AttrIndex].Value.pStr, &Val, false );
                        if( NumConv == 0 )
                        {
                            hr = LookupNamedVal( g_VolumeLevelNames, g_VolumeLevelVals,
                                                 NUM_VOLUME_LEVEL_VALS,
                                                 &Tag.Attrs[AttrIndex].Value,
                                                 &Val );
                            if( hr != S_OK )
                            {
                                hr = SPERR_XML_BAD_SYNTAX;
                                break;
                            }
                        }
                        else if( NumConv != (ULONG)Tag.Attrs[AttrIndex].Value.Len )
                        {
                            hr = SPERR_XML_BAD_SYNTAX;
                            break;
                        }

                        if( SUCCEEDED( hr ) )
                        {
                            Val = max( min( Val, 100 ), 0 );
                            NewGlobalState = m_GlobalStateStack.GetVal();
                            NewGlobalState.Volume = Val;
                            hr = m_GlobalStateStack.SetVal( NewGlobalState, !Tag.fIsGlobal );
                        }
                    }
                }
                else
                {
                    hr = PopXMLState();
                }
              }
              break;

              //--- Emphasis ----------------------------------------------------------
              case TAG_EMPH:
              {
                if( Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else if( Tag.fIsStartTag )
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( Tag.Attrs[AttrIndex].eAttr == ATTR_LEVEL ) break;
                    }

                    if( Tag.NumAttrs == 0 )
                    {
                        NewGlobalState = m_GlobalStateStack.GetVal();
                        NewGlobalState.EmphAdj = g_EmphLevelVals[1];
                        hr = m_GlobalStateStack.SetVal( NewGlobalState, !Tag.fIsGlobal );
                    }
                    else if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0) )
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                    else
                    {
                        ULONG NumConv = wcatol( Tag.Attrs[AttrIndex].Value.pStr, &Val, false );

                        if ( NumConv == 0 )
                        {
                            hr = LookupNamedVal( g_EmphLevelNames, g_EmphLevelVals,
                                                 NUM_EMPH_LEVEL_VALS, &Tag.Attrs[AttrIndex].Value,
                                                 &Val );
                        }
                        else if ( NumConv != (ULONG) Tag.Attrs[AttrIndex].Value.Len )
                        {
                            hr = SPERR_XML_BAD_SYNTAX;
                        }

                        if( SUCCEEDED( hr ) )
                        {
                            NewGlobalState = m_GlobalStateStack.GetVal();
                            NewGlobalState.EmphAdj = Val;
                            hr = m_GlobalStateStack.SetVal( NewGlobalState, !Tag.fIsGlobal );
                        }
                    }
                }
                else
                {
                    hr = PopXMLState();
                }
              }
              break;

              //--- Pitch -------------------------------------------------------------
              case TAG_PITCH:
              {
                if( Tag.fIsStartTag )
                {
                    //--- Make sure we have at least one known attribute
                    if( Tag.NumAttrs == 0 )
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                        break;
                    }

                    NewGlobalState = m_GlobalStateStack.GetVal();
                    SPVPITCH Pitch = NewGlobalState.PitchAdj;

                    for( int i = 0; i < Tag.NumAttrs; ++i )
                    {
                        ULONG NumConv = wcatol( Tag.Attrs[i].Value.pStr, &Val, false );
                        if( NumConv == 0 )
                        {
                            hr = LookupNamedVal( g_PitchNames, g_PitchVals, NUM_PITCH_VALS,
                                                 &Tag.Attrs[i].Value, &Val );
                            if( hr != S_OK )
                            {
                                hr = SPERR_XML_BAD_SYNTAX;
                                break;
                            }
                        }
                        else if( NumConv != (ULONG)Tag.Attrs[i].Value.Len )
                        {
                            hr = SPERR_XML_BAD_SYNTAX;
                            break;
                        }

                        switch( Tag.Attrs[i].eAttr )
                        {
                          case ATTR_MIDDLE:
                            Pitch.MiddleAdj += Val;
                            break;
                          case ATTR_ABSMIDDLE:
                            Pitch.MiddleAdj = Val;
                            break;
                          case ATTR_RANGE:
                            Pitch.RangeAdj += Val;
                            break;
                          case ATTR_ABSRANGE:
                            Pitch.RangeAdj = Val;
                            break;
                        }
                    }
                    if ( SUCCEEDED( hr ) )
                    {
                        NewGlobalState.PitchAdj = Pitch;
                        hr = m_GlobalStateStack.SetVal( NewGlobalState, !Tag.fIsGlobal );
                    }
                }
                else
                {
                    hr = PopXMLState();
                }
              }
              break;

              //--- Rate --------------------------------------------------------------
              case TAG_RATE:
              {
                if( Tag.fIsStartTag )
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( ( Tag.Attrs[AttrIndex].eAttr == ATTR_SPEED    ) ||
                            ( Tag.Attrs[AttrIndex].eAttr == ATTR_ABSSPEED ) )
                        {
                            ULONG NumConv = wcatol( Tag.Attrs[AttrIndex].Value.pStr, &Val, false );
                            if( NumConv == 0 )
                            {
                                hr = LookupNamedVal( g_RateSpeedNames, g_RateSpeedVals, NUM_RATE_SPEED_VALS,
                                                     &Tag.Attrs[AttrIndex].Value, &Val );
                                if( hr != S_OK )
                                {
                                    hr = SPERR_XML_BAD_SYNTAX;
                                    break;
                                }
                            }
                            else if( NumConv != (ULONG)Tag.Attrs[AttrIndex].Value.Len )
                            {
                                hr = SPERR_XML_BAD_SYNTAX;
                                break;
                            }

                            if( SUCCEEDED( hr ) )
                            {
                                NewGlobalState = m_GlobalStateStack.GetVal();
                                if( Tag.Attrs[AttrIndex].eAttr == ATTR_SPEED )
                                {
                                    NewGlobalState.RateAdj += Val;
                                }
                                else
                                {
                                    NewGlobalState.RateAdj = Val;
                                }
                                hr = m_GlobalStateStack.SetVal( NewGlobalState, !Tag.fIsGlobal );
                            }

                            //--- Set Rate flag so that m_fUseDefaultRate can be updated
                            if ( SUCCEEDED( hr ) &&
                                 Tag.fIsGlobal )
                            {
                                if ( !pCurrSeg )
                                {
                                    hr = SI.AddNewSeg( GetCurrXMLVoice(), &pCurrSeg );
                                }

                                if ( SUCCEEDED( hr ) )
                                {
                                    pCurrSeg->SetRateFlag();
                                }
                            }

                            break;
                        }
                    }

                    if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0))
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                }
                else
                {
                    hr = PopXMLState();
                }
              }
              break;

              //--- SPELL -----------------------------------------------------
              case TAG_SPELL:
              {
                if( Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else if( Tag.fIsStartTag )
                {
                    NewGlobalState = m_GlobalStateStack.GetVal();
                    NewGlobalState.fDoSpellOut = true;
                    hr = m_GlobalStateStack.SetVal( NewGlobalState, !Tag.fIsGlobal );
                }
                else
                {
                    hr = PopXMLState();
                }
              }
              break;

              //--- Change Lang -------------------------------------------------
              case TAG_LANG:
              {
                  //--- Set the current language
                  hr = SetXMLLanguage( Tag, &VoiceList, &PhoneConvList );

                  //--- Set the current seg to NULL to force a new segment to be created
                  pCurrSeg = NULL;
              }
              break;

              //--- Silence -----------------------------------------------------
              case TAG_SILENCE:
              {
                if( !Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( Tag.Attrs[AttrIndex].eAttr == ATTR_MSEC ) break;
                    }

                    if( ( AttrIndex == Tag.NumAttrs ) ||
                        ( Tag.Attrs[AttrIndex].Value.Len <= 0) ||
                        ( !( wcatol( Tag.Attrs[AttrIndex].Value.pStr, &Val, false ) == 
                             (ULONG) Tag.Attrs[AttrIndex].Value.Len ) ) )
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                    else
                    {
                        if( !pCurrSeg )
                        {
                            hr = SI.AddNewSeg( GetCurrXMLVoice(), &pCurrSeg );
                        }

                        if( SUCCEEDED( hr ) )
                        {
                            pFrag = pCurrSeg->AddFrag( this, SI.m_pText, pPos, pNext );
                            if( pFrag )
                            {
                                Val = max( min( Val, 65535 ), 0 );
                                pFrag->State.eAction      = SPVA_Silence;
                                pFrag->State.SilenceMSecs = Val;
                                pFrag->pTextStart         = NULL;
                                pFrag->ulTextLen          = 0;
                            }
                        }
                    }
                }
              }
              break;

              //--- Bookmark ----------------------------------------------------
              case TAG_BOOKMARK:
              {
                if( !Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( Tag.Attrs[AttrIndex].eAttr == ATTR_MARK ) break;
                    }

                    if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0))
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                    else
                    {
                        if( !pCurrSeg )
                        {
                            hr = SI.AddNewSeg( GetCurrXMLVoice(), &pCurrSeg );
                        }

                        if( SUCCEEDED( hr ) )
                        {
                            pFrag = pCurrSeg->AddFrag( this, SI.m_pText, pPos, pNext );
                            if( pFrag )
                            {
                                pFrag->State.eAction = SPVA_Bookmark;
                                pFrag->pTextStart    = Tag.Attrs[AttrIndex].Value.pStr;
                                pFrag->ulTextLen     = Tag.Attrs[AttrIndex].Value.Len;
                            }
                        }
                    }
                }
              }
              break;

              //--- Section ----------------------------------------------------
              case TAG_SECT:
              {
                if( !Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( Tag.Attrs[AttrIndex].eAttr == ATTR_ID ) break;
                    }

                    if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0))
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                    else
                    {
                        if( !pCurrSeg )
                        {
                            hr = SI.AddNewSeg( GetCurrXMLVoice(), &pCurrSeg );
                        }

                        if( SUCCEEDED( hr ) )
                        {
                            pFrag = pCurrSeg->AddFrag( this, SI.m_pText, pPos, pNext );
                            if( pFrag )
                            {
                                pFrag->State.eAction = SPVA_Section;
                                pFrag->pTextStart    = Tag.Attrs[AttrIndex].Value.pStr;
                                pFrag->ulTextLen     = Tag.Attrs[AttrIndex].Value.Len;
                            }
                        }
                    }
                }
              }
              break;

              //--- Part of speech --------------------------------------------
              case TAG_PARTOFSP:
              {
                if( Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else if( Tag.fIsStartTag )
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( Tag.Attrs[AttrIndex].eAttr == ATTR_PART ) break;
                    }

                    if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0))
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                    else
                    {
                        hr = LookupNamedVal( g_POSLevelNames, g_POSLevelVals,
                                             NUM_POS_LEVEL_VALS, &Tag.Attrs[AttrIndex].Value,
                                             &Val );
                    }
                    if ( SUCCEEDED( hr ) )
                    {
                        NewGlobalState = m_GlobalStateStack.GetVal();
                        NewGlobalState.ePartOfSpeech = (SPPARTOFSPEECH) Val;
                        hr = m_GlobalStateStack.SetVal( NewGlobalState, true );
                    }
                }
                else
                {
                    hr = PopXMLState();
                }
              }
              break;

              //--- Pronounciation --------------------------------------------
              case TAG_PRON:
              {
                if( Tag.fIsStartTag )
                {
                    //--- Find the attribute
                    for( AttrIndex = 0; AttrIndex < Tag.NumAttrs; ++AttrIndex )
                    {
                        if( Tag.Attrs[AttrIndex].eAttr == ATTR_SYM ) break;
                    }

                    if( ( AttrIndex == Tag.NumAttrs ) || ( Tag.Attrs[AttrIndex].Value.Len <= 0))
                    {
                        hr = SPERR_XML_BAD_SYNTAX;
                    }
                    else
                    {
                        if( !pCurrSeg )
                        {
                            hr = SI.AddNewSeg( GetCurrXMLVoice(), &pCurrSeg );
                        }

                        if( SUCCEEDED( hr ) )
                        {
                            pFrag = pCurrSeg->AddFrag( this, SI.m_pText, pPos, pNext );
                            if( pFrag )
                            {
                                hr = ConvertPhonStr2Bin( Tag, AttrIndex, pFrag );

                                if( Tag.fIsGlobal )
                                {
                                    pFrag->pTextStart = NULL;
                                    pFrag->ulTextLen  = 0;
                                }
                                else if( SUCCEEDED( hr ) )
                                {
                                    //--- Get the contained phrase to which
                                    //    this pronounciation applies
                                    pPos = wcskipwhitespace( pNext );
                                    if( ( hr = ParseTag( pPos, &Tag, &pNext )) == S_OK )
                                    {
                                        if( ( Tag.eTag == TAG_TEXT ) && ( pNext > pPos ) )
                                        {
                                            pFrag->ulTextSrcOffset += ULONG(pPos - pFrag->pTextStart);
                                            pFrag->pTextStart = wcskipwhitespace( pPos );
                                            pFrag->ulTextLen = ULONG(( wcskiptrailingwhitespace( pNext - 1 ) - pFrag->pTextStart ) + 1);
                                        }
                                        else if( ( Tag.eTag == TAG_PRON ) && !Tag.fIsStartTag )
                                        {
                                            //--- Empty scope
                                            pFrag->pTextStart = NULL;
                                            pFrag->ulTextLen  = 0;
                                        }
                                        else
                                        {
                                            hr = SPERR_XML_BAD_SYNTAX;
                                        }
                                    }
                                }
                            } // end if frag
                        }
                    }
                }
              }
              break;

              //--- Comment ---------------------------------------------------
              case TAG_XMLCOMMENT:  // skip
              case TAG_XMLDOC:
              case TAG_XMLDOCTYPE:
                  break;

              //--- New scope -------------------------------------------------
              case TAG_SAPI:
              {
                if( Tag.fIsGlobal )
                {
                    hr = SPERR_XML_BAD_SYNTAX;
                }
                else if( Tag.fIsStartTag )
                {
                    m_GlobalStateStack.DupAndPushVal();
                }
                else
                {
                    if( SUCCEEDED( hr = PopXMLState() ) )
                    {
                        //--- Add an empty segement with the global voice restored.
                        //    This will cause a change voice event to occur.
                        hr = SI.AddNewSeg( GetCurrXMLVoice(), &pCurrSeg );
                    }
                }
              }
              break;
            
              default:
                //--- Bad tag
                SPDBG_ASSERT( 0 );
            } // end switch
        } // end if successful tag parsing
    } // end while

    //--- Close any scopes left open
    m_GlobalStateStack.Reset();

    //--- Restore state unless caller wants to persist
    if( !(SI.m_dwSpeakFlags & SPF_PERSIST_XML) )
    {
        m_GlobalStateStack.SetBaseVal( SavedState );
    }

    return hr;
} /* CSpVoice::ParseXML */

//
//=== CSpeechSeg ==============================================================
//

/*****************************************************************************
* CSpeechSeg::AddFrag *
*---------------------*
*   Description:
*       This method adds a text fragment structure to the current xml parse
*   list and initializes it with the current state.
********************************************************************* EDC ***/
SPVTEXTFRAG* CSpeechSeg::
    AddFrag( CSpVoice* pVoice, WCHAR* pStart, WCHAR* pPos, WCHAR* pNext )
{
    SPVTEXTFRAG* pFrag = new SPVTEXTFRAG;
    if( pFrag )
    {
        //--- Add the fragment
        memset( pFrag, 0, sizeof( *pFrag ) );
        if( m_pFragTail )
        {
            m_pFragTail->pNext = pFrag;
            m_pFragTail = pFrag;
        }
        else
        {
            m_pFragHead = m_pFragTail = pFrag;
        }

        //--- Initialize it
        GLOBALSTATE tempGlobalState = pVoice->m_GlobalStateStack.GetVal();
        pFrag->State                = (SPVSTATE) tempGlobalState;
        pFrag->State.eAction        = tempGlobalState.fDoSpellOut ? (SPVA_SpellOut):(SPVA_Speak);
        pFrag->pTextStart           = wcskipwhitespace( pPos );
        pFrag->ulTextLen            = ULONG(pNext - pFrag->pTextStart);
        pFrag->ulTextSrcOffset      = ULONG(pFrag->pTextStart - pStart);
    }
    return pFrag;
} /* CSpeechSeg::AddFrag */

/****************************************************************************
* CSpeechSeg::Init *
*------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
HRESULT CSpeechSeg::Init( ISpTTSEngine * pCurrVoice, const CSpStreamFormat & OutFmt )
{
    SPDBG_FUNC("CSpeechSeg::Init");
    HRESULT hr = S_OK;

    if ( m_VoiceFormat.FormatId() != GUID_NULL) 
    {
        m_VoiceFormat.Clear();
    }
    
    SPDBG_ASSERT(m_VoiceFormat.FormatId() == GUID_NULL);
    hr = pCurrVoice->GetOutputFormat(&OutFmt.FormatId(), OutFmt.WaveFormatExPtr(),
                                     &m_VoiceFormat.m_guidFormatId, &m_VoiceFormat.m_pCoMemWaveFormatEx);

    if (SUCCEEDED(hr))
    {
        m_cpVoice = pCurrVoice;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CSpeechSeg::Init */

//
//=== CSpeakInfo ==============================================================
//


/*****************************************************************************
* CSpeakInfo::AddNewSeg *
*-----------------------*
*   Description:
*       This method creates a new speech segment. Each segment is intended for
*   a different underlying engine voice.
********************************************************************* EDC ***/
HRESULT CSpeakInfo::AddNewSeg( ISpTTSEngine* pCurrVoice, CSpeechSeg** ppNew )
{
    HRESULT hr = S_OK;
    
    *ppNew = NULL;
    if( m_pSpeechSegListTail && ( m_pSpeechSegListTail->GetFragList() == NULL ) )
    {
        //--- Reuse empty segment
        hr = m_pSpeechSegListTail->Init( pCurrVoice, m_OutStreamFmt );
        if (SUCCEEDED(hr))
        {
            *ppNew = m_pSpeechSegListTail;
        }
    }
    else
    {
        //--- Create and attach new segment
        CSpeechSeg* pNew = new CSpeechSeg;
        if( !pNew )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pNew->Init( pCurrVoice, m_OutStreamFmt );
            if (SUCCEEDED(hr))
            {
                *ppNew = pNew;

                if( m_pSpeechSegListTail )
                {
                    m_pSpeechSegListTail->SetNextSeg( pNew );
                    m_pSpeechSegListTail = pNew;
                }
                else
                {
                    m_pSpeechSegList = m_pSpeechSegListTail = pNew;
                }
            }
            else
            {
                delete pNew;
            }
        }
    }

    return hr;
} /* CSpeakInfo::AddNewSeg */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapisvr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapisvr\sapisvr.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <sapi.h>
#include <atlbase.h>
#include <spdebug.h>
#include "sapiint.h"
#include <assertwithstack.cpp>

extern "C" int WINAPI WinMain(
    HINSTANCE hInstance, 
    HINSTANCE hPrevInstance, 
    LPTSTR lpCmdLine, 
    int nShowCmd)
{
    SPDBG_FUNC("WinMain");
    HRESULT hr;

    SPDBG_DEBUG_SERVER_ON_START();

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        CComPtr<ISpSapiServer> cpSapiServer;
        hr = cpSapiServer.CoCreateInstance(CLSID_SpSapiServer);

        if (SUCCEEDED(hr))
        {
            hr = cpSapiServer->Run();
        }
    }

    CoUninitialize();

    SPDBG_REPORT_ON_FAIL(hr);    
    return SUCCEEDED(hr) ? 0 : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\sapisvr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__08118482_E572_4649_A856_6D1DDF721B3C__INCLUDED_)
#define AFX_STDAFX_H__08118482_E572_4649_A856_6D1DDF721B3C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__08118482_E572_4649_A856_6D1DDF721B3C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\cfgdump\cfgdump.cpp ===
// cfgdump.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "sapi.h"

#include "..\..\..\common\include\assertwithstack.h"

#include "..\..\..\common\include\assertwithstack.cpp"

#define _SYMBOL(x) (Header.pszSymbols + (x))

CComModule _Module;

const WCHAR * Word(ULONG x, const SPCFGHEADER & Header)
{
    const WCHAR * psz = Header.pszWords;
	if (x > Header.cchWords)
	{
		return(L"ERROR");
	}
    while (x)
    {
        for (; *psz; psz++) {}
        x--;
        psz++;
    }
    return psz;
}


void _PrintRuleName(const SPCFGHEADER & Header, ULONG ulIndex)
{
    for (ULONG i = 0; i < Header.cRules; i++)
    {
        if (Header.pRules[i].FirstArcIndex == ulIndex)
        {
            wprintf(L"<%s>", _SYMBOL(Header.pRules[i].NameSymbolOffset));
            return;
        }
    }
    wprintf(L"<0x%.8x>", ulIndex);
}

void _RecurseDump(const SPCFGHEADER & Header, ULONG NodeIndex, BYTE * pFlags, long * pPathIndexList, ULONG ulPathLen)
{
    if (NodeIndex == 0)
    {
        return;
    }
    SPCFGARC * pArc = Header.pArcs + NodeIndex;
    while (TRUE)
    {
        if ((pFlags[NodeIndex] & 0x40)== 0)      // Don't allow 2 recursions
        {
            if (pFlags[NodeIndex] & 0x80)
            {
                pFlags[NodeIndex] |= 0x40;
                pPathIndexList[ulPathLen] = -((long)NodeIndex);
            }
            else
            {
                pFlags[NodeIndex] |= 0x80;
                pPathIndexList[ulPathLen] = NodeIndex;
            }
            if (pArc->NextStartArcIndex == 0)    // Terminal -- Print the stuff out!
            {
                for (ULONG i = 0; i <= ulPathLen; i++)
                {
                    ULONG ulIndex;
                    if (pPathIndexList[i] < 0)
                    {
                        ulIndex = -pPathIndexList[i];
                    }
                    else
                    {
                        ulIndex = pPathIndexList[i];
                    }
                    SPCFGARC * pPrintNode = Header.pArcs + ulIndex;
                    if (pPrintNode->fRuleRef)
                    {
                        SPCFGRULE * pRule = Header.pRules + pPrintNode->TransitionIndex;
                        if (pRule->NameSymbolOffset)
                        {
                            wprintf(L"(%s) ", _SYMBOL(pRule->NameSymbolOffset));
                        }
                        else
                        {
                            wprintf(L"(ID=%d) ", pRule->RuleId);
                        }
                    }
                    else
                    {
                        if (pPrintNode->TransitionIndex)
                        {
							if (pPrintNode->TransitionIndex == SPTEXTBUFFERTRANSITION)
							{
								wprintf(L"[TEXTBUFFER] ");
							}
							else if (pPrintNode->TransitionIndex == SPWILDCARDTRANSITION)
							{
								wprintf(L"... ");
							}
							else if (pPrintNode->TransitionIndex == SPDICTATIONTRANSITION)
							{
								wprintf(L"* ");
							}
							else
							{
                                const WCHAR *pszWord = Word(pPrintNode->TransitionIndex, Header); 
                                wprintf(L"%s%c ", pszWord, (pszWord && (*pszWord == L'/')) ? L';' : L'');
							}
                        }
                    }
                }
                //
                //  Now the semantic info...
                //
                BOOL bHaveSemanticInfo = FALSE;
                wprintf(L"-- ");
                for (i = 0; i <= ulPathLen; i++)
                {
                    ULONG ulVal;
                    if (pPathIndexList[i] < 0)
                    {
                        ulVal = -pPathIndexList[i];
                    }
                    else
                    {
                        ulVal = pPathIndexList[i];
                    }
                    if (Header.pArcs[ulVal].fHasSemanticTag)
                    {
                        long lFirst = 0;
                        long lLast = ((long)Header.cSemanticTags) - 1;
                        while (lFirst <= lLast)
                        {
                            long lTest = (lFirst + lLast) / 2;
                            SPCFGSEMANTICTAG * pTag = Header.pSemanticTags + lTest;
                            ULONG ulTestVal = pTag->ArcIndex;
                            if (ulTestVal == ulVal)
                            {
                                CComVariant cvVar;
                                HRESULT hr = AssignSemanticValue(pTag, &cvVar);
                                if (SUCCEEDED(hr))
                                {
                                    hr = cvVar.ChangeType(VT_BSTR);
                                }
                                wprintf(L"%s=\"%s\" (%s)", _SYMBOL(pTag->PropNameSymbolOffset), _SYMBOL(pTag->PropValueSymbolOffset), 
                                        cvVar.bstrVal);
                                bHaveSemanticInfo = TRUE;
                                break;
                            }
                            if (ulTestVal < ulVal)
                            {
                                lFirst = lTest + 1;
                            }
                            else
                            {
                                lLast = lTest - 1;
                            }
                        }
                        _ASSERT(lFirst <= lLast);
                    }
                }
                if (!bHaveSemanticInfo)
                {
                    wprintf(L"(none)\n");
                }
                else
                {
                    wprintf(L"\n");
                }
            }
            else
            {
                _RecurseDump(Header, pArc->NextStartArcIndex, pFlags, pPathIndexList, ulPathLen+1);
            }
            if (pFlags[NodeIndex] & 0x40)
            {
                pFlags[NodeIndex] &= ~(0x40);
            }
            else
            {
                pFlags[NodeIndex] &= ~(0x80);
            }
        }
        if (pArc->fLastArc)
        {
            break;
        }
        pArc++;
        NodeIndex++;
    }
}

void DumpContents(const SPCFGSERIALIZEDHEADER * pFileData)
{

    CComPtr<ISpGramCompBackend> cpBackend;
    cpBackend.CoCreateInstance(CLSID_SpGramCompBackend);
    cpBackend->InitFromBinaryGrammar(pFileData);

    ULONG i;
    SPCFGHEADER Header;
    SpConvertCFGHeader(pFileData, &Header);
    SPCFGSERIALIZEDHEADER *pFH = (SPCFGSERIALIZEDHEADER *)pFileData;

    //
    //  Raw dump here...
    //
    WCHAR guidstr[MAX_PATH];
    wprintf(L"HEADER:\n");
    ::StringFromGUID2(Header.FormatId, guidstr, MAX_PATH);
    wprintf(L"ForamtId      = %s\n", guidstr);
    ::StringFromGUID2(Header.GrammarGUID, guidstr, MAX_PATH);
    wprintf(L"GrammarGUID   = %s\n", guidstr);
    wprintf(L"LangID        = %d\n", Header.LangID);
    wprintf(L"Largest State = %d\n", Header.cArcsInLargestState);
    wprintf(L"cchWords      = %d\n",Header.cchWords);
    wprintf(L"cchSymbols    = %d\n", Header.cchSymbols);
    wprintf(L"cRules        = %d\n", Header.cRules);
    wprintf(L"cArcs         = %d\n", Header.cArcs );
    wprintf(L"cSemanticTags = %d\n", Header.cSemanticTags);
    wprintf(L"cResources    = %d\n", Header.cResources);
    wprintf(L"Words         = 0x%.8x\n", pFH->pszWords);
    wprintf(L"Symbols       = 0x%.8x\n", pFH->pszSymbols);
    wprintf(L"Rules         = 0x%.8x\n", pFH->pRules);
    wprintf(L"Arcs          = 0x%.8x\n", pFH->pArcs);
    wprintf(L"SemanticTags  = 0x%.8x\n", pFH->pSemanticTags);
    wprintf(L"Resources     = 0x%.8x\n", pFH->pResources);

    if (Header.cchWords < 1)
    {
        wprintf(L"\n\tERROR: Grammar contains no words!\n");
    }

    wprintf(L"\nWORDS:\n");
    i = 1;
    while (i < Header.cchWords)
    {
        wprintf(L"0x%.8x -->%s<--\n", i, Header.pszWords + i);
        i = i + wcslen(Header.pszWords + i) + 1;
    }

    wprintf(L"\nSYMBOLS:\n");
    i = 1;
    while (i < Header.cchSymbols)
    {
        wprintf(L"0x%.8x - %s\n", i, Header.pszSymbols + i);
        i = i + wcslen(Header.pszSymbols + i) + 1;
    }

    wprintf(L"\nSEMANTIC TAGS:\n");
    SPCFGSEMANTICTAG *pTag = Header.pSemanticTags;
    for(i=0;i < Header.cSemanticTags; i++)
    {
        CComVariant cvVar;
        HRESULT hr = AssignSemanticValue(pTag, &cvVar);
        if (SUCCEEDED(hr))
        {
            hr = cvVar.ChangeType(VT_BSTR);
        }
        wprintf(L"0x%.8x - [0x%.8x (%1d) - 0x%.8x (%1d)] Name (%d): %s  Value (%d): \"%s\" %s\n", 
             pTag->ArcIndex, pTag->StartArcIndex, pTag->fStartParallelEpsilonArc, pTag->EndArcIndex, pTag->fEndParallelEpsilonArc, 
             pTag->PropId,(pTag->PropNameSymbolOffset) ? &Header.pszSymbols[pTag->PropNameSymbolOffset] : L" N/A ",
             pTag->PropValueSymbolOffset, (pTag->PropValueSymbolOffset) ? &Header.pszSymbols[pTag->PropValueSymbolOffset] : L"",
             cvVar.bstrVal);
        pTag++;
    }

    BYTE * aFlags = new BYTE[Header.cArcs];
    if (aFlags == NULL)
    {
        wprintf(L"Internal tool error -- Out of memory");
        return;
    }
    memset(aFlags, 0, Header.cArcs);
    wprintf(L"\nRULE-INDEX       ID       TOP  ACT  PROP IMP  EXP  RES  DYN   FIRST-ARC    NAME-INDEX   NAME\n");
    SPCFGRULE * pRule = Header.pRules;
    for (i = 0; i < Header.cRules; i++, pRule++)
    {
        wprintf(L"0x%.8x   0x%.8x    %1.d    %1.d    %1.d    %1.d    %1.d    %1.d    %1.d    0x%.8x   0x%.8x   \"%s\"\n",
                i, pRule->RuleId, pRule->fTopLevel, pRule->fDefaultActive, pRule->fPropRule, pRule->fImport, pRule->fExport, pRule->fHasResources, pRule->fDynamic, 
                pRule->FirstArcIndex, pRule->NameSymbolOffset, _SYMBOL(pRule->NameSymbolOffset));
        aFlags[pRule->FirstArcIndex] = 1;
    }
    SPCFGARC * pArc = Header.pArcs;
    for (i = 0; i < Header.cArcs; i++, pArc++)
    {
        if (pArc->fRuleRef)
        {
            aFlags[pArc->TransitionIndex] |= 2;
        }
    }

    wprintf(L"\nNON-TOP-LEVEL RULES\n");
    for (i = 1; i < Header.cArcs; i++)
    {
        if (aFlags[i] == 2)
        {
            wprintf(L"0x%.8x\n", i);
        }
    }


    wprintf(L"\nARC-INDEX  WEIGHT RULE  LAST  SEM-TAG   TRANS-IDX    NEXT-ARC CONF TRANSITION NAME\n");
    pArc = Header.pArcs;
    for (i = 0; i < Header.cArcs; i++, pArc++)
    {
        wprintf(L"0x%.8x  %4.4f    %1.d   %1.d     %1.d       0x%.8x   0x%.8x  %2s   ", 
            i, (Header.pWeights) ? Header.pWeights[i] : 1.0f, pArc->fRuleRef, pArc->fLastArc, pArc->fHasSemanticTag, pArc->TransitionIndex, 
            pArc->NextStartArcIndex, pArc->fLowConfRequired ? L"-1" : pArc->fHighConfRequired ? L"+1" : L"  ");
        if (pArc->TransitionIndex == SPTEXTBUFFERTRANSITION)
        {
            wprintf(L"[TEXTBUFFER]\n");
        }
        else if (pArc->TransitionIndex == SPWILDCARDTRANSITION)
        {
            wprintf(L"[WILDCARD]\n");
        }
        else if (pArc->TransitionIndex == SPDICTATIONTRANSITION)
        {
            wprintf(L"[DICTATION]\n");
        }
        else if (pArc->fRuleRef)
        {
            SPCFGRULE * pRule = Header.pRules + pArc->TransitionIndex;
            if (pRule->fImport)
            {
                wprintf(L"(%s)\n", _SYMBOL(pRule->NameSymbolOffset));
            }
            else
            {
                if (pRule->NameSymbolOffset)
                {
                    wprintf(L"<%s>\n", _SYMBOL(pRule->NameSymbolOffset));
                }
                else
                {
                    wprintf(L"<0x%.8x>\n", pArc->TransitionIndex);
                }
            }
        }
        else
        {
            wprintf(L"%s\n", Word(pArc->TransitionIndex, Header));
        }
    }

    //
    //  Resources
    //
    if (Header.cResources)
    {
        wprintf(L"\nRES-INDEX     RULE-INDEX    NAME = VAL\n");
        SPCFGRESOURCE * pRes = Header.pResources;
        for (i = 0; i < Header.cResources; i++, pRes++)
        {
            wprintf(L"0x%.8x    0x%.8x    %s = %s\n", i, pRes->RuleIndex,
                    _SYMBOL(pRes->ResourceNameSymbolOffset), 
                    _SYMBOL(pRes->ResourceValueSymbolOffset));
        }
    }
    else
    {
        wprintf(L"\nNO RESOURCES IN THIS GRAMMAR\n");
    }


    //
    //  Now a formatted dump
    //

    pRule = Header.pRules;
    for (i = 0; i < Header.cRules; i++, pRule++)
    {
        if (!pRule->fImport)
        {
            if (pRule->NameSymbolOffset)
            {
                wprintf(L"\nRule %d - %s\n", i, _SYMBOL(pRule->NameSymbolOffset));
            }
            else
            {
                wprintf(L"\nRule %d - <NO NAME> (ID=%d)\n", i, pRule->RuleId);
            }
        }
        else
        {
            wprintf(L"\nRule <0x%.8x> %s\n", pRule->FirstArcIndex);
        }
        long Path[100];
        _RecurseDump(Header, pRule->FirstArcIndex, aFlags, Path, 0);
    }

    delete[] aFlags;
}


//
// Compile an XML file, and dump it.
//
void LoadCompileDumpXML(char * pszFilename)
{
	HRESULT hr =  S_OK;

    CComPtr<ISpStream> cpSrcStream;
    CComPtr<IStream> cpDestMemStream;
    CComPtr<ISpGrammarCompiler> cpCompiler;


    hr = SPBindToFile(pszFilename, SPFM_OPEN_READONLY, &cpSrcStream);
	if( FAILED(hr) )
	{
        wprintf(L"\n\tERROR: could not open parse %S\n", pszFilename );
		wprintf(L"\tERROR: try using the complete name.  i.e. C:\\blah\\%S\n\n", pszFilename );
		return;
	}

    if (SUCCEEDED(hr))
    {
        hr = ::CreateStreamOnHGlobal(NULL, TRUE, &cpDestMemStream);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpCompiler.CoCreateInstance(CLSID_SpGrammarCompiler);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpCompiler->CompileStream(cpSrcStream, cpDestMemStream, NULL, NULL, NULL, 0);
		if(FAILED(hr))
		{
			wprintf(L"\n\tERROR: Compile of %S failed.\n", pszFilename );
			return;
		}
    }
	if (SUCCEEDED(hr))
    {
        HGLOBAL hGlobal;
        hr = ::GetHGlobalFromStream(cpDestMemStream, &hGlobal);
        if (SUCCEEDED(hr))
        {
            SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )GlobalLock(hGlobal);

            DumpContents((SPCFGSERIALIZEDHEADER *)pBinaryData);

            GlobalUnlock(hGlobal);
        }
    }
	if(FAILED(hr))
	{
		wprintf(L"\n\tERROR: Could not dump %S.\n", pszFilename );
		return;
	}
}

//
// Load a CFG file and dump it.
//
void LoadDumpCFG(char * pszFilename)
{
    HANDLE hFile = ::CreateFile(pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        HANDLE hMapFile;
        hMapFile = ::CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (hMapFile)
        {
            LPVOID lpMapAddress;
            lpMapAddress = ::MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
            if (lpMapAddress)
            {
                DumpContents((SPCFGSERIALIZEDHEADER *)lpMapAddress);
                ::UnmapViewOfFile(lpMapAddress);
            }
            ::CloseHandle(hMapFile);
        }
        ::CloseHandle(hFile);
    }
    else
    {
        wprintf(L"\n\tERROR: could not open %S\n\n", pszFilename );
    }
}


int main(int argc, char* argv[])
{
    USES_CONVERSION;
    ::CoInitialize(NULL);
    if (argc != 2)
    {
        wprintf(L"\n\tusage: %s <binary cfg file>\n\n", T2W(argv[0]));
        return 0;
    }

	//
	// Determine the file extension, or add .cfg
	//
    char * pszFilename = (char*)calloc( strlen(argv[1]) + 5,sizeof(char));
	strcat( pszFilename, argv[1] );


	if (stricmp(&pszFilename[strlen(pszFilename)-4],".xml") != 0 )
	{
		if (strcmp(&pszFilename[strlen(pszFilename)-4],".cfg"))
		{
			strcat(pszFilename,".cfg");
		}
	}

	//
	// Try and parse the file.
	//
	if (stricmp(&pszFilename[strlen(pszFilename)-4],".xml")==0)
	{
		LoadCompileDumpXML(pszFilename);
	}
	else
	{
		LoadDumpCFG(pszFilename);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\cfgdump\makefile.inc ===
copyexe :
	copy /Y $(O)\GC.exe ..\bin\GC.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\cfgdump\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	cfgdump.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\cfgdump\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__876C331C_D1C9_11D2_A086_00C04F8EF9B5__INCLUDED_)
#define AFX_STDAFX_H__876C331C_D1C9_11D2_A086_00C04F8EF9B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		    // Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN


#include "windows.h"
#include "tchar.h"
#include "sapi.h"
#include "atlbase.h"
#include "spddkhlp.h"

#ifndef __CFGDUMP_
#define __CFGDUMP_

extern CComModule _Module;

#include "sapiint.h"
#include "spinthlp.h"
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__876C331C_D1C9_11D2_A086_00C04F8EF9B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__876C331C_D1C9_11D2_A086_00C04F8EF9B5__INCLUDED_)
#define AFX_STDAFX_H__876C331C_D1C9_11D2_A086_00C04F8EF9B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		    // Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include "windows.h"
#include "tchar.h"
#include "sapi.h"
#include "atlbase.h"
#include "spddkhlp.h"
#include "StreamHlp.h"

#ifndef __GC_
#define __GC_
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__876C331C_D1C9_11D2_A086_00C04F8EF9B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	cfgdump.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gc\gc.cpp ===
// gc.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "AssertWithStack.cpp"

CSpUnicodeSupport   g_Unicode;

class CError : public ISpErrorLog
{
public:
    CError(const WCHAR * pszFileName)
    {
        m_pszFileName = pszFileName;
    }
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(IUnknown) ||
            riid == __uuidof(ISpErrorLog))
        {
            *ppv = (ISpErrorLog *)this;
            return S_OK;
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return 2;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }
    // -- ISpErrorLog
    STDMETHODIMP AddError(const long lLine, HRESULT hr, const WCHAR * pszDescription, const WCHAR * pszHelpFile, DWORD dwHelpContext);

    // --- data members
    const WCHAR * m_pszFileName;
};

HRESULT CError::AddError(const long lLine, HRESULT hr, const WCHAR * pszDescription, const WCHAR * pszHelpFile, DWORD dwHelpContext)
{
    SPDBG_FUNC("CError::AddError");
    USES_CONVERSION;
    if (lLine > 0)
    {
        fprintf(stderr, "%s(%d) : %s\n", W2T(m_pszFileName), lLine, W2T(pszDescription));
    }
    else
    {
        fprintf(stderr, "%s(1) : %s\n", W2T(m_pszFileName), W2T(pszDescription));
    }
    return S_OK;
}

HRESULT ParseCommandLine(
    int argc, 
    char * argv[], 
    WCHAR ** pszInFileName,
    WCHAR ** pszOutFileName,
    WCHAR ** pszHeaderFileName)
{
    SPDBG_FUNC("ParseCommandLine");
    HRESULT hr = S_OK;
    
    // Our job is to come up with the three filenames from the command
    // line arguments. We'll store them locally in cotask strings, 
    // and return them at the end
    CSpDynamicString dstrInFileName;
    CSpDynamicString dstrOutFileName;
    CSpDynamicString dstrHeaderFileName;
    
    for (int i = 1; SUCCEEDED(hr) && i < argc; i++)
    {
        // If this param looks like it's an option
        if ((argv[i][0] == L'-') || (argv[i][0] == L'/'))
        {
            if (stricmp(&argv[i][1], "?") == 0)
            {
                // The invoker is asking for help, give it to them as if they specified an
                // invalid argument
                hr = E_INVALIDARG;
            }
            else if (i + 1 >= argc)
            {
                // The following arguments require an additional argument themsevles
                // so if we don't have one, we're done
                hr = E_INVALIDARG;
            }
            else if (stricmp(&argv[i][1], "o") == 0)
            {
                // Set the output filename if it hasn't already been set
                if (dstrOutFileName.Length() != 0)
                {
                    hr = E_INVALIDARG;
                }
                    
                dstrOutFileName = argv[++i];
            }
            else if (stricmp(&argv[i][1], "h") == 0)
            {
                // Set the header filename if it hasn't already been set
                if (dstrHeaderFileName.Length() != 0)
                {
                    hr = E_INVALIDARG;
                }
                
                dstrHeaderFileName = argv[++i];
            }
            else
            {
                // Unknown option, we'll need to display usage
                hr = E_INVALIDARG;
            }
        }
        else
        {
            // Set the filename if it hasn't already been set
            if (dstrInFileName.Length() != 0)
            {
                hr = E_INVALIDARG;
            }
            
            dstrInFileName = argv[i];
        }
    }

    // If we don't have an input file name, that's an error at this point
    if (SUCCEEDED(hr) && dstrInFileName.Length() == 0)
    {
        hr = E_INVALIDARG;
    }

    // If we don't already have an output file name, make one up
    // based on the input file name (replacing the .cfg if it's there)
    if (SUCCEEDED(hr) && dstrOutFileName.Length() == 0)
    {
        dstrOutFileName = dstrInFileName;
        
        if (dstrOutFileName.Length() >= 4 &&
            wcsicmp(((const WCHAR *)dstrOutFileName) + dstrOutFileName.Length() - 4, L".xml") == 0)
        {
            wcscpy(((WCHAR *)dstrOutFileName) + dstrOutFileName.Length() - 4, L".cfg");
        }
        else
        {
            dstrOutFileName.Append(L".cfg");
        }
    }

    // If we failed above, we need to display usage
    if (FAILED(hr))
    {
        fprintf(stderr, "%s [/o cfg_filename] [/h header_filename] input_filename\n", argv[0]);
    }
    else
    {
        // Pass back our filenames based on what we saw on the command line
        *pszInFileName = dstrInFileName.Detach();
        *pszOutFileName = dstrOutFileName.Detach();
        *pszHeaderFileName = dstrHeaderFileName.Detach();
    }
    
    return hr;
}

HRESULT OpenFile(
        const WCHAR * pszFileName, 
        DWORD dwDesiredAccess, 
        DWORD dwCreationDisposition, 
        const WCHAR * pszNewExtension, 
        CSpFileStream ** ppFileStream)
{
    SPDBG_FUNC("OpenFile");
    HRESULT hr = S_OK;
    
    // Try to open the file
    HANDLE hFile = g_Unicode.CreateFile(pszFileName, dwDesiredAccess, 0, NULL, dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        // If that failed, try again appending the extension first
        if (pszNewExtension != NULL)
        {
            CSpDynamicString dstrFileNameWithExt;
            dstrFileNameWithExt.Append2(pszFileName, pszNewExtension);
            
            hFile = g_Unicode.CreateFile(dstrFileNameWithExt, dwDesiredAccess, 0, NULL, dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, NULL);
        }
    }
    
    // If we couldn't open the file, record the error
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = SpHrFromLastWin32Error();
    }
    
    // Create a new filestream object for that file
    CSpFileStream * pFileStream;
    if (SUCCEEDED(hr))
    {
        *ppFileStream = new CSpFileStream(hFile);
        if (*ppFileStream == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    // If we failed
    if (FAILED(hr))
    {
        // First we should let the invoker know that it failed
        USES_CONVERSION;
        fprintf(stderr, "Error: Error opening %s\n", W2T(pszFileName));
        
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
        }
    }
    
    return hr;
}

HRESULT Compile(const WCHAR * pszInFileName, const WCHAR * pszOutFileName, const WCHAR * pszHeaderFileName)
{
    SPDBG_FUNC("Compile");
    HRESULT hr;
    
    CComPtr<ISpGrammarCompiler> cpCompiler;
    hr = cpCompiler.CoCreateInstance(CLSID_SpGrammarCompiler);
    
    CComPtr<CSpFileStream> cpInStream;
    if (SUCCEEDED(hr))
    {
        hr = OpenFile(pszInFileName, GENERIC_READ, OPEN_EXISTING, L".xml", &cpInStream);
    }
    
    CComPtr<CSpFileStream> cpOutStream;
    if (SUCCEEDED(hr))
    {
        hr = OpenFile(pszOutFileName, GENERIC_WRITE, CREATE_ALWAYS, NULL, &cpOutStream);
    }
    
    CComPtr<CSpFileStream> cpHeaderStream;
    if (SUCCEEDED(hr) && pszHeaderFileName != NULL)
    {
        hr = OpenFile(pszHeaderFileName, GENERIC_WRITE, CREATE_ALWAYS, NULL, &cpHeaderStream);
    }
        
    if (SUCCEEDED(hr))
    {
        CError errorlog(pszInFileName);
        hr = cpCompiler->CompileStream(cpInStream, cpOutStream, cpHeaderStream, NULL, &errorlog, 0);
    }
    
    return hr;
}

HRESULT Execute(int argc, char * argv[])
{
    SPDBG_FUNC("Execute");
    HRESULT hr = S_OK;
    
    CSpDynamicString dstrInFileName, dstrOutFileName, dstrHeaderFileName;
    hr = ParseCommandLine(argc, argv, &dstrInFileName, &dstrOutFileName, &dstrHeaderFileName);
    
    if (SUCCEEDED(hr))
    {
        hr = Compile(dstrInFileName, dstrOutFileName, dstrHeaderFileName);
    }

    if (SUCCEEDED(hr))
    {
        fprintf(stderr, "Compilation successful!\n");
    }

    return hr;
}

int main(int argc, char* argv[])
{
    SPDBG_FUNC("main");
    HRESULT hr;
    hr = CoInitialize(NULL);
    
    if (SUCCEEDED(hr))
    {
        hr = Execute(argc, argv);
        CoUninitialize();
    }
    
    return FAILED(hr) ? -1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gc\makefile.inc ===
copyexe :
	copy /Y $(O)\GC.exe ..\bin\GC.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\tom_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Apr 20 10:28:51 1999
 */
/* Compiler settings for tom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_tom = {0x8CC497C9,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextDocument = {0x8CC497C0,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextRange = {0x8CC497C2,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextSelection = {0x8CC497C1,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextFont = {0x8CC497C3,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextPara = {0x8CC497C4,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextStoryRanges = {0x8CC497C5,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextDocument2 = {0x01c25500,0x4268,0x11d1,{0x88,0x3a,0x3c,0x8b,0x00,0xc1,0x00,0x00}};


const IID IID_ITextMsgFilter = {0xa3787420,0x4267,0x11d1,{0x88,0x3a,0x3c,0x8b,0x00,0xc1,0x00,0x00}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	GramComp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\makefile.inc ===
copyexe :
	copy /Y $(O)\GramComp.exe ..\bin\GramComp.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GramComp.rc
//
#define IDC_MYICON                      5
#define IDC_RICHEDITWND                 100
#define IDC_COMPILEOUTPUTWND            101
#define IDD_FIND                        101
#define IDD_GRAMCOMP_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDI_GRAMCOMP                    107
#define IDI_SMALL                       108
#define IDC_GRAMCOMP                    109
#define IDS_CANTOPENSOURCE              110
#define IDS_CANTOPENDEST                111
#define IDS_COMPILESUCCESS              112
#define IDS_COMPFILE                    113
#define IDS_COMPILEFAILURE              114
#define IDR_MAINFRAME                   128
#define IDD_DIALOG_COMPILE              129
#define IDD_TESTGRAMMAR                 130
#define IDR_GRAMACCEL                   131
#define IDD_DIALOG1                     133
#define IDD_GOTO                        134
#define IDC_LIST_STATUS                 1000
#define IDC_STATUS                      1001
#define IDE_FINDTEXT                    1002
#define IDB_FINDNEXT                    1003
#define IDB_CANCEL                      1004
#define IDB_UP                          1005
#define IDB_DOWN                        1006
#define IDB_MATCHCASE                   1007
#define IDC_LIST_PHRASES                1008
#define IDC_BEGINRECO                   1010
#define IDB_MUTE                        1011
#define IDC_GRAMMAR_STATUS              1012
#define IDB_OK                          1013
#define IDE_LINE                        1014
#define IDC_EDIT_PARSETEXT              1015
#define IDC_BUTTON_SUBMIT               1016
#define IDC_EDIT1                       1017
#define ID_FILE_NEW                     32771
#define IDM_FILE_NEW                    32771
#define ID_FILE_SAVE                    32772
#define IDM_FILE_SAVE                   32772
#define IDM_FILE_OPEN                   32773
#define ID_FILE_SAVEAS                  32774
#define IDM_FILE_SAVEAS                 32774
#define IDM_BUILD_COMPILE               32775
#define IDM_BUILD_SILENT                32778
#define IDM_EDIT_UNDO                   32779
#define IDM_EDIT_REDO                   32780
#define IDM_EDIT_COPY                   32782
#define IDM_EDIT_CUT                    32783
#define IDM_EDIT_PASTE                  32784
#define IDM_EDIT_DELETE                 32785
#define IDM_EDIT_SELECTALL              32786
#define IDM_EDIT_FIND                   32787
#define IDM_TESTGRAMMAR                 32788
#define IDM_EDIT_GOTO                   32789
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32791
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\comp.cpp ===
#include "stdafx.h"
#include <stdio.h>
#include "comp.h"
#include "StreamHlp.h"

//#define INPROC

/****************************************************************************
* CCompiler::~CCompiler *
*---------------------------*
*   Description:
*       Releases objects created by CCompiler
**************************************************************** Leonro *****/
CCompiler::~CCompiler()
{
    m_cpRichEdit.Release();   
    m_cpTextDoc.Release();    
    m_cpTextSel.Release();    
    m_cpRecognizer.Release();
    m_cpRecoContext.Release(); 
    m_cpCompiler.Release();
    m_cpRecoGrammar.Release();
    
    if( m_hMod )
    {
        FreeLibrary( m_hMod );
    }
}

/****************************************************************************
* CCompiler::Initialize *
*---------------------------*
*   Description:
*       Set up the windows, as well as the RichEdit objects.
*       Also it initializes some SAPI objects.
************************************************************** Leonro *******/ 
HRESULT CCompiler::Initialize( int nCmdShow )
{
    TCHAR           szTitle[MAX_LOADSTRING];                  // The title bar text
    TCHAR           szWindowClass[MAX_LOADSTRING];            // Window class
    HRESULT         hr = S_OK;
    WNDCLASSEX      wcex;
   
    // Initialize global strings
    LoadString( m_hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING );
    LoadString( m_hInstance, IDC_GRAMCOMP, szWindowClass, MAX_LOADSTRING );
    
    // Register the windows class
    wcex.cbSize         = sizeof(WNDCLASSEX); 
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = m_hInstance;
    wcex.hIcon          = LoadIcon(m_hInstance, (LPCTSTR)IDI_GRAMCOMP);
    wcex.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = (LPCSTR)IDC_GRAMCOMP;
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_SMALL);

    // Register window and create the sapi grammar compiler
    if( RegisterClassEx(&wcex) )
    {
        hr = m_cpCompiler.CoCreateInstance( CLSID_SpGrammarCompiler );
        if( FAILED( hr ) )
        {
            MessageBox( NULL, _T("Error initializing speech objects. Shutting down.\n\n"
                "      Please make sure SAPI5 is installed!"), _T("Error"), MB_OK );
        }
    }
    else
    {
        MessageBox( NULL, _T("Error initializing application. Shutting down."), 
                        _T("Error"), MB_OK );
        hr = E_FAIL;
    }
    

    // Load DLL for Rich Edit 3.0
    if( SUCCEEDED( hr ) )
    {
        m_hMod = LoadLibrary( "RICHED20.DLL" );
        if( !m_hMod )
        {
            MessageBox( NULL, "Couldn't find required riched32.dll. Shutting down!", 
                        "Error - Missing dll", MB_OK );
            hr = E_FAIL;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        // Perform application initialization:
        m_hWnd = CreateWindow( szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, m_hInstance, this );

        if( m_hWnd && m_hWndStatus && m_hWndEdit )
        {
            // Get TOM interfaces
            SendMessage( m_hWndEdit, EM_GETOLEINTERFACE, 0, (LPARAM)(LPVOID FAR *)&m_cpRichEdit );
            SendMessage( m_hWndEdit, EM_SETEVENTMASK, 0, ENM_CHANGE | ENM_KEYEVENTS ); 

            if( !m_cpRichEdit )
            {
                hr = E_NOINTERFACE;
            }

            if( SUCCEEDED( hr ) )
            {
                hr = m_cpRichEdit->QueryInterface( IID_ITextDocument, (void**)&m_cpTextDoc );
                if( SUCCEEDED( hr ) )
                {
                    hr = m_cpTextDoc->GetSelection( &m_cpTextSel );  
                }
            }
         
            if( SUCCEEDED( hr ) )
            {
                // Load Accelerators
                m_hAccelTable = LoadAccelerators( m_hInstance, MAKEINTRESOURCE(IDR_GRAMACCEL) );

                ::ShowWindow( m_hWnd, nCmdShow );
                ::UpdateWindow( m_hWnd ); 
            }
            else
            {
                MessageBox( m_hWnd, _T("Error initializing edit control. Shutting down!"), _T("Error"), MB_OK );                   
            }
        }
    }

    return hr;
}

/****************************************************************************************
* CCompiler::Run() *
*----------------------*
*   Description:
*       Contains the message loop for the application
**************************************************************************** Leonro *****/
int CCompiler::Run()
{
    MSG msg;

    // Main message loop:
    while( ::GetMessage(&msg, NULL, 0, 0) ) 
    {
        if( !::TranslateAccelerator(m_hWnd, m_hAccelTable, &msg) ) 
        {
            ::TranslateMessage( &msg );
            ::DispatchMessage( &msg );
        }
    }

    return msg.wParam; 
}   /* CCompiler::Run */

/****************************************************************************
* CCompiler::WndProc *
*---------------------------*
*   Description:
*       Processes messages for the main window.
***************************************************************** Leonro ****/
LRESULT CALLBACK CCompiler::WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    int             wmId, wmEvent;
    static BOOL     bFileOpened = FALSE;
    PAINTSTRUCT     psMain, psStatus;
    HDC             hMainDC=0, hStatusDC=0;
    long            lSaved = 0;
    HRESULT         hr = S_OK;
    static TCHAR    szTitle[NORM_SIZE] = _T("");
    TCHAR           szFileName[NORM_SIZE] = _T("");
    static TCHAR    szSaveFileName[NORM_SIZE] = _T("");
    HMENU           hMenu=0;
    static int      iNumUndos=0;
    long            lStart, lEnd;

    CCompiler*      pThis = (CCompiler *)GetWindowLong(hWnd, GWL_USERDATA);

    // get the handle to the menu
    hMenu = GetMenu( hWnd );
    
    switch (message) 
    {
    case WM_SETFOCUS:
        SetFocus (pThis->m_hWndEdit);
        break;

    case WM_CREATE:
        pThis = (CCompiler *)(((CREATESTRUCT *) lParam)->lpCreateParams);
        SetWindowLong(hWnd, GWL_USERDATA, (LPARAM)pThis);
        pThis->m_hWnd = hWnd;
        
        // Create the compile status window
        pThis->m_hWndStatus = CreateWindowEx (
                WS_EX_CLIENTEDGE,
                _T("LISTBOX"),
                NULL,
                WS_CHILD | WS_VISIBLE | LBS_NOINTEGRALHEIGHT | LBS_NOSEL | WS_VSCROLL | 
                WS_HSCROLL,
                1, 1, 1, 1,
                hWnd,
                NULL,
                pThis->m_hInstance,
                NULL);
        // Create the actual rich edit window
        pThis->m_hWndEdit = CreateWindowEx( 
                WS_EX_CLIENTEDGE, 
                RICHEDIT_CLASS,
                NULL, 
                WS_CHILD | WS_VISIBLE | WS_BORDER | ES_MULTILINE |
                    WS_VSCROLL | ES_AUTOVSCROLL | ES_NOHIDESEL | ES_WANTRETURN,
                1, 1, 1, 1,
                hWnd, 
                (HMENU)IDC_RICHEDITWND, 
                pThis->m_hInstance,  
                NULL );        
        break;

    case WM_ERASEBKGND:
        return TRUE;

    case WM_SIZE:
    {
        // move the editor and compiler window
        LONG lListBoxHeight = (HIWORD(lParam) / 4);
        LONG lCodeHeight = HIWORD(lParam) - lListBoxHeight;
        MoveWindow (pThis->m_hWndEdit, 0, 0,
            LOWORD(lParam), lCodeHeight , FALSE);
        MoveWindow (pThis->m_hWndStatus, 0, lCodeHeight,
            LOWORD(lParam), lListBoxHeight, FALSE);
        // repaint
        InvalidateRect( hWnd, NULL, FALSE );
    }
    break;

    case WM_COMMAND:
        wmId    = LOWORD(wParam); 
        wmEvent = HIWORD(wParam); 

        // Update available menu items
        pThis->m_cpTextSel->GetStart( &lStart );
        pThis->m_cpTextSel->GetStoryLength( &lEnd );
        if( lEnd-lStart > 1 )
        {
            EnableMenuItem( hMenu, IDM_EDIT_CUT, MF_ENABLED );
            EnableMenuItem( hMenu, IDM_EDIT_COPY, MF_ENABLED );
        }
        else
        {
            EnableMenuItem( hMenu, IDM_EDIT_CUT, MF_GRAYED );
            EnableMenuItem( hMenu, IDM_EDIT_COPY, MF_GRAYED );
        }

        // Parse the menu selections:
        switch( wmId )
        {
            case IDM_FILE_NEW:
                // Check if the file has been changed and save if necessary
                hr = pThis->m_cpTextDoc->GetSaved( &lSaved );
                if( lSaved == tomFalse && SUCCEEDED( hr ) )
                {
                    int iRetVal = MessageBox( pThis->m_hWndEdit, _T("Do you want to save your changes?"),
                                            _T("Grammar Compiler"), MB_YESNO );
                    if( iRetVal == IDYES )
                    {
                        BOOL    bRetVal = TRUE;

                        // No need to call save file dialog if there's already a file name
                        if( !_tcscmp( szSaveFileName, "" ) )
                        {
                            bRetVal = pThis->CallSaveFileDialog( hWnd, szSaveFileName );
                        }

                        // TOM save file
                        if( bRetVal )
                        {
                            // TOM save file
                            pThis->FileSave( hWnd, pThis, szSaveFileName );
                        }
                    }
                    else
                    {
                        pThis->m_cpTextDoc->SetSaved( tomTrue );
                    }
                }
                
                // call TOM new
                pThis->m_cpTextDoc->New();
                pThis->m_cpTextDoc->SetSaved( tomTrue );

                // Add the file name to the title bar
                LoadString( pThis->m_hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING );
                _tcscat( szTitle, _T(" - []") );
                SetWindowText( hWnd, szTitle );

                // reset defaults
                ::SendMessage( pThis->m_hWndStatus, LB_RESETCONTENT, 0, 0 );
                ::SendMessage( pThis->m_hWndStatus, LB_SETHORIZONTALEXTENT, 0, 0 );
                pThis->m_szCFGDestFile[0]    = 0;
                pThis->m_szHeaderDestFile[0] = 0;
                pThis->m_szXMLSrcFile[0]     = 0;
                pThis->m_fNeedStartCompile   = TRUE;
                pThis->m_hrWorstError        = 0;
                _tcscpy( szSaveFileName, _T("") );
                InvalidateRect( hWnd, NULL, FALSE );
                break;

            case IDM_FILE_OPEN:
                // Save old file first if one exists and it has not been saved
                hr = pThis->m_cpTextDoc->GetSaved( &lSaved );
                if( lSaved == tomFalse && SUCCEEDED( hr ) )
                {
                    int iRetVal = MessageBox( pThis->m_hWndEdit, _T("Do you want to save your changes?"),
                                    _T("Grammar Compiler"), MB_YESNO );
                    if( iRetVal == IDYES )
                    {
                        // reset errors
                        pThis->m_hrWorstError = 0;

                        // TOM save file
                        hr = pThis->FileSave( hWnd, pThis, szSaveFileName );                    
                        if( hr == STG_E_ACCESSDENIED ) // Handle read only files
                        {
                            MessageBox( pThis->m_hWndEdit, _T("This file exists with Read Only attributes.\n Please use a different file name."),
                                            _T("File Save"), MB_OK );
                            // Call FileSave again but this time pop the save file dialog box
                            pThis->FileSave( hWnd, pThis, szSaveFileName );
                        }
                    }
                    else
                    {
                        pThis->m_cpTextDoc->SetSaved( tomTrue );
                    }
                }

                bFileOpened = pThis->CallOpenFileDialog( hWnd, szFileName,
                    _T("XML (*.xml)\0*.xml\0TXT (*.txt)\0*.txt\0All Files (*.*)\0*.*\0") );
                
                // Copy the open file name to the Save file name for use later
                _tcscpy( szSaveFileName, szFileName );
                if( bFileOpened )
                {
                    HRESULT     hr = S_OK;
                    VARIANT     Var;
                    USES_CONVERSION;

                    // reset text in windows
                    _tcscpy(pThis->m_szXMLSrcFile, szFileName);
                    ::SendMessage( pThis->m_hWndStatus, LB_RESETCONTENT, 0, 0 );
                    ::SendMessage( pThis->m_hWndStatus, LB_SETHORIZONTALEXTENT, 0, 0 );

                    InvalidateRect( hWnd, NULL, FALSE );

                    // Open the file in the rich edit control
                    VariantInit( &Var );
                    Var.vt = VT_BSTR;
                    Var.bstrVal = SysAllocString( T2W(szFileName) ); // Will use Win32 file command
                    hr = pThis->m_cpTextDoc->Open( &Var, tomOpenExisting, 0 ); 
                    hr &= ~0x40000; // Mask off bit 18
                    if( hr == STG_E_ACCESSDENIED ) // Handle read only files
                    {
                        pThis->m_cpTextDoc->Open( &Var, tomReadOnly | tomOpenExisting, 0 );
                    }
                    SysFreeString( Var.bstrVal );
                    
                    // reset defaults
                    pThis->m_szCFGDestFile[0]    = 0;
                    pThis->m_szHeaderDestFile[0] = 0;
                    pThis->m_fNeedStartCompile   = TRUE;
                    pThis->m_hrWorstError        = 0;
                    
                    // no changes to the file yet so set SetSaved to true
                    pThis->m_cpTextDoc->SetSaved( tomTrue );

                    // Add the file name to the title bar
                    LoadString( pThis->m_hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING );
                    _tcscat( szTitle, _T(" - [") );
                    _tcscat( szTitle, szFileName );
                    _tcscat( szTitle, _T("]") );
                    SetWindowText( hWnd, szTitle );
                }
                break;

            case IDM_FILE_SAVEAS:
                // Remove old save file name if one exists
                _tcscpy( szSaveFileName, _T("") );
                // no break here

            case IDM_FILE_SAVE:
                // TOM save file
                hr = pThis->FileSave( hWnd, pThis, szSaveFileName );                    
                if( hr == STG_E_ACCESSDENIED ) // Handle read only files
                {
                    MessageBox( pThis->m_hWndEdit, _T("This file exists with Read Only attributes.\n Please use a different file name."),
                                    _T("File Save"), MB_OK );
                    // Call FileSave again but this time pop the save file dialog box
                    hr = pThis->FileSave( hWnd, pThis, szSaveFileName );
                }

                // Add the file name to the title bar
                if( SUCCEEDED( hr ) )
                {
                    LoadString( pThis->m_hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING );
                    _tcscat( szTitle, _T(" - [") );
                    _tcscat( szTitle, szSaveFileName );
                    _tcscat( szTitle, _T("]") );
                    SetWindowText( hWnd, szTitle );
                }
                break;

            case IDM_BUILD_COMPILE:
                if( pThis->m_fNeedStartCompile )
                {
                    pThis->Compile( hWnd, szSaveFileName, szTitle, pThis );
                }
                break;

            case IDC_RICHEDITWND:
                // When user changes contents of edit control update status bar on top
                if( wmEvent == EN_CHANGE )
                {
                    TCHAR    szTitleNotSaved[NORM_SIZE] = _T("");

                    if( !_tcscmp( szTitle, _T("") ) )
                    {
                        LoadString( pThis->m_hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING );
                        _tcscat( szTitle, _T(" - []") );
                    }

                    _tcscpy( szTitleNotSaved, szTitle );
                    _tcscat( szTitleNotSaved, _T("*") );
                    SetWindowText( hWnd, szTitleNotSaved );

                    pThis->m_fNeedStartCompile = TRUE;

                    //Update edit menu items
                    EnableMenuItem( hMenu, IDM_EDIT_UNDO, MF_ENABLED );
                }
                break;

            case IDM_EDIT_UNDO:
                // Undo
                pThis->m_cpTextDoc->Undo( 1, NULL );
                EnableMenuItem( hMenu, IDM_EDIT_REDO, MF_ENABLED );
                iNumUndos++;
                break;

            case IDM_EDIT_REDO:
                // Redo
                pThis->m_cpTextDoc->Redo( 1, NULL );
                if( --iNumUndos < 1 )
                {
                    EnableMenuItem( hMenu, IDM_EDIT_REDO, MF_GRAYED );
                    iNumUndos = 0;
                }
                break;

            case IDM_EDIT_COPY:
                // Copy
                pThis->m_cpTextSel->Copy( NULL );
                EnableMenuItem( hMenu, IDM_EDIT_PASTE, MF_ENABLED );
                break;

            case IDM_EDIT_CUT:
                // Cut
                pThis->m_cpTextSel->Cut( NULL );
                EnableMenuItem( hMenu, IDM_EDIT_PASTE, MF_ENABLED );
                break;

            case IDM_EDIT_PASTE:
                // Paste
                pThis->m_cpTextSel->Paste( NULL, 0 );
                break;

            case IDM_EDIT_DELETE:
                // Delete
                pThis->m_cpTextSel->Delete( tomCharacter, 1, NULL );
                break;

            case IDM_EDIT_SELECTALL:
                // Select all
                {
                    pThis->m_cpTextSel->GetStart( &lStart );
                    pThis->m_cpTextSel->GetStoryLength( &lEnd );
                    pThis->m_cpTextSel->MoveStart( tomCharacter, -lStart, NULL );
                    pThis->m_cpTextSel->MoveEnd( tomCharacter, lEnd-lStart, NULL );
                }
                break;

            case IDM_EDIT_FIND:
                // Find
                DialogBoxParam( pThis->m_hInstance, (LPCTSTR)IDD_FIND, hWnd, Find, (LPARAM)pThis);
                break;

            case IDM_EDIT_GOTO:
                // Find
                DialogBoxParam( pThis->m_hInstance, (LPCTSTR)IDD_GOTO, hWnd, Goto, (LPARAM)pThis);
                break;

            case IDM_TESTGRAMMAR:
                // Only compile if necessary
                if( pThis->m_fNeedStartCompile )
                {
                    hr = pThis->Compile( hWnd, szSaveFileName, szTitle, pThis );
                }      
                // Create new dialog box
                if( SUCCEEDED( hr ) )
                {
                    DialogBoxParam( pThis->m_hInstance, (LPCTSTR)IDD_TESTGRAMMAR, hWnd, TestGrammar, (LPARAM)pThis);
                }
                else if( hr == E_INVALIDARG )
                {
                    MessageBox( pThis->m_hWndEdit, _T("Please enter text or open an xml file first."), _T("Compile Error"), MB_OK );
                }
                else if( hr == E_FAIL )
                {
                    MessageBox( pThis->m_hWndEdit, _T("Please save file first."), _T("Compile Error"), MB_OK );
                }
                else
                {
                    MessageBox( pThis->m_hWndEdit, _T("Error compiling xml file."),
                                    _T("Compile Error"), MB_OK );
                }
                break;

            case IDM_ABOUT:
                // About box
                DialogBox( pThis->m_hInstance, (LPCTSTR)IDD_ABOUTBOX, hWnd, About );
                break;

            case IDM_EXIT:
                SendMessage( hWnd, WM_CLOSE, 0, 0 );
                break;

            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
        }
        break;

    case WM_CLOSE:
        {
            int iRetVal = 0;
            // Check if the file has been changed and save if necessary
            hr = pThis->m_cpTextDoc->GetSaved( &lSaved );
            if( lSaved == tomFalse && SUCCEEDED( hr ) )
            {
                iRetVal = MessageBox( pThis->m_hWndEdit, _T("Do you want to save your changes?"),
                                        _T("Grammar Compiler"), MB_YESNOCANCEL );
                if( iRetVal == IDYES )
                {
                    // No need to call save file dialog if there's already a file name
                    if( !_tcscmp( szSaveFileName, "" ) )
                    {
                        pThis->CallSaveFileDialog( hWnd, szSaveFileName );
                    }

                    // TOM save file
                    pThis->FileSave( hWnd, pThis, szSaveFileName );
                }
                else
                {
                    pThis->m_cpTextDoc->SetSaved( tomTrue );
                }
            }
        
            if( iRetVal != IDCANCEL )
            {
                DestroyWindow( hWnd );
            }
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc( hWnd, message, wParam, lParam );
    }
    return 0;
}

/****************************************************************************
* CCompiler::About *
*---------------------------*
*   Description:
*       Message handler for About box.
***************************************************************** Leonro ****/ 
INT_PTR CALLBACK CCompiler::About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            break;
    }
    return FALSE;
}

/****************************************************************************
* CCompiler::Find *
*---------------------------*
*   Description:
*       Message handler for Find box.
***************************************************************** Leonro ****/ 
INT_PTR CALLBACK CCompiler::Find(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR       szFindText[NORM_SIZE]=_T("");
    CComBSTR    bStr( _T("Grammar") );
    long        lUpDown = tomForward;
    long        lFlags=0;

    CCompiler*  pThis = (CCompiler *)GetWindowLong( hDlg, GWL_USERDATA );
    
    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLong( hDlg, GWL_USERDATA, lParam );
            SendDlgItemMessage( hDlg, IDB_DOWN, BM_SETCHECK, BST_CHECKED, 0 );
            return TRUE;

        case WM_COMMAND:
            {
                switch( LOWORD( wParam ) )
                {
                case IDB_FINDNEXT:
                    // Get text string
                    GetDlgItemText( hDlg, IDE_FINDTEXT, szFindText, NORM_SIZE );
                    bStr = szFindText;

                    // Search up or down?
                    SendDlgItemMessage( hDlg, IDB_DOWN, BM_GETCHECK, 0, 0 )?
                        lUpDown = tomForward : lUpDown = tomBackward;
                    
                    // Match case?
                    SendDlgItemMessage( hDlg, IDB_MATCHCASE, BM_GETCHECK, 0, 0 )? 
                            lFlags=tomMatchCase : lFlags=0;
                    
                    pThis->m_cpTextSel->FindText( bStr, lUpDown, lFlags, NULL );

                    return TRUE;

                case IDB_CANCEL:
                case IDCANCEL:
                    EndDialog( hDlg, LOWORD(wParam) );
                    return TRUE;
                }
            }
            break;

        case WM_CLOSE:
            EndDialog( hDlg, LOWORD(wParam) );
            return TRUE;
    }
    return FALSE;
}

/****************************************************************************
* CCompiler::Goto *
*---------------------------*
*   Description:
*       Message handler for Goto box.
**************************************************************** Leonro *****/ 
INT_PTR CALLBACK CCompiler::Goto( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    TCHAR       szGotoLine[NORM_SIZE]=_T("");
    TCHAR       szCurrLine[NORM_SIZE]=_T("");
    long        iGotoLine, iCurrLine, iLinesToMove;
    
    CCompiler*  pThis = (CCompiler *)GetWindowLong( hDlg, GWL_USERDATA );
    

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLong( hDlg, GWL_USERDATA, lParam );
            pThis = (CCompiler *)lParam;
            pThis->m_cpTextSel->GetIndex( tomLine, &iCurrLine );
            _itoa( iCurrLine, szCurrLine, 10 );
            SetDlgItemText( hDlg, IDE_LINE, szCurrLine );
            return TRUE;

        case WM_COMMAND:
            {
                switch( LOWORD( wParam ) )
                {
                case IDB_OK:
                    // Get current line
                    pThis->m_cpTextSel->GetIndex( tomLine, &iCurrLine );
                    // Get goto line
                    GetDlgItemText( hDlg, IDE_LINE, szGotoLine, NORM_SIZE );
                    iGotoLine = atoi( szGotoLine );
                    EndDialog( hDlg, LOWORD(wParam) );
                    // Calculate number of lines to move
                    iLinesToMove = iGotoLine - iCurrLine;
                    // Move
                    pThis->m_cpTextSel->MoveDown( tomLine, iLinesToMove, tomMove, NULL );
                    return TRUE;

                case IDB_CANCEL:
                case IDCANCEL:
                    EndDialog( hDlg, LOWORD(wParam) );
                    return TRUE;
                }                
            }
            break;

        case WM_CLOSE:
            EndDialog( hDlg, LOWORD(wParam) );
            return TRUE;
    }
    return FALSE;
}

/****************************************************************************
* CCompiler::TestGrammar *
*---------------------------*
*   Description:
*       Message handler for TestGrammar box.
**************************************************************** Leonro *****/ 
LRESULT CALLBACK CCompiler::TestGrammar(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    CCompiler*  pThis = (CCompiler *)GetWindowLong( hDlg, GWL_USERDATA );

    switch (message)
    {
        case WM_RECOEVENT:
        {
            pThis->RecoEvent( hDlg, pThis );
        }
        return TRUE;

        case WM_INITDIALOG:
            {
                SetWindowLong( hDlg, GWL_USERDATA, lParam );
                pThis = (CCompiler *)lParam;

                // Create the shared sapi reco instance if the app hasn't already done so
                if( !pThis->m_cpRecognizer )
                {
#ifdef INPROC
                    // Create the inproc engine
                    hr = pThis->m_cpRecognizer.CoCreateInstance( CLSID_SpInprocRecognizer );

                    // Create default audio input
                    CComPtr<ISpObjectToken> cpAudioToken;
                    if (SUCCEEDED(hr))
                    {
                        hr = SpGetDefaultTokenFromCategoryId(SPCAT_AUDIOIN, &cpAudioToken);
                    }
                    if (SUCCEEDED(hr))
                    {
                        pThis->m_cpRecognizer->SetInput(cpAudioToken, TRUE);
                    }
#else
                    // Create the shared engine
                    hr = pThis->m_cpRecognizer.CoCreateInstance( CLSID_SpSharedRecognizer );

#endif

                    // Create the Reco context
                    if( SUCCEEDED( hr ) )
                    {
                        hr = pThis->m_cpRecognizer->CreateRecoContext( &pThis->m_cpRecoContext );
                    }
                }                

                // Set up windows messageing for recognition events
                if( SUCCEEDED( hr ) )
                {
                    hr = pThis->m_cpRecoContext->SetNotifyWindowMessage( hDlg, WM_RECOEVENT, 0, 0);
                }
                
                if( SUCCEEDED( hr ) )
                {
                    const ULONGLONG ullInterest = SPFEI(SPEI_SOUND_END) | SPFEI(SPEI_SOUND_START) | SPFEI(SPEI_HYPOTHESIS) |
                                                  SPFEI(SPEI_RECOGNITION) | SPFEI(SPEI_FALSE_RECOGNITION);
                              
                    hr = pThis->m_cpRecoContext->SetInterest( ullInterest, ullInterest );
                }

                // Get locale/font settings
                if( SUCCEEDED( hr ) )
                {
                    LCID lcid = GetUserDefaultLCID();

                    // Pick an appropriate font.  On Windows 2000, let the system fontlink.
                    DWORD dwVersion = GetVersion();

                    if (   dwVersion >= 0x80000000
                        || LOBYTE(LOWORD(dwVersion)) < 5
                        || LANGIDFROMLCID(lcid) != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
                    {
                        TCHAR achCodePage[6];
                        UINT uiCodePage;

                        if( 0 != GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, achCodePage, 6) )
                        {
                            uiCodePage = atoi(achCodePage);
                        }
                        else
                        {
                            uiCodePage = GetACP();
                        }

                        CComPtr<IMultiLanguage> cpMultiLanguage;
                        MIMECPINFO MimeCpInfo;

                        if (   SUCCEEDED(cpMultiLanguage.CoCreateInstance(CLSID_CMultiLanguage))
                            && SUCCEEDED(cpMultiLanguage->GetCodePageInfo(uiCodePage, &MimeCpInfo)))
                        {
                            USES_CONVERSION;

                            HFONT hfont = CreateFont( 0, 0, 0, 0, FW_NORMAL, 0, 0, 0,
                                                 MimeCpInfo.bGDICharset,
                                                 OUT_DEFAULT_PRECIS,
                                                 CLIP_DEFAULT_PRECIS,
                                                 DEFAULT_QUALITY,
                                                 DEFAULT_PITCH,
                                                 W2T(MimeCpInfo.wszProportionalFont ));

                        }
                    }
                }

                // Update status edit box
                if( SUCCEEDED( hr ) )
                {
                    const static TCHAR szPrefixText[] = _T("Current C&&C Grammar: ");
                    TCHAR szDesc[sp_countof(pThis->m_szCFGDestFile) + sp_countof(szPrefixText) + 4];
                    _tcscpy( szDesc, szPrefixText );
                    if( *pThis->m_szCFGDestFile )
                    {
                        _tcscat( szDesc, pThis->m_szCFGDestFile );
                    }
                    else
                    {
                        _tcscat( szDesc, _T("none") );
                    }
                    SendDlgItemMessage( hDlg, IDC_GRAMMAR_STATUS, WM_SETTEXT, 0, (LPARAM)szDesc );
                }

                if( FAILED( hr ) )
                {
                    MessageBox( hDlg, _T("Error initializing Speech Recognizer."),
                                                                _T("Error"), MB_OK );
                    EndDialog( hDlg, LOWORD(wParam) );
                }
            }

            return TRUE;

        case WM_COMMAND:
            {
                switch( LOWORD( wParam ) )
                {
                case IDC_BEGINRECO:
                    // Load the grammar
                    if( SendDlgItemMessage( hDlg, IDC_BEGINRECO, BM_GETCHECK, 0, 0 ) )
                    {
                        // Enable Emulate Recognition feature 
                        EnableWindow( GetDlgItem(hDlg, IDC_EDIT_PARSETEXT), TRUE );
                        
                        TCHAR*  szPath = pThis->m_szCFGDestFile;
                        hr = pThis->LoadGrammar( szPath );
                        if( FAILED( hr ) )
                        {
                            MessageBox( hDlg, _T("Error loading grammar. Make sure")
                                        _T(" a file is loaded, saved, and compiled."),
                                        _T("Error"), MB_OK );
                        }

                        // Activate the grammar
                        if( SUCCEEDED( hr ) )
                        {
                            hr = pThis->m_cpRecoGrammar->SetRuleState(NULL, NULL, SPRS_ACTIVE);
                        }

                        if( FAILED( hr ) )
                        {
                            // Release grammar
                            pThis->m_cpRecoGrammar.Release();
                            MessageBox( NULL, _T("Error loading grammar."), 
                                    _T("Error"), MB_OK );
                            EndDialog( hDlg, LOWORD(wParam) );
                            return FALSE;
                        }
                    }
                    else
                    {
                        // Disable Emulate Recognition
                        EnableWindow( GetDlgItem(hDlg, IDC_EDIT_PARSETEXT), FALSE );

                        // Release grammar
                        pThis->m_cpRecoGrammar.Release();
                    }
                    return TRUE;
                
                case IDB_MUTE:
                    {
                        // Check if the user has selected mute
                        if( SendDlgItemMessage( hDlg, IDB_MUTE, BM_GETCHECK, 0, 0 ) )
                        {
                            pThis->m_cpRecognizer->SetRecoState( SPRST_INACTIVE );
                        }
                        else
                        {
                            pThis->m_cpRecognizer->SetRecoState( SPRST_ACTIVE );
                        }
                    }
                    return TRUE;

                case IDC_BUTTON_SUBMIT:
                    {
                        CSpDynamicString    dstrText;
                        int                 iStrLen = 0;
                        TCHAR               szEmulateRecoText[NORM_SIZE];
                        USES_CONVERSION;

                        UINT numChar = GetDlgItemText(  hDlg, IDC_EDIT_PARSETEXT, 
                                                        szEmulateRecoText, NORM_SIZE );
                        if( pThis->m_cpRecoGrammar )
                        {
                            pThis->m_dstr = L"";
                            HRESULT hr = pThis->EmulateRecognition(T2W(szEmulateRecoText));
                            if( SP_NO_PARSE_FOUND == hr )
                            {
                                ::SendMessage( GetDlgItem(hDlg, IDC_LIST_PHRASES), WM_SETTEXT, 
                                               0, (LPARAM)"<Unrecognized phrase>");
                            }
                        }
                    }
                    return TRUE;
                }
            }
            return TRUE;

        case WM_CLOSE:
            {
                // Release grammar
                pThis->m_cpRecoGrammar.Release();
                EndDialog( hDlg, LOWORD(wParam) );
            }
            return TRUE;
    }
    return FALSE;
}

/****************************************************************************
* CCompiler::AddStatus *
*---------------------------*
*   Description:
*       Writes compile output to the status window.
*****************************************************************************/ 
void CCompiler::AddStatus(HRESULT hr, UINT uID, const TCHAR * pFmtString)
{
    USES_CONVERSION;
    TCHAR sz[MAX_PATH];
    ::LoadString(m_hInstance, uID, sz, sp_countof(sz));
    if (pFmtString)
    {
        TCHAR szFormatted[MAX_PATH];
        ::wsprintf(szFormatted, sz, pFmtString);
        AddError(-1, hr, T2W(szFormatted), NULL, 0);
    }
    else
    {
        AddError(-1, hr, T2W(sz), NULL, 0);
    }
}

/****************************************************************************
* CCompiler::AddError *
*---------------------------*
*   Description:
*       Writes compile error messages to the status window.
*****************************************************************************/ 
STDMETHODIMP CCompiler::AddError(const long lLine, HRESULT hr, const WCHAR * pszDescription, const WCHAR * pszHelpFile, DWORD dwHelpContext)
{
    if (FAILED(hr) && SUCCEEDED(m_hrWorstError))
    {
        m_hrWorstError = hr;
    }
    
    USES_CONVERSION;
    TCHAR *pszText = NULL;
    TCHAR *pszFinalOutput = NULL;
    if (hr == S_OK)
    {
        pszFinalOutput = W2T(pszDescription);
    }
    else
    {
        pszText = new TCHAR[ MAX_PATH + _tcslen( m_szXMLSrcFile ) + _tcslen( W2T(pszDescription) ) ];
        if ( pszText )
        {
            if (lLine >= 0)
            {
                wsprintf(pszText, SUCCEEDED(hr) ? _T("%s(%d) Warning: %s\n") : _T("%s(%d) Error: %s\n"),
                         m_szXMLSrcFile, lLine, W2T(pszDescription));
            }
            else
            {
                wsprintf(pszText, SUCCEEDED(hr) ? _T("%s Warning: %s\n") : _T("%s Error: %s\n"),
                         m_szXMLSrcFile, W2T(pszDescription));
            }

            pszFinalOutput = pszText;
        }
        else
        {
            // out of memory: just give the description
            pszFinalOutput = W2T(pszDescription);
        }
    }

    bool fNeedToUpdateWidth = false;    // Might need to tell the listbox to show the hscroll
    HWND hwndList = NULL;
	if( m_hDlg )	// dialog
	{
		if( m_fCommandLine )
		{
			int iRet = ::SendDlgItemMessage(m_hDlg, IDC_LIST_STATUS, LB_ADDSTRING, 0, (LPARAM)pszFinalOutput);
            hwndList = ::GetDlgItem( m_hDlg, IDC_LIST_STATUS );
            fNeedToUpdateWidth = (LB_ERR != iRet);
		}
		else
		{
			_tprintf( pszFinalOutput );
		}
	}
	else			// window
	{
        int iRet = ::SendMessage( m_hWndStatus, LB_ADDSTRING, 0, (LPARAM) pszFinalOutput );
        hwndList = m_hWndStatus;
        fNeedToUpdateWidth = (LB_ERR != iRet);
	}

    if ( fNeedToUpdateWidth )
    {
        // Listboxes do not update their horizontal extent dynamically,
        // so we need to do so here.
        HDC hdc = ::GetDC( hwndList );
        SIZE size;
        ::GetTextExtentPoint32( hdc, pszFinalOutput, _tcslen( pszFinalOutput ), &size );
        ::ReleaseDC( hwndList, hdc );

        int iCurrentWidth = (int) ::SendMessage( hwndList, LB_GETHORIZONTALEXTENT, 0, 0 );
        if ( size.cx > iCurrentWidth )
        {
            ::SendMessage( hwndList, LB_SETHORIZONTALEXTENT, size.cx, 0 );
        }

    }

    if ( pszText )
    {
        delete[] pszText;
    }

    return S_OK;
}


/****************************************************************************
* CCompiler::EnterIdle *
*---------------------------*
*   Description:
*       Calls the SAPI grammar compiler to compile the xml file.
*****************************************************************************/ 
HRESULT CCompiler::EnterIdle()
{
    HRESULT     hr = S_OK;

    if (m_fNeedStartCompile)
    {
        BOOL bWorked = FALSE;
        m_fNeedStartCompile = FALSE;
        CSpFileStream Source(&hr, m_szXMLSrcFile);
        AddInternalError(hr, IDS_CANTOPENSOURCE, m_szXMLSrcFile);
        if (SUCCEEDED(hr))
        {
            CSpFileStream Dest(&hr, m_szCFGDestFile, GENERIC_WRITE, 0, CREATE_ALWAYS);
            AddInternalError(hr, IDS_CANTOPENDEST, m_szCFGDestFile);
            if (SUCCEEDED(hr) && strlen(m_szHeaderDestFile))
            {
                CSpFileStream Header(&hr, m_szHeaderDestFile, GENERIC_WRITE, 0, CREATE_ALWAYS);
                AddInternalError(hr, IDS_CANTOPENDEST, m_szHeaderDestFile); 
                WriteStream(&Header, "#ifndef __");
                StripWrite(&Header, m_szHeaderDestFile);
                WriteStream(&Header, "_IDs__\n");
                WriteStream(&Header, "#define __");
                StripWrite(&Header, m_szHeaderDestFile);
                WriteStream(&Header, "_IDs__\n\n");

                if (SUCCEEDED(hr))
                {
                    if( !m_fSilent )
                    {
                        hr = m_cpCompiler->CompileStream(&Source, &Dest, &Header, NULL, this, 0);
                    }
                    else
                    {
                        hr = m_cpCompiler->CompileStream(&Source, &Dest, &Header, NULL, m_cpError, 0);
                    }
                    
                }
                if (SUCCEEDED(hr))
                {
                    WriteStream(&Header, "\n#endif\n");
                }
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    if( !m_fSilent )
                    {
                        hr = m_cpCompiler->CompileStream(&Source, &Dest, NULL, NULL, this, 0);
                    }
                    else
                    {
                        hr = m_cpCompiler->CompileStream(&Source, &Dest, NULL, NULL, m_cpError, 0);
                    }
                }
            }

            if (SUCCEEDED(hr) && SUCCEEDED(m_hrWorstError))
            {
                AddStatus(S_OK, IDS_COMPILESUCCESS);
                bWorked = TRUE;
                if (m_fSilent)
                {
                    ::EndDialog(m_hDlg, S_OK);
                }
            }
            else
            {
                AddStatus(hr, IDS_COMPILEFAILURE);
                bWorked = FALSE;
                if (m_fSilent)
                {
                    ::EndDialog(m_hDlg, S_OK);
                }
            }
        }
        if (!bWorked)
        {
            ::DeleteFile(m_szCFGDestFile);
        }
    }

    return hr;
}

/****************************************************************************
* CCompiler::LoadGrammar *
*---------------------------*
*   Description:
*       Loads and activates the Grammar
***************************************************************** Leonro ****/ 
HRESULT CCompiler::LoadGrammar( TCHAR* szPath )
{
    HRESULT     hr = S_OK;

    // load grammar
    hr = m_cpRecoContext->CreateGrammar(GRAM_ID, &m_cpRecoGrammar);
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        hr = m_cpRecoGrammar->LoadCmdFromFile( T2W(szPath), SPLO_STATIC );
        if (FAILED(hr))
        {
            m_cpRecoGrammar.Release();
        }
    }
    return hr;
}

/****************************************************************************
* CCompiler::WriteStream *
*---------------------------*
*   Description:
*       Calls write on the output stream
*****************************************************************************/
HRESULT CCompiler::WriteStream(IStream * pStream, const char * pszText)
{
    ULONG cch = strlen(pszText);
    return pStream->Write(pszText, cch, NULL);
}

/****************************************************************************
* CCompiler::StripWrite *
*---------------------------*
*   Description:
*       Strips characters off strings
*****************************************************************************/
HRESULT CCompiler::StripWrite(IStream * pStream, const char * pszText)
{
    ULONG cch = strlen(pszText);
    char * psz = (char *)_alloca((cch + 1) * sizeof(char));
    char c;
    char * pszWork = psz;
    do
    {
        c = *pszText++;
        *pszWork++ = ((c == 0) || (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) ? c : '_';
    } while (c);
    return pStream->Write(psz, cch, NULL);
}

/****************************************************************************
* CCompiler::CallOpenFileDialog *
*---------------------------*
*   Description:
*       Displays the open dialog box to retrieve the 
*       user-selected .txt or .xml file for synthisizing
*************************************************************** Leonro ******/ 
BOOL CCompiler::CallOpenFileDialog( HWND hWnd, LPSTR szFileName, TCHAR* szFilter )   
{
    OPENFILENAME    ofn;
    BOOL            bRetVal           = TRUE;
    LONG            lRetVal;
    HKEY            hkResult;
    TCHAR           szPath[NORM_SIZE]       = _T("");
    DWORD           size = NORM_SIZE;

    // Open the last directory used by this app (stored in registry)
    lRetVal = RegCreateKeyEx( HKEY_CURRENT_USER, 
                        _T("SOFTWARE\\Microsoft\\Speech\\AppData\\PathToGrammarFiles"), 0, NULL, 0,
                        KEY_ALL_ACCESS, NULL, &hkResult, NULL );

    if( lRetVal == ERROR_SUCCESS )
    {
        RegQueryValueEx( hkResult, _T("GramCompFiles"), NULL, NULL, (PBYTE)szPath, &size );
    }

    ofn.lStructSize       = OPENFILENAME_SIZE_VERSION_400;
    ofn.hwndOwner         = hWnd;    
    ofn.lpstrFilter       = szFilter;
    ofn.lpstrCustomFilter = NULL;    
    ofn.nFilterIndex      = 1;    
    ofn.lpstrInitialDir   = szPath;
    ofn.lpstrFile         = szFileName;  
    ofn.nMaxFile          = NORM_SIZE;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;    
    ofn.lpstrDefExt       = _T("xml");
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

    // Pop the dialog
    bRetVal = GetOpenFileName( &ofn );
    
    // Write the directory path you're in to the registry
    TCHAR   pathstr[NORM_SIZE] = _T("");
    strcpy( pathstr, szFileName );

    int i=0; 
    while( pathstr[i] != NULL )
    {
        i++;
    }
    while( pathstr[i] != '\\' )
    {
        i --;
    }
    pathstr[i] = NULL;

    RegSetValueEx( hkResult, _T("GramCompFiles"), NULL, REG_EXPAND_SZ, (PBYTE)pathstr, strlen(pathstr)+1 );

    RegCloseKey( hkResult );

    return bRetVal;
}

/****************************************************************************
* CCompiler::CallSaveFileDialog *
*---------------------------*
*   Description:
*       Displays the save file dialog box and retrieves 
*       the user-selected save file name.
*************************************************************** Leonro ******/ 
BOOL CCompiler::CallSaveFileDialog( HWND hWnd, TCHAR* szSaveFile )
{
    TCHAR   pszFileName[MAX_PATH] = _T("");
    BOOL    bSuccess = TRUE;
    static TCHAR    pszFilter[MAX_PATH] = _T("leon");

    OPENFILENAME ofn;
    ZeroMemory( &ofn, OPENFILENAME_SIZE_VERSION_400 );
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
    ofn.hwndOwner = hWnd;
    ofn.hInstance = m_hInstance;
    ofn.lpstrFilter = "XML Files (*.xml)\0*.xml\0Text Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szSaveFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.nMaxFileTitle = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = NULL;
    ofn.Flags = OFN_CREATEPROMPT;
    ofn.lpstrDefExt = "xml";

    bSuccess = GetSaveFileName( &ofn );
    
    return bSuccess;
}

/****************************************************************************
* CCompiler::FileSave *
*---------------------------*
*   Description:
*       Saves the TOM file to disk
**************************************************************** Leonro *****/ 
HRESULT CCompiler::FileSave( HWND hWnd, CCompiler* pComp, TCHAR* szSaveFile )
//
{
    VARIANT     Var;
    HRESULT     hr = S_OK;
    BOOL        bRetVal = TRUE;
    USES_CONVERSION;

    // Call save file dialog if there's no file name already
    if( !_tcscmp( szSaveFile, "" ) )
    {
        bRetVal = CallSaveFileDialog( hWnd, szSaveFile );
    }

    // TOM save file
    if( bRetVal )
    {
        // Save it
        VariantInit( &Var );
        Var.vt = VT_BSTR;
        Var.bstrVal = SysAllocString( T2W(szSaveFile) ); // Will use Win32 file command
        hr = pComp->m_cpTextDoc->Save( &Var, tomCreateAlways, 1200 ); 
        hr &= ~0x40000; // Mask off bit 18
        SysFreeString( Var.bstrVal );

        if( SUCCEEDED( hr ) )
        {
            // Set the compiler source file to the newly saved file
            _tcscpy( pComp->m_szXMLSrcFile, szSaveFile );
        }
        else
        {
            _tcscpy( szSaveFile, _T("") );
        }

        // If the text document has been saved
        if( SUCCEEDED( hr ) )
        {
            pComp->m_cpTextDoc->SetSaved( tomTrue );
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

/****************************************************************************
* CCompiler::Compile *
*---------------------------*
*   Description:
*       Handles compiling the text in the editor. This function calls CCompiler::EnterIdle
*       to do the actual compiling.
***************************************************************** Leonro ****/ 
HRESULT CCompiler::Compile( HWND hWnd, TCHAR* szSaveFileName, TCHAR* szTitle, CCompiler* pComp )
{
    HRESULT     hr = S_OK;
    long        lSaved = 0;

    // reset errors
    pComp->m_hrWorstError = 0;

    // Save file first if it has not been saved
    hr = pComp->m_cpTextDoc->GetSaved( &lSaved );
    if( lSaved == tomFalse && SUCCEEDED( hr ) )
    {
        // TOM save file
        hr = FileSave( hWnd, pComp, szSaveFileName );                    
        if( hr == STG_E_ACCESSDENIED ) // Handle read only files
        {
            MessageBox( pComp->m_hWndEdit, _T("This file exists with Read Only attributes.\n Please use a different file name."),
                            _T("File Save"), MB_OK );
            // Call FileSave again but this time pop the save file dialog box
            hr = FileSave( hWnd, pComp, szSaveFileName );
        }
        // Add the file name to the title bar
        if( SUCCEEDED( hr ) )
        {
            LoadString( pComp->m_hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING );
            _tcscat( szTitle, _T(" - [") );
            _tcscat( szTitle, szSaveFileName );
            _tcscat( szTitle, _T("]") );
            SetWindowText( hWnd, szTitle );
        }
    }

    // If everything has succeeded but there is no source text in the editor 
    // set hr to InvalidArg
    if( SUCCEEDED( hr ) && !*pComp->m_szXMLSrcFile )
    {
        hr = E_INVALIDARG;
    }

    // Clear out the listbox of any previous errors
    ::SendMessage( m_hWndStatus, LB_RESETCONTENT, 0, 0 );

    // Set up the compiler and do it
    if( SUCCEEDED( hr ) ) 
    {
        // construct name from m_szXMLSrcFile
        _tcscpy(pComp->m_szCFGDestFile, pComp->m_szXMLSrcFile);
        _tcscpy(&pComp->m_szCFGDestFile[strlen(pComp->m_szCFGDestFile) -3], _T("cfg"));
    
        // update text in Status Window
        TCHAR sz[MAX_PATH];
        TCHAR *pszOutput = new TCHAR[ sp_countof(sz) + _tcslen( pComp->m_szXMLSrcFile ) ];
        if ( pszOutput )
        {
            LoadString( m_hInstance, IDS_COMPFILE, sz, sp_countof(sz) );
            wsprintf( pszOutput, sz, pComp->m_szXMLSrcFile );
            ::SendMessage( m_hWndStatus, LB_INSERTSTRING, 0, (LPARAM) pszOutput );

            // Size the listbox
            HDC hdc = ::GetDC( m_hWndStatus );
            SIZE size;
            ::GetTextExtentPoint32( hdc, pszOutput, _tcslen( pszOutput ), &size );
            ::ReleaseDC( m_hWndStatus, hdc );
            ::SendMessage( m_hWndStatus, LB_SETHORIZONTALEXTENT, size.cx, 0 );
            delete[] pszOutput;
        }

        // call the actual compile step
        pComp->EnterIdle();
    
        // repaint
        InvalidateRect( hWnd, NULL, FALSE );
    
        // Check for compile errors
        hr = pComp->m_hrWorstError;
        if( FAILED( hr ) )
        {
            pComp->m_fNeedStartCompile = TRUE;
        }
        else
        {
            pComp->m_fNeedStartCompile = FALSE;
        }
    }
    
    return hr;
}

/****************************************************************************
* CCompiler::RecoEvent *
*---------------------------*
*   Description:
*       Helper function that handles speech events
**************************************************************** Leonro *****/ 
void CCompiler::RecoEvent( HWND hDlg, CCompiler* pComp )
{
    USES_CONVERSION;
    HRESULT         hr=S_OK;
    CSpEvent        event;
    long            iNewPhrase=0;
    static BOOL     fStartSound = FALSE;

    if( pComp->m_cpRecoContext )
    {
        while( event.GetFrom(pComp->m_cpRecoContext) == S_OK )
        {
            // Switch on recognition event
            switch( event.eEventId )
            {
            case SPEI_SOUND_START:
                fStartSound = TRUE;
                m_dstr = L"";
                break;

            case SPEI_SOUND_END:
                if( fStartSound )
                {
                    fStartSound = FALSE;
                    if( !pComp->m_fGotReco )
                    {
                        CSpDynamicString dstrText = L"<noise>";
                        TCHAR* szUnRecoString = W2T( dstrText.m_psz );
                    
                        iNewPhrase = SendDlgItemMessage( hDlg, IDC_LIST_PHRASES, LB_ADDSTRING, 
                                                            0, (LPARAM)szUnRecoString );
                        SendDlgItemMessage( hDlg, IDC_LIST_PHRASES, LB_SETCURSEL, iNewPhrase, 0);
                    }
                    pComp->m_fGotReco = FALSE;
                }
                break;

            case SPEI_FALSE_RECOGNITION:
                ::SendMessage( GetDlgItem(hDlg, IDC_LIST_PHRASES), WM_SETTEXT, 0, (LPARAM)"<Unrecognized>");
                break;

            case SPEI_RECOGNITION:
            case SPEI_HYPOTHESIS:
                Recognize( hDlg, *pComp, event );
                break;
            }
        }
    }
}


/****************************************************************************
* CCompiler::Recognize *
*----------------------*
*   Description:
*       Helper function that handles recognition events
*************************************************************** MarkNik *****/ 
void CCompiler::Recognize( HWND hDlg, CCompiler &rComp, CSpEvent &rEvent )
{
    USES_CONVERSION;
    CComPtr<ISpRecoResult> cpResult;
    cpResult = rEvent.RecoResult();
    HRESULT                 hr = S_OK;
    long            iNewPhrase=0;

    rComp.m_fGotReco = TRUE;

    CSpDynamicString dstrText;

    SPPHRASE *pElements;
    if( SUCCEEDED( cpResult->GetPhrase( &pElements ) ) )
    {
        _ASSERT(pElements->ullGrammarID == GRAM_ID);
        TCHAR szText[256];


        HWND hwndEdit = GetDlgItem(hDlg, IDC_LIST_PHRASES);
        ULONG CurrentLen = ::SendMessage( hwndEdit, WM_GETTEXTLENGTH, 0, 0 );

        if( SPEI_RECOGNITION == rEvent.eEventId )
        {
            m_dstr.Append( L"------------- Recognition Event: ------------- \r\n\r\n" );
        }
        else if ( SPEI_HYPOTHESIS == rEvent.eEventId )
        {
            m_dstr.Append( L"------------- Hypothesis Event: ------------- \r\n\r\n" );
        }
        else
        {
            m_dstr.Append( L"Unknown Event...:\r\n\r\n" );
        }

        if (pElements->Rule.pszName || pElements->Rule.ulId)
        {
            wsprintf(szText, "RULE=\"%s\" (%05d)\r\n", W2T(pElements->Rule.pszName), pElements->Rule.ulId);
            m_dstr.Append( T2W(szText) );
            hr = cpResult->GetText( SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstrText, NULL );
            if( SUCCEEDED( hr ) )
            {
                m_dstr.Append( dstrText );
            }
            else
            {
                m_dstr.Append( L"<Unrecognized phrase>" );
            }
        }
        else
        {
            m_dstr = L"DICTATION\r\n";
            CSpDynamicString dstrText;
            hr = cpResult->GetText( SP_GETWHOLEPHRASE, SP_GETWHOLEPHRASE, TRUE, &dstrText, NULL );
            if( SUCCEEDED( hr ) )
            {
                m_dstr.Append( dstrText );
            }
            else
            {
                m_dstr.Append( L"<Unrecognized DICTATION>" );
            }
        }

        m_dstr.Append(L"\r\n");
        if (pElements->pProperties)
        {
            m_dstr.Append(L"\r\nPROPERTIES:\r\n");
            ConstructPropertyDisplay(pElements->pElements, pElements->pProperties, m_dstr, 0);
        }

        m_dstr.Append(L"\r\nPARSE TREE:\r\n");
        ConstructRuleDisplay(&pElements->Rule, m_dstr, 0);

        m_dstr.Append(L"\r\nELEMENTS:\r\n");
        for (ULONG i = 0; i < pElements->Rule.ulCountOfElements; i++)
        {
            wsprintf(szText, " <%u - %u> \"%s\" %c(%c)\r\n", 
                pElements->pElements[i].ulAudioStreamOffset,
                pElements->pElements[i].ulAudioStreamOffset + pElements->pElements[i].ulAudioSizeBytes,
                W2T(pElements->pElements[i].pszDisplayText), 
                ConfidenceGroupChar(pElements->pElements[i].ActualConfidence),
                ConfidenceGroupChar(pElements->pElements[i].RequiredConfidence));
            m_dstr.Append(T2W(szText));
        }

        m_dstr.Append( L"\r\n\r\n" );
        ::SendMessage( hwndEdit, WM_SETTEXT, 0, (LPARAM)W2T(m_dstr));

        ::CoTaskMemFree(pElements);
    }
    else
    {
        ::SendMessage( GetDlgItem(hDlg, IDC_LIST_PHRASES), WM_SETTEXT, 0, (LPARAM)"<Unrecognized>");
    }
}

/****************************************************************************
* CCompiler::EmulateRecognition *
*-----------------------------------*
*   Description:
*       Allows users to input text to emmulate recognition
*
***************************************************************** PhilSch ***/
HRESULT CCompiler::EmulateRecognition(WCHAR *pszText)
{
    HRESULT hr = S_OK;

    // Get local info
    SPRECOGNIZERSTATUS stat;
    LANGID LangID;
    ZeroMemory(&stat, sizeof(stat));
    m_cpRecognizer->GetStatus(&stat);
    LangID = stat.aLangID[0];

    CComPtr<ISpPhraseBuilder> cpPhrase;
    if (SUCCEEDED(CreatePhraseFromText(pszText, &cpPhrase, LangID)) && m_cpRecognizer)
    {
        return( m_cpRecognizer->EmulateRecognition(cpPhrase) );
    }

    return S_FALSE;
}


/* MEMBER FUNCTIONS FOR THE COMMAND LINE VERSION OF THE APPLICATION ONLY*/
/****************************************************************************
* CCompiler::InitDialog *
*---------------------------*
*   Description:
*       Initializes the command line version of the compile status dialog box
*****************************************************************************/ 
BOOL CCompiler::InitDialog(HWND hDlg)
{
    m_hDlg = hDlg;
    TCHAR sz[MAX_PATH];
    ::LoadString(m_hInstance, IDS_COMPFILE, sz, sp_countof(sz));
    TCHAR szTitle[MAX_PATH];
    wsprintf(szTitle, sz, m_szXMLSrcFile);
    ::SendDlgItemMessage(hDlg, IDC_STATUS, WM_SETTEXT, 0, (LPARAM)szTitle);
    return TRUE;
}

/****************************************************************************
* CCompiler::DialogProc *
*---------------------------*
*   Description:
*       Message handler for command line version of dialog box
*****************************************************************************/ 
int CALLBACK CCompiler::DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CCompiler * pThis = (CCompiler *)::GetWindowLong(hDlg, GWL_USERDATA);
	switch (message)
	{
        case WM_INITDIALOG:
            ::SetWindowLong(hDlg, GWL_USERDATA, lParam);
            pThis = (CCompiler *)lParam;
            return pThis->InitDialog(hDlg);   //1

        case WM_PAINT:
            if (pThis->m_fNeedStartCompile)
            {
                ::PostMessage(hDlg, WM_APP, 0, 0);
            }
            break;

        case WM_APP:
            pThis->EnterIdle();
            return TRUE;

        case WM_COMMAND:
        {
            if (LOWORD(wParam) == IDOK) 
            {
                EndDialog(hDlg, 0);
                return TRUE;
            }
	    }
	    break;
	}
    return FALSE;
}


/****************************************************************************
* CError::AddError *
*------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CError::AddError(const long lLine, HRESULT hr, const WCHAR * pszDescription, const WCHAR * pszHelpFile, DWORD dwHelpContext)
{
    SPDBG_FUNC("CError::AddError");
    USES_CONVERSION;
    ATLTRACE(L"%s(%d) : %s\n", T2W(m_pszFileName), lLine, pszDescription);
    return S_OK;
}
/****************************************************************************
* CError::Init *
*--------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CError::Init(const char *pszFileName)
{
    SPDBG_FUNC("CError::Init");   
    m_pszFileName = pszFileName;
    return S_OK;
}

/****************************************************************************
* CRecoDlgClass::ConstructPropertyDisplay *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CCompiler::ConstructPropertyDisplay(const SPPHRASEELEMENT *pElem, const SPPHRASEPROPERTY *pProp, 
                                                CSpDynamicString & dstr, ULONG ulLevel)
{
    SPDBG_FUNC("CRecoDlgClass::ConstructPropertyDisplay");
    HRESULT hr = S_OK;
    USES_CONVERSION;
    TCHAR szText[256];

    // constrcut indent
    while(SUCCEEDED(hr) && pProp)
    {
        wsprintf(szText, " [%2d, %2d] ", pProp->ulFirstElement, pProp->ulFirstElement + pProp->ulCountOfElements);
        for (ULONG i = 0; i < ulLevel; i++)
        {
            dstr.Append(L"\t");
        }
        if (pProp->pszName)
        {
            if (wcslen(pProp->pszName) > 240)
            {
                dstr.Append(L"\"(Rule name too long)\" = \"");
            }
            else
            {
                wsprintf(szText, "\"%s\" = \"", W2T(pProp->pszName));
                dstr.Append(T2W(szText));
            }
        }
        else
        {
            dstr.Append(L"\"(UNK)\" = \"");
        }
        if (!pProp->pszValue)
        {
            // construct the value from the elements!
            ULONG ulEndElement = pProp->ulFirstElement + pProp->ulCountOfElements;
            for (ULONG j = pProp->ulFirstElement; j < ulEndElement; j++)
            {
                if (j+1 < ulEndElement)
                {
                    dstr.Append2(pElem[j].pszDisplayText, L" ");
                }
                else
                {
                    dstr.Append(pElem[j].pszDisplayText);
                }
            }
        }
        else
        {
            dstr.Append(pProp->pszValue);
        }

        if (pProp->vValue.vt != VT_EMPTY)
        {
            CComVariant cv = pProp->vValue;
            cv.ChangeType(VT_BSTR);
            wsprintf(szText, "\" (%d = %s)", pProp->ulId, W2T(cv.bstrVal));
        }
        else
        {
            wsprintf(szText, "\" (%d)", pProp->ulId);
        }
        dstr.Append2(T2W(szText), L"\r\n");
        if (pProp->pFirstChild)
        {
            hr = ConstructPropertyDisplay(pElem, pProp->pFirstChild, dstr, ulLevel + 1);
        }
        pProp = pProp->pNextSibling;
    }
    return hr;
}


/****************************************************************************
* CRecoDlgClass::ConstructRuleDisplay *
*-------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CCompiler::ConstructRuleDisplay(const SPPHRASERULE *pRule, CSpDynamicString &dstr, ULONG ulLevel)
{
    SPDBG_FUNC("CRecoDlgClass::ConstructRuleDisplay");
    HRESULT hr = S_OK;

    USES_CONVERSION;
    TCHAR szText[256];

    // constrcut indent
    while(SUCCEEDED(hr) && pRule)
    {
        wsprintf(szText, " [%2d, %2d] ", pRule->ulFirstElement, pRule->ulFirstElement + pRule->ulCountOfElements);
        for (ULONG i = 0; i < ulLevel; i++)
        {
            dstr.Append(L"\t");
        }
        if (pRule->pszName)
        {
            if (wcslen(pRule->pszName) > 240)
            {
                dstr.Append(L"\"(Rule name too long)\" = \"");
            }
            else
            {
                wsprintf(szText, "%s \"%s\" (%d)", szText, W2T(pRule->pszName), pRule->ulId);
                dstr.Append(T2W(szText));
            }
        }
        else
        {
            dstr.Append(L"\"(UNK)\" = \"");
        }
        dstr.Append(L"\r\n");
        if (pRule->pFirstChild)
        {
            hr = ConstructRuleDisplay(pRule->pFirstChild, dstr, ulLevel + 1);
        }
        pRule = pRule->pNextSibling;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		    // Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN
#define MAX_SIZE        4096
#define NORM_SIZE       256
#define WM_RECOEVENT    WM_APP      // Window message used for recognition events
#define GRAM_ID         11111


// Windows Header Files:
#include <windows.h>
#include <commdlg.h>

// C RunTime Header Files
#include <stdio.h>

// Other Header Files

#ifndef __CFGDUMP_
#define __CFGDUMP_

#include <tchar.h>
#include <atlbase.h>
#include <ole2.h>
#include <oleauto.h>
#include <richedit.h>
#include <richole.h>
#include "tom.h"
#include <mlang.h>
#include <sapi.h>
#include <sphelper.h>
#include <spddkhlp.h>
#include <sapiint.h>
#include "resource.h"
#endif

/****************************************************************************
* CRecoDlgListItem *
*------------------*
*   
*   This class stores the recognition result as well as a text string associated
*   with the recognition.  Note that the string will sometimes be <noise> and
*   the pResult will be NULL.  In other cases the string will be <Unrecognized>
*   and pResult will be valid.
*
********************************************************************* RAL ***/

class CRecoDlgListItem
{
public:
    CRecoDlgListItem(ISpRecoResult * pResult, const WCHAR * pwsz, BOOL fHypothesis) :
        m_cpRecoResult(pResult),
        m_dstr(pwsz),
        m_fHypothesis(fHypothesis)
    {}

    ISpRecoResult * GetRecoResult() const { return m_cpRecoResult; }
    int GetTextLength() const { return m_dstr.Length(); }
    const WCHAR * GetText() const { return m_dstr; }
    BOOL IsHypothesis() const { return m_fHypothesis; }

private:
    CComPtr<ISpRecoResult>  m_cpRecoResult;
    CSpDynamicString        m_dstr;
    BOOL                    m_fHypothesis;
};


#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\gramcomp.cpp ===
// GramComp.cpp : Defines the entry point for the application.
//
#include "stdafx.h"
#include "resource.h"
#include "comp.h"
#include <sapi.h>
#include <assertwithstack.cpp>

// Foward declarations of functions included in this code module:
BOOL                CallOpenFileDialog( HWND hWnd, TCHAR* szFileName, TCHAR* szFilter );
BOOL                CallSaveFileDialog( HWND hWnd, TCHAR* szSaveFile );
HRESULT             FileSave( HWND hWnd, CCompiler* pComp, TCHAR* szSaveFile );
HRESULT             Compile( HWND, TCHAR*, TCHAR*, CCompiler* );
void                RecoEvent( HWND, CCompiler* );

/************************************************************************
* WinMain() *
*-----------*
*   Description:
*       Main entry point for the application
**************************************************************************/
int APIENTRY WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR pCmdLine, int nCmdShow )
{
    int                 iRet = 0;
    HRESULT             hr = S_OK;
    
    #ifdef _WIN32_WCE
    if (SUCCEEDED(::CoInitializeEx(NULL,COINIT_MULTITHREADED)))
#else
    if (SUCCEEDED(::CoInitialize(NULL)))
#endif
    {
        {
        CCompiler   Comp( hInstance );

        // Initialize the application
        hr = Comp.Initialize( nCmdShow );

        if( SUCCEEDED( hr ) )
        {
            Comp.Run();
        }
        }
        
        CoUninitialize();        
    }

    return iRet;
}   /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\tools\gramcomp\comp.h ===
/******************************************************************************
*   Comp.h 
*       This module contains the base definitions for the SAPI 5 Grammar 
*       portion of the GramComp application.
*
*   Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
******************************************************************************/

#ifndef __COMPILER__CLASS__
#define __COMPILER__CLASS__

#define MAX_LOADSTRING 100


// Helper function
inline char ConfidenceGroupChar(char Confidence)
{
    switch (Confidence)
    {
    case SP_LOW_CONFIDENCE:
        return '-';

    case SP_NORMAL_CONFIDENCE:
        return ' ';

    case SP_HIGH_CONFIDENCE:
        return '+';

    default:
        _ASSERTE(false);
        return '?';
    }
}


//--- Class, Struct and Union Definitions -------------------------------------
class CCompiler : public ISpErrorLog
{
public:
    CCompiler(HINSTANCE hInstance): m_hInstance(hInstance),
                                     m_hWnd(NULL),
                                     m_hAccelTable(0),
                                     m_hrWorstError(S_OK),
                                     m_hDlg(NULL),
                                     m_fNeedStartCompile(TRUE),
                                     m_fSilent(FALSE),
                                     m_fCommandLine(FALSE),
                                     m_fGenerateHeader(FALSE),
                                     m_fGotReco(FALSE),
                                     m_hWndEdit(NULL),
                                     m_hWndStatus(NULL),
                                     m_hMod(0)
    {
         m_szXMLSrcFile[0]     = 0;
         m_szCFGDestFile[0]    = 0;
         m_szHeaderDestFile[0] = 0;
    }
    ~CCompiler();

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(IUnknown) ||
            riid == __uuidof(ISpErrorLog))
        {
            *ppv = (ISpErrorLog *)this;
            return S_OK;
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return 2;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }
    
    HRESULT Initialize( int nCmdShow );
    int Run();
    static LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK Find(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK Goto(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK TestGrammar(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    void AddStatus(HRESULT hr, UINT uID, const TCHAR * pFmtString = NULL);
    STDMETHODIMP AddError(const long lLine, HRESULT hr, const WCHAR * pszDescription, const WCHAR * pszHelpFile, DWORD dwHelpContext);
    HRESULT EnterIdle();
    HRESULT LoadGrammar(TCHAR* szPath);
    HRESULT WriteStream(IStream * pStream, const char * pszText);
    HRESULT StripWrite(IStream * pStream, const char * pszText);
    BOOL CallOpenFileDialog( HWND hWnd, LPSTR szFileName, TCHAR* szFilter );
    BOOL CallSaveFileDialog( HWND hWnd, TCHAR* szSaveFile );
    HRESULT FileSave( HWND hWnd, CCompiler* pComp, TCHAR* szSaveFile );
    HRESULT Compile( HWND hWnd, TCHAR* szSaveFileName, TCHAR* szTitle, CCompiler* pComp );
    void RecoEvent( HWND hDlg, CCompiler* pComp );
    HRESULT EmulateRecognition( WCHAR *pszText );

    void Recognize( HWND hDlg, CCompiler &rComp, CSpEvent &rEvent );
    HRESULT ConstructPropertyDisplay(const SPPHRASEELEMENT *pElem, const SPPHRASEPROPERTY *pProp, 
                                                CSpDynamicString & dstr, ULONG ulLevel);
    HRESULT ConstructRuleDisplay(const SPPHRASERULE *pRule, CSpDynamicString &dstr, ULONG ulLevel);


    inline void AddInternalError(HRESULT hr, UINT uID, const TCHAR * pFmtString = NULL)
    {
        if (hr != S_OK)
        {
            AddStatus(hr, uID, pFmtString);
        }
    }

    // Member functions for the command line version of the application
    BOOL InitDialog(HWND);
    static int CALLBACK CCompiler::DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    


public:
    const HINSTANCE  m_hInstance;       // Instance handle of process
    HWND        m_hWnd;                 // Window handle of dialog
    HACCEL      m_hAccelTable;          // Handle to the accelerators
    BOOL        m_fNeedStartCompile;    // Need a recompile?
    BOOL        m_fSilent;              // Silent or non-silent mode
	BOOL		m_fCommandLine;         // App being run from command line?
    BOOL        m_fGenerateHeader;      // Create a header file from compilation?
    BOOL        m_fGotReco;             // Was a recognition received?
    HWND        m_hDlg;                 // Window handle of command line compile dialog
    HWND        m_hWndEdit;             // Window handle of main edit window
    HWND        m_hWndStatus;           // Window handle of compile status window
    HRESULT     m_hrWorstError;         // Error code from compiler
    HMODULE     m_hMod;                 // Handle to the rich edit control
    CComPtr<ISpErrorLog>            m_cpError;          // Error log object
    CComPtr<ISpGrammarCompiler>     m_cpCompiler;       // Grammar compiler interface
    CComPtr<ISpRecoGrammar>         m_cpRecoGrammar;    // Grammar compiler interface
    CComPtr<IRichEditOle>           m_cpRichEdit;       // OLE interface to the rich edit control
    CComPtr<ITextDocument>          m_cpTextDoc;        // Rich edit control interface
    CComPtr<ITextSelection>         m_cpTextSel;        // Rich edit control interface
    CComPtr<ISpRecognizer>          m_cpRecognizer;     // SR engine interface
    CComPtr<ISpRecoContext>         m_cpRecoContext;    // SR engine interface
    TCHAR       m_szXMLSrcFile[MAX_PATH];               // Path to xml source file
    TCHAR       m_szCFGDestFile[MAX_PATH];              // Output location for cfg file
    TCHAR       m_szHeaderDestFile[MAX_PATH];           // Output location for header file
    CSpDynamicString m_dstr;

};


class CError : public ISpErrorLog
{
public:
    CError() : m_pszFileName(NULL) {};
    CError(const char * pszFileName)
    {
        m_pszFileName = pszFileName;
    }
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(IUnknown) ||
            riid == __uuidof(ISpErrorLog))
        {
            *ppv = (ISpErrorLog *)this;
            return S_OK;
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return 2;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }
    // -- ISpErrorLog
    STDMETHODIMP AddError(const long lLine, HRESULT hr, const WCHAR * pszDescription, const WCHAR * pszHelpFile, DWORD dwHelpContext);

    // -- local
    HRESULT Init(const char *pszFileName);

    // --- data members
    const char * m_pszFileName;
};

#endif  // Must be the last line of this file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\setup\installer\ca_srdata\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CA_SRData.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\setup\installer\ca_srdata\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__DEB8559A_C327_48E1_87A6_BC128C29AE9D__INCLUDED_)
#define AFX_STDAFX_H__DEB8559A_C327_48E1_87A6_BC128C29AE9D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <tchar.h>
#include <shfolder.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DEB8559A_C327_48E1_87A6_BC128C29AE9D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\setup\installer\ca_srdata\ca_srdata.cpp ===
// CA_SRData.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}


const static TCHAR *g_ppszFileList[] = 
{
    _T("SR\\1033\\af031033.am"),
    _T("SR\\1033\\af031033.env"),
    _T("SR\\1033\\af031033.nsc"),
    _T("SR\\1033\\ai041033.am"),
    _T("SR\\1033\\ai041033.env"),
    _T("SR\\1033\\ai041033.nsc"),
    _T("SR\\1033\\am031033.am"),
    _T("SR\\1033\\am031033.env"),
    _T("SR\\1033\\am031033.nsc"),
    _T("SR\\1033\\ci031033.am"),
    _T("SR\\1033\\ci031033.env"),
    _T("SR\\1033\\ci031033.nsc"),
    _T("SR\\1033\\l1033.adc"),
    _T("SR\\1033\\l1033.art"),
    _T("SR\\1033\\l1033.cw"),
    _T("SR\\1033\\l1033.dlm"),
    _T("SR\\1033\\l1033.ini"),
    _T("SR\\1033\\l1033.ngr"),
    _T("SR\\1033\\l1033.phn"),
    _T("SR\\1033\\l1033.smp"),
    _T("SR\\1033\\l1033.tre"),
    _T("SR\\1033\\l1033.vec"),
    _T("SR\\1033\\p1033.dlm"),
    _T("SR\\1033\\p1033.ngr"),
    _T("SR\\1033\\s1033.dlm"),
    _T("SR\\1033\\s1033.ngr"),
    _T("SR\\2052\\af032052.am"),
    _T("SR\\2052\\af032052.env"),
    _T("SR\\2052\\af032052.nsc"),
    _T("SR\\2052\\am032052.am"),
    _T("SR\\2052\\am032052.env"),
    _T("SR\\2052\\am032052.nsc"),
    _T("SR\\2052\\l2052.adc"),
    _T("SR\\2052\\l2052.art"),
    _T("SR\\2052\\l2052.cw"),
    _T("SR\\2052\\l2052.dlm"),
    _T("SR\\2052\\l2052.ini"),
    _T("SR\\2052\\l2052.ngr"),
    _T("SR\\2052\\l2052.phn"),
    _T("SR\\2052\\l2052.smp"),
    _T("SR\\2052\\l2052.tre"),
    _T("SR\\2052\\l2052.vec"),
    _T("SR\\2052\\p2052.dlm"),
    _T("SR\\2052\\p2052.ngr"),
    _T("SR\\1041\\af031041.am"),
    _T("SR\\1041\\af031041.env"),
    _T("SR\\1041\\af031041.nsc"),
    _T("SR\\1041\\am031041.am"),
    _T("SR\\1041\\am031041.env"),
    _T("SR\\1041\\am031041.nsc"),
    _T("SR\\1041\\ci031041.am"),
    _T("SR\\1041\\ci031041.env"),
    _T("SR\\1041\\ci031041.nsc"),
    _T("SR\\1041\\l1041.adc"),
    _T("SR\\1041\\l1041.art"),
    _T("SR\\1041\\l1041.cw"),
    _T("SR\\1041\\l1041.dlm"),
    _T("SR\\1041\\l1041.ini"),
    _T("SR\\1041\\l1041.ngr"),
    _T("SR\\1041\\l1041.phn"),
    _T("SR\\1041\\l1041.smp"),
    _T("SR\\1041\\l1041.tre"),
    _T("SR\\1041\\l1041.vec"),
    _T("SR\\1041\\p1041.dlm"),
    _T("SR\\1041\\p1041.ngr"),
    _T("SR\\1041\\s1041.dlm"),
    _T("SR\\1041\\s1041.ngr"),
    _T("Lexicon\\1033\\lsr1033.lxa"),
    _T("Lexicon\\1033\\r1033sr.lxa"),
    _T("Lexicon\\2052\\lsr2052.lxa"),
    _T("Lexicon\\2052\\r2052sr.lxa"),
    _T("Lexicon\\1041\\lsr1041.lxa"),
    _T("Lexicon\\1041\\llts1041.lxa"),
    _T("")
};

UINT __stdcall CA_SRDatafiles(HANDLE hInstall)
{
    HRESULT hr;
    TCHAR pszCommonPath[MAX_PATH] = _T("");

    // Get the path to the system's CommonProgramFiles folder
    hr = SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES_COMMON,
					NULL, 0, pszCommonPath);

    if (hr != S_OK)
    {
        hr = E_FAIL; // If file is not there (S_FALSE) then cannot continue
    }
    else
    {
        _tcscat(pszCommonPath, _T("\\SpeechEngines\\Microsoft\\"));
    }

    TCHAR pszFile[MAX_PATH];
    for (ULONG ul = 0; SUCCEEDED(hr) && *g_ppszFileList[ul] != _T('\0'); ul++)
    {
        //cat name
        pszFile[0] = _T('\0');
        _tcscat(pszFile, pszCommonPath);
        _tcscat(pszFile, g_ppszFileList[ul]);

        //open file if exists
        HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            //touch file
            SYSTEMTIME st;
            FILETIME ft;

            GetSystemTime(&st);

            if(SystemTimeToFileTime(&st, &ft))
            {
                SetFileTime(hFile, NULL, NULL, &ft);
            }

            ::CloseHandle(hFile);
        }

        // Keep running even if one file fails
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\setup\installer\regcpl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	regcpl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\setup\installer\regcpl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <tchar.h>
#include "shfolder.h"


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\setup\installer\regcpl\regcpl.cpp ===
// regcpl.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	BOOL		b_ControliniModified = 0;
	TCHAR		pszPathToControlIni[MAX_PATH] = _T("");
	DWORD		dwRetVal = 0;
	
	// Get the path to the system's CommonProgramFiles folder
	if( SUCCEEDED( SHGetFolderPath( NULL, CSIDL_PROGRAM_FILES_COMMON |CSIDL_FLAG_CREATE, 
					NULL, 0, pszPathToControlIni ) ) )
	{
        TCHAR pszShortPath[MAX_PATH] = _T("");
        if (::GetShortPathName(pszPathToControlIni, pszShortPath, sizeof(pszShortPath)/sizeof(TCHAR)))
        {
             _tcscat(pszShortPath, _T("\\Microsoft Shared\\Speech\\sapi.cpl"));
		    // Modify control.ini on win95 and NT4
		    b_ControliniModified = WritePrivateProfileString("MMCPL", "sapi.cpl", 
								    pszShortPath, "control.ini");
        }


	}

	if( !b_ControliniModified )
	{
		return ERROR_INSTALL_FAILURE;
	}
	else
	{
		return ERROR_SUCCESS;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\setup_whistler\makefile.inc ===
# LCID:  Locale ID in hex.

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

# If language text identifiers ever change, this needs updating.
# Alternatively, move sapi5.inx / sapi5.txt to \nt\mergedcomponents\SetupInfs
# where the makefile.inc there contains the below code for all infs. Hence
# any change there will automatically word with our sapi5.txt file, unless
# it adds new supported languages.

!if "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
LCID=401
!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional
LCID=404
!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
LCID=405
!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
LCID=408
!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
# ???
LCID=408
!elseif "$(LANGUAGE)"=="USA" || "$(LANGUAGE)"=="usa"
# USA
LCID=409
!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
LCID=40D
!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
LCID=40E
!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
LCID=411
!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
LCID=412
!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
LCID=415
!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
LCID=419
!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
LCID=41F
!elseif "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
LCID=804
!endif

PREFLAGS=/DLANGUAGE_ID="0x$(LCID)" -nologo /EP

$(O)\sapi5.inf: sapi5.inx sapi5.txt
    $(CC) $(PREFLAGS) /nologo /c /EP $(@B).txt > $(O)\$(@B).txt1
    unitext -m -o $(O)\$(@B).txt1 $(O)\$(@B).txt2
    copy /b $(@B).inx+$(O)\$(@B).txt2 $(O)\$(@B).tmp1
    prodfilt -u $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -u $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).txt2
    $(STAMP)
    $(TSBINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\backend.h ===
/******************************************************************************
* Backend.h *
*-----------*
*  This is the header file for the CBackend implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 03/01/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

#ifndef Backend_H
#define Backend_H

#ifndef ReverbFX_H
#include "ReverbFX.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef SPCollec_h
#include <SPCollec.h>
#endif

#include "SpTtsEngDebug.h"





static const short MAX_TARGETS_PER_UNIT = 3;          // Max number of knots allowed
static const short MIN_VOICE_PITCH      = 10;         // Lowest voiced pitch (hertz)
static const short UNIT_SIL             = 0;           // Silence phon
static const short SPEECH_FRAME_SIZE	= 5000;        // Output audio uffer...
static const short SPEECH_FRAME_OVER	= 1000;        // ...plus pad

//----------------------------------------------------------
// find a yn corresponding to xn, 
// given (x0, y0), (x1, y1), x0 <= xn <= x1
//----------------------------------------------------------
inline float LinInterp( float x0, float xn, float x1, float y0, float y1 )
{
    return y0 + (y1-y0)*(xn-x0)/(x1-x0);
}

// Math marcos
#define ABS(x) ((x) >= 0 ? (x) : -(x))
#define MAX(x,y) (((x) >= (y)) ? (x) : (y))
#define MIN(x,y) (((x) <= (y)) ? (x) : (y))

static const float LINEAR_BKPT  = 0.1f;
static const float LOG_RANGE    = (-25.0f);

//********************************************************************
//
//  CBackend keeps track of all the state information for the
//  synthesis process.
//
//********************************************************************
class CBackend 
{
public:
    /*--- Constructors/Destructors ---*/
    CBackend ();
    ~CBackend ();

    /*=== Methods =======*/
    HRESULT Init(   IMSVoiceData* pVoiceDataObj, 
                    CFeedChain *pSrcObj, 
                    MSVOICEINFO* pVoiceInfo );
	SPEECH_STATE	GetSpeechState() {return m_SpeechState;}
    void    PrepareSpeech( ISpTTSEngineSite* outputSite );
    HRESULT RenderFrame( );


private:
    HRESULT StartNewUnit();
    long    ProsodyMod(    UNITINFO    *pCurUnit, 
                            long        cInEpochs, 
                            float       durationMpy,
                            long        cMaxOutEpochs);
    void    CleanUpSynth();
    void    ResRecons(  float   *pInRes,
                        long    InSize,
                        float   *pOutRes,
                        long    OutSize,
                        float   scale );
    void    LPCFilter( float *pCurLPC, float *pCurRes, long len, float gain );
    void    FreeSynth( MSUNITDATA* pSynth );
    void    PSOLA_Stretch(  float *pInRes, long InSize, 
                            float *pOutRes, long OutSize,
                            float *pWindow, 
                            long  cWindowSize );
    void    CvtToShort( float *pSrc, long blocksize, long stereoOut, float audioGain );
    void    Release( );
   
    /*=== Member Data ===*/
    CFeedChain      *m_pSrcObj;             // Backend gets its input from here
    MSUNITDATA      m_Synth;                // Unit data from 'Voicedataobj'
    float          *m_pHistory;             // LPC delays
    unsigned long   m_fModifiers;
    float          *m_pHistory2;            // IIR delays
    float          *m_pFilter;              // IIR/FIR coefficients
    long            m_cNumTaps;             // Coefficient count            
    LP_CReverbFX    m_pReverb;              // Reverb object


    long            *m_pMap;                // in/out epoch map
    float           *m_pOutEpoch;           // epoch sizes
    short           *m_pRevFlag;            // true = rev unvoiced

    float           *m_pInRes;              // m_pSynth.pRes
    float           *m_pInEpoch;            // m_pSynth.pEpoch
    float           *m_pLPC;                // m_pSynth->pLPC
    long            m_cOutSamples_Phon;     // sample count
    long            m_durationTarget;       // target sample total
    long            m_silMode;
    float           *m_pSynthTime;          // pCurUnit->pTime
    float           *m_pSynthAmp;           // pCurUnit->pAmp
    long            m_nKnots;               // pCurUnit->nKnots

    SPEECH_STATE    m_SpeechState;          // Either continue or done
    long            m_cOutSamples_Frame;    // Audio output sample count for frame
    float           *m_pSpeechBuf;          // Audio output sample buffer
    ULONG           m_cOutSamples_Total;    // Audio output sample count for Speak
    long            m_EpochIndex;           // Index for render
    long            m_cOutEpochs;           // Count for render


    long            m_vibrato_Phase1;       // Current vibrato phase index
    float           m_VibratoDepth;         // Vibrato gain
    float           m_VibratoFreq;          // Vibrato speed
    long            m_StereoOut;            // TRUE = stereo output
    long            m_BytesPerSample;       // 2 = mono, 4 = stereo
    IMSVoiceData*   m_pVoiceDataObj;        // Voice object
    ULONG           m_cOrder;               // LPC filter order
    float           m_SampleRate;           // I/O rate
    float*          m_pWindow;              // Hanning Window
    long            m_FFTSize;              // FFT length

    // User Controls
    float           m_UnitVolume;           // 0 - 1.0 (linear)
    long            m_MasterVolume;         // 0 - 100 (linear)
    float           m_linearScale;          // Linear taper region scale

    // SAPI audio sink
    ISpTTSEngineSite*   m_pOutputSite;
	bool			m_HasSpeech;
};




//--------------------------------
// Unimplemented
//--------------------------------
static const long BACKEND_BITFLAG_WHISPER     = (1 << 0);
static const long BACKEND_BITFLAG_FIR         = (1 << 1);
static const long BACKEND_BITFLAG_IIR         = (1 << 2);
static const long BACKEND_BITFLAG_REVERB      = (1 << 3);
static const float VIBRATO_DEFAULT_DEPTH      = 0.05f;
static const float VIBRATO_DEFAULT_FREQ       = 3.0f;          // hz

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\alloops.h ===
/******************************************************************************
* AlloOps.h *
*-----------*
*  This is the header file for the following clsses:
*		CAlloCell
*		CAlloList
*		CDuration
*		CSyllableTagger
*		CToneTargets
*		CPitchProsody

  *------------------------------------------------------------------------------
  *  Copyright (C) 1999 Microsoft Corporation		  Date: 03/01/99
  *  All Rights Reserved
  *
*********************************************************************** MC ****/

#ifndef AlloOps_H
#define AlloOps_H

#include "stdafx.h"
#include "commonlx.h"

#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif

#ifndef SPCollec_h
#include <SPCollec.h>
#endif

#include "SpTtsEngDebug.h"

//***************************
// Allophones
//***************************
typedef enum
{	
    _IY_,	_IH_,	_EH_,	_AE_,	_AA_,	_AH_,	_AO_,	_UH_,	_AX_,	_ER_,
    _EY_,	_AY_,	_OY_,	_AW_,	_OW_,	_UW_, 
    _IX_,	_SIL_,	_w_,	_y_,
    _r_,	_l_,	_h_,	_m_,	_n_,	_NG_,	_f_,	_v_,	_TH_,	_DH_,
    _s_,	_z_,	_SH_,	_ZH_,	_p_,	_b_,	_t_,	_d_,	_k_,	_g_,
    _CH_,	_JH_,	_DX_,	 
	_STRESS1_,
    _STRESS2_,
    _EMPHSTRESS_,
    _SYLLABLE_,
} ALLO_CODE;

static const long NUMBER_OF_ALLO = (_SYLLABLE_ + 1);

//-----------------------------------
// For 2-word allo conversion
//-----------------------------------
static const short NO_IPA = 0;



// XXXX XXXX XXXX XXXX XXXX bLis ssoo ttBB

// X = unused
// B = boundary type
// t = syllable type
// o = vowel order
// s = stress type
// i = word initial consonant
// L = syLlable start
// b = break

enum ALLOTAGS
{	
    WORD_START			= (1 << 0),
        TERM_BOUND			= (1 << 1),
        BOUNDARY_TYPE_FIELD = WORD_START | TERM_BOUND,			// mask
        
        WORD_END_SYLL		= (1 << 2),
        TERM_END_SYLL		= (1 << 3),
        SYLLABLE_TYPE_FIELD = WORD_END_SYLL | TERM_END_SYLL,	// mask
        
        FIRST_SYLLABLE_IN_WORD			= (1 << 4),  // in multi-syllable word
        MID_SYLLABLE_IN_WORD			= (2 << 4),
        LAST_SYLLABLE_IN_WORD			= (3 << 4),
        MORE_THAN_ONE_SYLLABLE_IN_WORD	= LAST_SYLLABLE_IN_WORD,  // either bit is set
        ONE_OR_NO_SYLLABLE_IN_WORD		= 0x0000,  // niether bits are set
        SYLLABLE_ORDER_FIELD			= LAST_SYLLABLE_IN_WORD,  // mask
        
        PRIMARY_STRESS		= (1 << 6),
        SECONDARY_STRESS	= (1 << 7),
        EMPHATIC_STRESS 	= (1 << 8),
        IS_STRESSED 		= PRIMARY_STRESS | SECONDARY_STRESS | EMPHATIC_STRESS,
        PRIM_OR_EMPH_STRESS = PRIMARY_STRESS | EMPHATIC_STRESS,
        STRESS_FIELD		= PRIMARY_STRESS | SECONDARY_STRESS | EMPHATIC_STRESS,	// mask
        
        WORD_INITIAL_CONSONANT	= (1 << 9), 		 // up to 1st vowel in word
        STRESSED_INITIAL_CONS	= (IS_STRESSED + WORD_INITIAL_CONSONANT),
        SYLLABLE_START			= (1 << 10),
        
        SIL_BREAK			= (1 << 11),
};


//***************************
// AlloFlags
//***************************
enum ALLOFLAGS
{	
    KVOWELF = (1<<0),
        KCONSONANTF = (1<<1),
        KVOICEDF = (1<<2),
        KVOWEL1F = (1<<3),
        KSONORANTF = (1<<4),
        KSONORANT1F = (1<<5),
        KNASALF = (1<<6),
        KLIQGLIDEF = (1<<7),
        KSONORCONSONF = (1<<8),
        KPLOSIVEF = (1<<9),
        KPLOSFRICF = (1<<10),
        KOBSTF = (1<<11),
        KSTOPF = (1<<12),
        KALVEOLARF = (1<<13),
        KVELAR = (1<<14),
        KLABIALF = (1<<15),
        KDENTALF = (1<<16),
        KPALATALF = (1<<17),
        KYGLIDESTARTF = (1<<18),
        KYGLIDEENDF = (1<<19),
        KGSTOPF = (1<<20),
        KFRONTF = (1<<21),
        KDIPHTHONGF = (1<<22),
        KHASRELEASEF = (1<<23),
        KAFFRICATEF = (1<<24),
        KLIQGLIDE2F = (1<<25),
        KVOCLIQ = (1<<26),
        KFRIC = (1<<27),
        
        KFLAGMASK1 = (KLABIALF+KDENTALF+KPALATALF+KALVEOLARF+KVELAR+KGSTOPF),
        KFLAGMASK2 = (KALVEOLARF-1),
};


#define BOUNDARY_BASE   1000
enum TOBI_BOUNDARY
{
    K_NOBND = 0,
    K_LMINUS = BOUNDARY_BASE,   // fall
    K_HMINUS,                   // none
    K_LMINUSLPERC,
    K_LMINUSHPERC,
    K_HMINUSHPERC,
    K_HMINUSLPERC,
};




enum TUNE_TYPE
{
    NULL_BOUNDARY = 0,  // no boundary NOTE: always put this at the beginning
    PHRASE_BOUNDARY,    // comma
    EXCLAM_BOUNDARY,    // exclamatory utterance terminator
    YN_QUEST_BOUNDARY,     // yes-no question terminator
    WH_QUEST_BOUNDARY,     // yes-no question terminator
    DECLAR_BOUNDARY,    // declarative terminator
    PAREN_L_BOUNDARY,   // left paren
    PAREN_R_BOUNDARY,   // right paren
    QUOTE_L_BOUNDARY,   // left quote
    QUOTE_R_BOUNDARY,   // right quote
	PHONE_BOUNDARY,
	TOD_BOUNDARY,
	ELLIPSIS_BOUNDARY,

    SUB_BOUNDARY_1,     // NOTE: always put these at the end
    SUB_BOUNDARY_2,
    SUB_BOUNDARY_3,
    SUB_BOUNDARY_4,
    SUB_BOUNDARY_5,
    SUB_BOUNDARY_6,
	NUMBER_BOUNDARY,

	TAIL_BOUNDARY,
};


//***************************
// ToBI Constants
//***************************
// !H is removed from consideration in the first pass processing
// !H can possibly be recovered from analysis of the labeling and
// contour at later stages (tilt, prominence, pitch range, downstep)
#define ACCENT_BASE   1
enum TOBI_ACCENT
{
    K_NOACC = 0,
    K_HSTAR = ACCENT_BASE,  // peak                         rise / fall
    K_LSTAR,                // acc syll nucleus valley      early fall
    K_LSTARH,               // late rise
    K_RSTAR,                //
    K_LHSTAR,               // early rise
    K_DHSTAR,               // 
	K_HSTARLSTAR,
};



enum BOUNDARY_SOURCE
{
    BND_NoSource = 0,

	//-- Phrase boundary rules
	BND_PhraseRule1,
	BND_PhraseRule2,
	BND_PhraseRule3,
	BND_PhraseRule4,
	BND_PhraseRule5,
	BND_PhraseRule6,
	BND_PhraseRule7,
	BND_PhraseRule8,
	BND_PhraseRule9,
	BND_PhraseRule10,
	BND_PhraseRule11,
	BND_PhraseRule12,
	BND_PhraseRule13,

	//-- ToBI
	BND_YNQuest,
	BND_WHQuest,
	BND_Period,
	BND_Comma,

	//--Templates
	BND_NumberTemplate,		// Should never get this!
	BND_IntegerQuant,
	BND_Currency_DOLLAR,
	BND_Frac_Num,

	BND_Phone_COUNTRY,
	BND_Phone_AREA,
	BND_Phone_ONE,
	BND_Phone_DIGITS,

	BND_TimeOFDay_HR,
	BND_TimeOFDay_AB,
	BND_Ellipsis,

	BND_ForcedTerm,			// Should never get this!

    BND_IDontKnow,
};

enum ACCENT_SOURCE
{
    ACC_NoSource = 0,

	//-- Phrase boundary rules
	ACC_PhraseRule1,
	ACC_PhraseRule2,
	ACC_PhraseRule3,
	ACC_PhraseRule4,
	ACC_PhraseRule5,
	ACC_PhraseRule6,
	ACC_PhraseRule7,
	ACC_PhraseRule8,
	ACC_PhraseRule9,
	ACC_PhraseRule10,
	ACC_PhraseRule11,
	ACC_PhraseRule12,
	ACC_PhraseRule13,

	//-- ToBI
	ACC_InitialVAux,
	ACC_FunctionSeq,
	ACC_ContentSeq,
	ACC_YNQuest,
	ACC_Period,
	ACC_Comma,

	//--Templates
	ACC_IntegerGroup,
	ACC_NumByNum,
	ACC_Frac_DEN,		// "half", "tenths", etc.
	ACC_Phone_1stArea,	// 1st digit in area code
	ACC_Phone_3rdArea,	// 3rd digit in area code
	ACC_Phone_1st3,		
	ACC_Phone_3rd3,		
	ACC_Phone_1st4,
	ACC_Phone_3rd4,
	ACC_TimeOFDay_HR,
	ACC_TimeOFDay_1stMin,
	ACC_TimeOFDay_M,

	ACC_PhoneBnd_AREA,
	ACC_PhoneBnd_34,
	ACC_PhoneBnd_4,

	ACC_IDontKnow,
};



enum SILENCE_SOURCE
{
    SIL_NoSource = 0,

	SIL_Term,
	SIL_QuoteStart,
	SIL_QuoteEnd,
	SIL_ParenStart,
	SIL_ParenEnd,
	SIL_Emph,
	SIL_SubBound,		// Should never see this (gets removed)
	SIL_XML,

	//-- Prosody templates
	SIL_TimeOfDay_HR,
	SIL_TimeOfDay_AB,

	SIL_Phone_COUNTRY,
	SIL_Phone_AREA,
	SIL_Phone_ONE,
	SIL_Phone_DIGITS,

	SIL_Fractions_NUM,
	SIL_Currency_DOLLAR,
	SIL_Integer_Quant,

	SIL_Head,
	SIL_Tail,
	SIL_Ellipsis,

	SIL_ForcedTerm,			// Should never get this!
};




static const short TOKEN_LEN_MAX	= 20;

class CFEToken
{
public:
    CFEToken();
    ~CFEToken();
    
    WCHAR           tokStr[TOKEN_LEN_MAX];
    long            tokLen;
    PRONSRC 		m_PronType;

    long            phon_Len;
    ALLO_CODE       phon_Str[SP_MAX_PRON_LENGTH];		// Allo string
    ENGPARTOFSPEECH	POScode;
    PROSODY_POS     m_posClass;

    ULONG           srcPosition;					// Source position for this token
    ULONG           srcLen; 						// Source length for this token
    ULONG           sentencePosition;				// Source position for sentence
    ULONG           sentenceLen; 					// Source length for sentence
    ULONG           user_Volume;					// 1 - 101
    long            user_Rate;						// -10 - 10
    long            user_Pitch; 					// -10 - 10
    long            user_Emph;						// 0 or 5
    ULONG           user_Break; 					// ms of silence
    CBookmarkList   *pBMObj;
    TOBI_ACCENT     m_Accent;                        // accent prosodic control
    long            m_Accent_Prom;                   // prominence prosodic control
    TOBI_BOUNDARY   m_Boundary;                        // boundary tone prosodic control
    long            m_Boundary_Prom;                   // prominence prosodic control
    TUNE_TYPE       m_TuneBoundaryType;             // Current token is a boundary
	float			m_TermSil;						// Pad word with silence (in sec)
    float           m_DurScale;						// Duration ratio
	float			m_ProsodyDurScale;
	float			m_PitchBaseOffs;				// Relative baseline pitch offset in octaves
	float			m_PitchRangeScale;				// Pitch range offset scale (0 - 2.0) 

	//--- Diagnostic
	ACCENT_SOURCE		m_AccentSource;		
	BOUNDARY_SOURCE		m_BoundarySource;
	SILENCE_SOURCE		m_SilenceSource;
};
typedef CSPList<CFEToken*,CFEToken*> CFETokenList;



class CAlloCell
{
public:
    CAlloCell();
    ~CAlloCell();
    //--------------------------------
    // Member Vars
    //--------------------------------
    ALLO_CODE	m_allo;
    short		m_dur;
    float		m_ftDuration;
    float       m_UnitDur;
    short		m_knots;
    float		m_ftTime[KNOTS_PER_PHON];
    float		m_ftPitch[KNOTS_PER_PHON];
    long		m_ctrlFlags;
    TOBI_ACCENT m_ToBI_Accent;
    long        m_Accent_Prom;                   // prominence prosodic control
    TOBI_BOUNDARY   m_ToBI_Boundary;
    long        m_Boundary_Prom;                 // prominence prosodic control
    long        m_PitchBufStart;
    long        m_PitchBufEnd;
    ULONG		m_user_Volume;
    long		m_user_Rate;
    long		m_user_Pitch;
    long		m_user_Emph;
    ULONG		m_user_Break;
    ULONG       m_Sil_Break;
    float		m_Pitch_HI;
    float		m_Pitch_LO;
    ULONG		m_SrcPosition;
    ULONG		m_SrcLen;
    ULONG       m_SentencePosition;				// Source position for sentence
    ULONG       m_SentenceLen; 					// Source length for sentence
    TUNE_TYPE   m_TuneBoundaryType;
    TUNE_TYPE   m_NextTuneBoundaryType;
    CBookmarkList	*m_pBMObj;
    float       m_DurScale;						// Duration ratio
	float		m_ProsodyDurScale;
	float		m_PitchBaseOffs;				// Relative baseline pitch offset in octaves
	float		m_PitchRangeScale;				// Pitch range offset scale (0 - 2.0) 

	//--- Diagnostic
	ACCENT_SOURCE		m_AccentSource;		
	BOUNDARY_SOURCE		m_BoundarySource;
	SILENCE_SOURCE		m_SilenceSource;
	char				*m_pTextStr;
};





class CAlloList
{
public:
    CAlloList();
    ~CAlloList();
    //--------------------------------
    // Methods
    //--------------------------------
    CAlloCell *GetCell( long index );
    CAlloCell *GetTailCell();
    long GetCount();
    bool WordToAllo( CFEToken *pPrevTok, CFEToken *pTok, CFEToken *pNextTok, CAlloCell *pEndCell );
	CAlloCell *GetHeadCell()
	{
		m_ListPos = m_AlloCellList.GetHeadPosition();
		return m_AlloCellList.GetNext( m_ListPos );
	}
	CAlloCell *GetNextCell()
	{
		if( m_ListPos )
		{
			return m_AlloCellList.GetNext( m_ListPos );
		}
		else
		{
			//-- We're at end of list!
			return NULL;
		}
	}
	//-- For debug only
    void OutAllos();

private:
    //--------------------------------
    // Member Vars
    //--------------------------------
    long		m_cAllos;
	SPLISTPOS	m_ListPos;
    CSPList<CAlloCell*,CAlloCell*> m_AlloCellList;
};



//-----------------------------------
// Speaking Rate parameters
//-----------------------------------
static const float MAX_SIL_DUR = 1.0f; 			// seconds
static const float MIN_ALLO_DUR = 0.011f;		// seconds
static const float MAX_ALLO_DUR = 5.0f;		// seconds


class CDuration
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void AlloDuration( CAlloList *pAllos, float rateRatio );
    
private:
    void Pause_Insertion( long userDuration, long silBreak );
    void PhraseFinal_Lengthen( long cellCount );
    long Emphatic_Lenghen( long lastStress );
    //--------------------------------
    // Member vars
    //--------------------------------
    float   m_DurHold;
	float	m_TotalDurScale;
	float	m_durationPad;
    
    ALLO_CODE	m_cur_Phon;
    long		m_cur_PhonCtrl;
    long		m_cur_PhonFlags;
    long		m_cur_SyllableType;
    short		m_cur_VowelFlag;
    long		m_cur_Stress;
    ALLO_CODE	m_prev_Phon;
    long		m_prev_PhonCtrl;
    long		m_prev_PhonFlags;
    ALLO_CODE	m_next_Phon;
    long		m_next_PhonCtrl;
    long		m_next_PhonFlags;
    ALLO_CODE	m_next2_Phon;
    long		m_next2_PhonCtrl;
    long		m_next2_PhonFlags;
    TUNE_TYPE   m_NextBoundary, m_CurBoundary;
};






typedef struct
{ 
    ALLO_CODE	allo;
    long		ctrlFlags;
}ALLO_ARRAY;




class CSyllableTagger
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void TagSyllables( CAlloList *pAllos );
    
private:
    void MarkSyllableOrder( long scanIndex);
    void MarkSyllableBoundry( long scanIndex);
    void MarkSyllableStart();
    short Find_Next_Word_Bound( short index );
    short If_Consonant_Cluster( ALLO_CODE Consonant_1st, ALLO_CODE Consonant_2nd);
	void ListToArray( CAlloList *pAllos );
	void ArrayToList( CAlloList *pAllos );
    
    //--------------------------------
    // Member vars
    //--------------------------------
    ALLO_ARRAY	*m_pAllos;
    long		m_numOfCells;
};


enum { TARG_PER_ALLO_MAX = 2 }; // One for accent and one for boundary



enum TUNE_STYLE
{
    FLAT_TUNE = 0,      // flat
    DESCEND_TUNE,       // go down
    ASCEND_TUNE,        // go up
};

//------------------
// Global Constants
//------------------
static const float PITCH_BUF_RES = (float)0.010;
static const float K_HSTAR_OFFSET = (float)0.5;
static const float K_HDOWNSTEP_COEFF  = (float)0.5;


//------------------
// Macros
//------------------
#define CeilVal(x) ((m_CeilSlope * x) + m_CeilStart)
#define FloorVal(x) ((m_FloorSlope * x) + m_FloorStart)
#define RefVal(x) ((m_RefSlope * x) + m_RefStart)



class CPitchProsody
{
public:
    //--------------------------------
    // Methods
    //--------------------------------
    void AlloPitch( CAlloList *pAllos, float baseLine, float pitchRange );
    
private:
    float DoPitchControl( long pitchControl, float basePitch );
    void PitchTrack();
    void SetDefaultPitch();
    void GetKnots();
    void NewTarget( long index, float value );

    //--------------------------------
    // Member vars
    //--------------------------------
    CAlloList		*m_pAllos;
    long			m_numOfCells;

    float           m_TotalDur;     // phrase duration in seconds
    TUNE_STYLE      m_Tune_Style;
    float           *m_pContBuf;
    float           m_OffsTime;
    TOBI_ACCENT     m_CurAccent;

	//------------------------
	// Diagnostic
	//------------------------
	ACCENT_SOURCE		m_CurAccentSource;		
	BOUNDARY_SOURCE		m_CurBoundarySource;
	char				*m_pCurTextStr;
};



#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\alphanorm.cpp ===
/***********************************************************************************************
* AlphaNorm.cpp *
*---------------*
*  Description:
*   These functions normalize mostly-alpha strings.
*-----------------------------------------------------------------------------------------------
*  Created by AARONHAL                                                           August 3, 1999
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
***********************************************************************************************/

#include "stdafx.h"
#include "stdsentenum.h"

/***********************************************************************************************
* IsAbbreviationEOS *
*-------------------*
*   Description:
*       Abbreviations which get here are ALWAYS abbreviations.  This function tries to determine 
*   whether or not the period at the end of the abbreviation is the end of the sentence.  
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsAbbreviationEOS( const AbbrevRecord* pAbbreviation, CItemList &ItemList, SPLISTPOS ItemPos, 
                                         CSentItemMemory &MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IsAbbreviationEOS" );
    HRESULT hr = S_OK;
    BOOL fMatchedEOS = false;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = (WCHAR*) m_pEndOfCurrToken, *pTempEndChar = (WCHAR*) m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
                fMatchedEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                    fMatchedEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }

    //--- Insert abbreviation into the ItemList
    if ( SUCCEEDED( hr ) )
    {
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long) (m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IsAbbreviationEOS */

/***********************************************************************************************
* IfEOSNotAbbreviation *
*----------------------*
*   Description:
*       Abbreviations which get here may or may not be abbreviations.  If the period is EOS,
*   this is not an abbreviation (and return will be E_INVALIDARG), otherwise, it is an
*   abbreviation.
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IfEOSNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList &ItemList, SPLISTPOS ItemPos, 
                                            CSentItemMemory &MemoryManager, BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IfEOSNotAbbreviation" );
    HRESULT hr = S_OK;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( !pTempNextChar )
        {
            hr = E_INVALIDARG;
        }

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }
    
    if ( *pfIsEOS )
    {
        //--- EOS - not an abbreviation
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Insert abbreviation into the ItemList
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IfEOSNotAbbreviation */

/***********************************************************************************************
* IfEOSAndLowercaseNotAbbreviation *
*----------------------------------*
*   Description:
*       Abbreviations which get here may or may not be abbreviations.  If the period is EOS,
*   and the next item is lowercase this is not an abbreviation (and return will be E_INVALIDARG), 
*   otherwise, it is an abbreviation.
*
*   If match made:
*       Sets the Item in the ItemList at ItemPos to the abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IfEOSAndLowercaseNotAbbreviation( const AbbrevRecord* pAbbreviation, CItemList &ItemList, 
                                                        SPLISTPOS ItemPos, CSentItemMemory &MemoryManager, 
                                                        BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IfEOSAndLowercaseNotAbbreviation" );
    HRESULT hr = S_OK;

    //--- Need to determine whether the abbreviation's period is also the end of the sentence.
    if ( !(*pfIsEOS) )
    {
        //--- Advance to the beginning of the next token
        const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
        const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
        hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

        if ( SUCCEEDED( hr ) )
        {

            //--- If we have reached the end of the buffer, consider the abbreviation's period as
            //--- the end of the sentence.
            if ( !pTempNextChar )
            {
                *pfIsEOS = true;
            }
            //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
            //--- the next token is a common first word (which must be capitalized).
            else if ( IsCapital( *pTempNextChar ) )
            {
                WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                //--- Try to match a first word.
                WCHAR temp = (WCHAR) *pTempEndOfItem;
                *pTempEndOfItem = 0;
                
                if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                              sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                {
                    *pfIsEOS = true;
                }

                *pTempEndOfItem = temp;
            }
        }
    }
    
    if ( *pfIsEOS &&
         !iswupper( *m_pNextChar ) )
    {
        //--- EOS - not an abbreviation
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Insert abbreviation into the ItemList
        CSentItem Item;

        Item.pItemSrcText       = m_pNextChar;
        Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
        Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                  (long)( m_pNextChar - m_pCurrFrag->pTextStart );
        Item.ulNumWords         = 1;
        Item.Words = (TTSWord*) MemoryManager.GetMemory( sizeof(TTSWord), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( Item.Words, sizeof(TTSWord) );
            Item.Words[0].pXmlState  = &m_pCurrFrag->State;
            Item.Words[0].pWordText  = Item.pItemSrcText;
            Item.Words[0].ulWordLen  = Item.ulItemSrcLen;
            Item.Words[0].pLemma     = Item.pItemSrcText;
            Item.Words[0].ulLemmaLen = Item.ulItemSrcLen;
            Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSAbbreviationInfo), &hr );
            if ( SUCCEEDED( hr ) )
            {
                if ( NeedsToBeNormalized( pAbbreviation ) )
                {
                    Item.pItemInfo->Type = eABBREVIATION_NORMALIZE;
                }
                else
                {
                    Item.pItemInfo->Type = eABBREVIATION;
                }
                ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation = pAbbreviation;
                ItemList.SetAt( ItemPos, Item );
            }
        }
    }

    return hr;
} /* IfEOSNotAbbreviation */

/***********************************************************************************************
* SingleOrPluralAbbreviation *
*----------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine whether it should take its singular form, plural form, or some alternate.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::SingleOrPluralAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                  CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SingleOrPluralAbbreviation" );
    HRESULT hr = S_OK;

    //--- Get Item which comes before the abbreviation
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pPron->pronArray[PRON_A].POScount = 1;
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;
        pPron->hasAlt                     = false;
        pPron->altChoice                  = PRON_A;
        //--- Abbreviation table pronunciations are basically just vendor lex prons...
        pPron->pronType                   = eLEXTYPE_PRIVATE1;

        //--- If a cardinal number, need to do singular vs. plural logic
        if ( TempItem.pItemInfo->Type == eNUM_CARDINAL ||
             TempItem.pItemInfo->Type == eDATE_YEAR )
        {
            if ( ( TempItem.ulItemSrcLen == 1 &&
                   wcsncmp( TempItem.pItemSrcText, L"1", 1 ) == 0 ) ||
                 ( TempItem.ulItemSrcLen == 2 &&
                   wcsncmp( TempItem.pItemSrcText, L"-1", 2 ) == 0 ) )
            {
                //--- Use singular form - first entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
            else
            {
                //--- Use plural form - second entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
        //--- If a decimal number, pick plural
        else if ( TempItem.pItemInfo->Type == eNUM_DECIMAL )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
        //--- If an ordinal number or fraction, pick singular
        else if ( TempItem.pItemInfo->Type == eNUM_ORDINAL )
        {
            //--- Use singular form - first entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Fractions and mixed fractions require some more work...
        else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
        {
            if ( ( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard )
            {
                //--- Standard fractions (e.g. 11/20) get the plural form
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;

            }
            else
            {
                //--- Singular form with [of a] or [of an] inserted beforehand
                if ( bsearch( (void*) pAbbrevInfo->pPron1, (void*) g_Vowels, sp_countof( g_Vowels ), 
                     sizeof( WCHAR ), CompareWCHARAndWCHAR ) )
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfAn );
                    pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfAn );
                }
                else
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfA );
                    pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfA );
                }
                wcscat( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   += wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
        else if ( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION )
        {
            //--- Plural form
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;

        }
        //--- Special case - preceded by "one"
        else if ( TempItem.ulItemSrcLen == 3 &&
                  wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 )
        {
            //--- Use singular form - first entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Special case - Number cu. MeasurementAbbrev (e.g. 10 cu. cm, 1 cu cm)
        //--- Special case - Number fl. MeasurementAbbrev (e.g. 10 fl. oz., 10 fl oz)
        else if ( ( TempItem.ulItemSrcLen == 2 &&
                    ( _wcsnicmp( TempItem.pItemSrcText, L"cu", 2 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"sq", 2 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"fl", 2 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 3 &&
                    ( _wcsnicmp( TempItem.pItemSrcText, L"cu.", 3 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"sq.", 3 ) == 0 ||
                      _wcsnicmp( TempItem.pItemSrcText, L"fl.", 3 ) == 0 ) ) )
        {
            if ( TempPos )
            {
                TempItem = ItemList.GetPrev( TempPos );
                //--- If a cardinal number, need to do singular vs. plural logic
                if ( TempItem.pItemInfo->Type == eNUM_CARDINAL )
                {
                    if ( ( TempItem.ulItemSrcLen == 1 &&
                           wcsncmp( TempItem.pItemSrcText, L"1", 1 ) == 0 ) ||
                         ( TempItem.ulItemSrcLen == 2 &&
                           wcsncmp( TempItem.pItemSrcText, L"-1", 2 ) == 0 ) )
                    {
                        //--- Use singular form - first entry
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                        pPron->POSchoice                    = pAbbrevInfo->POS1;
                    }
                    else
                    {
                        //--- Use plural form - second entry
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                        pPron->POSchoice                    = pAbbrevInfo->POS2;
                    }
                }
                //--- If a decimal number, pick plural
                else if ( TempItem.pItemInfo->Type == eNUM_DECIMAL )
                {
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
                //--- If an ordinal number or fraction, pick singular
                else if ( TempItem.pItemInfo->Type == eNUM_ORDINAL )
                {
                    //--- Use singular form - first entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                    pPron->POSchoice                    = pAbbrevInfo->POS1;
                }
                //--- Fractions and mixed fractions require some more work...
                else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
                {
                    if (( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard ) 
                    {
						//--- Standard fractions (e.g. 11/20) get the plural form
						wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
						pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
					    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
					    pPron->POSchoice                    = pAbbrevInfo->POS2;
                    }
                    else
                    {
                        //--- Singular form with [of a] or [of an] inserted beforehand
						//--- (this was handled when processing 'cu' or 'sq')
                        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                        pPron->POSchoice                    = pAbbrevInfo->POS1;
                    }
                }
                else if ( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION )
                {
                    //--- Plural form
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;

                }
                //--- Special case - preceded by "one"
                else if ( TempItem.ulItemSrcLen == 3 &&
                          wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 )
                {
                    //--- Use singular form - first entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                    pPron->POSchoice                    = pAbbrevInfo->POS1;
                }
                //--- Default behavior
                else
                {
                    //--- Use plural form - second entry
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
            }
        }
        //--- Check for number words - just cover through 99...
        else if ( ( TempItem.ulItemSrcLen == 3 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"two", 3 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"six", 3 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"ten", 3 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 4 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"four", 4 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"five", 4 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"nine", 4 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 5 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"three", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"seven", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eight", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"forty", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fifty", 5 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"sixty", 5 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 6 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"twenty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"thirty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eighty", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"ninety", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eleven", 6 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"twelve", 6 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 7 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"seventy", 7 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fifteen", 7 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"sixteen", 7 ) == 0 ) ) ||
                  ( TempItem.ulItemSrcLen == 8 &&
                    ( wcsncmp( TempItem.pItemSrcText, L"thirteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"fourteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"eighteen", 8 ) == 0 ||
                      wcsncmp( TempItem.pItemSrcText, L"nineteen", 8 ) == 0 ) ) )
        {
            //--- Use plural form - second entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;    
        }                    
        //--- Default behavior
        else
        {
            //--- Has alternate when non-number precedes - special case
            if ( pAbbrevInfo->pPron3 )
            {
                //--- Use initial form - third entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
                pPron->POSchoice                    = pAbbrevInfo->POS3;
            }
            else
            {
                //--- Use plural form - second entry
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
    }
    //--- Default behavior
    else if ( hr == E_INVALIDARG )
    {
        hr = S_OK;

        //--- Has alternate when non-number precedes - special case
        if ( pAbbrevInfo->pPron3 )
        {
            //--- Use initial form - third entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
            pPron->POSchoice                    = pAbbrevInfo->POS3;
        }
        else
        {
            //--- Use plural form - second entry
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* SingleOrPluralAbbreviation */

/***********************************************************************************************
* DoctorDriveAbbreviation *
*-------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine whether it should be Doctor (Saint) or Drive (Street).
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::DoctorDriveAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                               CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SingleOrPluralAbbreviation" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;
    BOOL fDoctor = false;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get Item which comes after the Abbreviation
    SPLISTPOS TempPos = ListPos;
    if ( !ListPos )
    {
        //--- Go with Drive - end of buffer cannot be followed by a name...
        fDoctor = false;
        fMatch  = true;
    }
    else
    {
        TTSSentItem TempItem = ItemList.GetNext( TempPos );
        if ( TempItem.eItemPartOfSpeech == MS_EOSItem )
        {
            //--- Go with Drive - end of buffer cannot be followed by a name...
            fDoctor = false;
            fMatch  = true;
        }
        else
        {
            ULONG index = 0;

            //--- Try to match a Name (an uppercase letter followed by lowercase letters)
            if ( TempItem.ulItemSrcLen > 0 &&
                 iswupper( TempItem.pItemSrcText[index] ) )
            {
                index++;
                while ( index < TempItem.ulItemSrcLen &&
                        iswlower( TempItem.pItemSrcText[index] ) )
                {
                    index++;
                }
                //--- Check for possessives - RAID 5823
                if ( index == TempItem.ulItemSrcLen - 2    &&
                     TempItem.pItemSrcText[index+1] == L'\'' &&
                     TempItem.pItemSrcText[index+2] == L's' )
                {
                    index += 2;
                }

                //--- Check for directions - North, South, West, East, Ne, Nw, Se, Sw, N, S, E, W
                if ( index == TempItem.ulItemSrcLen &&
                     wcsncmp( TempItem.pItemSrcText, L"North", 5 ) != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"South", 5 ) != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"West", 4 )  != 0 &&
                     wcsncmp( TempItem.pItemSrcText, L"East", 4 )  != 0 &&
                     !( TempItem.ulItemSrcLen == 2 &&
                        ( wcsncmp( TempItem.pItemSrcText, L"Ne", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Nw", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Se", 2 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"Sw", 2 ) == 0 ) ) &&
                     !( TempItem.ulItemSrcLen == 1 &&
                        ( wcsncmp( TempItem.pItemSrcText, L"N", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"S", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"E", 1 ) == 0 ||
                          wcsncmp( TempItem.pItemSrcText, L"W", 1 ) == 0 ) ) )
                {
                    //--- Check for name previous item
                    TempPos = ListPos;

                    ItemList.GetPrev( TempPos );
                    if ( TempPos )
                    {
                        ItemList.GetPrev( TempPos );
                        if ( TempPos )
                        {
                            TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                            index = 0;

                            if ( PrevItem.ulItemSrcLen > 0 &&
                                 iswupper( PrevItem.pItemSrcText[index++] ) )
                            {
                                while ( index < PrevItem.ulItemSrcLen &&
                                        islower( PrevItem.pItemSrcText[index] ) )
                                {
                                    index++;
                                }
                                if ( index == PrevItem.ulItemSrcLen )
                                {
                                    //--- Go with Drive - names before and after, e.g. Main St. Washington, D.C.
                                    fDoctor = false;
                                    fMatch  = true;
                                }
                            }
                        }
                    }                                    

                    if ( !fMatch )
                    {
                        //--- Go with Doctor - matched a Name after and not a name before
                        fDoctor = true;
                        fMatch  = true;
                    }
                }
                else if ( index == 1                    &&
                          TempItem.ulItemSrcLen == 2    &&
                          TempItem.pItemSrcText[index] == L'.' )
                {
                    //--- Go with Doctor - matched an initial
                    fDoctor = true;
                    fMatch  = true;
                }
            }
        }
    }

    if ( !fMatch ) 
    {
        //--- Try to get previous item...
        BOOL fSentenceInitial = false;
        TempPos = ListPos;
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                ItemList.GetPrev( TempPos );
                if ( !TempPos )
                {
                    fSentenceInitial = true;
                }
                else
                {
                    TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                    if ( PrevItem.pItemInfo->Type == eOPEN_PARENTHESIS ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACKET     ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACE       ||
                         PrevItem.pItemInfo->Type == eSINGLE_QUOTE     ||
                         PrevItem.pItemInfo->Type == eDOUBLE_QUOTE )
                    {
                        fSentenceInitial = true;
                    }
                }
            }
        }
        //--- Sentence initial - go with Doctor
        if ( fSentenceInitial )
        {
            fDoctor = true;
            fMatch  = true;
        }
        //--- Default - go with Drive
        else
        {
            fDoctor = false;
            fMatch = true;
        }
    }

    if ( fDoctor )
    {
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
        pPron->POSchoice                    = pAbbrevInfo->POS1;
    }
    else
    {  
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
    }


    return hr;
} /* DoctorDriveAbbreviation */

/***********************************************************************************************
* AbbreviationFollowedByDigit *
*-----------------------------*
*   Description:
*       At this point, we are already sure that the item is an abbreviation, and just need to
*   determine which pronunciation to go with.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::AbbreviationFollowedByDigit( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                   CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AbbreviationFollowedByDigit" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get Item which comes after the Abbreviation
    SPLISTPOS TempPos = ListPos;
    if ( !ListPos )
    {
        //--- Go with pron 2
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
    }
    else
    {
        TTSSentItem TempItem = ItemList.GetNext( TempPos );

        if ( TempItem.ulItemSrcLen > 0 &&
             iswdigit( TempItem.pItemSrcText[0] ) )
        {
            //--- Go with pron 1
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        else
        {
            //--- Go with pron 2
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* AbbreviationFollowedByDigit */

/***********************************************************************************************
* AllCapsAbbreviation *
*---------------------*
*   Description:
*       This functions disambiguates abbreviations without periods which are pronounced
*   differently if they are all capital letters.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::AllCapsAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                           CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AllCapsAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        //--- All Caps - go with first pronunciation
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Not All Caps - go with second pronunciation
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* AllCapsAbbreviation */

/***********************************************************************************************
* CapitalizedAbbreviation *
*-------------------------*
*   Description:
*       This functions disambiguates abbreviations without periods which are pronounced
*   differently if they begin with a capital letter.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::CapitalizedAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                               CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::CapitalizedAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        //--- Capitalized - go with first pronunciation
        if ( iswupper( TempItem.pItemSrcText[0] ) )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
        //--- Not Capitalized - go with second pronunciation
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }

    return hr;
} /* CapitalizedAbbreviation */

/***********************************************************************************************
* SECAbbreviation *
*-----------------*
*   Description:
*       This functions disambiguates SEC, Sec, and sec and so forth...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::SECAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                       CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::SECAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        //--- All Caps - go with SEC
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron3 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS3;
            pPron->POSchoice                    = pAbbrevInfo->POS3;
        }
        //--- Not All Caps - do SingleOrPlural disambiguation
        else
        {
            SingleOrPluralAbbreviation( pAbbrevInfo, pPron, ItemList, ListPos );
        }
    }

    return hr;
} /* SECAbbreviation */

/***********************************************************************************************
* DegreeAbbreviation *
*--------------------*
*   Description:
*       This functions disambiguates C, F, and K (Celsius, Fahrenheit, Kelvin)
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::DegreeAbbreviation( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                          CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::DegreeAbbreviation" );
    HRESULT hr = S_OK;

    pPron->pronArray[PRON_A].POScount = 1;
    pPron->pronArray[PRON_B].POScount = 0;
    pPron->pronArray[PRON_B].phon_Len = 0;
    pPron->hasAlt                     = false;
    pPron->altChoice                  = PRON_A;
    //--- Abbreviation table pronunciations are basically just vendor lex prons...
    pPron->pronType                   = eLEXTYPE_PRIVATE1;

    //--- Get this item and previous item
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem, PrevItem;
    BOOL fLetter = false;
    
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TempItem = ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                PrevItem = ItemList.GetPrev( TempPos );
                if ( PrevItem.pItemInfo->Type != eNUM_DEGREES )
                {
                    fLetter = true;
                }
            }
            else
            {
                fLetter = true;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( fLetter )
        {
            //--- This word is just the letter C, F, or K - second pron
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
        //--- This word is the degree expansion - Celsius, Fahrenheit, or Kelvin
        else
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
        }
    }

    return hr;
} /* DegreeAbbreviation */

/***********************************************************************************************
* IsInitialIsm *
*--------------*
*   Description:
*       Checks the next token in the text stream to determine if it is an initialism.  Also 
*   tries to determine whether or not the period at the end of the initialism is the end of 
*   the sentence.  
*
*   If match made:
*       Advances m_pNextChar to the appropriate position (either the period at the end of the 
*   abbreviation, or just past that period).  Sets the Item in the ItemList at ItemPos to the
*   abbreviation.
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsInitialism( CItemList &ItemList, SPLISTPOS ItemPos, CSentItemMemory &MemoryManager,
                                    BOOL* pfIsEOS )
{
    SPDBG_FUNC( "CStdSentEnum::IsInitialism" );

    HRESULT hr = S_OK;
    BOOL fMatchedEOS = false;

    //--- Initialism must be at least two characters.
    if ( (long)(m_pEndOfCurrItem - m_pNextChar) < 4 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        const WCHAR *pIterator = NULL;
        ULONG ulCount = 0;
    
        pIterator  = m_pNextChar;

        //--- Iterate through the token, each time checking for an alpha character followed by a period.
        while ( SUCCEEDED(hr) &&
                pIterator <= m_pEndOfCurrItem - 2)
        {
            if ( !iswalpha(*pIterator) ||
                 *(pIterator + 1) != L'.' )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                pIterator += 2;
                ulCount++;
            }
        }

        //--- Need to determine whether the initialism's period is also the end of the sentence.
        if ( SUCCEEDED( hr ) &&
             !(*pfIsEOS) )
        {
            //--- Advance to the beginning of the next token
            const WCHAR *pTempNextChar = m_pEndOfCurrToken, *pTempEndChar = m_pEndChar;
            const SPVTEXTFRAG *pTempCurrFrag = m_pCurrFrag;
            hr = SkipWhiteSpaceAndTags( pTempNextChar, pTempEndChar, pTempCurrFrag, MemoryManager );

            if ( SUCCEEDED( hr ) )
            {

                //--- If we have reached the end of the buffer, consider the abbreviation's period as
                //--- the end of the sentence.
                if ( !pTempNextChar )
                {
                    *pfIsEOS = true;
                    fMatchedEOS = true;
                }
                //--- Otherwise, only consider the abbreviation's period as the end of the sentence if
                //--- the next token is a common first word (which must be capitalized).
                else if ( IsCapital( *pTempNextChar ) )
                {
                    WCHAR *pTempEndOfItem = (WCHAR*) FindTokenEnd( pTempNextChar, pTempEndChar );

                    //--- Try to match a first word.
                    WCHAR temp = (WCHAR) *pTempEndOfItem;
                    *pTempEndOfItem = 0;
                
                    if ( bsearch( (void*) pTempNextChar, (void*) g_FirstWords, sp_countof( g_FirstWords ),
                                  sizeof( SPLSTR ), CompareStringAndSPLSTR ) )
                    {
                        *pfIsEOS = true;
                        fMatchedEOS = true;
                    }

                    *pTempEndOfItem = temp;
                }
            }
        }

        //--- Now insert the Initialism in the ItemList.
        if ( SUCCEEDED(hr) )
        {
            CSentItem Item;
            Item.pItemSrcText       = m_pNextChar;
            Item.ulItemSrcLen       = (long)(m_pEndOfCurrItem - m_pNextChar);
            Item.ulItemSrcOffset    = m_pCurrFrag->ulTextSrcOffset +
                                      (long)( m_pNextChar - m_pCurrFrag->pTextStart );
            Item.ulNumWords         = ulCount;
            Item.Words = (TTSWord*) MemoryManager.GetMemory( ulCount * sizeof(TTSWord), &hr );
            if ( SUCCEEDED( hr ) )
            {
                SPVSTATE* pNewState = (SPVSTATE*) MemoryManager.GetMemory( sizeof( SPVSTATE ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    //--- Ensure letters are pronounced as nouns...
                    memcpy( pNewState, &m_pCurrFrag->State, sizeof( SPVSTATE ) );
                    pNewState->ePartOfSpeech = SPPS_Noun;

                    ZeroMemory( Item.Words, ulCount * sizeof(TTSWord) );
                    for ( ULONG i = 0; i < ulCount; i++ )
                    {
                        Item.Words[i].pXmlState  = pNewState;
                        Item.Words[i].pWordText  = &Item.pItemSrcText[ 2 * i ];
                        Item.Words[i].ulWordLen  = 1;
                        Item.Words[i].pLemma     = Item.Words[i].pWordText;
                        Item.Words[i].ulLemmaLen = Item.Words[i].ulWordLen;
                    }
                    Item.pItemInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        Item.pItemInfo->Type = eINITIALISM;
                        ItemList.SetAt( ItemPos, Item );
                    }
                }
            }
        }
    }
    return hr;
} /* IsInitialism */

/***********************************************************************************************
* IsAlphaWord *
*-------------*
*   Description:
*       Checks the next token in the text stream to determine if it is an Alpha Word (all alpha
*   characters, except possibly a single apostrophe). 
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsAlphaWord( const WCHAR* pStartChar, const WCHAR* pEndChar, TTSItemInfo*& pItemNormInfo,
                                   CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsAlphaWord" );
    SPDBG_ASSERT( pStartChar < pEndChar );
    HRESULT hr = S_OK;

    bool fApostropheSeen = false;
    WCHAR *pCurrChar = (WCHAR*) pStartChar;

    while ( SUCCEEDED( hr ) &&
            pCurrChar &&
            pCurrChar < pEndChar )
    {
        if ( iswalpha( *pCurrChar ) )
        {
            pCurrChar++;
        }
        else if ( *pCurrChar == L'\''&&
                  !fApostropheSeen )
        {
            fApostropheSeen = true;
            pCurrChar++;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        //--- Matched Alpha Word
        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eALPHA_WORD;
        }
    }

    return hr;
} /* IsAlphaWord */

/***********************************************************************************************
* AbbreviationModifier *
*----------------------*
*   Description:
*       Fixes pronunciation issues for special case where 'sq' or 'cu' modifies
*		a measurement.
*
*************************************************************** MERESHAW **********************/
HRESULT CStdSentEnum::AbbreviationModifier( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, 
                                                  CItemList& ItemList, SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::AbbreviationModifier" );
    HRESULT hr = S_OK;

    //--- Get Item which comes before the abbreviation modifier
    SPLISTPOS TempPos = ListPos;
    TTSSentItem TempItem = ItemList.GetPrev( TempPos );
    if ( TempPos )
    {
        //--- Current Item - if All Caps, go with first pronunciation (need to do this before next 
        //---   stage of processing, since CU and FL's all caps prons take precedence over numeric...)
        TempItem = ItemList.GetPrev( TempPos );
        for ( ULONG i = 0; i < TempItem.ulItemSrcLen; i++ )
        {
            if ( !iswupper( TempItem.pItemSrcText[i] ) )
            {
                break;
            }
        }
        if ( i == TempItem.ulItemSrcLen )
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
            pPron->POSchoice                    = pAbbrevInfo->POS1;
            return hr;
        }             
    }
    else
    {
        hr = E_INVALIDARG;
    }
    if ( TempPos )
    {
        TempItem = ItemList.GetPrev( TempPos );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if ( SUCCEEDED( hr ) )
    {
        pPron->pronArray[PRON_A].POScount = 1;
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;
        pPron->hasAlt                     = false;
        pPron->altChoice                  = PRON_A;
        //--- Abbreviation table pronunciations are basically just vendor lex prons...
        pPron->pronType                   = eLEXTYPE_PRIVATE1;

        //--- If a cardinal, decimal, or ordinal number, use regular form
        if (( TempItem.pItemInfo->Type == eNUM_CARDINAL ) ||
			( TempItem.pItemInfo->Type == eNUM_DECIMAL ) ||
			( TempItem.pItemInfo->Type == eNUM_ORDINAL ) ||
			( TempItem.pItemInfo->Type == eNUM_MIXEDFRACTION ) ||
			( TempItem.pItemInfo->Type == eDATE_YEAR ) ||
			( TempItem.ulItemSrcLen == 3 &&
                  wcsnicmp( TempItem.pItemSrcText, L"one", 3 ) == 0 ))
        {
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }

        //--- Fractions and mixed fractions require some more work...
        else if ( TempItem.pItemInfo->Type == eNUM_FRACTION )
        {
            if (( (TTSNumberItemInfo*) TempItem.pItemInfo )->pFractionalPart->fIsStandard ) 
            {
                //--- Standard fractions (e.g. 11/20) get the plural form
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
            else
            {
                //--- Singular form with [of a] inserted beforehand ([of an] case need not be
				//--- checked because we're only dealing with 'sq' or 'cu'.

				wcscpy( pPron->pronArray[PRON_A].phon_Str, g_pOfA );
				pPron->pronArray[PRON_A].phon_Len = wcslen( g_pOfA );
                
                wcscat( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                pPron->pronArray[PRON_A].phon_Len   += wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                pPron->POSchoice                    = pAbbrevInfo->POS2;
            }
        }
 
        //--- Default behavior
        else
        {
            //--- Use default form ('sq')
            wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
            pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
            pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
            pPron->POSchoice                    = pAbbrevInfo->POS2;
        }
    }
    //--- Default behavior - use first pron
    else if ( hr == E_INVALIDARG )
    {
        hr = S_OK;
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
        pPron->POSchoice                    = pAbbrevInfo->POS1;
    }

    return hr;
} /* AbbreviationModifier */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\backend.cpp ===
/*******************************************************************************
* Backend.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the CBackend class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

#include "stdafx.h"
#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef Backend_H
#include "Backend.h"
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif


//-----------------------------
// Data.cpp
//-----------------------------
extern const short   g_IPAToAllo[];
extern const short   g_AlloToViseme[];


//--------------------------------------
// DEBUG: Save utterance WAV file
//--------------------------------------
//#define   SAVE_WAVE_FILE  1




const unsigned char g_SineWaveTbl[] =
{
    0x7b,0x7e,0x81,0x84,0x87,0x89,0x8c,0x8f,0x92,0x95,0x98,0x9b,0x9d,0xa0,0xa3,0xa6,
    0xa8,0xab,0xae,0xb0,0xb3,0xb5,0xb8,0xbb,0xbd,0xbf,0xc2,0xc4,0xc7,0xc9,0xcb,0xcd,
    0xcf,0xd1,0xd3,0xd5,0xd7,0xd9,0xdb,0xdd,0xdf,0xe0,0xe2,0xe3,0xe5,0xe6,0xe8,0xe9,
    0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf2,0xf3,0xf3,0xf4,0xf4,0xf4,0xf4,
    0xf5,0xf5,0xf5,0xf5,0xf4,0xf4,0xf4,0xf4,0xf3,0xf3,0xf2,0xf1,0xf1,0xf0,0xef,0xee,
    0xed,0xec,0xeb,0xea,0xe9,0xe7,0xe6,0xe5,0xe3,0xe1,0xe0,0xde,0xdc,0xdb,0xd9,0xd7,
    0xd5,0xd3,0xd1,0xcf,0xcd,0xcb,0xc8,0xc6,0xc4,0xc1,0xbf,0xbc,0xba,0xb7,0xb5,0xb2,
    0xb0,0xad,0xaa,0xa8,0xa5,0xa2,0x9f,0x9d,0x9a,0x97,0x94,0x91,0x8f,0x8c,0x89,0x86,
    0x83,0x80,0x7d,0x7a,0x77,0x75,0x72,0x6f,0x6c,0x69,0x66,0x64,0x61,0x5e,0x5b,0x58,
    0x56,0x53,0x50,0x4e,0x4b,0x49,0x46,0x44,0x41,0x3f,0x3c,0x3a,0x38,0x35,0x33,0x31,
    0x2f,0x2d,0x2b,0x29,0x27,0x25,0x23,0x21,0x1f,0x1e,0x1c,0x1b,0x19,0x18,0x16,0x15,
    0x14,0x13,0x12,0x11,0x10,0x0f,0x0e,0x0d,0x0c,0x0c,0x0b,0x0b,0x0a,0x0a,0x0a,0x0a,
    0x09,0x09,0x09,0x09,0x0a,0x0a,0x0a,0x0a,0x0b,0x0b,0x0c,0x0d,0x0d,0x0e,0x0f,0x10,
    0x11,0x12,0x13,0x14,0x15,0x17,0x18,0x1a,0x1b,0x1d,0x1e,0x20,0x22,0x23,0x25,0x27,
    0x29,0x2b,0x2d,0x2f,0x31,0x34,0x36,0x38,0x3a,0x3d,0x3f,0x42,0x44,0x47,0x49,0x4c,
    0x4e,0x51,0x54,0x56,0x59,0x5c,0x5f,0x61,0x64,0x67,0x6a,0x6d,0x6f,0x72,0x75,0x78
};







/*void  PredictEpochDist(   float   duration,
long    nKnots,
float   SampleRate,
float   *pTime, 
float   *pF0)
{
long            curSamplesOut, endSample, j;
float           epochFreq;
long            epochLen, epochCount;

  
    curSamplesOut   = 0;
    endSample       = (long) (SampleRate * duration );
    epochCount      = 0;
    
      while( curSamplesOut < endSample )
      {
      j = 1;
      //---------------------------------------------------
      // Align to appropriate knot bassed on
      // current output sample
      //---------------------------------------------------
      while( (j < nKnots - 1) && (curSamplesOut > pTime[j]) ) 
      j++;
      //---------------------------------------------------
      // Calculate exact pitch thru linear interpolation
      //---------------------------------------------------
      epochFreq = LinInterp( pTime[j - 1], curSamplesOut, pTime[j], pF0[j - 1], pF0[j] );
      //---------------------------------------------------
      // Calc sample count for curent epoch
      //---------------------------------------------------
      epochLen  = (long) (SampleRate / epochFreq);
      epochCount++;
      
        curSamplesOut += epochLen;
        }
        
          
            }
*/











/*****************************************************************************
* CBackend::CBackend *
*--------------------*
*   Description: Constructor
*   
********************************************************************** MC ***/
CBackend::CBackend( )
{
    SPDBG_FUNC( "CBackend::CBackend" );
    m_pHistory      = NULL;
    m_pHistory2     = NULL;
    m_pFilter       = NULL;
    m_pReverb       = NULL;
    m_pOutEpoch     = NULL;
    m_pMap          = NULL;
    m_pRevFlag      = NULL;
    m_pSpeechBuf    = NULL;
    m_VibratoDepth  = 0;
    m_UnitVolume    = 1.0f;
    m_MasterVolume  = SPMAX_VOLUME;
    memset( &m_Synth, 0, sizeof(MSUNITDATA) );
} /* CBackend::CBackend */


/*****************************************************************************
* CBackend::~CBackend *
*---------------------*
*   Description:  Destructor
*       
********************************************************************** MC ***/
CBackend::~CBackend( )
{
    SPDBG_FUNC( "CBackend::~CBackend" );

    Release();
} /* CBackend::~CBackend */




/*****************************************************************************
* CBackend::Release *
*---------------------*
*   Description:
*   Free memory allocaterd by Backend
*       
********************************************************************** MC ***/
void CBackend::Release( )
{
    SPDBG_FUNC( "CBackend::Release" );
    CleanUpSynth( );

    if( m_pSpeechBuf)
    {
        delete m_pSpeechBuf;
        m_pSpeechBuf = NULL;
    }
    if( m_pHistory )
    {
        delete m_pHistory;
        m_pHistory = NULL;
    }
    if( m_pHistory2 )
    {
        delete m_pHistory2;
        m_pHistory2 = NULL;
    }
    if( m_pReverb )
    {
        delete m_pReverb;
        m_pReverb = NULL;
    }
} /* CBackend::Release */



/*****************************************************************************
* CBackend::Init *
*----------------*
*   Description:
*   Opens a backend instance, keeping a pointer of the acoustic
*   inventory.
*       
********************************************************************** MC ***/
HRESULT CBackend::Init( IMSVoiceData* pVoiceDataObj, CFeedChain *pSrcObj, MSVOICEINFO* pVoiceInfo )
{
    SPDBG_FUNC( "CBackend::Init" );
    long    LPCsize = 0;
    HRESULT hr = S_OK;
    
    m_pVoiceDataObj = pVoiceDataObj;
    m_SampleRate = (float)pVoiceInfo->SampleRate;
    m_pSrcObj   = pSrcObj;
    m_cOrder = pVoiceInfo->LPCOrder;
    m_pWindow = pVoiceInfo->pWindow;
    m_FFTSize = pVoiceInfo->FFTSize;
    m_VibratoDepth = ((float)pVoiceInfo->VibratoDepth) / 100.0f;
    m_VibratoDepth = 0;				// NOTE: disable vibrato
    m_VibratoFreq = pVoiceInfo->VibratoFreq;
    if( pVoiceInfo->eReverbType > REVERB_TYPE_OFF )
    {
        m_StereoOut = true;
        m_BytesPerSample = 4;
    }
    else
    {
        m_StereoOut = false;
        m_BytesPerSample = 2;
    }
    //---------------------------------------
    // Allocate AUDIO buffer
    //---------------------------------------
    m_pSpeechBuf = new float[SPEECH_FRAME_SIZE + SPEECH_FRAME_OVER];
    if( m_pSpeechBuf == NULL )
    {
        //--------------------------------------
        // Out of memory!
        //--------------------------------------
        hr = E_OUTOFMEMORY;
    }
    if( SUCCEEDED(hr) )
    {
        //---------------------------------------
        // Allocate HISTORY buffer
        //---------------------------------------

        LPCsize = m_cOrder + 1;
        m_pHistory = new float[LPCsize];
        if( m_pHistory == NULL )
        {
            //--------------------------------------
            // Out of memory!
            //--------------------------------------
            hr = E_OUTOFMEMORY;
        }
    }
    if( SUCCEEDED(hr) )
    {
        memset( m_pHistory, 0, LPCsize * sizeof(float) );
        m_pOutEpoch         = NULL;
        m_pMap              = NULL;
        m_pRevFlag          = NULL;
        m_fModifiers        = 0;
        m_vibrato_Phase1    = 0;


        //--------------------------------
        // Reverb Effect
        //--------------------------------
        //pVoiceInfo->eReverbType = REVERB_TYPE_HALL;
        if( pVoiceInfo->eReverbType > REVERB_TYPE_OFF )
        {
            //--------------------------------
            // Create ReverbFX object
            //--------------------------------
            if( m_pReverb == NULL )
            {
                m_pReverb = new CReverbFX;
                if( m_pReverb )
                {
                    short       result;
                    result = m_pReverb->Reverb_Init( pVoiceInfo->eReverbType, (long)m_SampleRate, m_StereoOut );
                    if( result != KREVERB_NOERROR )
                    {
                        //--------------------------------------------
                        // Not enough memory to do reverb
                        // Recover gracefully
                        //--------------------------------------------
                        delete m_pReverb;
                        m_pReverb = NULL;
                    }
                    /*else
                    {
                    //--------------------------------------------------------
                    // Init was successful, ready to do reverb now
                    //--------------------------------------------------------
                    }*/
                }
            }
        }

        //----------------------------
        // Linear taper region scale
        //----------------------------
        m_linearScale = (float) pow( 10.0, (double)((1.0f - LINEAR_BKPT) * LOG_RANGE) / 20.0 );


    #ifdef SAVE_WAVE_FILE
        m_SaveFile = (PCSaveWAV) new CSaveWAV;     // No check needed, if this fails, we simply don't save file.
        if( m_SaveFile )
        {
            m_SaveFile->OpenWavFile( (long)m_SampleRate );
        }
    #endif

    }
    else
    {
        if( m_pSpeechBuf )
        {
            delete m_pSpeechBuf;
            m_pSpeechBuf = NULL;
        }
        if( m_pHistory )
        {
            delete m_pHistory;
            m_pHistory = NULL;
        }
    }

    return hr;    
} /* CBackend::Init */


/*****************************************************************************
* CBackend::FreeSynth *
*---------------------*
*   Description:
*   Return TRUE if consoants can be clustered.
*       
********************************************************************** MC ***/
void CBackend::FreeSynth( MSUNITDATA* pSynth )
{
    SPDBG_FUNC( "CBackend::FreeSynth" );
    if( pSynth->pEpoch )
    {
        delete pSynth->pEpoch;
        pSynth->pEpoch = NULL;
    }
    if( pSynth->pRes )
    {
        delete pSynth->pRes;
        pSynth->pRes = NULL;
    }
    if( pSynth->pLPC )
    {
        delete pSynth->pLPC;
        pSynth->pLPC = NULL;
    }
} /* CBackend::FreeSynth */


/*****************************************************************************
* ExpConverter *
*--------------*
*   Description:
*   Convert linear to exponential taper
*   'ref' is a linear value between 0.0 to 1.0
*       
********************************************************************** MC ***/
static float   ExpConverter( float ref, float linearScale )
{
    SPDBG_FUNC( "ExpConverter" );
    float   audioGain;

    if( ref < LINEAR_BKPT)
    {
        //----------------------------------------
        // Linear taper below LINEAR_BKPT
        //----------------------------------------
        audioGain = linearScale * (ref / LINEAR_BKPT);
    }
    else
    {
        //----------------------------------------
        // Log taper above LINEAR_BKPT
        //----------------------------------------
        audioGain = (float) pow( 10.0, (double)((1.0f - ref) * LOG_RANGE) / 20.0 );
    }

    return audioGain;
} /* ExpConverter */



/*****************************************************************************
* CBackend::CvtToShort *
*----------------------*
*   Description:
*   Convert (in place) FLOAT audio to SHORT.
*       
********************************************************************** MC ***/
void CBackend::CvtToShort( float *pSrc, long blocksize, long stereoOut, float audioGain )
{
    SPDBG_FUNC( "CBackend::CvtToShort" );
    long        i;
    short       *pDest;
    float       fSamp;
    
    pDest = (short*)pSrc;
    for( i = 0; i < blocksize; ++i )
    {
        //------------------------
        // Read float sample...
        //------------------------
        fSamp = (*pSrc++) * audioGain;
        //------------------------
        // ...clip to 16-bits...
        //------------------------
        if( fSamp > 32767 )
        {
            fSamp = 32767;
        }
        else if( fSamp < (-32768) )
        {
            fSamp = (-32768);
        }
        //------------------------
        // ...save as SHORT
        //------------------------
        *pDest++ = (short)fSamp;
        if( stereoOut )
        {
            *pDest++ = (short)(0 - (int)fSamp);
        }
    }
} /* CBackend::CvtToShort */



/*****************************************************************************
* CBackend::PSOLA_Stretch *
*-------------------------*
*   Description:
*   Does PSOLA epoch stretching or compressing
*       
********************************************************************** MC ***/
void CBackend::PSOLA_Stretch(     float *pInRes, long InSize, 
                    float *pOutRes, long OutSize,
                    float *pWindow, 
                    long  cWindowSize )
{
    SPDBG_FUNC( "CBackend::PSOLA_Stretch" );
    long    i, lim;
    float   window, delta, kf;
    
    memset( pOutRes, 0, sizeof(float) * OutSize  );
    lim = MIN(InSize, OutSize );
    delta = (float)cWindowSize / (float)lim;
    kf = 0.5f;
    pOutRes[0] = pInRes[0];
    for( i = 1; i < lim; ++i )
    {
        kf += delta;
        window = pWindow[(long) kf];
        pOutRes[i] += pInRes[i] * window;
        pOutRes[OutSize - i] += pInRes[InSize - i] * window;
    }
} /* CBackend::PSOLA_Stretch */





/*****************************************************************************
* CBackend::PrepareSpeech *
*-------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CBackend::PrepareSpeech( ISpTTSEngineSite* outputSite )
{
    SPDBG_FUNC( "CBackend::PrepareSpeech" );
    
    //m_pUnits      = pUnits;
    //m_unitCount       = unitCount;
    //m_CurUnitIndex    = 0;
    m_pOutputSite = outputSite;
    m_silMode = true;
    m_durationTarget = 0;
    m_cOutSamples_Phon = 1;
    m_cOutEpochs = 0;            // Pull model big-bang
    m_SpeechState = SPEECH_CONTINUE;
    m_cOutSamples_Total = 0;
	m_HasSpeech = false;
} /* CBackend::PrepareSpeech */


/*****************************************************************************
* CBackend::ProsodyMod *
*----------------------*
*   Description:
*   Calculate the epoch sequence for the synthesized speech
* 
*   INPUT:
* 
*   OUTPUT:
*       FIlls 'pOutEpoch', 'pMap', and 'pRevFlag'
*       Returns new epoch count
*       
********************************************************************** MC ***/
long CBackend::ProsodyMod(     UNITINFO    *pCurUnit, 
                               long         cInEpochs, 
                               float        durationMpy,
                               long         cMaxOutEpochs )
{   
    SPDBG_FUNC( "CBackend::ProsodyMod" );
    long    iframe, framesize, framesizeOut, j;
    long    cntOut, csamplesOut, cOutEpochs;
    BOOL    fUnvoiced;
    short   fReverse;
    float   totalDuration;
    float   durationIn;         // Active accum of IN duration
    float   durationOut;        // Active accum of OUT duration aligned to IN domain
    float   freqMpy;
    BOOL    fAdvanceInput;
    float           vibrato;
    unsigned char   *SineWavePtr;
    float           epochFreq;
    float           *pTime;
    float           *pF0;
    
    iframe          = 0;
    durationIn      = 0.0f;
    durationOut     = 0.0f;
    csamplesOut     = 0;
    cntOut          = 0;
    cOutEpochs      = 0;
    fReverse        = false;
    pTime           = pCurUnit->pTime;
    pF0             = pCurUnit->pF0;
    
    //------------------------------------
    // Find total input duration
    //------------------------------------
    totalDuration   = 0;
    for( j = 0; j < cInEpochs; ++j )
    {
        totalDuration += ABS(m_pInEpoch[j]);
    }
    
    /*PredictEpochDist(     pCurUnit->duration,
    pCurUnit->nKnots,
    m_SampleRate,
    pTime, 
    pF0 );*/
    
    while( iframe < cInEpochs && cOutEpochs < cMaxOutEpochs)
    {
        //-----------------------------------------
        //  Compute output frame length
        //-----------------------------------------
        if( m_pInEpoch[iframe] < 0 )
        {
            //-------------------------------------------------
            // Since we can't change unvoiced pitch,
            // do not change frame size for unvoiced frames
            //-------------------------------------------------
            framesize       = (long)((-m_pInEpoch[iframe]) + 0.5f);
            framesizeOut    = framesize;
            fUnvoiced       = true;
        }
        else
        {
            //---------------------------------------------------
            // Modify frame size for voiced epoch
            // based on epoch frequency
            //---------------------------------------------------
            j = 1;
            //---------------------------------------------------
            // Align to appropriate knot bassed on
            // current output sample
            //---------------------------------------------------
            while( (j < (long)pCurUnit->nKnots - 1) && (csamplesOut > pTime[j]) ) 
                j++;
            //---------------------------------------------------
            // Calculate exact pitch thru linear interpolation
            //---------------------------------------------------
            
            epochFreq = LinInterp( pTime[j - 1], (float)csamplesOut, pTime[j], pF0[j - 1], pF0[j] );
            
            
            SineWavePtr = (unsigned char*)&g_SineWaveTbl[0];
            vibrato = (float)(((unsigned char)(*(SineWavePtr + (m_vibrato_Phase1 >> 16)))) - 128);
            vibrato *= m_VibratoDepth;
            
            //---------------------------------------------------
            // Scale frame size using in/out ratio
            //---------------------------------------------------
            epochFreq       = epochFreq + vibrato;
            if( epochFreq < MIN_VOICE_PITCH )
            {
                epochFreq = MIN_VOICE_PITCH;
            }
            framesize       = (long)(m_pInEpoch[iframe] + 0.5f);
            framesizeOut    = (long)(m_SampleRate / epochFreq);
            
            
            vibrato         = ((float)256 / ((float)22050 / m_VibratoFreq)) * (float)framesizeOut;    // 3 Hz
            //vibrato           = ((float)256 / (float)7350) * (float)framesizeOut; // 3 Hz
            m_vibrato_Phase1 += (long)(vibrato * (float)65536);
            m_vibrato_Phase1 &= 0xFFFFFF;
            //---------------------------------------------------
            // @@@@ REMOVED 2x LIMIT
            //---------------------------------------------------
            /*if( framesizeOut > 2*framesize )
            {
            framesizeOut = 2*framesize;
            }
            if( framesize > 2*framesizeOut )
            {
            framesizeOut = framesize/2;
        }*/
            freqMpy = (float) framesize / framesizeOut;
            fUnvoiced = false;
        }
        
        
        //-------------------------------------------
        //  Generate next output frame
        //-------------------------------------------
        fAdvanceInput = false;
        if( durationOut + (0.5f * framesizeOut/durationMpy) <= durationIn + framesize )
        {
            //-----------------------------------------
            // If UNvoiced and odd frame,
            // reverse residual
            //-----------------------------------------
            if( fUnvoiced && (cntOut & 1) )
            {
                m_pRevFlag[cOutEpochs] = true;
                fReverse = true;
            }
            else
            {
                m_pRevFlag[cOutEpochs] = false;
                fReverse = false;
            }
            ++cntOut;
            
            durationOut += framesizeOut/durationMpy;
            csamplesOut += framesizeOut;
            m_pOutEpoch[cOutEpochs] = (float)framesizeOut;
            m_pMap[cOutEpochs] = iframe;
            cOutEpochs++;
        }
        else 
        {
            fAdvanceInput = true;
        }
        
        //-------------------------------------------
        // Advance to next input frame
        //-------------------------------------------
        if(     ((durationOut + (0.5f * framesizeOut/durationMpy)) > (durationIn + framesize)) || 
            //(cntOut >= 3) ||          @@@@ REMOVED 2x LIMIT
            //(fReverse == true) ||
            fAdvanceInput )
        {
            durationIn += framesize;
            ++iframe;
            cntOut = 0;
        }
    }
        
    return cOutEpochs;
} /* CBackend::ProsodyMod */



/*****************************************************************************
* CBackend::LPCFilter *
*---------------------*
*   Description:
*   LPC filter of order cOrder. It filters the residual signal
*   pRes, producing output pOutWave. This routine requires that
*   pOutWave has the true waveform history from [-cOrder,0] and
*   of course it has to be defined.
*       
********************************************************************** MC ***/
void CBackend::LPCFilter( float *pCurLPC, float *pCurRes, long len, float gain )
{
    SPDBG_FUNC( "CBackend::LPCFilter" );
    INT t, j;
    
    for( t = 0; t < len; t++ )
    {
        m_pHistory[0] = pCurLPC[0] * pCurRes[t];
        for( j = m_cOrder; j > 0; j-- )
        {
            m_pHistory[0] -= pCurLPC[j] * m_pHistory[j];
            m_pHistory[j] = m_pHistory[j - 1];
        }
        pCurRes[t] = m_pHistory[0] * gain;
    }
} /* CBackend::LPCFilter */


/*void CBackend::LPCFilter( float *pCurLPC, float *pCurRes, long len )
{
long        t;

  for( t = 0; t < len; t++ )
        {
        pCurRes[t] = pCurRes[t] * 10;
        }
        }
*/



/*****************************************************************************
* CBackend::ResRecons *
*---------------------*
*   Description:
*   Obtains output prosody modified residual
*       
********************************************************************** MC ***/
void CBackend::ResRecons( float *pInRes, 
                          long  InSize, 
                          float *pOutRes, 
                          long  OutSize, 
                          float scale )
{
    SPDBG_FUNC( "CBackend::ResRecons" );
    long        i, j;
    
    if( m_pRevFlag[m_EpochIndex] )
    {
        //----------------------------------------------------
        // Process repeated and reversed UNvoiced residual
        //----------------------------------------------------
        for( i = 0, j = OutSize-1;  i < OutSize;  ++i, --j )
        {
            pOutRes[i] = pInRes[j];
        }
    }
    else if( InSize == OutSize )
    {
        //----------------------------------------------------
        // Unvoiced residual or voiced residual 
        // with no pitch change
        //----------------------------------------------------
        memcpy( pOutRes, pInRes, sizeof(float) *OutSize );
    }
    else
    {
        //----------------------------------------------------
        // Process voiced residual   
        //----------------------------------------------------
        PSOLA_Stretch( pInRes, InSize, pOutRes, OutSize, m_pWindow, m_FFTSize );
    }
    
    //----------------------------------
    // Amplify frame
    //----------------------------------
    if( scale != 1.0f )
    {
        for( i = 0 ; i < OutSize; ++i )
        {
            pOutRes[i] *= scale;
        }
    }
} /* CBackend::ResRecons */




/*****************************************************************************
* CBackend::StartNewUnit *
*------------------------*
*   Description:
*   Synthesize audio samples for a target unit
* 
*   INPUT:
*       pCurUnit - unit ID, F0, duration, etc.
* 
*   OUTPUT:
*       Sets 'pCurUnit->csamplesOut' with audio length
*       
********************************************************************** MC ***/
HRESULT CBackend::StartNewUnit( )
{   
    SPDBG_FUNC( "CBackend::StartNewUnit" );
    long        cframeMax = 0, cInEpochs = 0, i;
    float       totalDuration, durationOut, durationMpy = 0;
    UNITINFO    *pCurUnit;
    HRESULT     hr = S_OK;
    SPEVENT     event;
	ULONGLONG	clientInterest;
 	USHORT		volumeVal;
   
	// Check for VOLUME change
	if( m_pOutputSite->GetActions() & SPVES_VOLUME )
	{
		hr = m_pOutputSite->GetVolume( &volumeVal );
		if ( SUCCEEDED( hr ) )
		{
			if( volumeVal > SPMAX_VOLUME )
			{
				//--- Clip rate to engine maximum
				volumeVal = SPMAX_VOLUME;
			}
			else if ( volumeVal < SPMIN_VOLUME )
			{
				//--- Clip rate to engine minimum
				volumeVal = SPMIN_VOLUME;
			}
			m_MasterVolume = volumeVal;
		}
	}

    //---------------------------------------
    // Delete previous unit
    //---------------------------------------
    CleanUpSynth( );
    
    //---------------------------------------
    // Get next phon
    //---------------------------------------
    hr = m_pSrcObj->NextData( (void**)&pCurUnit, &m_SpeechState );
    if( m_SpeechState == SPEECH_CONTINUE )
    {
		m_HasSpeech = pCurUnit->hasSpeech;
		m_pOutputSite->GetEventInterest( &clientInterest );

		//------------------------------------------------
        // Post SENTENCE event
        //------------------------------------------------
        if( (pCurUnit->flags & SENT_START_FLAG) && (clientInterest & SPFEI(SPEI_SENTENCE_BOUNDARY)) )
        {
			event.elParamType = SPET_LPARAM_IS_UNDEFINED;
            event.eEventId = SPEI_SENTENCE_BOUNDARY;
            event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
	        event.lParam = pCurUnit->sentencePosition;	        // Input word position
	        event.wParam = pCurUnit->sentenceLen;	            // Input word length
            m_pOutputSite->AddEvents( &event, 1 );
        }
        //------------------------------------------------
        // Post PHONEME event
        //------------------------------------------------
        if( clientInterest & SPFEI(SPEI_PHONEME) )
		{
			event.elParamType = SPET_LPARAM_IS_UNDEFINED;
			event.eEventId = SPEI_PHONEME;
			event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
			event.lParam = ((ULONG)pCurUnit->AlloFeatures << 16) + g_IPAToAllo[pCurUnit->AlloID];
			event.wParam = ((ULONG)(pCurUnit->duration * 1000.0f) << 16) + g_IPAToAllo[pCurUnit->NextAlloID];
			m_pOutputSite->AddEvents( &event, 1 );
		}

        //------------------------------------------------
        // Post VISEME event
        //------------------------------------------------
        if( clientInterest & SPFEI(SPEI_VISEME) )
		{
			event.elParamType = SPET_LPARAM_IS_UNDEFINED;
			event.eEventId = SPEI_VISEME;
			event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
			event.lParam = ((ULONG)pCurUnit->AlloFeatures << 16) + g_AlloToViseme[pCurUnit->AlloID];
			event.wParam = ((ULONG)(pCurUnit->duration * 1000.0f) << 16) + g_AlloToViseme[pCurUnit->NextAlloID];
			m_pOutputSite->AddEvents( &event, 1 );
		}

        //------------------------------------------------
        // Post any bookmark events
        //------------------------------------------------
        if( pCurUnit->pBMObj != NULL )
        {
            CBookmarkList   *pBMObj;
            BOOKMARK_ITEM*  pMarker;

            //-------------------------------------------------
            // Retrieve marker strings from Bookmark list and
            // enter into Event list
            //-------------------------------------------------
            pBMObj = (CBookmarkList*)pCurUnit->pBMObj;
            //cMarkerCount = pBMObj->m_BMList.GetCount();
			if( clientInterest & SPFEI(SPEI_TTS_BOOKMARK) )
			{
				//---------------------------------------
				// Send event for every bookmark in list
				//---------------------------------------
				SPLISTPOS	listPos;

				listPos = pBMObj->m_BMList.GetHeadPosition();
				while( listPos )
				{
					pMarker                    = (BOOKMARK_ITEM*)pBMObj->m_BMList.GetNext( listPos );
					event.eEventId             = SPEI_TTS_BOOKMARK;
					event.elParamType          = SPET_LPARAM_IS_STRING;
					event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
                    //--- Copy in bookmark string - has been NULL terminated in source already...
					event.lParam               = pMarker->pBMItem;
                    // Engine must convert string to long for wParam.
                    event.wParam               = _wtol((WCHAR *)pMarker->pBMItem);
					m_pOutputSite->AddEvents( &event, 1 );
				}
			}
            //---------------------------------------------
            // We don't need this Bookmark list any more
            //---------------------------------------------
            delete pBMObj;
            pCurUnit->pBMObj = NULL;
        }
		


        pCurUnit->csamplesOut = 0;
        //******************************************************
        // For SIL, fill buffer with zeros...
        //******************************************************
        if( pCurUnit->UnitID == UNIT_SIL )
        {   
            //---------------------------------------------
            // Calc SIL length
            //---------------------------------------------
            m_durationTarget    = (long)(m_SampleRate * pCurUnit->duration);
            m_cOutSamples_Phon  = 0;
            m_silMode           = true;
        
            //---------------------------------------------
            // Clear LPC filter storage
            //---------------------------------------------
            memset( m_pHistory, 0, sizeof(float)*(m_cOrder+1) );
        
            //--------------------------------
            // Success!
            //--------------------------------

            // Debug macro - output unit data...
            TTSDBG_LOGUNITS;
        }   
        //******************************************************
        // ...otherwise fill buffer with inventory data
        //******************************************************
        else
        {
            m_silMode = false;
            // Get unit data from voice
            hr = m_pVoiceDataObj->GetUnitData( pCurUnit->UnitID, &m_Synth );
            if( SUCCEEDED(hr) )
            {
                durationOut     = 0.0f;
                cInEpochs       = m_Synth.cNumEpochs;
                m_pInEpoch      = m_Synth.pEpoch;
                //cframeMax     = PeakValue( m_pInEpoch, cInEpochs );
                totalDuration   = (float)m_Synth.cNumSamples;

                //-----------------------------------------------
                // For debugging: Force duration to unit length
                //-----------------------------------------------
                /*float       unitDur;

                unitDur = totalDuration / 22050.0f;     
                if( pCurUnit->duration < unitDur )
                {
                    if( pCurUnit->speechRate < 1 )
                    {
                        pCurUnit->duration = unitDur * pCurUnit->speechRate;
                    }
                    else
                    {
                        pCurUnit->duration = unitDur;
                    }
                }*/

                durationMpy     = pCurUnit->duration;
        
                cframeMax = (long)pCurUnit->pF0[0];
                for( i = 1; i < (long)pCurUnit->nKnots; i++ )
                {
                    //-----------------------------------------
                    // Find the longest epoch
                    //-----------------------------------------
                    cframeMax = (long)(MAX(cframeMax,pCurUnit->pF0[i]));
                }
                cframeMax *= (long)(durationMpy * MAX_TARGETS_PER_UNIT);
        
        
                durationMpy = (m_SampleRate * durationMpy) / totalDuration;
                cframeMax += (long)(durationMpy * cInEpochs * MAX_TARGETS_PER_UNIT);
                //
                // mplumpe 11/18/97 : added to eliminate chance of crash.
                //
                cframeMax *= 2;
                //---------------------------------------------------
                // New epochs adjusted for duration and pitch
                //---------------------------------------------------
                m_pOutEpoch = new float[cframeMax];
                if( !m_pOutEpoch )
                {
                    //--------------------------------------
                    // Out of memory!
                    //--------------------------------------
                    hr = E_OUTOFMEMORY;
                    pCurUnit->csamplesOut = 0;
                    CleanUpSynth( );
                }
            }
            if( SUCCEEDED(hr) )
            {
                //---------------------------------------------------
                // Index back to orig epoch
                //---------------------------------------------------
                m_pMap = new long[cframeMax];
                if( !m_pMap )
                {
                    //--------------------------------------
                    // Out of memory!
                    //--------------------------------------
                    hr = E_OUTOFMEMORY;
                    pCurUnit->csamplesOut = 0;
                    CleanUpSynth( );
                }
            }
            if( SUCCEEDED(hr) )
            {
                //---------------------------------------------------
                // TRUE = reverse residual
                //---------------------------------------------------
                m_pRevFlag = new short[cframeMax];
                if( !m_pRevFlag )
                {
                    //--------------------------------------
                    // Out of memory!
                    //--------------------------------------
                    hr = E_OUTOFMEMORY;
                    pCurUnit->csamplesOut = 0;
                    CleanUpSynth( );
                }
            }
            if( SUCCEEDED(hr) )
            {
                //---------------------------------------------------------------------
                // Compute synthesis epochs and corresponding mapping to analysis
                // fills in:    m_pOutEpoch, m_pMap, m_pRevFlag
                //---------------------------------------------------------------------
                m_cOutEpochs = ProsodyMod( pCurUnit, cInEpochs, durationMpy, cframeMax );
        
                //------------------------------------------------
                // Now that actual epoch sizes are known,
                // calculate total audio sample count
                // @@@@ NO LONGER NEEDED
                //------------------------------------------------
                pCurUnit->csamplesOut = 0;
                for( i = 0; i < m_cOutEpochs; i++ )
                {
                    pCurUnit->csamplesOut += (long)(ABS(m_pOutEpoch[i]));
                }
        
        
                m_cOutSamples_Phon  = 0;
                m_EpochIndex        = 0;
                m_durationTarget    = (long)(pCurUnit->duration * m_SampleRate);
                m_pInRes            = m_Synth.pRes;
                m_pLPC              = m_Synth.pLPC;
                m_pSynthTime        = pCurUnit->pTime;
                m_pSynthAmp         = pCurUnit->pAmp;
                m_nKnots            = pCurUnit->nKnots;
                // NOTE: Maybe make log volume?
                m_UnitVolume        = (float)pCurUnit->user_Volume / 100.0f;

                //------------------------------------------------
                // Post WORD event
                //------------------------------------------------
               if( (pCurUnit->flags & WORD_START_FLAG) && (clientInterest & SPFEI(SPEI_WORD_BOUNDARY)) )
                {
					event.elParamType = SPET_LPARAM_IS_UNDEFINED;
                    event.eEventId = SPEI_WORD_BOUNDARY;
                    event.ullAudioStreamOffset = m_cOutSamples_Total * m_BytesPerSample;
	                event.lParam = pCurUnit->srcPosition;	        // Input word position
	                event.wParam = pCurUnit->srcLen;	            // Input word length
                    m_pOutputSite->AddEvents( &event, 1 );
                }
        

                //--- Debug macro - output unit data
                TTSDBG_LOGUNITS;
            }
        }
    }

    return hr;
} /* CBackend::StartNewUnit */





/*****************************************************************************
* CBackend::CleanUpSynth *
*------------------------*
*   Description:
*       
********************************************************************** MC ***/
void    CBackend::CleanUpSynth( )
{
    SPDBG_FUNC( "CBackend::CleanUpSynth" );

    if( m_pOutEpoch )
    {
        delete m_pOutEpoch;
        m_pOutEpoch = NULL;
    }
    if( m_pMap )
    {
        delete m_pMap;
        m_pMap = NULL;
    }
    if( m_pRevFlag )
    {
        delete m_pRevFlag;
        m_pRevFlag = NULL;
    }
    // NOTE: make object?
    FreeSynth( &m_Synth );

} /* CBackend::CleanUpSynth */



/*****************************************************************************
* CBackend::RenderFrame *
*-----------------------*
*   Description:
*   This this the central synthesis loop. Keep filling output audio
*   buffer until buffer frame is full or speech is done. To render 
*   continous speech, get each unit one at a time from upstream buffer.
*       
********************************************************************** MC ***/
HRESULT CBackend::RenderFrame( )
{
    SPDBG_FUNC( "CBackend::RenderFrame" );
    long        InSize, OutSize;
    long        iframe;
    float       *pCurInRes, *pCurOutRes;
    long        i, j;
    float       ampMpy;
    HRESULT     hr = S_OK;
    
    m_cOutSamples_Frame = 0;
    do
    {
        OutSize = 0;
        if( m_silMode )
        {
            //-------------------------------
            // Silence mode
            //-------------------------------
            if( m_cOutSamples_Phon >= m_durationTarget )
            {
                //---------------------------
                // Get next unit
                //---------------------------
                hr = StartNewUnit( );
                if (FAILED(hr))
                {
                    //-----------------------------------
                    // Try to end it gracefully...
                    //-----------------------------------
                    m_SpeechState = SPEECH_DONE;
                }

				TTSDBG_LOGSILEPOCH;
            }
            else
            {
                //---------------------------
                // Continue with current SIL
                //---------------------------
                m_pSpeechBuf[m_cOutSamples_Frame] = 0;
                OutSize = 1;
            }
        }
        else
        {
            if( m_EpochIndex < m_cOutEpochs )
            {
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                //
                // Continue with current phon
                //
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                //------------------------------------
                // Find current input residual
                //------------------------------------
                iframe = m_pMap[m_EpochIndex];
                pCurInRes = m_pInRes;
                for( i = 0; i < iframe; i++)
                {
                    pCurInRes += (long) ABS(m_pInEpoch[i]);
                }
                
                pCurOutRes  = m_pSpeechBuf + m_cOutSamples_Frame;
                InSize      = (long)(ABS(m_pInEpoch[iframe]));
                OutSize     = (long)(ABS(m_pOutEpoch[m_EpochIndex]));
                if (m_cOutSamples_Frame + OutSize > SPEECH_FRAME_SIZE + SPEECH_FRAME_OVER)
                {
                    m_pOutEpoch[m_EpochIndex] = SPEECH_FRAME_OVER-1;  // still huge
                    OutSize = (long)(ABS(m_pOutEpoch[m_EpochIndex]));
                }
                j = 1;
                while( (j < m_nKnots - 1) && (m_cOutSamples_Phon > m_pSynthTime[j]) )
                {
                    j++;
                }
                ampMpy = LinInterp( m_pSynthTime[j - 1], (float)m_cOutSamples_Phon, m_pSynthTime[j], m_pSynthAmp[j - 1], m_pSynthAmp[j] );
                //ampMpy = 1;
                
                //--------------------------------------------
                // Do stretching of residuals
                //--------------------------------------------
                ResRecons( pCurInRes, InSize, pCurOutRes, OutSize, ampMpy );
                
                //--------------------------------------------
                // Do LPC reconstruction
                //--------------------------------------------
                float       *pCurLPC;
				float       totalGain;

				totalGain = ExpConverter( ((float)m_MasterVolume / (float)SPMAX_VOLUME), m_linearScale ) 
								* ExpConverter( m_UnitVolume, m_linearScale );
                
                pCurLPC = m_pLPC + m_pMap[m_EpochIndex] * (1 + m_cOrder);
                pCurLPC[0] = 1.0f;
                LPCFilter( pCurLPC, &m_pSpeechBuf[m_cOutSamples_Frame], OutSize, totalGain );
                m_EpochIndex++;
            }
            else
            {
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                //
                // Get next phon
                //
                //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                hr = StartNewUnit( );
                if (FAILED(hr))
                {
                    //-----------------------------------
                    // Try to end it gracefully...
                    //-----------------------------------
                    m_SpeechState = SPEECH_DONE;
                }
				TTSDBG_LOGSILEPOCH;
            }
        }
        m_cOutSamples_Frame += OutSize;
        m_cOutSamples_Phon += OutSize;
        m_cOutSamples_Total += OutSize;

		TTSDBG_LOGEPOCHS;
    }
    while( (m_cOutSamples_Frame < SPEECH_FRAME_SIZE) && (m_SpeechState == SPEECH_CONTINUE) );
    
	if( SUCCEEDED(hr) )
	{
		//----------------------------------------------
		// Convert buffer from FLOAT to SHORT
		//----------------------------------------------
		if( m_pReverb )
		{
			//---------------------------------
			// Add REVERB
			//---------------------------------
			m_pReverb->Reverb_Process( m_pSpeechBuf, m_cOutSamples_Frame, 1.0f );
		}
		else
		{
			CvtToShort( m_pSpeechBuf, m_cOutSamples_Frame, m_StereoOut, 1.0f );
		}

        //--- Debug Macro - output wave data to stream
        TTSDBG_LOGWAVE;
	}
    
    if( SUCCEEDED( hr ) )
    {
        //------------------------------------
        // Send this buffer to SAPI site
        //------------------------------------
        DWORD   cbWritten;

		//------------------------------------------------------------------------------------
		// This was my lame hack to avoid sending buffers when nothing was spoken.
		// It was causing problems (among others) since StartNewUnit() was still sending
		// events - with no corresponding audio buffer! 
		//
		// This was too simple of a scheme. Disable this feature for now... 
		// ...until I come up with something more robust. (MC)
		//------------------------------------------------------------------------------------

		//if( m_HasSpeech )
		{
			hr = m_pOutputSite->Write( (void*)m_pSpeechBuf, 
									  m_cOutSamples_Frame * m_BytesPerSample, 
									  &cbWritten );
			if( FAILED( hr ) )
			{
				//----------------------------------------
				// Abort! Unable to write audio data
				//----------------------------------------
				m_SpeechState = SPEECH_DONE;
			}
		}
    }

    //------------------------------------
    // Return render state
    //------------------------------------
    return hr;
} /* CBackend::RenderFrame */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\alloops.cpp ===
/*******************************************************************************
* AlloOps.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the CAlloOps class.
*-------------------------------------------------------------------------------
*  Created By: mc                                        Date: 03/12/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"

#ifndef __spttseng_h__
#include "spttseng.h"
#endif
#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef FeedChain_H
#include "FeedChain.h"
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif




//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned short  g_Opcode_To_ASCII[];
extern const unsigned long   g_AlloFlags[];


/*****************************************************************************
* CBookmarkList::~CBookmarkList *
*-------------------------------*
*   Description:
*   Destructor for CBookmarkList
*       
********************************************************************** MC ***/
CBookmarkList::~CBookmarkList()
{
    SPDBG_FUNC( "CBookmarkList::~CBookmarkList" );
    BOOKMARK_ITEM*  pItem;

    //----------------------------------------
    //   Remove every item in link list.
    //----------------------------------------
    while( !m_BMList.IsEmpty() )
    {
        pItem = (BOOKMARK_ITEM*)m_BMList.RemoveHead();
        delete pItem;
    }
} /* CBookmarkList::~CBookmarkList */




/*****************************************************************************
* CFEToken::CFEToken *
*------------------------*
*   Description:
*   Initializer for CFEToken
*       
********************************************************************** MC ***/
CFEToken::CFEToken()
{
    SPDBG_FUNC( "CFEToken::CFEToken" );

    user_Volume = DEFAULT_USER_VOL;
    user_Rate = DEFAULT_USER_RATE;
    user_Pitch = DEFAULT_USER_PITCH;
    user_Emph = DEFAULT_USER_EMPH;
    user_Break = 0;
    pBMObj = NULL;

    memset( &tokStr[0], 0, sizeof(WCHAR) * TOKEN_LEN_MAX);
    tokLen = 0;
    memset( &phon_Str[0], 0, sizeof(short) * SP_MAX_PRON_LENGTH);
    phon_Len = 0;
    m_posClass = POS_UNK;
    POScode = MS_Unknown;
    m_TuneBoundaryType = NULL_BOUNDARY;
    m_Accent = K_NOACC;
    m_Boundary = K_NOBND;

	m_TermSil			= 0;
    m_DurScale			= 0.0f;
    m_ProsodyDurScale	= 1.0f;
	m_PitchBaseOffs		= 0.0f;
	m_PitchRangeScale	= 1.0f;

	// The following don't need to be init'd
    m_PronType			= PRON_LTS;
    sentencePosition	= 0;				// Source sentence position for this token
    sentenceLen			= 0; 				// Source sentence length for this token
    srcPosition			= 0;				// Source position for this token
    srcLen				= 0; 				// Source length for this token
    m_Accent_Prom		= 0;                // prominence prosodic control
    m_Boundary_Prom		= 0;                // prominence prosodic control
	m_TermSil			= 0;				// Pad word with silence (in sec)

	//--- Diagnostic
	m_AccentSource		= ACC_NoSource;
	m_BoundarySource	= BND_NoSource;
	m_SilenceSource		= SIL_NoSource;


} /* CFEToken::CFEToken */


/*****************************************************************************
* CFEToken::~CFEToken *
*-----------------------*
*   Description:
*   Destructor for CFEToken
*       
********************************************************************** MC ***/
CFEToken::~CFEToken()
{
    SPDBG_FUNC( "CFEToken::~CFEToken" );

    if( pBMObj != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete pBMObj;
    }

} /* CFEToken::~CFEToken */





/*****************************************************************************
* CAlloCell::CAlloCell *
*------------------------*
*   Description:
*   Initializer for CAlloCell
*       
********************************************************************** MC ***/
CAlloCell::CAlloCell()
{
    SPDBG_FUNC( "CAlloCell::CAlloCell" );
    long    i;

    m_allo				= _SIL_;
    m_dur				= 0;
    m_ftDuration		= m_UnitDur = 0;
    m_knots				= KNOTS_PER_PHON;
    m_ctrlFlags			= 0;
    m_user_Rate			= 0;
    m_user_Volume		= DEFAULT_USER_VOL;
    m_user_Pitch		= 0;
    m_user_Emph			= 0;
    m_user_Break		= 0;
    m_Sil_Break			= 0;
    m_Pitch_HI			= 0;
    m_Pitch_LO			= 0;
    m_pBMObj			= NULL;
    m_ToBI_Boundary		= K_NOBND;
    m_ToBI_Accent		= K_NOACC;
	m_TuneBoundaryType	= m_NextTuneBoundaryType = NULL_BOUNDARY;
    m_DurScale			= 1.0;
    m_ProsodyDurScale	= 1.0;
	m_PitchBaseOffs		= 0.0f;
	m_PitchRangeScale	= 1.0f;
    for( i = 0; i < KNOTS_PER_PHON; i++ )
    {
        m_ftTime[i] = 0;
        m_ftPitch[i] = 100;
    }


    m_Accent_Prom	 = 0;                   // prominence prosodic control
    m_Boundary_Prom	 = 0;                 // prominence prosodic control
    m_PitchBufStart	 = 0;
    m_PitchBufEnd	 = 0;
    m_SrcPosition	 = 0;
    m_SrcLen		 = 0;
    m_SentencePosition	 = 0;
    m_SentenceLen		 = 0;

	//--- Diagnostic
	m_AccentSource		= ACC_NoSource;
	m_BoundarySource	= BND_NoSource;
	m_SilenceSource		= SIL_NoSource;
	m_pTextStr			= NULL;

} /* CAlloCell::CAlloCell */


/*****************************************************************************
* CAlloCell::~CAlloCell *
*-----------------------*
*   Description:
*   Destructor for CAlloCell
*       
********************************************************************** MC ***/
CAlloCell::~CAlloCell()
{
    SPDBG_FUNC( "CAlloCell::~CAlloCell" );

    if( m_pBMObj != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete m_pBMObj;
    }

    if( m_pTextStr != NULL )
    {
        //---------------------------------------
        // Dispose bookmark list
        //---------------------------------------
        delete m_pTextStr;
    }


} /* CAlloCell::~CAlloCell */





/*****************************************************************************
* CAlloList::CAlloList *
*------------------------*
*   Description:
*   Initialize list with 2 silence entries. These will 
*   become the head an tail when real entries are stuffed
*       
********************************************************************** MC ***/
CAlloList::CAlloList()
{
    SPDBG_FUNC( "CAlloList::CAlloList" );
    CAlloCell   *pCell;

    m_cAllos = 0;
	m_ListPos = NULL;
    //------------------------------------
    // Create initial TAIL silence cell
    //------------------------------------
    pCell = new CAlloCell;
    if( pCell )
    {
        m_AlloCellList.AddHead( pCell );
        pCell->m_ctrlFlags |= WORD_START + TERM_BOUND;
        pCell->m_TuneBoundaryType = TAIL_BOUNDARY;
		pCell->m_SilenceSource = SIL_Tail;
        m_cAllos++;
    }
    //------------------------------------
    // Create initial HEAD silence cell
    //------------------------------------
    pCell = new CAlloCell;
    if( pCell )
    {
        m_AlloCellList.AddHead( pCell );
        pCell->m_ctrlFlags |= WORD_START;
		pCell->m_SilenceSource = SIL_Head;
        m_cAllos++;
    }
} /* CAlloList::CAlloList */


                


/*****************************************************************************
* CAlloList::~CAlloList *
*-------------------------*
*   Description:
*   Remove every item in link list.
*       
********************************************************************** MC ***/
CAlloList::~CAlloList()
{
    SPDBG_FUNC( "CAlloList::~CAlloList" );
    CAlloCell   *pCell;

    while( !m_AlloCellList.IsEmpty() )
    {
        pCell = (CAlloCell*)m_AlloCellList.RemoveHead();
        delete pCell;
    }

} /* CAlloList::~CAlloList */





/*****************************************************************************
* CAlloList::GetAllo *
*---------------------*
*   Description:
*   Return pointer of allocell at index
*       
********************************************************************** MC ***/
CAlloCell *CAlloList::GetCell( long index )
{
    SPDBG_FUNC( "CAlloList::GetCell" );

    return (CAlloCell*)m_AlloCellList.GetAt( m_AlloCellList.FindIndex( index ));
} /* CAlloList::GetCell */


/*****************************************************************************
* CAlloList::GetTailCell *
*-------------------------*
*   Description:
*   Return pointer of last allo in link list
*       
********************************************************************** MC ***/
CAlloCell *CAlloList::GetTailCell()
{
    SPDBG_FUNC( "CAlloList::GetTailCell" );

    return (CAlloCell*)m_AlloCellList.GetTail();
} /* CAlloList::GetTailCell */


/*****************************************************************************
* CAlloList::GetTailCell *
*-----------------------*
*   Description:
*   Return allo list size
*       
********************************************************************** MC ***/
long CAlloList::GetCount()
{
    SPDBG_FUNC( "CAlloList::GetCount" );

    return m_AlloCellList.GetCount();
} /* CAlloList::GetCount */





/*****************************************************************************
* PrintPhon *
*-----------*
*   Description:
*   Print 2-char allo name
*       
********************************************************************** MC ***/
void PrintPhon( ALLO_CODE allo, char * /*msgStr*/)
{
    SPDBG_FUNC( "PrintPhon" );

    unsigned short  nChar;
    
    nChar = g_Opcode_To_ASCII[allo];
    if( nChar >> 8 )
    {
        SPDBG_DMSG1( "%c", nChar >> 8 );
    }
    if( nChar & 0xFF )
    {
        SPDBG_DMSG1( "%c", nChar & 0xFF );
    }
} /* PrintPhon */




/*****************************************************************************
* CAlloList::OutAllos *
*--------------------*
*   Description:
*   Dump ALLO_CELL contents
*       
********************************************************************** MC ***/
void CAlloList::OutAllos()
{
    SPDBG_FUNC( "CAlloOps::OutAllos" );
    CAlloCell       *pCurCell;

    long    i, flags, flagsT;
    char    msgStr[400];
    
    for( i = 0; i < m_cAllos; i++ )
    {
        pCurCell = GetCell( i );
        flags = pCurCell->m_ctrlFlags;
        
        if( flags & WORD_START)
        {
            SPDBG_DMSG0( "\n" );
        }
        
        //----------------------------
        // Allo
        //----------------------------
        PrintPhon( pCurCell->m_allo, msgStr );
        
        //----------------------------
        // Duration
        //----------------------------
        SPDBG_DMSG1( "\t%.3f\t", pCurCell->m_ftDuration );
        
        //----------------------------
        // Boundry
        //----------------------------
        if( flags & BOUNDARY_TYPE_FIELD)
        {
            SPDBG_DMSG0( "(" );
            if( flags & WORD_START)
            {
                SPDBG_DMSG0( "-wS" );
            }
            if( flags & TERM_BOUND)
            {
                SPDBG_DMSG0( "-tB" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Syllable type
        //----------------------------
        if( flags & SYLLABLE_TYPE_FIELD)
        {
            SPDBG_DMSG0( "(" );
            if( flags & WORD_END_SYLL)
            {
                SPDBG_DMSG0( "-wE" );
            }
            if( flags & TERM_END_SYLL)
            {
                SPDBG_DMSG0( "-tE" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Syllable order
        //----------------------------
        if( flags & SYLLABLE_ORDER_FIELD)
        {
            SPDBG_DMSG0( "(" );
            
            flagsT = flags & SYLLABLE_ORDER_FIELD;
            if( flagsT == FIRST_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Fs" );
            }
            else if( flagsT == MID_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Ms" );
            }
            else if( flagsT == LAST_SYLLABLE_IN_WORD)
            {
                SPDBG_DMSG0( "-Ls" );
            }
            SPDBG_DMSG0( ")\t" );
        }
        
        //----------------------------
        // Stress
        //----------------------------
        if( flags & PRIMARY_STRESS)
        {
            SPDBG_DMSG0( "-Stress\t" );
        }
        
        //----------------------------
        // Word initial consonant
        //----------------------------
        if( flags & WORD_INITIAL_CONSONANT)
        {
            SPDBG_DMSG0( "-InitialK\t" );
        }
        
        //----------------------------
        // Syllable start
        //----------------------------
        if( flags & SYLLABLE_START)
        {
            SPDBG_DMSG0( "-Syll\t" );
        }
        
        SPDBG_DMSG0( "\n" );
        }
} /* CAlloList::OutAllos */




/*****************************************************************************
* CAlloList::WordToAllo *
*-----------------------*
*   Description:
*   Copy word token to AlloCells
*   Insert allos BEFORE 'pEndCell'
*       
********************************************************************** MC ***/
bool CAlloList::WordToAllo( CFEToken *pPrevTok, CFEToken *pTok, CFEToken *pNextTok, CAlloCell *pEndCell )
{
    SPDBG_FUNC( "CAlloList::WordToAllo" );

    long    i;
    long    startLatch;
    CAlloCell   *pCurCell;
    long    firstVowel, lastVoiced;
    bool    gotAccent, isStressed;
	bool	hasSpeech;
    
    //-----------------------------------------
    // First, find ToBI accent locations
    //-----------------------------------------
    firstVowel  = lastVoiced = (-1);
    gotAccent   = false;
	hasSpeech	= false;
    for( i = 0; i < pTok->phon_Len; i++ )
    {
        isStressed = false;
        if( pTok->phon_Str[i] < _STRESS1_ )
        {
            //----------------------------
            // Potential ToBI accent
            //----------------------------
            if( (!gotAccent) && (g_AlloFlags[pTok->phon_Str[i]] & KVOWELF) )
            {
                if( (i < (pTok->phon_Len -1)) && (pTok->phon_Str[i+1] == _STRESS1_) )
                {
                    //-------------------------------------
                    // Put accent at 1st stressed vowel
                    //-------------------------------------
                    firstVowel = i;
                    gotAccent = true;
                }
                else if( firstVowel < 0 )
                {
                    //-------------------------------------
                    // In case there's no stressed vowel 
                    // in this word, use 1st vowel
                    //-------------------------------------
                    firstVowel = i;
                }
            }
            //----------------------------
            // Potential ToBI boundary
            //----------------------------
            if( g_AlloFlags[pTok->phon_Str[i]] & KVOICEDF )
            {
                lastVoiced = i;
            }
        }
    }
    //-----------------------------------------
    // Now, copy data to allo list
    //-----------------------------------------
    startLatch  = true;
    for( i = 0; i < pTok->phon_Len; i++ )
    {
        if( pTok->phon_Str[i] < _STRESS1_ )
        {
			if( (pTok->phon_Str[i] == _SIL_) && (pTok->m_TuneBoundaryType >= SUB_BOUNDARY_1) )
			{
				//----------------------------------------------------------------
				// Before skipping this, propagate the dur scale gain
				//----------------------------------------------------------------
				if( pTok->m_DurScale == 0 )
				{
					if( pPrevTok )
					{
						pTok->m_DurScale = pPrevTok->m_DurScale;
					}
					else
					{
						pTok->m_DurScale = 1.0;
					}
				}
				continue;
			}
            //------------------------------------
            // Create new cell
            //------------------------------------
            pCurCell = new CAlloCell;
            if( pCurCell )
            {
                m_AlloCellList.InsertBefore( m_AlloCellList.Find(pEndCell), pCurCell);
                m_cAllos++;

                //----------------------------
                // Copy only phons
                //----------------------------
                pCurCell->m_allo = (ALLO_CODE) pTok->phon_Str[i];
                //---------------------------------------------
                // See if this allo will generate speech
                //---------------------------------------------
				if( (pCurCell->m_allo >= _IY_) &&
					(pCurCell->m_allo <= _DX_) &&
					(pCurCell->m_allo != _SIL_) )
				{
					hasSpeech = true;
				}

                //----------------------------
                // Save src position
                //----------------------------
                pCurCell->m_SrcPosition = pTok->srcPosition;
                pCurCell->m_SrcLen = pTok->srcLen;
                pCurCell->m_SentencePosition = pTok->sentencePosition;
                pCurCell->m_SentenceLen = pTok->sentenceLen;

                //----------------------------
                // Flag WORD START?
                //----------------------------
                if( startLatch )
                {
                    pCurCell->m_ctrlFlags |= WORD_START;
                    startLatch = false;
                }

                //----------------------------
                // Is next allo a STRESS?
                //----------------------------
                if( i < (pTok->phon_Len -1) )
                {
                    if( pTok->phon_Str[i+1] == _STRESS1_ )
                    {
                        pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
                    }
					else
					{
						//----------------------------------------------
						// Voice inventory does not have unstressed
						// entries for these diphongs
						//----------------------------------------------
						if( (pCurCell->m_allo == _AW_) ||
							(pCurCell->m_allo == _AY_) ||
							(pCurCell->m_allo == _EY_) ||
							(pCurCell->m_allo == _OY_) )
						{
							pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
						}
					}
                }

				//---------------------------
				// Diagnostic
				//---------------------------
				if( pCurCell->m_allo == _SIL_ )
				{
					pCurCell->m_SilenceSource = pTok->m_SilenceSource;
				}
                //----------------------------
                // Place ToBI accent
                //----------------------------
                if( i == firstVowel )
                {
                    pCurCell->m_ToBI_Accent = pTok->m_Accent;
					//---------------------------
					// Diagnostic
					//---------------------------
					pCurCell->m_AccentSource = pTok->m_AccentSource;
					pCurCell->m_pTextStr = new char[pTok->tokLen+1];
					if( pCurCell->m_pTextStr )
					{
						WideCharToMultiByte (	CP_ACP, 0, 
												pTok->tokStr, -1, 
												pCurCell->m_pTextStr, pTok->tokLen+1, 
												NULL, NULL);
					}
                }
                pCurCell->m_Accent_Prom = pTok->m_Accent_Prom;
                //----------------------------
                // Place ToBI boundary
                //----------------------------
                if( i == lastVoiced )
                {
                    pCurCell->m_ToBI_Boundary = pTok->m_Boundary;
					//---------------------------
					// Diagnostic
					//---------------------------
					pCurCell->m_BoundarySource = pTok->m_BoundarySource;
                }
                pCurCell->m_Boundary_Prom = pTok->m_Boundary_Prom;

                //----------------------------
                // User Controls
                //----------------------------
                pCurCell->m_user_Volume = pTok->user_Volume;
                pCurCell->m_user_Rate = pTok->user_Rate;
                pCurCell->m_user_Pitch = pTok->user_Pitch;
				pCurCell->m_user_Emph = 0;
				if( pTok->user_Emph > 0 )
				{
					if( i == firstVowel )
					{
						pCurCell->m_user_Emph = pTok->user_Emph;
						pCurCell->m_ctrlFlags |= PRIMARY_STRESS;
					}
				}
                pCurCell->m_user_Break = pTok->user_Break;
                pCurCell->m_pBMObj = pTok->pBMObj;
                pTok->pBMObj = NULL;

				//-----------------------------------------------
				// If token's m_DurScale is not defined,
				//  try to use prev token's ratio
				//-----------------------------------------------
				if( pTok->m_DurScale == 0 )
				{
					if( pPrevTok )
					{
						pCurCell->m_DurScale = pPrevTok->m_DurScale;
					}
					else
					{
						pCurCell->m_DurScale = 1.0;
					}
					//-------------------------------------------------------
					// Write back in case next token is also undefined
					//-------------------------------------------------------
					pTok->m_DurScale = pCurCell->m_DurScale;
				}
				else
				{
					pCurCell->m_DurScale = pTok->m_DurScale;
				}
				pCurCell->m_ProsodyDurScale = pTok->m_ProsodyDurScale;

				if( pNextTok )
				{
					pCurCell->m_NextTuneBoundaryType = pNextTok->m_TuneBoundaryType;
				}
				else
				{
					pCurCell->m_NextTuneBoundaryType = NULL_BOUNDARY;
				}
				pCurCell->m_PitchBaseOffs = pTok->m_PitchBaseOffs;
				pCurCell->m_PitchRangeScale = pTok->m_PitchRangeScale;

                //----------------------------------------------
                // Is this a term word?
                //----------------------------------------------
                pCurCell->m_TuneBoundaryType = pTok->m_TuneBoundaryType;
                if( pTok->m_TuneBoundaryType != NULL_BOUNDARY )
                {
                    pCurCell->m_ctrlFlags |= TERM_BOUND + WORD_START;
                }
            }
        }

    }
	//----------------------------------------
	// Insert word pause?
	//----------------------------------------
	if( pTok->m_TermSil > 0 )
	{
        pCurCell = new CAlloCell;
        if( pCurCell )
        {
            m_AlloCellList.InsertBefore( m_AlloCellList.Find(pEndCell), pCurCell);
            m_cAllos++;

            //----------------------------
            // Add silence
            //----------------------------
            pCurCell->m_allo = _SIL_;

            //----------------------------
            // Save src position
            //----------------------------
            pCurCell->m_SrcPosition = pTok->srcPosition;
            pCurCell->m_SrcLen = pTok->srcLen;
            pCurCell->m_SentencePosition = pTok->sentencePosition;
            pCurCell->m_SentenceLen = pTok->sentenceLen;
            //----------------------------
            // User Controls
            //----------------------------
            pCurCell->m_user_Volume = pTok->user_Volume;
            pCurCell->m_user_Rate = pTok->user_Rate;
            pCurCell->m_user_Pitch = pTok->user_Pitch;
            pCurCell->m_user_Emph = pTok->user_Emph;
            pCurCell->m_user_Break = pTok->user_Break;
            pCurCell->m_pBMObj = NULL;
            pCurCell->m_TuneBoundaryType = pTok->m_TuneBoundaryType;
            pCurCell->m_Boundary_Prom = pTok->m_Boundary_Prom;
            pCurCell->m_Accent_Prom = pTok->m_Accent_Prom;
			pCurCell->m_ctrlFlags = 0;
			pCurCell->m_UnitDur = pTok->m_TermSil;
            pCurCell->m_Sil_Break = (unsigned long)(pCurCell->m_UnitDur * 1000);	// sec -> ms
			pCurCell->m_user_Break = 0;
			pCurCell->m_DurScale = pTok->m_DurScale;
			pCurCell->m_ProsodyDurScale = 1.0f;
		}
	}

	return hasSpeech;
} /* CAlloList::WordToAllo */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\duration.cpp ===
/******************************************************************************
* Duration.cpp *
*--------------*
*
*------------------------------------------------------------------------------
*  Copyright (C) 1999 Microsoft Corporation         Date: 04/28/99
*  All Rights Reserved
*
*********************************************************************** MC ****/

//--- Additional includes
#include "stdafx.h"

#ifndef SPDebug_h
#include <spdebug.h>
#endif
#ifndef Frontend_H
#include "Frontend.h"
#endif
#ifndef AlloOps_H
#include "AlloOps.h"
#endif



//-----------------------------
// Data.cpp
//-----------------------------
extern const unsigned long    g_AlloFlags[];
extern const float  g_BoundryDurTbl[];
extern const float  g_BoundryStretchTbl[];





/*****************************************************************************
* CDuration::Pause_Insertion *
*----------------------------*
*   Description:
*   Duration Rule #1 - Pause Insertion
*       
********************************************************************** MC ***/
void CDuration::Pause_Insertion( long userDuration, long silBreak )
{
    SPDBG_FUNC( "CDuration::Pause_Insertion" );

    if( userDuration )
    {
        m_DurHold = ((float)userDuration / 1000);
        m_TotalDurScale = 1.0;
    }
    else if( silBreak )
    {
        m_DurHold = ((float)silBreak / 1000);
    }
    else
    {
        if( m_CurBoundary != NULL_BOUNDARY)
        {
            m_DurHold = g_BoundryDurTbl[(long)m_CurBoundary];
			//m_DurHold *= m_TotalDurScale;

			//----------------------------
			// Clip to limits
			//----------------------------
			if( m_DurHold > MAX_SIL_DUR )
			{
				m_DurHold = MAX_SIL_DUR;
			}
			/*else if( m_DurHold < MIN_ALLO_DUR )
			{
				m_DurHold = MIN_ALLO_DUR;
			}*/
        }
    }

} /* CDuration::Pause_Insertion */





/*****************************************************************************
* CDuration::PhraseFinal_Lengthen *
*---------------------------------*
*   Description:
*   Duration Rule #2 - Phrase-final Lengthening
*       
********************************************************************** MC ***/
void CDuration::PhraseFinal_Lengthen( long /*cellCount*/ )
{
    SPDBG_FUNC( "CDuration::PhraseFinal_Lengthen" );
	float		stretchGain;

    if( m_cur_SyllableType & TERM_END_SYLL)
    {
    
    
        if( (m_cur_Stress) && (m_cur_VowelFlag) )
        {
            stretchGain = g_BoundryStretchTbl[(long)m_NextBoundary];
			m_DurHold *= stretchGain;

			//----------------------------
			// Clip to limits
			//----------------------------
			if( m_DurHold > MAX_ALLO_DUR )
			{
				m_DurHold = MAX_ALLO_DUR;
			}
			else if( m_DurHold < MIN_ALLO_DUR )
			{
				m_DurHold = MIN_ALLO_DUR;
			}
        }
    }
} /* CDuration::PhraseFinal_Lengthen */


#define		EMPH_VOWEL_GAIN	1.0f
#define		EMPH_CONS_GAIN	1.25f
#define		EMPH_VOWEL_MIN	0.060f
#define		EMPH_CONS_MIN	0.020f
#define		EMPH_MIN_DUR	0.150f

/*****************************************************************************
* CDuration::Emphatic_Lenghen *
*-----------------------------*
*   Description:
*   Duration Rule #8 - Lengthening for emphasis
*       
********************************************************************** MC ***/
long CDuration::Emphatic_Lenghen( long lastStress )
{
    SPDBG_FUNC( "CDuration::Emphatic_Lenghen" );

    long            eFlag;
	bool			isEmph;

    eFlag = lastStress;
	if( m_cur_Stress & EMPHATIC_STRESS )
	{
		isEmph = true;
	}
	else
	{
		isEmph = false;
	}

    if( (m_cur_PhonCtrl & WORD_INITIAL_CONSONANT) || 
        ( m_cur_VowelFlag && (!isEmph)) )
    {
        eFlag = false;          // start of a new word OR non-emph vowel    
    }
    
    if( isEmph )
    {
        eFlag = true;           // continue lengthening until above condition is met    
    }
    
    if( eFlag )
    {
		

		/*if( m_DurHold < EMPH_MIN_DUR )
		{
			m_durationPad += EMPH_MIN_DUR - m_DurHold;
		}*/

		float		durDiff;
        if( m_cur_VowelFlag)
        {
			durDiff = (m_DurHold * EMPH_VOWEL_GAIN) - m_DurHold;
			if( durDiff <  EMPH_VOWEL_MIN )
			{
				durDiff = EMPH_VOWEL_MIN;
			}
        }
        else
        {
			durDiff = (m_DurHold * EMPH_CONS_GAIN) - m_DurHold;
			if( durDiff <  EMPH_CONS_MIN )
			{
				durDiff = EMPH_CONS_MIN;
			}
        }
		m_durationPad += durDiff;    // lengthen phon for emph    
    }

    return eFlag;
} /* CDuration::Emphatic_Lenghen */





/*****************************************************************************
* CDuration::AlloDuration *
*-------------------------*
*   Description:
*   Calculate durations
*       
********************************************************************** MC ***/
void CDuration::AlloDuration( CAlloList *pAllos, float rateRatio )
{
    SPDBG_FUNC( "CDuration::AlloDuration" );

    
    long        eFlag;
    CAlloCell   *pPrevCell, *pCurCell, *pNextCell, *pNext2Cell;
    long        numOfCells;
    long        userDuration, silBreak;
    
    numOfCells = pAllos->GetCount();

    if( numOfCells > 0 )
    {
        eFlag   = false;
		//------------------------------
		// Fill the pipeline
		//------------------------------
		pPrevCell = pAllos->GetHeadCell();
		pCurCell = pAllos->GetNextCell();
		pNextCell = pAllos->GetNextCell();
		pNext2Cell = pAllos->GetNextCell();

		//------------------------------
		// 1st allo is always SIL
		//------------------------------
        pPrevCell->m_ftDuration = pPrevCell->m_UnitDur = PITCH_BUF_RES;           // initial SIL    
		while( pCurCell )
        {
            //------------------
            // Current  
            //------------------
            m_cur_Phon = pCurCell->m_allo;
            m_cur_PhonCtrl = pCurCell->m_ctrlFlags;
            m_cur_SyllableType = m_cur_PhonCtrl & SYLLABLE_TYPE_FIELD;
            m_cur_Stress = m_cur_PhonCtrl & STRESS_FIELD;
            m_cur_PhonFlags = ::g_AlloFlags[m_cur_Phon];
            userDuration = pCurCell->m_user_Break;
            silBreak = pCurCell->m_Sil_Break;
            if( m_cur_PhonFlags & KVOWELF)
            {
                m_cur_VowelFlag = true;
            }
            else
            {
                m_cur_VowelFlag = false;
            }
            m_CurBoundary = pCurCell->m_TuneBoundaryType;
            m_NextBoundary = pCurCell->m_NextTuneBoundaryType;
            m_TotalDurScale = rateRatio * pCurCell->m_DurScale * pCurCell->m_ProsodyDurScale;
			m_DurHold = pCurCell->m_UnitDur;
			m_durationPad = 0;

			if( pCurCell->m_user_Emph > 0 )
			{
				m_cur_Stress |= EMPHATIC_STRESS;
			}
        
            //------------------
            // Prev  
            //------------------
            m_prev_Phon = pPrevCell->m_allo;
            m_prev_PhonCtrl = pPrevCell->m_ctrlFlags;
            m_prev_PhonFlags = ::g_AlloFlags[m_prev_Phon];
        
            //------------------
            // Next
            //------------------
            if( pNextCell )
            {
                m_next_Phon = pNextCell->m_allo;
                m_next_PhonCtrl = pNextCell->m_ctrlFlags;
            }
            else
            {
                m_next_Phon = _SIL_;
                m_next_PhonCtrl = 0;
            }
            m_next_PhonFlags = ::g_AlloFlags[m_next_Phon];
        
            //------------------
            // 2 phons ahead 
            //------------------
            if( pNext2Cell )
            {
                m_next2_Phon = pNext2Cell->m_allo;
                m_next2_PhonCtrl = pNext2Cell->m_ctrlFlags;
            }
            else
            {
                m_next2_Phon = _SIL_;
                m_next2_PhonCtrl = 0;
            }
            m_next2_PhonFlags = ::g_AlloFlags[m_next2_Phon];

        
            if( m_cur_Phon == _SIL_ )
            {
                //-------------------------------------------
                // #1 - Pause Insertion  
                //-------------------------------------------
                Pause_Insertion( userDuration, silBreak );
            }
            else
            {
                //-------------------------------------------
                // #2 - Phrase-final Lengthening 
                //-------------------------------------------
                PhraseFinal_Lengthen( numOfCells );
        
                //-------------------------------------------
                // #8  Lengthening for emphasis 
                //-------------------------------------------
                eFlag = Emphatic_Lenghen( eFlag );        
   
            }
        
            pCurCell->m_ftDuration = ((m_DurHold + m_durationPad) / m_TotalDurScale);

			//---------------------------------
			// Shift the pipeline once
			//---------------------------------
			pPrevCell	= pCurCell;
			pCurCell	= pNextCell;
			pNextCell	= pNext2Cell;
			pNext2Cell	= pAllos->GetNextCell();
        }
    }
} /* CDuration::AlloDuration */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\disambig.cpp ===
/*******************************************************************************
* Disambig.cpp *
*--------------*
*	Description:
*		This module contains the methods to disambiguate part of speech and
*	select the correct pronounciation from the lexicon.
*-------------------------------------------------------------------------------
*  Created By: EDC										  Date: 07/15/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "commonlx.h"
#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif
#include "spttsengdebug.h"

/*****************************************************************************
* TryPOSConversion *
*------------------*  
*       
*   Description:
*       Checks to see whether the argument PRONRECORD contains the argument
*   ENGPARTOFSPEECH as an option.  If so, sets the PRONRECORD alternate
*   choice and part of speech choice, and returns true.  If not, just returns
*   false without modifying the PRONRECORD at all.
*
***************************************************************** AH *********/
bool TryPOSConversion( PRONRECORD& pPron, ENGPARTOFSPEECH PartOfSpeech )
{

    //--- Check first pronunciation
    for ( ULONG i = 0; i < pPron.pronArray[0].POScount; i++ )
    {
        if ( pPron.pronArray[0].POScode[i] == PartOfSpeech )
        {
            pPron.altChoice = 0;
            pPron.POSchoice = PartOfSpeech;
            return true;
        }
    }

    //--- Check second pronunciation
    if ( pPron.hasAlt )
    {
        for ( ULONG i = 0; i < pPron.pronArray[1].POScount; i++ )
        {
            if ( pPron.pronArray[1].POScode[i] == PartOfSpeech )
            {
                pPron.altChoice = 1;
                pPron.POSchoice = PartOfSpeech;
                return true;
            }
        }
    }

    return false;
} /* TryPOS Conversion */

/*****************************************************************************
* DisambiguatePOS *
*-----------------*  
*       
*   Description:
*       Disambiguate parts of speech by applying patches in order...  This 
*   work is an implementation of Eric Brill's rule-based part of speech
*   tagger - see, for example:
*
*   Brill, Eric. 1992. A simple rule-based part of speech tagger.  
*       In Proceedings of the Third Conference on Applied Natural
*       Language Processing, ACL. Trento, Italy.
*
***************************************************************** AH *********/
void DisambiguatePOS( PRONRECORD *pProns, ULONG cNumOfWords )
{
    SPDBG_FUNC( "DisambiguatePOS" );

    //--- Iterate over the patches, applying each (where applicable) to the
    //--- entire sentence.  For each patch, iterate over each word in the 
    //--- sentence to which the patch could apply (from left to right).
    for ( int i = 0; i < sp_countof( g_POSTaggerPatches ); i++ )
    {
        switch ( g_POSTaggerPatches[i].eTemplateType )
        {
        case PREV1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches, and
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and 
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 2; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two previous matches, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two after matches, and 
                            //--- the conversion POS is a possibility for this word, convert the
                            //--- POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                 pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches OR the
                            //--- POS two previous matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 1                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }            
                        }
                    }
                }
            }
            break;
        case NEXT1OR2T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches OR the POS
                            //--- two after matches, and the conversion POS is a possibility for this 
                            //--- word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 2                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2OR3T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous POS matches OR the
                            //--- POS two previous matches OR the POS three previous matches, and 
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 1                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j > 2                                                        &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j - 3].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }                         
                        }
                    }
                }
            }
            break;
        case NEXT1OR2OR3T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches OR the POS
                            //--- two after matches OR the POS three after matches, and the conversion 
                            //--- POS is a possibility for this word, convert the POS.
                            if ( ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 2                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) ||
                                 ( j < cNumOfWords - 3                                          &&
                                   pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS &&
                                   pProns[j + 3].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1TNEXT1T:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 1; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and the
                            //--- previous POS matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1TNEXT2T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 1; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the POS two after matches, and the
                            //--- previous POS matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2TNEXT1T:
            {
                if ( cNumOfWords > 3 )
                {
                    for ( ULONG j = 2; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next POS matches, and the
                            //--- POS two previous matches, and the conversion POS is a possibility 
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 2].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS2 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CAP:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the word is capitalized, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             iswupper( pProns[j].orthStr[0] ) )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                        }
                    }
                }
            }
            break;
        case NOTCAP:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the word is not capitalized, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             !iswupper( pProns[j].orthStr[0] ) )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                        }
                    }
                }
            }
            break;
        case PREVCAP:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word is capitalized, 
                            //--- and the conversion POS is a possibility for this word, convert the 
                            //--- POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 iswupper( pProns[j - 1].orthStr[0] ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREVNOTCAP:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word is capitalized, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 !iswupper( pProns[j - 1].orthStr[0] ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 2; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word two previous matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j - 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 2; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the word two after matches, and the
                            //--- conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                 _wcsicmp( pProns[j + 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case PREV1OR2W:
            {
                if ( cNumOfWords > 2 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word OR the word two 
                            //--- previous matches, and the conversion POS is a possibility for this word, 
                            //--- convert the POS.
                            if ( ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) ||
                                 ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j - 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1OR2W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word matches OR the word two after
                            //--- matches, and the conversion POS is a possibility for this word, convert the 
                            //--- POS.
                            if ( ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) ||
                                 ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                                   _wcsicmp( pProns[j + 2].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 ) )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the previous
                            //--- word matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                    &&
                                 _wcsicmp( pProns[j].orthStr,     g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1W:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the next
                            //--- word matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                    &&
                                 _wcsicmp( pProns[j].orthStr,     g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the previous
                            //--- POS matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1T:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current word matches, and the next
                            //--- POS matches, and the conversion POS is a possibility for this word, convert
                            //--- the POS.
                            if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRW:
            {
                for ( ULONG j = 0; j < cNumOfWords; j++ )
                {
                    if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                    {
                        //--- If the current POS matches, and the current word matches, and the
                        //--- conversion POS is a possibility for this word, convert the POS.
                        if ( pProns[j].POSchoice == g_POSTaggerPatches[i].eCurrentPOS &&
                             _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                        {
                            TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS ) ;
                        }
                    }
                }
            }
            break;
        case PREV1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the previous word and POS match, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case NEXT1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the next word and POS match, and
                            //--- the conversion POS is a possibility for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS   &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1 &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord1 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWPREV1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 1; j < cNumOfWords; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current words matches, and the
                            //--- previous word and POS match, and the conversion POS is a possibility
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 )     == 0 &&
                                 pProns[j - 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1              &&
                                 _wcsicmp( pProns[j - 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        case CURRWNEXT1WT:
            {
                if ( cNumOfWords > 1 )
                {
                    for ( ULONG j = 0; j < cNumOfWords - 1; j++ )
                    {
                        if ( pProns[j].XMLPartOfSpeech == MS_Unknown )
                        {
                            //--- If the current POS matches, and the current words matches, and the
                            //--- next word and POS match, and the conversion POS is a possibility
                            //--- for this word, convert the POS.
                            if ( pProns[j].POSchoice     == g_POSTaggerPatches[i].eCurrentPOS                &&
                                 _wcsicmp( pProns[j].orthStr, g_POSTaggerPatches[i].pTemplateWord1 )     == 0 &&
                                 pProns[j + 1].POSchoice == g_POSTaggerPatches[i].eTemplatePOS1              &&
                                 _wcsicmp( pProns[j + 1].orthStr, g_POSTaggerPatches[i].pTemplateWord2 ) == 0 )
                            {
                                TryPOSConversion( pProns[j], g_POSTaggerPatches[i].eConvertToPOS );
                            }
                        }
                    }
                }
            }
            break;
        }
    }
} /* DisambiguatePOS */

/*****************************************************************************
* Pronounce *
*-----------*
*	Description:
*		Get lexicon or letter-to-sound (LTS) pronunciations
*		
********************************************************************** MC ***/
HRESULT CStdSentEnum::Pronounce( PRONRECORD *pPron )
{
    SPDBG_FUNC( "Pronounce" );
    SPWORDPRONUNCIATIONLIST 	SPList;
    HRESULT 	hr = SPERR_NOT_IN_LEX;
    ULONG	cPhonLen;
    DWORD dwFlags = eLEXTYPE_USER | eLEXTYPE_APP | eLEXTYPE_PRIVATE1 | eLEXTYPE_PRIVATE2;
    BOOL  fPOSExists = false;
    
    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );

    //--- Special Case - XML Provided Part Of Speech.  Search for exact match first...
    if ( pPron->XMLPartOfSpeech != MS_Unknown )
    {
        //--- Try User Lexicon
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_USER, &SPList );
        if ( SUCCEEDED( hr ) &&
             SPList.pFirstWordPronunciation )
        {
            for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                  pPronunciation = pPronunciation->pNextWordPronunciation )
            {
                if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                {
                    fPOSExists = true;
                    break;
                }
            }
            if ( !fPOSExists )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
            }
        }
        //--- Handle empty pronunciation
        else if ( !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
        //--- Try App Lexicon
        if ( !fPOSExists )
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_APP, &SPList );
            if ( SUCCEEDED( hr ) &&
                SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
        //--- Try Vendor Lexicon
        if ( !fPOSExists )
        {
            hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE1, &SPList );
            if ( SUCCEEDED( hr ) &&
                 SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
        //--- Try Morph Lexicon
        if ( !fPOSExists )
        {
            hr = m_pMorphLexicon->DoSuffixMorph( pPron->orthStr, pPron->lemmaStr, 1033, dwFlags, &SPList );
            if ( SUCCEEDED( hr ) &&
                 SPList.pFirstWordPronunciation )
            {
                for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation;
                      pPronunciation = pPronunciation->pNextWordPronunciation )
                {
                    if ( pPronunciation->ePartOfSpeech == pPron->XMLPartOfSpeech )
                    {
                        fPOSExists = true;
                        break;
                    }
                }
                if ( !fPOSExists )
                {
                    //--- Need to do this the last time, to make sure we hit the default code below...
                    //--- RAID 5078
                    hr = SPERR_NOT_IN_LEX;
                    if ( SPList.pvBuffer )
                    {
                        ::CoTaskMemFree( SPList.pvBuffer );
                        ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                    }
                }
            }
            //--- Handle empty pronunciation
            else if ( !SPList.pFirstWordPronunciation )
            {
                if ( SPList.pvBuffer )
                {
                    ::CoTaskMemFree( SPList.pvBuffer );
                    ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
                }
                hr = SPERR_NOT_IN_LEX;
            }
        }
    }
        
    //--- Default case - just look up orthography and go with first match.
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_USER, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }            
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_APP, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE1, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_pMorphLexicon->DoSuffixMorph( pPron->orthStr, pPron->lemmaStr, 1033, 
                                             dwFlags, &SPList );

        //--- Handle empty pronunciation
        if ( SUCCEEDED( hr ) &&
             !SPList.pFirstWordPronunciation )
        {
            if ( SPList.pvBuffer )
            {
                ::CoTaskMemFree( SPList.pvBuffer );
                ZeroMemory( &SPList, sizeof(SPWORDPRONUNCIATIONLIST) );
            }
            hr = SPERR_NOT_IN_LEX;
        }
    }
    if ( hr == SPERR_NOT_IN_LEX )
    {
        hr = m_cpAggregateLexicon->GetPronunciations( pPron->orthStr, 1033, eLEXTYPE_PRIVATE2, &SPList );

        //--- Make all LTS words Nouns...
        for ( SPWORDPRONUNCIATION *pPronunciation = SPList.pFirstWordPronunciation; pPronunciation; 
              pPronunciation = pPronunciation->pNextWordPronunciation )
        {
            pPronunciation->ePartOfSpeech = SPPS_Noun;
        }
    }

    if (SUCCEEDED(hr))
    {
        //--- WARNING - this assumes pronunciations will only come from one type of lexicon, an assumption
        //---   which was true as of July, 2000
        pPron->pronType = SPList.pFirstWordPronunciation->eLexiconType;

        //------------------------------------------------------------
        // SAPI unrolls pronunciations from their POS.
        // So roll them back into the original collapsed array 
        // of one or two candidates with sorted POS (argh...)
        //------------------------------------------------------------
        SPWORDPRONUNCIATION 	*firstPron, *pCurPron, *pNextPron;
        
        //------------------------------------------
        // Init  pronunciation A
        //------------------------------------------
        pCurPron = firstPron = SPList.pFirstWordPronunciation;
        pPron->pronArray[PRON_A].POScount = 1;
        //----------------------------
        // Get phoneme length
        //----------------------------
        cPhonLen = wcslen( firstPron->szPronunciation ) + 1;	// include delimiter
        //----------------------------
        // Clip phoneme string to max  
        //----------------------------
        if( cPhonLen > SP_MAX_PRON_LENGTH )
        {
            cPhonLen = SP_MAX_PRON_LENGTH;
        }
        //----------------------------
        // Copy unicode phoneme string
        //----------------------------
        memcpy( pPron->pronArray[PRON_A].phon_Str, firstPron->szPronunciation, cPhonLen * sizeof(WCHAR) );
        // RAID 21464 - null-terminate SP_MAX_PRON_LENGTH length pronunciations...
        pPron->pronArray[PRON_A].phon_Str[cPhonLen-1] = 0;
        pPron->pronArray[PRON_A].phon_Len = cPhonLen -1;		// minus delimiter
        pPron->pronArray[PRON_A].POScode[0] = (ENGPARTOFSPEECH)firstPron->ePartOfSpeech; 
        
        //------------------------------------------
        // Init  pronunciation B
        //------------------------------------------
        pPron->pronArray[PRON_B].POScount = 0;
        pPron->pronArray[PRON_B].phon_Len = 0;

        pNextPron = pCurPron->pNextWordPronunciation;
        
        while( pNextPron )
        {
            int 	isDiff;
            
            isDiff = wcscmp( firstPron->szPronunciation, pNextPron->szPronunciation );
            if( isDiff )
            {
                //------------------------------------------------
                // Next pronunciation is different from 1st
                //------------------------------------------------
                if( pPron->pronArray[PRON_B].POScount < POS_MAX )
                {
                    //---------------------------------------
                    // Gather POS B into array
                    //---------------------------------------
                    pPron->pronArray[PRON_B].POScode[pPron->pronArray[PRON_B].POScount] = 
                        (ENGPARTOFSPEECH)pNextPron->ePartOfSpeech;
                    pPron->pronArray[PRON_B].POScount++;
                    if( pPron->pronArray[PRON_B].phon_Len == 0 )
                    {
                        //-----------------------------------------
                        // If there's no B pron yet, make one
                        //-----------------------------------------
                        cPhonLen = wcslen( pNextPron->szPronunciation ) + 1;	// include delimiter
                        //----------------------------
                        // Clip phoneme string to max
                        //----------------------------
                        if( cPhonLen > SP_MAX_PRON_LENGTH )
                        {
                            cPhonLen = SP_MAX_PRON_LENGTH;
                        }
                        //----------------------------
                        // Copy unicode phoneme string
                        //----------------------------
                        memcpy( pPron->pronArray[PRON_B].phon_Str, 
                            pNextPron->szPronunciation, 
                            cPhonLen * sizeof(WCHAR) );
                        // RAID 21464 - null-terminate SP_MAX_PRON_LENGTH length pronunciations...
                        pPron->pronArray[PRON_B].phon_Str[cPhonLen-1] = 0;
                        pPron->pronArray[PRON_B].phon_Len = cPhonLen -1;		// minus delimiter
                        pPron->hasAlt = true;
                    } 
                }
            }
            else
            {
                //------------------------------------------------
                // Next pronunciation is same as 1st
                //------------------------------------------------
                if( pPron->pronArray[PRON_A].POScount < POS_MAX )
                {
                    //---------------------------------------
                    // Gather POS A into array
                    //---------------------------------------
                    pPron->pronArray[PRON_A].POScode[pPron->pronArray[PRON_A].POScount] = 
                        (ENGPARTOFSPEECH)pNextPron->ePartOfSpeech;
                    pPron->pronArray[PRON_A].POScount++;
                }
            }
            pCurPron = pNextPron;
            pNextPron = pCurPron->pNextWordPronunciation;
        }
    }

    //--- If XML POS provided, set selection now as it won't be touched by the POS Tagger
    if ( pPron->XMLPartOfSpeech != MS_Unknown )
    {
        BOOL fMadeMatch = false;

        //--- Check first pronunciation
        for ( ULONG i = 0; i < pPron->pronArray[0].POScount; i++ )
        {
            if ( pPron->pronArray[0].POScode[i] == pPron->XMLPartOfSpeech )
            {
                pPron->altChoice = 0;
                pPron->POSchoice = pPron->XMLPartOfSpeech;
                fMadeMatch = true;
            }
        }

        //--- Check second pronunciation
        if ( pPron->hasAlt )
        {
            for ( ULONG i = 0; i < pPron->pronArray[1].POScount; i++ )
            {
                if ( pPron->pronArray[1].POScode[i] == pPron->XMLPartOfSpeech )
                {
                    pPron->altChoice = 1;
                    pPron->POSchoice = pPron->XMLPartOfSpeech;
                    fMadeMatch = true;
                }
            }
        }

        //--- If this POS didn't exist for the word, let POS Tagger do its thing
        //--- to determine a pronunciation, and then reassign the POS later...
        if ( !fMadeMatch )
        {
            pPron->XMLPartOfSpeech = MS_Unknown;
            pPron->POSchoice       = pPron->pronArray[PRON_A].POScode[0];
        }
    }
    //--- Set default POS, for later refinement by POS Tagger
    else
    {
        pPron->POSchoice = pPron->pronArray[PRON_A].POScode[0];
        pPron->altChoice = PRON_A;
    }

    if( SPList.pvBuffer )
    {
        ::CoTaskMemFree( SPList.pvBuffer );
    }

    return hr;
} /* Pronounce */

/*****************************************************************************
* CStdSentEnum::DetermineProns *
*------------------------------*
*   Description:
* 	  This method determines POS and looks up the pronounciation
********************************************************************* MC ****/
HRESULT CStdSentEnum::DetermineProns( CItemList& ItemList, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::DetermineProns" );
    HRESULT hr = S_OK;
    ULONG cNumOfProns, cPronIndex;
    PRONRECORD*	  pProns = NULL;

    //--- Count the total number of pronunciations needed
    cNumOfProns = 0;
    SPLISTPOS ListPos = ItemList.GetHeadPosition();
    while( ListPos )
    {
        TTSSentItem& Item = ItemList.GetNext( ListPos );
        for ( ULONG i = 0; i < Item.ulNumWords; i++ )
        {
            if( Item.Words[i].pWordText &&
                ( Item.Words[i].pXmlState->eAction == SPVA_Speak || 
                  Item.Words[i].pXmlState->eAction == SPVA_SpellOut || 
                  Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
            {
                ++cNumOfProns;
            }
        }
    }

    if ( cNumOfProns )
    {
        pProns = new PRONRECORD[cNumOfProns];

        if( !pProns )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //--- First, get item pronunciation(s)
            ZeroMemory( pProns, cNumOfProns * sizeof(PRONRECORD) );
            cPronIndex = 0;
            ListPos = ItemList.GetHeadPosition();

            //--- Iterate through ItemList
            while( ListPos && SUCCEEDED( hr ) )
            {
                TTSSentItem& Item = ItemList.GetNext( ListPos );
                //--- Iterate over Words
                for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                {
                    //--- Get pronunciations and parts of speech for spoken items only
                    if ( Item.Words[i].pWordText && 
                         ( Item.Words[i].pXmlState->eAction == SPVA_Speak ||
                           Item.Words[i].pXmlState->eAction == SPVA_SpellOut ||
                           Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
                    {
                        SPDBG_ASSERT( cPronIndex < cNumOfProns );
                        ULONG cItemLen = Item.Words[i].ulWordLen;
                        //--- Clip at max text length
                        if( cItemLen > ( SP_MAX_WORD_LENGTH-1 ) )
                        {
                            cItemLen = SP_MAX_WORD_LENGTH - 1;
                        }
                        //--- Copy item text
                        memcpy( pProns[cPronIndex].orthStr, 
                                Item.Words[i].pWordText, 
                                cItemLen * sizeof(WCHAR) );
                        pProns[cPronIndex].orthStr[cItemLen] = 0;
                        //--- Set Part of Speech, if given in XML
                        if ( Item.Words[i].pXmlState->ePartOfSpeech != MS_Unknown )
                        {
                            pProns[cPronIndex].XMLPartOfSpeech = (ENGPARTOFSPEECH)Item.Words[i].pXmlState->ePartOfSpeech;
                        }
                        //--- Do Lex Lookup, if necessary
                        if ( Item.Words[i].pXmlState->pPhoneIds == NULL || 
                             Item.Words[i].pXmlState->ePartOfSpeech == MS_Unknown )
                        {
                            //--- Special Case - Disambiguate Abbreviations
                            if ( Item.pItemInfo->Type == eABBREVIATION ||
                                 Item.pItemInfo->Type == eABBREVIATION_NORMALIZE )
                            {
                                const AbbrevRecord *pAbbrevInfo = 
                                    ( (TTSAbbreviationInfo*) Item.pItemInfo )->pAbbreviation;
                                if ( pAbbrevInfo->iPronDisambig < 0 )
                                {
                                    //--- Default case - just take the first (and only) pronunciation
                                    pProns[cPronIndex].pronArray[PRON_A].POScount   = 1;
                                    wcscpy( pProns[cPronIndex].pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                                    pProns[cPronIndex].pronArray[PRON_A].phon_Len   = 
                                        wcslen( pProns[cPronIndex].pronArray[PRON_A].phon_Str );
                                    pProns[cPronIndex].pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                                    pProns[cPronIndex].pronArray[PRON_B].POScount   = 0;
                                    pProns[cPronIndex].pronArray[PRON_B].phon_Len   = 0;
                                    pProns[cPronIndex].hasAlt                       = false;
                                    pProns[cPronIndex].altChoice                    = PRON_A;
                                    pProns[cPronIndex].POSchoice                    = pAbbrevInfo->POS1;
                                    //--- Abbreviation table prons are basically just vendor lex prons...
                                    pProns[cPronIndex].pronType                     = eLEXTYPE_PRIVATE1;
                                }
                                else
                                {
                                    hr = ( this->*g_PronDisambigTable[pAbbrevInfo->iPronDisambig] )
                                                ( pAbbrevInfo, &pProns[cPronIndex], ItemList, ListPos ); 
                                }
								pProns[cPronIndex].fUsePron = true;
                            }
                            //--- Default case
                            else
                            {
                                //--- Check disambiguation list
                                const AbbrevRecord* pAbbrevRecord = 
                                    (AbbrevRecord*) bsearch( (void*) pProns[cPronIndex].orthStr, (void*) g_AmbiguousWordTable,
                                                             sp_countof( g_AmbiguousWordTable ), sizeof( AbbrevRecord ),
                                                             CompareStringAndAbbrevRecord );
                                if ( pAbbrevRecord )
                                {
                                    hr = ( this->*g_AmbiguousWordDisambigTable[pAbbrevRecord->iPronDisambig] )
                                                ( pAbbrevRecord, &pProns[cPronIndex], ItemList, ListPos );
                                    pProns[cPronIndex].fUsePron = true;
                                }
                                //--- Do Lex Lookup, if necessary
                                else
                                {
                                    hr = Pronounce( &pProns[cPronIndex] );
                                }
                            }
                        }
                        cPronIndex++;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                //--- Next, disambiguate part-of-speech
                DisambiguatePOS( pProns, cNumOfProns );

                //--- Output debugging information
                TTSDBG_LOGPOSPOSSIBILITIES( pProns, cNumOfProns, STREAM_POSPOSSIBILITIES );

                //--- Finally, copy selected pronunciation to 'ItemList'
                PRONUNIT *selectedUnit;
                cPronIndex = 0;
                ListPos = ItemList.GetHeadPosition();

                while( ListPos && SUCCEEDED(hr) )
                {
                    TTSSentItem& Item = ItemList.GetNext( ListPos );
                    for ( ULONG i = 0; i < Item.ulNumWords; i++ )
                    {
                        //--- Set pronunciation and part-of-speech for spoken items only
                        if( Item.Words[i].pWordText &&
                            ( Item.Words[i].pXmlState->eAction == SPVA_Speak || 
                              Item.Words[i].pXmlState->eAction == SPVA_SpellOut ||
                              Item.Words[i].pXmlState->eAction == SPVA_Pronounce ) )
                        {
                            SPDBG_ASSERT( cPronIndex < cNumOfProns );
                            //--- Use XML specified pronunciation, if given.
                            if ( Item.Words[i].pXmlState->pPhoneIds )
                            {
                                Item.Words[i].pWordPron = Item.Words[i].pXmlState->pPhoneIds;
                            }
                            else
                            {
                                selectedUnit = &pProns[cPronIndex].pronArray[pProns[cPronIndex].altChoice];
                                Item.Words[i].pWordPron =
                                    (SPPHONEID*) MemoryManager.GetMemory( (selectedUnit->phon_Len + 1) * 
                                                                          sizeof(SPPHONEID), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    wcscpy( Item.Words[i].pWordPron, selectedUnit->phon_Str );
                                }
                            }

                            //--- Use XML specified part-of-speech, if given.  This will override the case
                            //--- where the POS didn't exist as an option and the POS Tagger did its thing
                            //--- to find a pronunciation.
                            if ( Item.Words[i].pXmlState->ePartOfSpeech != MS_Unknown )
                            {
                                Item.Words[i].eWordPartOfSpeech = (ENGPARTOFSPEECH)Item.Words[i].pXmlState->ePartOfSpeech;
                            }
                            else
                            {
                                Item.Words[i].eWordPartOfSpeech = pProns[cPronIndex].POSchoice;
                            }

                            //--- Root word
                            if ( pProns[cPronIndex].lemmaStr[0] )
                            {
                                Item.Words[i].ulLemmaLen = wcslen( pProns[cPronIndex].lemmaStr );
                                Item.Words[i].pLemma = 
                                    (WCHAR*) MemoryManager.GetMemory( Item.Words[i].ulLemmaLen * sizeof(WCHAR), &hr );
                                if ( SUCCEEDED( hr ) )
                                {                               
                                    wcsncpy( (WCHAR*) Item.Words[i].pLemma, pProns[cPronIndex].lemmaStr,
                                             Item.Words[i].ulLemmaLen );
                                }
                            }

                            //--- Insert pron in text, if appropriate - RAID #4746
                            if ( pProns[cPronIndex].fUsePron )
                            {
                                ULONG ulNumChars = wcslen( Item.Words[i].pWordPron );
                                Item.Words[i].pWordText = 
                                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( (WCHAR*) Item.Words[i].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                                    (WCHAR) Item.Words[i].pWordText[0] = L'*';
                                    wcscpy( ( (WCHAR*) Item.Words[i].pWordText + 1 ), Item.Words[i].pWordPron );
                                    (WCHAR) Item.Words[i].pWordText[ ulNumChars + 1 ] = L'*';
									Item.Words[i].ulWordLen = ulNumChars + 2;
                                }
                            }

                            cPronIndex++;
                        }
                    }
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                //--- Check Post POS disambiguation list
                SPLISTPOS ListPos = ItemList.GetHeadPosition();
                while ( ListPos && SUCCEEDED( hr ) )
                {
                    TTSSentItem& Item = ItemList.GetNext( ListPos );
                    if ( Item.pItemInfo->Type == eALPHA_WORD ||
                         Item.pItemInfo->Type == eABBREVIATION ||
                         Item.pItemInfo->Type == eABBREVIATION_NORMALIZE )
                    {
                        WCHAR temp;
                        BOOL fPeriod = false;
                        if ( Item.pItemSrcText[Item.ulItemSrcLen - 1] == L'.' &&
                             Item.ulItemSrcLen > 1 )
                        {
                            temp = Item.pItemSrcText[Item.ulItemSrcLen - 1];
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen - 1 ) = 0;
                            fPeriod = true;
                        }
                        else
                        {
                            temp = Item.pItemSrcText[Item.ulItemSrcLen];
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen ) = 0;
                        }

                        const AbbrevRecord* pAbbrevRecord =
                            (AbbrevRecord*) bsearch( (void*) Item.pItemSrcText, (void*) g_PostLexLookupWordTable,
                                                     sp_countof( g_PostLexLookupWordTable ), sizeof( AbbrevRecord ),
                                                     CompareStringAndAbbrevRecord );
                        if ( pAbbrevRecord )
                        {
                            hr = ( this->*g_PostLexLookupDisambigTable[pAbbrevRecord->iPronDisambig] )
                                        ( pAbbrevRecord, ItemList, ListPos, MemoryManager );
                        }
                
                        if ( fPeriod )
                        {
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen - 1 ) = temp;
                        }
                        else
                        {
                            *( (WCHAR*) Item.pItemSrcText + Item.ulItemSrcLen ) = temp;
                        }
                    }
                }
            }
        }
    }
    
    if (pProns)
    {
        delete [] pProns;
    }

    return hr;
} /* CStdSentEnum::DetermineProns */

/***********************************************************************************************
* MeasurementDisambig *
*---------------------*
*   Description:
*       This overrides initial pronunciations of measurement abbreviations when they are used
*   as modifiers - e.g. "a 7 ft. pole" vs. "the pole was 7 ft. long"
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::MeasurementDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                           SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::MeasurementDisambig" );
    HRESULT hr = S_OK;

    //--- Get previous two items
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                TTSSentItem TempItem = ItemList.GetPrev( TempPos );
                //--- Previous must be a number
                if ( TempItem.pItemInfo->Type == eNUM_CARDINAL )
                {
                    //--- Get next item
                    TempPos = ListPos;
                    TempItem = ItemList.GetNext( TempPos );
                    //--- Next must be a noun or adj
                    if ( TempItem.eItemPartOfSpeech == MS_Noun )
                    {
                        //--- Matched a 7 ft. pole type example - go with singular
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& MeasurementItem = ItemList.GetPrev( TempPos );
                        //--- Singular will always be shorter than plural, so this should never overwrite
                        //---   anything...
                        wcscpy( MeasurementItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( MeasurementItem.Words[0].pWordPron );
                        MeasurementItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) MeasurementItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) MeasurementItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) MeasurementItem.Words[0].pWordText + 1 ), MeasurementItem.Words[0].pWordPron );
                            (WCHAR) MeasurementItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							MeasurementItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else if ( TempItem.eItemPartOfSpeech == MS_Adj &&
                              TempPos )
                    {
                        //--- Next must be a noun
                        TempItem = ItemList.GetNext( TempPos );
                        {
                            if ( TempItem.eItemPartOfSpeech == MS_Noun )
                            {
                                //--- Matched a 7 ft. pole type example - go with singular
                                TempPos = ListPos;
                                ItemList.GetPrev( TempPos );
                                TTSSentItem& MeasurementItem = ItemList.GetPrev( TempPos );
                                //--- Singular will always be shorter than plural, so this should never overwrite
                                //---   anything...
                                wcscpy( MeasurementItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );

                                //--- Insert pron into word text - RAID #4746
                                ULONG ulNumChars = wcslen( MeasurementItem.Words[0].pWordPron );
                                MeasurementItem.Words[0].pWordText = 
                                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                                if ( SUCCEEDED( hr ) )
                                {
                                    ZeroMemory( (WCHAR*) MeasurementItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                                    (WCHAR) MeasurementItem.Words[0].pWordText[0] = L'*';
                                    wcscpy( ( (WCHAR*) MeasurementItem.Words[0].pWordText + 1 ), MeasurementItem.Words[0].pWordPron );
                                    (WCHAR) MeasurementItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
									MeasurementItem.Words[0].ulWordLen = ulNumChars + 2;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
} /* MeasurementDisambig */

/***********************************************************************************************
* TheDisambig *
*-------------*
*   Description:
*       This function disambiguates the word the - before a vowel it becomes "thee", before a
*   consonant it is "thuh"...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::TheDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                   SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::TheDisambig" );
    HRESULT hr = S_OK;

    //--- Get next item
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        TTSSentItem NextItem = ItemList.GetNext( TempPos );

        if ( NextItem.Words[0].pWordPron &&
             bsearch( (void*) NextItem.Words[0].pWordPron, (void*) g_Vowels, sp_countof( g_Vowels ), 
                      sizeof( WCHAR ), CompareWCHARAndWCHAR ) )
        {
            //--- Matched a vowel - go with / DH IY 1 /
            TempPos = ListPos;
            ItemList.GetPrev( TempPos );
            TTSSentItem& TheItem = ItemList.GetPrev( TempPos );
            //--- The two pronunciations are exactly the same length, so this should never overwrite
            //---   anything
            wcscpy( TheItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
            TheItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
            //--- Insert pron into word text - RAID #4746
            ULONG ulNumChars = wcslen( TheItem.Words[0].pWordPron );
            TheItem.Words[0].pWordText = 
                (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( (WCHAR*) TheItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                (WCHAR) TheItem.Words[0].pWordText[0] = L'*';
                wcscpy( ( (WCHAR*) TheItem.Words[0].pWordText + 1 ), TheItem.Words[0].pWordPron );
                (WCHAR) TheItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
				TheItem.Words[0].ulWordLen = ulNumChars + 2;
            }
        }
        else
        {
            //--- Didn't match a vowel - go with / DH AX 1 /
            TempPos = ListPos;
            ItemList.GetPrev( TempPos );
            TTSSentItem& TheItem = ItemList.GetPrev( TempPos );
            //--- The two pronunciations are exactly the same length, so this should never overwrite
            //---   anything
            wcscpy( TheItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
            TheItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
            //--- Insert pron into word text - RAID #4746
            ULONG ulNumChars = wcslen( TheItem.Words[0].pWordPron );
            TheItem.Words[0].pWordText = 
                (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
            if ( SUCCEEDED( hr ) )
            {
                ZeroMemory( (WCHAR*) TheItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                (WCHAR) TheItem.Words[0].pWordText[0] = L'*';
                wcscpy( ( (WCHAR*) TheItem.Words[0].pWordText + 1 ), TheItem.Words[0].pWordPron );
                (WCHAR) TheItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
				TheItem.Words[0].ulWordLen = ulNumChars + 2;
            }
        }
    }

    return hr;
} /* TheDisambig */

/***********************************************************************************************
* ADisambig *
*-----------*
*   Description:
*       This function disambiguates the word "a" - / EY 1 - Noun / vs. / AX - Det /
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ADisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, CItemList& ItemList, 
                                 SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::ADisambig" );
    HRESULT hr = S_OK;
    BOOL fNoun = false;

    //--- Get Current Item...
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TTSSentItem CurrentItem = ItemList.GetPrev( TempPos );

            //--- If "a" is part of a multi-word item, use the Noun pronunciation...
            //--- If "a" is not an AlphaWord, use the Noun pronunciation...
            if ( CurrentItem.ulNumWords > 1 ||
                 CurrentItem.pItemInfo->Type != eALPHA_WORD )
            {
                fNoun = true;
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
    }

    if ( !fNoun )
    {
        //--- Get Next Item...
        TempPos = ListPos;
        if ( TempPos )
        {
            TTSSentItem NextItem = ItemList.GetNext( TempPos );

            //--- If "a" is followed by punctuation, use the Noun pronunciation...
            if ( !( NextItem.pItemInfo->Type & eWORDLIST_IS_VALID ) )
            {
                fNoun = true;
                wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS1;
                pPron->POSchoice                    = pAbbrevInfo->POS1;
            }
        }
    }

    //--- Default - use the Determiner pronunciation (but include Noun pronunciation as well,
    //---   so that POS tagger rules will work properly)...
    if ( !fNoun )
    {
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->pronArray[PRON_A].POScount   = 1;
        pPron->POSchoice                    = pAbbrevInfo->POS2;
        wcscpy( pPron->pronArray[PRON_B].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_B].phon_Len   = wcslen( pPron->pronArray[PRON_B].phon_Str );
        pPron->pronArray[PRON_B].POScode[0] = pAbbrevInfo->POS1;
        pPron->pronArray[PRON_B].POScount   = 1;
        pPron->hasAlt = true;
    }

    return hr;
} /* ADisambig */

/***********************************************************************************************
* PolishDisambig *
*----------------*
*   Description:
*       This function disambiguates the word "polish" - [p ow 1 l - ax sh - Noun] vs.
*   [p ow 1 l - ax sh - Adj] vs. [p aa 1 l - ih sh - Verb] vs. [p aa 1 l - ih sh - Noun]
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::PolishDisambig( const AbbrevRecord* pAbbrevInfo, PRONRECORD* pPron, CItemList& ItemList, 
                                      SPLISTPOS ListPos )
{
    SPDBG_FUNC( "CStdSentEnum::PolishDisambig" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;

    //--- Get Current Item...
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            TTSSentItem CurrentItem = ItemList.GetPrev( TempPos );

            //--- If "Polish" is capitalized and not sentence-initial, and not preceded immediately
            //--- by an open double-quote or parenthesis, use Noun...
            if ( iswupper( CurrentItem.pItemSrcText[0] ) )
            {
                BOOL fSentenceInitial = false;
                if ( !TempPos )
                {
                    fSentenceInitial = true;
                }
                else
                {
                    TTSSentItem PrevItem = ItemList.GetPrev( TempPos );
                    if ( PrevItem.pItemInfo->Type == eOPEN_PARENTHESIS ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACKET     ||
                         PrevItem.pItemInfo->Type == eOPEN_BRACE       ||
                         PrevItem.pItemInfo->Type == eSINGLE_QUOTE     ||
                         PrevItem.pItemInfo->Type == eDOUBLE_QUOTE )
                    {
                        fSentenceInitial = true;
                    }
                }
                if ( fSentenceInitial )
                {
                    fMatch = true;
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
                    pPron->POSchoice                    = pAbbrevInfo->POS2;
                }
                else
                {
                    fMatch = true;
                    wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron1 );
                    pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
                    pPron->pronArray[PRON_A].POScode[0] = MS_Noun;
                    pPron->POSchoice                    = MS_Noun;
                }
            }
        }
    }

    //--- Default - use the Verb pronunciation (but include the others as well,
    //---   so that POS tagger rules will work properly)...
    if ( !fMatch )
    {
        //--- Verb, Noun
        wcscpy( pPron->pronArray[PRON_A].phon_Str, pAbbrevInfo->pPron2 );
        pPron->pronArray[PRON_A].phon_Len   = wcslen( pPron->pronArray[PRON_A].phon_Str );
        pPron->pronArray[PRON_A].POScode[0] = pAbbrevInfo->POS2;
        pPron->pronArray[PRON_A].POScode[1] = pAbbrevInfo->POS3;
        pPron->pronArray[PRON_A].POScount   = 2;
        //--- Adj
        wcscpy( pPron->pronArray[PRON_B].phon_Str, pAbbrevInfo->pPron1 );
        pPron->pronArray[PRON_B].phon_Len   = wcslen( pPron->pronArray[PRON_B].phon_Str );
        pPron->pronArray[PRON_B].POScode[0] = pAbbrevInfo->POS1;
        pPron->pronArray[PRON_B].POScount   = 1;
        //--- Set initial choice to Verb...
        pPron->POSchoice                    = pAbbrevInfo->POS2;
        pPron->hasAlt = true;
    }

    return hr;
} /* PolishDisambig */

/***********************************************************************************************
* ReadDisambig *
*--------------*
*   Description:
*       This function disambiguates the word Read - past tense vs. present...
*
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ReadDisambig( const AbbrevRecord* pAbbrevInfo, CItemList& ItemList, 
                                    SPLISTPOS ListPos, CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::ReadDisambig" );
    HRESULT hr = S_OK;
    BOOL fMatch = false;

    //--- Get prev item
    SPLISTPOS TempPos = ListPos;
    if ( TempPos )
    {
        ItemList.GetPrev( TempPos );
        if ( TempPos )
        {
            ItemList.GetPrev( TempPos );
            if ( TempPos )
            {
                TTSSentItem PrevItem = ItemList.GetPrev( TempPos );

                //--- Check for closest auxiliary
                while ( PrevItem.Words[0].eWordPartOfSpeech != MS_VAux  &&
                        PrevItem.Words[0].eWordPartOfSpeech != MS_Contr &&
                        TempPos )
                {
                    PrevItem = ItemList.GetPrev( TempPos );
                }

                if ( PrevItem.Words[0].eWordPartOfSpeech == MS_VAux )
                {
                    fMatch = true;
                    if ( wcsnicmp( PrevItem.Words[0].pWordText, L"have", 4 )    == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"has", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"had", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"am", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"ain't", 5 )   == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"are", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"aren't", 6 )  == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"be", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"is", 2 )      == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"was", 3 )     == 0 ||
                         wcsnicmp( PrevItem.Words[0].pWordText, L"were", 4 )    == 0 )
                    {
                        //--- Matched have or haven't (has or hasn't, had or hadn't) - go with "red"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        //--- The two pronunciations are exactly the same length, so this should never overwrite
                        //---   anything
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else
                    {
                        //--- Some other auxiliary - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        //--- The two pronunciations are exactly the same length, so this should never overwrite
                        //---   anything
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
                //--- Check for pronoun aux contractions
                else if ( PrevItem.Words[0].eWordPartOfSpeech == MS_Contr )
                {
                    fMatch = true;
                    const WCHAR *pApostrophe = wcsstr( PrevItem.Words[0].pWordText, L"'" );
                    if ( pApostrophe &&
                         wcsnicmp( pApostrophe, L"'ll", 3 ) == 0 )
                    {
                        //--- Matched an 'll form - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                    else
                    {
                        //--- Some other form - go with "red"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
                //--- Check for infinitival form
                else 
                {
                    TempPos = ListPos;
                    ItemList.GetPrev( TempPos );
                    ItemList.GetPrev( TempPos );
                    PrevItem = ItemList.GetPrev( TempPos );

                    if ( PrevItem.Words[0].ulWordLen == 2 &&
                         wcsnicmp( PrevItem.Words[0].pWordText, L"to", 2 ) == 0 )
                    {
                        fMatch = true;

                        //--- Matched infinitival form - go with "reed"
                        TempPos = ListPos;
                        ItemList.GetPrev( TempPos );
                        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                        //--- Insert pron into word text - RAID #4746
                        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                        ReadItem.Words[0].pWordText = 
                            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
							ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                        }
                    }
                }
            }
            //--- Sentence initial - go with "reed"
            else
            {
                fMatch = true;

                TempPos = ListPos;
                ItemList.GetPrev( TempPos );
                TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
                wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron1 );
                ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS1;
                ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS1;

                //--- Insert pron into word text - RAID #4746
                ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
                ReadItem.Words[0].pWordText = 
                    (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
                    (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
                    wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
                    (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
					ReadItem.Words[0].ulWordLen = ulNumChars + 2;
                }
            }
        }
    }

    if ( !fMatch )
    {
        TempPos = ListPos;
        ItemList.GetPrev( TempPos );
        TTSSentItem& ReadItem = ItemList.GetPrev( TempPos );
        //--- Default - go with past tense...
        wcscpy( ReadItem.Words[0].pWordPron, pAbbrevInfo->pPron2 );
        ReadItem.Words[0].eWordPartOfSpeech = pAbbrevInfo->POS2;
        ReadItem.eItemPartOfSpeech = pAbbrevInfo->POS2;

        //--- Insert pron into word text - RAID #4746
        ULONG ulNumChars = wcslen( ReadItem.Words[0].pWordPron );
        ReadItem.Words[0].pWordText = 
            (WCHAR*) MemoryManager.GetMemory( ( ulNumChars + 3 ) * sizeof( WCHAR ), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( (WCHAR*) ReadItem.Words[0].pWordText, ( ulNumChars + 3 ) * sizeof( WCHAR ) );
            (WCHAR) ReadItem.Words[0].pWordText[0] = L'*';
            wcscpy( ( (WCHAR*) ReadItem.Words[0].pWordText + 1 ), ReadItem.Words[0].pWordPron );
            (WCHAR) ReadItem.Words[0].pWordText[ ulNumChars + 1 ] = L'*';
			ReadItem.Words[0].ulWordLen = ulNumChars + 2;
        }
    }

    return hr;
} /* ReadDisambig */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\tts\msttsdrv\engine\datenorm.cpp ===
#include "stdafx.h"

#ifndef StdSentEnum_h
#include "stdsentenum.h"
#endif

#pragma warning (disable : 4296)

/***********************************************************************************************
* IsNumericCompactDate *
*----------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Date, and if so, which type.  
*
*   RegExp:
*       {[1-12]{'/' || '-' || '.'}[1-31]{'/' || '-' || '.'}[0-9999]} ||
*       {[1-31]{'/' || '-' || '.'}[1-12]{'/' || '-' || '.'}[0-9999]} ||
*       {[0-9999]{'/' || '-' || '.'}[1-12]{'/' || '-' || '.'}[1-31]}
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsNumericCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                            CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "CStdSentEnum::IsNumericCompactDate" );

    HRESULT hr = S_OK;
    
    WCHAR *pFirstChunk = 0, *pSecondChunk = 0, *pThirdChunk = 0, *pLeftOver = 0, *pDelimiter = 0;
    ULONG ulFirst = 0;
    ULONG ulSecond = 0;
    ULONG ulThird = 0;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    bool bThree = false, bTwo = false;
    bool fMonthDayYear = false, fDayMonthYear = false, fYearMonthDay = false;

    //--- Max length of a string matching the regexp is 10 characters 
    if ( ulTokenLen > 10 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Get the preferred order of the compact Date 
        if ( Context != NULL )
        {
            if ( _wcsicmp( Context, L"Date_MDY" ) == 0 )
            {
                fMonthDayYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_DMY" ) == 0 )
            {
                fDayMonthYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_YMD" ) == 0 )
            {
                fYearMonthDay = true;
            }
            else
            {
                if ( m_eShortDateOrder & MONTH_DAY_YEAR )
                {
                    fMonthDayYear = true;
                }
                else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
                {
                    fDayMonthYear = true;
                }
                else
                {
                    fYearMonthDay = true;
                }
            }
        }
        else
        {
            if ( m_eShortDateOrder & MONTH_DAY_YEAR )
            {
                fMonthDayYear = true;
            }
            else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
            {
                fDayMonthYear = true;
            }
            else
            {
                fYearMonthDay = true;
            }
        }

        pFirstChunk = (WCHAR*) m_pNextChar;

        //----------------------------------------------
        // First Try To Get Three Numerical Values
        //----------------------------------------------

        ulFirst = my_wcstoul( pFirstChunk, &pSecondChunk );
        if ( pFirstChunk != pSecondChunk && 
             ( pSecondChunk - pFirstChunk ) <= 4 )
        {
            pDelimiter = pSecondChunk;
            if ( MatchDateDelimiter( &pSecondChunk ) )
            {
                ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
                if ( pSecondChunk != pThirdChunk &&
                     ( pThirdChunk - pSecondChunk ) <= 4 )
                {
                    if ( *pThirdChunk == *pDelimiter &&
                         MatchDateDelimiter( &pThirdChunk ) )
                    {
                        ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                        if ( pThirdChunk != pLeftOver                               && 
                             pLeftOver == ( pFirstChunk + ulTokenLen ) &&
                             ( pLeftOver - pThirdChunk ) <= 4 )
                        {
                            //--- Successfully Matched { d+{'/' || '-' || '.'}d+{'/' || '-' || '.'}d+ } 
                            bThree = true;
                        }
                        else 
                        {
                            //--- Digit-String Delimiter Digit-String Delimiter non-digit cannot be a Date,
                            //--- nor can Digit-String Delimiter Digit-String Delimiter Digit-String String 
                            hr = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        if ( pThirdChunk == m_pEndOfCurrItem )
                        {
                            //--- Successfully Matched { d+{'/' || '-' || '.'}d+ } 
                            bTwo = true;
                        }
                        else
                        {
                            //--- Digit-String Delimiter Digit-String non-delimiter cannot be a Date 
                            hr = E_INVALIDARG;
                        }
                    }
                }
            }
            else
            {
                //--- Digit-String followed by non-delimiter cannot be a Date 
                hr = E_INVALIDARG;
            }
        }

        //------------------------------------------------
        // Now Figure Out What To Do With The Values 
        //------------------------------------------------

        //--- Matched a Month, Day, and Year ---//
        if ( SUCCEEDED( hr ) && 
             bThree )
        {
            //--- Try to valiDate values 
            ULONG ulFirstChunkLength  = (ULONG)(pSecondChunk - pFirstChunk  - 1);
            ULONG ulSecondChunkLength = (ULONG)(pThirdChunk  - pSecondChunk - 1);
            ULONG ulThirdChunkLength  = (ULONG)(pLeftOver    - pThirdChunk);

            //--- Preferred order is Month Day Year 
            if (fMonthDayYear)
            {
                //--- Try Month Day Year, then Day Month Year, then Year Month Day 
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX ) && 
                     ( ulFirstChunkLength <= 3 )                    &&
                     ( DAYMIN <= ulSecond && ulSecond <= DAYMAX)    && 
                     ( ulSecondChunkLength <= 3 )                   &&
                     ( YEARMIN <= ulThird && ulThird <= YEARMAX)    && 
                     ( ulThirdChunkLength >= 2 ) )
                {
                    NULL;
                }
                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )        && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fMonthDayYear = false;
                    fDayMonthYear = true;
                }
                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                          ( ulFirstChunkLength >= 2 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                          ( ulThirdChunkLength <= 3 ) )
                {
                    fMonthDayYear = false;
                    fYearMonthDay = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            } 
            //--- Preferred order is Day Month Year 
            else if ( fDayMonthYear )
            {
                //--- Try Day Month Year, then Month Day Year, then Year Month Day 
                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                     ( ulFirstChunkLength <= 3 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                     ( ulSecondChunkLength <= 3 )                       &&
                     ( YEARMIN <= ulThird && ulThird <= YEARMAX )       && 
                     ( ulThirdChunkLength >= 2 ) )
                {
                    NULL;
                }
                else if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )    && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )      && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fDayMonthYear = false;
                    fMonthDayYear = true;
                }                
                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                          ( ulFirstChunkLength >= 2 )                       &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                          ( ulThirdChunkLength <= 3 ) )
                {
                    fDayMonthYear = false;
                    fYearMonthDay = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            //--- Preferred order is Year Month Day 
            else if (fYearMonthDay)
            {
                //--- Try Year Month Day, then Month Day Year, then Day Month Year 
                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )      && 
                     ( ulFirstChunkLength >= 2 )                       &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )  && 
                     ( ulSecondChunkLength <= 3 )                      &&
                     ( DAYMIN <= ulThird && ulThird <= DAYMAX )        && 
                     ( ulThirdChunkLength <= 3 ) )
                {
                    NULL;
                }
                else if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )    && 
                          ( ulFirstChunkLength <= 3 )                       &&
                          ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )      && 
                          ( ulSecondChunkLength <= 3 )                      &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )      && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fYearMonthDay = false;
                    fMonthDayYear = true;
                }                
                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                          ( ulFirstChunkLength <= 3 )                        &&
                          ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                          ( ulSecondChunkLength <= 3 )                       &&
                          ( YEARMIN <= ulThird && ulThird <= YEARMAX )       && 
                          ( ulThirdChunkLength >= 2 ) )
                {
                    fYearMonthDay = false;
                    fDayMonthYear = true;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            //--- Fill out DateItemInfo structure appropriately.
            if ( SUCCEEDED( hr ) )
            {
                pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                    pItemNormInfo->Type = eDATE;
                    if ( fMonthDayYear )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pSecondChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulSecondChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pSecondChunk + 
                                                                                          ulSecondChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                            }
                        }
                    }
                    else if ( fDayMonthYear )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pFirstChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulFirstChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pFirstChunk + 
                                                                                          ulFirstChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                            }
                        }
                    }
                    else if ( fYearMonthDay )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pThirdChunk == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = ulThirdChunkLength;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pThirdChunk + 
                                                                                          ulThirdChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                    (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                            if ( SUCCEEDED( hr ) )
                            {
                                ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pFirstChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulFirstChunkLength;
                            }
                        }
                    }          
                }
            }
        }
        //--- Matched just a Month and Day, or a Month and Year ---//
        else if ( SUCCEEDED( hr ) &&
                  Context         &&
                  bTwo )
        {
            ULONG ulFirstChunkLength  = (ULONG)(pSecondChunk - pFirstChunk  - 1);
            ULONG ulSecondChunkLength = (ULONG)(pThirdChunk  - pSecondChunk);

            if ( _wcsicmp(Context, L"Date_MD") == 0 )
            {
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX )     && 
                     ( ulFirstChunkLength <= 2 )                        &&
                     ( DAYMIN <= ulSecond && ulSecond <= DAYMAX )       && 
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and day 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( pSecondChunk[0] == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk + 1;
                                ulSecondChunkLength--;
                            }
                            else 
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver = ulSecondChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar  = 
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar + ulSecondChunkLength;
                        }
                    }

                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_DM") == 0 )
            {
                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )         && 
                     ( ulFirstChunkLength <= 2 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   && 
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and day 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( m_pNextChar[0] == L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk + 1;
                                ulFirstChunkLength--;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver = ulFirstChunkLength;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar  =
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar + ulFirstChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_MY") == 0 )
            {
                if ( ( MONTHMIN <= ulFirst && ulFirst <= MONTHMAX ) && 
                     ( ulFirstChunkLength <= 2 )                    &&
                     ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) &&
                     ( ulSecondChunkLength >= 2 ) )
                {
                    //--- Successfully matched a month and year 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex      = ulFirst;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear        = pSecondChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits  = ulSecondChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( _wcsicmp(Context, L"Date_YM") == 0 )
            {
                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )       && 
                     ( ulFirstChunkLength >= 2 )                        &&
                     ( MONTHMIN <= ulSecond && ulSecond <= MONTHMAX )   &&
                     ( ulSecondChunkLength <= 2 ) )
                {
                    //--- Successfully matched a month and year 
                    pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
                        pItemNormInfo->Type = eDATE;
                        ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex      = ulSecond;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = 
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pYear, sizeof(TTSYearItemInfo) );
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear        = pFirstChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits  = ulFirstChunkLength;
                        }
                    }
                }
                else // values out of range
                {
                    hr = E_INVALIDARG;
                }
            }
            //--- not a date unless context specifies...
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    
    return hr;
} /* IsNumericCompactDate */

/***********************************************************************************************
* IsMonthStringCompactDate *
*--------------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a Date with a string for the month, and if so, which type.  
*
*   RegExp:
*       {[MonthString]{'/' || '-' || '.'}[1-31]{'/' || '-' || '.'}[0-9999]} ||
*       {[1-31]{'/' || '-' || '.'}[MonthString]{'/' || '-' || '.'}[0-9999]} ||
*       {[0-9999]{'/' || '-' || '.'}[MonthString]{'/' || '-' || '.'}[1-31]}
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsMonthStringCompactDate( TTSItemInfo*& pItemNormInfo, const WCHAR* Context, 
                                                CSentItemMemory& MemoryManager )
{
    SPDBG_FUNC( "DateNorm.cpp IsMonthStringCompactDate" );

    HRESULT hr = S_OK;
    WCHAR *pFirstChunk = 0, *pSecondChunk = 0, *pThirdChunk = 0, *pLeftOver = 0;
    ULONG ulFirst = 0;
    ULONG ulSecond = 0;
    ULONG ulThird = 0;
    ULONG ulTokenLen = (ULONG)(m_pEndOfCurrItem - m_pNextChar);
    ULONG ulFirstChunkLength = 0, ulSecondChunkLength = 0, ulThirdChunkLength = 0;
    bool fMonthDayYear = false, fDayMonthYear = false, fYearMonthDay = false;

    //--- Max length of a Date matching this regexp is 17 characters 
    if ( ulTokenLen > 17 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Get preferred order of Month, Day, and Year for this user 
        if (Context != NULL)
        {
            if ( _wcsicmp( Context, L"Date_MDY" ) == 0 )
            {
                fMonthDayYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_DMY" ) == 0 )
            {
                fDayMonthYear = true;
            }
            else if ( _wcsicmp( Context, L"Date_YMD" ) == 0 )
            {
                fYearMonthDay = true;
            }
            else
            {
                if ( m_eShortDateOrder & MONTH_DAY_YEAR )
                {
                    fMonthDayYear = true;
                }
                else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
                {
                    fDayMonthYear = true;
                }
                else
                {
                    fYearMonthDay = true;
                }
            }
        }
        else
        {
            if ( m_eShortDateOrder & MONTH_DAY_YEAR )
            {
                fMonthDayYear = true;
            }
            else if ( m_eShortDateOrder & DAY_MONTH_YEAR )
            {
                fDayMonthYear = true;
            }
            else
            {
                fYearMonthDay = true;
            }
        }

        pFirstChunk = (WCHAR*) m_pNextChar;
        pSecondChunk = pFirstChunk;

        //--- Try MonthString-Day-Year format 
        if ( iswalpha( *pFirstChunk ) )
        {
            ulFirst = MatchMonthString( pSecondChunk, ulTokenLen );
            if ( ulFirst )
            {
                ulFirstChunkLength = (ULONG)(pSecondChunk - pFirstChunk);
                if ( MatchDateDelimiter( &pSecondChunk ) )
                {
                    pThirdChunk = pSecondChunk;
                    ulSecond = my_wcstoul( pSecondChunk, &pThirdChunk );
                    if ( pSecondChunk != pThirdChunk &&
                         pThirdChunk - pSecondChunk <= 2 )
                    {
                        ulSecondChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                        if ( MatchDateDelimiter( &pThirdChunk ) )
                        {
                            ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                            if ( pThirdChunk != pLeftOver &&
                                 pLeftOver - pThirdChunk <= 4 )
                            {
                                ulThirdChunkLength = (ULONG)(pLeftOver - pThirdChunk);
                                //--- May have matched a month, day and year - valiDate values 
                                if ( ( DAYMIN <= ulSecond && ulSecond <= DAYMAX ) &&
                                     ( ulSecondChunkLength <= 2 )                 &&               
                                     ( YEARMIN <= ulThird && ulThird <= YEARMAX ) &&
                                     ( ulThirdChunkLength >= 2 ) )
                                {
                                    //--- Successfully matched a month, day and year 
                                    fMonthDayYear = true;
                                    fDayMonthYear = false;
                                    fYearMonthDay = false;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        else
                        {
                            if ( !Context ||
                                 ( Context &&
                                   _wcsicmp( Context, L"Date_MD" ) == 0 ) )
                            {
                                if ( ( DAYMIN <= ulSecond && ulSecond <= DAYMAX ) &&
                                     ( ulSecondChunkLength <= 2 ) )
                                {
                                    fMonthDayYear = true;
                                    fDayMonthYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    fYearMonthDay = true;
                                    pFirstChunk   = pSecondChunk;
                                    ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                                    ulSecond      = ulFirst;
                                    pThirdChunk   = NULL;
                                }
                            }
                            else if ( Context && 
                                      _wcsicmp( Context, L"Date_MY" ) == 0 )
                            {
                                if ( ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) &&
                                     ( ulSecondChunkLength <= 4 ) )
                                {
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    fYearMonthDay = true;
                                    pFirstChunk   = pSecondChunk;
                                    ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                                    ulSecond      = ulFirst;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                    }
                    else if ( pSecondChunk != pThirdChunk &&
                              pThirdChunk - pSecondChunk <= 4 )
                    {
                        if ( ( YEARMIN <= ulSecond && ulSecond <= YEARMAX ) )
                        {
                            fMonthDayYear = false;
                            fDayMonthYear = false;
                            fYearMonthDay = true;
                            pFirstChunk   = pSecondChunk;
                            ulFirstChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                            ulSecond = ulFirst;
                            pThirdChunk   = NULL;
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        //--- Try Day-MonthString-Year and Year-MonthString-Day Formats 
        else if ( isdigit( *pFirstChunk ) )
        {
            ulFirst = my_wcstoul( pFirstChunk, &pSecondChunk );
            if ( pFirstChunk != pSecondChunk &&
                 pSecondChunk - pFirstChunk <= 4 )
            {
                ulFirstChunkLength = (ULONG)(pSecondChunk - pFirstChunk);
                if ( MatchDateDelimiter( &pSecondChunk ) )
                {
                    pThirdChunk = pSecondChunk;
                    ulSecond = MatchMonthString( pThirdChunk, ulTokenLen - ulFirstChunkLength );
                    if ( ulSecond )
                    {
                        ulSecondChunkLength = (ULONG)(pThirdChunk - pSecondChunk);
                        if ( MatchDateDelimiter( &pThirdChunk ) )
                        {
                            ulThird = my_wcstoul( pThirdChunk, &pLeftOver );
                            if ( pThirdChunk != pLeftOver &&
                                 pLeftOver - pThirdChunk <= 4 )
                            {
                                ulThirdChunkLength = (ULONG)(pLeftOver - pThirdChunk);
                                //--- May have matched a month, day, and year - valiDate values                                 
                                if ( fDayMonthYear || 
                                     fMonthDayYear )
                                {
                                    //--- Preferred format is Month Day Year, or Day Month Year - in either case 
                                    //---     Day Month Year is preferable to Year Month Day 
                                    if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )     && 
                                         ( ulFirstChunkLength <= 2 )                    &&
                                         ( YEARMIN <= ulThird && ulThird <= YEARMAX )   &&
                                         ( ulThirdChunkLength >= 2 ) )
                                    {
                                        //--- Successfully matched a day, month and year 
                                        fDayMonthYear = true;
                                        fMonthDayYear = false;
                                        fYearMonthDay = false;
                                    }
                                    else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )  &&
                                              ( ulFirstChunkLength >= 2 )                   &&
                                              ( DAYMIN <= ulThird && ulThird <= DAYMAX )    &&
                                              ( ulThirdChunkLength <= 2 ) )
                                    {
                                        //--- Successfully matched a year, month and day 
                                        fYearMonthDay = true;
                                        fMonthDayYear = false;
                                        fDayMonthYear = false;
                                    }
                                    else
                                    {
                                        hr = E_INVALIDARG;
                                    }
                                }
                                else // fYearMonthDay
                                {
                                    //--- Preferred format is Year Month Day 
                                    if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )   &&
                                         ( ulFirstChunkLength >= 2 )                    &&
                                         ( DAYMIN <= ulThird && ulThird <= DAYMAX )     &&
                                         ( ulThirdChunkLength <= 2 ) )
                                    {
                                        //--- Successfully matched a year, month, and day
                                        fYearMonthDay = true;
                                        fMonthDayYear = false;
                                        fDayMonthYear = false;
                                    }
                                    else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )    && 
                                              ( ulFirstChunkLength <= 2 )                   &&
                                              ( YEARMIN <= ulThird && ulThird <= YEARMAX )  &&
                                              ( ulThirdChunkLength >= 2 ) )
                                    {
                                        //--- Successfully matched a day, month, and year
                                        fDayMonthYear = true;
                                        fMonthDayYear = false;
                                        fYearMonthDay = false;
                                    }
                                    else
                                    {
                                        hr = E_INVALIDARG;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                        //--- Matched two - either Day-Monthstring or Year-Monthstring
                        else
                        {
                            if ( !Context ||
                                 ( Context &&
                                   _wcsicmp( Context, L"Date_DM" ) == 0 ) )
                            {
                                //--- Preferred format is Month Day Year, or Day Month Year - in either case 
                                //---     Day Month Year is preferable to Year Month Day 
                                if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )     && 
                                     ( ulFirstChunkLength <= 2 ) )
                                {
                                    //--- Successfully matched a day, month and year 
                                    fDayMonthYear = true;
                                    fMonthDayYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )  &&
                                          ( ulFirstChunkLength <= 4 ) )
                                {
                                    //--- Successfully matched a year, month and day 
                                    fYearMonthDay = true;
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else if ( Context &&
                                      _wcsicmp( Context, L"Date_YM" ) == 0 )
                            {
                                //--- Preferred format is Year Month Day 
                                if ( ( YEARMIN <= ulFirst && ulFirst <= YEARMAX )   &&
                                     ( ulFirstChunkLength <= 4 ) )
                                {
                                    //--- Successfully matched a year, month, and day
                                    fYearMonthDay = true;
                                    fMonthDayYear = false;
                                    fDayMonthYear = false;
                                    pThirdChunk   = NULL;
                                }
                                else if ( ( DAYMIN <= ulFirst && ulFirst <= DAYMAX )    && 
                                          ( ulFirstChunkLength <= 2 ) )
                                {
                                    //--- Successfully matched a day, month, and year
                                    fDayMonthYear = true;
                                    fMonthDayYear = false;
                                    fYearMonthDay = false;
                                    pThirdChunk   = NULL;
                                }
                                else
                                {
                                    hr = E_INVALIDARG;
                                }
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                            }
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Fill out DateItemInfo structure appropriately.
    if ( SUCCEEDED( hr ) )
    {
        pItemNormInfo = (TTSDateItemInfo*) MemoryManager.GetMemory( sizeof(TTSDateItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            ZeroMemory( pItemNormInfo, sizeof(TTSDateItemInfo) );
            pItemNormInfo->Type = eDATE;
            if ( fMonthDayYear )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulFirst;
                ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                    if ( ulSecondChunkLength == 2 )
                    {
                        if ( *pSecondChunk != L'0' )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pSecondChunk + 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                        }
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pSecondChunk + 2;
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pSecondChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pSecondChunk + 1;
                    }
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = NULL;
                    }
                }
            }
            else if ( fDayMonthYear )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                            (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                if ( SUCCEEDED( hr ) )
                {
                    ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                    if ( ulFirstChunkLength == 2 )
                    {
                        if ( *pFirstChunk != L'0' )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pFirstChunk + 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                        }
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pFirstChunk + 2;
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pFirstChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pFirstChunk + 1;
                    }
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                                (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                        if ( SUCCEEDED( hr ) )
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulThirdChunkLength;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear = NULL;
                    }
                }
            }
            else if ( fYearMonthDay )
            {
                ( (TTSDateItemInfo*) pItemNormInfo )->ulMonthIndex          = ulSecond;
                if ( SUCCEEDED( hr ) )
                {
                    if ( pThirdChunk )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = 
                                (TTSIntegerItemInfo*) MemoryManager.GetMemory( sizeof(TTSIntegerItemInfo), &hr );
                        if ( ulThirdChunkLength == 2 )
                        {
                            ZeroMemory( ( (TTSDateItemInfo*) pItemNormInfo )->pDay, sizeof(TTSIntegerItemInfo) );
                            if ( *pThirdChunk != L'0' )
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 2;
                            }
                            else
                            {
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar  = pThirdChunk + 1;
                                ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver   = 1;
                            }
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar        = pThirdChunk + 2;
                        }
                        else
                        {
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pStartChar = pThirdChunk;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->lLeftOver  = 1;
                            ( (TTSDateItemInfo*) pItemNormInfo )->pDay->pEndChar   = pThirdChunk + 1;
                        }
                    }
                    else
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pDay = NULL;
                    }
                    ( (TTSDateItemInfo*) pItemNormInfo )->pYear =
                            (TTSYearItemInfo*) MemoryManager.GetMemory( sizeof(TTSYearItemInfo), &hr );
                    if ( SUCCEEDED( hr ) )
                    {
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear->pYear            = pFirstChunk;
                        ( (TTSDateItemInfo*) pItemNormInfo )->pYear->ulNumDigits      = ulFirstChunkLength;
                    }
                }
            }
            else
            {
                //--- should never get here.
                hr = E_UNEXPECTED;
            }
        }
    }
              
    return hr;
} /* IsMonthStringCompactDate */

/***********************************************************************************************
* IsLongFormDate_DMDY *
*---------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a long form Date.
*
*   RegExp:
*       [[DayString][,]?]? [MonthString][,]? [Day][,]? [Year]?
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsLongFormDate_DMDY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                           CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsLongFormDate_DMDY" );
    HRESULT hr = S_OK;
    WCHAR *pDayString = NULL, *pMonthString = NULL, *pDay = NULL, *pYear = NULL;
    ULONG ulDayLength = 0, ulYearLength = 0;
    long lDayString = -1, lMonthString = -1, lDay = 0, lYear = 0;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const WCHAR *pTempEndChar = NULL, *pTempEndOfItem = NULL;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag, *pTempFrag = NULL;
    const SPVSTATE *pDayStringXMLState = NULL, *pMonthStringXMLState = NULL, *pDayXMLState = NULL;
    const SPVSTATE *pYearXMLState = NULL;
    CItemList PostDayStringList, PostMonthStringList, PostDayList;
    BOOL fNoYear = false;

    //--- Try to match Day String
    pDayString   = (WCHAR*) pStartChar;
    lDayString   = MatchDayString( pDayString, (WCHAR*) pEndOfItem );

    //--- Failed to match a Day String
    if ( lDayString == 0 )
    {
        pDayString   = NULL;
    }
    //--- Matched a Day String, but it wasn't by itself or followed by a comma
    else if ( pDayString != pEndOfItem &&
              ( pDayString    != pEndOfItem - 1 ||
                *pEndOfItem != L',' ) )
    {
        hr = E_INVALIDARG;
    }
    //--- Matched a Day String - save XML State and move ahead in text
    else
    {
        pDayString         = (WCHAR*) pStartChar;
        pDayStringXMLState = &pFrag->State;

        pStartChar = pEndOfItem;
        if ( *pStartChar == L',' )
        {
            pStartChar++;
        }
        hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayStringList );
        if ( !pStartChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( pStartChar &&
                  SUCCEEDED( hr ) )
        {
            pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
        }
    }

    //--- Try to match Month String
    if ( SUCCEEDED( hr ) )
    {
        pMonthString = (WCHAR*) pStartChar;
        lMonthString = MatchMonthString( pMonthString, (ULONG)(pEndOfItem - pMonthString) );

        //--- Failed to match Month String, or Month String was not by itself...
        if ( !lMonthString ||
             ( pMonthString != pEndOfItem &&
               ( pMonthString  != pEndOfItem - 1 ||
                 *pMonthString != L',' ) ) )
        {
            hr = E_INVALIDARG;
        }
        //--- Matched a Month String - save XML State and move ahead in text
        else
        {
            pMonthString         = (WCHAR*) pStartChar;
            pMonthStringXMLState = &pFrag->State;

            pStartChar = pEndOfItem;
            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostMonthStringList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else if ( pStartChar &&
                      SUCCEEDED( hr ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                //--- Strip trailing punctuation, etc. since the next token could be the last one if
                //--- this is just a Monthstring and Day...
                while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                {
                    if ( *(pEndOfItem - 1) != L',' )
                    {
                        fNoYear = true;
                    }
                    pEndOfItem--;
                }
            }
        }
    }

    //--- Try to match Day
    if ( SUCCEEDED( hr ) )
    {
        lDay = my_wcstoul( pStartChar, &pDay );
        //--- Matched a Day - save XML State and move ahead in text
        if ( ( DAYMIN <= lDay && lDay <= DAYMAX ) &&
             pDay - pStartChar <= 2               &&
             ( pDay == pEndOfItem                 || 
              ( pDay == (pEndOfItem - 1) && *pDay == L',' ) ) )
        {
            if ( pDay == pEndOfItem )
            {
                ulDayLength = (ULONG)(pEndOfItem - pStartChar);
            }
            else if ( pDay == pEndOfItem - 1 )
            {
                ulDayLength = (ULONG)((pEndOfItem - 1) - pStartChar);
            }
            pDay         = (WCHAR*) pStartChar;
            pDayXMLState = &pFrag->State;

            if ( !fNoYear )
            {
                //--- Save pointers, in case there is no year present
                pTempEndChar   = pEndChar;
                pTempEndOfItem = pEndOfItem;
                pTempFrag      = pFrag;

                if ( *pEndOfItem == L',' )
                {
                    pStartChar = pEndOfItem + 1;
                }
                else
                {
                    pStartChar = pEndOfItem;
                }
                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    fNoYear = true;
                    pYear   = NULL;
                }
                else if ( pStartChar &&
                          ( SUCCEEDED( hr ) ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    //--- Strip trailing punctuation, since the next token will be the last one
                    //--- if this is Monthstring, Day, Year
                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                    {
                        pEndOfItem--;
                    }
                }
            }
        }
        //--- Failed to match a day
        else if ( ( YEARMIN <= lDay && lDay <= YEARMAX ) &&
                  pDay - pStartChar <= 4                  &&
                  pDay == pEndOfItem )
        {
            //--- Successfully matched Month String and Year
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
            //--- Don't try to match a year again
            fNoYear       = true;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match Year
    if ( SUCCEEDED( hr ) &&
         !fNoYear )
    {
        lYear = my_wcstoul( pStartChar, &pYear );
        //--- Matched a Year
        if ( ( YEARMIN <= lYear && lYear <= YEARMAX ) &&
             pYear - pStartChar <= 4                  &&
             pYear == pEndOfItem )
        {
            //--- Successfully matched Month String, Day, and Year (and possibly Day String)
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
        }
        else
        {
            //--- Failed to match Year - replace pointers with previous values
            pEndChar   = pTempEndChar;
            pEndOfItem = pTempEndOfItem;
            pFrag      = pTempFrag;
            pYear      = NULL;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eDATE_LONGFORM;

            //--- Insert Day String, if present
            if ( pDayString )
            {
                Word.pXmlState  = pDayStringXMLState;
                Word.pWordText  = g_days[lDayString - 1].pStr;
                Word.ulWordLen  = g_days[lDayString - 1].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

            //--- Insert Post Day String XML States
            while ( !PostDayStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayStringList.RemoveHead() ).Words[0] );
            }

            //--- Insert Month String
            Word.pXmlState  = pMonthStringXMLState;
            Word.pWordText  = g_months[lMonthString - 1].pStr;
            Word.ulWordLen  = g_months[lMonthString - 1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert Post Month String XML State
            while ( !PostMonthStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostMonthStringList.RemoveHead() ).Words[0] );
            }

            SPLISTPOS WordListPos = WordList.GetTailPosition();

            //--- Expand Day
            if ( ulDayLength == 1 )
            {
                NumberGroup Garbage;
                ExpandDigitOrdinal( *pDay, Garbage, WordList );
            }
            else if ( ulDayLength == 2 )
            {
                NumberGroup Garbage;
                ExpandTwoOrdinal( pDay, Garbage, WordList );
            }

            //--- Clean Up Day XML States
            WordList.GetNext( WordListPos );
            while ( WordListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( WordListPos );
                TempWord.pXmlState = pDayXMLState;
            }

            //--- Insert Post Day XML State
            while ( !PostDayList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayList.RemoveHead() ).Words[0] );
            }

            WordListPos = WordList.GetTailPosition();

            //--- Expand Year, if present
            if ( pYear )
            {
                TTSYearItemInfo TempYearInfo;
                TempYearInfo.pYear       = pYear;
                TempYearInfo.ulNumDigits = ulYearLength;
                hr = ExpandYear( &TempYearInfo, WordList );

                if ( SUCCEEDED( hr ) )
                {
                    //--- Clean Up Year XML States
                    WordList.GetNext( WordListPos );
                    while ( WordListPos )
                    {
                        TTSWord& TempWord  = WordList.GetNext( WordListPos );
                        TempWord.pXmlState = pYearXMLState;
                    }
                }
            }
            //--- Advance pointers
            m_pCurrFrag      = pFrag;
            m_pEndChar       = pEndChar;
            m_pEndOfCurrItem = pEndOfItem;
        }
    }

    return hr;
} /* IsLongFormDate_DMDY */

/***********************************************************************************************
* IsLongFormDate_DDMY *
*---------------------*
*   Description:
*       Checks the incoming Item's text to determine whether or not it
*   is a long form Date.
*
*   RegExp:
*       [[DayString][,]?]? [Day][,]? [MonthString][,]? [Year]?
*   
*   Types assigned:
*       Date
********************************************************************* AH **********************/
HRESULT CStdSentEnum::IsLongFormDate_DDMY( TTSItemInfo*& pItemNormInfo, CSentItemMemory& MemoryManager, 
                                           CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::IsLongFormDate_DDMY" );
    HRESULT hr = S_OK;
    WCHAR *pDayString = NULL, *pMonthString = NULL, *pDay = NULL, *pYear = NULL;
    ULONG ulDayLength = 0, ulYearLength = 0;
    long lDayString = -1, lMonthString = -1, lDay = 0, lYear = 0;
    const WCHAR *pStartChar = m_pNextChar, *pEndOfItem = m_pEndOfCurrItem, *pEndChar = m_pEndChar;
    const WCHAR *pTempEndChar = NULL, *pTempEndOfItem = NULL;
    const SPVTEXTFRAG* pFrag = m_pCurrFrag, *pTempFrag = NULL;
    const SPVSTATE *pDayStringXMLState = NULL, *pMonthStringXMLState = NULL, *pDayXMLState = NULL;
    const SPVSTATE *pYearXMLState = NULL;
    CItemList PostDayStringList, PostMonthStringList, PostDayList;
    BOOL fNoYear = false;

    //--- Try to match Day String
    pDayString   = (WCHAR*) pStartChar;
    lDayString   = MatchDayString( pDayString, (WCHAR*) pEndOfItem );

    //--- Failed to match a Day String
    if ( lDayString == 0 )
    {
        pDayString   = NULL;
    }
    //--- Matched a Day String, but it wasn't by itself or followed by a comma
    else if ( pDayString != pEndOfItem &&
              ( pDayString    != pEndOfItem - 1 ||
                *pEndOfItem != L',' ) )
    {
        hr = E_INVALIDARG;
    }
    //--- Matched a Day String - save XML State and move ahead in text
    else
    {
        pDayString         = (WCHAR*) pStartChar;
        pDayStringXMLState = &pFrag->State;

        pStartChar = pEndOfItem;
        if ( *pStartChar == L',' )
        {
            pStartChar++;
        }
        hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayStringList );
        if ( !pStartChar &&
             SUCCEEDED( hr ) )
        {
            hr = E_INVALIDARG;
        }
        else if ( pStartChar &&
                  SUCCEEDED( hr ) )
        {
            pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
        }
    }

    //--- Try to match Day
    if ( SUCCEEDED( hr ) )
    {
        lDay = my_wcstoul( pStartChar, &pDay );
        //--- Matched a Day - save XML State and move ahead in text
        if ( ( DAYMIN <= lDay && lDay <= DAYMAX ) &&
             pDay - pStartChar <= 2               &&
             ( pDay == pEndOfItem                 || 
              ( pDay == (pEndOfItem - 1) && *pDay == L',' ) ) )
        {
            if ( pDay == pEndOfItem )
            {
                ulDayLength = (ULONG)(pEndOfItem - pStartChar);
            }
            else if ( pDay == pEndOfItem - 1 )
            {
                ulDayLength = (ULONG)((pEndOfItem - 1) - pStartChar);
            }
            pDay         = (WCHAR*) pStartChar;
            pDayXMLState = &pFrag->State;

            if ( *pEndOfItem == L',' )
            {
                pStartChar = pEndOfItem + 1;
            }
            else
            {
                pStartChar = pEndOfItem;
            }

            hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostDayList );
            if ( !pStartChar &&
                 SUCCEEDED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else if ( pStartChar &&
                      ( SUCCEEDED( hr ) ) )
            {
                pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                //--- Strip trailing punctuation, since the next token will be the last one
                //--- if this is Monthstring, Day, Year
                while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                        IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                        IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                        IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                {
                    if ( *(pEndOfItem - 1) != L',' )
                    {
                        fNoYear = true;
                    }
                    pEndOfItem--;
                }
            }
        }
        //--- Failed to match a day
        else
        {
            hr = E_INVALIDARG;
        }
    }

    //--- Try to match Month String
    if ( SUCCEEDED( hr ) )
    {
        pMonthString = (WCHAR*) pStartChar;
        lMonthString = MatchMonthString( pMonthString, (ULONG)(pEndOfItem - pMonthString) );

        //--- Failed to match Month String, or Month String was not by itself...
        if ( !lMonthString ||
             ( pMonthString != pEndOfItem &&
               ( pMonthString  != pEndOfItem - 1 ||
                 *pMonthString != L',' ) ) )
        {
            hr = E_INVALIDARG;
        }
        //--- Matched a Month String - save XML State and move ahead in text
        else
        {
            pMonthString         = (WCHAR*) pStartChar;
            pMonthStringXMLState = &pFrag->State;

            if ( !fNoYear )
            {
                //--- Save pointers, in case there is no year present
                pTempEndChar   = pEndChar;
                pTempEndOfItem = pEndOfItem;
                pTempFrag      = pFrag;

                if ( *pEndOfItem == L',' )
                {
                    pStartChar = pEndOfItem + 1;
                }
                else
                {
                    pStartChar = pEndOfItem;
                }

                hr = SkipWhiteSpaceAndTags( pStartChar, pEndChar, pFrag, MemoryManager, true, &PostMonthStringList );
                if ( !pStartChar &&
                     SUCCEEDED( hr ) )
                {
                    fNoYear = true;
                    pYear   = NULL;
                }
                else if ( pStartChar &&
                          SUCCEEDED( hr ) )
                {
                    pEndOfItem = FindTokenEnd( pStartChar, pEndChar );
                    //--- Strip trailing punctuation, etc. since the next token could be the last one if
                    //--- this is Day, Monthstring, Year
                    while ( IsMiscPunctuation( *(pEndOfItem - 1) ) != eUNMATCHED ||
                            IsGroupEnding( *(pEndOfItem - 1) ) != eUNMATCHED     ||
                            IsQuotationMark( *(pEndOfItem - 1) ) != eUNMATCHED   ||
                            IsEOSItem( *(pEndOfItem - 1) ) != eUNMATCHED )
                    {
                        pEndOfItem--;
                    }
                }
            }
        }
    }

    //--- Try to match Year
    if ( SUCCEEDED( hr ) &&
         !fNoYear )
    {
        lYear = my_wcstoul( pStartChar, &pYear );
        //--- Matched a Year
        if ( ( YEARMIN <= lYear && lYear <= YEARMAX ) &&
             pYear - pStartChar <= 4                  &&
             pYear == pEndOfItem )
        {
            //--- Successfully matched Month String, Day, and Year (and possibly Day String)
            pYearXMLState = &pFrag->State;
            ulYearLength  = (ULONG)(pEndOfItem - pStartChar);
            pYear         = (WCHAR*) pStartChar;
        }
        else
        {
            //--- Failed to match Year - replace pointers with previous values
            pEndChar   = pTempEndChar;
            pEndOfItem = pTempEndOfItem;
            pFrag      = pTempFrag;
            pYear      = NULL;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        TTSWord Word;
        ZeroMemory( &Word, sizeof(TTSWord) );
        Word.eWordPartOfSpeech = MS_Unknown;

        pItemNormInfo = (TTSItemInfo*) MemoryManager.GetMemory( sizeof(TTSItemInfo), &hr );
        if ( SUCCEEDED( hr ) )
        {
            pItemNormInfo->Type = eDATE_LONGFORM;

            //--- Insert Day String, if present
            if ( pDayString )
            {
                Word.pXmlState  = pDayStringXMLState;
                Word.pWordText  = g_days[lDayString - 1].pStr;
                Word.ulWordLen  = g_days[lDayString - 1].Len;
                Word.pLemma     = Word.pWordText;
                Word.ulLemmaLen = Word.ulWordLen;
                WordList.AddTail( Word );
            }

            //--- Insert Post Day String XML States
            while ( !PostDayStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayStringList.RemoveHead() ).Words[0] );
            }

            //--- Insert Month String
            Word.pXmlState  = pMonthStringXMLState;
            Word.pWordText  = g_months[lMonthString - 1].pStr;
            Word.ulWordLen  = g_months[lMonthString - 1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert Post Month String XML State
            while ( !PostMonthStringList.IsEmpty() )
            {
                WordList.AddTail( ( PostMonthStringList.RemoveHead() ).Words[0] );
            }

            SPLISTPOS WordListPos = WordList.GetTailPosition();

            //--- Expand Day
            if ( ulDayLength == 1 )
            {
                NumberGroup Garbage;
                ExpandDigitOrdinal( *pDay, Garbage, WordList );
            }
            else if ( ulDayLength == 2 )
            {
                NumberGroup Garbage;
                ExpandTwoOrdinal( pDay, Garbage, WordList );
            }

            //--- Clean Up Day XML States
            WordList.GetNext( WordListPos );
            while ( WordListPos )
            {
                TTSWord& TempWord  = WordList.GetNext( WordListPos );
                TempWord.pXmlState = pDayXMLState;
            }

            //--- Insert Post Day XML State
            while ( !PostDayList.IsEmpty() )
            {
                WordList.AddTail( ( PostDayList.RemoveHead() ).Words[0] );
            }

            WordListPos = WordList.GetTailPosition();

            //--- Expand Year, if present
            if ( pYear )
            {
                TTSYearItemInfo TempYearInfo;
                TempYearInfo.pYear       = pYear;
                TempYearInfo.ulNumDigits = ulYearLength;
                hr = ExpandYear( &TempYearInfo, WordList );

                if ( SUCCEEDED( hr ) )
                {
                    //--- Clean Up Year XML States
                    WordList.GetNext( WordListPos );
                    while ( WordListPos )
                    {
                        TTSWord& TempWord  = WordList.GetNext( WordListPos );
                        TempWord.pXmlState = pYearXMLState;
                    }
                }
            }
            //--- Advance pointers
            m_pCurrFrag      = pFrag;
            m_pEndChar       = pEndChar;
            m_pEndOfCurrItem = pEndOfItem;
        }
    }

    return hr;
} /* IsLongFormDate_DMDY */

/***********************************************************************************************
* ExpandDate *
*------------*
*   Description:
*       Expands Items previously determined to be of type Date by IsNumericCompactDate, 
*   IsMonthStringCompactDate, or IsTwoValueDate.
*
*   NOTE: This function does not do parameter validation.  Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandDate( TTSDateItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandDate" );
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;

    //--- Insert DayString, if present.
    if ( pItemInfo->ulDayIndex )
    {
        Word.pWordText  = g_days[pItemInfo->ulDayIndex - 1].pStr;
        Word.ulWordLen  = g_days[pItemInfo->ulDayIndex - 1].Len;
        Word.pLemma     = Word.pWordText;
        Word.ulLemmaLen = Word.ulWordLen;
        WordList.AddTail( Word );
    }

    //--- Insert Month 
    Word.pWordText  = g_months[pItemInfo->ulMonthIndex - 1].pStr;
    Word.ulWordLen  = g_months[pItemInfo->ulMonthIndex - 1].Len;
    Word.pLemma     = Word.pWordText;
    Word.ulLemmaLen = Word.ulWordLen;
    WordList.AddTail( Word );

    //--- Expand Day, if present.
    if ( pItemInfo->pDay )
    {
        if ( pItemInfo->pDay->lLeftOver == 1 )
        {
            NumberGroup Garbage;
            ExpandDigitOrdinal( *pItemInfo->pDay->pStartChar, Garbage, WordList );
        }
        else if ( pItemInfo->pDay->lLeftOver == 2 )
        {
            NumberGroup Garbage;
            ExpandTwoOrdinal( pItemInfo->pDay->pStartChar, Garbage, WordList );
        }
    }

    //--- Expand Year, if present.
    if ( pItemInfo->pYear )
    {
        ExpandYear( pItemInfo->pYear, WordList );
    }
    return hr;
} /* ExpandDate_Standard */

/***********************************************************************************************
* ExpandYear *
*-------------*
*   Description:
*       Expands four digit strings into words in groups of two, and inserts them into Item List 
*   at ListPos.  Thus 1999 come out as "nineteen ninety nine" rather than "one thousand nine
*   hundred ninety nine"...
*   Note: This function does not do parameter validation. Assumed to be done by caller.
********************************************************************* AH **********************/
HRESULT CStdSentEnum::ExpandYear( TTSYearItemInfo* pItemInfo, CWordList& WordList )
{
    SPDBG_FUNC( "CStdSentEnum::ExpandYear" );

    // 1000 - 9999
    HRESULT hr = S_OK;
    TTSWord Word;
    ZeroMemory( &Word, sizeof(TTSWord) );
    Word.pXmlState          = &m_pCurrFrag->State;
    Word.eWordPartOfSpeech  = MS_Unknown;
    NumberGroup Garbage;

    switch ( pItemInfo->ulNumDigits )
    {
    case 2:

        //--- Expand as "two thousand" if the two digits are both zeroes.
        if ( pItemInfo->pYear[0] == L'0' &&
             pItemInfo->pYear[1] == L'0' )
        {
            //--- Insert "two".
            Word.pWordText  = g_ones[2].pStr;
            Word.ulWordLen  = g_ones[2].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- Insert "thousand".
            Word.pWordText  = g_quantifiers[1].pStr;
            Word.ulWordLen  = g_quantifiers[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
        }
        //--- Expand as "oh number" if the first digit is zero.
        else if ( pItemInfo->pYear[0] == L'0' )
        {
            Word.pWordText  = g_O.pStr;
            Word.ulWordLen  = g_O.Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );
            ExpandDigit( pItemInfo->pYear[1], Garbage, WordList );
        }
        //--- Otherwise just expand as a two digit cardinal number
        else
        {
            ExpandTwoDigits( pItemInfo->pYear, Garbage, WordList );
        }
        break;

    case 3:

        //--- Expand as a three digit cardinal number;
        ExpandThreeDigits( pItemInfo->pYear, Garbage, WordList );
        break;

    case 4:

        //--- If of form "[x]00[y]" expand as "x thousand y", or just "x thousand" if y is also zero.
        if ( pItemInfo->pYear[1] == L'0' &&
             pItemInfo->pYear[2] == L'0' &&
             pItemInfo->pYear[0] != L'0' )
        {
            //--- "x" 
            ExpandDigit( pItemInfo->pYear[0], Garbage, WordList );

            //--- "thousand".
            Word.pWordText  = g_quantifiers[1].pStr;
            Word.ulWordLen  = g_quantifiers[1].Len;
            Word.pLemma     = Word.pWordText;
            Word.ulLemmaLen = Word.ulWordLen;
            WordList.AddTail( Word );

            //--- "y" 
            if ( pItemInfo->pYear[3] != L'0' )
            {
                ExpandDigit( pItemInfo->pYear[3], Garbage, WordList );
            }
        }
        // Otherwise...
        else
        {
            //--- Expand first two digits - e.g. "nineteen"
            ExpandTwoDigits( pItemInfo->pYear, Garbage, WordList );