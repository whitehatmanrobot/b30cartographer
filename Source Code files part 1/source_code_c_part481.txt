ert(_pMarkup && _pMarkup == _pMarkup->GetWindowedMarkupContext());
        CMarkup *pMarkup = Markup();

        if (pparam->_pMarkup)
        {
            pMarkup = pparam->_pMarkup->GetWindowedMarkupContext();
        }
        else if (pparam->_pElement && pparam->_pElement->IsInMarkup())
        {
            pMarkup = pparam->_pElement->GetWindowedMarkupContext();
        }

        if (pMarkup != _pMarkup)
            goto Cleanup;

        hr = THR(CEventObj::Create(ppEventObj, Doc(), NULL, pMarkup));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setTimeout
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::setTimeout(
    BSTR strCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    VARIANT v;

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = strCode;

    RRETURN(SetErrorInfo(SetTimeout(&v, lMSec, FALSE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setTimeout (can accept IDispatch *)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::setTimeout(
    VARIANT *pCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    RRETURN(SetErrorInfo(SetTimeout(pCode, lMSec, FALSE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::clearTimeout
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::clearTimeout(LONG timerID)
{
    RRETURN(SetErrorInfo(ClearTimeout(timerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setInterval
//
//  Synopsis:  Runs <Code> every <msec> milliseconds
//             Note: Nav 4 behavior of msec=0 is like setTimeout msec=0
//
//----------------------------------------------------------------------------

HRESULT
CWindow::setInterval(
    BSTR strCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    VARIANT v;

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = strCode;

    RRETURN(SetErrorInfo(SetTimeout(&v, lMSec, TRUE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setInterval (can accept IDispatch *)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::setInterval(
    VARIANT *pCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    RRETURN(SetErrorInfo(SetTimeout(pCode, lMSec, TRUE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::clearInterval
//
//  Synopsis:   deletes the period timer set by setInterval
//
//----------------------------------------------------------------------------

HRESULT
CWindow::clearInterval(LONG timerID)
{
    RRETURN(SetErrorInfo(ClearTimeout(timerID)));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_screen
//
//--------------------------------------------------------------------------

HRESULT
CWindow::get_screen(IHTMLScreen**p)
{
    HRESULT     hr;

    hr = THR(_Screen.QueryInterface(
            IID_IHTMLScreen,
            (void **)p));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::showModelessDialog
//
//  Synopsis - helper function for the modal/modeless dialogs
//
//----------------------------------------------------------------------------
HRESULT
CWindow::ShowHTMLDialogHelper( HTMLDLGINFO * pdlgInfo )
{
    HRESULT hr = S_OK;
    TCHAR   achBuf[pdlUrlLen];
    DWORD   cchBuf;
    BOOL    fBlockArguments;
    BOOL    fWrappedUrl = FALSE;
    BSTR    bstrTempUrl = NULL;
    CStr    cstrSpecialURL;

    DWORD      dwTrustMe = ((_pMarkup->IsMarkupTrusted()) ||
                            GetCallerHTMLDlgTrust(this)) ? 0 : HTMLDLG_DONTTRUST;

    TCHAR *    pchUrl = (TCHAR *) CMarkup::GetUrl(_pMarkup);

    Assert(pdlgInfo);

    // Remember if this is a trusted dialog
    pdlgInfo->dwFlags |= dwTrustMe;

    //
    // is this a valid call to make at this time?
    if (!(Doc() && Doc()->_pInPlace))
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    //
    // First do some in-parameter checking
    if (pdlgInfo->pvarOptions &&
        VT_ERROR == V_VT(pdlgInfo->pvarOptions) &&
        DISP_E_PARAMNOTFOUND == V_ERROR(pdlgInfo->pvarOptions))
    {
        pdlgInfo->pvarOptions = NULL;
    }

    //
    // Can't load a blank page, or none bstr VarOptions
    if (!pdlgInfo->bstrUrl || !*pdlgInfo->bstrUrl)
    {
        if (pdlgInfo->fModeless)
        {
            // use about:blank for the name and continue
            bstrTempUrl = SysAllocString(_T("about:blank"));
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else if (IsSpecialUrl(pdlgInfo->bstrUrl))
    {
        if (WrapSpecialUrl(pdlgInfo->bstrUrl, &cstrSpecialURL, pchUrl, FALSE, FALSE) != S_OK)
            goto Cleanup;

        hr = cstrSpecialURL.AllocBSTR(&bstrTempUrl);
        if (hr)
            goto Cleanup;

        fWrappedUrl = TRUE;
    }

    if (pdlgInfo->pvarOptions &&
        VT_ERROR != V_VT(pdlgInfo->pvarOptions) &&
        VT_BSTR != V_VT(pdlgInfo->pvarOptions))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // dereference if needed
    if (pdlgInfo->pvarOptions && V_VT(pdlgInfo->pvarOptions) == (VT_BYREF | VT_VARIANT))
        pdlgInfo->pvarOptions = V_VARIANTREF(pdlgInfo->pvarOptions);

    if (pdlgInfo->pvarArgIn && V_VT(pdlgInfo->pvarArgIn)== (VT_BYREF | VT_VARIANT))
        pdlgInfo->pvarArgIn = V_VARIANTREF(pdlgInfo->pvarArgIn);

    //
    // Create a moniker from the combined url handed in and our own url
    // (to resolve relative paths).
    hr = CoInternetCombineUrl(pchUrl,
                              bstrTempUrl ? bstrTempUrl : pdlgInfo->bstrUrl,
                              URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                              achBuf,
                              ARRAY_SIZE(achBuf),
                              &cchBuf,
                              0);
    if (hr)
        goto Cleanup;


    // SECURITY ALERT - now that we have a combined url we can do some security
    // work.  see bug ie11361 - the retval args and the ArgsIn can contain
    // scriptable objects.  Because they pass through directly from one doc to
    // another it is possible to send something across domains and thus avoid the
    // security tests.  To stop this what we do is check for accessAllowed between
    // this parent doc, and the dialog url.  If access is allowed, we continue on
    // without pause.  If, however, it is cross domain then we still allow the dialog
    // to come up, but we block the passing of arguments back and forth.

    // we don't need to protect HTA, about:blank, or res: url
    fBlockArguments = (_pMarkup->IsMarkupTrusted() || Doc()->_fInTrustedHTMLDlg) ? FALSE : ( !_pMarkup->AccessAllowed(achBuf) );

    //
    // Create a moniker from the combined url handed in and our own url
    // (to resolve relative paths).
    if (fWrappedUrl)
    {
        hr = CoInternetCombineUrl(pchUrl,
                                  pdlgInfo->bstrUrl,
                                  URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                                  achBuf,
                                  ARRAY_SIZE(achBuf),
                                  &cchBuf,
                                  0);
        if (hr)
            goto Cleanup;
    }

    hr = THR(CreateURLMoniker(NULL, achBuf, &(pdlgInfo->pmk)));
    if (hr)
        goto Cleanup;

    // Do a local machine check.
    if (!COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(_pMarkup, NULL, achBuf))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // Prepare remaining parameters for dialog creation
    pdlgInfo->hwndParent = Doc()->_pInPlace->_hwnd;

    pdlgInfo->pMarkup = _pMarkup;

    //
    // bring up the dialog
    //--------------------------------------------------------------------
    if (pdlgInfo->fModeless)
    {
        if (fBlockArguments)
            pdlgInfo->pvarArgIn = NULL;

        hr = THR(InternalModelessDialog(pdlgInfo));
    }
    else
    {
        CDoEnableModeless   dem(Doc(), this);

        if (dem._hwnd)
        {
            if (fBlockArguments)
            {
                pdlgInfo->pvarArgIn = NULL;
                pdlgInfo->pvarArgOut = NULL;
            }

            hr = THR(InternalShowModalDialog(pdlgInfo));
        }
    }

    if (hr)
        goto Cleanup;

Cleanup:
    SysFreeString(bstrTempUrl);
    ReleaseInterface(pdlgInfo->pmk);
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::showModelessDialog
//
//  Synopsis:   Interface method to bring up a modeless HTMLdialog given a url
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWindow::showModelessDialog(/* in */ BSTR      bstrUrl,
                               /* in */ VARIANT * pvarArgIn,
                               /* in */ VARIANT * pvarOptions,
                               /* ret */IHTMLWindow2** ppDialog)
{
    HTMLDLGINFO dlginfo;

    dlginfo.bstrUrl = bstrUrl;
    dlginfo.pvarArgIn = pvarArgIn;
    dlginfo.pvarOptions = pvarOptions;
    dlginfo.fModeless = TRUE;
    dlginfo.ppDialog = ppDialog;
    dlginfo.pMarkup = _pMarkup;

    RRETURN(SetErrorInfo(ShowHTMLDialogHelper( &dlginfo )));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::showModalDialog
//
//  Synopsis:   Interface method to bring up a HTMLdialog given a url
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::showModalDialog(BSTR       bstrUrl,
                            VARIANT *  pvarArgIn,
                            VARIANT *  pvarOptions,
                            VARIANT *  pvarArgOut)
{
    HTMLDLGINFO dlginfo;

    dlginfo.bstrUrl = bstrUrl;
    dlginfo.pvarArgIn = pvarArgIn;
    dlginfo.pvarOptions = pvarOptions;
    dlginfo.pvarArgOut = pvarArgOut;
    dlginfo.fModeless = FALSE;
    dlginfo.pMarkup = _pMarkup;

    RRETURN(SetErrorInfo(ShowHTMLDialogHelper( &dlginfo )));
}

//---------------------------------------------------------------------------
//
//  Member:     CWindow::createPopup
//
//  Synopsis:   load about:blank for now
//
//---------------------------------------------------------------------------

HRESULT
CWindow::createPopup(VARIANT *pVarInArg, IDispatch** ppPopup)
{
    HRESULT hr = E_INVALIDARG;
    IHTMLPopup      *pIPopup    = NULL;
    CHTMLPopup      *pPopup     = NULL;

    if (    V_VT(pVarInArg) == VT_EMPTY
        ||  V_VT(pVarInArg) == VT_ERROR
        ||  V_VT(pVarInArg) == VT_NULL
        ||  (   V_VT(pVarInArg) == VT_BSTR
            &&  (   V_BSTR(pVarInArg) == NULL
                ||  V_BSTR(pVarInArg)[0] == 0)
            )
        )
    {
        hr = CoCreateInstance(CLSID_HTMLPopup,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IHTMLPopup,
                                  (void **) &pIPopup);

        if (FAILED(hr))
            return hr;

        hr = pIPopup->QueryInterface(CLSID_HTMLPopup, (void **)&pPopup);
        if (FAILED(hr))
            return hr;

        pPopup->_pWindowParent = this;
        AddRef();

        hr = THR(pPopup->CreatePopupDoc());
        if (hr)
            goto Cleanup;

        hr = pIPopup->QueryInterface(IID_IDispatch, (void **)ppPopup);
        pIPopup->Release();

        // We don't want to show tooltips on the document when popups are around, so kill
        // any that might be there.
        // (See TODO in CElement::ShowTooltipInternal for why we don't show the tooltips)

        FormsHideTooltip();
    }

Cleanup:
    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
//  Member:     CWindow::GetMultiTypeInfoCount
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetMultiTypeInfoCount(ULONG *pc)
{
    TraceTag((tagOmWindow, "GetMultiTypeInfoCount"));

    *pc = (_pMarkup->IsPrimaryMarkup() && _pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE) ? 2 : 1;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CWindow::GetInfoOfIndex
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    TraceTag((tagOmWindow, "GetInfoOfIndex"));

    HRESULT hr      = S_OK;
    CDoc *  pDoc    = Doc();

    if (_pMarkup->IsPrimaryMarkup())
    {
        //
        // First try the main typeinfo
        //

        if (1 == iTI &&
            _pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE &&
            dwFlags & MULTICLASSINFO_GETTYPEINFO)
        {
            //
            // Caller wanted info on the dynamic part of the window.
            //

            hr = THR(pDoc->EnsureObjectTypeInfo());
            if (hr)
                goto Cleanup;

            *ppTICoClass = pDoc->_pTypInfoCoClass;
            (*ppTICoClass)->AddRef();

            //
            // Clear out these values so that we can use the base impl.
            //

            dwFlags &= ~MULTICLASSINFO_GETTYPEINFO;
            iTI = 0;
            ppTICoClass = NULL;
        }
    }
    hr = THR(super::GetInfoOfIndex(
        iTI,
        dwFlags,
        ppTICoClass,
        pdwTIFlags,
        pcdispidReserved,
        piidPrimary,
        piidSource));

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Fire_onscroll
//
//  Synopsis:   Fires the onscroll events of the window
//
//--------------------------------------------------------------------------
void CWindow::Fire_onscroll()
{
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONSCROLL, 0, _T("scroll"));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Fire_onload, Fire_onunload, Fire_onbeforeunload
//
//  Synopsis:   Fires the onload/onunload events of the window
//
//--------------------------------------------------------------------------

void CWindow::Fire_onload()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONLOAD, 0, _T("load"));
}

void CWindow::Fire_onunload()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONUNLOAD, 0, _T("unload"));
}

BOOL CWindow::Fire_onbeforeunload()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    BOOL fRet = TRUE;
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONBEFOREUNLOAD, 0, _T("beforeunload"), &fRet);
    return fRet;
}

BOOL
CWindow::Fire_onhelp()
{
    BOOL fRet = TRUE;
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONHELP, 0, _T("help"), &fRet);
    return fRet;
}

void
CWindow::Fire_onresize()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONRESIZE, 0, _T("resize"));

    // If we are running a page transition, we need to stop it
    CDocument *pDocument = Document();
    if(pDocument && pDocument->HasPageTransitions())
    {
        pDocument->PostCleanupPageTansitions();
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Fire_onfocus, Fire_onblur
//
//  Synopsis:   Fires the onfocus/onblur events of the window
//
//--------------------------------------------------------------------------

void CWindow::Fire_onfocus()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONFOCUS, 0, _T("focus"));
}

void CWindow::Fire_onblur()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONBLUR, 0, _T("blur"));
}

void CWindow::Fire_onbeforeprint()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONBEFOREPRINT, 0, _T("beforeprint"));
}

void CWindow::Fire_onafterprint()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONAFTERPRINT, 0, _T("afterprint"));
}

//+----------------------------------------------------------------------------------
//
//  Member:     alert
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::alert(BSTR message)
{
    BOOL fRightToLeft;

    if (!Document())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }
    
    THR(Document()->GetDocDirection(&fRightToLeft));

    if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS))
        RRETURN(S_OK);
    else
        RRETURN(SetErrorInfo(
            THR(Doc()->ShowMessageEx(
                NULL,
                fRightToLeft ? MB_OK | MB_ICONEXCLAMATION | MB_RTLREADING | MB_RIGHT : MB_OK | MB_ICONEXCLAMATION,
                NULL,
                0,
                (TCHAR*)STRVAL(message)))));
}

//+----------------------------------------------------------------------------------
//
//  Member:     confirm
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::confirm(BSTR message, VARIANT_BOOL *pConfirmed)
{
    HRESULT     hr;
    int         nRes;

    if (!pConfirmed)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pConfirmed = VB_FALSE;

    if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS))
    {
        hr = S_OK;
        nRes = IDOK;
    }
    else
    {
        hr = THR(Doc()->ShowMessageEx(
                &nRes,
                MB_OKCANCEL | MB_ICONQUESTION,
                NULL,
                0,
                (TCHAR*)STRVAL(message)));
        if (hr)
            goto Cleanup;
    }

    *pConfirmed = (IDOK == nRes) ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   object model implementation
//
//              returns number of frames in frameset of document;
//              fails if the doc does not contain frameset
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_length(long * pcFrames)
{
    if (!Document())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }
        
    RRETURN (SetErrorInfo(Document()->get_length(pcFrames)));
}


HRESULT
CDocument::get_length(long * pcFrames)
{
    HRESULT hr;
    CMarkup *   pMarkup = Markup();

    Assert(pMarkup);

    if (!pcFrames)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pcFrames = 0;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->CollectionCache()->GetLength(CMarkup::FRAMES_COLLECTION, pcFrames));

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CWindow::showHelp
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::showHelp(BSTR helpURL, VARIANT helpArg, BSTR features)
{
    HRESULT   hr = E_FAIL;
    VARIANT * pHelpArg;
    long      lHelpId = 0;
    TCHAR   * pchExt;
    CVariant  cvArg;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR   * pchHelpFile = cBuf;
    BOOL    fPath;

    if (!helpURL)
        goto Cleanup;

    // we need a HelpId for WinHelp Files:
    // dereference if variable passed in
    pHelpArg = (V_VT(&helpArg) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&helpArg) : &helpArg;

    // if the extention is .hlp it is WinHelp, otherwise assume html/text
    pchExt = _tcsrchr(helpURL, _T('.'));
    if (pchExt && !FormsStringICmp(pchExt, _T(".hlp")) && Doc()->_fInTrustedHTMLDlg)
    {
        UINT      uCommand = HELP_CONTEXT;
        if(V_VT(pHelpArg) == VT_BSTR)
        {
            hr = THR(ttol_with_error(V_BSTR(pHelpArg), &lHelpId));
            if (hr)
            {
                // TODO (carled) if it is not an ID it might be a bookmark
                //  or empty, or just text, extra processing necessary here.
                goto Cleanup;
            }
        }
        else
        {
            // make sure the second argument is a I4
            hr = cvArg.CoerceVariantArg(pHelpArg, VT_I4);
            if(FAILED(hr))
                goto Cleanup;

            if(hr == S_OK)
            {
                lHelpId = V_I4(&cvArg);
            }
        }

        //  If features == "popup", we need to open the
        //  hwlp window as a popup.
        if (features && !FormsStringICmp(features, _T("popup")))
        {
            uCommand = HELP_CONTEXTPOPUP;
        }

        // if the path is absent try to use the ML stuff
        fPath =  (_tcsrchr(helpURL, _T('\\')) != NULL) || (_tcsrchr(helpURL, _T('/')) != NULL);

        if(!fPath)
        {
            hr =  THR(MLWinHelp(TLS(gwnd.hwndGlobalWindow),
                           helpURL,
                           uCommand,
                           lHelpId)) ? S_OK : E_FAIL;
        }
        // If the call failed try again without using theML stuff. It could be that the
        // help file was not found in the language directory, but it sits somewhere under
        // the path.
        if(fPath || hr == E_FAIL)
        {
            hr =  THR(WinHelp(TLS(gwnd.hwndGlobalWindow),
                           helpURL,
                           uCommand,
                           lHelpId)) ? S_OK : E_FAIL;
        }

    }
    else
    {
        // HTML help case
        HWND hwndCaller;
        TCHAR achFile[pdlUrlLen];
        ULONG cchFile = ARRAY_SIZE(achFile);

        Doc()->GetWindowForBinding(&hwndCaller);

        hr = CMarkup::ExpandUrl(_pMarkup, helpURL, ARRAY_SIZE(cBuf), pchHelpFile, NULL);
        if (hr || !*pchHelpFile)
            goto Cleanup;

        if (GetUrlScheme(pchHelpFile) == URL_SCHEME_FILE)
        {
            hr = THR(PathCreateFromUrl(pchHelpFile, achFile, &cchFile, 0));
            if (hr)
                goto Cleanup;

            pchHelpFile = achFile;
        }

        if (!COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(_pMarkup, NULL, pchHelpFile))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        // Show the help file
        hr = THR(CallHtmlHelp(hwndCaller, pchHelpFile, 0x20, 0));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+---------------------------------------------------------------------------
//
//  Member: CWindow::CallHtmlHelp
//
//  Wrapper that dynamically loads, translates to ASCII and calls HtmlHelpA
//----------------------------------------------------------------------------

HRESULT
CWindow::CallHtmlHelp(HWND hwnd, BSTR pszFile, UINT uCommand, DWORD_PTR dwData, HWND *pRetVal /*=NULL*/)
{
    HRESULT     hr = S_OK;
    HWND        hwndRet = NULL;
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    hwndRet = MLHtmlHelp(hwnd, pszFile, uCommand, dwData, ML_CROSSCODEPAGE);
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    if(pRetVal)
        *pRetVal = hwndRet;

    RRETURN(SetErrorInfo( hr));
}



HRESULT
CWindow::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};

#define TITLEBAR_FEATURE_NAME   _T("titlebar")

//+---------------------------------------------------------------------------
//
//  Member: CWindow::FilterOutFeaturesString
//
//  Removes the unsafe features from the features string
//----------------------------------------------------------------------------
HRESULT
CWindow::FilterOutFeaturesString(BSTR bstrFeatures, CStr *pcstrOut)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pchFound;
    LPCTSTR         pchInPtr = bstrFeatures;
    CBufferedStr    strOut;

    Assert(pcstrOut);

    if(!bstrFeatures)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    do
    {
        pchFound = _tcsistr(pchInPtr, TITLEBAR_FEATURE_NAME);
        if(!pchFound)
        {
            Assert( pchInPtr[0] != 0 ) ; // prefix happiness. 
            strOut.QuickAppend(pchInPtr);
            break;
        }

        strOut.QuickAppend(pchInPtr, pchFound - pchInPtr);

        //Make sure we are on the left side of the =
        if(pchFound > pchInPtr && *(pchFound - 1) != _T(',') && !isspace(*(pchFound - 1)))
        {
            LPTSTR pchComma, pchEqual;
            pchComma =  _tcschr(pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1), _T(','));
            pchEqual =  _tcschr(pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1), _T('='));
            // If there is no = or there is an = and there is a comma and comma is earlier we ignore
            if(!pchEqual || (pchComma && pchComma < pchEqual))
            {
                // This was a wrong titlebar setting, keep it
                strOut.QuickAppend(pchFound, (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1));
                pchInPtr = pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1);
                continue;
            }
        }

        pchInPtr = pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1);

        pchFound = _tcschr(pchInPtr, _T(','));
        if(!pchFound)
            break;

        pchInPtr = pchFound + 1;

    } while (*pchInPtr != 0);

    hr = THR(pcstrOut->Set(strOut));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function: PromptDlgProc()
//
//----------------------------------------------------------------------------

struct SPromptDlgParams      // Communicates info the to dlg box routines.
{
    CStr    strUserMessage;     // Message to display.
    CStr    strEditFieldValue;  // IN has initial value, OUT has return value.
};

INT_PTR CALLBACK PromptDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    SPromptDlgParams *pdp = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            Assert(lParam);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);
            {
                pdp = (SPromptDlgParams*)lParam;
                SetDlgItemText(hDlg,IDC_PROMPT_PROMPT,pdp->strUserMessage);
                SetDlgItemText(hDlg,IDC_PROMPT_EDIT,pdp->strEditFieldValue);
                // Select the entire default string value:
                SendDlgItemMessage(hDlg,IDC_PROMPT_EDIT,EM_SETSEL, 0, -1 );
            }
            return (TRUE);

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    {
                        HRESULT hr;
                        int linelength;
                        pdp = (SPromptDlgParams*)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                        Assert( pdp );
                        linelength = SendDlgItemMessage(hDlg,IDC_PROMPT_EDIT,EM_LINELENGTH,(WPARAM)0,(LPARAM)0);
                        // FYI: this routine allocates linelength+1 TCHARS, +1 for the NULL.
                        hr = pdp->strEditFieldValue.Set( NULL, linelength );
                        if( FAILED( hr ) )
                            goto ErrorDispatch;
                        GetDlgItemText(hDlg,IDC_PROMPT_EDIT,pdp->strEditFieldValue,linelength+1);
                    }
                    EndDialog(hDlg, TRUE);
                    break;
                case IDCANCEL:
                ErrorDispatch:;
                    EndDialog(hDlg, FALSE);
                    break;
            }
            return TRUE;

        case WM_CLOSE:
            EndDialog(hDlg, FALSE);
            return TRUE;

    }
    return FALSE;
}


STDMETHODIMP
CWindow::prompt(BSTR message, BSTR defstr, VARIANT *retval)
{
    HRESULT             hr = S_OK;
    int                 result = 0;
    SPromptDlgParams    pdparams;

    pdparams.strUserMessage.SetBSTR(message);
    pdparams.strEditFieldValue.SetBSTR(defstr);

    {
        CDoEnableModeless   dem(Doc(), this);

        if (dem._hwnd)
        {
            result = DialogBoxParam(GetResourceHInst(),             // handle to application instance
                                    MAKEINTRESOURCE(IDD_PROMPT_MSHTML),    // identifies dialog box template name
                                    dem._hwnd,
                                    PromptDlgProc,                  // pointer to dialog box procedure
                                    (LPARAM)&pdparams);
        }
    }

    if (retval)
    {
        if (!result)  // If the user hit cancel then allways return the empty string
        {
            // Nav compatability - return null
            V_VT(retval) = VT_NULL;
        }
        else
        {
            // Allocate the returned bstr:
            V_VT(retval) = VT_BSTR;
            hr = THR((pdparams.strEditFieldValue.AllocBSTR( &V_BSTR(retval) )));
        }
    }

    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------------------------
//
//  Member:     focus
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::focus()
{
    HRESULT hr          = S_OK;
    CDoc *  pDoc        = Doc();
    HWND    hwndParent  = NULL;
    HWND    hwnd;

    if (!pDoc->_pInPlace || !pDoc->_pInPlace->_hwnd)
        goto Cleanup;

    hwnd = pDoc->_pInPlace->_hwnd;

    while (hwnd)
    {
        hwndParent = hwnd;
        hwnd = GetParent(hwnd);
    }

    Assert(hwndParent);

    // restore window first if minimized.
    if (IsIconic(hwndParent))
        ShowWindow(hwndParent, SW_RESTORE);
    else
    {
        ::SetWindowPos(hwndParent, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);

        // SetWindowPos does not seem to bring the window to top of the z-order
        // when window.focus() is called if the browser app is not in the foreground,
        // unless the z-order was changed with the window.blur() method in a prior call.
        ::SetForegroundWindow(hwndParent);
    }

    hr = THR(_pMarkup->GetElementTop()->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
    if (hr)
        goto Cleanup;

    // Fire the window onfocus event here if it wasn't previously fired in
    // BecomeCurrent() due to our inplace window not previously having the focus
    _pMarkup->Window()->Post_onfocus();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     blur
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::blur()
{
    HRESULT hr          = S_OK;
    CDoc *  pDoc        = Doc();
    HWND    hwndParent  = NULL;
    HWND    hwnd;
    BOOL    fOldInhibitFocusFiring;

    if (!pDoc->_pInPlace)
        goto Cleanup;

    hwnd = pDoc->_pInPlace->_hwnd;

    while(hwnd)
    {
        hwndParent = hwnd;
        hwnd = GetParent(hwnd);
    }

    Assert(hwndParent);
    ::SetWindowPos(hwndParent, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);

    hr = THR(_pMarkup->Root()->BecomeCurrent(0));
    if (hr)
        goto Cleanup;

    // remove focus from current frame window with the focus
    fOldInhibitFocusFiring = pDoc->_fInhibitFocusFiring;
    pDoc->_fInhibitFocusFiring = TRUE;
    ::SetFocus(NULL);
    pDoc->_fInhibitFocusFiring = fOldInhibitFocusFiring;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


void
COmWindowProxy::Post_onfocus()
{
    // if onblur was last fired then fire onfocus
    if (!_fFiredWindowFocus && Markup()->LoadStatus() >= LOADSTATUS_DONE)
    {
        // Enable window onblur firing next
        _fFiredWindowFocus = TRUE;
        GWPostMethodCall(this, ONCALL_METHOD(COmWindowProxy, Fire_onfocus, fire_onfocus), 0, TRUE, "COmWindowProxy::Fire_onfocus");
    }
}

void
COmWindowProxy::Post_onblur(BOOL fOnblurFiredFromWM)
{
    // if onfocus was last fired then fire onblur
    if (_fFiredWindowFocus && Markup()->LoadStatus() >= LOADSTATUS_DONE)
    {
        // Enable window onfocus firing next
        _fFiredWindowFocus = FALSE;
        GWPostMethodCall(this, ONCALL_METHOD(COmWindowProxy, Fire_onblur, fire_onblur), fOnblurFiredFromWM, TRUE, "COmWindowProxy::Fire_onblur");
    }
}

//=============================================================================
//=============================================================================
//
//          EVENTPARAM CLASS:
//
//=============================================================================
//=============================================================================

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::EVENTPARAM
//
//  Synopsis:   constructor
//
//  Parameters: pDoc            Doc to bind to
//              fInitState      If true, then initialize state type
//                              members.  (E.g. x, y, keystate, etc).
//
//---------------------------------------------------------------------------

EVENTPARAM::EVENTPARAM(CDoc * pNewDoc,
                       CElement * pElement,
                       CMarkup * pMarkup,
                       BOOL fInitState,
                       BOOL fPush, /* = TRUE */
                       const EVENTPARAM* pParam /* = NULL */)
{
    if (pParam)
    {
        Assert(pNewDoc == pParam->pDoc);
        memcpy(this, pParam, sizeof(*this));
        pEventObj = NULL;
        if (psrcFilter)
            psrcFilter->AddRef();
    }
    else
    {
        memset(this, 0, sizeof(*this));
        _lSubDivisionSrc = -1;
        _lSubDivisionFrom = -1;
        _lSubDivisionTo = -1;
    }

    if (!pNewDoc)
    {
        pDoc = NULL;
        return;
    }

    pDoc = pNewDoc;
    if (pDoc)
        pDoc->SubAddRef(); // balanced in destructor

    _pElement = pElement;
    if (pElement)
        pElement->SubAddRef();

    _pMarkup = pMarkup;
    if (pMarkup)
        pMarkup->SubAddRef();

    _fOnStack = FALSE;

    if (fPush)
        Push();

    if (!pParam)
        _lKeyCode = 0;

    if (fInitState && pDoc)
    {
        POINT pt;

        ::GetCursorPos(&pt);
        _screenX= pt.x;
        _screenY= pt.y;

        if (pDoc->_pInPlace)
        {
            ::ScreenToClient(pDoc->_pInPlace->_hwnd, &pt);
        }

        SetClientOrigin(pElement ? pElement : pDoc->_pElemCurrent, &pt);
        _sKeyState = VBShiftState();

        _fShiftLeft = !!(GetKeyState(VK_LSHIFT) & 0x8000);
        _fCtrlLeft = !!(GetKeyState(VK_LCONTROL) & 0x8000);
        _fAltLeft = !!(GetKeyState(VK_LMENU) & 0x8000);

        _pLayoutContext = GUL_USEFIRSTLAYOUT;
    }
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::~EVENTPARAM
//
//  Synopsis:   copy ctor
//
//---------------------------------------------------------------------------

EVENTPARAM::EVENTPARAM( const EVENTPARAM* pParam )
{
    memcpy( this, pParam, sizeof( *this ));

    _fOnStack = FALSE; // by default we are not on the stack unless we are explicitly put there.

    Assert(pDoc);
    pDoc->SubAddRef();

    if (_pElement)
        _pElement->SubAddRef();

    if (_pMarkup)
        _pMarkup->SubAddRef();

    if ( psrcFilter )
        psrcFilter->AddRef();
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::~EVENTPARAM
//
//  Synopsis:   destructor
//
//---------------------------------------------------------------------------

EVENTPARAM::~EVENTPARAM()
{
    if (_pElement)
        _pElement->SubRelease();

    if (_pMarkup)
        _pMarkup->SubRelease();

    if (!pDoc)
        return;

    Pop();

    ReleaseInterface( (IUnknown *)psrcFilter );

    if (pDoc)
        pDoc->SubRelease(); // to balance SubAddRef in constructor
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::Push
//
//---------------------------------------------------------------------------

void
EVENTPARAM::Push()
{
    if (!_fOnStack && pDoc)
    {
        _fOnStack = TRUE;
        pparamPrev = pDoc->_pparam;
        pDoc->_pparam = this;
    }
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::Pop
//
//---------------------------------------------------------------------------

void
EVENTPARAM::Pop()
{
    if (_fOnStack && pDoc)
    {
        _fOnStack = FALSE;
        pDoc->_pparam = pparamPrev;
    }
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::IsCancelled
//
//---------------------------------------------------------------------------

BOOL
EVENTPARAM::IsCancelled()
{
    HRESULT     hr;

    if (VT_EMPTY != V_VT(&varReturnValue))
    {
        hr = THR(VariantChangeTypeSpecial (&varReturnValue, &varReturnValue,VT_BOOL));
        if (hr)
            return FALSE; // assume event was not cancelled if changing type to bool failed

        return (VT_BOOL == V_VT(&varReturnValue) && VB_FALSE == V_BOOL(&varReturnValue));
    }
    else
    {   // if the variant is empty, we consider it is not cancelled by default
        return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_defaultStatus
//
//  Synopsis :  Return string of the default status.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_defaultStatus(BSTR *pbstr)
{
    HRESULT hr = S_OK;

    if (!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(Doc()->_acstrStatus[STL_DEFSTATUS].AllocBSTR(pbstr));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_status
//
//  Synopsis :  Return string of the status.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_status(BSTR *pbstr)
{
    HRESULT hr = S_OK;

    if (!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(Doc()->_acstrStatus[STL_TOPSTATUS].AllocBSTR(pbstr));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_defaultStatus
//
//  Synopsis :  Set the default status.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::put_defaultStatus(BSTR bstr)
{
    HRESULT hr = THR(Doc()->SetStatusText(bstr, STL_DEFSTATUS, Markup()));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_status
//
//  Synopsis :  Set the status text.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::put_status(BSTR bstr)
{
    HRESULT hr = THR(Doc()->SetStatusText(bstr, STL_TOPSTATUS, Markup()));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::scroll
//
//  Synopsis :  Scroll the document by this x & y.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::scroll(long x, long y)
{
    CLayout *   pLayout;
    CDispNode * pDispNode;
    CElement * pElement;

    pElement = _pMarkup->GetCanvasElement();

    if (!pElement)
    {
        return S_OK;
    }

    // make sure that we are calced before trying anything fancy
    if (S_OK != pElement->EnsureRecalcNotify())
        return E_FAIL;

    pLayout   = pElement->GetUpdatedLayout();
    if (!pLayout)
    {
        return S_OK;
    }

    pDispNode =  pLayout->GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        x = g_uiDisplay.DeviceFromDocPixelsX(x);
        y = g_uiDisplay.DeviceFromDocPixelsY(y);

        pLayout->ScrollTo(CSize(x, y));
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::scrollTo
//
//  Synopsis :  Scroll the document to this x & y.
//
//----------------------------------------------------------------------------
HRESULT
CWindow::scrollTo(long x, long y)
{
    RRETURN(scroll(x, y));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::scrollBy
//
//  Synopsis :  Scroll the document by this x & y.
//
//----------------------------------------------------------------------------
HRESULT
CWindow::scrollBy(long x, long y)
{
    CLayout *   pLayout;
    CDispNode * pDispNode;
    CElement  * pElement;

    pElement = _pMarkup->GetCanvasElement();

    if (!pElement)
        return S_OK;

    // make sure that we are calced before trying anything fancy
    if (S_OK != pElement->EnsureRecalcNotify())
        return E_FAIL;

    pLayout   = pElement->GetUpdatedLayout();
    pDispNode = pLayout
                    ? pLayout->GetElementDispNode()
                    : NULL;

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        x = g_uiDisplay.DeviceFromDocPixelsX(x);
        y = g_uiDisplay.DeviceFromDocPixelsY(y);

        pLayout->ScrollBy(CSize(x, y));
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_location
//
//  Synopsis :  Retrieve the location object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_location(IHTMLLocation **ppLocation)
{
    HRESULT     hr;

    if (!_pLocation)
    {
        _pLocation = new COmLocation(this);
        if (!_pLocation)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // will subaddref on us if QI succeeded
    hr = THR(_pLocation->QueryInterface(IID_IHTMLLocation, (VOID **)ppLocation));


Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_history
//
//  Synopsis :  Retrieve the history object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_history(IOmHistory **ppHistory)
{
    HRESULT     hr;

    if (!_pHistory)
    {
        _pHistory = new COmHistory(this);
        if (!_pHistory)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // will subaddref on us if QI succeeded
    hr = THR(_pHistory->QueryInterface(IID_IOmHistory, (VOID **)ppHistory));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::close
//
//  Synopsis :  Close this window.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::close()
{
    HRESULT hr       = S_OK;
    int     nResult;
    CDoc *  pDoc     = Doc();
    BOOL    fCancel  = FALSE;
    BOOL    fIsChild = (V_VT(&_varOpener) != VT_EMPTY);

    if (!_pWindowParent)
    {

        //
        // if there are print jobs spooling we do not want to close down at this
        // point in time.  but we will need to remember that this was called and
        // do it at another point in time.  Ugh, terrible hack. 110421.
        //
        // NOTE: (carled) This shouldn't be necessary, and once we properly
        // lock the process in the template management code.  The reason this doesn't work
        // right now is that the backup dochostUIhandler does not have a _pUnkSite, and we
        // can't call IOleObjectWithSite::SetSite in EnsureBackupUIHandler because that will
        // set up a refcount-cycle, and so the CDoc can passivate in the middle of printing.
        // one option is to turn each _cSpoolingPrintJobs into an addref on CDoc.
        //
        if (pDoc->PrintJobsPending())
        {
            pDoc->_fCloseOnPrintCompletion = TRUE;
            goto Cleanup;
        }


        // Fire the WebOC WindowClosing event and only close
        // the window if the host does not set Cancel to TRUE.
        //
        pDoc->_webOCEvents.WindowClosing(pDoc->_pTopWebOC, fIsChild, &fCancel);
        if (!fCancel)
        {
            // If this is a trusted document (HTA) or child window, close silently. Otherwise
            // ask the user if it is okay to close the window.

            if (_pMarkup->IsMarkupTrusted() || fIsChild)
                goto CloseWindow;
            else
            {
                hr = pDoc->ShowMessage(&nResult, MB_YESNO | MB_ICONQUESTION,
                                       0, IDS_CONFIRM_SCRIPT_CLOSE_TEXT);
                if (hr)
                    goto Cleanup;

                fCancel = (nResult != IDYES);
            }

CloseWindow:
            if (!fCancel)
            {
                // Try to Exec an OLECMDID_CLOSE command.
                //
                CTExec(Doc()->_pClientSite, NULL, OLECMDID_CLOSE, 0, NULL, NULL);
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_opener
//
//  Synopsis :  Retrieve the opener property.
//
//----------------------------------------------------------------------------

HRESULT CWindow::put_opener(VARIANT varOpener)
{
    HRESULT             hr;
    hr = THR(VariantCopy(&_varOpener, &varOpener));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_opener
//
//  Synopsis :  Retrieve the opener object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_opener(VARIANT *pvarOpener)
{
    HRESULT             hr = S_OK;

    if (pvarOpener)
        hr = THR(VariantCopy(pvarOpener, &_varOpener));

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_navigator
//
//  Synopsis :  Retrieve the navigator object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_navigator(IOmNavigator **ppNavigator)
{
    HRESULT     hr = S_OK;
    IHTMLWindow2 *pShDocVwWindow = NULL;

    THR_NOTRACE(Doc()->QueryService(
            SID_SHTMLWindow2,
            IID_IHTMLWindow2,
            (void**)&pShDocVwWindow));


    if (pShDocVwWindow)
    {
        hr = THR(pShDocVwWindow->get_navigator(ppNavigator));
        goto Cleanup;
    }

    if (!_pNavigator)
    {
        _pNavigator = new COmNavigator(this);
        if (!_pNavigator)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // will subaddref on us if QI succeeded
    hr = THR(_pNavigator->QueryInterface(IID_IOmNavigator, (VOID **)ppNavigator));

Cleanup:
    ReleaseInterface(pShDocVwWindow);
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_clientInformation
//
//  Synopsis :  Retrieve the navigator object though the client alias
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_clientInformation(IOmNavigator **ppNavigator)
{
    RRETURN(get_navigator(ppNavigator));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_name
//
//  Synopsis :  Set the name of this window.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::put_name(BSTR bstr)
{
    HRESULT hr;
    hr = THR(_cstrName.Set(bstr));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_name
//
//  Synopsis :  Retrieve the name of this window.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_name(BSTR *pbstr)
{
    HRESULT hr;
    hr = THR(_cstrName.AllocBSTR(pbstr));
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     CWindow::get_screenLeft
//
//  Synopsis:   Get the name property
//
//  mwatt: Changes because not all HTML frames have a CDOC only the primary Window.
//
//---------------------------------------------------------------------------

HRESULT
CWindow::get_screenLeft(long *pVal)
{
    HRESULT hr = S_OK;

    CTreeNode * pOffsetParent;
    CTreeNode * pTempElement;

    CRootElement* pMyRootElement;
    CElement*     pMasterElement;

    POINT ptDocLeftTop;
    POINT ptElementLeftTop;
    long  nTotalLeft;
    long  nParentLeftness;

    nTotalLeft = ptDocLeftTop.x = ptDocLeftTop.y = 0;

    ptElementLeftTop = ptDocLeftTop;

    //
    // mwatt: Are we the primary window?
    //

    if (IsPrimaryWindow())
    {
        if (Doc()->_pInPlace && !ClientToScreen(Doc()->_pInPlace->_hwnd, &ptDocLeftTop))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        *pVal = ptDocLeftTop.x;
        *pVal = g_uiDisplay.DocPixelsFromDeviceX(*pVal);
    }
    else
    {
        //
        // mwatt: not primary then add our position to our parents position
        //

        pMyRootElement = _pMarkup->Root();

        if (pMyRootElement->HasMasterPtr() && _pWindowParent)
        {
            pMasterElement = pMyRootElement->GetMasterPtr();
			
            Assert(pMasterElement);

            pMasterElement->GetElementTopLeft(ptElementLeftTop);

            nTotalLeft += ptElementLeftTop.x;

            pTempElement = pMasterElement->GetFirstBranch();

            if (pTempElement != NULL)
            {
               pOffsetParent = pTempElement->ZParentBranch();

 while (      pOffsetParent != NULL && (pOffsetParent->Tag() != ETAG_IFRAME)
                        &&  (pOffsetParent->Tag() != ETAG_FRAMESET  || _pWindowParent->IsPrimaryWindow()    )   )
               {
                   pOffsetParent->Element()->GetElementTopLeft(ptElementLeftTop);
                   nTotalLeft += ptElementLeftTop.x;
 
                   CMarkup* pMarkup = NULL;
 
                   if(pOffsetParent->Element()->HasMarkupPtr())
                   {
                       pMarkup = pOffsetParent->Element()->GetMarkup();
                   }
 
                   if(pOffsetParent->Tag() == ETAG_BODY && pMarkup && !pMarkup->IsPrimaryMarkup())
                   {
                       long nBorder = 0;
                       IHTMLControlElement* pControlElem = NULL;
 
                       if( SUCCEEDED(pOffsetParent->Element()->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
                           SUCCEEDED(pControlElem->get_clientLeft(&nBorder)))
                       {
                           nTotalLeft += nBorder;
                           pControlElem->Release();
                       }
                   }

                   pTempElement = pOffsetParent->ZParentBranch();

                   if (pTempElement != pOffsetParent)
                   {
                      pOffsetParent = pTempElement;
                   }
                   else
                   {
                      pOffsetParent = NULL;
                   }
               }
            }

            nTotalLeft = g_uiDisplay.DocPixelsFromDeviceX(nTotalLeft);

            hr = _pWindowParent->get_screenLeft(&nParentLeftness);

            if (hr)
            {
                goto Cleanup;
            }

            *pVal = nParentLeftness + nTotalLeft;

            IHTMLDocument2* pDoc = NULL;
            IHTMLElement* pElem = NULL;
            IHTMLControlElement* pControlElem = NULL;
			IHTMLElement2 * pElem2 = NULL;
			
			long lValue = 0;

            if (SUCCEEDED(_pWindowParent->get_document(&pDoc)) && 
                SUCCEEDED(pDoc->get_body(&pElem)) && 
				SUCCEEDED(pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2)) &&	
				SUCCEEDED(pElem2->get_scrollLeft(&lValue)))
            {
				if(_pWindowParent->IsPrimaryWindow()&& 
					SUCCEEDED(pElem->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
					SUCCEEDED(pControlElem->get_clientLeft(&nTotalLeft)))   
				{	
					*pVal = *pVal + nTotalLeft;
					pControlElem->Release();
				}

				*pVal  -= lValue;
				pElem2->Release();
            }

        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}



//+--------------------------------------------------------------------------
//
//  Member:     CWindow::get_screenTop
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT
CWindow::get_screenTop(long *pVal)
{
    HRESULT hr = S_OK;

    CTreeNode * pOffsetParent;
    CTreeNode * pTempElement;

    CRootElement* pMyRootElement;
    CElement*     pMasterElement;

    POINT ptDocLeftTop;
    POINT ptElementLeftTop;

    long  nTotalTop;
    long  nParentTopness;

    nTotalTop = ptDocLeftTop.x = ptDocLeftTop.y = 0;

    ptElementLeftTop = ptDocLeftTop;

    //
    // mwatt: Are we the primary window?
    //

    if (IsPrimaryWindow())
    {
        if (Doc()->_pInPlace && !ClientToScreen(Doc()->_pInPlace->_hwnd, &ptDocLeftTop))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        *pVal = ptDocLeftTop.y;
        *pVal = g_uiDisplay.DocPixelsFromDeviceY(*pVal);        
    }
    else
    {
        //
        // mwatt: not primary then add our position to the primary window's position.
        //

        pMyRootElement = _pMarkup->Root();

        if (pMyRootElement->HasMasterPtr() && _pWindowParent)
        {
            pMasterElement = pMyRootElement->GetMasterPtr();

            Assert(pMasterElement);

            pMasterElement->GetElementTopLeft(ptElementLeftTop);

            nTotalTop += ptElementLeftTop.y;

            pTempElement = pMasterElement->GetFirstBranch();

            if (pTempElement != NULL)
            {
               pOffsetParent = pTempElement->ZParentBranch();

			while (  pOffsetParent != NULL && (pOffsetParent->Tag() != ETAG_IFRAME)
                       &&  (pOffsetParent->Tag() != ETAG_FRAMESET  || _pWindowParent->IsPrimaryWindow()    )   )
               {
                   pOffsetParent->Element()->GetElementTopLeft(ptElementLeftTop);
                   nTotalTop += ptElementLeftTop.y;
 
                   CMarkup* pMarkup = NULL;
 
                   if(pOffsetParent->Element()->HasMarkupPtr())
                   {
                       pMarkup = pOffsetParent->Element()->GetMarkup();
                   }
 
                   if(pOffsetParent->Tag() == ETAG_BODY && pMarkup && !pMarkup->IsPrimaryMarkup())
                   {
                       long nBorder = 0;
                       IHTMLControlElement* pControlElem = NULL;
 
                       if( SUCCEEDED(pOffsetParent->Element()->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
                           SUCCEEDED(pControlElem->get_clientTop(&nBorder)))
                       {
                           nTotalTop += nBorder;
                           pControlElem->Release();
                       }
                   }


                   pTempElement = pOffsetParent->ZParentBranch();

                   if (pTempElement != pOffsetParent)
                   {
                      pOffsetParent = pTempElement;
                   }
                   else
                   {
                      pOffsetParent = NULL;
                   }
               }
            }

            nTotalTop = g_uiDisplay.DocPixelsFromDeviceY(nTotalTop);
            hr = _pWindowParent->get_screenTop(&nParentTopness);

            if (hr)
            {
                goto Cleanup;
            }

            *pVal = nParentTopness + nTotalTop;

            IHTMLDocument2* pDoc = NULL;
            IHTMLElement* pElem = NULL;
            IHTMLControlElement* pControlElem = NULL;
			IHTMLElement2 * pElem2 = NULL;
			
			long lValue = 0;

            if (SUCCEEDED(_pWindowParent->get_document(&pDoc)) && 
                SUCCEEDED(pDoc->get_body(&pElem)) && 
				SUCCEEDED(pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2)) &&	
				SUCCEEDED(pElem2->get_scrollTop(&lValue)))
            {
				if(_pWindowParent->IsPrimaryWindow()&& 
					SUCCEEDED(pElem->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
					SUCCEEDED(pControlElem->get_clientTop(&nTotalTop)))   
				{	
					*pVal = *pVal + nTotalTop;
					pControlElem->Release();
				}

				*pVal  -= lValue;
				pElem2->Release();
            }
        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CWindow::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    RRETURN(CBase::attachEvent(event, pDisp, pResult));
}

HRESULT
CWindow::detachEvent(BSTR event, IDispatch* pDisp)
{
    RRETURN(CBase::detachEvent(event, pDisp));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::execScript
//
//  Synopsis :  interface method to immediately execute a piece of script passed
//      in. this is added to support the multimedia efforts that need to execute
//      a script immediatedly, based on a high resolution timer. rather than
//      our setTimeOut mechanism which has to post execute-messages
//
//----------------------------------------------------------------------------

HRESULT
CWindow::execScript(BSTR bstrCode, BSTR bstrLanguage, VARIANT * pvarRet)
{
    HRESULT hr = E_INVALIDARG;

    if (SysStringLen(bstrCode) && pvarRet)
    {
        CExcepInfo       ExcepInfo;
        CScriptCollection * pScriptCollection;

        hr = CTL_E_METHODNOTAPPLICABLE;

        pScriptCollection = _pMarkup->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = THR(pScriptCollection->ParseScriptText(
                bstrLanguage,           // pchLanguage
                NULL,                   // pMarkup
                NULL,                   // pchType
                bstrCode,               // pchCode
                NULL,                   // pchItemName
                _T("\""),               // pchDelimiter
                0,                      // ulOffset
                0,                      // ulStartingLine
                NULL,                   // pSourceObject
                SCRIPTTEXT_ISVISIBLE,   // dwFlags
                pvarRet,                // pvarResult
                &ExcepInfo));           // pExcepInfo
        }
    }

    RRETURN(SetErrorInfo( hr ));
}


//+--------------------------------------------------------------------------
//
//  Member : print
//
//  Synopsis : implementation of the IOmWindow3 method to expose print behavior
//      through the OM. to get the proper UI all we need to do is send this
//      to the top level window.
//
//+--------------------------------------------------------------------------
HRESULT
CWindow::print()
{
    HRESULT  hr = S_OK;

    if (!Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }

    if (   Doc()->IsPrintDialog()
        || Doc()->_fPrintEvent
        || Doc()->_fPrintJobPending)
        goto Cleanup;

    //
    // TODO - we need this mechanism more generally, but due to the
    // fact that Print calls that come through IOleCommandTarget::Exec may
    // have varargs that need to be maintained, we need to do this in the
    // next release. for now, we can mark a pending job for this call
    // (no args) and send the exec during onLoadStatusDone
    //
    // if we are not done being parsed we cannot print.
    //
    if (_pMarkup->LoadStatus() <= LOADSTATUS_PARSE_DONE)
    {
        Doc()->_fPrintJobPending = TRUE;
        goto Cleanup;
    }

    // turn this into the print ExecCommand -- note that we have to start at
    // the root level document, not at this document. This is per spec.
    hr = THR(Doc()->ExecHelper(Doc()->_pWindowPrimary->Document(),
                            const_cast < GUID * > ( & CGID_MSHTML ),
                            IDM_EXECPRINT,
                            0,
                            NULL,
                            NULL));

    // is the print canceled?
    if (hr == S_FALSE || hr == OLECMDERR_E_CANCELED)
        hr = S_OK;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::open
//
//  Synopsis :  Open a new window.
//
//----------------------------------------------------------------------------

#ifdef NO_MARSHALLING
extern "C" HRESULT CoCreateInternetExplorer(REFIID iid, DWORD dwClsContext, void **ppvunk);
#endif

HRESULT
CWindow::open(
    BSTR url,
    BSTR name,
    BSTR features,
    VARIANT_BOOL replace,
    IHTMLWindow2** ppWindow)
{
    RRETURN(OpenEx(url, NULL, name, features, replace, ppWindow));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::navigate
//
//  Synopsis :  Navigate this window elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::navigate(BSTR bstrUrl)
{
    HRESULT hr;

    hr = THR(FollowHyperlinkHelper( bstrUrl, 0, 0));

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_closed
//
//  Synopsis :  Retrieve the closed property.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_closed(VARIANT_BOOL *p)
{
    HRESULT             hr = S_OK;

    if (Doc()->GetHWND())
    {
        *p = VB_FALSE;
    }
    else
    {
        *p = VB_TRUE;
    }

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_self
//
//  Synopsis :  Retrieve ourself.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_self(IHTMLWindow2 **ppSelf)
{
    HRESULT             hr = S_OK;

    *ppSelf = (IHTMLWindow2 *)this;
    AddRef();

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_window
//
//  Synopsis :  Retrieve self.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_window(IHTMLWindow2 **ppWindow)
{
    CWindow * pWindow = this;

    if (_punkViewLinkedWebOC)
    {
        COmWindowProxy * pOmWindowProxy = GetInnerWindow();

        if (pOmWindowProxy)
            pWindow = pOmWindowProxy->Window();
    }

    RRETURN(THR(pWindow->get_self(ppWindow)));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_top
//
//  Synopsis :  Get the topmost window in this hierarchy.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_top(IHTMLWindow2 **ppTop)
{
    HRESULT hr = S_OK;
    IHTMLWindow2 *  pThis = this;
    IHTMLWindow2 *  pParent = NULL;

    AddRef();   // To compensate for pThis.

    for (pThis->get_parent(&pParent);
         pParent && !IsSameObject(pParent, pThis);
         pThis->get_parent(&pParent))
    {
        ReleaseInterface(pThis);
        pThis = pParent;
        pParent = NULL;
    }

    Assert(pThis);
    *ppTop = pThis;
    pThis->AddRef();
    ReleaseInterface(pParent);
    ReleaseInterface(pThis);

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_parent
//
//  Synopsis :  Retrieve parent window in this hierarchy.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_parent(IHTMLWindow2 **ppParent)
{
    HRESULT  hr   = S_OK;
    CDoc   * pDoc = Doc();

    // If we have a parent window and the parent window
    // doesn't have a markup, a host app may be shutting
    // us downs in the middle of an event. In that
    // case, _pWindowParent->_pMarkup can be NULL. If
    // we are not shutting down and the markup is NULL,
    // we need to figure out why.
    //
    Assert(!_pWindowParent || _pWindowParent->_pMarkup || pDoc->_fIsClosingOrClosed);

    // Even if we have a window parent,
    // If we are a desktop item and our parent is the desktop or
    // If case we are in an HTA and we are not trusted while our parent is,
    // then return the self instead of the parent
    //
    if (   _pWindowParent
        && _pWindowParent->_pMarkup
        &&  !(!_pMarkup->IsMarkupTrusted()
            && _pWindowParent->_pMarkup->IsMarkupTrusted()))
    {
        Assert( !_pWindowParent->IsShuttingDown() );
        *ppParent = _pWindowParent;
        _pWindowParent->AddRef();
    }
    else if (pDoc->_fPopupDoc)
    {
        Assert(pDoc->_pPopupParentWindow);
        Assert( !pDoc->_pPopupParentWindow->IsShuttingDown() );
        *ppParent = pDoc->_pPopupParentWindow;
        pDoc->_pPopupParentWindow->AddRef();
    }
    else if (pDoc->_fViewLinkedInWebOC && !pDoc->_fIsActiveDesktopComponent)
    {
        COmWindowProxy * pOmWindowProxy = pDoc->GetOuterWindow();

        if (pOmWindowProxy)
            hr = THR(pOmWindowProxy->Window()->get_parent(ppParent));
    }
    else
    {
        hr = THR(get_self(ppParent));
    }

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::GetSecurityID
//
//  Synopsis:   Retrieve a security ID from a url from the system sec mgr.
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::GetSecurityID(BYTE *pbSID, DWORD *pcb, LPCTSTR pchURL, LPCWSTR pchDomain, BOOL useDomain)
{
    HRESULT hr;
    DWORD   dwSize;
    TCHAR   achURL[pdlUrlLen];
    CStr    cstrSpecialUrl;
    LPCTSTR pchCreatorUrl;
    CDoc *  pDoc = Doc();

    hr = THR(pDoc->EnsureSecurityManager());
    if (hr)
        goto Cleanup;

    if (!pchURL)
    {
        pchURL = GetUrl(this);
    }

    // Do we have a file URL?
    hr = THR(CoInternetParseUrl(pchURL,
                                PARSE_PATH_FROM_URL,
                                0,
                                achURL,
                                ARRAY_SIZE(achURL),
                                &dwSize,
                                0));

    // hr == S_OK indicates that the URL is a file URL.
    extern DWORD g_dwAppCompat;
    if (g_dwAppCompat)
    {
        if (!hr)
        {
            pchURL = achURL;
        }

        // Unescape the URL.
        hr = THR(CoInternetParseUrl(
                pchURL,
                PARSE_ENCODE,
                0,
                achURL,
                ARRAY_SIZE(achURL),
                &dwSize,
                0));
        if (hr)
            goto Cleanup;
 
        //UnescapeAndTruncateUrl appears to be used to prevent %01 spoofing.
        //It is needed only if we unescape the URL before calling GetSecurityID()
        UnescapeAndTruncateUrl(achURL);
    }
    else
    {
        if (hr)
            StrCpyN(achURL, pchURL, sizeof(achURL)/sizeof(achURL[0]));
    }
    
//TODO: FerhanE/Anandra:  Although we have removed the %01 hack from Trident and shdocvw,
//                        we need to provide this when getting the security ID from URLMON for now.
//                        We have to arrange it so that other customers of URLMON who use the
//                        GetSecurityID also update their code, before we can remove the dependency there.

    pchCreatorUrl = GetAAcreatorUrl();

    // If a creator URL is set, it means that either this markup's window was opened with window.open
    // or it is a frame with a special URL. Either case, we have to wrap the URL with the creator's to
    // reflect the creator's domain.

    if (pchCreatorUrl && *pchCreatorUrl)
    {
        hr = WrapSpecialUrl( achURL, &cstrSpecialUrl, pchCreatorUrl, FALSE, FALSE);
    }
    else
    {
        cstrSpecialUrl.Set(achURL);
    }

    hr = THR(pDoc->_pSecurityMgr->GetSecurityId(
                cstrSpecialUrl,
                pbSID,
                pcb,
                useDomain?(DWORD_PTR)pchDomain : (DWORD_PTR)Domain()));
    if (hr)
        goto Cleanup;

//  No counter action to the wrapping above, since the string is on stack

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  member :    CMarkup::IsUrlRecursive
//
//  Synopsis :  Check if url is recursive with parents by walking up the markup
//              tree.
//
//----------------------------------------------------------------------------

BOOL
CMarkup::IsUrlRecursive(LPCTSTR pchUrl)
{
    HRESULT             hr = S_OK;
    TCHAR               achUrlOnly[pdlUrlLen];
    LPTSTR              pchLocation;
    BOOL                fRes = FALSE;
    CMarkup *           pMarkup = this;

    //prepare a copy of the pchUrl, which can be manipulated and changed.
    StrCpy(achUrlOnly, pchUrl);

    // if there is a '#....' at the end of the url, we
    // don't want to have it there for the comparisons.
    pchLocation = (LPTSTR) UrlGetLocation(achUrlOnly);

    if (pchLocation)
        * pchLocation = _T('\0');

    // if we are pointing to any of the markups in the parent chain,
    // we would recurse forever.
    while (pMarkup)
    {
        DWORD   cchParentUrl = pdlUrlLen;
        TCHAR   achParentUrl[pdlUrlLen];

        // We were passing a NULL URL occasionally and tripping an assert,
        // so instead we continue with the return value that we would have gotten
        // had we made the call
        LPCTSTR pchTempUrl = CMarkup::GetUrl(pMarkup);
        if (pchTempUrl)
        {
            hr = THR(UrlCanonicalize(
                        pchTempUrl,
                        (LPTSTR) achParentUrl,
                        &cchParentUrl,
                        URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE));
        }
        else
        {
            hr = E_INVALIDARG;
        }

        // if the hr is wrong leave with a no-recursion return value,
        // this is by design (anandra-ferhane)
        if (hr)
            goto Cleanup;

        pchLocation = (LPTSTR) UrlGetLocation(achParentUrl);
        if (pchLocation)
            * pchLocation = _T('\0');

        // UrlCompare returns 0 if the urls are the same
        if ( !UrlCompare( achUrlOnly, achParentUrl, TRUE) )
        {
            // if two urls are the same, then the given url is recursive
            fRes = TRUE;
            goto Cleanup;
        }

        // walk up parent markup
        pMarkup = pMarkup->GetParentMarkup();
    }

Cleanup:
    return fRes;
}

//+------------------------------------------------------------------
//
//  Members: moveTo, moveBy, resizeTo, resizeBy
//
// TODO (carled) - eventually the then clause of the shdocvw if, should
// be removed and the else clause should become the body of
// this function.  To do this SHDOCVW will have to implement
// IHTMLOMWindowServices and this is part of the window split
// work.  This will have to happen for almost every function and
// method in this file that delegates explicitly to shdocvw.  i.e.
// trident should have NO explicit knowledge about its host.
//
//----------------------------------------------------------------------

HRESULT
CWindow::moveTo(long x, long y)
{
    HRESULT             hr = S_OK;
    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                ::SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->moveTo(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else    // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices *pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->moveTo(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        hr = THR(put_Left(x));
        if(hr)
            goto Cleanup;
        hr = THR(put_Top(y));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CWindow::moveBy(long x, long y)
{
    HRESULT             hr = S_OK;
    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                RECT rcWindow;

                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                ::GetWindowRect(hwnd, &rcWindow);

                ::SetWindowPos(hwnd, NULL, rcWindow.left + x, rcWindow.top + y, 0, 0,
                               SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->moveBy(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices * pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->moveBy(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        long xCur, yCur;

        hr = THR(get_Left(&xCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Left(x + xCur));
        if(hr)
            goto Cleanup;

        hr = THR(get_Top(&yCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Top(y + yCur));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CWindow::resizeTo(long x, long y)
{
    HRESULT             hr = S_OK;

    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                // We do not allow the size to be less then 100 for top level windows in browser
                if (x < 100)
                    x = 100;

                if (y < 100)
                    y = 100;

                ::SetWindowPos(hwnd, NULL, 0, 0, x, y, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->resizeTo(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices *pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->resizeTo(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        hr = THR(put_Width(x));
        if(hr)
            goto Cleanup;
        hr = THR(put_Height(y));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CWindow::resizeBy(long x, long y)
{
    HRESULT             hr = S_OK;
    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                RECT rcWindow;
                long w, h;

                ::GetWindowRect(hwnd, &rcWindow);

                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                w = rcWindow.right - rcWindow.left + x;
                h = rcWindow.bottom - rcWindow.top + y;

                if (w < 100)
                    w = 100;

                if (h < 100)
                    h = 100;

                ::SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->resizeBy(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices *pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->resizeBy(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        long xCur, yCur;

        hr = THR(get_Width(&xCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Width(x + xCur));
        if(hr)
            goto Cleanup;

        hr = THR(get_Height(&yCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Height(y + yCur));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_Option
//
//  Synopsis :  Retrieve Option element factory.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_Option(IHTMLOptionElementFactory **ppDisp)
{
    HRESULT                 hr = S_OK;
    COptionElementFactory * pFactory;

    if (ppDisp == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppDisp = NULL;

    pFactory = new COptionElementFactory;
    if ( !pFactory )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pFactory->_pMarkup = _pMarkup;
    _pMarkup->SubAddRef();
    hr = pFactory->QueryInterface ( IID_IHTMLOptionElementFactory, (void **)ppDisp );
    pFactory->PrivateRelease();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_Image
//
//  Synopsis :  Retrieve Image element factory.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_Image(IHTMLImageElementFactory**ppDisp)
{
    HRESULT                 hr = S_OK;
    CImageElementFactory *  pFactory;

    if (ppDisp == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppDisp = NULL;

    pFactory = new CImageElementFactory;
    if ( !pFactory )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pFactory->_pMarkup = _pMarkup;
    _pMarkup->SubAddRef();
    hr = pFactory->QueryInterface ( IID_IHTMLImageElementFactory, (void **)ppDisp );
    pFactory->PrivateRelease();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//----------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CWindow::OnCreate(IUnknown * pUnkDestination, ULONG cbCookie)
{
    HRESULT             hr;
    IServiceProvider *  pSP = NULL;
    CVariant            varDummy;
    CVariant            var;

    // Assume that we will fail.
    if( !pUnkDestination )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Get the IHTMLWindow2 from the IUnknown pointer we have in hand, to prepare the
    // return value for the window.open call.

    // Get the IServiceProvider interface pointer
    hr = THR(pUnkDestination->QueryInterface(IID_IServiceProvider, (void **) &pSP));
    if (hr)
        goto Cleanup;

    // We should not have anything in the _pOpenedWindow. However, we should clean it if
    // there is one, to stop a leak.
    // Once we switch to native frame, this release will not be needed.
    Assert(_pOpenedWindow == NULL );
    ReleaseInterface(_pOpenedWindow);

    // Get the IHTMLWindow2 interface pointer for the new window
    // We will not release the pointer we get, it will be handed to the caller of window.open.
    hr = THR(pSP->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void **) &_pOpenedWindow));
    if (hr)
        goto Cleanup;

    Assert(_pOpenedWindow);

    // set the opener property on the new window

    VariantInit(&var);
    VariantInit(&varDummy);

    V_VT(&var) = VT_DISPATCH;

    // If we are being hosted in SHDOCVW, then the opener should be its IHTMLWindow2 stub.
    // Otherwise, the opener is this window object.

    // No need to addref. put_opener takes care of the addref issue ...
    V_DISPATCH(&var) = DYNCAST(IHTMLWindow2, this);

    // call dummy put_opener in order to make use of its marshalling to set
    // child flag in opened window
    V_VT(&varDummy) = VT_BOOL;
    V_BOOL(&varDummy) = 666;
    hr = THR(_pOpenedWindow->put_opener(varDummy));

    // set actual opener
    hr = THR(_pOpenedWindow->put_opener(var));

    // clear the variant, without causing the reference to be released by accident
    V_VT(&var) = VT_EMPTY;

Cleanup:
    ReleaseInterface(pSP);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CWindow::OnReuse(IUnknown * pUnkDestination)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CWindow::GetOptionString(BSTR * pbstrOptions)
{
    HRESULT hr = S_OK;

    // if we are opening a window using the context menu etc. and not the window.open,
    // shdocvw will not reset the options it cached.
    // We return S_FALSE to indicate that the options should not be reset, and the
    // navigation request we made was not through a window.open call.
    if (!_fOpenInProgress)
    {
        return S_FALSE;
    }

    if (!pbstrOptions)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrOptions = NULL;

    // Allocate a new features string from the features string
    // we have received .
    if (_cstrFeatures)
    {
        // the caller will release the string, so we can NULL the pointer
        hr = THR(FormsAllocString(_cstrFeatures, pbstrOptions));

        // free the string, so we don't use the same set of options
        // for the next call.
        _cstrFeatures.Free();
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  CDocument - implementation for the window.document object
//
//--------------------------------------------------------------------------

const CBase::CLASSDESC CDocument::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDocument2,            // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

void
CDocument::Passivate()
{
    CFramesCollection * pFrames = NULL;

    if(_pPageTransitionInfo)
    {
        // Passing 1 will ensure we do not try to cleanup posted CleanupPageTransitions
        // requests from Passivate
        CleanupPageTransitions(TRUE);
        delete _pPageTransitionInfo;
    }

    GetPointerAt(FindAAIndex(DISPID_INTERNAL_FRAMESCOLLECTION, CAttrValue::AA_Internal),
        (void **) &pFrames);

    if (pFrames)
    {
        pFrames->Release();
    }


    super::Passivate();
}

CSecurityThunkSub::CSecurityThunkSub(CBase * pBase, DWORD dwThunkType)
{
    _pBase = pBase;
    _pvSecurityThunk = NULL;
    _dwThunkType = dwThunkType;
    _pBase->PrivateAddRef();
    _ulRefs = 0;
}

CSecurityThunkSub::~CSecurityThunkSub()
{
    Assert(_pBase);

    // If this thunk has already been reset, don't set it to NULL on the owner here
    // as this has already happened at the appropriate time on the reset.
    if (!_pvSecurityThunk)
    {
        switch(_dwThunkType)
        {
        case EnumSecThunkTypeDocument:
            DYNCAST(CDocument, _pBase)->_pvSecurityThunk = NULL;
            break;
        case EnumSecThunkTypeWindow:
            DYNCAST(COmWindowProxy, _pBase)->_pvSecurityThunk = NULL;
            break;
        case EnumSecThunkTypePendingWindow:
            DYNCAST(COmWindowProxy, _pBase)->_pvSecurityThunkPending = NULL;;
            break;
        default:
            AssertSz(0, "Invalid value for _dwThunkType");
        }
    }

    _pBase->PrivateRelease();
    _pvSecurityThunk = NULL;
}

extern BOOL g_fInIexplorer;
extern BOOL g_fInExplorer;

HRESULT
CSecurityThunkSub::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT     hr;

    if (!_pvSecurityThunk || (!g_fInExplorer && !g_fInIexplorer))
    {
        Assert(_pBase);
        hr = THR_NOTRACE(_pBase->PrivateQueryInterface(riid, ppv));
    }
    else 
    {
        // We are here because this sec. thunk has been reset in the browser
        if (_pvSecurityThunk &&
            (riid == IID_IUnknown || 
             riid == IID_IDispatch || 
             riid == IID_IDispatchEx))
        {
            if (ppv)
            {
                *ppv = _pvSecurityThunk;
                ((IUnknown *)*ppv)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            AssertSz(FALSE, "This document has been navigated");
            if (ppv)
                *ppv = NULL;

            hr = E_NOINTERFACE;
        }
    }

    RRETURN1(hr, E_NOINTERFACE);
}

ULONG
CSecurityThunkSub::AddRef()
{
    _ulRefs++;
    return _ulRefs;

}

ULONG
CSecurityThunkSub::Release()
{
    _ulRefs--;
    if (0 == _ulRefs)
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

///////////////////////////////////////////////////////////////////////////////
//
// Class CDocument
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////////

BEGIN_TEAROFF_TABLE(CDocument, IOleItemContainer)
    // IParseDisplayName methods
    TEAROFF_METHOD(CDocument, ParseDisplayName, parsedisplayname, (IBindCtx *pbc, LPOLESTR pszDisplayName,ULONG *pchEaten, IMoniker **ppmkOut))
    // IOleContainer methods
    TEAROFF_METHOD(CDocument, EnumObjects, enumobjects, (DWORD grfFlags, IEnumUnknown **ppenum))
    TEAROFF_METHOD(CDocument, LockContainer, lockcontainer, (BOOL fLock))
    // IOleItemContainer methods
    TEAROFF_METHOD(CDocument, GetObject, getobject, (LPTSTR pszItem, DWORD dwSpeedNeeded, IBindCtx *pbc, REFIID riid, void **ppvObject))
    TEAROFF_METHOD(CDocument, GetObjectStorage, getobjectstorage, (LPOLESTR pszItem, IBindCtx *pbc, REFIID riid, void **ppvStorage))
    TEAROFF_METHOD(CDocument, IsRunning, isrunning, (LPOLESTR pszItem))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IInternetHostSecurityManager)
    TEAROFF_METHOD(CDocument, HostGetSecurityId, hostgetsecurityid, (BYTE *pbSID, DWORD *pcb, LPCWSTR pwszDomain))
    TEAROFF_METHOD(CDocument, HostProcessUrlAction, hostprocessurlaction, (DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved))
    TEAROFF_METHOD(CDocument, HostQueryCustomPolicy, hostquerycustompolicy, (REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved))
END_TEAROFF_TABLE()

///////////////////////////////////////////////////////////////////////////////
//
// methods
//
///////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CDocument constructor
//
//--------------------------------------------------------------------------

CDocument::CDocument( CMarkup * pMarkupOwner )
{
#if 1 //..todo del
    Assert (!_pMarkup);
    Assert (!_pWindow);
    Assert (_eHTMLDocDirection == 0);
    Assert (!_pCSelectionObject);
    Assert (!_pvSecurityThunk);
#endif

    Assert( pMarkupOwner );
    _pMarkup = pMarkupOwner;

    _lnodeType = 9;     // Node type is set to DOCUMENT

    SetGalleryMeta(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::SwitchOwnerToWindow
//
//--------------------------------------------------------------------------
void
CDocument::SwitchOwnerToWindow( CWindow  * pWindow )
{
    Assert( pWindow && _pMarkup && !_pWindow );

    CMarkup * pMarkupRelease = NULL;

    // Transfer our >1 ref to the Window
    if (_ulRefs > 1)
    {
        pMarkupRelease = _pMarkup;
        pWindow->AddRef();
    }

    pWindow->_pDocument = this;
    _pMarkup->DelDocumentPtr();

    _pMarkup = NULL;
    _pWindow = pWindow;

    if (pMarkupRelease)
        pMarkupRelease->Release();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDocument::Window
//
//--------------------------------------------------------------------------

CWindow *
CDocument::Window()
{
    if (_pMarkup)
    {
        Assert (!_pWindow);

        COmWindowProxy * pWindowProxy = _pMarkup->Window();

        return pWindowProxy ? pWindowProxy->Window() : NULL;
    }
    else
    {
        Assert (_pWindow);
        return _pWindow;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::Markup
//
//--------------------------------------------------------------------------

CMarkup *
CDocument::Markup()
{
    if (_pWindow)
    {
        Assert (!_pMarkup);
        return _pWindow->Markup();
    }
    else
    {
        Assert (_pMarkup);
        return _pMarkup;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::GetWindowedMarkupContext
//
//--------------------------------------------------------------------------

CMarkup *
CDocument::GetWindowedMarkupContext()
{
    if (_pWindow)
    {
        Assert(!_pMarkup);
        return _pWindow->Markup();
    }
    else
    {
        Assert(_pMarkup && _pMarkup->GetWindowedMarkupContext());
        return _pMarkup->GetWindowedMarkupContext();
    }
}

COmWindowProxy *
CBase::Proxy()
{
    COmWindowProxy *pWindow = NULL;
    void *pObj;

    if (SUCCEEDED(PrivateQueryInterface(CLSID_HTMLWindow2, (void **)&pObj)))
    {
        pWindow = ((CWindow *)this)->_pWindowProxy;
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CDocument, (void **)&pObj)))
    {
        pWindow = ((CDocument *)this)->GetWindowedMarkupContext()->Window();
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CElement, (void **)&pObj)))
    {
        pWindow = ((CElement *)this)->GetWindowedMarkupContext()->Window();
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CStyle, (void**)&pObj)))
    {
        pWindow = ((CStyle*)this)->GetElementPtr()->GetWindowedMarkupContext()->Window();
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_HTMLLocation, (void**)&pObj)))
    {
        pWindow = ((COmLocation*)this)->Window()->_pWindowProxy;
    }    
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CAttribute, (void**)&pObj)))
    {
        pWindow = ((CAttribute*)this)->_pDocument->MyCWindow()->_pWindowProxy;
    }
    //CSelectionObject doesn't have a CLSID
    else if (SUCCEEDED(PrivateQueryInterface(IID_IHTMLSelectionObject, (void**)&pObj)))
    {
        pWindow = ((CSelectionObject*)this)->Document()->MyCWindow()->_pWindowProxy;
        ((IUnknown *)pObj)->Release();
    }    
    
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_HTMLWindowProxy, (void **)&pWindow)))
    {
        AssertSz((COmWindowProxy *)this == pWindow, "Window Proxy Mismatch");
    }

    if (pWindow == NULL)
    {
        // If you hit this assert, it means that the class that's coming through this codepath 
        // is not special cased above. To get rid of this assert, figure out what the derived
        // class is and add a case above for whatever class it is that's asserting.

        // This assert can't be enabled right now because the DRT triggers it. We need to find
        // what classes are needed to make the DRT run.
        //AssertSz(false, "Couldn't find a WindowProxy for this CBase-derived class, add one to the code!");
    }
    return pWindow;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::IsMyParentAlive
//
//--------------------------------------------------------------------------

inline BOOL
CDocument::IsMyParentAlive(void)
{
    return MyCWindow()->GetObjectRefs() != 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::PrivateAddRef
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDocument::PrivateAddRef()
{
    if( _ulRefs == 1 )
    {
        if (_pMarkup )
            _pMarkup->AddRef();
        else
        {
            Assert( _pWindow );
            _pWindow->AddRef();
        }

    }

    return super::PrivateAddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::PrivateRelease
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDocument::PrivateRelease()
{
    CMarkup * pMarkup = NULL;
    CWindow * pWindow = NULL;

    if( _ulRefs == 2 )
    {
        pMarkup = _pMarkup;
        pWindow = _pWindow;

        Assert( !!pMarkup ^ !!pWindow );
    }

    ULONG ret = super::PrivateRelease();

    if (pMarkup)
        pMarkup->Release();
    else if (pWindow)
        pWindow->Release();

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::GetSecurityThunk
//
//--------------------------------------------------------------------------

HRESULT
CDocument::GetSecurityThunk(LPVOID * ppv)
{
    HRESULT                 hr = S_OK;
    CSecurityThunkSub *     pThunkSub;

    if (!_pvSecurityThunk)
    {
        pThunkSub = new CSecurityThunkSub(this, CSecurityThunkSub::EnumSecThunkTypeDocument);
        if (!pThunkSub)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = CreateTearOffThunk(
            this,                                   // pvObject1
            (void*) s_apfnIDispatchEx,              // apfn1
            NULL,                                   // pUnkOuter
            &_pvSecurityThunk,                      // ppvThunk
            pThunkSub,                              // pvObject2
            *(void **)(IUnknown*)pThunkSub,         // apfn2
            QI_MASK | ADDREF_MASK | RELEASE_MASK,   // dwMask
            g_apIID_IDispatchEx);                   // appropdescsInVtblOrder

        if (hr)
            goto Cleanup;
    }

    *ppv = _pvSecurityThunk;

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     ResetSecurityThunk
//
//--------------------------------------------------------------------------

void
ResetSecurityThunkHelper(LPVOID * ppvSecurityThunk)
{
    Assert(ppvSecurityThunk);

    if (*ppvSecurityThunk)
    {
        TEAROFF_THUNK * pThunk = (TEAROFF_THUNK*)(*ppvSecurityThunk);

        Assert (pThunk->pvObject1);

        pThunk->pvObject1       = (IDispatchEx*)&g_DummySecurityDispatchEx;
        pThunk->apfnVtblObject1 = *(void **)(IDispatchEx*)(&g_DummySecurityDispatchEx);

        Assert (pThunk->pvObject2);
        CSecurityThunkSub *thunkSub = (CSecurityThunkSub *)(pThunk->pvObject2);
        thunkSub->_pvSecurityThunk = *ppvSecurityThunk;

        *ppvSecurityThunk = NULL;
    }
}

void
CDocument::ResetSecurityThunk()
{
    ResetSecurityThunkHelper(&_pvSecurityThunk);
}

void
COmWindowProxy::ResetSecurityThunk()
{
    ResetSecurityThunkHelper(&_pvSecurityThunk);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::QueryService
//
//--------------------------------------------------------------------------

HRESULT
CDocument::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT     hr = S_OK;
    CDoc  *     pDoc = Doc();
    CWindow *   pWindow = Window();

//
//TODO: FerhanE: Anvui tool should be changed to get rid of this hack here.
//
    if (IsEqualGUID(rguidService, IID_IDispatchEx) &&
        IsEqualGUID(riid,         IID_IDispatchEx))
    {
        hr = THR(GetSecurityThunk(ppvService));
        if (hr)
            goto Cleanup;

        ((IUnknown *)(*ppvService))->AddRef();
    }
    else if (IsEqualGUID(rguidService, SID_SContainerDispatch) || 
        IsEqualGUID(rguidService, IID_IInternetHostSecurityManager) ||
        IsEqualGUID(rguidService, IID_IInternetSecurityManager))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvService));
    }
    else if (IsEqualGUID(rguidService, IID_IAccessible))
    {
        // we have to return the IAccessible
        hr = EnsureAccWindow(pWindow);

        if (S_OK == hr)
        {
            hr = THR(pWindow->_pAccWindow->QueryInterface(riid,ppvService));
        }
        else
            hr = E_NOINTERFACE;
    }
    else if (IsEqualGUID(rguidService, CLSID_HTMLWindow2))
    {
        *ppvService = Markup()->GetNearestMarkupForScriptCollection()->Window()->Window();
    }
    else if (  pDoc->_fDefView
            && !Markup()->IsPrimaryMarkup()
            && IsEqualGUID(rguidService, SID_SShellBrowser)
            && IsEqualGUID(riid, IID_IBrowserService))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvService));
    }
    else if (pWindow)
    {
        hr = THR_NOTRACE(pWindow->QueryService(rguidService, riid, ppvService));
    }
    else if (Markup())
    {
        hr = THR_NOTRACE(pDoc->QueryService(rguidService, riid, ppvService));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
CDocument::QueryInterface(REFIID iid, LPVOID * ppv)
{
    void *          pv = NULL;
    const void *    apfn = NULL;
    HRESULT         hr;

    if (!ppv)
        RRETURN(E_INVALIDARG);

    CDoc *  pDoc = Doc();

    *ppv = NULL;

    if ( g_fInPip &&
        ( iid == IID_IPersistMoniker ||
          iid == IID_IPersistFile ))
    {
        RRETURN(E_NOINTERFACE);
    }

    switch (iid.Data1)
    {
        QI_TEAROFF(this, IOleCommandTarget, NULL)
        QI_TEAROFF(this, IInternetHostSecurityManager, NULL)
        QI_TEAROFF(this, IOleItemContainer, NULL)
        QI_TEAROFF(this, IPersistHistory, NULL)
        QI_TEAROFF(this, IPersistFile, NULL)
        QI_TEAROFF(this, IPersistStreamInit, NULL)
        QI_TEAROFF2(this, IPersist, IPersistFile, NULL)
        QI_TEAROFF(this, IPersistMoniker, NULL)
        QI_TEAROFF(this, IObjectSafety, NULL)
        QI_TEAROFF2(this, IOleContainer, IOleItemContainer, NULL)
        QI_TEAROFF2(this, IParseDisplayName, IOleItemContainer, NULL)
        QI_TEAROFF(this, IHTMLDOMNode, NULL)
        QI_TEAROFF(this, IHTMLDOMNode2, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument2, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument3, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument4, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument5, NULL)

        QI_FALLTHRU(IDispatch, IUnknown)
        QI_FALLTHRU(IDispatchEx, IUnknown)
        QI_CASE(IUnknown)
        {
            hr = THR(GetSecurityThunk(ppv));
            if (hr)
                RRETURN (hr);
            break;
        }

        QI_CASE(IHTMLDocument)
        {
            hr = THR(CreateTearOffThunk(this, s_apfnpdIHTMLDocument2, NULL, ppv));
            if (hr)
                RRETURN(hr);
            break;
        }
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(this, NULL);
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
        QI_FALLTHRU(IMarkupServices, IMarkupServices2)
        QI_CASE(IMarkupServices2)
        {
            apfn = CDoc::s_apfnIMarkupServices2;
            break;
        }
        QI_CASE(IHighlightRenderingServices)
        {
            apfn = CDoc::s_apfnIHighlightRenderingServices;
            break;
        }
        QI_FALLTHRU(IMarkupContainer, IMarkupContainer2)
        QI_CASE(IMarkupContainer2)
        {
            pv = Markup();
            apfn = CMarkup::s_apfnIMarkupContainer2;
            break;
        }
        QI_CASE(IHTMLChangePlayback)
        {
            pv = Markup();
            apfn = CMarkup::s_apfnIHTMLChangePlayback;
            break;
        }
        QI_CASE(IPersistStream)
        {
            apfn = s_apfnIPersistStreamInit;       // IPersistStreamInit contains everything IPersistStream has.
            pv = this;
            break;
        }
        QI_CASE(IDisplayServices)
        {
            apfn = CDoc::s_apfnIDisplayServices;
            break;
        }
        QI_CASE(IServiceProvider)
        {
            apfn = s_apfnIServiceProvider;
            pv = this;
            break;
        }
        QI_FALLTHRU(IOleWindow, IOleInPlaceObjectWindowless)
        QI_FALLTHRU(IOleInPlaceObject, IOleInPlaceObjectWindowless)
        QI_CASE(IOleInPlaceObjectWindowless)
        {
            apfn = CDoc::s_apfnIOleInPlaceObjectWindowless;
            break;
        }
        QI_CASE(IOleObject)
        {
            apfn = CDoc::s_apfnIOleObject;
            break;
        }
        QI_FALLTHRU(IViewObjectEx, IViewObject2)
        QI_FALLTHRU(IViewObject, IViewObject2)
        QI_CASE(IViewObject2)
        {
            apfn = *(void **)(IViewObjectEx *)pDoc;
            break;
        }
        QI_CASE(IOleControl)
        {
            apfn = CDoc::s_apfnIOleControl;
            break;
        }
        QI_FALLTHRU(IProvideMultipleClassInfo, IProvideClassInfo2)
        QI_FALLTHRU(IProvideClassInfo, IProvideClassInfo2)
        QI_CASE(IProvideClassInfo2)
        {
            apfn = CDoc::s_apfnIProvideMultipleClassInfo;
            break;
        }
        QI_CASE(ISpecifyPropertyPages)
        {
            apfn = CDoc::s_apfnISpecifyPropertyPages;
            break;
        }
        QI_CASE(IInternetSecurityManager)
        {
            pDoc->EnsureSecurityManager();
            *((IInternetSecurityManager **) ppv) = pDoc->_pSecurityMgr;
            break;
        }
#ifdef FANCY_CONNECTION_STUFF
        QI_CASE(IRunnableObject)
        {
            apfn = CDoc::s_apfnIRunnableObject;
            break;
        }
        QI_CASE(IExternalConnection)
        {
            apfn = CDoc::s_apfnIExternalConnection;
            break;
        }
#endif
        QI_CASE(IDataObject)
        {
            apfn = CDoc::s_apfnIDataObject;
            break;
        }
        QI_CASE(IOleDocument)
        {
            apfn = CDoc::s_apfnIOleDocument;
            break;
        }
        QI_FALLTHRU(IOleCache2, IOleCache)
        QI_CASE(IOleCache)
        {
            apfn = CDoc::s_apfnIOleCache2;
            break;
        }
        QI_CASE(IPointerInactive)
        {
            apfn = CDoc::s_apfnIPointerInactive;
            break;
        }
        QI_CASE(ISupportErrorInfo)
        {
            apfn = CDoc::s_apfnISupportErrorInfo;
            break;
        }
        QI_CASE(IPerPropertyBrowsing)
        {
            apfn = CDoc::s_apfnIPerPropertyBrowsing;
            break;
        }
        QI_CASE(IOleInPlaceActiveObject)
        {
            apfn = CDoc::s_apfnIOleInPlaceActiveObject;
            break;
        }
        QI_CASE(IOleDocumentView)
        {
            apfn = CDoc::s_apfnIOleDocumentView;
            break;
        }
#if DBG==1
        QI_CASE(IEditDebugServices)
        {
            apfn = CDoc::s_apfnIEditDebugServices;
            break;
        }
#endif
        QI_CASE(IIMEServices)
        {
            apfn = CDoc::s_apfnIIMEServices;
            break;
        }

        QI_CASE(IBrowserService)
        {
            if (pDoc->_fDefView && !Markup()->IsPrimaryMarkup())
            {
                apfn = s_apfnIBrowserService;
                pv = this;
            }

            break;
        }

        default:
            if (DispNonDualDIID(iid))
            {
                hr = THR(CreateTearOffThunk(
                        this,
                        (void *)CDocument::s_apfnpdIHTMLDocument2,
                        NULL,
                        ppv,
                        (void *)CDocument::s_ppropdescsInVtblOrderIHTMLDocument2));

                if (hr)
                    RRETURN(hr);

                break;
            }
            else if (IsEqualIID(iid, CLSID_CMarkup))
            {
                *ppv = Markup();
                return S_OK;
            } else if (IsEqualIID(iid, CLSID_CDocument))
            {
                *ppv = this;
                return S_OK;
            }
    }

    if (apfn && pDoc)
    {
        hr = THR(CreateTearOffThunk(
                pv ? pv : pDoc,
                apfn,
                NULL,
                ppv,
                (IUnknown *)(IPrivateUnknown *)this,
                *(void **)(IUnknown *)(IPrivateUnknown *)this,
                QI_MASK | ADDREF_MASK | RELEASE_MASK,
                NULL,
                NULL));
        if (hr)
            RRETURN(hr);
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }
}


CDoc *
CDocument::Doc()
{
    if (_pMarkup)
    {
        Assert (!_pWindow);
        return _pMarkup->Doc();
    }
    else
    {
        Assert (_pWindow);
        return _pWindow->Doc();
    }
}

CAtomTable *
CDocument::GetAtomTable(BOOL * pfExpando)
{
    CDoc * pDoc = Doc();

    if (pfExpando)
    {
        *pfExpando = GetWindowedMarkupContext()->_fExpando;
    }

    return &pDoc->_AtomTable;
}

HRESULT
CDocument::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    return QueryInterface(iid, ppv);
}

HRESULT
CDocument::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    HRESULT hr;

    hr = THR(Doc()->QueryStatusHelper(this, pguidCmdGroup, cCmds, rgCmds, pcmdtext));

    RRETURN(hr);
}

HRESULT
CDocument::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT hr;

    hr = THR(Doc()->ExecHelper(this, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

    SRETURN(hr);
}

long
CDocument::GetDocumentReadyState()
{
    CWindow * pWindow = Window();

    if ( pWindow &&
         pWindow->_pMarkupPending &&
         !IsScriptUrl (CMarkup::GetUrl(pWindow->_pMarkupPending) ))
    {
        return pWindow->_pMarkupPending->GetReadyState();
    }

    return Markup()->GetReadyState();
}


HRESULT
CDocument::InvokeEx(DISPID       dispid,
                    LCID         lcid,
                    WORD         wFlags,
                    DISPPARAMS * pdispparams,
                    VARIANT    * pvarResult,
                    EXCEPINFO  * pexcepinfo,
                    IServiceProvider * pSrvProvider)
{
    HRESULT     hr;
    CMarkup *   pMarkup;
    THREADSTATE *pts = GetThreadState();

    if (pts)
        pts->fCalledFromDocumentInvokeEx = TRUE;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    pMarkup = Markup();

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, GetDocumentReadyState(), pvarResult));
    if (hr != S_FALSE)
        goto Cleanup;

    if (DISPID_WINDOWOBJECT == dispid ||
        DISPID_SECURITYCTX == dispid ||
        DISPID_SECURITYDOMAIN == dispid)
    {
        if (!pMarkup->HasWindow())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        else
        {
            hr = THR(pMarkup->Window()->InvokeEx(dispid,
                                      lcid,
                                      wFlags,
                                      pdispparams,
                                      pvarResult,
                                      pexcepinfo,
                                      pSrvProvider));
        }
    }
    else
    {
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
        if (hr)
            goto Cleanup;

        // for IE3 backward compat, doc.Script has a diff dispid than in IE4, so
        // map it to new one.
        if (0x60020000 == dispid)
            dispid = DISPID_CDocument_Script;

        hr = THR_NOTRACE(DispatchInvokeCollection(this,
                                                  super::InvokeEx,
                                                  pMarkup->CollectionCache(),
                                                  CMarkup::NAVDOCUMENT_COLLECTION,
                                                  dispid,
                                                  IID_NULL,
                                                  lcid,
                                                  wFlags,
                                                  pdispparams,
                                                  pvarResult,
                                                  pexcepinfo,
                                                  NULL,
                                                  pSrvProvider));

    }

Cleanup:
    if (pts)
        pts->fCalledFromDocumentInvokeEx = FALSE;

    RRETURN_NOTRACE(hr);
}

HRESULT
CDocument::GetDispID(BSTR bstrName,
                   DWORD grfdex,
                   DISPID *pid)
{
    HRESULT hr;

    CMarkup * pMarkup = Markup();

    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(DispatchGetDispIDCollection(this,
                                                 super::GetDispID,
                                                 pMarkup->CollectionCache(),
                                                 CMarkup::NAVDOCUMENT_COLLECTION,
                                                 bstrName,
                                                 grfdex,
                                                 pid));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(THR_NOTRACE(hr));
}

HRESULT
CDocument::GetNextDispID(DWORD grfdex,
                       DISPID id,
                       DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(Markup()->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // Notice here that we set the fIgnoreOrdinals to TRUE for Nav compatability
    // We don't want ordinals in the document name space
    hr = DispatchGetNextDispIDCollection(this,
                                         super::GetNextDispID,
                                         Markup()->CollectionCache(),
                                         CMarkup::NAVDOCUMENT_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CDocument::GetMemberName(DISPID id,
                       BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(Markup()->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
                                         super::GetMemberName,
                                         Markup()->CollectionCache(),
                                         CMarkup::NAVDOCUMENT_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

HRESULT
CDocument::GetNameSpaceParent(IUnknown **ppunk)
{
    CMarkup * pMarkup = Markup()->GetNearestMarkupForScriptCollection();
    
#if DBG==1
    // optionally secure the window proxy given to script engine
    if (IsTagEnabled(tagSecureScriptWindow))
    {
        CScriptCollection *pSC = pMarkup->GetScriptCollection();
        Assert(pSC);
        Assert(pSC->_pSecureWindowProxy);
        Assert(!pSC->_pSecureWindowProxy->_fTrusted);
        HRESULT hr = pSC->_pSecureWindowProxy->QueryInterface(IID_IDispatchEx, (void **)ppunk);
        RRETURN(hr);
    }
#endif

    if ( pMarkup->HasWindowPending() )
    {
        RRETURN(pMarkup->GetWindowPending()->QueryInterface(IID_IDispatchEx, (void **)ppunk));
    }
    else
    {
        AssertSz(0,"no window");
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::OnPropertyChange
//
//  Synopsis:   Invalidate, fire property change, and so on.
//
//  Arguments:  [dispidProperty] -- PROPID of property that changed
//              [dwFlags]        -- Flags to inhibit behavior
//
//----------------------------------------------------------------------------
HRESULT
CDocument::OnPropertyChange(DISPID dispidProp, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    CDoc * pDoc = Doc();

    Assert( !ppropdesc || ppropdesc->GetDispid() == dispidProp );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );


    switch (dispidProp)
    {
        case DISPID_BACKCOLOR :
            pDoc->OnAmbientPropertyChange(DISPID_AMBIENT_BACKCOLOR);
            break;

        case DISPID_FORECOLOR :
            pDoc->OnAmbientPropertyChange(DISPID_AMBIENT_FORECOLOR);
            break;

        case DISPID_A_DIR :
            pDoc->OnAmbientPropertyChange(DISPID_AMBIENT_RIGHTTOLEFT);
            break;
        case DISPID_OMDOCUMENT+14:  // designMode
            pDoc->SetDesignMode(this, GetAAdesignMode());
            break;

    }

    if ((dwFlags & (SERVERCHNG_NOVIEWCHANGE|FORMCHNG_NOINVAL)) == 0)
    {
        pDoc->Invalidate();
    }

    if (dwFlags & ELEMCHNG_CLEARCACHES )
    {
        Markup()->Root()->GetFirstBranch()->VoidCachedInfo();
    }

    if (dwFlags & FORMCHNG_LAYOUT)
    {
        Markup()->Root()->ResizeElement(NFLAGS_FORCE);
    }

    // Don't fire OnPropertyChange for designmode - at least, we didn't before.
    if (Markup()->IsPrimaryMarkup() && dispidProp != DISPID_OMDOCUMENT+14)
    {
        Verify(!pDoc->CServer::OnPropertyChange(dispidProp, dwFlags, ppropdesc));
    }

    if (!(dwFlags & SERVERCHNG_NOPROPCHANGE))
    {
        IGNORE_HR(FireOnChanged(dispidProp));
    }

    // Let's special case something here.  If dispidProp == DISPID_IHTMLDOCUMENT2_ACTIVEELEMENT
    // then find the pTridentSvc and notify top-level browser (which should be listening for Intelliforms)
    //
    if (dispidProp == DISPID_CDocument_activeElement && pDoc->_pTridentSvc)
    {
        IHTMLElement *pEle=NULL;

        get_activeElement(&pEle);

        // Send it up even if NULL
        pDoc->_pTridentSvc->ActiveElementChanged(pEle);

        if (pEle)
            pEle->Release();
    }

    // see todo in CElement:OnPropertyChange
    // if ( fSomeoneIsListening )

    // Post the call to fire onpropertychange if dispid is that of activeElement, this
    // is so that the order of event firing is maintained in SetCurrentElem.
    if (dispidProp == DISPID_CDocument_activeElement)
        hr = THR(GWPostMethodCall(this, ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0, TRUE, "CDoc::FirePostedOnPropertyChange"));
    else
        hr = THR(Fire_PropertyChangeHelper(dispidProp, dwFlags, ppropdesc));

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::Fire_PropertyChangeHelper
//
//
//+---------------------------------------------------------------------------
HRESULT
CDocument::Fire_PropertyChangeHelper(DISPID dispidProperty, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    LPCTSTR pszName;
    PROPERTYDESC *pPropDesc = (PROPERTYDESC *)ppropdesc;

    if (pPropDesc)
    {
        Assert(dispidProperty == pPropDesc->GetDispid());
        //Assert(dwFlags == pPropDesc->GetdwFlags());
    }
    else
    {
        hr = THR(FindPropDescFromDispID(dispidProperty, &pPropDesc, NULL, NULL));
    }

    if (hr)
        goto Cleanup;

    Assert(pPropDesc);

    pszName = pPropDesc->pstrExposedName ? pPropDesc->pstrExposedName : pPropDesc->pstrName;

    if (pszName != NULL)
    {
        Fire_onpropertychange(pszName);
    }

Cleanup:
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::Fire_onpropertychange
//
//  Synopsis:   Fires the onpropertychange event, sets up the event param
//
//+----------------------------------------------------------------------------

void
CDocument::Fire_onpropertychange(LPCTSTR strPropName)
{
    EVENTPARAM param(Doc(), NULL, Markup(), TRUE);

    param.SetType(s_propdescCDocumentonpropertychange.a.pstrName + 2);
    param.SetPropName(strPropName);

    FireEvent(Doc(), DISPID_EVMETH_ONPROPERTYCHANGE, DISPID_EVPROP_ONPROPERTYCHANGE);
}

//+----------------------------------------------------------------------------
//
//  Member:     open, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::open(BSTR mimeType, VARIANT varName, VARIANT varFeatures, VARIANT varReplace,
                    /* retval */ IDispatch **ppDisp)
{
    CDoc::LOADINFO   LoadInfo = { 0 };
    HRESULT          hr = S_OK;
    CStr             cstrCallerURL;
    SSL_SECURITY_STATE sssCaller;
    VARIANT        * pvarName, * pvarFeatures, * pvarReplace;
    CVariant         vRep;
    BOOL             fReplace = FALSE;
    BSTR             bstrFullUrl = NULL;
    CMarkup        * pMarkup = Markup();
    CMarkup        * pMarkupNew = NULL;
    COmWindowProxy * pOmWindow;
    CDoc           * pDoc = Doc();
    DWORD            dwTLFlags = 0;

    if (ppDisp)
        *ppDisp = NULL;
    
    Assert(pMarkup);

    if (!pMarkup->HasWindow())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pvarName = (V_VT(&varName) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&varName) : &varName;

    pvarFeatures = (V_VT(&varFeatures) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&varFeatures) : &varFeatures;

    pvarReplace = (V_VT(&varReplace) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&varReplace) : &varReplace;

    // If parameter 3 is specified consider the call window.open
    if (!ISVARIANTEMPTY(pvarFeatures))
    {
        BSTR            bstrName, bstrFeatures;
        VARIANT_BOOL    vbReplace;

        // Check the parameter types
        if (V_VT(pvarName) != VT_BSTR ||
            (!ISVARIANTEMPTY(pvarFeatures) &&  V_VT(pvarFeatures) != VT_BSTR))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        bstrName = (ISVARIANTEMPTY(pvarName)) ? NULL : V_BSTR(pvarName);
        bstrFeatures = (ISVARIANTEMPTY(pvarFeatures)) ? NULL : V_BSTR(pvarFeatures);

        if (!ISVARIANTEMPTY(pvarReplace))
        {
            if (vRep.CoerceVariantArg(pvarReplace, VT_BOOL) != S_OK)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            vbReplace = V_BOOL(&vRep);
        }
        else
        {
            vbReplace = VB_FALSE;
        }

        hr = THR(GetFullyExpandedUrl(this, mimeType, &bstrFullUrl));
        if (hr)
            goto Cleanup;

        // In this case mimiType contains the URL
        // TODO (scotrobe): Bad - do not cast the ppDisp to an
        // IHTMLWindow2. It may not be a window. 
        //
        hr = THR(MyCWindow()->_pWindowProxy->open(bstrFullUrl, bstrName, bstrFeatures,
                                        vbReplace, (IHTMLWindow2 **) ppDisp));
        goto Cleanup;
    }



    // If we're running script then do nothing.
    if (pMarkup->HtmCtx())
    {
        if (pMarkup->IsInScriptExecution())
        {
            goto Cleanup;
        }

#if DBG==1
        // Any pending bindings then abort them.
        // Note that shdocvw forces READYSTATE_COMPLETE on subframes when we do this,
        // so don't assert when we notice that shdocvw's readystate is different from
        // the hosted doc (tagReadystateAssert is used in frmsite.cxx)
        BOOL fOldReadyStateAssert = IsTagEnabled(tagReadystateAssert);

        EnableTag(tagReadystateAssert, FALSE);
#endif

        if (pDoc->_pClientSite && pMarkup->IsPrimaryMarkup())
        {
            IGNORE_HR(CTExec(pDoc->_pClientSite,
                             &CGID_ShellDocView,
                             SHDVID_DOCWRITEABORT,
                             0,
                             NULL,
                             NULL));
        }

#if DBG==1
        EnableTag(tagReadystateAssert, fOldReadyStateAssert);
#endif
    }

    // If second argument is "replace", set replace
    if (V_VT(pvarName) == VT_BSTR)
    {
        if (V_BSTR(pvarName) && !StrCmpI(V_BSTR(pvarName),_T("replace")))
        {
            fReplace = TRUE;
        }
    }

    if (mimeType)
    {
        const MIMEINFO * pmi = GetMimeInfoFromMimeType(mimeType);

        // TODO: (TerryLu) If we can't find the known mimetype then to match
        //  Navigator we need to be able to open a plugin from a list of
        //  plugins.  Navigator will as well allow going to netscape page
        //  on plugins.  This is a task which needs to be done.

        if (pmi && pmi->pfnImg)
        {
            // TODO: (dinartem) We don't support opening image formats yet.
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        LoadInfo.pmi = pmi;
    }

    //
    // open implies close() if needed
    //

    if (pMarkup->HtmCtx() && pMarkup->HtmCtx()->IsOpened())
    {
        hr = THR(close());
        if (hr)
            goto Cleanup;
    }

    //
    // discover the calling doc's URL and security state
    // fire_onunload can stomp the DISPID_INTERNAL_INVOKECONTEXT,
    // so we need to get the security state/url out first
    //

    hr = THR(GetCallerSecurityStateAndURL(&sssCaller, cstrCallerURL, this, NULL));

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    //
    // Before starting the unload sequence, fire onbeforeunload and allow abort
    //

    pOmWindow = pMarkup->Window();
    Assert(pOmWindow);

    if (!pOmWindow->Fire_onbeforeunload())
    {
        goto Cleanup;
    }

    //
    // Right before clearing out the document, ask the shell to
    // create a history entry. (exception: replace history if
    // "replace" was specified or if opening over an about: page)
    //

    if (pDoc->_pInPlace && pDoc->_pInPlace->_pInPlaceSite)
    {
        CVariant var(VT_BSTR);
        const TCHAR * pchUrl = CMarkup::GetUrl(pMarkup);

        hr = cstrCallerURL.AllocBSTR(&V_BSTR(&var));
        if (hr)
            goto Cleanup;

        if (    pMarkup->IsPrimaryMarkup()
            &&  (fReplace || !pchUrl || !*pchUrl || GetUrlScheme(pchUrl) == URL_SCHEME_ABOUT))
        {
            IGNORE_HR(CTExec(pDoc->_pInPlace->_pInPlaceSite,
                             &CGID_Explorer,
                             SBCMDID_REPLACELOCATION,
                             0, &var, 0));

            LoadInfo.fDontUpdateTravelLog = TRUE;

        }
    } 

    if(fReplace)
    {
        LoadInfo.fDontUpdateTravelLog = TRUE;
    }

    LoadInfo.codepage        = CP_UCS_2;
    LoadInfo.fKeepOpen       = TRUE;
    LoadInfo.pchDisplayName  = cstrCallerURL;

    // TODO (MohanB) We should retain UrlOriginal if the caller is this document
    // LoadInfo.pchUrlOriginal  = const_cast<TCHAR*>(CMarkup::GetUrlOriginal(pMarkup));

    LoadInfo.fUnsecureSource = (sssCaller <= SSL_SECURITY_MIXED);

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pMarkup->Window());
    if (hr)
        goto Cleanup;

    LoadInfo.fDontFireWebOCEvents = TRUE;

    //
    // Since we are not loading this markup with a bind context, the LoadFromInfo
    // will not have a chance to call the SetAACreatorUrl.
    // In case this is a special URL, we set the creator URL here
    //
    if (IsSpecialUrl(cstrCallerURL))
    {
        TCHAR * pchCreatorUrl;

        pchCreatorUrl = (TCHAR *)pMarkup->GetAAcreatorUrl();

        TraceTag((tagSecurityContext,
                    "CDocument::open- Caller URL: %ws Existing Markup: 0x%x CreatorUrl: %ws",
                    (LPTSTR)cstrCallerURL, pMarkup, pchCreatorUrl));

        if (pchCreatorUrl && *pchCreatorUrl)
        {
            TraceTag((tagSecurityContext,
                        "CDocument::open- Set creator URL on new Markup:0x%x to URL:%ws",
                        pMarkupNew, pchCreatorUrl));

            pMarkupNew->SetAAcreatorUrl(pchCreatorUrl);
        }
        else
        {
            TraceTag((tagSecurityContext,
                        "CDocument::open- Set creator URL on new Markup:0x%x to URL:%ws",
                        pMarkupNew, (TCHAR *)CMarkup::GetUrl(pMarkup)));

            pMarkupNew->SetAAcreatorUrl((TCHAR *)CMarkup::GetUrl(pMarkup));
        }
    }

    hr = THR(pMarkupNew->LoadFromInfo(&LoadInfo, NULL, cstrCallerURL));

    if (hr)
        goto Cleanup;

    pMarkup->Window()->Window()->UpdateWindowData(NO_POSITION_COOKIE);

    // If the document.open() happens during a history
    // navigation (i.e., back/forward), we don't want to
    // update the travel log because it has already been
    // updated. Doing so will cause extra travel log entries.
    //
    if (!pMarkup->_fLoadingHistory && !pMarkup->_fNewWindowLoading)
    {
        dwTLFlags |= COmWindowProxy::TLF_UPDATETRAVELLOG
                  |  COmWindowProxy::TLF_UPDATEIFSAMEURL;
    }

    pMarkup->Window()->SwitchMarkup(pMarkupNew, FALSE, dwTLFlags, TRUE);

    // Write a unicode signature in case we need to reload this document

    Assert(pMarkupNew->HtmCtx());

    pMarkupNew->HtmCtx()->WriteUnicodeSignature();

    hr = S_OK;

    if (ppDisp)
    {
        Assert(this == pMarkupNew->Document());
        hr = THR(pMarkupNew->Document()->QueryInterface(IID_IHTMLDocument2, (void**)ppDisp));
    }

Cleanup:
    if (pMarkupNew)
    {
        pMarkupNew->Release();
    }

    FormsFreeString(bstrFullUrl);

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     write
//
//  Synopsis:   Automation method,
//              inserts the specified HTML into the preparser
//
//----------------------------------------------------------------------------
HRESULT
CDocument::write(SAFEARRAY * psarray)
{
    HRESULT             hr = S_OK;
    CVariant            varstr;
    long                iArg, cArg;
    IUnknown *          pUnkCaller = NULL;
    IServiceProvider *  pSrvProvider = NULL;
    CMarkup *           pMarkup = Markup();

    Assert(pMarkup);

    if (    !pMarkup->IsInScriptExecution()
        &&  (   pMarkup->LoadStatus() == LOADSTATUS_DONE
             || !pMarkup->HtmCtx()
             || !pMarkup->HtmCtx()->IsOpened()))
    {
        hr = THR(open(NULL, varstr, varstr, varstr, NULL));
        if (hr)
            goto Cleanup;
    }

    TraceTag((tagSecurityContext, "CDocument::write called"));

    pMarkup = Markup();    // CDocument::open creates a new markup

    Assert(pMarkup->HtmCtx());

    if (psarray == NULL || SafeArrayGetDim(psarray) != 1)
        goto Cleanup;

    cArg = psarray->rgsabound[0].cElements;

    // If we have a caller context (Established by IDispatchEx::InvokeEx,
    // use this to when converting the value in the safearray.
    GetUnknownObjectAt(FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT,
                                   CAttrValue::AA_Internal),
                       &pUnkCaller);
    if (pUnkCaller)
    {
        IGNORE_HR(pUnkCaller->QueryInterface(IID_IServiceProvider,
                                             (void**)&pSrvProvider));

        CStr cstrCallerURL;
        SSL_SECURITY_STATE sssCaller;

        // Do mixed security check now: pick up URL
        hr = THR(GetCallerSecurityStateAndURL(&sssCaller, cstrCallerURL, this, NULL));
        if (!SUCCEEDED(hr))
            goto Cleanup;

        if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cstrCallerURL, FALSE, TRUE, sssCaller <= SSL_SECURITY_MIXED))
            goto Cleanup;
    }

    for (iArg = 0; iArg < cArg; ++iArg)
    {
        VariantInit(&varstr);

        hr = SafeArrayGetElement(psarray, &iArg, &varstr);

        if (hr == S_OK)
        {
            hr = VariantChangeTypeSpecial(&varstr, &varstr, VT_BSTR, pSrvProvider);
            if (hr == S_OK)
            {
                Doc()->_iDocDotWriteVersion++;
                hr = THR(pMarkup->HtmCtx()->Write(varstr.bstrVal, TRUE));
            }

            VariantClear(&varstr);
        }

        if (hr)
            break;
    }

    //  bump up the count, this reduces the overall number of
    //      iterations that can happen before we prompt for denial of service
    //      (see CWindow::QueryContinueScript
    Assert(GetWindowedMarkupContext()->GetWindowPending());
    GetWindowedMarkupContext()->GetWindowPending()->Window()->ScaleHeavyStatementCount();

Cleanup:
    ReleaseInterface(pSrvProvider);
    ReleaseInterface(pUnkCaller);

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     writeln
//
//  Synopsis:   Automation method,
//              inserts the sepcified HTML into the preparser
//
//----------------------------------------------------------------------------
HRESULT
CDocument::writeln(SAFEARRAY * psarray)
{
    HRESULT hr;
    CMarkup * pMarkup;

    hr = THR(write(psarray));

    pMarkup = Markup();

    Assert(pMarkup);

    if ((hr == S_OK) && pMarkup->HtmCtx())
    {
        hr = THR(pMarkup->HtmCtx()->Write(_T("\r\n"), TRUE));
    }

    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     close, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::close(void)
{
    CMarkup * pMarkup = Markup();

    Assert(pMarkup);

    // Don't allow a document.close if a document.open didn't happen

    if (    !pMarkup->HtmCtx()
        ||  !pMarkup->HtmCtx()->IsOpened()
        ||  !pMarkup->GetProgSinkC())
        goto Cleanup;

    pMarkup->HtmCtx()->Close();
    pMarkup->GetProgSinkC()->OnMethodCall((DWORD_PTR) pMarkup->GetProgSinkC());

    Assert(!pMarkup->HtmCtx()->IsOpened());

Cleanup:
    return(S_OK);
}

HRESULT
CDocument::clear(void)
{
    // This routine is a no-op under Navigator and IE.  Use document.close
    // followed by document.open to clear all elements in the document.

    return S_OK;
}



//+----------------------------------------------------------------------------
//
// Member:      CDocument::GetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDocument::GetInterfaceSafetyOptions(
    REFIID riid,
    DWORD *pdwSupportedOptions,
    DWORD *pdwEnabledOptions)
{
    // TODO CDoc doesn't do much, but is this the right thing for a markup?
    return Doc()->GetInterfaceSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
}


//+----------------------------------------------------------------------------
//
// Member:      CDoc::SetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDocument::SetInterfaceSafetyOptions(
    REFIID riid,
    DWORD dwOptionSetMask,
    DWORD dwEnabledOptions)
{
    // TODO CDoc doesn't do much, but is this the right thing for a markup?
    return Doc()->SetInterfaceSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_bgColor, IOmDocument
//
//  Synopsis: defers to body get_bgcolor
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_bgColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAbgColor();
    }
    else
    {
        Val = pBody->GetFirstBranch()->GetCascadedbackgroundColor();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crBack()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_bgColor, IOmDocument
//
//  Synopsis: defers to body put_bgcolor
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_bgColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT            hr;
    CMarkup *          pMarkup = Markup();

    Assert(pMarkup);

    IGNORE_HR(pMarkup->GetBodyElement(&pBody));

    // this only goes up
    pMarkup->OnLoadStatus(LOADSTATUS_INTERACTIVE);

    if (!pBody)
    {
        // its NOT a body element. assume Frameset.
        hr = THR(s_propdescCDocumentbgColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
        if(hr)
            goto Cleanup;

        // Force a repaint and transition to a load-state where
        // we are allowed to redraw.
        Doc()->GetView()->Invalidate((CRect *)NULL, TRUE);
    }
    else
    {
        // we have a body tag
        hr = THR(pBody->put_bgColor(p));
        ReleaseInterface(pBody);

        Doc()->GetView()->EnsureView(LAYOUT_DEFEREVENTS | LAYOUT_SYNCHRONOUSPAINT);

        if (hr ==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_bgColor, 0, (PROPERTYDESC *)&s_propdescCDocumentbgColor);

    }

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_fgColor, IOmDocument
//
//  Synopsis: defers to body get_text
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_fgColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAfgColor();
    }
    else
    {
        Val = pBody->GetFirstBranch()->GetCascadedcolor();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crText()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_fgColor, IOmDocument
//
//  Synopsis: defers to body put_text
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_fgColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT        hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        hr = THR(s_propdescCDocumentfgColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_text(p));
        ReleaseInterface(pBody);
        if (hr == S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_fgColor, 0, (PROPERTYDESC *)&s_propdescCDocumentfgColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_linkColor, IOmDocument
//
//  Synopsis: defers to body get_link
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_linkColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAlinkColor();
    }
    else
    {
        Val = pBody->GetAAlink();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crAnchor()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_linkColor, IOmDocument
//
//  Synopsis: defers to body put_link
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_linkColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT        hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        hr = THR(s_propdescCDocumentlinkColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_link(p));
        ReleaseInterface(pBody);
        if (hr==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_linkColor, 0, (PROPERTYDESC *)&s_propdescCDocumentlinkColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_alinkColor, IOmDocument
//
//  Synopsis: defers to body get_aLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_alinkColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAalinkColor();
    }
    else
    {
        Val = pBody->GetAAaLink();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crAnchor()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_alinkColor, IOmDocument
//
//  Synopsis: defers to body put_aLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_alinkColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT        hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        hr = THR(s_propdescCDocumentalinkColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_aLink(p));
        ReleaseInterface(pBody);
        if (hr==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_alinkColor, 0, (PROPERTYDESC *)&s_propdescCDocumentalinkColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_vlinkColor, IOmDocument
//
//  Synopsis: defers to body get_vLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_vlinkColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAvlinkColor();
    }
    else
    {
        Val = pBody->GetAAvLink();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crAnchorVisited()));

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_vlinkColor, IOmDocument
//
//  Synopsis: defers to body put_vLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_vlinkColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT            hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        // not a body, assume frameset
        hr = THR(s_propdescCDocumentvlinkColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_vLink(p));
        ReleaseInterface(pBody);
        if (hr==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_vlinkColor, 0, (PROPERTYDESC *)&s_propdescCDocumentvlinkColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

HRESULT
CDocument::get_parentWindow(IHTMLWindow2 **ppWindow)
{
    HRESULT             hr;
    CMarkup *           pMarkup = Markup();
    COmWindowProxy *    pWindow;
    CVariant            varWindow(VT_DISPATCH);
    CVariant            varRes(VT_DISPATCH);

    if ( ppWindow )
        *ppWindow = NULL;

    Assert(pMarkup);
    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pWindow = pMarkup->GetFrameOrPrimaryMarkup()->Window();
    AssertSz (pWindow, "Frame or primary markup does not have window - this should be an impossible sitation");
    if (!pWindow)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    V_DISPATCH(&varWindow) = (IHTMLWindow2 *)pWindow;
    pWindow->AddRef();

    hr = pWindow->SecureObject( &varWindow, &varRes, NULL, this);

    if (!hr)
    {
        *ppWindow = ((IHTMLWindow2 *)V_DISPATCH(&varRes));
        (*ppWindow)->AddRef();
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     activeElement, IOmDocument
//
//  Synopsis: returns a pointer to the active element (the element with the focus)
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_activeElement(IHTMLElement ** ppElement)
{
    HRESULT     hr = S_OK;
    CDoc    *   pDoc = Doc();
    CMarkup *   pMarkup = Markup();

    if (!ppElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElement = NULL;

    if (pDoc->_pElemCurrent && pDoc->_pElemCurrent != pDoc->PrimaryRoot())
    {
        CElement * pTarget = pDoc->_pElemCurrent;

        //
        // Marka - check that currency and context are in sync. It IS valid for them to be out
        // of sync ONLY if we have a selection in an HTMLArea or similar control and have clicked
        // away on a button (ie lost focus in the control that has selection).
        //
        // OR We're not in designmode
        //
        // We leave this assert here to assure that currency and context are in sync during the places
        // in the Drt that get_activeElement is called (eg. during siteselect.js).
        //
#ifdef SET_EDIT_CONTEXT
        AssertSz(( !pDoc->_pElemEditContext ||
                   ! pDoc->_fDesignMode ||
                  pDoc->_pElemEditContext == pDoc->_pElemCurrent ||
                 ( pDoc->_pElemEditContext->TestLock(CElement::ELEMENTLOCK_FOCUS ))||
                 ( pDoc->_pElemEditContext->GetMasterPtr()->TestLock(CElement::ELEMENTLOCK_FOCUS )) ||
                  (pDoc->_pElemEditContext && pDoc->_pElemEditContext->GetMasterPtr() == pDoc->_pElemCurrent)), "Currency and context do not match" );
#endif


        // if an area has focus, we have to report that
        if (pDoc->_pElemCurrent->Tag() == ETAG_IMG && pDoc->_lSubCurrent >= 0)
        {
            CAreaElement * pArea = NULL;
            CImgElement *pImg = DYNCAST(CImgElement, pDoc->_pElemCurrent);

            if (pImg->GetMap())
            {
                pImg->GetMap()->GetAreaContaining(pDoc->_lSubCurrent, &pArea);
                pTarget = pArea;
            }
        }

        // now that we have a target element, let's make sure that we return
        // something in the CDocument which received the call.
        if (pTarget->GetMarkup() != pMarkup)
        {
            // the element is not in the markup that this CDocument is attached to.

            // Is it in a markup that this one contains ?
            CTreeNode * pNode = pTarget->GetFirstBranch();
            Assert(pNode);
            pNode = pNode->GetNodeInMarkup(pMarkup);

            //
            // TODO: right fix is to cache elemActive per Markup
            //

            if (!pNode)
            {
                pTarget = NULL;
                if (    pMarkup->LoadStatus() >= LOADSTATUS_DONE
                    &&  pMarkup->Root()->HasMasterPtr())
                {
                    CElement * pElemMaster = pMarkup->Root()->GetMasterPtr();

                    if (    pElemMaster->Tag() == ETAG_FRAME
                        ||  pElemMaster->Tag() == ETAG_IFRAME)
                    {
                        pTarget = pMarkup->GetElementClient();
                    }
                }
                if (!pTarget)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            else
            {
                pTarget = pNode->Element();
            }

            Assert(pTarget);
        }

        // all other cases fall through
        IGNORE_HR(pTarget->QueryInterface(IID_IHTMLElement,
                                          (void**) ppElement));
    }

    if (*ppElement == NULL && pDoc->_fVID && !pDoc->_fVID7)
        hr = E_FAIL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member  : GetMarkupUrl
//
//  Synopsis: returns the raw, uncanonicalized, url of this document. If
//            fOriginal is TRUE, then return the original URL, otherwise
//            the one obtained from the moniker after URLMON transformations.
//
//-----------------------------------------------------------------------------

HRESULT
CDocument::GetMarkupUrl(CStr * const pcstrRetString, BOOL fOriginal)
{
    HRESULT   hr;
    CMarkup * pMarkup       = Markup();
    LPCTSTR   pchUrl        = NULL;
    CDoc *pDoc = Doc();

    // HACKALERT (sramani) Photo Suite III calls get_URL before waiting for any
    // document complete events while navigating and it expects to get the URL
    // of the new page, but pMarkup is still pointing to the old page. Bug 93275.

    // DOUBLEHACKALERT (sramani) msxml needs the doc from the pending markup, apparently
    // for doing some security checks, which fails when using back\forward nav. Bug 109727

    if (g_fInPhotoSuiteIII || (pDoc->_fStartup && pDoc->IsAggregatedByXMLMime()))
    {
        CWindow * pWindow = Window();

        //
        // TODO (FerhanE) The solution explained above and implemented below is good
        // in general but not for JScript and VBScript URL href calls. These are creating pending
        // markups and then releasing them w/o switching them in. This causes the URL
        // that is returned to be the href of the link, not the containing markup's URL.
        // Working around it for now with the same reasoning above. Bug 94256.
        //
        if (pWindow && pWindow->_pMarkupPending)
        {
            CMarkup * pMarkupPending = pWindow->_pMarkupPending;
            UINT      uProt;

            uProt = GetUrlScheme(CMarkup::GetUrl(pMarkupPending));

            if (URL_SCHEME_JAVASCRIPT != uProt && URL_SCHEME_VBSCRIPT != uProt)
            {
                pMarkup = pMarkupPending;
            }
        }
    }

    if (fOriginal && pMarkup && pMarkup->HasLocationContext())
    {
        pchUrl = pMarkup->GetLocationContext()->_pchUrlOriginal;
    }

    if (!pchUrl)
    {
        fOriginal = FALSE;
        pchUrl = CMarkup::GetUrl(pMarkup);
    }

    hr = THR(pcstrRetString->Set(pchUrl));
    if (hr)
        goto Cleanup;

    if (!fOriginal)
    {
        CStr cstrLocation;

        cstrLocation.Set(CMarkup::GetUrlLocation(pMarkup));
        if (cstrLocation.Length())
        {
            hr = THR(pcstrRetString->Append(cstrLocation));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------------------------
//
//  Member:     get_URL, IOmDocument
//
//  Synopsis: returns the url of this document
//
//--------------------------------------------------------------------------------------------

HRESULT
CDocument::get_URL(BSTR * pbstrUrl)
{
    HRESULT hr = S_OK;
    CStr    cstrRetString;
    TCHAR   achUrl[pdlUrlLen];
    DWORD   dwLength = ARRAY_SIZE(achUrl);

    if (!pbstrUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrUrl = NULL;

    hr = GetMarkupUrl(&cstrRetString, FALSE);
    if (hr)
        goto Cleanup;

    if (!InternetCanonicalizeUrl(cstrRetString,
                                 achUrl,
                                 &dwLength,
                                 ICU_DECODE | URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE))
        goto Cleanup;

    *pbstrUrl = SysAllocString(achUrl);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------------------------
//
//  Member:     get_URLUnencoded, IHTMLDocument4
//
//  Synopsis: returns the unencoded url of this document
//
//--------------------------------------------------------------------------------------------

HRESULT
CDocument::get_URLUnencoded(BSTR * pbstrUrl)
{
    HRESULT hr = S_OK;
    CStr    cstrRetString;
    TCHAR   achUrl[pdlUrlLen];
    DWORD   dwLength = ARRAY_SIZE(achUrl);

    if (!pbstrUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrUrl = NULL;

    hr = GetMarkupUrl(&cstrRetString, FALSE);
    if (hr)
        goto Cleanup;

        if (!InternetCanonicalizeUrl(cstrRetString, achUrl, &dwLength,
                                 ICU_NO_ENCODE | ICU_DECODE | URL_BROWSER_MODE))
        {
            goto Cleanup;
        }

    // MHTML protocol URLs begin with mhtml:. We have to
    // strip off the mhtml protocol specifier in this case.
    //
    if (StrStr(achUrl, _T("mhtml:")))
    {
        *pbstrUrl = SysAllocString(StrChr(achUrl, _T(':'))+1);
    }
    else
    {
        *pbstrUrl = SysAllocString(achUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     put_URL, IOmDocument
//
//  Synopsis: set the url of this document by defering to put_ window.location.href
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_URL(BSTR b)
{
    IHTMLLocation * pLocation =NULL;
    HRESULT hr = S_OK;
    BSTR bstrNew = NULL;

    if (!Markup()->HasWindow())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr =THR(Markup()->Window()->get_location(&pLocation));
    if (hr)
        goto Cleanup;

    hr = THR(GetFullyExpandedUrl(this, b, &bstrNew));
    if (hr)
        goto Cleanup;

    hr =THR(pLocation->put_href(bstrNew));
    if (hr)
        goto Cleanup;

    Fire_PropertyChangeHelper(DISPID_CDocument_URL, 0, (PROPERTYDESC *)&s_propdescCDocumentURL);

Cleanup:
    FormsFreeString(bstrNew);
    ReleaseInterface(pLocation);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_location, IOmDocument
//
//  Synopsis : this defers to the window.location property
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_location(IHTMLLocation** ppLocation)
{
    HRESULT hr = S_OK;
    IHTMLWindow2 * pNewWindow = NULL;

    if (!Markup()->HasWindow())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    COmWindowProxy * pProxy = Markup()->Window();    

    IGNORE_HR(pProxy->SecureObject(pProxy, (IHTMLWindow2**)&pNewWindow, TRUE));

    hr =THR(pNewWindow->get_location(ppLocation));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pNewWindow);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_lastModified, IOmDocument
//
//  Synopsis: returns the date of the most recent change to the document
//              this comes from the http header.
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_lastModified(BSTR * p)
{
    HRESULT  hr = S_OK;
    FILETIME ftLastMod;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *p = NULL;

    ftLastMod = Markup()->GetLastModDate();

    if (!ftLastMod.dwLowDateTime && !ftLastMod.dwHighDateTime)
    {
        // TODO  - If the last modified date is requested early enough on a slow (modem) link
        // then sometimes the GetCacheInfo call fails in this case the current date and time is
        // returned.  This is not the optimal solution but it allows the user to use the page without
        // a scriping error and since we are guarenteed to be currently downloading this page for this
        // to fail the date should not appear to unusual.
        SYSTEMTIME  currentSysTime;

        GetSystemTime(&currentSysTime);
        if (!SystemTimeToFileTime(&currentSysTime, &ftLastMod))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // We alway convert to fixed mm/dd/yyyy hh:mm:ss format TRUE means include the time
    hr = THR(ConvertDateTimeToString(ftLastMod, p, TRUE));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_referrer, IOmDocument
//
//  Synopsis: returns the url of the document that had the link to this one
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_referrer(BSTR * p)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = Markup();

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *p = NULL;
    Assert( pMarkup );
    if (pMarkup->GetDwnDoc() && pMarkup->GetDwnDoc()->GetDocReferer())
    {
        CStr    cstrRefer;

        cstrRefer.Set(pMarkup->GetDwnDoc()->GetDocReferer());
        if (*cstrRefer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        {
            UINT    uProtRefer = GetUrlScheme(cstrRefer);
            UINT    uProtUrl   = GetUrlScheme(CMarkup::GetUrl(pMarkup));

            //only report the referred if: (referrer_scheme/target_Scheme)
            // http/http   http/https     https/https
            // so the if statement is :
            // (http_r && ( http_t || https_t)) || (https_r && https_t)
            if ((URL_SCHEME_HTTP == uProtRefer &&
                      (URL_SCHEME_HTTP == uProtUrl ||
                       URL_SCHEME_HTTPS == uProtUrl))
                 || (URL_SCHEME_HTTPS == uProtRefer &&
                     URL_SCHEME_HTTPS == uProtUrl))
            {
                cstrRefer.AllocBSTR(p);
                if (*p == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_domain, IOmDocument
//
//  Synopsis: returns the domain of the current document, initially the hostname
//      but once set, it is a sub-domain of the url hostname
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_domain(BSTR * p)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup = Markup();
    LPCTSTR pchUrl = CMarkup::GetUrl(pMarkup);
    LPCTSTR pchCreatorUrl;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pchUrl || !*pchUrl)
    {
        *p = 0;
        goto Cleanup;
    }

    // This is for IE 5.01 compatibility bug 94729.
    if (IsSpecialUrl(pchUrl) && pMarkup)
    {
        pchCreatorUrl = pMarkup->GetAAcreatorUrl();
        if (pchCreatorUrl && *pchCreatorUrl)
            pchUrl = pchCreatorUrl;
    }

    Assert( pMarkup );
    if (pMarkup->Domain() && *(pMarkup->Domain()))
    {
        hr = THR(FormsAllocString(pMarkup->Domain(), p));
    }
    else
    {
        CStr    cstrComp;

        hr = THR_NOTRACE(Doc()->GetMyDomain(pchUrl, &cstrComp));   // TODO (lmollico): move to CMarkup
        if (hr == S_FALSE) hr = S_OK;
        if (hr)
            goto Cleanup;

        hr = THR(cstrComp.AllocBSTR(p));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     put_domain, IDocument
//
//  Synopsis: restricted to setting as a domain suffix of the hostname
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_domain (BSTR p)
{
    HRESULT hr = S_OK;
    CStr    cstrComp;
    TCHAR * pTempSet;
    TCHAR * pTempUrl;
    long    lSetSize;
    long    lUrlSize;
    long    lOffset;
    CMarkup * pMarkup = Markup();
    const TCHAR * pchUrl = CMarkup::GetUrl(pMarkup);

    if (!pchUrl || !*pchUrl)
    {
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }

    hr = THR(Doc()->GetMyDomain(pchUrl, &cstrComp)); // TODO (lmollico): move to CMarkup
    if (hr)
        goto Cleanup;

    // set up variable for loop
    lSetSize = SysStringLen(p);
    lUrlSize = cstrComp.Length();

    if ((lUrlSize == lSetSize) && !FormsStringNICmp(cstrComp, lUrlSize, p, lSetSize))
    {
        pMarkup->Window()->_fDomainChanged = 1;
        hr = THR(pMarkup->SetDomain(p));
        goto Cleanup;   // hr is S_OK
    }

    hr = E_INVALIDARG;

    if (lSetSize >lUrlSize)   // set is bigger than url
        goto Cleanup;

    lOffset = lUrlSize - lSetSize;
    pTempUrl = cstrComp + lOffset-1;

    //must be proper substring wrt the . in the url domain
    if (lOffset && *pTempUrl++ != _T('.'))
        goto Cleanup;

    if (!FormsStringNICmp(pTempUrl, lSetSize, p, lSetSize))
    {
        BYTE    abSID[MAX_SIZE_SECURITY_ID];
        DWORD   cbSID = ARRAY_SIZE(abSID);

        // match! now for one final check
        // there must be a '.' in the set string
        pTempSet = p+1;
        if (!_tcsstr(pTempSet, _T(".")))
            goto Cleanup;

        hr = THR(pMarkup->SetDomain(p));
        if (hr)
            goto Cleanup;

        //
        // If we successfully set the domain, reset the sid of
        // the security proxy based on the new information.
        //

        hr = THR(pMarkup->GetSecurityID(abSID, &cbSID));
        if (hr)
            goto Cleanup;

        hr = THR(pMarkup->Window()->Init(MyCWindow(), abSID, cbSID));
        if (hr)
            goto Cleanup;

        // Set the flag: domain is modified
        pMarkup->Window()->_fDomainChanged = 1;

        IGNORE_HR(OnPropertyChange(DISPID_CDocument_domain,
                                   0,
                                   (PROPERTYDESC *)&s_propdescCDocumentdomain));
    }

Cleanup:
    if (hr == S_FALSE)
        hr = CTL_E_METHODNOTAPPLICABLE;
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument:get_readyState
//
//  Synopsis:  first implementation, this is for the OM and uses the long _readyState
//      to determine the string returned.
//
//+------------------------------------------------------------------------------
HRESULT
CDocument::get_readyState(BSTR * p)
{
    HRESULT     hr      = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(GetDocumentReadyState(), p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDoc::get_Script
//
//  Synopsis:   returns OmWindow.  This routine returns the browser's
//   implementation of IOmWindow object, not our own _pOmWindow object.  This
//   is because the browser's object is the one with the longest lifetime and
//   which is handed to external entities.  See window.cxx CWindow::XXXX
//   for crazy delegation code.
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_Script(IDispatch **ppWindow)
{
    HRESULT hr = S_OK;
    IHTMLWindow2 *pWindow = NULL;
    CVariant varWindow(VT_DISPATCH);
    CVariant varRes(VT_DISPATCH);
    COmWindowProxy *pProxy = Markup() ? Markup()->Window() : NULL;

    if (ppWindow)
        *ppWindow = NULL;

    if (pProxy)
    {
        hr = THR(pProxy->QueryInterface(IID_IHTMLWindow2, (void **)&pWindow));
        if (hr)
            goto Cleanup;

        V_DISPATCH(&varWindow) = pWindow;

        hr = pProxy->SecureObject(&varWindow, &varRes, NULL, this);
        if (!hr)
        {
            *ppWindow = ((IHTMLWindow2 *)V_DISPATCH(&varRes));
            (*ppWindow)->AddRef();
        }
    }
    else
    {
        hr = E_PENDING;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::releaseCapture()
{
    Doc()->ReleaseOMCapture();
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CDocument::get_frames(IHTMLFramesCollection2 ** ppDisp)
{
    HRESULT hr                  = E_INVALIDARG;
    CMarkup           * pMarkup;

    if (!ppDisp)
        goto Cleanup;

    *ppDisp = NULL;
    pMarkup = Markup();

    Assert( pMarkup );
    
    // If there is a window, return it to be compatible with old behavior
    if (pMarkup->HasWindow())
    {
        hr = pMarkup->Window()->get_frames(ppDisp);
        goto Cleanup;
    }

    else
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

#ifdef THIS_IS_INSECURE

    // Otherwise, construct (if necessary) and return a frames collection object

    GetPointerAt(FindAAIndex(DISPID_INTERNAL_FRAMESCOLLECTION, CAttrValue::AA_Internal),
        (void **) &pFrames);

    if (!pFrames)
    {
        pFrames = new CFramesCollection(this);
        if (!pFrames)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        AddPointer(DISPID_INTERNAL_FRAMESCOLLECTION, (void *) pFrames, CAttrValue::AA_Internal);
    }
    hr = THR_NOTRACE(pFrames->QueryInterface(IID_IHTMLFramesCollection2, (void**) ppDisp));
#endif

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_styleSheets(IHTMLStyleSheetsCollection** ppDisp)
{
    HRESULT hr = E_POINTER;

    if (!ppDisp)
        goto Cleanup;

    hr = THR(Markup()->EnsureStyleSheets());
    if (hr)
        goto Cleanup;

    hr = THR(Markup()->GetStyleSheetArray()->
            QueryInterface(IID_IHTMLStyleSheetsCollection, (void**)ppDisp));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_compatMode(BSTR *pbstr)
{
    HRESULT hr;

    if (pbstr == NULL)
    {
        hr = E_POINTER;
    }
    else
    {
        htmlCompatMode hcm =  Markup()->IsStrictCSS1Document() ? htmlCompatModeCSS1Compat : htmlCompatModeBackCompat;
        hr = THR(STRINGFROMENUM(htmlCompatMode, hcm, pbstr));
    }

    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     GetSelection
//
//  Synopsis:   for the Automation Object Model, this returns a pointer to
//                  the ISelectionObj interface. which fronts for the
//                  selection record exposed
//
//-------------------------------------------------------------------------
HRESULT
CDocument::get_selection(IHTMLSelectionObject ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_pCSelectionObject || _pCSelectionObject->GetSecurityMarkup() != Markup())
    {        
        _pCSelectionObject = new CSelectionObject(this);
        
        if (!_pCSelectionObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCSelectionObject->QueryInterface(IID_IHTMLSelectionObject,
                                                (void**) ppDisp ));

        _pCSelectionObject->Release();

        if (hr )
            goto Cleanup;
    }
    else
    {
        hr = THR(_pCSelectionObject->QueryInterface(IID_IHTMLSelectionObject,
                                                (void **) ppDisp));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    //
    // Fix for Vizactbug - 93247
    // We want the doc's DeferUpdateUI to get called for this method.
    // so we call the Doc's SetErrorInfo.
    //
    if ( g_fInVizAct2000 )
    {
        CDoc* pDoc = Doc();

        RRETURN( pDoc ? pDoc->SetErrorInfo(hr) : SetErrorInfo(hr) );
    }
    else
        RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_title, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_title(BSTR v)
{
    HRESULT hr;

    hr = THR(Markup()->EnsureTitle());
    if (hr)
        goto Cleanup;

    Assert(Markup()->GetTitleElement());

    hr = THR(Markup()->GetTitleElement()->SetTitle(v));

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_title, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_title(BSTR *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!Markup()->GetTitleElement() ||
        !Markup()->GetTitleElement()->_cstrTitle)
    {
        *p = SysAllocString(_T(""));
        if (!*p)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = THR(Markup()->GetTitleElement()->_cstrTitle.AllocBSTR(p));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Getbody
//
//  Synopsis:   Get the body interface for this form
//
//--------------------------------------------------------------------------
HRESULT
CDocument::get_body(IHTMLElement ** ppDisp)
{
    HRESULT         hr = S_OK;;
    CElement *      pElementClient;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDisp = NULL;

    pElementClient = Markup()->GetElementClient();

    if (pElementClient)
    {
        Assert(pElementClient->Tag() != ETAG_ROOT);

        hr = pElementClient->QueryInterface(IID_IHTMLElement, (void **) ppDisp);
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------
// Maximum length of a cookie string ( according to Netscape docs )
#define MAX_COOKIE_LENGTH 4096

HRESULT
CDocument::get_cookie(BSTR* retval)
{
    HRESULT  hr = S_OK;

    if (!retval)
    {
        hr = E_POINTER;
    }
    else
    {
        TCHAR achCookies[MAX_COOKIE_LENGTH + 1];
        DWORD dwCookieSize = ARRAY_SIZE(achCookies);

        memset(achCookies, 0,sizeof(achCookies));

        *retval = NULL;

        if (Markup()->GetCookie(CMarkup::GetUrl(Markup()), NULL, achCookies, &dwCookieSize))
        {
            if (dwCookieSize == 0) // We have no cookies
                achCookies[0] = _T('\0'); // So make the cookie string the empty str

            hr = FormsAllocString(achCookies, retval);
        }
        // else return S_OK and an empty string 
    }

    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------
HRESULT CDocument::put_cookie(BSTR cookie)
{
    if (cookie)
    {
        CMarkup * pMarkup = Markup();
        pMarkup->SetCookie(CMarkup::GetUrl(pMarkup), NULL, cookie);

        IGNORE_HR(OnPropertyChange(DISPID_CDocument_cookie,
                                   0,
                                   (PROPERTYDESC *)&s_propdescCDocumentcookie));
    }
    return S_OK;
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------
HRESULT CDocument::get_expando(VARIANT_BOOL *pfExpando)
{
    HRESULT hr = S_OK;

    if (pfExpando)
    {
        *pfExpando = GetWindowedMarkupContext()->_fExpando ? VB_TRUE : VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    RRETURN(SetErrorInfo(hr));
}


HRESULT CDocument::put_expando(VARIANT_BOOL fExpando)
{
    CMarkup *pMarkup = GetWindowedMarkupContext();

    if ((pMarkup->_fExpando ? VB_TRUE : VB_FALSE) != fExpando)
    {
        pMarkup->_fExpando = fExpando;
        Fire_PropertyChangeHelper(DISPID_CDocument_expando, 0, (PROPERTYDESC *)&s_propdescCDocumentexpando);
    }
    return SetErrorInfo(S_OK);
}

//+-------------------------------------------------------------------------
//
// Members:     Get/SetCharset
//
// Synopsis:    Functions to get at the document's charset from the object
//              model.
//
//--------------------------------------------------------------------------
HRESULT CDocument::get_charset(BSTR* retval)
{
    TCHAR   achCharset[MAX_MIMECSET_NAME];
    HRESULT hr;

    hr = THR(GetMlangStringFromCodePage(Markup()->GetCodePage(), achCharset,
                                        ARRAY_SIZE(achCharset)));
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(achCharset, retval);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//--------------------------------------------------------------------------
HRESULT
CDocument::put_charset(BSTR mlangIdStr)
{
    HRESULT hr;
    CODEPAGE cp;
    CDoc * pDoc = Doc();
    CMarkup *pMarkup = Markup();

    hr = THR(GetCodePageFromMlangString(mlangIdStr, &cp));
    if (hr)
        goto Cleanup;

    Assert(cp != CP_UNDEFINED);

    hr = THR(mlang().ValidateCodePage(g_cpDefault, cp, pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : NULL,
                                      FALSE, pDoc->_dwLoadf & DLCTL_SILENT));
    if (hr)
        goto Cleanup;

    // HACK: bug 110839: Outlook98 calls this method immediately after IPersist::Load.
    // They rely on the fact that we syncronously start load and the document
    // is the new one already (as in IE5.0)
    // So we emulate this behavior for them routing the call to pending markup.
    if (pDoc->_fOutlook98)
    {
        CWindow * pWindow = Window();

        if(pWindow && pWindow->_pMarkupPending)
            pMarkup = pWindow->_pMarkupPending;
    }

    hr = THR(pMarkup->SwitchCodePage(cp));
    if (hr)
        goto Cleanup;

    // Outlook98 calls put_charset and expects it not
    // to make us dirty.  They expect a switch from design
    // to browse mode to always reload from the original
    // source in this situation.  For them we make this routine
    // act just like IE4
    // Outlook2000 didn't fix this, so we have to hack around them still
    if (!pDoc->_fOutlook98 && !pDoc->_fOutlook2000)
    {
        //
        // Make sure we have a META tag that's in sync with the document codepage.
        //
        hr = THR(pMarkup->UpdateCodePageMetaTag(cp));
        if (hr)
            goto Cleanup;

        IGNORE_HR(OnPropertyChange(DISPID_CDocument_charset,
                                   0,
                                   (PROPERTYDESC *)&s_propdescCDocumentcharset));
    }

    //
    // Clear our caches and force a repaint since codepages can have
    // distinct fonts.
    //
    pMarkup->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
// Members:     Get/SetDefaultCharset
//
// Synopsis:    Functions to get at the thread's default charset from the
//              object model.
//
//--------------------------------------------------------------------------
HRESULT
CDocument::get_defaultCharset(BSTR* retval)
{
    TCHAR   achCharset[MAX_MIMECSET_NAME];
    HRESULT hr;

    hr = THR(GetMlangStringFromCodePage(Doc()->_pOptionSettings->codepageDefault,
                                        achCharset, ARRAY_SIZE(achCharset)));
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(achCharset, retval);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::put_defaultCharset(BSTR mlangIdStr)
{
#if NOT_YET

    // N.B. (johnv) This method will be exposed through the object model
    // but not through IDispatch in Beta2.  Commenting out until we can
    // do this, since this function may pose a security risk (a script
    // can make it impossible to view any subsequently browsed pages).

    HRESULT hr;
    CODEPAGE cp;

    hr = THR(GetCodePageFromMlangString(mlangIdStr, &cp));
    if (hr)
        goto Cleanup;

    if (cp != CP_UNDEFINED)
    {
        _pOptionSettings->codepageDefault = cp;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

#endif

    return S_OK;    // so enumerating through properties won't fail
}

//+---------------------------------------------------------------------------
//
//  Members:    Get/SetDir
//
//  Synopsis:   Functions to get at the document's direction from the object
//              model.
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_dir(BSTR * p)
{
    CElement * pHtmlElement;
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pHtmlElement = Markup()->GetHtmlElement();
    if (pHtmlElement != NULL)
    {
        hr = THR(pHtmlElement->get_dir(p));
    }
    else
    {
        hr = THR(s_propdescCDocumentdir.b.GetEnumStringProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::put_dir(BSTR v)
{
    CElement * pHtmlElement;
    HRESULT hr = S_OK;
    long eHTMLDir = htmlDirNotSet;
    CMarkup * pMarkup = Markup();

    Assert(pMarkup);

    pHtmlElement = pMarkup->GetHtmlElement();

    if (pHtmlElement != NULL)
    {
        hr = THR(pHtmlElement->put_dir(v));
        if (hr == S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_dir, 0, (PROPERTYDESC *)&s_propdescCDocumentdir);
    }
    else
    {
        hr = THR(s_propdescCDocumentdir.b.SetEnumStringProperty(v, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }

    hr = THR(s_enumdeschtmlDir.EnumFromString(v, &eHTMLDir));
    if (!hr)
        _eHTMLDocDirection = eHTMLDir;

    // send the property change message to the body. These depend upon
    // being in edit mode or not.
    CBodyElement * pBody;

    pMarkup->GetBodyElement(&pBody);
    if (pBody)
        pBody->OnPropertyChange(DISPID_A_DIR,
                                ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS,
                                (PROPERTYDESC *)&s_propdescCElementdir);

    RRETURN( SetErrorInfo(hr) );
}

//+---------------------------------------------------------------------------
//
// Helper Function: GetFileTypeInfo, called by get_mimeType
//
//----------------------------------------------------------------------------

BSTR
GetFileTypeInfo(TCHAR * pchFileName)
{
#if !defined(WIN16) && !defined(WINCE)
    SHFILEINFO sfi;

    if (pchFileName &&
            pchFileName[0] &&
            SHGetFileInfo(
                pchFileName,
                FILE_ATTRIBUTE_NORMAL,
                &sfi,
                sizeof(sfi),
                SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES))
    {
        return SysAllocString(sfi.szTypeName);
    }
    else
#endif //!WIN16 && !WINCE
    {
        return NULL;
    }
}

//+---------------------------------------------------------------------------
//
// Member: get_mimeType
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_mimeType(BSTR * pMimeType)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    *pMimeType = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr)
    {
        *pMimeType = GetFileTypeInfo(pchCachedFile);
    }

    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileSize
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileSize(BSTR * pFileSize)
{
    HRESULT hr = S_OK;
    TCHAR   szBuf[64];
    TCHAR * pchCachedFile = NULL;

    if (pFileSize == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileSize = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            Format(0, szBuf, ARRAY_SIZE(szBuf), _T("<0d>"), (long)wfd.nFileSizeLow);
            *pFileSize = SysAllocString(szBuf);
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileCreatedDate
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileCreatedDate(BSTR * pFileCreatedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileCreatedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileCreatedDate = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftCreationTime, pFileCreatedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileModifiedDate
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileModifiedDate(BSTR * pFileModifiedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileModifiedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileModifiedDate = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftLastWriteTime, pFileModifiedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

// TODO (lmollico): get_fileUpdatedDate won't work if src=file://htm
//+---------------------------------------------------------------------------
//
// Member: get_fileUpdatedDate
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileUpdatedDate(BSTR * pFileUpdatedDate)
{
    HRESULT   hr = S_OK;
    const TCHAR * pchUrl = CMarkup::GetUrl(Markup());

    * pFileUpdatedDate = NULL;

    if (pchUrl)
    {
        BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
        INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
        DWORD                       cInfo = sizeof(buf);

        if (RetrieveUrlCacheEntryFile(pchUrl, pInfo, &cInfo, 0))
        {
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(pInfo->LastModifiedTime, pFileUpdatedDate, FALSE));
            DoUnlockUrlCacheEntryFile(pchUrl, 0);
        }
    }

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_security
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_security(BSTR * pSecurity)
{
    HRESULT hr = S_OK;
    TCHAR   szBuf[2048];
    BOOL    fSuccess = FALSE;
    const TCHAR * pchUrl = CMarkup::GetUrl(Markup());

    if (pchUrl && (GetUrlScheme(pchUrl) == URL_SCHEME_HTTPS))
    {
        fSuccess = InternetGetCertByURL(pchUrl, szBuf, ARRAY_SIZE(szBuf));
    }

    if (!fSuccess)
    {
        LoadString(
                GetResourceHInst(),
                IDS_DEFAULT_DOC_SECURITY_PROP,
                szBuf,
                ARRAY_SIZE(szBuf));
    }

    *pSecurity = SysAllocString(szBuf);

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_protocol
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_protocol(BSTR * pProtocol)
{
    HRESULT   hr = S_OK;
    TCHAR   * pResult = NULL;

    pResult = ProtocolFriendlyName((TCHAR *) CMarkup::GetUrl(Markup()));

    if (pResult)
    {
        int z = (_tcsncmp(pResult, 4, _T("URL:"), -1) == 0) ? (4) : (0);
        *pProtocol = SysAllocString(pResult + z);
        SysFreeString(pResult);
    }
    else
    {
        *pProtocol = NULL;
    }
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_nameProp
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_nameProp(BSTR * pName)
{
    RRETURN(SetErrorInfo(get_title(pName)));
}

HRESULT
CDocument::toString(BSTR *pbstrString)
{
    RRETURN(super::toString(pbstrString));
}

HRESULT
CDocument::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    RRETURN(super::attachEvent(event, pDisp, pResult));
}

HRESULT
CDocument::detachEvent(BSTR event, IDispatch* pDisp)
{
    RRETURN(super::detachEvent(event, pDisp));
}

HRESULT
CDocument::recalc(VARIANT_BOOL fForce)
{
    // recalc across all markups for now
    RRETURN(SetErrorInfo(Doc()->_recalcHost.EngineRecalcAll(fForce)));
}

HRESULT CDocument::createTextNode(BSTR text, IHTMLDOMNode **ppTextNode)
{
    HRESULT             hr = S_OK;
    CMarkup *           pMarkup = NULL;
    CMarkupPointer *    pmkpPtr = NULL;
    long                lTextID;
    long                lLen = -1;
    CMarkupPointer      mkpEnd (Doc());

    if (!ppTextNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppTextNode = NULL;

    // Because Perf is not our primary concern right now, I'm going to create
    // a markup container to hold the text. If we had more time, I'd just store the string internaly
    // and special case access to the data in all the method calls
    hr = THR(Doc()->CreateMarkup(&pMarkup, Markup()->GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    pmkpPtr = new CMarkupPointer(Doc());
    if (!pmkpPtr)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pmkpPtr->MoveToContainer(pMarkup, TRUE));
    if (hr)
        goto Cleanup;

    pmkpPtr->SetGravity(POINTER_GRAVITY_Left);

    // Put the text in
    hr = THR(pmkpPtr->Doc()->InsertText(pmkpPtr, text, -1, MUS_DOMOPERATION));
    if (hr)
        goto Cleanup;

    // Position the end pointer to the extreme right of the text
    hr = THR(mkpEnd.MoveToPointer(pmkpPtr));
    if (hr)
        goto Cleanup;

    // Move right by the number of chars inserted
    hr = THR(mkpEnd.Right(TRUE, NULL, NULL, &lLen, NULL, &lTextID));
    if (hr)
        goto Cleanup;

    hr = THR(Doc()->CreateDOMTextNodeHelper(pmkpPtr, &mkpEnd, ppTextNode));
    if (hr)
        goto Cleanup;

    pmkpPtr = NULL; // Text Node now owns the pointer


Cleanup:
    ReleaseInterface((IUnknown*)(pMarkup)); // Text Node keeps the markup alive
    delete pmkpPtr;
    RRETURN(SetErrorInfo(hr));
}


HRESULT CDocument::get_documentElement(IHTMLElement **ppRootElem)
{
    HRESULT hr = S_OK;
    CElement *pRootElem = NULL;

    if (!ppRootElem)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppRootElem = NULL;

    pRootElem = Markup()->GetHtmlElement();
    if (pRootElem)
        hr = THR(pRootElem->QueryInterface(IID_IHTMLElement, (void **)ppRootElem));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDocument::get_all(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::ELEMENT_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_anchors(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::ANCHORS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_links(IHTMLElementCollection ** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::LINKS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_forms(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::FORMS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_applets(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::APPLETS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_images(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::IMAGES_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_scripts(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::SCRIPTS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_embeds( IHTMLElementCollection** ppDisp )
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::EMBEDS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_plugins(IHTMLElementCollection** ppDisp)
{
    // plugins is an alias for embeds
    RRETURN(get_embeds(ppDisp));
}


HRESULT
CDocument::get_uniqueID(BSTR *pID)
{
    HRESULT     hr;
    CStr        cstrUniqueID;

    hr = THR(Doc()->GetUniqueIdentifier(&cstrUniqueID));
    if (hr)
        goto Cleanup;

    hr = THR(cstrUniqueID.AllocBSTR(pID));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::createElement ( BSTR bstrTag, IHTMLElement ** pIElementNew )
{
    HRESULT hr = S_OK;
    CElement * pElement = NULL;

    if (!bstrTag || !pIElementNew)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(Markup()->CreateElement(
            ETAG_NULL, & pElement, bstrTag, SysStringLen(bstrTag)));
    if (hr)
        goto Cleanup;

    hr = THR(pElement->QueryInterface( IID_IHTMLElement, (void **) pIElementNew));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pElement)
        pElement->Release();

    RRETURN( hr );
}


HRESULT
CDocument::createStyleSheet ( BSTR bstrHref /*=""*/, long lIndex/*=-1*/, IHTMLStyleSheet ** ppnewStyleSheet )
{
    HRESULT         hr = S_OK;
    CElement      * pElementNew = NULL;
    CStyleSheet   * pStyleSheet;
    BOOL            fIsLinkElement;
    CStyleSheetArray * pStyleSheets;
    CMarkup       * pMarkup = Markup();

    if (!ppnewStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert(pMarkup);

    if (!pMarkup->GetHeadElement())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppnewStyleSheet = NULL;

    // If there's an HREF, we create a LINK element, otherwise it's a STYLE element.

    fIsLinkElement = (bstrHref && *bstrHref);

    hr = THR(pMarkup->CreateElement(
            (fIsLinkElement) ? ETAG_LINK : ETAG_STYLE, & pElementNew));

    if (hr)
        goto Cleanup;

    hr = pMarkup->EnsureStyleSheets();
    if (hr)
        goto Cleanup;

    Assert(pMarkup->HasStyleSheetArray());
    pStyleSheets = pMarkup->GetStyleSheetArray();

    if ( lIndex < -1 || lIndex >= pStyleSheets->Size() )
        lIndex = -1;    // Just append to the end if input is outside the bounds

    Assert( "Must have a root site!" && pMarkup->Root() );

    // Fix up the index - incoming index is index in stylesheets list, but param to
    // AddHeadElement is index in ALL head elements.  There may be META or TITLE, etc.
    // tags mixed in.
    if (lIndex > 0)
    {
        long nHeadNodes;
        long i;
        long nSSInHead;
        CTreeNode *pNode;
        CLinkElement *pLink;
        CStyleElement *pStyle;

        CChildIterator ci((CElement *)pMarkup->GetHeadElement(), NULL, CHILDITERATOR_DEEP);

        for ( nHeadNodes = 0 ; ci.NextChild() ; )
            nHeadNodes++;

        ci.SetBeforeBegin();

        nSSInHead = 0;

        for ( i = 0 ; (pNode = ci.NextChild()) != NULL ; i++ )
        {
            if ( pNode->Tag() == ETAG_LINK )
            {
                pLink = DYNCAST( CLinkElement, pNode->Element() );
                if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                    ++nSSInHead;
            }
            else if ( pNode->Tag() == ETAG_STYLE )
            {
                pStyle = DYNCAST( CStyleElement, pNode->Element() );
                if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                    ++nSSInHead;
            }
            if ( nSSInHead == lIndex )
            {           // We've found the stylesheet that should immediately precede us - we'll
                i++;    // add our new ss at the next head index.
                break;
            }
        }
        if ( i == nHeadNodes )   // We'll be at the end anyway.
            lIndex = -1;
        else
            lIndex = i;         // Here's the new index, adjusted for other HEAD elements.
    }

    // Go ahead and add it to the head.
    //--------------------------------
    //   For style elements we need to set _fParseFinished to FALSE so that the style sheet
    // is not automatically created when we insert the style element into the tree from here.
    // We will create and insert the styleSheet into the proper position of the collection later.
    //   When the element is inserted through DOM we want to have a stylesheet so we set
    // _fParseFinished to TRUE (we are not going to parse anything in that case)
    if(!fIsLinkElement)
    {
        DYNCAST( CStyleElement, pElementNew)->_fParseFinished = FALSE;
    }

    hr = THR(pMarkup->AddHeadElement( pElementNew, lIndex ));
    if (hr)
        goto Cleanup;

    // We MUST put the element in the HEAD (the AddHeadElement() above) before we do the element-specific
    // stuff below, because the element will try to find itself in the head in CLinkElement::OnPropertyChange()
    // or CStyleElement::EnsureStyleSheet().
    if ( fIsLinkElement )
    {   // It's a LINK element - DYNCAST it and grab the CStyleSheet.
        CLinkElement *pLink = DYNCAST( CLinkElement, pElementNew );
        pLink->put_StringHelper( _T("stylesheet"), (PROPERTYDESC *)&s_propdescCLinkElementrel );
        pLink->put_UrlHelper( bstrHref, (PROPERTYDESC *)&s_propdescCLinkElementhref );
        pStyleSheet = pLink->_pStyleSheet;
    }
    else
    {   // It's a STYLE element - this will make sure we create a stylesheet attached to the CStyleElement.
        CStyleElement *pStyle = DYNCAST( CStyleElement, pElementNew );
        hr = THR( pStyle->EnsureStyleSheet() );
        if (hr)
            goto Cleanup;
        pStyleSheet = pStyle->_pStyleSheet;
    }

    if ( !pStyleSheet )
        hr = E_OUTOFMEMORY;
    else
        hr = THR( pStyleSheet->QueryInterface ( IID_IHTMLStyleSheet, (void **)ppnewStyleSheet ) );

Cleanup:
    CElement::ClearPtr(&pElementNew);
    RRETURN(SetErrorInfo(hr));
}


HTC
CDocument::HitTestPoint(CMessage *pMsg, CTreeNode **ppNode, DWORD dwFlags)
{
    // NOTE:  This function assumes that the point is in COORDSYS_SCROLL coordinates when
    //        passed in.

    CLayout *   pLayout;
    CElement *  pRoot   = Markup()->Root();
    CElement *  pElemMaster;

    Assert(pRoot);

    if (!pRoot->IsInViewTree())
        return HTC_NO;

    // If this isn't the primary document, transform to the global coordinate system.
    if (pRoot->HasMasterPtr())
    {
        pElemMaster = pRoot->GetMasterPtr();

        if (S_OK != pElemMaster->EnsureRecalcNotify())
            return HTC_NO;

        pLayout = pElemMaster->GetUpdatedLayout();
        Assert(pLayout);

        pLayout->TransformPoint(&pMsg->pt, COORDSYS_SCROLL, COORDSYS_GLOBAL);
    }

    return Doc()->HitTestPoint(pMsg, ppNode, HT_VIRTUALHITTEST);
}

HRESULT
CDocument::elementFromPoint(long x, long y, IHTMLElement **ppElement)
{
    HRESULT    hr = S_OK;
    CTreeNode *pNode = NULL;
    HTC        htc;
    CMessage   msg;

    if (!ppElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *ppElement = NULL;

    x = g_uiDisplay.DeviceFromDocPixelsX(x);
    y = g_uiDisplay.DeviceFromDocPixelsY(y);

    msg.pt = CPoint(x,y);
    htc = HitTestPoint(&msg, &pNode, HT_VIRTUALHITTEST);

    if (htc != HTC_NO)
    {
        if (pNode->Tag() == ETAG_IMG)
        {
            // did we hit an area?
            pNode->Element()->SubDivisionFromPt(msg.ptContent, &msg.lSubDivision);
            if (msg.lSubDivision >=0)
            {
                // hit was on an area in an img, return the area.
                CAreaElement * pArea = NULL;
                CImgElement  * pImg = DYNCAST(CImgElement, pNode->Element());

                Assert(pImg->GetMap());

                // if we can get a node for the area, then return it
                // otherwise default back to returning the element.
                pImg->GetMap()->GetAreaContaining(msg.lSubDivision, &pArea);
                if (pArea)
                {
                    pNode = pArea->GetFirstBranch();
                    Assert(pNode);
                }
            }
        }

        if (pNode->GetMarkup() != Markup())
        {
            // get a node that contains the hit node and lives in this markup
            pNode = pNode->GetNodeInMarkup(Markup());

            if (!pNode)
            {
                // No element at the given point in the given document
                hr = S_OK;
                goto Cleanup;
            }

            Assert(pNode->GetMarkup() == Markup());
        }

        hr = THR( pNode->GetElementInterface( IID_IHTMLElement, (void **) ppElement ) );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     execCommand
//
//  Synopsis:   Executes given command
//
//  Returns:
//----------------------------------------------------------------------------
HRESULT
CDocument::execCommand(BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT value, VARIANT_BOOL *pfRet)
{
    HRESULT hr;
    CDoc * pDoc = Doc();
    CDoc::CLock Lock(pDoc, FORMLOCK_QSEXECCMD);
    BOOL fAllow;

    hr = THR(Markup()->AllowClipboardAccess(bstrCmdId, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;           // Fail silently

    hr = THR(super::execCommand(bstrCmdId, showUI, value));

    if (pfRet)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------
HRESULT
CDocument::execCommandShowHelp(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT hr;

    hr = THR(super::execCommandShowHelp(bstrCmdId));

    if (pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandSupported(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandSupported(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandEnabled(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandEnabled(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandState(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandState(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandIndeterm(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandIndeterm(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandText(BSTR bstrCmdId, BSTR *pcmdText)
{
    RRETURN(super::queryCommandText(bstrCmdId, pcmdText));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandValue(BSTR bstrCmdId, VARIANT *pvarRet)
{
    RRETURN(super::queryCommandValue(bstrCmdId, pvarRet));
}

HRESULT
CDocument::createDocumentFragment(IHTMLDocument2 **ppNewDoc)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkupContext;
    CMarkup *pMarkup = NULL;
    CDocument *pDocument = NULL;
    CDoc *pDoc = Doc();

    if ( !ppNewDoc )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppNewDoc = NULL;
    pMarkupContext = GetWindowedMarkupContext();

    hr = THR(pDoc->CreateMarkup(&pMarkup, pMarkupContext));
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    hr = THR(pMarkup->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    pDocument->_lnodeType = 11;

    hr = THR(pDocument->QueryInterface(IID_IHTMLDocument2, (void **)ppNewDoc));
    if (hr)
        goto Cleanup;

Cleanup:

    if(pMarkup)
        pMarkup->Release();
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_parentDocument(IHTMLDocument2 **ppParentDoc)
{
    // root doc!
    if (ppParentDoc)
        *ppParentDoc = NULL;

    return S_OK;
}

HRESULT
CDocument::get_enableDownload(VARIANT_BOOL *pfDownload)
{
/*
    // TODO: Revisit in IE6
    if (pfDownload)
        *pfDownload = _fEnableDownload ? VARIANT_TRUE : VARIANT_FALSE;
*/
    if (pfDownload)
        *pfDownload = VARIANT_FALSE;

    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::put_enableDownload(VARIANT_BOOL fDownload)
{
/*
    // TODO: Revisit in IE6
    _fEnableDownload = !!fDownload;
*/
    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::get_baseUrl(BSTR *p)
{
    if ( p )
        *p = NULL;

    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::put_baseUrl(BSTR b)
{
    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::get_inheritStyleSheets(VARIANT_BOOL *pfInherit)
{
    if ( pfInherit )
        *pfInherit = NULL;

    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::put_inheritStyleSheets(VARIANT_BOOL fInherit)
{
    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::getElementsByName(BSTR v, IHTMLElementCollection** ppDisp)
{
    HRESULT hr = E_INVALIDARG;

    if (!ppDisp || !v)
        goto Cleanup;

    *ppDisp = NULL;

    hr = THR(Markup()->GetDispByNameOrID(v, (IDispatch **)ppDisp, TRUE));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::getElementsByTagName(BSTR v, IHTMLElementCollection** ppDisp)
{
    HRESULT hr = E_INVALIDARG;
    if (!ppDisp || !v)
        goto Cleanup;

    *ppDisp = NULL;

    // Make sure our collection is up-to-date.
    hr = THR(Markup()->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // Check for '*' which means return the 'all' collection
    if ( !StrCmpIC(_T("*"), v) )
    {
        hr = THR(Markup()->CollectionCache()->GetDisp(
                    CMarkup::ELEMENT_COLLECTION,
                    (IDispatch**)ppDisp));
    }
    else
    {
        // Get a collection of the specified tags.
        hr = THR(Markup()->CollectionCache()->GetDisp(
                    CMarkup::ELEMENT_COLLECTION,
                    v,
                    CacheType_Tag,
                    (IDispatch**)ppDisp,
                    FALSE)); // Case sensitivity ignored for TagName
    }

    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::getElementById(BSTR v, IHTMLElement** ppel)
{
    HRESULT hr = E_INVALIDARG;
    CElement *pel = NULL;

    if (!ppel || !v)
        goto Cleanup;

    *ppel = NULL;

    hr = THR(Markup()->GetElementByNameOrID(v, &pel));
    // Didn't find elem with id v, return null, if hr == S_FALSE, more than one elem, return first
    if (FAILED(hr))
    {
        hr = S_OK;
        goto Cleanup;
    }

    Assert(pel);
    hr = THR(pel->QueryInterface(IID_IHTMLElement, (void **)ppel));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CDocument::hasFocus(VARIANT_BOOL * pfFocus)
{
    CDoc *  pDoc = Doc();
    HRESULT hr;

    if (!pfFocus)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pfFocus = VB_FALSE;
    Assert(pDoc);

    if (pDoc->HasFocus() && pDoc->State() >= OS_UIACTIVE)
    {
        // check if we are the foreground window
        HWND hwndFG = ::GetForegroundWindow();
        HWND hwndDoc = pDoc->_pInPlace->_hwnd;

        Assert(hwndDoc);
        if (hwndFG == hwndDoc || ::IsChild(hwndFG, hwndDoc))
        {
            *pfFocus = VB_TRUE;
        }
    }
    hr = S_OK;
Cleanup:
    RRETURN(SetErrorInfo(hr));
}


STDMETHODIMP
CDocument::focus()
{
    CDoc *  pDoc = Doc();

    Assert(pDoc && pDoc->_pElemCurrent);
    if (pDoc->State() >= OS_UIACTIVE)
    {
        if (!pDoc->HasFocus())
        {
            pDoc->TakeFocus();
        }
    }
    else
    {
        IGNORE_HR(pDoc->_pElemCurrent->BecomeUIActive());
    }
    if (pDoc->State() >= OS_UIACTIVE && pDoc->HasFocus())
    {
        // Make this the foreground window
        HWND hwndFG = ::GetForegroundWindow();
        HWND hwndDoc = pDoc->_pInPlace->_hwnd;
        HWND hwndTop = hwndDoc;

        if (hwndFG != hwndDoc && !::IsChild(hwndFG, hwndDoc))
        {

            // get top level window
            while ((hwndDoc = ::GetParent(hwndDoc)) != NULL)
            {
                hwndTop = hwndDoc;
            }
            ::SetForegroundWindow(hwndTop);
        }
    }

    // This assert could fail because script set focus elsewhere
    // explicitly during ui-activation. When I hit that failure, I will remove this
    // assert.
    Assert(!pDoc->_pInPlace || pDoc->_pInPlace->_fDeactivating || pDoc->HasFocus());
    RRETURN(S_OK);
}


STDMETHODIMP
CDocument::createDocumentFromUrl(BSTR bstrUrl, BSTR bstrOptions, IHTMLDocument2** ppDocumentNew)
{
    return createDocumentFromUrlInternal(bstrUrl, bstrOptions, ppDocumentNew, 0);
}

HRESULT
CDocument::createDocumentFromUrlInternal(BSTR bstrUrl, BSTR bstrOptions, IHTMLDocument2** ppDocumentNew, DWORD dwFlagsInternal /*=0*/)
{
    HRESULT             hr                  = S_OK;
    TCHAR *             pchUrl              = bstrUrl;
    DWORD               dwBindf             = 0;
    TCHAR               cBuf[pdlUrlLen];
    TCHAR *             pchExpandedUrl      = cBuf;
    COmWindowProxy *    pWindow             = NULL;
    CDoc *              pDoc                = Doc();
    CDwnDoc *           pDwnDoc;
    CMarkup *           pMarkup             = Markup();
    DWORD               dwFlags             = CDoc::FHL_CREATEDOCUMENTFROMURL;

    if (!ppDocumentNew)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDocumentNew = NULL;

    cBuf[0] = _T('\0');

    if (!pchUrl || !*pchUrl)
        goto Cleanup;

    CMarkup::ExpandUrl(pMarkup, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, NULL);

    if (pMarkup->IsUrlRecursive(pchExpandedUrl))
        goto Cleanup;

    pDwnDoc = pMarkup->GetDwnDoc();
    if (pDwnDoc)
    {
        dwBindf = pDwnDoc->GetBindf();
    }

    // Parse the options to look for directives.
    if (bstrOptions)
    {
        CDataListEnumerator   dleOptions(bstrOptions, _T(' '));
        LPCTSTR pch = NULL; // keep compiler happy
        INT     cch = 0;    // keep compiler happy

        while (dleOptions.GetNext(&pch, &cch))
        {
            switch (cch)
            {
                case 5:
                    if ( !_tcsnicmp(pch, cch, L"print", cch) )  // 'Cuz there is no _wcsnicmp - and _tcsnicmp is hardwired wide.
                    {
                        if (    !!(dwFlagsInternal & CDFU_DONTVERIFYPRINT)
                            ||  pMarkup->IsPrintTemplate())
                        {
                            dwFlags |= CDoc::FHL_SETTARGETPRINTMEDIA;
                        }
                        else
                        {
                            hr = E_ACCESSDENIED;
                            goto Cleanup;
                        }
                    }
                    break;
            }
        }
    }

    hr = THR(pDoc->FollowHyperlink(
            pchExpandedUrl,
            NULL,               // pchTarget
            NULL,               // pElementContext
            NULL,               // pDwnPost
            FALSE,              // fSendAsPost
            NULL,               // pchExtraHeaders
            TRUE,               // fOpenInNewWindow
            pMarkup->GetFrameOrPrimaryMarkup()->Window(),  // pWindow - pass our OM window ("this" == the OM document)
            &pWindow,           // ppWindowOut
            dwBindf,            // dwBindf
            ERROR_SUCCESS,      // dwSecurityCode
            FALSE,              // fReplace
            NULL,               // ppHTMLWindow2
            FALSE,              // fOpenInNewBrowser
            dwFlags             // dwFlags
            ));

    if (pWindow)
    {
        Assert(pWindow->Document() && pWindow->Window()->_pMarkup);
        IGNORE_HR( pWindow->Window()->_pMarkup->SetOrphanedMarkup( TRUE ) );
        hr = pWindow->Document()->QueryInterface(IID_IHTMLDocument2, (void**)ppDocumentNew);
    }

Cleanup:
    if (pWindow)
    {
        pWindow->Release();
    }

    RRETURN(SetErrorInfo(hr));
}



STDMETHODIMP
CDocument::createEventObject(VARIANT *pvarEventObject, IHTMLEventObj** ppEventObj)
{
    CDoc *  pDoc = Doc();

    EVENTPARAM *pParam = NULL;
    HRESULT hr;

    if (!ppEventObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // if event object passed in, copy it, else create new one on heap and init it.
    if (pvarEventObject && V_VT(pvarEventObject) == VT_DISPATCH)
    {
        CEventObj *pSrcEventObj;

        hr = THR(V_DISPATCH(pvarEventObject)->QueryInterface(CLSID_CEventObj, (void **)&pSrcEventObj));
        if (hr)
            goto Cleanup;

        pSrcEventObj->GetParam(&pParam);
        if (!pParam)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }

    hr = THR(CEventObj::Create(ppEventObj, pDoc, NULL, Markup(), FALSE, NULL, pParam));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  CFramesCoolection
//
//--------------------------------------------------------------------------

const CBase::CLASSDESC CFramesCollection::s_classdesc =
{
    &CLSID_FramesCollection,        // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFramesCollection2,    // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CFramesCollection::CFramesCollection(CDocument * pDocument)
    : _pDocument(pDocument)
{
    Assert(_pDocument);
    _pDocument->SubAddRef();
}

void
CFramesCollection::Passivate()
{
    Assert(_pDocument);
    _pDocument->SubRelease();
    _pDocument = NULL;
    super::Passivate();
}

STDMETHODIMP
CFramesCollection::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLFramesCollection2)
    }
    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

STDMETHODIMP
CFramesCollection::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    RRETURN (SetErrorInfo(_pDocument->item(pvarArg1, pvarRes)));
}

STDMETHODIMP
CFramesCollection::get_length(long * pcFrames)
{
    RRETURN (SetErrorInfo(_pDocument->get_length(pcFrames)));
}

//+-------------------------------------------------------------------------
//
//  CScreen - implementation for the window.screen object
//
//--------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CScreen, CWindow, _Screen)

const CBase::CLASSDESC CScreen::s_classdesc =
{
    &CLSID_HTMLScreen,              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLScreen,               // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+-------------------------------------------------------------------------
//
//  CScreen:: property members
//
//--------------------------------------------------------------------------

STDMETHODIMP CScreen::get_colorDepth(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    long d = MyCWindow()->Doc()->_bufferDepth;
    if (d > 0)
        *p = d;
    else
    {
        // TODO: If code can run during printing, we should figure out
        // how to get to the color depth of the printer.
        // If not, we could add BITSPIXEL as a TLS cached item.
        *p = GetDeviceCaps(TLS(hdcDesktop), BITSPIXEL);
    }
    return S_OK;
}

STDMETHODIMP CScreen::get_logicalXDPI(long *plXDPI)
{   
    const SIZE size = g_uiDisplay.GetDocPixelsPerInch();

    if (!plXDPI)
        return E_INVALIDARG;

    *plXDPI = size.cx;

    return S_OK;
}

STDMETHODIMP CScreen::get_logicalYDPI(long *plYDPI)
{
    const SIZE size = g_uiDisplay.GetDocPixelsPerInch();

    if (!plYDPI)
        return E_INVALIDARG;

    *plYDPI = size.cy;

    return S_OK;
}

STDMETHODIMP CScreen::get_deviceXDPI(long *plXDPI)
{
    const SIZE size = g_uiDisplay.GetResolution();

    if (!plXDPI)
        return E_INVALIDARG;

    *plXDPI = size.cx;

    return S_OK;
}

STDMETHODIMP CScreen::get_deviceYDPI(long *plYDPI)
{
    const SIZE size = g_uiDisplay.GetResolution();
    
    if (!plYDPI)
        return E_INVALIDARG;

    *plYDPI = size.cy;

    return S_OK;
}

STDMETHODIMP CScreen::put_bufferDepth(long v)
{
    switch (v)
    {
    case 0:                     // 0 means no explicit buffering requested
    case -1:                    // -1 means buffer at screen depth
    case 1:                     // other values are specific buffer depths...
    case 4:
    case 8:
    case 16:
    case 24:
    case 32:
        break;
    default:
        v = -1;                 // for unknown values, use screen depth
        break;
    }

    CDoc *pDoc = MyCWindow()->Doc();
    if (pDoc->_bufferDepth != v)
    {
        pDoc->_bufferDepth = v;
        pDoc->Invalidate();
    }
    return S_OK;
}

STDMETHODIMP CScreen::get_bufferDepth(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    *p = MyCWindow()->Doc()->_bufferDepth;
    return S_OK;
}

STDMETHODIMP CScreen::get_width(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    // TODO: Implement the printer case.
    *p = g_uiDisplay.DocPixelsFromDeviceX(GetDeviceCaps(TLS(hdcDesktop), HORZRES));
    return S_OK;
}

STDMETHODIMP CScreen::get_height(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    // TODO: Implement the printer case.
    *p = g_uiDisplay.DocPixelsFromDeviceY(GetDeviceCaps(TLS(hdcDesktop), VERTRES));
    return S_OK;
}

//----------------------------------------------------------------------------
//  Member: put_updateInterval
//
//  Synopsis:   updateInterval specifies the interval between painting invalid
//              regions. This is used for throttling mutliple objects randomly
//              invalidating regions to a specific update time.
//              interval specifies milliseconds.
//----------------------------------------------------------------------------
STDMETHODIMP CScreen::put_updateInterval(long interval)
{
    MyCWindow()->Doc()->UpdateInterval( interval );
    return S_OK;
}

STDMETHODIMP CScreen::get_updateInterval(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    *p = MyCWindow()->Doc()->GetUpdateInterval();
    return S_OK;
}

STDMETHODIMP CScreen::get_availHeight(long*p)
{
    HRESULT hr = S_OK;
    RECT    Rect;
    BOOL    fRes;

    if(p == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = 0;

    // BUGWIN16 replace with GetSystemMetrics on Win16
    fRes = ::SystemParametersInfo(SPI_GETWORKAREA, 0, &Rect, 0);
    if(!fRes)
    {
        hr = HRESULT_FROM_WIN32(GetLastWin32Error());
        goto Cleanup;
    }

    *p = Rect.bottom - Rect.top;
    *p = g_uiDisplay.DocPixelsFromDeviceY(*p);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CScreen::get_availWidth(long*p)
{
    HRESULT hr = S_OK;
    RECT    Rect;
    BOOL    fRes;

    if(p == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = 0;

    // BUGWIN16 replace with GetSystemMetrics on Win16
    fRes = ::SystemParametersInfo(SPI_GETWORKAREA, 0, &Rect, 0);
    if(!fRes)
    {
        hr = HRESULT_FROM_WIN32(GetLastWin32Error());
        goto Cleanup;
    }

    *p = Rect.right - Rect.left;
    *p = g_uiDisplay.DocPixelsFromDeviceX(*p);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CScreen::get_fontSmoothingEnabled(VARIANT_BOOL*p)
{
    HRESULT hr = S_OK;
    BOOL    fSmoothing;
    BOOL    fRes;

    if(p == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = VB_FALSE;

    // BUGWIN16 replace with GetSystemMetrics on Win16
    fRes = ::SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &fSmoothing, 0);
    if(!fRes)
    {
        hr = HRESULT_FROM_WIN32(GetLastWin32Error());
        goto Cleanup;
    }

    if(fSmoothing)
        *p = VB_TRUE;

Cleanup:
    RRETURN(hr);
}
//+-------------------------------------------------------------------------
//
//  Method:     CScreen::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
CScreen::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;

    switch (iid.Data1)
    {
     QI_INHERITS(this, IUnknown)
     QI_TEAROFF2(this, IDispatch, IHTMLScreen, NULL)
     QI_TEAROFF(this, IHTMLScreen, NULL)
     QI_TEAROFF(this, IHTMLScreen2, NULL)
     QI_TEAROFF(this, IObjectIdentity, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        HRESULT hr;
        
        if (DispNonDualDIID(iid))
        {
            hr = THR( CreateTearOffThunk(this, (void *)s_apfnIHTMLScreen, NULL, ppv) );
        }
        else
        {
            hr = E_NOINTERFACE;
        }

        RRETURN(hr);
    }
}

HRESULT CScreen::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    return QueryInterface(iid, ppv);
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_offscreenBuffering
//
//  Synopsis :  Set whether we paint using offscreen buffering
//
//----------------------------------------------------------------------------
HRESULT
CWindow::put_offscreenBuffering(VARIANT var)
{
    HRESULT     hr;
    CVariant    varTemp;

    hr = varTemp.CoerceVariantArg( &var, VT_BOOL );
    if ( DISP_E_TYPEMISMATCH == hr )
    {
        // handle Nav 4 compat where "" is the same as FALSE
        // and anything in a string is considered TRUE
        if ( VT_BSTR == V_VT(&var) )
        {
            V_VT(&varTemp) = VT_BOOL;
            hr = S_OK;
            if ( 0 == SysStringByteLen(V_BSTR(&var)) )
                V_BOOL(&varTemp) = VB_FALSE;
            else
                V_BOOL(&varTemp) = VB_TRUE;
        }
    }
    if ( SUCCEEDED(hr) )
    {
        Doc()->SetOffscreenBuffering(BOOL_FROM_VARIANT_BOOL(V_BOOL(&varTemp)));
    }
    return SetErrorInfo(hr);
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_offscreenBuffering
//
//  Synopsis :  Return string/bool of tristate: auto, true, or false
//
//----------------------------------------------------------------------------
HRESULT
CWindow::get_offscreenBuffering(VARIANT *pvar)
{
    HRESULT hr = S_OK;
    int buffering;      // -1 = auto, 0=false, 1=true

    if (!pvar)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    buffering = Doc()->GetOffscreenBuffering();
    if ( buffering < 0 )
    {
        V_VT(pvar) = VT_BSTR;
        hr = THR(FormsAllocString ( _T("auto"), &V_BSTR(pvar)));
    }
    else
    {
        V_VT(pvar) = VT_BOOL;
        V_BOOL(pvar) = VARIANT_BOOL_FROM_BOOL(!!buffering);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     CWindow::get_external
//
//  Synopsis:   Get IDispatch object associated with the IDocHostUIHandler
//
//---------------------------------------------------------------------------
HRESULT
CWindow::get_external(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDisp = NULL;

    if (Doc()->_pHostUIHandler)
    {
        hr = Doc()->_pHostUIHandler->GetExternal(ppDisp);
            if (hr == E_NOINTERFACE)
            {
                hr = S_OK;
                Assert(*ppDisp == NULL);
            }
            else if (hr)
                goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

CAtomTable *
CWindow::GetAtomTable (BOOL *pfExpando)
{
    if (pfExpando)
    {
        *pfExpando = Markup()->_fExpando;
    }

    return &(Doc()->_AtomTable);
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_clipboardData
//
//  Synopsis :  Return the data transfer object.
//
//----------------------------------------------------------------------------
HRESULT
CWindow::get_clipboardData(IHTMLDataTransfer **ppDataTransfer)
{
    HRESULT hr = S_OK;
    CDataTransfer * pDataTransfer;
    IDataObject * pDataObj = NULL;

    if (!ppDataTransfer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDataTransfer = NULL;

    hr = THR(OleGetClipboard(&pDataObj));
    if (hr)
        goto Cleanup;

    pDataTransfer = new CDataTransfer(this, pDataObj, FALSE);  // fDragDrop = FALSE

    pDataObj->Release();    // extra addref from OleGetClipboard

    if (!pDataTransfer)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pDataTransfer->QueryInterface(
                IID_IHTMLDataTransfer,
                (void **) ppDataTransfer));
        pDataTransfer->Release();
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//---------------------------------------------------------------------------
//
//  CDataTransfer ClassDesc
//
//---------------------------------------------------------------------------

const CBase::CLASSDESC CDataTransfer::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDataTransfer,             // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};



//---------------------------------------------------------------------------
//
//  Member:     CDataTransfer::CDataTransfer
//
//  Synopsis:   ctor
//
//---------------------------------------------------------------------------

CDataTransfer::CDataTransfer(CWindow * pWindow, IDataObject * pDataObj, BOOL fDragDrop)
{
    _pWindow = pWindow;
    _pWindow->SubAddRef();
    _pDataObj = pDataObj;
    _pDataObj->AddRef();
    _fDragDrop = fDragDrop;
}


//---------------------------------------------------------------------------
//
//  Member:     CDataTransfer::~CDataTransfer
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------------------

CDataTransfer::~CDataTransfer()
{
    _pWindow->SubRelease();
    _pDataObj->Release();
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataTransfer::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
CDataTransfer::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTMLDataTransfer, NULL)
    QI_TEAROFF2(this, IUnknown, IHTMLDataTransfer, NULL)
    QI_TEAROFF(this, IServiceProvider, NULL)
    default:
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataTransfer::QueryService
//
//  Synopsis:   Per IServiceProvider
//
//--------------------------------------------------------------------------

HRESULT
CDataTransfer::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT hr;

    if (    IsEqualGUID(rguidService, IID_IDataObject)
        &&  IsEqualGUID(riid,         IID_IDataObject))
    {
        IDataObject * pDataObj = NULL;

        if (_fDragDrop)
        {
            *ppvService = _pDataObj;
        }
        else
        {
            IDataObject * pDataTLS = TLS(pDataClip);

            // TODO (jbeda) There are slight problems with keeping
            // this data on the TLS since the CGenDataObject holds
            // onto the doc. 1) Strangeness if more than one doc is in
            // play 2) The doc could go away but the CGenDataObject is
            // still on the clipboard.  This should really be on the doc
            // and flushed during the CDoc's passivate.

            if (pDataTLS)
            {
                *ppvService = pDataTLS;
            }
            else
            {
                pDataObj = new CGenDataObject(_pWindow->Doc());
                if (pDataObj == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                _pWindow->SetClipboard(pDataObj);

                *ppvService = pDataObj;
            }
        }

        ((IUnknown*)(*ppvService))->AddRef();
        if (pDataObj)
            pDataObj->Release();

        hr = S_OK;
    }
    else
    {
        *ppvService = NULL;
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}



static HRESULT copyBstrToHglobal(BOOL fAnsi, BSTR bstr, HGLOBAL *phglobal)
{
    HRESULT hr      = S_OK;
    void *  pvText;
    DWORD   cbSize;
    DWORD   cch     = FormsStringLen(bstr) + 1;

    Assert(phglobal);

    if (fAnsi)
    {
        cbSize = WideCharToMultiByte(CP_ACP, 0, bstr, cch, NULL, 0, NULL, NULL);
        if (!cbSize)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else // unicode
    {
        cbSize = cch * sizeof(TCHAR);
    }
    *phglobal = GlobalAlloc(GMEM_MOVEABLE, cbSize);
    if (!*phglobal)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pvText = GlobalLock(*phglobal);
    if (!pvText)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if (fAnsi)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, bstr, cch, (char*)pvText, cbSize, NULL, NULL))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        memcpy((TCHAR *)pvText, bstr, cbSize);
    }
    GlobalUnlock(*phglobal);

Cleanup:
    RRETURN(hr);
Error:
    if (*phglobal)
        GlobalFree(*phglobal);
    *phglobal = NULL;
    goto Cleanup;
}

HRESULT
CDataTransfer::setData(BSTR format, VARIANT* data, VARIANT_BOOL* pret)
{
    HRESULT hr = S_OK;
    STGMEDIUM stgmed = {0, NULL};
    FORMATETC fmtc;
    TCHAR * pchData = NULL;
    VARIANT *pvarData;
    EVENTPARAM * pparam;
    IDataObject * pDataObj = NULL;
    BOOL fCutCopy = TRUE;
    BOOL fAddRef = TRUE;
    CDragStartInfo * pDragStartInfo = _pWindow->Doc()->_pDragStartInfo;
    IUniformResourceLocator * pUrlToDrag = NULL;

    if (!_fDragDrop)    // access to window.clipboardData.setData
    {
        BOOL fAllow;
        hr = THR(_pWindow->Markup()->ProcessURLAction(URLACTION_SCRIPT_PASTE, &fAllow));
        if (hr || !fAllow)
            goto Error;       // Fail silently
    }

    pparam = _pWindow->Doc()->_pparam;

    if (pparam)
    {
        LPCTSTR pchType = pparam->GetType();
        fCutCopy = pchType && (!StrCmpIC(_T("cut"), pchType) || !StrCmpIC(_T("copy"), pchType));
    }

    if (_fDragDrop && pDragStartInfo)
        pDataObj = _pDataObj;
    else
    {
        IDataObject * pDataTLS = TLS(pDataClip);

        // TODO (jbeda) There are slight problems with keeping
        // this data on the TLS since the CGenDataObject holds
        // onto the doc. 1) Strangeness if more than one doc is in
        // play 2) The doc could go away but the CGenDataObject is
        // still on the clipboard.  This should really be on the doc
        // and flushed during the CDoc's passivate.

        fCutCopy = TRUE;
        if (pDataTLS)
            pDataObj = pDataTLS;
        else
        {
            pDataObj = new CGenDataObject(_pWindow->Doc());
            if (pDataObj == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
            fAddRef = FALSE;
        }
    }

    if (!pDataObj)
    {
        AssertSz(FALSE, "The pDataObj pointer is NULL. We need to understand this scenario. Contact:FerhanE");
        goto Error;
    }

    if (fAddRef)
        pDataObj->AddRef();

    if (!pret)
    {
        hr = E_POINTER;
        goto Error;
    }

    pvarData = (data && (V_VT(data) == (VT_BYREF | VT_VARIANT))) ?
        V_VARIANTREF(data) : data;

    if (pvarData)
    {
        if (V_VT(pvarData) == VT_BSTR)
            pchData = V_BSTR(pvarData);
        else
        {
            hr = E_INVALIDARG;
            goto Error;
        }
    }

    if (!StrCmpIC(format, _T("Text")))
    {
        // First. set as unicode text
        if (pchData)
        {
            hr = copyBstrToHglobal(FALSE, pchData, &(stgmed.hGlobal));
            if (hr)
                goto Error;
        }
        else
            stgmed.hGlobal = NULL;

        stgmed.tymed = TYMED_HGLOBAL;
        fmtc.cfFormat = CF_UNICODETEXT;
        fmtc.ptd = NULL;
        fmtc.dwAspect = DVASPECT_CONTENT;
        fmtc.lindex = -1;
        fmtc.tymed = TYMED_HGLOBAL;

        hr = pDataObj->SetData(&fmtc, &stgmed, TRUE);
        if (hr)
            goto Error;

        // Now, set as ansi text
        if (pchData)
        {
            hr = copyBstrToHglobal(TRUE, pchData, &(stgmed.hGlobal));
            if (hr)
                goto Error;
        }
        fmtc.cfFormat = CF_TEXT;

        hr = pDataObj->SetData(&fmtc, &stgmed, TRUE);
        if (hr)
            goto Error;
    }
    else if (!StrCmpIC(format, _T("Url")))
    {
        IDataObject * pLinkDataObj;

        if (pDragStartInfo && pDragStartInfo->_pUrlToDrag)
            hr = pDragStartInfo->_pUrlToDrag->SetURL(pchData, 0);
        else if (pchData && (pDragStartInfo || fCutCopy))
        {
            hr = THR(CreateLinkDataObject(pchData, NULL, &pUrlToDrag));
            if (hr)
                goto Cleanup;

            hr = THR(pUrlToDrag->QueryInterface(IID_IDataObject, (void **) &pLinkDataObj));
            if (hr)
                goto Cleanup;

            ReplaceInterface(&(DYNCAST(CBaseBag, pDataObj)->_pLinkDataObj), pLinkDataObj);
            pLinkDataObj->Release();
        }
    }
    else if (!data)
    {
        if (!StrCmpIC(format, _T("File")))
            fmtc.cfFormat = CF_HDROP;
        else if (!StrCmpIC(format, _T("Html")))
            fmtc.cfFormat = cf_HTML;
        else if (!StrCmpIC(format, _T("Image")))
            fmtc.cfFormat = CF_DIB;
        else
        {
            hr = E_UNEXPECTED;
            goto Error;
        }

        stgmed.hGlobal = NULL;
        stgmed.tymed = TYMED_HGLOBAL;
        fmtc.ptd = NULL;
        fmtc.dwAspect = DVASPECT_CONTENT;
        fmtc.lindex = -1;
        fmtc.tymed = TYMED_HGLOBAL;

        hr = pDataObj->SetData(&fmtc, &stgmed, TRUE);
        if (hr)
            goto Error;
    }
    else
    {
        hr = E_UNEXPECTED;
        goto Error;
    }

    if (fCutCopy)
        _pWindow->SetClipboard(pDataObj);

    *pret = VB_TRUE;
Cleanup:
    ReleaseInterface(pDataObj);
    ReleaseInterface(pUrlToDrag);
    RRETURN(SetErrorInfo(hr));
Error:
    if (stgmed.hGlobal)
        GlobalFree(stgmed.hGlobal);
    if (pret)
        *pret = VB_FALSE;
    goto Cleanup;
}

HRESULT
CDataTransfer::getData(BSTR format, VARIANT* pvarRet)
{
    HRESULT hr = S_OK;
    STGMEDIUM stgmed = {0, NULL};
    FORMATETC fmtc;
    HGLOBAL hGlobal = NULL;
    HGLOBAL hUnicode = NULL;
    TCHAR * pchText = NULL;
    IUniformResourceLocator * pUrlToDrag = NULL;

    if (!_fDragDrop)    // access to window.clipboardData.getData
    {
        BOOL fAllow;
        hr = THR(_pWindow->Markup()->ProcessURLAction(URLACTION_SCRIPT_PASTE, &fAllow));
        if (hr || !fAllow)
            goto Cleanup;       // Fail silently
    }

    if (!pvarRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!StrCmpIC(format, _T("Text")))
    {
        fmtc.cfFormat = CF_UNICODETEXT;
        fmtc.ptd = NULL;
        fmtc.dwAspect = DVASPECT_CONTENT;
        fmtc.lindex = -1;
        fmtc.tymed = TYMED_HGLOBAL;

        if (    (_pDataObj->QueryGetData(&fmtc) == NOERROR)
            &&  (_pDataObj->GetData(&fmtc, &stgmed) == S_OK))
        {
            hGlobal = stgmed.hGlobal;
            pchText = (TCHAR *) GlobalLock(hGlobal);
        }
        else
        {
            fmtc.cfFormat = CF_TEXT;
            if (    (_pDataObj->QueryGetData(&fmtc) == NOERROR)
                &&  (_pDataObj->GetData(&fmtc, &stgmed) == S_OK))
            {
                hGlobal = stgmed.hGlobal;
                hUnicode = TextHGlobalAtoW(hGlobal);
                pchText    = (TCHAR *) GlobalLock(hUnicode);
            }
            else
            {
                V_VT(pvarRet) = VT_NULL;
                hr = S_OK;
                goto Cleanup;
            }
        }

        if (!pchText)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        V_VT(pvarRet) = VT_BSTR;
        V_BSTR(pvarRet) = SysAllocString(pchText);
    }
    else if (!StrCmpIC(format, _T("Url")))
    {
        hr = _pDataObj->QueryInterface(IID_IUniformResourceLocator, (void**)&pUrlToDrag);
        if (hr && DYNCAST(CBaseBag, _pDataObj)->_pLinkDataObj)
            hr = DYNCAST(CBaseBag, _pDataObj)->_pLinkDataObj->QueryInterface(IID_IUniformResourceLocator, (void**)&pUrlToDrag);
        if (hr)
        {
            V_VT(pvarRet) = VT_NULL;
            hr = S_OK;
            goto Cleanup;
        }

        hr = pUrlToDrag->GetURL(&pchText);
        if (hr)
            goto Cleanup;

        V_VT(pvarRet) = VT_BSTR;
        V_BSTR(pvarRet) = SysAllocString(pchText);
        CoTaskMemFree(pchText);
    }
    else
        hr = E_UNEXPECTED;


Cleanup:
    if (hGlobal)
    {
        GlobalUnlock(hGlobal);
        ReleaseStgMedium(&stgmed);
    }
    if (hUnicode)
    {
        GlobalUnlock(hUnicode);
        GlobalFree(hUnicode);
    }
    ReleaseInterface(pUrlToDrag);

    RRETURN(_pWindow->Doc()->SetErrorInfo(hr));
}

HRESULT
CDataTransfer::clearData(BSTR format, VARIANT_BOOL* pret)
{
    HRESULT hr = S_OK;

    if (!StrCmpIC(format, _T("null")))
    {
        IGNORE_HR(setData(_T("Text"), NULL, pret));
        IGNORE_HR(setData(_T("Url"), NULL, pret));
        IGNORE_HR(setData(_T("File"), NULL, pret));
        IGNORE_HR(setData(_T("Html"), NULL, pret));
        IGNORE_HR(setData(_T("Image"), NULL, pret));
    }
    else
    {
        hr = setData(format, NULL, pret);
    }

    RRETURN(hr);
}

HRESULT
CDataTransfer::get_dropEffect(BSTR *pbstrDropEffect)
{
    HRESULT hr;
    htmlDropEffect dropEffect = htmlDropEffectNone;
    EVENTPARAM * pparam;

    if (!_fDragDrop)
    {
        *pbstrDropEffect = NULL;
        hr = S_OK;
        goto Cleanup;
    }

    if (pbstrDropEffect == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pparam = _pWindow->Doc()->_pparam;

    switch (pparam->dwDropEffect)
    {
    case DROPEFFECT_COPY:
        dropEffect = htmlDropEffectCopy;
        break;
    case DROPEFFECT_LINK:
        dropEffect = htmlDropEffectLink;
        break;
    case DROPEFFECT_MOVE:
        dropEffect = htmlDropEffectMove;
        break;
    case DROPEFFECT_NONE:
        dropEffect = htmlDropEffectNone;
        break;
    default:
        Assert(FALSE);
    }

    hr = THR(STRINGFROMENUM(htmlDropEffect, (long) dropEffect, pbstrDropEffect));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDataTransfer::put_dropEffect(BSTR bstrDropEffect)
{
    HRESULT hr;
    htmlDropEffect dropEffect;
    EVENTPARAM * pparam;

    if (!_fDragDrop)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(ENUMFROMSTRING(htmlDropEffect, bstrDropEffect, (long *) &dropEffect));
    if (hr)
        goto Cleanup;

    pparam = _pWindow->Doc()->_pparam;

    switch (dropEffect)
    {
    case htmlDropEffectCopy:
        pparam->dwDropEffect = DROPEFFECT_COPY;
        break;
    case htmlDropEffectLink:
        pparam->dwDropEffect = DROPEFFECT_LINK;
        break;
    case htmlDropEffectMove:
        pparam->dwDropEffect = DROPEFFECT_MOVE;
        break;
    case htmlDropEffectNone:
        pparam->dwDropEffect = DROPEFFECT_NONE;
        break;
    default:
        Assert(FALSE);
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CDataTransfer::get_effectAllowed(BSTR *pbstrEffectAllowed)
{
    HRESULT hr;
    htmlEffectAllowed effectAllowed;
    CDragStartInfo * pDragStartInfo = _pWindow->Doc()->_pDragStartInfo;

    if (!_fDragDrop)
    {
        *pbstrEffectAllowed = NULL;
        hr = S_OK;
        goto Cleanup;
    }

    if (pbstrEffectAllowed == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pDragStartInfo)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    switch (pDragStartInfo->_dwEffectAllowed)
    {
    case DROPEFFECT_COPY:
        effectAllowed = htmlEffectAllowedCopy;
        break;
    case DROPEFFECT_LINK:
        effectAllowed = htmlEffectAllowedLink;
        break;
    case DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedMove;
        break;
    case DROPEFFECT_COPY | DROPEFFECT_LINK:
        effectAllowed = htmlEffectAllowedCopyLink;
        break;
    case DROPEFFECT_COPY | DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedCopyMove;
        break;
    case DROPEFFECT_LINK | DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedLinkMove;
        break;
    case DROPEFFECT_COPY | DROPEFFECT_LINK | DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedAll;
        break;
    case DROPEFFECT_NONE:
        effectAllowed = htmlEffectAllowedNone;
        break;
    default:
        effectAllowed = htmlEffectAllowedUninitialized;
        break;
    }

    hr = THR(STRINGFROMENUM(htmlEffectAllowed, (long) effectAllowed, pbstrEffectAllowed));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDataTransfer::put_effectAllowed(BSTR bstrEffectAllowed)
{
    HRESULT hr;
    htmlEffectAllowed effectAllowed;
    CDragStartInfo * pDragStartInfo = _pWindow->Doc()->_pDragStartInfo;

    if (!_fDragDrop)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (!pDragStartInfo)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(ENUMFROMSTRING(htmlEffectAllowed, bstrEffectAllowed, (long *) &effectAllowed));
    if (hr)
        goto Cleanup;

    switch (effectAllowed)
    {
    case htmlEffectAllowedCopy:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY;
        break;
    case htmlEffectAllowedLink:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_LINK;
        break;
    case htmlEffectAllowedMove:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedCopyLink:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_LINK;
        break;
    case htmlEffectAllowedCopyMove:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedLinkMove:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_LINK | DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedAll:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_LINK | DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedNone:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_NONE;
        break;
    case htmlEffectAllowedUninitialized:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_UNINITIALIZED;
        break;
    default:
        Assert(FALSE);
    }

Cleanup:
    RRETURN(hr);
}

extern  DYNLIB g_dynlibUSER32;
DYNPROC        g_dynprocIsWinEventHookInstalled = { NULL, &g_dynlibUSER32, "IsWinEventHookInstalled" };
BOOL           g_fIsWinEventHookInstalled       = TRUE; // TRUE if there is somebody listening to MSAA focus events,
                                                        // TRUE by default for Downlevel platform support.

#define DONOTHING_ISWINEVENTHOOKINSTALLED (BOOL (APIENTRY *)(DWORD))1

HRESULT
CWindow::FireAccessibilityEvents(DISPID dispidEvent)
{
    HRESULT hr   = S_OK;
    CDoc  * pDoc = Doc();
    Assert(pDoc);

    if (g_dynprocIsWinEventHookInstalled.pfn != DONOTHING_ISWINEVENTHOOKINSTALLED)
    {
        if (!g_dynprocIsWinEventHookInstalled.pfn)
        {
            IGNORE_HR(LoadProcedure(&g_dynprocIsWinEventHookInstalled));
            if (!g_dynprocIsWinEventHookInstalled.pfn)
            {
                //API not supported
                g_dynprocIsWinEventHookInstalled.pfn = DONOTHING_ISWINEVENTHOOKINSTALLED;
                goto CallFireAccessibilityEvents;
            }
        }

        Assert(g_dynprocIsWinEventHookInstalled.pfn);

        g_fIsWinEventHookInstalled = (*(BOOL (APIENTRY *)(DWORD)) g_dynprocIsWinEventHookInstalled.pfn)(EVENT_OBJECT_FOCUS);
    }

CallFireAccessibilityEvents:
    if (IsPrimaryWindow())
    {
        // top level window is the OBJID_WINDOW, which is 0
        hr = THR(pDoc->FireAccessibilityEvents(dispidEvent, OBJID_WINDOW, TRUE));
    }
    else
    {
        hr = THR(pDoc->FireAccessibilityEvents(dispidEvent, (CBase *)this, TRUE));
    }

    RRETURN(hr);
}

//
// get a window proxy that we can return to the script environment,
//
COmWindowProxy *
COmWindowProxy::GetSecureWindowProxy(BOOL fClearWindow /* = FALSE */)
{
    IHTMLWindow2 * pIHTMLWindow2 = NULL;

    IGNORE_HR(SecureObject( this, &pIHTMLWindow2));

    //
    // Make the script collection point to the secure object we created.
    // if it is not already doing so.
    // This is only done if we are not shutting down this markup.
    //
    if (!fClearWindow)
        Markup()->GetScriptCollection();

    // We know for sure that the pIHTMLWindow2 is a COmWindowProxy
    // in the same thread. Casting is OK.
    return ((COmWindowProxy *)pIHTMLWindow2);
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::GetClassID
//
//  Synopsis : Per IPersist
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::GetClassID(CLSID * pclsid)
{
    if (!pclsid)
    {
        RRETURN(E_INVALIDARG);
    }

    *pclsid = CLSID_HTMLDocument;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::IsDirty
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------
//
//  TODO: FerhanE
//          The _lDirtyVersion flag is on the CDoc. It means that on a multiframe
//          document, if one of the frames has a dirty section, the whole document
//          will be marked as dirty. It is bad in a scenario where you are making
//          the call to frame2's document and the frame1 is dirty and frame2 is not.
//
//          The change requires touching all sorts of places including parser code. The
//          _lDirtyVersion on the CDoc has to die and CDocument has to have a counter.
//          I am delaying that change to finish fixing all IPersist interfaces first. We
//          can make that update after we provide basic functionality to load/save through
//          these interfaces.
//          Another part of that cleanup should be to port the _fHasOleSite flag to the document.
//          However, we should change its name to _fNotifyForDirty or something, since framesites
//          are no longer olesites and they can have dirtied documents inside. CDoc's optimization can
//          be mimicked then.
//
STDMETHODIMP
CDocument::IsDirty(void)
{
    CDoc * pDoc = Markup()->Doc();

    // never dirty in design mode
    if (!DesignMode())
        return S_FALSE;

    if (pDoc->_lDirtyVersion != 0)
        return S_OK;

    Assert(Markup()->Root());

    CNotification   nf;
    nf.UpdateDocDirty(Markup()->Root());
    Markup()->Notify(&nf);

    if (pDoc->_lDirtyVersion == 0)
        return S_FALSE;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::Load
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT hr;

    hr = THR(Window()->FollowHyperlinkHelper((TCHAR *)pszFileName, 0, 0));

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member   : CDocument::Save
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    HRESULT hr = S_OK;

    hr = THR(Markup()->Doc()->SaveHelper(Markup(), pszFileName, fRemember));

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::SaveCompleted
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::SaveCompleted(LPCOLESTR pszFileName)
{
    HRESULT hr = S_OK;

    hr = THR(Markup()->Doc()->SaveCompletedHelper(Markup(), pszFileName));

    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member   : CDocument::GetCurFile
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

HRESULT
CDocument::GetCurFile(LPOLESTR *ppszFileName)
{
    HRESULT         hr;
    TCHAR           achFile[MAX_PATH];
    ULONG           cchFile = ARRAY_SIZE(achFile);
    const TCHAR *   pchUrl  = CMarkup::GetUrl(Markup());

    if (!pchUrl || GetUrlScheme(pchUrl) != URL_SCHEME_FILE)
        return E_UNEXPECTED;

    hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
    if (hr)
        RRETURN(hr);

    RRETURN(THR(TaskAllocString(achFile, ppszFileName)));
}

//+------------------------------------------------------------------------
//
//  Class:      CDocument - IPersistHistory implementation
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CDocument::LoadHistory
//
//  Synopsis:   implementation of IPersistHistory::LoadHistory
//
//-------------------------------------------------------------------------
HRESULT
CDocument::LoadHistory(IStream * pStream, IBindCtx * pbc)
{
    RRETURN(_pWindow->LoadHistory(pStream, pbc));
}

//+------------------------------------------------------------------------
//
//  Member:     CDocument::SaveHistory
//
//  Synopsis:   implementation of IPersistHistory::SaveHistory
//
//-------------------------------------------------------------------------
HRESULT
CDocument::SaveHistory(IStream * pStream)
{
    RRETURN(_pWindow->SaveHistory(pStream));
}

//+------------------------------------------------------------------------
//
//  Member:     CDocument::GetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::GetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDocument::GetPositionCookie(DWORD * pdwCookie)
{
    RRETURN(_pWindow->GetPositionCookie(pdwCookie));
}

//+------------------------------------------------------------------------
//
//  Member:     CDocument::SetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::SetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDocument::SetPositionCookie(DWORD dwCookie)
{
    RRETURN(_pWindow->SetPositionCookie(dwCookie));
}

//+------------------------------------------------------------------------
//
//  Member:     CWindow::FollowHyperlinkHelper
//
//-------------------------------------------------------------------------
HRESULT
CWindow::FollowHyperlinkHelper(TCHAR * pchUrl,
                               DWORD dwBindf,
                               DWORD dwFlags,
                               TCHAR * pchUrlContext)
{
    HRESULT hr;
    CFrameSite * pFrameSite = GetFrameSite();

    if (pFrameSite)
    {
        CStr strUrlOrig;

        hr = strUrlOrig.Set(pFrameSite->GetAAsrc());
        if (hr)
            goto Cleanup;

        hr = THR(pFrameSite->SetAAsrc(pchUrl));
        if (hr)
            goto Cleanup;

        hr = THR(pFrameSite->OnPropertyChange_Src(dwBindf, dwFlags | CDoc::FHL_FOLLOWHYPERLINKHELPER, pchUrlContext));

        // regardless we navigated or not. Restore the original src
        hr = THR(pFrameSite->SetAAsrc(strUrlOrig));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(_pMarkup->Doc()->FollowHyperlink(pchUrl,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  FALSE,
                                                  NULL,
                                                  FALSE,
                                                  _pMarkup->Window(),
                                                  NULL,
                                                  dwBindf,
                                                  ERROR_SUCCESS,
                                                  FALSE,
                                                  NULL,
                                                  FALSE,
                                                  dwFlags,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  pchUrlContext));
    }

Cleanup:
    RRETURN(hr);
}

void
CDocument::Fire_onreadystatechange()
{
    CWindow * pWindow = Window();

    FireEvent(Doc(), DISPID_EVMETH_ONREADYSTATECHANGE, DISPID_EVPROP_ONREADYSTATECHANGE, _T("readystatechange"));

    if (pWindow)
    {
        CFrameSite * pFrameSite = pWindow->GetFrameSite();

        if (pFrameSite)
            pFrameSite->Fire_onreadystatechange();
    }
}

void
CWindow::HandlePendingScriptErrors( BOOL fShowError)
{
    CPendingScriptErr * pErrRec = NULL;

    for (int i=0; i < _aryPendingScriptErr.Size(); i++ )
    {
        pErrRec = &_aryPendingScriptErr[i];

        // being paranoid about reentrancy and checking the markup pointer too...
        if (pErrRec)
        {
            ErrorRecord errorRecord;

            Assert(pErrRec->_pMarkup);

            if (fShowError &&
                !pErrRec->_pMarkup->IsPassivated() &&
                !pErrRec->_pMarkup->IsPassivating())
            {
                HRESULT hr;

                errorRecord.Init(E_ACCESSDENIED, pErrRec->_cstrMessage, (LPTSTR) CMarkup::GetUrl(pErrRec->_pMarkup));

                hr = pErrRec->_pMarkup->GetNearestMarkupForScriptCollection()->ReportScriptError(errorRecord);
            }

            // cleanup as we go
            pErrRec->_cstrMessage.Free();
            pErrRec->_pMarkup->SubRelease();
            pErrRec->_pMarkup = NULL;
        }
    }

    _aryPendingScriptErr.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::SetBindCtx
//
//  Synopsis : Sets the bind ctx that will be used when delegating the
//             navigation to shdocvw for non-html mime types.
//
//-------------------------------------------------------------------------

void CWindow::SetBindCtx(IBindCtx * pBindCtx)
{
    Assert(pBindCtx);
    ReplaceInterface(&_pBindCtx, pBindCtx);
}


//+------------------------------------------------------------------------
//
//  Member   : CDocument::SetGalleryMeta
//
//  Synopsis : sets _bIsGalleryMeta var
//
//-------------------------------------------------------------------------

void CDocument::SetGalleryMeta(BOOL bValue)
{
    _bIsGalleryMeta = bValue;
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::GetGalleryMeta
//
//  Synopsis : returns _bIsGalleryMeta var
//
//-------------------------------------------------------------------------

BOOL CDocument::GetGalleryMeta()
{
    return(_bIsGalleryMeta);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::Load, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDocument::Load(BOOL fFullyAvailable, IMoniker *pmkName, IBindCtx *pbctx,
    DWORD grfMode)
{
    HRESULT     hr = E_INVALIDARG;
    TCHAR       *pchURL = NULL;

    if( pmkName == NULL )
        goto Cleanup;

    AssertSz( pbctx, "This call carries a bind context. Find out for what purpose. (FerhanE/MarkA)");

    // Get the URL from the display name of the moniker:
    hr = pmkName->GetDisplayName(pbctx, NULL, &pchURL);
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(Window()->FollowHyperlinkHelper((TCHAR *)pchURL, 0, 0));

Cleanup:
    CoTaskMemFree(pchURL);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::Save, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDocument::Save(IMoniker *pmkName, LPBC pBCtx, BOOL fRemember)
{
    HRESULT     hr;
    IStream *   pStm = NULL;

    if (pmkName == NULL)
    {
        pmkName = Markup()->GetNonRefdMonikerPtr();
    }

    hr = THR(pmkName->BindToStorage(pBCtx, NULL, IID_IStream, (void **)&pStm));
    if (hr)
        goto Cleanup;

    hr = THR(Markup()->Save(pStm, TRUE));
    if (hr)
        goto Cleanup;

    if (fRemember)
    {
        hr = THR( Markup()->ReplaceMonikerPtr( pmkName ) );
        if( hr )
            goto Cleanup;

        Markup()->ClearDwnPost();
    }

Cleanup:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::SaveCompleted, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDocument::SaveCompleted(IMoniker *pmkName, LPBC pBCtx)
{
    HRESULT hr = S_OK;
    if (pmkName && Markup()->Doc()->DesignMode())
    {
        hr = THR(Markup()->ReplaceMonikerPtr( pmkName ));
        if( hr )
            goto Cleanup;

        Markup()->ClearDwnPost();
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::GetCurMoniker, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDocument::GetCurMoniker(IMoniker **ppmkName)
{
    IMoniker *pmk = Markup()->GetNonRefdMonikerPtr();

    if (!ppmkName)
        RRETURN(E_POINTER);

    if (!pmk)
        RRETURN(E_UNEXPECTED);

    *ppmkName = pmk;
    pmk->AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::Load, IPersistStream and IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::Load( LPSTREAM pStream )
{
    HRESULT hr;

    // if we are the top level document, then delegate to the doc.
    if (Markup()->IsPrimaryMarkup())
    {
        hr = THR(Markup()->Doc()->Load(pStream));
    }
    else
    {
        // we just can't load a frame from stream.
        hr = E_NOTIMPL;
    }

    RRETURN1(hr, E_NOTIMPL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::Load, IPersistStream and IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    HRESULT hr;

    hr = THR( Markup()->SaveToStream( pStream ) );
    if( hr )
        goto Cleanup;

    if( fClearDirty )
    {
        Markup()->ClearDirtyFlag();
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::GetSizeMax, IPersistStream and IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::InitNew, IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::InitNew()
{
    return E_NOTIMPL;
}

#if DBG==1 
//  
//  CWindow::SetProxyCaller -- IDebugWindow
//
HRESULT
CWindow::SetProxyCaller(IUnknown *pProxy)
{
    if (pProxy)
    {
        // If nested _different_ proxies, only the innermost counts. Don't have to be super robust here
        if (_pProxyCaller != NULL && _pProxyCaller != pProxy)
        {
            Assert(TRUE); // this happens in frames.js set breakpoint here if you want to see.
            _cNestedProxyCalls = 0;
        }

        _pProxyCaller = pProxy;
        _cNestedProxyCalls++;
    }
    else
    {
        if (0 >= --_cNestedProxyCalls)
        {
            _pProxyCaller = NULL;
        }
        // count will run negative here on nested proxies; 
        // we let it do so in case we want to learn more about it
    }

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\unknownp.cxx ===
//+---------------------------------------------------------------------
//
//   File:      unknownp.cxx
//
//  Contents:   Unknown Pair class
//
//  Classes:    CUnknownPairList
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNKNOWNP_HXX_
#define X_UNKNOWNP_HXX_
#include "unknownp.hxx"
#endif

CUnknownPair* 
CUnknownPairList::Get(size_t i)
{
    Assert(i>=0&&i<Length());
    return ((CUnknownPair *)*_paryUnknown)+i;
}

size_t
CUnknownPairList::Length() const
{
    return _paryUnknown?_paryUnknown->Size():0;
}

HRESULT 
CUnknownPairList::Duplicate(CUnknownPairList &upl) const
{
    HRESULT hr = S_OK;
    CUnknownPair *pupThis, *pupThat;
    int cUPairs;

    CDataAry<CUnknownPair> *paryOtherUnknown;

    // Both attr bags must have unknowns, or neither
    if (!_paryUnknown)
        goto Cleanup;

    cUPairs = _paryUnknown->Size();

    upl._paryUnknown = new CDataAry<CUnknownPair>;
    if (!upl._paryUnknown)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    paryOtherUnknown = upl._paryUnknown;
    hr = paryOtherUnknown->EnsureSize(cUPairs);
    if (hr)
        goto Cleanup;

    paryOtherUnknown->SetSize(cUPairs);

    pupThis = (CUnknownPair *)*_paryUnknown;
    pupThat = (CUnknownPair *)*paryOtherUnknown;
    for ( ; --cUPairs >= 0; pupThis++, pupThat++)
    {
        UINT cchA = pupThis->_cstrA.Length();
        UINT cchB = pupThis->_cstrB.Length();

        new (&pupThat->_cstrA) CStr();
        new (&pupThat->_cstrB) CStr();

        hr = pupThat->_cstrA.Set((LPTSTR)pupThis->_cstrA, cchA);
        if (hr)
            goto Cleanup;

        if (cchB)
        {
            hr = pupThat->_cstrB.Set((LPTSTR)pupThis->_cstrB, cchB);
            if (hr)
                goto Cleanup;
        }
    }

// TODO: Should we free a partially copied array???
Cleanup:
    RRETURN(hr);
}

BOOL 
CUnknownPairList::Compare(const CUnknownPairList *pup) const
{
    CUnknownPair *pupThis, *pupThat;
    int cUPairs;
    CDataAry<CUnknownPair> *paryOtherUnknown = pup->_paryUnknown;

    // Both attr bags must have unknowns, or neither
    if (!_paryUnknown || !paryOtherUnknown)
    {
        return (!_paryUnknown && !paryOtherUnknown);
    }

    cUPairs = _paryUnknown->Size();
    if (cUPairs != paryOtherUnknown->Size())
        return FALSE;

    pupThis = (CUnknownPair *)*_paryUnknown;
    pupThat = (CUnknownPair *)*paryOtherUnknown;
    for ( ; --cUPairs >= 0; pupThis++, pupThat++)
    {
        UINT cchName = pupThis->_cstrA.Length();
        UINT cchValue = pupThis->_cstrB.Length();

        // Check lengths first
        if (   cchName != pupThat->_cstrA.Length()
            || cchValue != pupThat->_cstrB.Length())
            return FALSE;

        if (   _tcsicmp((LPTSTR)pupThis->_cstrA, (LPTSTR)pupThat->_cstrA)
            || (cchValue && StrCmpC((LPTSTR)pupThis->_cstrB, (LPTSTR)pupThat->_cstrB)))
            return FALSE;
    }
    return TRUE;
}

WORD 
CUnknownPairList::ComputeCrc() const
{
    WORD wHash = 0;

    if (_paryUnknown) {
        CUnknownPair *pUPair;
        int cUPairs;

        for (pUPair = (CUnknownPair *)*_paryUnknown, cUPairs = _paryUnknown->Size();
             cUPairs; cUPairs--, pUPair++)
        {
            wHash ^= pUPair->_cstrA.ComputeCrc();
            wHash ^= pUPair->_cstrB.ComputeCrc();
        }
    }
    return wHash;
}

HRESULT
CUnknownPairList::AddUnknownPair(const TCHAR *pchA, const size_t cchA,
                            const TCHAR *pchB, const size_t cchB)
{
    HRESULT hr = S_OK;
    CUnknownPair *pUPair;
    CUnknownPair upDummy;
    int iCount, iIndex, iDiff;


    Assert(pchA);

    if (!_paryUnknown)
    {
        _paryUnknown = new CDataAry<CUnknownPair>;
    }

    if (!_paryUnknown)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // TODO: should bsearch

    iCount = _paryUnknown->Size();

    for (iIndex = 0; iIndex < iCount; iIndex++)
    {
        pUPair = Get(iIndex);
        Assert(pUPair);

        // Compare names (case-insensitive)
        iDiff = _tcsnicmp(pchA, cchA, (LPTSTR)pUPair->_cstrA, -1);
        if (iDiff < 0)
            break;
        else if (!iDiff)
        {
            // Compare values
            if (!cchB || !pchB)      // If there's no value, insert here
                break;
            else if (!(LPTSTR)pUPair->_cstrB)   // If this slot has no value, keep looking
                continue;
            else
            {
                // Compare value strings (case-sensitive)
                iDiff = _tcsncmp(pchB, cchB, (LPTSTR)pUPair->_cstrB, -1);
                if (iDiff <= 0)
                    break;
            }
        }
    }

    // TODO: This is egregious. Should upDummy be initialized first?????
    hr = _paryUnknown->InsertIndirect(iIndex, &upDummy);
    if (hr)
        goto Cleanup;
    pUPair = Get(iIndex);
    Assert(pUPair);

    new (&pUPair->_cstrA) CStr();
    new (&pUPair->_cstrB) CStr();

    hr = pUPair->_cstrA.Set(pchA, cchA);
    if (hr)
        goto Cleanup;

    if (pchB && cchB)
    {
        hr = pUPair->_cstrB.Set(pchB, cchB);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);

}

void
CUnknownPairList::Free()
{
    CUnknownPair *pUPair;

    if (_paryUnknown)
    {
        int i = _paryUnknown->Size();
        for (pUPair = (CUnknownPair *)(*_paryUnknown); i; i--, pUPair++)
        {
            pUPair->_cstrA.Free();
            pUPair->_cstrB.Free();
        }

        delete _paryUnknown;
        _paryUnknown = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\unixbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       src\site\base\unixbase.cxx
//
//  Contents:   Implementation of Unix specific/different operations
//
//  Classes:    
//
//  Functions:
//
//  History:    03-Sep-97   davidd    Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "formkrnl.hxx"

EXTERN_C char *MwGetXDisplayString( void );

HRESULT CDoc::InvokeEditor( LPCSTR lpszPath )
{
    HKEY  hkeyUnix;
    CHAR  szCommand [2*MAX_PATH];
    CHAR  szCmdTempl[MAX_PATH+1];
    CHAR  szName    [MAX_PATH+1];
    CHAR  hKeyName  [MAX_PATH+1];

    STARTUPINFOA st;
    PROCESS_INFORMATION pi;

    BOOL  bIsKnownEdit  = FALSE;
    char  displayString [2*MAX_PATH];
    DWORD editors       = 0;
    DWORD type          = REG_SZ;
    DWORD dwLength      = sizeof(szCmdTempl);

    if( MwGetXDisplayString() )
        sprintf( displayString, "-display %s", MwGetXDisplayString() );
    else
        sprintf( displayString, " ");
        

    // Get user preferred editor.

    if( getenv("EDITOR" ) )
       strcpy(szName, getenv("EDITOR") );
    else
       strcpy(szName, "vi");

    // Check editor against the list of known editors in 
    // registry.

    sprintf( hKeyName, 
             "Software\\Microsoft\\Internet Explorer\\Unix\\Editors\\%s",
             szName );

    LONG lResult = RegOpenKeyExA(
       HKEY_CURRENT_USER,
       hKeyName,
       0,
       KEY_QUERY_VALUE,
       &hkeyUnix);

    if (lResult == ERROR_SUCCESS) 
    {
        // Read command template for the registered editor

        lResult = RegQueryValueExA(
           hkeyUnix,
           "command",
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  &szCmdTempl,
           (LPDWORD) &dwLength);

        if( lResult == ERROR_SUCCESS )
            bIsKnownEdit = TRUE;
            
        RegCloseKey(hkeyUnix);

    }

    // Create proper command and append dissplay string to make the
    // editor appear on the same XServer as the Iexplorer.
    if( !bIsKnownEdit )
    {
        // Default use vi
        sprintf( szCommand, "xterm %s -e vi %s ", displayString, lpszPath  );
    }
    else
    {
        // Use template command from registry to create actual command.
        sprintf( szCommand, szCmdTempl, displayString, lpszPath );
    }

    // Initialize startup info struct.
    st.cb = sizeof(STARTUPINFO);
    st.lpReserved = NULL;
    st.lpDesktop  = NULL;
    st.lpTitle    = NULL;
    st.dwFlags    = 0;
    st.wShowWindow= SW_SHOWNORMAL;
    st.cbReserved2= 0;
    st.lpReserved2= NULL;

    // Launch the command
    if ( CreateProcessA( NULL, szCommand, NULL, NULL, TRUE, 
                         CREATE_NEW_CONSOLE, NULL, NULL, &st, &pi )) 
    {
        return S_OK;
    }

    RRETURN( GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\viewserv.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CARET_HXX_
#define X_CARET_HXX_
#include "caret.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif


#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef _X_ADORNER_HXX_
#define _X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifdef UNIX
#include "quxcopy.hxx"
#endif

#ifndef I_CORERC_H_
#include "corerc.h"
#endif

#ifndef X_DISPSERV_HXX_
#define X_DISPSERV_HXX_
#include "dispserv.hxx"
#endif

static const LPTSTR astrCursor[] =
{
    IDC_SIZEALL,                    // HTC_TOPBORDER         = 21,
    IDC_SIZEALL,                    // HTC_LEFTBORDER        = 22,
    IDC_SIZEALL,                    // HTC_BOTTOMBORDER      = 23,
    IDC_SIZEALL,                    // HTC_RIGHTBORDER       = 24,
    IDC_SIZENWSE,                   // HTC_TOPLEFTHANDLE     = 25,
    IDC_SIZEWE,                     // HTC_LEFTHANDLE        = 26,
    IDC_SIZENS,                     // HTC_TOPHANDLE         = 27,
    IDC_SIZENESW,                   // HTC_BOTTOMLEFTHANDLE  = 28,
    IDC_SIZENESW,                   // HTC_TOPRIGHTHANDLE    = 29,
    IDC_SIZENS,                     // HTC_BOTTOMHANDLE      = 30,
    IDC_SIZEWE,                     // HTC_RIGHTHANDLE       = 31,
    IDC_SIZENWSE,                   // HTC_BOTTOMRIGHTHANDLE = 32
};


MtDefine(CDocRegionFromMarkupPointers_aryRects_pv, Locals, "CDoc::RegionFromMarkupPointers aryRects::_pv")


DeclareTag(tagSelectionTimer, "Selection", "Selection Timer Actions in CDoc")
DeclareTag(tagViewServicesErrors, "ViewServices", "Show Viewservices errors")
DeclareTag( tagViewServicesCpHit, "ViewServices", "Show Cp hit from CpFromPoint")
DeclareTag( tagViewServicesShowEtag, "ViewServices", "Show _etag in MoveMarkupPointer")

DeclareTag( tagViewServicesShowScrollRect, "ViewServices", "Show Scroll Rect")
DeclareTag(tagEditDisableEditFocus, "Edit", "Disable On Edit Focus")

////////////////////////////////////////////////////////////////


HRESULT
CDoc::MoveMarkupPointerToPoint( 
    POINT               pt, 
    IMarkupPointer *    pPointer, 
    BOOL *              pfNotAtBOL, 
    BOOL *              pfAtLogicalBOL,
    BOOL *              pfRightOfCp, 
    BOOL                fScrollIntoView )
{
    RRETURN( THR( MoveMarkupPointerToPointEx( pt, pPointer, TRUE, pfNotAtBOL, pfAtLogicalBOL, pfRightOfCp, fScrollIntoView ))); // Default to global coordinates
}

HRESULT 
CDoc::MoveMarkupPointerToPointEx(
    POINT               pt,
    IMarkupPointer *    pPointer,
    BOOL                fGlobalCoordinates,
    BOOL *              pfNotAtBOL,
    BOOL *              pfAtLogicalBOL,
    BOOL *              pfRightOfCp,
    BOOL                fScrollIntoView )
{
    HRESULT hr = E_FAIL;
    CMarkupPointer * pPointerInternal = NULL;
    POINT ptContent;
    CLayoutContext *pLayoutContext = NULL;
    
    CTreeNode * pTreeNode = GetNodeFromPoint( pt, &pLayoutContext, fGlobalCoordinates, &ptContent, NULL, NULL, NULL );
    
    if( pTreeNode == NULL )
        goto Cleanup;

    // TODO: the following block seem to be extra, together with "if".
    //       It can lie in case of relatively positioned nodes.
    //       I think that following changes shouldd be done:
    //       1) add new variable, CDispNode *pDispnode;
    //       2) pass &pDispnode as 8th argument GetNodeFromPoint();
    //       3) supply MovePointerToPointInternal() with this pDispNode as 13th arg,
    //       4) and remove the whole <if (..) { ... }>
    //       See accutil.cxx for example, and bugs 105942, 106131, 109587 fixes.
    //       Not fixed because of improper project stage (mikhaill 5/9/00).
    if ( ( ptContent.x == 0 ) && ( ptContent.y == 0 ) )
    {
        //
        // NOTE Sometimes - HitTestPoint returns ptContent of 0 We take over ourselves.
        //
        CFlowLayout * pLayout = NULL;
        
        pLayout = pTreeNode->GetFlowLayout( pLayoutContext );
        if( pLayout == NULL )
            goto Cleanup;

        CPoint myPt( pt );
        pLayout->TransformPoint( &myPt, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT, NULL );

        ptContent.x = myPt.x;
        ptContent.y = myPt.y;
    }
    
    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) &pPointerInternal ));
    if( FAILED( hr ))
        goto Cleanup;

    //
    // Accessing line information, ensure a recalc has been done
    //
    hr = THR(pTreeNode->Element()->EnsureRecalcNotify(FALSE));
    if (hr)
        goto Cleanup;
    

    hr = THR( MovePointerToPointInternal( ptContent, pTreeNode, pLayoutContext, pPointerInternal, pfNotAtBOL, pfAtLogicalBOL, pfRightOfCp, fScrollIntoView, pTreeNode->GetFlowLayout( pLayoutContext ), NULL, TRUE ));

Cleanup:
    RRETURN( hr );
}

//*********************************************************************************
//
// TODO - this routine returns values in the Local coords of the layout the pointer is in !
// We should either make this more explicit via a name change - or better allow specification
// of the cood-sys you are using.
//
//*********************************************************************************


HRESULT
CDoc::GetLineInfo(IMarkupPointer *pPointer, BOOL fAtEndOfLine, HTMLPtrDispInfoRec *pInfo)
{
    HRESULT             hr = S_OK;
    CMarkupPointer *    pPointerInternal;
    CFlowLayout *       pFlowLayout;
    CTreeNode *         pNode = NULL;
    CCharFormat const * pCharFormat = NULL;

    hr = THR( pPointer->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal ));
    if (hr)
        goto Cleanup;

    Assert( pPointerInternal->IsPositioned() );
    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);   
    if(pNode == NULL)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pCharFormat = pNode->GetCharFormat();
    pFlowLayout = pNode->GetFlowLayout();

    if(!pFlowLayout)
    {
        hr = OLE_E_BLANK;
        goto Cleanup;
    }

    hr = pFlowLayout->GetLineInfo( pPointerInternal, fAtEndOfLine, pInfo, pCharFormat );

Cleanup:
    RRETURN(hr);    
}

HRESULT
CDoc::RegionFromMarkupPointers( IMarkupPointer *pPointerStart, 
                                IMarkupPointer *pPointerEnd, 
                                HRGN *phrgn)
{
    HRESULT                 hr;
    CMarkupPointer *        pStart  = NULL;
    CMarkupPointer *        pEnd    = NULL;
    RECT                    rcBounding = g_Zero.rc;
    CStackDataAry<RECT, 4>  aryRects(Mt(CDocRegionFromMarkupPointers_aryRects_pv));

    // check parameters
    if ( !pPointerStart || !pPointerEnd || !phrgn )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    // clean the out parameter
    *phrgn = NULL;

    // Get the CMarkupPointer values for the IMarkupPointer 
    // parameters we received
    hr = pPointerStart->QueryInterface( CLSID_CMarkupPointer, (void **)&pStart );
    if ( hr ) 
        goto Cleanup;

    hr = pPointerEnd->QueryInterface( CLSID_CMarkupPointer, (void **)&pEnd );
    if ( hr ) 
        goto Cleanup;

    // We better have these pointers.
    Assert( pStart );
    Assert( pEnd );

    // Get rectangles
    hr = RegionFromMarkupPointers( pStart, pEnd, &aryRects, &rcBounding );
    if ( hr )
        goto Cleanup;


//TODO:   [FerhanE]
//          The code below has to change in order to return a region that contains
//          multiple rectangles. To do that, a region must be created for each 
//          member of the rect. array and combined with the complete region.
//
//          Current code only returns the region for the bounding rectangle.

    // Create and return BOUNDING region
    *phrgn = CreateRectRgn( rcBounding.left ,rcBounding.top,
                            rcBounding.right, rcBounding.bottom );

Cleanup:
    RRETURN( hr );
}


HRESULT
CDoc::RegionFromMarkupPointers( CMarkupPointer  *   pStart, 
                                CMarkupPointer  *   pEnd,
                                CDataAry<RECT>  *   paryRects, 
                                RECT            *   pBoundingRect = NULL, 
                                BOOL                fCallFromAccLocation)
{
    HRESULT         hr = S_OK;
    CTreeNode *     pTreeNode = NULL;
    CFlowLayout *   pFlowLayout = NULL;
    long            cpStart = 0;        // Starting cp.
    long            cpEnd = 0;          // Ending cp

    CElement *      pElem = NULL;

    if ( !pStart || !pEnd || !paryRects)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Calculate the starting and ending cps
    cpStart = pStart->GetCp();
    cpEnd = pEnd->GetCp();

    //Get the flow layout that the markup pointer is placed in.
    pTreeNode = pStart->CurrentScope(MPTR_SHOWSLAVE);
    if ( !pTreeNode )
        goto Error;

    pFlowLayout = pTreeNode->GetFlowLayout();
    if ( !pFlowLayout )
        goto Error;

    // get the element we are in.
    pElem = pTreeNode->Element();
    
    // Get the rectangles.
    pFlowLayout->RegionFromElement( pElem, 
                                    paryRects,  
                                    NULL, NULL, 
                                    RFE_SELECTION|RFE_SCREENCOORD, 
                                    cpStart, cpEnd, 
                                    pBoundingRect );

    // BUT Wait NF ... in IE5.0 RFE_SCREENCORD for frames was wrt the frame's window
    // in IE5.5 there is not window for the frame, and so the RFE_SCREENCOORD is 
    // returning wrt the top window, and not accounting for the origin offest of the
    // frame.  Also, with Viewlinks, if they are a windowed markup, then this needs to
    // be wrt to that. so:
    if (   pBoundingRect
        && pElem->GetWindowedMarkupContext() 
        && !fCallFromAccLocation)
    {
        POINT ptOrg;
        CMarkup  *pwmc = pElem->GetWindowedMarkupContext();

        pwmc->GetElementClient()->GetClientOrigin(&ptOrg);

        pBoundingRect->left   -= ptOrg.x;
        pBoundingRect->right  -= ptOrg.x;
        pBoundingRect->top    -= ptOrg.y;
        pBoundingRect->bottom -= ptOrg.y;

        // and the Array Rects as well.
    }

    
Cleanup:
    RRETURN( hr );

Error:
    RRETURN( E_FAIL );
}


HRESULT 
CDoc::GetCurrentSelectionSegmentList( 
    ISegmentList ** ppSegment)
{
    HRESULT hr = S_OK;
    Assert( _pElemCurrent );

    ISelectionServices  *pSelSvc = NULL;

    hr = THR( GetSelectionServices( &pSelSvc ) );
    if( hr )
        goto Cleanup;

    hr = THR( pSelSvc->QueryInterface( IID_ISegmentList, ( void**) ppSegment ));

Cleanup:
    ReleaseInterface( pSelSvc );

    RRETURN ( hr ) ;
}


CMarkup * 
CDoc::GetCurrentMarkup()
{
    CMarkup * pMarkup = NULL;
    
    if (_pElemCurrent)
    {
        if (_pElemCurrent->HasSlavePtr())
        {
            pMarkup = _pElemCurrent->GetSlavePtr()->GetMarkup();
        }
        else
        {
            pMarkup = _pElemCurrent->GetMarkup();
        }
    }

    return pMarkup;
}        

//+====================================================================================
//
// Method: IsCaretVisible
//
// Synopsis: Checks for caret visibility - if there's no caret - return false.
//
//------------------------------------------------------------------------------------

BOOL
CDoc::IsCaretVisible( BOOL * pfPositioned )
{
    BOOL fVisible = FALSE;
    BOOL fPositioned = FALSE;
    
    if ( _pCaret )
    {
        _pCaret->IsVisible( & fVisible );
        fPositioned = _pCaret->IsPositioned();
    }
    
    if ( pfPositioned )
        *pfPositioned = fPositioned;
        
    return fVisible;        
}

HRESULT 
CDoc::GetCaret(
    IHTMLCaret ** ppCaret )
{
    HRESULT hr = S_OK;

    // NOTE (johnbed) : when CView comes into being, the caret will be
    // stored there and will require a view pointer as well.
    
    // lazily construct the caret...
    
    if( _pCaret == NULL )
    {
        _pCaret = new CCaret( this );
        
        if( _pCaret == NULL )
            goto Error;

        _pCaret->AddRef();      // Doc holds a ref to caret, released in passivate
        _pCaret->Init();        // Init the object
        _pCaret->Hide();        // Default to hidden - host or edit can show after move.
    }
    
    if (ppCaret)
    {
        hr = _pCaret->QueryInterface( IID_IHTMLCaret, (void **) ppCaret );
    }

    RRETURN( hr );

Error:
    return E_OUTOFMEMORY;
}

HRESULT 
CDoc::IsBlockElement ( IHTMLElement * pIElement,
                           BOOL  * fResult ) 
{
    HRESULT     hr;
    CElement  * pElement = NULL;

    if (! pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR_NOTRACE( pIElement->QueryInterface( CLSID_CElement,
            (void **) & pElement ) );
    if (hr)
        goto Cleanup;

    *fResult = pElement->IsBlockElement();

Cleanup:
    RRETURN( hr );
}

HRESULT
CDoc::GetFlowElement ( IMarkupPointer * pIPointer,
                       IHTMLElement  ** ppIElement )
{
    HRESULT           hr;
    BOOL              fPositioned = FALSE;
    CFlowLayout     * pFlowLayout;
    CTreeNode       * pTreeNode = NULL;
    CMarkupPointer  * pMarkupPointer = NULL;
    CElement        * pElement = NULL;

    if (! pIPointer || !ppIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIElement = NULL;

    hr = THR( pIPointer->IsPositioned( & fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR_NOTRACE( pIPointer->QueryInterface(CLSID_CMarkupPointer, (void **) &pMarkupPointer) );    
    if (hr)
        goto Cleanup;

    pTreeNode = (pMarkupPointer->IsPositioned() ) ? pMarkupPointer->CurrentScope(MPTR_SHOWSLAVE) : NULL;
    
    if (! pTreeNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pFlowLayout = pTreeNode->GetFlowLayout();
    
    if (!pFlowLayout)
    {
        hr = S_OK ;
        goto Cleanup;
    }
    
    pElement = pFlowLayout->ElementOwner();

    Assert(pElement);

    if (! pElement)
        goto Cleanup;

    hr = THR_NOTRACE( pElement->QueryInterface( IID_IHTMLElement, (void **) ppIElement ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+------------------------------------------------------------------------------------
//
// Funcion:   MapToCoorinateEnum()
//
// Synopsis:  Helper function which maps a given COORD_SYSTEM to its corresponding
//            CLayout::COORDINATE_SYSTEM
//           
//-------------------------------------------------------------------------------------

COORDINATE_SYSTEM
MapToCoordinateEnum ( COORD_SYSTEM eCoordSystem )
{   
    COORDINATE_SYSTEM eCoordinate;

    switch( eCoordSystem )
    {
    case COORD_SYSTEM_GLOBAL:   
        eCoordinate = COORDSYS_GLOBAL;
        break;

    case COORD_SYSTEM_PARENT: 
        eCoordinate = COORDSYS_PARENT;
        break;

    case COORD_SYSTEM_CONTAINER:
        eCoordinate = COORDSYS_BOX;
        break;

    case COORD_SYSTEM_CONTENT:
        eCoordinate = COORDSYS_FLOWCONTENT;
        break;

    default:
        AssertSz( FALSE, "Invalid COORD_SYSTEM tag" );
        eCoordinate = COORDSYS_FLOWCONTENT;
    }


    return eCoordinate;
}

//+------------------------------------------------------------------------------------
//
// Method:    TransformPoint
//
// Synopsis:  Exposes CLayout::TransformPoint() to MshtmlEd via DisplayServices
//           
//-------------------------------------------------------------------------------------

HRESULT
CDoc::TransformPoint ( POINT        * pPoint,
                       COORD_SYSTEM eSource,
                       COORD_SYSTEM eDestination,
                       IHTMLElement * pIElement )                        
{
    HRESULT         hr;
    CElement    *   pElement;
    CTreeNode   *   pNode;
    CLayout *       pLayout;

    if (!pPoint || !pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void** ) & pElement ));
    if ( hr )
        goto Cleanup;

    pNode = pElement->GetFirstBranch();
    if ( ! pNode )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pLayout = pNode->GetUpdatedNearestLayout();
    if ( ! pLayout )
    {
        CheckSz(0, "Has no layout ");
        hr = E_FAIL;
        goto Cleanup;
    }

    if( eSource == COORD_SYSTEM_FRAME && eDestination != COORD_SYSTEM_GLOBAL )
    {
        AssertSz(0, "Invalid Transform");
        hr = E_FAIL;
        goto Cleanup;
    }

    g_uiDisplay.DeviceFromDocPixels(pPoint);

    {
        CPoint cpoint( pPoint->x, pPoint->y );
    
        if( eSource == COORD_SYSTEM_FRAME )
        {
            POINT ptOrigin;
        
            //
            // We are transforming from FRAME coordinate systems to GLOBAL coordinate
            // systems.  In this case, simply call GetClientOrigin in order to get the
            // coordinates of the parent frame (if there is one) in Global coords
            // 
            pElement->GetClientOrigin( &ptOrigin );

            pPoint->x += ptOrigin.x;
            pPoint->y += ptOrigin.y;
        }
        else
        {
            //
            // Perform the given transform
            //
            pLayout->TransformPoint( &cpoint, 
                                         MapToCoordinateEnum( eSource ), 
                                         MapToCoordinateEnum( eDestination ),
                                         NULL );
            pPoint->x = cpoint.x;
            pPoint->y = cpoint.y;
        }
    }


    g_uiDisplay.DocPixelsFromDevice(pPoint);

Cleanup:
    RRETURN( hr );

}

//+------------------------------------------------------------------------------------
//
// Method:    TransformRect
//
// Synopsis:  Exposes CLayout::TransformRect() to the editor via IDisplayServices
//           
//-------------------------------------------------------------------------------------

HRESULT
CDoc::TransformRect(RECT            *pRect,
                    COORD_SYSTEM    eSource,
                    COORD_SYSTEM    eDestination,
                    IHTMLElement    *pIElement )                        
{
    HRESULT             hr;
    CElement            *pElement;
    CTreeNode           *pNode;
    CLayout             *pLayout;
    CRect               rectInternal;

    if( !pIElement || !pRect )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    rectInternal.left = pRect->left;
    rectInternal.top = pRect->top;
    rectInternal.right = pRect->right;
    rectInternal.bottom = pRect->bottom;
    
    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void **) &pElement ));
    if ( hr )
        goto Cleanup;

    pNode = pElement->GetFirstBranch();
    if( !pNode )
    {
        AssertSz(0, "No longer in Tree");
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pLayout = pNode->GetUpdatedNearestLayout();
    if ( !pLayout )
    {
        AssertSz(0, "Has no layout ");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Actually perform the transform
    //


    g_uiDisplay.DeviceFromDocPixels(&rectInternal);

    pLayout->TransformRect( &rectInternal, 
                            MapToCoordinateEnum( eSource ), 
                            MapToCoordinateEnum( eDestination ) );

    g_uiDisplay.DocPixelsFromDevice(&rectInternal);

    pRect->left = rectInternal.left;
    pRect->bottom = rectInternal.bottom;
    pRect->top = rectInternal.top;
    pRect->right = rectInternal.right;


Cleanup:
    RRETURN( hr );

}


HRESULT 
CDoc::GetActiveIMM(
    IActiveIMMApp** ppActiveIMM)
{
#ifndef NO_IME
    Assert(ppActiveIMM);

    extern IActiveIMMApp * GetActiveIMM();

    *ppActiveIMM = GetActiveIMM();
    if (*ppActiveIMM)
        (*ppActiveIMM)->AddRef();

    return S_OK;
#else
    return E_FAIL;
#endif
}


// declared in formkrnl.hxx

// MSAA expects GetNodeFromPoint()'s to take pt as COORDSYS_POINT (IE 86011)

CTreeNode *
CDoc::GetNodeFromPoint(
    const POINT &   pt,                              // [in] pt must be in either COORDSYS_BOX or COORDSYS_GLOBAL
    CLayoutContext**ppLayoutContext,                 // [out] layout context the returned tree node was hit in
    BOOL            fGlobalCoordinates,
    POINT *         pptContent /* = NULL */,
    LONG *          plCpMaybe /* = NULL */ ,
    BOOL*           pfEmptySpace /* = NULL */ ,
    BOOL *          pfInScrollbar /* = NULL */,
    CDispNode **    ppDispNode /*= NULL */)
{   
    AssertSz( ppLayoutContext, "Must pass an out param for layout context" );

    CTreeNode *         pTreeNode = NULL;
    
    POINT               ptContent;
    CDispNode *         pDispNode = NULL;
    COORDINATE_SYSTEM   coordSys;
    HITTESTRESULTS      HTRslts;
    HTC                 htcResult = HTC_NO;
    DWORD               dwHTFlags = HT_VIRTUALHITTEST |       // Turn on virtual hit testing
                                    HT_NOGRABTEST |           // Ignore grab handles if they exist
                                    HT_IGNORESCROLL;          // Ignore testing scroll bars                                  

    ptContent = g_Zero.pt;
    *ppLayoutContext = NULL;   

    if( fGlobalCoordinates )
        coordSys = COORDSYS_GLOBAL;    
    else
        coordSys = COORDSYS_BOX;

    //
    //  Do a hit test to figure out what node would be hit by this point.
    //  I know this seems like a lot of work to just get the TreeNode,
    //  but we have to do this. Also, we can't trust the cp returned in
    //  HTRslts. Some day, perhaps we can.
    //

    if( !_view.IsActive() ) 
        goto Cleanup;

    htcResult = _view.HitTestPoint( pt, 
                                    &coordSys,
                                    NULL,
                                    dwHTFlags, 
                                    &HTRslts,
                                    &pTreeNode, 
                                    ptContent, 
                                    &pDispNode,
                                    ppLayoutContext);

Cleanup:
    if( pptContent != NULL )
    {
        pptContent->x = ptContent.x;
        pptContent->y = ptContent.y;
    }

    if( plCpMaybe != NULL )
    {
        *plCpMaybe = HTRslts._cpHit;
    }
    
    if ( pfEmptySpace )
    {
        *pfEmptySpace = HTRslts._fWantArrow;
    }

    if ( ppDispNode )
    {
        *ppDispNode = pDispNode;
    }
    
    return pTreeNode;
}



//+====================================================================================
//
// Method: ScrollPointersIntoView
//
// Synopsis: Given two pointers ( that denote a selection). Do the "right thing" to scroll
//           them into view.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::ScrollPointersIntoView(
    IMarkupPointer *    pStart,
    IMarkupPointer *    pEnd)
{
    HRESULT hr = S_OK;
    CTreeNode* pNode;
    CFlowLayout* pFlowLayout ;
    CMarkupPointer* pPointerInternal = NULL;
    CMarkupPointer* pPointerInternal2 = NULL;
    int cpStart, cpEnd, cpTemp;

    hr = THR( pStart->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal ));
    if ( hr )
        goto Cleanup;

        
    hr = THR( pEnd->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal2 ));
    if ( hr )
        goto Cleanup;
        
    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);
    pFlowLayout = pNode->GetFlowLayout();

    if (pFlowLayout)
    {
        cpStart = pPointerInternal->GetCp();
        cpEnd = pPointerInternal2->GetCp();
        if ( cpStart > cpEnd )
        {
            cpTemp = cpStart ;
            cpStart = cpEnd;
            cpEnd = cpTemp;
        }


        pFlowLayout->ScrollRangeIntoView( cpStart, cpEnd , SP_MINIMAL , SP_MINIMAL);
    }
    
Cleanup:
    RRETURN ( hr );
}

HRESULT
CDoc::ScrollPointerIntoView(
    IMarkupPointer *    pPointer,
    BOOL                fNotAtBOL,
    POINTER_SCROLLPIN   eScrollAmount )
{
    HRESULT hr = S_OK;
    CFlowLayout * pFlowLayout = NULL;
    SCROLLPIN ePin = SP_MINIMAL;
    HTMLPtrDispInfoRec LineInfo;
    CMarkupPointer* pPointerInternal = NULL ;
    CTreeNode* pNode;
    CFlowLayout* pNodeFlow = NULL;
    CSize viewSize;
    
    GetLineInfo( pPointer, fNotAtBOL, &LineInfo );
    

    LONG x, y, delta, height, clipX, clipY;
    x = LineInfo.lXPosition;
    y = LineInfo.lBaseline;
    delta = LineInfo.lLineHeight ;

    GetView()->GetViewSize( & viewSize);
    clipX = viewSize.cx / 4;
    clipY = viewSize.cy / 4;
    
    height = min( (int) LineInfo.lLineHeight , (int) clipY);
    CRect rc( x - min( delta , clipX  ) , y - height, x + min( delta, clipX )  , y + LineInfo.lDescent + 2  );

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointerInternal ));
    if ( hr )
        goto Cleanup;
        
    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);
    if ( pNode )
        pNodeFlow = pNode->GetFlowLayout();
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    switch( eScrollAmount )
    {
        case POINTER_SCROLLPIN_TopLeft:
            ePin = SP_TOPLEFT;
            break;
        case POINTER_SCROLLPIN_BottomRight:
            ePin = SP_BOTTOMRIGHT;
            break;        
        default:
            ePin = SP_MINIMAL;
            break;
    }

    //
    // We always scroll on the _pElemEditContext
    //
    if ( _pElemCurrent )
        pFlowLayout = _pElemCurrent->GetFirstBranch()->GetFlowLayout();

    if ( pFlowLayout && pNodeFlow )
    {            
        TraceTag(( tagViewServicesShowScrollRect, "ScrollRect: left:%ld top:%ld right:%ld bottom:%ld",
                                rc.left, rc.top, rc.right, rc.bottom ));
            
        pNodeFlow->ScrollRectIntoView( rc, ePin , ePin );
    }        
    else
        hr = E_FAIL;
        
Cleanup:        
    return hr;
}

//+====================================================================================
//
// Method: ScrollRectIntoView
//
// Synopsis: Scroll any arbitrary rect into view on a given elemnet.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::ScrollRectIntoView( IHTMLElement* pIElement, RECT rect)
{
    HRESULT hr = S_OK;
    CElement* pElement;

    g_uiDisplay.DeviceFromDocPixels(&rect);
    
    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void**) & pElement ));
    if ( hr )
        goto Cleanup;
        
    
    if ( pElement && pElement->GetFirstBranch() )
    {
        CFlowLayout* pScrollLayout = NULL;        

        pScrollLayout = pElement->GetFirstBranch()->GetFlowLayout();
            
        Assert( pScrollLayout );
        if ( pScrollLayout )
        {   
            pScrollLayout->TransformRect(&rect, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
            {
                CRect r(rect);            
                pScrollLayout->ScrollRectIntoView( r, SP_MINIMAL, SP_MINIMAL );
            }
        }
        else
            hr = E_FAIL;
    }
    else
        hr = E_FAIL;
Cleanup:
    RRETURN( hr );
}



HRESULT 
CDoc::IsSite( 
    IHTMLElement *  pIElement, 
    BOOL*           pfSite, 
    BOOL*           pfText, 
    BOOL*           pfMultiLine, 
    BOOL*           pfScrollable )
{
    HRESULT hr = S_OK;
    CElement * pElement = NULL;
    CTreeNode * pNode = NULL;
    
    BOOL fSite = FALSE;
    BOOL fText = FALSE;
    BOOL fMultiLine = FALSE;
    BOOL fScrollable = FALSE;
    
    if (! pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void**) & pElement ));
    if ( hr )
        goto Cleanup;

    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
        if (!pElement)
        {
            goto Cleanup;
        }

    }

    pNode = pElement->GetFirstBranch();
    if( pNode == NULL )
        goto Cleanup;
        
    fSite = pNode->ShouldHaveLayout();

    if( pfText )
    {
        CFlowLayout * pLayout = NULL;
        pLayout = pNode->HasFlowLayout();

        if( pLayout != NULL )
        {
            fText = TRUE;
            fSite = TRUE;
        }

        if( fText && pfMultiLine )
        {
            fMultiLine = pLayout->GetMultiLine();
        }

        // TODO (johnbed) we may at some point want to break this apart from the flow layout check
        if( fText && pfScrollable )
        {
            CDispNode * pDispNode = pLayout->GetElementDispNode();
            fScrollable = pDispNode && pDispNode->IsScroller();
        }
    }
    
Cleanup:
    if( pfSite )
        *pfSite = fSite;

    if( pfText )
        *pfText = fText;

    if( pfMultiLine )
        *pfMultiLine = fMultiLine;

    if( pfScrollable )
        *pfScrollable = fScrollable;

    RRETURN( hr );
}


//+====================================================================================
//
// Method: QueryBreaks
//
// Synopsis: Returnline break information associated with a given pointer
//
//------------------------------------------------------------------------------------


HRESULT
CDoc::QueryBreaks ( IMarkupPointer * pPointer, DWORD * pdwBreaks, BOOL fWantPendingBreak )
{
    HRESULT             hr;
    CMarkupPointer *    pmpPointer = NULL;
    CLineBreakCompat    breaker;   

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpPointer ) );
    if (hr)
        return hr;

    breaker.SetWantPendingBreak ( fWantPendingBreak );

    return breaker.QueryBreaks( pmpPointer, pdwBreaks );
}

//+====================================================================================
//
// Method: GetCursorForHTC
//
// Synopsis: Gets the Cursor for an HTC value 
//
//------------------------------------------------------------------------------------

LPCTSTR
CDoc::GetCursorForHTC( HTC inHTC )
{
    Assert( inHTC >= HTC_TOPBORDER );
    Assert( inHTC <= HTC_BOTTOMRIGHTHANDLE);

    return astrCursor[inHTC - HTC_TOPBORDER ];
}

//+====================================================================================
//
// Method: CurrentScopeOrSlave
//
// Synopsis: Returns the current scope for a pointer, like CurrentScope; but
//           can also return the slave element
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::CurrentScopeOrSlave ( IMarkupPointer * pPointer, IHTMLElement **ppElemCurrent )
{
    HRESULT hr = S_OK;
    CMarkupPointer *    pmp = NULL;
    CTreeNode * pNode;

    if (!ppElemCurrent)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElemCurrent = NULL;
    
    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    if (hr)
        goto Cleanup;
        
    pNode = pmp->CurrentScope(MPTR_SHOWSLAVE);
    
    if (pNode)
    {
        hr = THR(
            pNode->GetElementInterface(
                IID_IHTMLElement, (void **) ppElemCurrent ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}


//
// IEditDebugServices Methods.
//
#if DBG == 1

//+====================================================================================
//
// Method: GetCp
//
// Synopsis: Gets the CP of a pointer. -1 if it's unpositioned
//
//------------------------------------------------------------------------------------


HRESULT
CDoc::GetCp( IMarkupPointer* pIPointer, long* pcp)
{
    HRESULT hr = S_OK;
    CMarkupPointer* pPointer = NULL;
    long cp = 0;
    
    hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer ));
    if ( hr ) 
        goto Cleanup;

    cp = pPointer->GetCp();
        
Cleanup:
    if ( pcp )
        *pcp = cp;
        
    RRETURN ( hr );
}


//+====================================================================================
//
// Method: SetDebugName
//
// Synopsis: Allows setting of Debug Name on an IMarkupPointer. This name then shows up
//           in DumpTree's.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::SetDebugName( IMarkupPointer* pIPointer, LPCTSTR strDebugName )
{
    HRESULT hr = S_OK;
    CMarkupPointer* pPointer = NULL;

    
    hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer ));
    if ( hr ) 
        goto Cleanup;

    pPointer->SetDebugName( strDebugName);
    
Cleanup:

    RRETURN ( hr );

}

//+====================================================================================
//
// Method: SetDisplaypointerDebugName
//
// Synopsis: Allows setting of Debug Name on an IDisplayPointer. This name then shows up
//           in DumpTree's.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::SetDisplayPointerDebugName( IDisplayPointer* pDispPointer, LPCTSTR strDebugName )
{
    HRESULT hr = S_OK;
    CDisplayPointer* pDispPointerInternal = NULL;

    
    hr = THR( pDispPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pDispPointerInternal ));
    if ( hr ) 
        goto Cleanup;

    pDispPointerInternal->SetDebugName( strDebugName);
    
Cleanup:

    RRETURN ( hr );

}

//+====================================================================================
//
// Method: DumpTree
//
// Synopsis: Calls dumptree on an IMarkupPointer.
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::DumpTree( IMarkupPointer* pIPointer)
{
    HRESULT hr = S_OK;
    CMarkupPointer* pPointer = NULL;
    CMarkup * pMarkup = NULL;

    if (pIPointer)
    {
        hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer ));
        
        if ( hr ) 
            goto Cleanup;

        pMarkup = pPointer->Markup();
    }
    
    if (!pMarkup)
        pMarkup = PrimaryMarkup();

    if (pMarkup)
        pMarkup->DumpTree();
    
Cleanup:

    RRETURN ( hr );
}


//+====================================================================================
//
// Method: LinesInElement
//
// Synopsis: Calls LinesInElement on CElement.
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::LinesInElement(IHTMLElement *pIHTMLElement, long *piLines)
{
    CElement *pElement;
    HRESULT hr = E_INVALIDARG;

    if (!piLines)
        goto Cleanup;
    if(pIHTMLElement)
    {
        hr = THR(pIHTMLElement->QueryInterface(CLSID_CElement, (void **)&pElement));
        if(hr)
            goto Cleanup;
        *piLines = pElement->GetLineCount();
    }

Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: FontsOnLine
//
// Synopsis: Calls FontsOnLine on the CElement.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::FontsOnLine(IHTMLElement *pIHTMLElement, long iLine, BSTR *pbstrFonts)
{
    CElement *pElement;
    HRESULT hr = E_INVALIDARG;
    
    if(pIHTMLElement)
    {
        hr = THR(pIHTMLElement->QueryInterface(CLSID_CElement, (void **)&pElement));
        if (hr)
            goto Cleanup;
        hr = THR(pElement->GetFonts(iLine, pbstrFonts));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method: GetPixel
//
// Synopsis: Gets the pixel value
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::GetPixel(long X, long Y, long *piColor)
{
    HRESULT hr = E_INVALIDARG;

    if (!piColor)
        goto Cleanup;

    if (   _pInPlace
        && _pInPlace->_hwnd
       )
    {
        *piColor = (long)::GetPixel(::GetDC(_pInPlace->_hwnd), X, Y);
    }
    else
    {
        *piColor = long(CLR_INVALID);
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: IsUsingBckgrnRecalc
//
// Synopsis: Determines whether background recalc has been executed.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::IsUsingBckgrnRecalc(BOOL *pfUsingBckgrnRecalc)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pfUsingBckgrnRecalc)
    {
        *pfUsingBckgrnRecalc = _fUsingBckgrnRecalc;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+====================================================================================
//
// Method: IsUsingTableIncRecalc 
//
// Synopsis: Determines whether table incremental recalc has been executed.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::IsUsingTableIncRecalc(BOOL *pfUsingTableIncRecalc)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pfUsingTableIncRecalc)
    {
        *pfUsingTableIncRecalc = _fUsingTableIncRecalc;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+====================================================================================
//
// Method: IsEncodingAutoSelect
//
// Synopsis: Determines whether encoding Auto-Select is on or off.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::IsEncodingAutoSelect(BOOL *pfEncodingAutoSelect)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pfEncodingAutoSelect)
    {
        *pfEncodingAutoSelect = IsCpAutoDetect();
        hr = S_OK;
    }

    RRETURN(hr);
}

//+====================================================================================
//
// Method: EnableEncodingAutoSelect
//
// Synopsis: Enables / disables encoding Auto-Select.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::EnableEncodingAutoSelect(BOOL fEnable)
{
    HRESULT hr = S_OK;

    SetCpAutoDetect(fEnable);
    
    RRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\window2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       window2.cxx
//
//  Contents:   Further implementation of CWindow
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif


DeclareTag(tagPics, "dwn", "Trace PICS processing");
ExternTag(tagSecurityContext);

HRESULT
CWindow::SuperNavigate(BSTR      bstrURL,
                       BSTR      bstrLocation,
                       BSTR      bstrShortcut,
                       BSTR      bstrFrameName,
                       VARIANT * pvarPostData,
                       VARIANT * pvarHeaders,
                       DWORD     dwFlags)
{
    CDoc * pDoc = Doc();
    DWORD  dwFHLFlags = 0;
    SAFEARRAY * pPostDataArray = NULL;
    DWORD cbPostData = 0;
    BYTE * pPostData = NULL;
    TCHAR * pchExtraHeaders = NULL;
    CDwnPost * pDwnPost = NULL;
    HRESULT hr;

    // If we are shutting down or have shut down, don't start a new navigate
    if (pDoc->IsShut())
        return E_FAIL;

    // Lock the Doc!
    CDoc::CLock DocLock(pDoc);

    if (bstrShortcut && IsPrimaryWindow())
    {
        // TODO: (jbeda) this stuff should probably be put on the markup
        // as part of the CMarkupTransNavContext

        HRESULT        hr;
        IPersistFile * pISFile = NULL;

        // create the shortcut object for the provided cachefile
        hr = THR(CoCreateInstance(CLSID_InternetShortcut,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IPersistFile,
                                  (void **)&pISFile));
        if (SUCCEEDED(hr))
        {
            hr = THR(pISFile->Load(bstrShortcut, 0));

            if (SUCCEEDED(hr))
            {
                ClearInterface(&pDoc->_pShortcutUserData);

                hr = THR(pISFile->QueryInterface(IID_INamedPropertyBag,
                                                 (void **)&pDoc->_pShortcutUserData));
                if (!hr)
                {
                    IGNORE_HR(pDoc->_cstrShortcutProfile.Set(bstrShortcut));
                }
            }

            pISFile->Release();
        }
    }

    // We only want to set the _fShdocvwNavigate
    // flag to true if this navigation came from 
    // shdocvw. 
    //
    if (_pMarkup->IsPrimaryMarkup() && !(dwFlags & DOCNAVFLAG_DOCNAVIGATE))
    {
        dwFHLFlags |= CDoc::FHL_SHDOCVWNAVIGATE;
    }

    if ( dwFlags & DOCNAVFLAG_DONTUPDATETLOG )
    {
        dwFHLFlags |= CDoc::FHL_DONTUPDATETLOG; 
    }
    
    _fHttpErrorPage = !!(dwFlags & DOCNAVFLAG_HTTPERRORPAGE);

    if (  dwFlags & DOCNAVFLAG_REFRESH )
    {
        dwFHLFlags |= CDoc::FHL_REFRESH;
    }
    
    // If this is a frame, then indicate it in the call to followhyperlink below
    if (_pWindowParent)
    {
        dwFHLFlags |= CDoc::FHL_FRAMENAVIGATION;
    }

    if (dwFlags & DOCNAVFLAG_HTTPERRORPAGE)
    {
        dwFHLFlags |= CDoc::FHL_ERRORPAGE;
    }

    if (pvarHeaders)
    {
       if ((VT_BSTR | VT_BYREF) == pvarHeaders->vt)
       {
           pchExtraHeaders = *pvarHeaders->pbstrVal;
       }
       else if (VT_BSTR == pvarHeaders->vt)
       {
           pchExtraHeaders = pvarHeaders->bstrVal;
       }
    }

    if (pvarPostData && (VT_ARRAY & pvarPostData->vt))
    {
        if (VT_BYREF & pvarPostData->vt)
        {
            pPostDataArray = *pvarPostData->pparray;
        }
        else
        {
            pPostDataArray = pvarPostData->parray;
        }

        if (pPostDataArray)
        {
            // lock the array for reading, get pointer to data
            hr = SafeArrayAccessData(pPostDataArray, (void **) &pPostData);

            if (SUCCEEDED(hr)) 
            {
                long nElements = 0;
                DWORD dwElemSize;

                // get number of elements in array
                SafeArrayGetUBound(pPostDataArray, 1, (long *) &nElements);
                // SafeArrayGetUBound returns zero-based max index, add one to get element count

                nElements++;
                // get bytes per element
                dwElemSize = SafeArrayGetElemsize(pPostDataArray);

                // bytes per element should be one if we created this array
                Assert(dwElemSize == 1);

                // calculate total byte count anyway so that we can handle
                // safe arrays other people might create with different element sizes
                cbPostData = dwElemSize * nElements;

                if (0 == cbPostData)
                    pPostData = NULL;

                if (pPostData && cbPostData)
                {
                    IGNORE_HR(CDwnPost::Create(cbPostData, pPostData, TRUE, &pDwnPost));
                }
            }
        }
    }

    hr = THR(pDoc->FollowHyperlink(bstrURL,                                 /* pchURL              */
                                   bstrFrameName,                           /* pchTarget           */
                                   NULL,                                    /* pElementContext     */
                                   pDwnPost,                                /* pDwnPost            */
                                   !!pDwnPost,                              /* fSendAsPost         */
                                   pchExtraHeaders,                         /* pchExtraHeaders     */
                                   FALSE,                                   /* fOpenInNewWindow    */
                                   _pMarkup->Window(),                      /* pWindow             */
                                   NULL,                                    /* ppWindowOut         */
                                   0,                                       /* dwBindf             */
                                   ERROR_SUCCESS,                           /* dwSecurityCode      */
                                   FALSE,                                   /* fReplace            */
                                   NULL,                                    /* ppHTMLWindow2       */
                                   dwFlags & DOCNAVFLAG_OPENINNEWWINDOW,    /* fOpenInNewBrowser   */
                                   dwFHLFlags,                              /* dwFlags             */
                                   NULL,                                    /* pchName             */
                                   NULL,                                    /* pStmHistory         */
                                   NULL,                                    /* pElementMaster      */
                                   NULL,                                    /* pchUrlContext       */
                                   NULL,                                    /* pfLocalNavigation   */
                                   NULL,                                    /* pfProtocolNavigates */
                                   bstrLocation                             /* pchLocation         */
                                   ));

    if (pPostDataArray)
    {
        // done reading from array, unlock it
        SafeArrayUnaccessData(pPostDataArray);
    }

    ReleaseInterface(pDwnPost);

    RRETURN(hr);
}


//
//  CWindow::NavigateEx -- IHTMLPrivateWindow2
//
HRESULT
CWindow::NavigateEx(    BSTR        bstrURL, 
                        BSTR        bstrOriginal,
                        BSTR        bstrLocation, 
                        BSTR        bstrContext,
                        IBindCtx*   pBindCtx, 
                        DWORD       dwNavOptions,
                        DWORD       dwFHLFlags)
{
    HRESULT         hr;
    CStr            cstrExpandedUrl;
    CStr            cstrLocation;
    CDwnBindInfo *  pDwnBindInfo    = NULL;
    
    CDoc * pDoc = Doc();

    cstrExpandedUrl.Set(bstrURL);
    cstrLocation.Set(bstrLocation);

    if (pBindCtx)
    {
        TraceTag(( tagSecurityContext, 
                    "CWindow::NavigateEx - Bind context exists. URL: %ws, Context: %ws", 
                    bstrURL, 
                    bstrContext));

        // Retrieve DwnBindInfo from the BindCtx
        {
            IUnknown *pUnk = NULL;
            pBindCtx->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pUnk);
            if (pUnk)
            {
                pUnk->QueryInterface(IID_IDwnBindInfo, (void **)&pDwnBindInfo);
                ReleaseInterface(pUnk);
            }
        }


        hr =  THR(pDoc->DoNavigate(   &cstrExpandedUrl,
                                      &cstrLocation,
                                       pDwnBindInfo,
                                       pBindCtx,
                                       NULL,
                                       NULL,
                                       _pMarkup->Window(),      // Opener window
                                       NULL,
                                       FALSE,
                                       TRUE,
                                       FALSE,
                                       FALSE,
                                       NULL,
                                       TARGET_FRAMENAME,        // target type
                                       dwFHLFlags,              // FHL_* flags
                                       NULL,                    
                                       FALSE,
                                       NULL,
                                       NULL, 
                                       bstrOriginal));
        if (pDwnBindInfo)
        {
            pDwnBindInfo->Release();
        }
    }
    else
    {
        TraceTag(( tagSecurityContext, 
                    "CWindow::NavigateEx - Bind context does not exist. URL: %ws, Context: %ws", 
                    bstrURL, 
                    bstrContext));

        dwFHLFlags |= !!(dwNavOptions & NAVIGATEEX_DONTUPDATETRAVELLOG) ? CDoc::FHL_DONTUPDATETLOG : 0 ;
        
        hr = THR(FollowHyperlinkHelper( bstrURL, 0, dwFHLFlags, bstrContext));
    }

    RRETURN(hr);
}


//
//  CWindow::GetInnerWindowUnknown -- IHTMLPrivateWindow2
//
HRESULT
CWindow::GetInnerWindowUnknown(IUnknown** ppUnknown)
{
    HRESULT hr = E_FAIL;

    *ppUnknown = NULL;

    if (_punkViewLinkedWebOC)
    {
        COmWindowProxy * pOmWindowProxy = GetInnerWindow();

        if (pOmWindowProxy)
            hr = pOmWindowProxy->QueryInterface(IID_IUnknown, (void **) ppUnknown);
    }

    RRETURN1(hr, E_FAIL);
}

//  
//  CWindow::OpenEx -- IHTMLPrivateWindow3
//
HRESULT
CWindow::OpenEx(BSTR url, 
                BSTR urlContext, 
                BSTR name, 
                BSTR features, 
                VARIANT_BOOL replace, 
                IHTMLWindow2 ** ppWindow)
{
    HRESULT         hr;

    // copy the feature string, to be provided to shdocvw on demand.
    // FilterOutFeaturesString expects a non-null string.
    if( features && *features )
    {
        hr = THR(FilterOutFeaturesString(features, &_cstrFeatures));
        if (hr)
            goto Cleanup;
    }

    // Process name and return an error code if
    // the target name contains invalid characters.
    // This is for compatibility with IE5 and earlier.
    //
    if (name)
    {
        // Make sure we have a legal name
        for (int i = 0; i < lstrlenW(name); i++)
        {
            if (!(IsCharAlphaNumeric(name[i]) || _T('_') == name[i]))
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
    }
    
    _fOpenInProgress = TRUE;

    TraceTag((tagSecurityContext, "CWindow::open - URL: %ws", url));
    
    hr = THR(SetErrorInfo(Doc()->FollowHyperlink(url,                                                       // pchURL
                                                 name,                                                      // pchTarget
                                                 NULL,                                                      // pElementContext
                                                 NULL,                                                      // pDwnPost
                                                 FALSE,                                                     // fSendAsPost
                                                 NULL,                                                      // pchExtraHeaders
                                                 FALSE,                                                     // fOpenInNewWindow
                                                 _pMarkup->Window(),                                        // pWindow
                                                 NULL,                                                      // ppWindowOut
                                                 0,                                                         // dwBindOptions
                                                 ERROR_SUCCESS,                                             // dwSecurityCode
                                                 replace != VARIANT_FALSE,                                  // fReplace
                                                 ppWindow,                                                  // ppHTMLWindow2
                                                 FALSE,                                                     // fOpenInNewBrowser
                                                 ( VARIANT_TRUE == replace ) ? CDoc::FHL_DONTUPDATETLOG : 0,// dwFlags
                                                 NULL,                                                      // pchName
                                                 NULL,                                                      // pStmHistory
                                                 NULL,                                                      // pElementMaster
                                                 urlContext                                                 // pchUrlContext
                                                 )));
                                                 
    _fOpenInProgress = FALSE;

Cleanup:
    // The features string must be cleared here in order to 
    // avoid using the wrong features if the user shift-clicks 
    // on a link to open a new window. Clearing of the features
    // string here is dependent on the fact that the opening of 
    // the new window via OpenInNewWindow() is synchronous.
    //
    _cstrFeatures.Free();

    RRETURN(hr);
}


HRESULT
CWindow::GetAddressBarUrl(BSTR * pbstrURL)
{
    HRESULT hr = S_OK;
    CStr    cstrRetString;
    TCHAR   achUrl[pdlUrlLen];
    DWORD   dwLength = ARRAY_SIZE(achUrl);
    TCHAR * pchUrl;    

    if (!pbstrURL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrURL = NULL;

    hr = Document()->GetMarkupUrl(&cstrRetString, TRUE);
    if (hr)
        goto Cleanup;

    // In IE5, file protocols did not display %20 in the address bar.
    if (GetUrlScheme(cstrRetString) == URL_SCHEME_FILE)
    {
        if (!InternetCanonicalizeUrl(cstrRetString, achUrl, &dwLength,
                                     ICU_NO_ENCODE | ICU_DECODE | URL_BROWSER_MODE))
        {
            goto Cleanup;
        }
        pchUrl = achUrl;
    }
    else 
    {
        pchUrl = cstrRetString;
    }

    *pbstrURL = SysAllocString(pchUrl);

Cleanup:
    RRETURN(hr);
}


HRESULT
CWindow::GetPendingUrl(LPOLESTR* pstrURL)
{
    HRESULT hr = E_INVALIDARG;

    if (_pMarkupPending && _pMarkupPending->HasUrl())
    {
        TCHAR * pchUrl = _pMarkupPending->Url();

        hr = TaskAllocString( pchUrl, pstrURL );
        if (hr)
            goto Cleanup;

        TraceTag((tagPics, "CWindow::GetPendingUrl returning \"%S\"", *pstrURL));

        hr = S_OK;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CWindow::SetPICSTarget(IOleCommandTarget* pctPICS)
{
    HRESULT hr = E_INVALIDARG;

    TraceTag((tagPics, "CWindow::SetPICSTarget(%x)", pctPICS));

    if( _pMarkupPending )
    {
        hr = THR(_pMarkupPending->SetPicsTarget(pctPICS));
    }

    RRETURN(hr);
}

HRESULT
CWindow::PICSComplete(BOOL fApproved)
{
    TraceTag((tagPics, "CWindow::PICSComplete(%x)", fApproved));

    Assert( _pMarkupPending && !_pMarkupPending->GetPicsTarget() );

    // We should have gotten quite a few asserts before this point
    // This isn't perforance critical so lets at least not crash.
    if (_pMarkupPending)
    {
        _pMarkupPending->_fPicsProcessPending = FALSE;

        if (fApproved)
        {
            _pMarkupPending->_pHtmCtx->ResumeAfterScan();
        }
        else
        {
            ReleaseMarkupPending(_pMarkupPending);

            // Reset the URL on the window so 
            // that refresh won't load the page!
            if (_pMarkup->_fPICSWindowOpenBlank)
            {
                CMarkup::SetUrl(_pMarkup, NULL);
            }
        }
    }

    return S_OK;
}

HRESULT
CWindow::FindWindowByName(LPCOLESTR       pstrTargetName,
                          IHTMLWindow2 ** ppWindow)
{
    Assert(pstrTargetName);
    Assert(ppWindow);

    return FindWindowByName(pstrTargetName, NULL, ppWindow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\wscript.cxx ===
//+------------------------------------------------------------------------
//
//  File:       wscript.cxx
//
//  Contents:   CDoc deferred-script execution support.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#define SCRIPTSDEFERDELAY 113

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsInScript
//
//  Synopsis:   TRUE if we are in a script
//
//--------------------------------------------------------------------

BOOL 
CWindow::IsInScript()
{
    // If we are in a script - then IsInScript is true.  NOTE: we aggregate
    // our scriptnesting with those of our children
    return (_cScriptNesting > 0) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnterScript
//
//  Synopsis:   Note that we are inside a script
//
//--------------------------------------------------------------------

HRESULT 
CWindow::EnterScript()
{
    HRESULT hr = S_OK;

    _cScriptNesting++;

    CDoc* pDoc = Doc();
    Assert(pDoc);

    pDoc->_cScriptNestingTotal++;

    //  Fire off Exec (this will go up the frame hierarchy) to indicate that
    //  SHDOCVW should not retry deactivating any docobjects whose deactivation was
    //  deferred due to a child being in script code.
        //  Quickly forward this up to command target of our clientsite
        //  this is how we tell SHDOCVW to try to activate any view whose
        //  activation was deferred while some frame was in a script.  as
        //  a script that is executing blocks activation of any parent frame
        //  this has to (potentially) be forwarded all the way up to browser
        //  window

    if (_cScriptNesting > 15)
    {
        hr = VBSERR_OutOfStack;
        _fStackOverflow = TRUE;
        goto Cleanup;
    }

    if (_cScriptNesting == 1)
    {
        // Initialize error condition flags/counters.
        _fStackOverflow = FALSE;
        _fOutOfMemory = FALSE;
        _fEngineSuspended = FALSE;
        _badStateErrLine = 0;

        // Start tracking total number of script statements executed
        _dwTotalStatementCount = 0;

        pDoc->_fEngineSuspended = FALSE;
        pDoc->UpdateFromRegistry();

        // Initialize the max statement count from default
        _dwMaxStatements = pDoc->_pOptionSettings->dwMaxStatements;
        
        _fUserStopRunawayScript = FALSE;
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::LeaveScript
//
//  Synopsis:   Note that we are leaving a script
//
//--------------------------------------------------------------------

HRESULT 
CWindow::LeaveScript()
{
    HRESULT hr = S_OK;

    Assert(_cScriptNesting > 0);

    if (_cScriptNesting == 0)
        return E_FAIL;

    _cScriptNesting--;

    CDoc* pDoc = Doc();
    if (pDoc)
        pDoc->_cScriptNestingTotal--;

    if (_cScriptNesting == 0)
    {
        // Clear accumulated count of statements
        _dwTotalStatementCount = 0;
        _dwMaxStatements = 0;

        // Reset the user's inputs so that other scripts may execute
        _fUserStopRunawayScript = FALSE;

        if (_fStackOverflow || _fOutOfMemory)
        {
            // Bring up a simple dialog box for stack overflow or
            // out of memory.  We don't have any room to start up
            // the parser and create an HTML dialog as OnScriptError
            // would do.
            TCHAR   achBuffer[256];

            Format(0,
                   achBuffer,
                   ARRAY_SIZE(achBuffer),
                   _T("<0s> at line: <1d>"),
                   _fStackOverflow ? _T("Stack overflow") : _T("Out of memory"),
                   _badStateErrLine);

            alert(achBuffer);
        }
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::QueryContinueScript
//
//  Synopsis:   See if the current script fragment has been executing
//              for too long.
//
//--------------------------------------------------------------------

HRESULT CWindow::QueryContinueScript( ULONG ulStatementCount )
{
    // If the user has already made a decision about aborting or
    // continuing the script, repeat that answer until all presently
    // running scripts are dead.
    if (_fUserStopRunawayScript)
        return E_ABORT;

    // it is possible that this call get's reentered while we are 
    // currently displaying the ContinueScript dialog
    // prevent popping up another dialog and continue to run the 
    // scripts until the user decided on the first one (frankman&GaryBu)
    if (_fQueryContinueDialogIsUp)
        return S_OK;
    
    // Accumulate the statement  since we were last called
    _dwTotalStatementCount += ulStatementCount;

    // rgardner, for now it seems sensible not to factor in time. Many OCXs
    // for instance will take ages to do their job, but only take one
    // statement to do so.

    if (_dwTotalStatementCount > _dwMaxStatements)
    {
        int iUserResponse;
        TCHAR achMsg[256];
        CDoc *pDoc = Doc();

        _fQueryContinueDialogIsUp = TRUE;
        
        IGNORE_HR(Format(0, achMsg, ARRAY_SIZE(achMsg), MAKEINTRESOURCE(IDS_RUNAWAYSCRIPT)));
        pDoc->ShowMessageEx( &iUserResponse, MB_ICONEXCLAMATION | MB_YESNO, NULL, 0, achMsg );

        _fQueryContinueDialogIsUp = FALSE;
            

        if (iUserResponse == IDYES)
        {
            _fUserStopRunawayScript = TRUE;
            return E_ABORT;
        }
        else
        {
            _dwTotalStatementCount = 0;
            // User has chosen to continue execution, increase the interval to the next
            // warning
            if (_dwMaxStatements < ((DWORD)-1)>>3)
                _dwMaxStatements <<= 3;
            else
                _dwMaxStatements = (DWORD)-1;
        }
    }
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::IsInScriptExecution
//
//  Synopsis:   TRUE if we are executing a script now
//
//--------------------------------------------------------------------

BOOL CMarkup::IsInScriptExecution()
{
    return HasScriptContext() ? (ScriptContext()->_cScriptExecution > 0) : FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::EnterScriptExecution
//
//--------------------------------------------------------------------

HRESULT 
CMarkup::EnterScriptExecution(CWindow **ppWindow)
{
    HRESULT                 hr;
    CMarkup *               pMarkup;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    // inline script contributes twice to _cScriptExecution
    pMarkup = GetWindowedMarkupContext();
    Assert(pMarkup);
    Assert(pMarkup->GetWindowPending());

    Assert(ppWindow);
    *ppWindow = pMarkup->HasWindowPending() ? pMarkup->GetWindowPending()->Window() : NULL;

    if (*ppWindow)
    {
        hr = THR((*ppWindow)->EnterScript());
        if (hr)
            goto Cleanup;
    }

    pScriptContext->_cScriptExecution++;
    
Cleanup:
    RRETURN(hr); 
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::LeaveScriptExecution
//
//  Synopsis:   Note that we are leaving an inline script
//
//--------------------------------------------------------------------

HRESULT 
CMarkup::LeaveScriptExecution(CWindow *pWindow)
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = ScriptContext();
  
    Assert(pWindow);
    Assert(pScriptContext || !_fLoaded);
    
    if (pScriptContext && pScriptContext->_cScriptExecution == 1)
    {
        // Before leaving top-level execution, commit queued
        // scripts. (may block parser)
        hr = THR(CommitQueuedScripts());
        if (hr)
            goto Cleanup;
    }
        
    // inline script contributes twice to _cScriptNesting
    Assert(!GetWindowedMarkupContext()->HasWindowPending() || GetWindowedMarkupContext()->GetWindowPending()->Window() == pWindow);

    if (pWindow)
    {
        hr = THR(pWindow->LeaveScript());
        if (hr)
            goto Cleanup;
    }

    if( pScriptContext )
        pScriptContext->_cScriptExecution--;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::AllowScriptExecution
//
//  Synopsis:   Return whether inline scripts are allowed to be
//              parsed.
//
//--------------------------------------------------------------------

BOOL
CMarkup::AllowScriptExecution()
{
    // script parsing contexts are always alowed to Execute if we are
    // already running inside an inline script (note: the script parsing
    // context knows to queue nested <SCRIPT SRC=*> tags for actual
    // execution after the outermost script is finished).
    if (IsInScriptExecution())
        return TRUE;

    // Otherwise, we're at the top level
    return AllowImmediateScriptExecution();
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::AllowImmediateScriptExecution
//
//  Synopsis:   Return whether scripts are allowed to be committed.
//
//--------------------------------------------------------------------
BOOL
CMarkup::AllowImmediateScriptExecution()
{
    // No Execute is allowed while we are not inplace
    if (_pDoc->_fNeedInPlaceActivation &&
        !IsPrintMedia() &&
        (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE) &&
        _pDoc->State() < OS_INPLACE)
        return FALSE;
        
    // No Execute is allowed while we are downloading script
    if (HasScriptContext() && ScriptContext()->_cScriptDownload)
		return FALSE;

    // CONSIDER: (jbeda) this whole _fBindResultPending thing seems shady...

    // ... or we have a pending window
    // The BindResult is E_PENDING for unknown Mime types, in which case, this temporary markup
    // will be released, but we need to allow execution to get to OnParseStatusDone
    if (_fWindowPending && !_fBindResultPending) 
        return FALSE;

    // ... or if our windowed markup context is not ready
    CMarkup * pMarkupContext = GetWindowedMarkupContext();
    if (    pMarkupContext 
        &&  pMarkupContext != this
        &&  !pMarkupContext->AllowScriptExecution() )
    {
        return FALSE;
    }

    // Normally inline script can be run
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::BlockScriptExecutionHelper
//
//  Synopsis:   Sleeps the CHtmLoadCtx and sets things up to
//              wait until script execution is allowed again
//
//--------------------------------------------------------------------

HRESULT
CMarkup::BlockScriptExecutionHelper()
{
    HRESULT                 hr;
    BOOL                    fRequestInPlaceActivation = FALSE;
    BOOL                    fGoInteractive = FALSE;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    Assert(!pScriptContext->_fScriptExecutionBlocked);
    Assert(!AllowImmediateScriptExecution());

    // First make sure our windowed markup context is ready for us
    {
        CMarkup * pMarkupContext = GetWindowedMarkupContext();
        if (    pMarkupContext 
            &&  pMarkupContext != this
            &&  !pMarkupContext->AllowScriptExecution())
        {
            BOOL fParentBlocked = FALSE;

            CMarkupScriptContext *  pScriptContextParent;
            hr = THR( pMarkupContext->EnsureScriptContext(&pScriptContextParent) );
            if (hr)
                goto Cleanup;

            if (!pScriptContextParent->_fScriptExecutionBlocked)
            {
                // Block the parent
                pMarkupContext->BlockScriptExecutionHelper();

                if (!pMarkupContext->AllowScriptExecution())
                    fParentBlocked = TRUE;
            }
            else
            {
                fParentBlocked = TRUE;
            }

            if (fParentBlocked)
            {
                // Block ourselves
                pScriptContext->_fScriptExecutionBlocked = TRUE;
            
                // Make sure we get notified when the parent is unblocked
                pScriptContextParent->RegisterMarkupForScriptUnblock( this );
            }
        }
    }

    // If we're not inplace active or have a pending window, request inplace activation
    if (    _pDoc->_fNeedInPlaceActivation 
        &&  (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE) 
        &&  _pDoc->State() < OS_INPLACE)
    {
        fRequestInPlaceActivation = TRUE;
        pScriptContext->_fScriptExecutionBlocked = TRUE;
    }
    
    // If we're waiting on script to download
    if (pScriptContext->_cScriptDownload)
    {
        pScriptContext->_fScriptExecutionBlocked = TRUE;
    }

    if (_fWindowPending && !_fBindResultPending)
    {
        fGoInteractive = TRUE;
        pScriptContext->_fScriptExecutionBlocked = TRUE;
    }

    // We might not be blocked at this point if we
    // tried our windowed markup context and it was
    // able to unblock immediately.
    if (!pScriptContext->_fScriptExecutionBlocked)
        goto Cleanup;

    SuspendDownload();

    if (fRequestInPlaceActivation)
    {
        hr = THR(_pDoc->RegisterMarkupForInPlace(this));
        if (hr)
            goto Cleanup;
    }

    if (fGoInteractive || fRequestInPlaceActivation)
    {
        // No more pics allowed.
        if (IsPrimaryMarkup() && _pDoc->_fStartup)
        {
            ProcessMetaPicsDone();
        }

        // Request in-place activation by going interactive
        RequestReadystateInteractive(TRUE);
    }

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::UnblockScriptExecutionHelper
//
//--------------------------------------------------------------------

HRESULT
CMarkup::UnblockScriptExecutionHelper()
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = ScriptContext();

    // If we were blocking execution of inline script, unblock
    if (pScriptContext && pScriptContext->_fScriptExecutionBlocked && AllowScriptExecution())
    {
        pScriptContext->_fScriptExecutionBlocked = FALSE;
        ResumeDownload();
    }
    
    // If we are outside of inline script when we discover
    // we are in-place, ensure execution of any queued
    // scripts which may have been waiting
    // (may reblock parser)
    if (!pScriptContext || pScriptContext->_cScriptExecution == 0)
    {
        hr = THR(CommitQueuedScriptsInline());
        if (hr)
            goto Cleanup;
    }

    if (pScriptContext)
    {
        pScriptContext->NotifyMarkupsScriptUnblock();
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::RegisterMarkupForInPlace
//
//--------------------------------------------------------------------

HRESULT
CDoc::RegisterMarkupForInPlace(CMarkup * pMarkup)
{
    HRESULT     hr;

    // assert that the markup is not registered already
    Assert (-1 == _aryMarkupNotifyInPlace.Find(pMarkup));

    hr = _aryMarkupNotifyInPlace.Append(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::UnregisterMarkupForInPlace
//
//--------------------------------------------------------------------

HRESULT
CDoc::UnregisterMarkupForInPlace(CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;

    _aryMarkupNotifyInPlace.DeleteByValue(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::NotifyMarkupsInPlace
//
//--------------------------------------------------------------------

HRESULT
CDoc::NotifyMarkupsInPlace()
{
    HRESULT     hr = S_OK;
    int         c;
    CMarkup *   pMarkup;

    while (0 != (c = _aryMarkupNotifyInPlace.Size()))
    {
        pMarkup = _aryMarkupNotifyInPlace[c - 1];

        _aryMarkupNotifyInPlace.Delete(c - 1);

        hr = THR(pMarkup->UnblockScriptExecutionHelper());
        if (hr)
            break;

        // schedule flushing the peer tasks queue. Flushing should be posted, not synchronous,
        // so to allow shdocvw to connect to the doc fully before we start attaching peers
        // and possible firing events to shdocvw (e.g. errors)
        IGNORE_HR(GWPostMethodCall(
            pMarkup,
            ONCALL_METHOD(CMarkup, ProcessPeerTasks, processpeertasks),
            0, FALSE, "CMarkup::ProcessPeerTasks"));
    }
    Assert (0 == _aryMarkupNotifyInPlace.Size());

    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::RegisterMarkupForModelessEnable
//
//--------------------------------------------------------------------

HRESULT
CDoc::RegisterMarkupForModelessEnable(CMarkup * pMarkup)
{
    HRESULT     hr;

    // assert that the markup is not registered already
    Assert (-1 == _aryMarkupNotifyEnableModeless.Find(pMarkup));

    hr = _aryMarkupNotifyEnableModeless.Append(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::UnregisterMarkupForModelessEnable
//
//--------------------------------------------------------------------

HRESULT
CDoc::UnregisterMarkupForModelessEnable(CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;

    _aryMarkupNotifyEnableModeless.DeleteByValue(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::NotifyMarkupsModelessEnable
//
//--------------------------------------------------------------------

MtDefine(NotifyMarkupsModelessEnable_aryMarkupNotifyEnableModelessLocal, Locals, "NotifyMarkupsModelessEnable aryMarkupNotifyEnableModelessLocal")
DECLARE_CStackPtrAry(CAryMarkupNotifyEnableModelessLocal, CMarkup*, 32, Mt(Mem), Mt(NotifyMarkupsModelessEnable_aryMarkupNotifyEnableModelessLocal))

HRESULT
CDoc::NotifyMarkupsModelessEnable()
{
    HRESULT     hr = S_OK;
    int         i, n;
    CMarkup *   pMarkup;
    CAryMarkupNotifyEnableModelessLocal aryMarkupNotifyEnableModelessLocal;

    // NOTE: (jbeda)
    // We want to kick all of the markups that are waiting for
    // modeless to be enabled.  We keep one master list for the CDoc
    // to make this as easy as possible.  We copy all eligibale markups
    // to a seperate array and remove them as we go.  We then kick each
    // of these markups.  We repeat until all markups on the master list
    // are not eligiable.

    do
    {
        // Phase 1: copy to the temp array and remove for master list if elegiable
        aryMarkupNotifyEnableModelessLocal.SetSize(0);

        for (i = _aryMarkupNotifyEnableModeless.Size() - 1; i >= 0; i--)
        {
            pMarkup = _aryMarkupNotifyEnableModeless[i];
            if (pMarkup->CanNavigate())
            {
                hr = aryMarkupNotifyEnableModelessLocal.Append(pMarkup);
                if (hr)
                    goto Error;

                pMarkup->PrivateAddRef();

                _aryMarkupNotifyEnableModeless.Delete(i);
            }
        }

        // Phase 2: call every markup on the list
        for (i = 0, n = aryMarkupNotifyEnableModelessLocal.Size(); i < n; i++)
        {
            pMarkup = aryMarkupNotifyEnableModelessLocal[i];

            if (pMarkup->_fInteractiveRequested)
            {
                pMarkup->_fInteractiveRequested = FALSE;
                pMarkup->RequestReadystateInteractive(FALSE);
            }

            pMarkup->PrivateRelease();
        }
    }
    while (n != 0);

Cleanup:
    RRETURN(hr);

Error:
    // Error during the populate phase has to cause us to
    // release all of the markups
    for (i = 0, n = aryMarkupNotifyEnableModelessLocal.Size(); i < n; i++)
    {
        pMarkup = aryMarkupNotifyEnableModelessLocal[i];
        pMarkup->PrivateRelease();
    }
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::BlockScriptExecution
//
//--------------------------------------------------------------------

void
CMarkup::BlockScriptExecution(DWORD * pdwCookie)
{
    HRESULT                 hr;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    if (!pdwCookie || !(*pdwCookie))
    {
        if (pdwCookie)
        {
            *pdwCookie = TRUE;
        }

        pScriptContext->_cScriptDownload++;
    }

Cleanup:
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::UnblockScriptExecution
//
//  Synopsis:   Unblock script if we were waiting for script
//              download to run script.
//
//--------------------------------------------------------------------

HRESULT
CMarkup::UnblockScriptExecution(DWORD * pdwCookie)
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = HasScriptContext() ? ScriptContext() : NULL;
    
    if (pScriptContext && (!pdwCookie || *pdwCookie))
    {
        Assert (pScriptContext);

        if (pdwCookie)
        {
            *pdwCookie = FALSE;
        }

        pScriptContext->_cScriptDownload--;

        hr = THR(UnblockScriptExecutionHelper());
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnqueueScriptToCommit
//
//  Synopsis:   Remember an inline script (with SRC=*) which needs
//              to be committed before unblocking the parser.
//
//              This happens when a script with SRC=* is written
//              by an inline script.
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnqueueScriptToCommit(CScriptElement *pelScript)
{
    HRESULT                 hr;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    hr = THR(pScriptContext->_aryScriptEnqueued.Append(pelScript));
    if (hr)
        goto Cleanup;

    pelScript->AddRef();

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::CommitQueuedScripts
//
//  Synopsis:   Execute saved up scripts
//
//              Must be called from within EnterScriptExecution/LeaveScriptExecution
//
//--------------------------------------------------------------------

HRESULT
CMarkup::CommitQueuedScripts()
{
    HRESULT                 hr = S_OK;
    CScriptElement *        pelScript = NULL;
    CMarkupScriptContext *  pScriptContext = ScriptContext();

    Assert(pScriptContext->_cScriptExecution == 1);

continue_label:

    while (pScriptContext->_aryScriptEnqueued.Size() && AllowImmediateScriptExecution())
    {
        pelScript = pScriptContext->_aryScriptEnqueued[0];
        
        pScriptContext->_aryScriptEnqueued.Delete(0);

        hr = THR(pelScript->CommitCode());
        if (hr)
            goto Cleanup;

        pelScript->Release();
        pelScript = NULL;
    }

    if (pScriptContext->_aryScriptEnqueued.Size() && !pScriptContext->_fScriptExecutionBlocked)
    {
        Assert(!AllowImmediateScriptExecution());
        hr = THR(BlockScriptExecutionHelper());
        if (hr)
            goto Cleanup;
        if (AllowImmediateScriptExecution())
            goto continue_label;
    }
        
Cleanup:
    if (pelScript)
        pelScript->Release();
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::CommitQueuedScriptsInline
//
//  Synopsis:   Execute saved up scripts
//
//              Does the EnterScriptExecution/LeaveScriptExecution so that inline
//              scripts can be executed from the outside
//              CHtmScriptParseCtx::Execute.
//
//--------------------------------------------------------------------

HRESULT
CMarkup::CommitQueuedScriptsInline()
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2;
    CWindow *               pWindow = NULL;
    CMarkupScriptContext *  pScriptContext = ScriptContext();
    
    // optimization: nothing to do if there are no queued scripts
    if (!pScriptContext || !pScriptContext->_aryScriptEnqueued.Size())
        goto Cleanup;

    hr = THR(EnterScriptExecution(&pWindow));
    if (hr)
        goto Cleanup;

    hr2 = THR(CommitQueuedScripts());

    hr = THR(LeaveScriptExecution(pWindow));
    if (hr2)
        hr = hr2;
        
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DeferScript
//
//----------------------------------------------------------------------------

HRESULT
CDoc::DeferScript(CScriptElement * pScript)
{
    HRESULT     hr;
    BOOL        fAllow;
    CMarkup    *pMarkup = pScript->GetMarkupPtr();

    hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;

    pScript->AddRef();
    pScript->_fDeferredExecution = !pMarkup->_fMarkupServicesParsing;

    hr = THR(_aryElementDeferredScripts.Append(pScript));
    if (hr)
        goto Cleanup;

    if (!_fDeferredScripts)
    {
        _fDeferredScripts = TRUE;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CommitDeferredScripts
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CommitDeferredScripts(BOOL fEarly, CMarkup *pContextMarkup /* == NULL */)
{
    HRESULT             hr = S_OK;
    int                 i;
    BOOL                fLeftSome = FALSE;

    if (!_fDeferredScripts)
        return S_OK;

    Assert(pContextMarkup);

    // Loop is structured inefficiently on purpose: we need to withstand
    // _aryElementDefereedScripts growing/being deleted in place
    
    for (i = 0; i < _aryElementDeferredScripts.Size(); i++)
    {
        CScriptElement *pScript = _aryElementDeferredScripts[i];
        
        if (pScript)
        {
            BOOL fCommitCode = (pScript->GetMarkup() == pContextMarkup);

            if (fEarly && pScript->_fSrc)
            {
                fLeftSome = TRUE;
            }
            else if (fCommitCode || !pScript->_fDeferredExecution)
            {
                _aryElementDeferredScripts[i] = NULL;
                
                Assert(!pScript->_fDeferredExecution || fCommitCode);
                pScript->_fDeferredExecution = FALSE;
                if (fCommitCode)
                    IGNORE_HR(pScript->CommitCode());
                pScript->Release();
            }
            else
            {
                fLeftSome = TRUE;
            }
        }
    }

    if (!fLeftSome)
    {
        _fDeferredScripts = FALSE;
        _aryElementDeferredScripts.DeleteAll();
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CommitScripts
//
//  Synopsis:   hooks up scripts 
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CommitScripts(CMarkup *pMarkup, CBase *pelTarget, BOOL fHookup)
{
    HRESULT             hr = S_OK;
    CScriptElement *    pScript;
    int                 cScripts;
    int                 iScript;
    BOOL                fAllow;
    CCollectionCache *  pCollectionCache;
    CMarkup *           pMarkupTarget = pMarkup;

    // TODO (JHarding): Millenium system restore keeps pumping messages to us after they've closed
    // us.  This will prevent us from crashing.
    if( IsShut() )
        goto Cleanup;

    if (!pMarkupTarget || !pMarkupTarget->_fHasScriptForEvent)
        goto Cleanup;
        
    hr = THR(pMarkupTarget->EnsureCollectionCache(CMarkup::SCRIPTS_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = pMarkupTarget->CollectionCache();

    cScripts = pCollectionCache->SizeAry(CMarkup::SCRIPTS_COLLECTION);
    if (!cScripts)
        goto Cleanup;

    hr = THR(pMarkupTarget->ProcessURLAction(URLACTION_SCRIPT_RUN, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;

    // iterate through all scripts in doc's script collection
    for (iScript = 0; iScript < cScripts; iScript++)
    {
        CElement *pElemTemp;

        hr = THR(pCollectionCache->GetIntoAry (CMarkup::SCRIPTS_COLLECTION, iScript, &pElemTemp));
        if (hr)
            goto Cleanup;

        pScript = DYNCAST(CScriptElement, pElemTemp);

        Assert (ETAG_SCRIPT == pElemTemp->Tag());

        if (!pScript->_fScriptCommitted || pelTarget)
            IGNORE_HR(pScript->CommitFunctionPointersCode(pelTarget, fHookup));
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\xbag.cxx ===
//---------------------------------------------------------------------
//
//   File:      xbag.cxx
//
//  Contents:   Xfer objects for selection and generic use
//
//  Classes:    CDropSource, CDummyDropSource, CBaseBag, CGenDataObject,
//              CEnumFormatEtc:
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_DRAGDROP_HXX_
#define X_DRAGDROP_HXX_
#include "dragdrop.hxx"
#endif

#ifndef X_SHLOBJ_H_
#define X_SHLOBJ_H_
#include <shlobj.h>
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

DeclareTagOther(tagIgnorePrivateCF, "FormKrnl", "Disable private CF's")

MtDefine(CDummyDropSource, ObjectModel, "CDummyDropSource")
MtDefine(CGenDataObject, ObjectModel, "CGenDataObject")
MtDefine(CGenDataObject_rgfmtc_pv, CGenDataObject, "CGenDataObject::_rgfmtc::_pv")
MtDefine(CGenDataObject_rgstgmed_pv, CGenDataObject, "CGenDataObject::_rgstgmed::_pv")
MtDefine(CEnumFormatEtc, ObjectModel, "CEnumFormatEtc")
MtDefine(CEnumFormatEtc_prgFormats, ObjectModel, "CEnumFormatEtc::_prgFormats")

//  NOTE that IFMTETC_PRIVATEFMT should be the first of our formats.
//    Other code in this file relies on this

#define IFMTETC_PRIVATEFMT  2
#define IFMTETC_CLSIDFMT    2
#define IFMTETC_PRIVTEXTFMT 3

// List of formats offered by our data transfer object via EnumFormatEtc
// NOTE: g_acfOleClipFormat is a global array of stock formats defined in
//       cdutil\dvutils.cxx and initialized in the Form class factory

// NOTE that the first two formats have the index to their clipformat
// rather than the actual clip format.  This value will be replaced in
// the call to InitFormClipFormats

static FORMATETC g_aGetFmtEtcs[] =
{
    { CF_COMMON(ICF_EMBEDSOURCE), NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE },
    { CF_COMMON(ICF_OBJECTDESCRIPTOR), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_COMMON(ICF_FORMSCLSID), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL},     //  IFMTETC_CLSIDFMT
    { CF_COMMON(ICF_FORMSTEXT), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL},      //  IFMTETC_PRIVTEXTFMT
};


//+---------------------------------------------------------------------------
//
//  Function:   InitFormClipFormats
//
//  Synopsis:   Set registered clip formats into g_aGetFmtEtcs.
//
//----------------------------------------------------------------------------

void
InitFormClipFormats( )
{
    SetCommonClipFormats(g_aGetFmtEtcs, ARRAY_SIZE(g_aGetFmtEtcs));
}


//+-------------------------------------------------------------------------
//
//  Function:   GetcfCLSIDFmt
//
//  Synopsis:   Attempt to retrieve our private CLSID clipboard format
//              information from the given data object.  If it is not
//              available this function returns an error.
//
//--------------------------------------------------------------------------

HRESULT
GetcfCLSIDFmt(LPDATAOBJECT pDataObj, TCHAR * tszClsid)
{
    HRESULT     hr;
    STGMEDIUM   stgmedium;
    TCHAR *     pszText;

    stgmedium.tymed = TYMED_HGLOBAL;
    stgmedium.hGlobal = NULL;
    stgmedium.pUnkForRelease = NULL;

    hr = pDataObj->GetData(&g_aGetFmtEtcs[IFMTETC_CLSIDFMT], &stgmedium);
    if (hr)
        goto Cleanup;

    if (TYMED_NULL == stgmedium.tymed)
    {
        hr = DV_E_FORMATETC;
        goto Cleanup;
    }

    // STGFIX: t-gpease 8-13-97
    Assert(stgmedium.tymed == TYMED_HGLOBAL);

    pszText = (TCHAR *) GlobalLock(stgmedium.hGlobal);
    Assert(pszText != NULL);
    if (pszText == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    memcpy(tszClsid, pszText, CLSID_STRLEN*sizeof(TCHAR));
    tszClsid[CLSID_STRLEN] = 0;
    GlobalUnlock(stgmedium.hGlobal);

Cleanup:
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   FindLegalCF
//
//  Synopsis:   Returns S_OK if the given data object contains a format
//              we can parse, or S_FALSE if it doesn't.  If the DO
//              returns an unexpected error, we return that instead.
//
//  Arguments:  [pDO]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
FindLegalCF(IDataObject * pDO)
{
    HRESULT     hr;
    int         c;
    FORMATETC * pformatetc;

#if defined(_MAC)
    if (!pDO)
        return S_OK;
#endif

    Assert(pDO);

    for (c = ARRAY_SIZE(g_aGetFmtEtcs), pformatetc = g_aGetFmtEtcs;
         c > 0;
         c--, pformatetc++)
    {
#if DBG == 1
        if (IsTagEnabled(tagIgnorePrivateCF))
        {
            if (c <= ARRAY_SIZE(g_aGetFmtEtcs) - IFMTETC_PRIVATEFMT)
                continue;
        }
#endif

        hr = pDO->QueryGetData(pformatetc);
        switch (hr)
        {
        case DV_E_FORMATETC:
        case DV_E_TYMED:
        case DV_E_DVASPECT:
            break;

        case DV_E_CLIPFORMAT:   //  This isn't a specified return value,
                                //    but the standard handler seems to
                                //    return it anyhow
            break;

        default:
            RRETURN(hr);
        }
    }

    return S_FALSE;
}


//
// CDropSource
// Implements IDropSource interface.

STDMETHODIMP
CDropSource::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    HRESULT hr = S_OK;

   if (_pDoc->_pDragStartInfo && !_pDoc->_pDragStartInfo->_pElementDrag->Fire_ondrag())
   {
        hr = DRAGDROP_S_CANCEL;
        goto Cleanup;
   }

   if (fEscapePressed)
    {
        hr = DRAGDROP_S_CANCEL;
        goto Cleanup;
    }

    // initialize ourself with the drag begin button
    if (_dwButton == 0)
        _dwButton = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

    // Assert(_dwButton); no need for this assert

    if (!(grfKeyState & _dwButton))
    {
        //
        // A button is released.
        //
        hr = DRAGDROP_S_DROP;
    }
    else if (_dwButton != (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)))
    {
        //
        //  If the button state is changed (except the drop case, which we handle
        // above, cancel the drag&drop.
        //
        hr = DRAGDROP_S_CANCEL;
    }

Cleanup:
    if (hr != S_OK)
    {
        // reset cursor here ?
        // SetCursor(LoadCursor(NULL, IDC_ARROW));
    }

    return hr;
}


STDMETHODIMP
CDropSource::GiveFeedback(DWORD dwEffect)
{
    // let OLE put up the right cursor
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

//
// CDummyDropSource
// Wraps a trivial instantiable class around CDropSource

STDMETHODIMP
CDummyDropSource::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IDropSource)
    {
        *ppv = this;
        ((IUnknown *)*ppv)->AddRef();
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


HRESULT
CDummyDropSource::Create(DWORD dwKeyState, CDoc * pDoc, IDropSource ** ppDropSrc)
{
    HRESULT         hr;

    *ppDropSrc = new CDummyDropSource;
    if (!*ppDropSrc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    ((CDummyDropSource *)(*ppDropSrc))->_dwButton =
        dwKeyState & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON);
    ((CDummyDropSource *)(*ppDropSrc))->_pDoc = pDoc;
    hr = S_OK;
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CBaseBag::QueryInterface, public
//
//  Synopsis:   Expose our IFaces
//
//---------------------------------------------------------------

STDMETHODIMP
CBaseBag::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (IUnknown *)(IDataObject *)this;
    }
    else if (IsEqualIID(riid,IID_IDataObject))
    {
        *ppv = (IDataObject *)this;
    }
    else if (IsEqualIID(riid,IID_IDropSource))
    {
        *ppv = (IDropSource *)this;
    }
    else if (IsEqualIID(riid,IID_IOleCommandTarget))
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+----------------------------------------------------------------------------
//
// CBaseBag IOleCommandTarget support
//
//-----------------------------------------------------------------------------
HRESULT
CBaseBag::QueryStatus(
            const GUID * pguidCmdGroup,
            ULONG        cCmds,
            OLECMD       rgCmds[],
            OLECMDTEXT * pcmdtext)
{
    RRETURN(OLECMDERR_E_UNKNOWNGROUP);
}

HRESULT
CBaseBag::Exec(
            const GUID * pguidCmdGroup,
            DWORD        nCmdID,
            DWORD        nCmdexecopt,
            VARIANTARG * pvarargIn,
            VARIANTARG * pvarargOut)
{
    HRESULT  hr = OLECMDERR_E_UNKNOWNGROUP;

    if (* pguidCmdGroup == CGID_DATAOBJECTEXEC)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case IDM_SETSECURITYDOMAIN:
            if (pvarargIn && (V_VT(pvarargIn) == VT_BSTR))
            {
                Assert(FormsStringLen(V_BSTR(pvarargIn)) == MAX_SIZE_SECURITY_ID);
                memcpy(_abSID, V_BSTR(pvarargIn), MAX_SIZE_SECURITY_ID);
                hr = S_OK;
            }
            break;

        case IDM_CHECKSECURITYDOMAIN:
            if (pvarargIn && (V_VT(pvarargIn) == VT_BSTR))
            {
                Assert(FormsStringLen(V_BSTR(pvarargIn)) == MAX_SIZE_SECURITY_ID);
                hr = !memcmp(_abSID, V_BSTR(pvarargIn), MAX_SIZE_SECURITY_ID) ?
                        S_OK : OLECMDERR_E_DISABLED;
            }
            break;
        }
    }
    RRETURN (hr);
}

/*
 * CGenDataObject - Generic IDataObject implementation.
 */


/********************************** Methods **********************************/


CGenDataObject::CGenDataObject(CDoc * pDoc)
    : _rgfmtc(Mt(CGenDataObject_rgfmtc_pv)),
      _rgstgmed(Mt(CGenDataObject_rgstgmed_pv))
{
    _ulRefs = 1;

    _pDoc = pDoc;
    _pLinkDataObj = NULL;

    _dwPreferredEffect              = DROPEFFECT_NONE;

#ifndef WIN16
    _fmtcPreferredEffect.cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
#endif //!WIN16
    _fmtcPreferredEffect.ptd        = NULL;
    _fmtcPreferredEffect.dwAspect   = DVASPECT_CONTENT;
    _fmtcPreferredEffect.lindex     = -1;
    _fmtcPreferredEffect.tymed      = TYMED_HGLOBAL;
}


CGenDataObject::~CGenDataObject()
{
    int         i;
    STGMEDIUM * pstgmed;

    for (i = _rgstgmed.Size(), pstgmed = _rgstgmed; i > 0; i--, pstgmed++)
        ReleaseStgMedium(pstgmed);
}


HRESULT
CGenDataObject::DeleteFormatData(CLIPFORMAT cfFormat)
{
    FORMATETC * pfmtc;
    int i;

    for (i = _rgfmtc.Size() - 1, pfmtc = _rgfmtc + i; i >= 0; --i, --pfmtc)
    {
        if (pfmtc->cfFormat == cfFormat)
        {
            _rgfmtc.Delete(i);
            _rgstgmed.Delete(i);
        }
    }

    return S_OK;
}

HRESULT
CGenDataObject::AppendFormatData(CLIPFORMAT cfFormat, HGLOBAL hGlobal)
{
    HRESULT hr;
    FORMATETC fmtc;
    STGMEDIUM stgmed;

    fmtc.cfFormat = cfFormat;
    fmtc.ptd = NULL;
    fmtc.dwAspect = DVASPECT_CONTENT;
    fmtc.lindex = -1;
    fmtc.tymed = TYMED_HGLOBAL;

    stgmed.tymed = TYMED_HGLOBAL;
    stgmed.hGlobal = hGlobal;
    stgmed.pUnkForRelease = NULL;

    hr = _rgfmtc.AppendIndirect(&fmtc);
    if (!hr)
    {
        hr = _rgstgmed.AppendIndirect(&stgmed);
        if (hr)
            _rgfmtc.DeleteByValueIndirect(&fmtc);
    }

    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
CGenDataObject::GetData(LPFORMATETC pfmtetc, LPSTGMEDIUM pstgmed)
{
    HRESULT     hr = S_OK;
    HGLOBAL hGlobal;
    DWORD *     pdw;
    int         i, c;
    FORMATETC * pfmtc;

    memset(pstgmed, 0, sizeof(*pstgmed));

    if (_dwPreferredEffect != DROPEFFECT_NONE &&
        FORMATETCMatchesRequest(pfmtetc, &_fmtcPreferredEffect))
    {
        hGlobal = GlobalAlloc(GPTR, sizeof(DWORD));
        if (!hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        IF_WIN16(pdw = (DWORD *)GlobalLock(hGlobal));
        IF_WIN32(pdw = (DWORD *)hGlobal);
        *pdw = _dwPreferredEffect;
        IF_WIN16(GlobalUnlock(hGlobal));

        pstgmed->tymed          = TYMED_HGLOBAL;
        pstgmed->hGlobal        = hGlobal;
        pstgmed->pUnkForRelease = NULL;
        goto Cleanup;
    }

    c = _rgfmtc.Size();
    for (i = 0, pfmtc = _rgfmtc; i < c; i++, pfmtc++)
    {
        if (FORMATETCMatchesRequest(pfmtetc, pfmtc))
            break;
    }
    if (i == c)
    {
        hr = DV_E_FORMATETC;
        goto Cleanup;
    }
    hr = THR(CloneStgMedium(&_rgstgmed[i], pstgmed));

Cleanup:
    if (hr && _pLinkDataObj)
        hr = _pLinkDataObj->GetData(pfmtetc, pstgmed);

    RRETURN(hr);
}


HRESULT STDMETHODCALLTYPE CGenDataObject::QueryGetData(LPFORMATETC pfmtetc)
{
    HRESULT     hr = S_OK;
    int         i;
    FORMATETC * pfmtc;

    if (_dwPreferredEffect != DROPEFFECT_NONE &&
        FORMATETCMatchesRequest(pfmtetc, &_fmtcPreferredEffect))
    {
        goto Cleanup;
    }
    for (i = _rgfmtc.Size(), pfmtc = _rgfmtc; i > 0; i--, pfmtc++)
    {
        if (FORMATETCMatchesRequest(pfmtetc, pfmtc))
            goto Cleanup;
    }
    hr = DV_E_FORMATETC;

Cleanup:
    if (hr && _pLinkDataObj)
        hr = _pLinkDataObj->QueryGetData(pfmtetc);

    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE CGenDataObject::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease)
{
    HRESULT hr;

    hr = DeleteFormatData(pformatetc->cfFormat);
    if (hr)
        goto Cleanup;

    if (pmedium->hGlobal)
        hr = AppendFormatData(pformatetc->cfFormat, pmedium->hGlobal);

Cleanup:
    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
CGenDataObject::EnumFormatEtc(DWORD                 dwDirection,
                              LPENUMFORMATETC FAR * ppenumFormatEtc)
{
    if (_pLinkDataObj)
    {
        AppendFormatData(cf_FILEDESCA, NULL);
        AppendFormatData(cf_FILEDESCW, NULL);
        AppendFormatData(cf_FILECONTENTS, NULL);
        AppendFormatData(cf_UNIFORMRESOURCELOCATOR, NULL);
    }

    *ppenumFormatEtc = NULL;
    RRETURN((dwDirection == DATADIR_GET) ?
        CEnumFormatEtc::Create(_rgfmtc, _rgfmtc.Size(), ppenumFormatEtc) :
        E_NOTIMPL);
}

void
CGenDataObject::SetBtnState(DWORD dwKeyState)
{
    _dwButton = dwKeyState & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON);
}

//
//  CEnumFormatEtc PUBLIC methods
//

/*
 *  CEnumFormatEtc::QueryInterface (riid, ppvObj)
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      HRESULT
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(
    REFIID riid,            // @parm Reference to requested interface ID
    void ** ppv)            // @parm out parm for interface ptr
{
    HRESULT     hresult = E_NOINTERFACE;

    *ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumFORMATETC) )
    {
        *ppv = this;
        AddRef();
        hresult = NOERROR;
    }
    return hresult;
}

/*
 *  CEnumFormatEtc::AddRef()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - incremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( )
{
    return ++_crefs;
}

/*
 *  CEnumFormatEtc::Release()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - decremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( )
{
    _crefs--;

    if( _crefs == 0 )
    {
        delete this;
        return 0;
    }

    return _crefs;
}

/*
 *  CEnumFormatEtc::Next (celt, rgelt, pceltFetched)
 *
 *  @mfunc
 *      fetches the next [celt] elements in our formatetc collection
 *
 *  @rdesc
 *      HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
        ULONG *pceltFetched)
{
    HRESULT     hresult = NOERROR;
    ULONG       cFetched;

    if( pceltFetched == NULL && celt != 1 )
    {
        // the spec says that if pceltFetched == NULL, then
        // the count of elements to fetch must be 1
        return E_INVALIDARG;
    }

    // we can only grab as many elements as there are left

    if( celt > _cTotal - _iCurrent )
    {
        cFetched = _cTotal - _iCurrent;
        hresult = S_FALSE;
    }
    else
    {
        cFetched = celt;
    }

    // Only copy if we have elements to copy

    if( cFetched > 0 )
    {
        memcpy( rgelt, _prgFormats + _iCurrent,
            cFetched * sizeof(FORMATETC) );
    }

    _iCurrent += cFetched;

    if( pceltFetched )
    {
        *pceltFetched = cFetched;
    }

    return hresult;
}

/*
 *  CEnumFormatEtc::Skip
 *
 *  @mfunc
 *      skips the next [celt] formats
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Skip( ULONG celt )
{
    HRESULT     hresult = NOERROR;

    _iCurrent += celt;

    if( _iCurrent > _cTotal )
    {
        // whoops, skipped too far ahead.  Set us to the max limit.
        _iCurrent = _cTotal;
        hresult = S_FALSE;
    }

    return hresult;
}

/*
 *  CEnumFormatEtc::Reset
 *
 *  @mfunc
 *      resets the seek pointer to zero
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Reset( void )
{
    _iCurrent = 0;

    return NOERROR;
}

/*
 *  CEnumFormatEtc::Clone
 *
 *  @mfunc
 *      clones the enumerator
 *
 *  @rdesc
 *      HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
    return CEnumFormatEtc::Create(_prgFormats, _cTotal, ppIEnum);
}

/*
 *  CEnumFormatEtc::Create (prgFormats, cTotal, hr)
 *
 *  @mfunc
 *      creates a new format enumerator
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      *copies* the formats passed in.  We do this as it simplifies
 *      memory management under OLE object liveness rules
 */

HRESULT CEnumFormatEtc::Create( FORMATETC *prgFormats, ULONG cTotal,
    IEnumFORMATETC **ppenum )
{
    CEnumFormatEtc *penum = new CEnumFormatEtc();

    if( penum != NULL )
    {
        // _iCurrent, _crefs are set in the constructor

        if( cTotal > 0 )
        {
            penum->_prgFormats = new(Mt(CEnumFormatEtc_prgFormats)) FORMATETC[cTotal];
            if( penum->_prgFormats )
            {
                penum->_cTotal = cTotal;
                memcpy(penum->_prgFormats, prgFormats,
                        cTotal * sizeof(FORMATETC));
                *ppenum = penum;
                return NOERROR;
            }
        }
    }

    return E_OUTOFMEMORY;
}

//
// CEnumFormatEtc PRIVATE methods
//

/*
 *  CEnumFormatEtc::CEnumFormatEtc()
 *
 *  @mfunc
 *      Private constructor
 */

CEnumFormatEtc::CEnumFormatEtc()
{
    _cTotal = 0;
    _crefs  = 1;
    _prgFormats = NULL;
    _iCurrent = 0;
}


/*
 *  CEnumFormatEtc::~CEnumFormatEtc()
 *
 *  @mfunc
 *      Private destructor
 */

CEnumFormatEtc::~CEnumFormatEtc( void )
{
    if( _prgFormats )
    {
        delete [] _prgFormats;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\wsmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       wsmgr.cxx
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_WSMGR_HXX_
#define X_WSMGR_HXX_
#include "wsmgr.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_FILLCODE_HXX_
#define X_FILLCODE_HXX_
#include "fillcode.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

// this class contains \r (for whitespace/nonspace breaking in OutputText)
#define ISSPACE(ch) (((ch) == _T(' ')) || ((unsigned)((ch) - 9)) <= 13 - 9)

MtDefine(CWhitespaceManager, Mem, "CWhitespaceManager");
MtDefine(CWhitespaceManager_aryNodesToUpdate_pv, CWhitespaceManager, "CWhitespaceManager::aryNodesToUpdate::pv")

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::CWhitespaceManager, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CWhitespaceManager::CWhitespaceManager()
    : _aryNodesToUpdate(Mt(CWhitespaceManager_aryNodesToUpdate_pv))

{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::CWhitespaceManager, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CWhitespaceManager::~CWhitespaceManager()
{
    if (_aryNodesToUpdate.Size())
    {
        GWKillMethodCall(this, ONCALL_METHOD(CWhitespaceManager, DeferredApplyChanges, deferredapplychanges), 0);
    }

    ReleaseNodes(_aryNodesToUpdate);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::RegisterWhitespaceChange, public
//
//  Synopsis:   Posts a deferred method call to apply whitespace changes asynchronously.
//
//  Arguments:  [pNode] - Nodes with pending collapsed whitespace change.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
    
HRESULT 
CWhitespaceManager::RegisterWhitespaceChange(CTreeNode *pNode)
{
    Assert(pNode);
    Assert(!pNode->IsDead());
    Assert(pNode->GetMarkup()->SupportsCollapsedWhitespace());
        
    //
    // Defer document change
    //

    // NOTE: if we have pending requests, then we already have a pending DeferredApplyChanges so we don't
    // need to create another one
    
    if (_aryNodesToUpdate.Size() == 0)
    {
        IGNORE_HR(GWPostMethodCall(this,
                                   ONCALL_METHOD(CWhitespaceManager, DeferredApplyChanges, deferredapplychanges),
                                   0,
                                   FALSE, "CWhitespaceManager::DeferredApplyChanges")); // There can be only one caret per cdoc
    }
    
    //
    // Append node to request list
    //
    
    pNode->NodeAddRef();
    _aryNodesToUpdate.Append(pNode);    

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CompareNodes, private
//
//  Synopsis:   To avoid processing the same nodes multiple times, we
//             take all requests and sort by:
//                 1. markup
//                 2. pre state (are we turning it on or off)
//                 3. CP of BeginPos 
//
//             With this sort order, we can elimate any nodes that are contained within
//             a previously processed node.
//
//  Arguments:  [pv1, pv2] - Nodes to be compared
//
//  Returns:    -1, 0, or 1 based on the usual qsort order
//
//----------------------------------------------------------------------------    

int RTCCONV
CompareNodes( const void * pv1, const void * pv2 )
{
    CTreeNode   *pNode1 = * (CTreeNode **) pv1;
    CTreeNode   *pNode2 = * (CTreeNode **) pv2;
    ULONG       cpStart1, cpStart2;
    BOOL        fPre1, fPre2;

    //
    // Treat dead nodes as infinite cp (we'll discard later)
    //
    
    if (pNode1->IsDead())
        return 1;

    if (pNode2->IsDead())
        return -1;

    //
    // Order by markup
    //

    if (pNode1->GetMarkup() < pNode2->GetMarkup())
        return -1;

    if (pNode1->GetMarkup() > pNode2->GetMarkup())
        return 1;
    
    //
    // Order by pre state
    //

    fPre1 = pNode1->GetParaFormat()->_fPreInner;
    fPre2 = pNode2->GetParaFormat()->_fPreInner;

    if (fPre1 < fPre2)
        return -1;

    if (fPre1 > fPre2)
        return 1;
           
    //
    // Order by start cp
    //

    cpStart1 = pNode1->GetBeginPos()->GetCp();
    cpStart2 = pNode2->GetBeginPos()->GetCp();

    if (cpStart1 < cpStart2)
        return -1;

    if (cpStart1 > cpStart2)
        return 1;

    return 0;    
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::DeferredApplyChanges, private
//
//  Synopsis:   Applies deferred whitespace change.
//
//  Arguments:  [dwContext] - unused but required by deferred method invocation
//
//  Returns:    void
//
//----------------------------------------------------------------------------    

void 
CWhitespaceManager::DeferredApplyChanges(DWORD_PTR dwContext)
{
    HRESULT hr = S_OK;
    CTreeNode **ppTreeNode;
    CTreeNode *pTreeNode;
    int        i;
    long        cpLast = 0;
    long        cpCurrent;
    CMarkup     *pLastMarkup = NULL;
    CMarkup     *pCurrentMarkup;
    BOOL        fPreLast = FALSE;
    BOOL        fPreCurrent;
    CPtrAry<CTreeNode *> aryNodesToUpdate(Mt(CWhitespaceManager_aryNodesToUpdate_pv));
    
    IFC( aryNodesToUpdate.Copy(_aryNodesToUpdate, FALSE) ); // steal ref from _aryNodesToUpdate
    _aryNodesToUpdate.DeleteAll();

    //
    // Sort nodes by first cp so that we can discard nested nodes
    //

    qsort(aryNodesToUpdate,
      aryNodesToUpdate.Size(),
      sizeof(CTreeNode*),
      CompareNodes);                

    //
    // Apply changes to each node
    //

    for (i = aryNodesToUpdate.Size(), ppTreeNode = aryNodesToUpdate;
        i > 0;
        i--, ppTreeNode++)
    {
        pTreeNode = *ppTreeNode;

        if (pTreeNode->IsDead())
        {
#if DBG==1
            {
                int         iDbg = i;
                CTreeNode   **ppDbgTreeNode = ppTreeNode;
                
                // Since dead TreeNodes have infinite weight in the sort, 
                // everything after this node should also be dead

                for (; iDbg > 0; iDbg--, ppDbgTreeNode++)
                {
                    Assert((*ppDbgTreeNode)->IsDead());
                }
            }            
#endif
            break; // we're done
        }

        pCurrentMarkup = pTreeNode->GetMarkup();
        cpCurrent = pTreeNode->GetBeginPos()->GetCp();
        fPreCurrent = pTreeNode->GetParaFormat()->_fPreInner;

        //
        // Make sure we don't apply changes to the scope of a node more
        // than once.
        //

        if (pCurrentMarkup != pLastMarkup
            || fPreCurrent != fPreLast
            || cpCurrent >= cpLast)
        {       
            IFC( ApplyChangesToNode(pTreeNode) );

            pLastMarkup = pCurrentMarkup;
            fPreLast = fPreCurrent;
            cpLast = pTreeNode->GetEndPos()->GetCp();
        }

        pTreeNode->SetPre(fPreCurrent);            
    }

Cleanup:
    ReleaseNodes(aryNodesToUpdate);
    ReleaseNodes(_aryNodesToUpdate);        
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::RemovePre, private
//
//  Synopsis:   Recollapse whitespace we expanded earlier
//
//  Arguments:  [pNodeToUpdate] - Node to update
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::RemovePre(CTreeNode *pNodeToUpdate)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup = pNodeToUpdate->GetMarkup();
    CDoc    *pDoc = pMarkup->Doc();
    long cch;
    TCHAR ch;           
    MARKUP_CONTEXT_TYPE context;
    CMarkupPointer mp(pDoc);
    CMarkupPointer mpPrev(pDoc);
    CMarkupPointer mpEnd(pDoc);
    CTreeNode *pNode, *pNodeScope;
    ULONG fillcode;
    BOOL fHasSpace = FALSE;
    BOOL fEatSpace = FALSE;
    BOOL fDone;
    BOOL fLeftIsPre, fRightIsPre;

    mp.SetAlwaysEmbed( TRUE );
    mpEnd.SetAlwaysEmbed( TRUE );
    IFC( mp.MoveToReference(pNodeToUpdate->GetBeginPos()->NextTreePos(), 0, pMarkup, -1) );
    IFC( mpEnd.MoveToReference(pNodeToUpdate->GetEndPos()->NextTreePos(), 0, pMarkup, -1) );    

    fillcode = FillCodeFromEtag(pNodeToUpdate->Tag());  
    IFC( RFill(&mp, FILL_RB(fillcode), &fHasSpace, &fEatSpace) );

    do
    {
        IFC( mpPrev.MoveToPointer(&mp) );        
        
        cch = -1;
        IFC( mp.Right(TRUE, &context, &pNode, &cch, &ch, NULL) );

        //
        // We only remove pre-ness if we are contained within !_fPre.  So,
        // keep track of the value of the format cache to the left and right
        // of our current position
        //
        
        pNodeScope = mpPrev.CurrentScope();
        fLeftIsPre = pNodeScope ? pNodeScope->GetParaFormat()->_fPreInner : FALSE;

        pNodeScope = mp.CurrentScope();
        fRightIsPre = pNodeScope ? pNodeScope->GetParaFormat()->_fPreInner : FALSE;

        switch (context)
        {
            case CONTEXT_TYPE_Text:     
                if (!fLeftIsPre)
                    IFC( CollapseWhitespace(&mpPrev, &mp, &fHasSpace, &fEatSpace) );
                break;

            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
                Assert(pNode);
                fillcode = FillCodeFromEtag(pNode->Tag());  

                if (!fLeftIsPre)
                    IFC( LFill(&mpPrev, FILL_LB(fillcode), &fHasSpace, &fEatSpace) );

                if (!fRightIsPre)
                {
                    IFC( RFill(&mp, FILL_RB(fillcode), &fHasSpace, &fEatSpace) );
                }
                else
                {
                    fHasSpace = FALSE;
                    fEatSpace = TRUE;                    
                }

                pNode->SetPre(FALSE);
                break;
                
            case CONTEXT_TYPE_ExitScope:
                Assert(pNode);
                fillcode = FillCodeFromEtag(pNode->Tag());  
                
                if (!fLeftIsPre)
                    IFC( LFill(&mpPrev, FILL_LE(fillcode), &fHasSpace, &fEatSpace) );
                
                if (!fRightIsPre)
                {
                    IFC( RFill(&mp, FILL_RE(fillcode), &fHasSpace, &fEatSpace) );
                }
                else
                {
                    fHasSpace = FALSE;
                    fEatSpace = TRUE;                                        
                }
                break;

        }        

        IFC( mp.IsRightOf(&mpEnd, &fDone) );            
    }
    while (!fDone);


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::CollapseWhitespace, private
//
//  Synopsis:   Recollapse whitespace we expanded earlier
//
//  Arguments:  [pmpLeft] - Pointer positioned left of text to be collapsed
//              [pmpRight] - Pointer positioned right of text to be collapsed
//              [pfHasSpace] - state for whitespace collapsing (ported from parser)
//              [pfEatSpace] - state for whitespace collapsing (ported from parser)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::CollapseWhitespace(CMarkupPointer *pmpLeft, CMarkupPointer *pmpRight, BOOL *pfHasSpace, BOOL *pfEatSpace)
{
    HRESULT hr = S_OK;
    ULONG cpStart, cpEnd;
    CDoc *pDoc = pmpLeft->Doc();
    CMarkup *pMarkup = pmpLeft->Markup();
    CMarkupPointer mpInsert(pDoc);
    CMarkupPointer mpStart(pDoc);
    CMarkupPointer mp(pDoc);
    CTxtPtr tp(pMarkup);
    CTxtPtr tpNext(pMarkup);
    CTxtPtr tpStart(pMarkup);
    TCHAR ch;
    CTreePos *ptp = NULL;
    TCHAR *pchWhitespace = NULL;
    LONG cch;

    mpInsert.SetAlwaysEmbed(TRUE);
    
    IFC( mp.MoveToPointer(pmpLeft) );
        
    do
    {
        //
        // Add pending whitespace
        //
        
        if (*pfHasSpace)
        {
            if (!(*pfEatSpace))
                IFC( AddSpace(&mp) );

            *pfHasSpace = FALSE;
        }

            
        tp.SetCp(mp.GetCp());
        cpEnd = pmpRight->GetCp();

        //
        // Skip nonspaces
        //
        
        if (!ISSPACE(tp.GetChar()))
        {
            *pfEatSpace = FALSE;
            
            for (tp.SetCp(mp.GetCp()); tp.GetCp() < cpEnd; tp.AdvanceCp(1))
            {
                ch = tp.GetChar();

                if (ch == ' ' && (tp.GetCp() + 1 < cpEnd))
                {
                    tpNext.SetCp(tp.GetCp()+1);
                    if (!ISSPACE(tpNext.GetChar()))
                    {
                        tp.SetCp(tpNext.GetCp());
                        continue;
                    }
                }
                
                if (ISSPACE(ch))
                    break;
            }

            if (tp.GetCp() >= cpEnd)
                break;
        }
        
        //
        // Store whitespace range
        //

        cpStart = tp.GetCp();
        while (ISSPACE(tp.GetChar()) && tp.GetCp() < cpEnd)
            tp.AdvanceCp(1);
        
        cpEnd = tp.GetCp();
        
        IFC( mpStart.MoveToCp(cpStart, pMarkup) );
        IFC( mp.MoveToCp(cpEnd, pMarkup) );

        cch = cpEnd - cpStart;
        pchWhitespace = new TCHAR[cch + 1];
        if (!pchWhitespace)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        tpStart.SetCp(cpStart);
        tpStart.GetRawText(cch, pchWhitespace);
        pchWhitespace[cch] = '\0';

        //
        // Remove whitespace from text store
        //
        
        IFC( pDoc->Remove(&mpStart, &mp) );

        //
        // Insert whitespace pointer
        //

        IFC( mpInsert.MoveToPointer(&mp) );

        ptp = pMarkup->NewPointerPos(NULL, FALSE, TRUE, TRUE);
        if (!ptp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        ptp->SetCollapsedWhitespace(pchWhitespace);
        pchWhitespace = NULL;

        IFC( pMarkup->EmbedPointers() );
        IFC( pMarkup->Insert(ptp, mpInsert.GetEmbeddedTreePos(), FALSE) );        
        ptp = NULL;        
        
        IFC( mpInsert.Unposition() );
        
        *pfHasSpace = TRUE;
    }
    while (mp.GetCp() < pmpRight->GetCp());
    
Cleanup:
    delete [] pchWhitespace;
    delete ptp;
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::ApplyPre, private
//
//  Synopsis:   Expand collapsed whitespace
//
//  Arguments:  [pNode] - Node that contains the whitespace to be expanded
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::ApplyPre(CTreeNode *pNode)
{
    HRESULT hr = S_OK;
    CTreePos *ptp;
    CTreePos *ptpEnd = pNode->GetEndPos();
    TCHAR   *pchCollapsedWhitespace;
    CMarkup *pMarkup = pNode->GetMarkup();
    CDoc    *pDoc = pMarkup->Doc();
    CMarkupPointer mp(pDoc);
    CMarkupPointer mpRight(pDoc);
    BOOL fIgnoreFirstCR, fNextIgnoreFirstCR = FALSE;
    long cch;
    TCHAR ch;           
    MARKUP_CONTEXT_TYPE context;
    BOOL fApplyPre = TRUE;
    
    mp.SetAlwaysEmbed(TRUE);

    fIgnoreFirstCR = (pNode->GetFancyFormat()->IsWhitespaceSet() && pNode->GetParaFormat()->_fPreInner)
                     || pNode->Tag() == ETAG_PRE;

    for (ptp = pNode->GetBeginPos()->NextTreePos(); 
         ptp != ptpEnd; 
         ptp = ptp->NextTreePos())
    {
        if (ptp->IsPointer() && fApplyPre)
        {
            pchCollapsedWhitespace = ptp->GetCollapsedWhitespace();
            if (pchCollapsedWhitespace)
            {
                IFC( mp.MoveToReference(ptp, 0, pMarkup, -1) ); 
                ptp->SetCling(FALSE);

                //
                // Remove exisiting space if required
                //

                // NOTE: Gravity is set to right iff we attached to a whitespace character
                if (ptp->Gravity())
                {

                    IFC( mpRight.MoveToPointer(&mp) );
                    cch = 1;
                    IFC( mpRight.Right(TRUE, &context, NULL, &cch, &ch) );
                    
                    if (context == CONTEXT_TYPE_Text && cch && ch == ' ')
                        IFC( pDoc->Remove(&mp, &mpRight) )
                    else
                        AssertSz(0, "Can't find associated space for collapsed whitespace");

                    IFC( mpRight.Unposition() );
                }

                //
                // Expand collapsed whitespace
                //
                               
                if (fIgnoreFirstCR && *pchCollapsedWhitespace == '\r')
                    pchCollapsedWhitespace++;

                if (*pchCollapsedWhitespace != '\0')
                    IFC( pDoc->InsertText(pchCollapsedWhitespace, -1, &mp) );
                

                //
                // Remove tree pos and advance ptp
                //

                IFC( pMarkup->RemovePointerPos(ptp, NULL, NULL) );  
                ptp = mp.GetEmbeddedTreePos();

            }
        }
        else if (ptp->IsBeginNode())
        {
            fApplyPre = ptp->Branch()->GetParaFormat()->_fPreInner;                
            if (fApplyPre)
            {
                ptp->Branch()->SetPre(TRUE);
                fNextIgnoreFirstCR = ptp->Branch()->GetFancyFormat()->IsWhitespaceSet();
            }
        }
        else if (ptp->IsEndNode())
        {
            CTreeNode *pParentNode = ptp->Branch()->Parent();

            if (pParentNode)
            {
                fApplyPre = pParentNode->GetParaFormat()->_fPreInner;                
            }
        }
            
        fIgnoreFirstCR = fNextIgnoreFirstCR;
        fNextIgnoreFirstCR = FALSE;
    }    

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::ApplyChangesToNode, private
//
//  Synopsis:   Apply or remove collapsed whitespace
//
//  Arguments:  [pNode] - Node that contains pending changes
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT
CWhitespaceManager::ApplyChangesToNode(CTreeNode *pNode)
{
    HRESULT      hr = S_OK;
    BOOL        fPre = pNode->GetParaFormat()->_fPreInner;

    if (fPre != pNode->IsPre())
    {
        if (fPre)
            hr = THR(ApplyPre(pNode));        
        else
            hr = THR(RemovePre(pNode));        
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::LFill, private
//
//  Synopsis:   LFill whitespace before node (ported from parser)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::LFill(CMarkupPointer *pmpPosition, UINT fillcode, BOOL *pfHasSpace, BOOL *pfEatSpace)
{
    HRESULT hr = S_OK;

    Assert(!(*pfEatSpace) || !(*pfHasSpace));

    //
    // Output, eat, or transfer space from the left
    //

    if (*pfHasSpace)
    {
        if (fillcode == FILL_PUT)
        {
            hr = THR( AddSpace(pmpPosition) );

            *pfEatSpace = TRUE;
        }        

        *pfHasSpace = FALSE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::RFill, private
//
//  Synopsis:   RFill whitespace after node (ported from parser)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::RFill(CMarkupPointer *pmpPosition, UINT fillcode, BOOL *pfHasSpace, BOOL *pfEatSpace)
{
    Assert(!(*pfEatSpace) || !(*pfHasSpace));

    // 1. Reject space to the right if EAT

    if (fillcode == FILL_EAT)
    {
        *pfHasSpace = FALSE;
        *pfEatSpace = TRUE;
    }

    // 2. Accept space to the right if PUT

    if (fillcode == FILL_PUT)
    {
        *pfEatSpace = FALSE;
    }
    
    // 3. Transfer any existing space by not resetting fHasSpace

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::ReleaseNodes, private
//
//  Synopsis:   Release all nodes
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

void 
CWhitespaceManager::ReleaseNodes(CPtrAry<CTreeNode *> &aryNodes)
{
    if (aryNodes.Size())
    {
        CTreeNode **ppTreeNode;
        int        i;

        for (i = aryNodes.Size(), ppTreeNode = aryNodes;
            i > 0;
            i--, ppTreeNode++)
        {
            (*ppTreeNode)->NodeRelease();
        }

        aryNodes.DeleteAll();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::AddSpace, private
//
//  Synopsis:   Add a real space - used for recollapsing whitespace
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::AddSpace(CMarkupPointer *pmp)
{
    HRESULT hr;
    CDoc    *pDoc = pmp->Doc();
    TCHAR   ch = ' ';
    POINTER_GRAVITY eGravity;
    CMarkupPointer mpLeft(pDoc);
    CTreePos *ptp;
    
    //
    // Insert space
    //

    mpLeft.SetAlwaysEmbed(TRUE);

    IFC( mpLeft.MoveToPointer(pmp) );

    IFC( pmp->Gravity(&eGravity) );
    IFC( pmp->SetGravity(POINTER_GRAVITY_Right) );

    IFC( pDoc->InsertText(pmp, &ch, 1, 0) );

    IFC( pmp->SetGravity(eGravity) );

    //
    // Cling to left space
    //

    ptp = mpLeft.GetEmbeddedTreePos();

    while (ptp->IsPointer())
    {
        if (ptp->GetCollapsedWhitespace())
        {
            ptp->SetGravity(TRUE);
            goto Cleanup;
        }

        ptp = ptp->PreviousTreePos();
    }

    ptp = mpLeft.GetEmbeddedTreePos();

    while (ptp->IsPointer())
    {
        if (ptp->GetCollapsedWhitespace())
        {
            ptp->SetGravity(TRUE);
            goto Cleanup;
        }

        ptp = ptp->NextTreePos();
    }
    
Cleanup:
    RRETURN(hr);
} 

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::FlushWhitespaceChanges, private
//
//  Synopsis:   Flushes pending whitespace changes
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    
HRESULT 
CWhitespaceManager::FlushWhitespaceChanges()
{
    if (_aryNodesToUpdate.Size())
    {
        GWKillMethodCall(this, ONCALL_METHOD(CWhitespaceManager, DeferredApplyChanges, deferredapplychanges), 0);
        DeferredApplyChanges(0);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\btnhlper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       btnhelp.cxx
//
//  Contents:   Button helper class implementation
//
//  Classes:    CButtonHelper
//
//  Functions:
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif


// Used by CInput on TYPE=file to differentiate clicks on the text and button portions.
const DWORD CLKDATA_BUTTON = 1;


//+------------------------------------------------------------------------
//
//  Member:     CBtnHelper::BtnTakeCapture
//
//  Synopsis:   take capture for the button helper and remember it
//
//-------------------------------------------------------------------------

void
CBtnHelper::BtnTakeCapture(BOOL fTake)
{
    CElement *pElem = GetElement();
    CDoc * pDoc = pElem->Doc();

    if (fTake)
    {
        pDoc->SetMouseCapture(
                MOUSECAPTURE_METHOD(CElement, HandleCaptureMessage, handlecapturemessage),
                pElem,
                TRUE,
                TRUE);
    }
    else
    {
        pDoc->ClearMouseCapture(pElem);
    }
    _fButtonHasCapture = fTake;
}


//+------------------------------------------------------------------------
//
//  Member:     CBtnHelper::BtnHasCapture
//
//  Synopsis:   check if the button helper really has capture
//
//-------------------------------------------------------------------------

BOOL
CBtnHelper::BtnHasCapture()
{
    return GetElement()->HasCapture() && _fButtonHasCapture;
}


//+---------------------------------------------------------------------------
//
// Member:      CBtnHelper::BtnHandleMessage
//
// Synopsis:    Handle window message
//
//----------------------------------------------------------------------------

HRESULT
CBtnHelper::BtnHandleMessage(CMessage * pMessage)
{
    HRESULT         hr      = S_FALSE;
    CElement *      pElem   = GetElement();
    BOOL            fCtrl   = pMessage->dwKeyState & FCONTROL;

    switch (pMessage->message)
    {
    case WM_KILLFOCUS:
        BTN_RESETSTATUS(_wBtnStatus);
        ChangePressedLook();
        hr = S_FALSE;
        break;
    case WM_SETFOCUS:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
        ChangePressedLook();
        hr = S_FALSE; //THR(SiteHandleMessage(pMessage, pChild));
        break;

    case WM_SETCURSOR:       
        if ( ! pMessage->pNodeHit->Element()->IsMasterParentEditable() )
        {
            pElem->SetCursorStyle(IDC_ARROW);
            hr = S_OK;
        }            
        break;
    case WM_KEYDOWN:
        switch (pMessage->wParam)
        {
        case 'M':
        case 'm':
            if (!fCtrl)
            {
                break;
            }
            // fall thru
        case VK_TAB:
            // change the look if this is not done yet.
            BTN_RESETSTATUS(_wBtnStatus);
            ChangePressedLook();
            hr = S_FALSE;
            break;

        case VK_BACK:
            // do not allow navigate back
            hr = S_OK;
            break;

        case VK_SPACE:
            // do not change look&feel if we already have the capture
            if (!BtnHasCapture())
            {
                PressButton(PRESSED_KEYBOARD);
                BtnTakeCapture(TRUE);
                hr = S_OK;
            }
             break;
        }
        break;

    case WM_CHAR:
        switch (pMessage->wParam)
        {
        case VK_SPACE:
            hr = S_OK;
        }
        break;

    case WM_KEYUP:
    {
        if (BtnHasCapture() && BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
        {
            if (!BTN_GETSTATUS(_wBtnStatus, PRESSED_MOUSE))
            {
                WORD    wOld = _wBtnStatus;

                _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_KEYBOARD);  // reset PRESSED_KEY bit
                BtnTakeCapture(FALSE);
                _wBtnStatus = wOld;
            }
            else
            {
            // the user still presses on the mouse
            // we should change the press look
                // reverse the bit
                _wBtnStatus = BTN_REVSTATUS(_wBtnStatus, PRESSED_MOUSE);
                if (PressedLooksDifferent(PRESSED_MOUSE))
                {
                    ChangePressedLook();
                }
            }
            ReleaseButton(PRESSED_KEYBOARD, pMessage);
        }

        hr = S_OK;
        break;
    }
    case WM_MOUSEOVER:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_MOUSEOVER);
    case WM_MOUSELEAVE:
        if (WM_MOUSELEAVE == pMessage->message)
        {
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_MOUSEOVER);
        }
        if (!BtnHasCapture() && !Pressed())
        {
            //
            // inval button
            //

            Invalidate();
        }
        break;
    case WM_MOUSEMOVE:

        // If the mouse is captured, that means that the user clicked
        // over the control. Else, it is moving over us, but we were not pressed.

        if (BtnHasCapture() && !BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
        {
            // See whether the mouse is still over us. If it goes from
            // being over to not, or visa versa, flip the _wBtnStatus flag
            // and, if that would affect visible image, redraw.

            if (((_wBtnStatus & PRESSED_MOUSE) != 0) !=
                  MouseIsOver(MAKEPOINTS(pMessage->lParam).x,
                              MAKEPOINTS(pMessage->lParam).y))
            {
                // reverse the bit
                _wBtnStatus = BTN_REVSTATUS(_wBtnStatus, PRESSED_MOUSE);
                if (PressedLooksDifferent(PRESSED_MOUSE))
                {
                    ChangePressedLook();
                }
            }
            if (!(pMessage->wParam & BTN_GETPRESSSTATUS(_wBtnStatus)))
            {
                BtnTakeCapture(FALSE);
            }
            hr = S_OK;
        }

        break;
    case WM_CAPTURECHANGED:
        // If the mouse is over the control at the time we lose capture,
        // then we need to remove the pressed state, just as though the
        // mouse had moved off the control.
#if DBG==1
        TLS(fHandleCaptureChanged) = TRUE;
#endif //DBG==1

        _fButtonHasCapture = FALSE;

        if (BTN_GETSTATUS(_wBtnStatus, PRESSED_MOUSE))
        {
            // if it is a mouse capture
            // reset the mouse pressed bit
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_MOUSE);

            // If the pressed state looks different from the unpressed
            // state, redraw.

            if (PressedLooksDifferent(PRESSED_MOUSE))
            {
                ChangePressedLook();
            }
            hr = S_OK;
        }
        else if (BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
        {
            // if it is a keyboard capture
            // reset the space pressed bit
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_KEYBOARD);

            // If the pressed state looks different from the unpressed
            // state, redraw.

            if (PressedLooksDifferent(PRESSED_KEYBOARD))
            {
                ChangePressedLook();
            }
            hr = S_OK;
        }
#if DBG==1
        TLS(fHandleCaptureChanged) = FALSE;
#endif //DBG==1
        break;

    case WM_LBUTTONDBLCLK:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_DOUBLECLICK);
        // fall through
    case WM_LBUTTONDOWN:

        if (pElem->HasCurrency() || pElem->IsUnselectable())
        {           
            BTN_PRESSLEFT(_wBtnStatus);
            PressButton(PRESSED_MOUSE);
            BtnTakeCapture(TRUE);
            hr = S_OK;
        }
        break;

    case WM_LBUTTONUP:
    {
        if (BtnHasCapture())
        {
            // if space key still down, we don't do anything
            if (!BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
            {
                WORD    wOld = _wBtnStatus;

                // temporarily reset mouse pressed bit to clear the capture
                _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_MOUSE);
                BtnTakeCapture(FALSE);
                _wBtnStatus = wOld;
            }
            ReleaseButton(PRESSED_MOUSE, pMessage);
            hr = S_OK;
        }
        break;
    }
#ifdef NEVER
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        if (HasCapture())
        {
            // clear bit
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_MOUSE);
            TakeCapture(FALSE);
        }
#endif

    case WM_CONTEXTMENU:
        hr = THR(pElem->OnContextMenu(
                (short)LOWORD(pMessage->lParam),
                (short)HIWORD(pMessage->lParam),
                CONTEXT_MENU_CONTROL));
        hr = S_OK;
        break;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBtnHelper::PressButton
//
//  Synopsis:   Enter the pressed state.
//
//  Arguments:
//
//  Notes:      PressButton and ReleaseButton keep track of which device has
//              pressed and released, so that we only release the button when
//              all devices have released. This matches VB behavior.
//                We also avoid redundant presses in case of repeated key down
//              without intervening key up.
//
//----------------------------------------------------------------------------

void
CBtnHelper::PressButton(WORD wWhoPressed)
{
    if (!BTN_PRESSED(_wBtnStatus))
    {
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, wWhoPressed);

        // A button that is already down does not change its image on being pressed, only on
        // being released. Other states do change on being pressed.

        if (PressedLooksDifferent(wWhoPressed))
        {
            ChangePressedLook();
        }
    }
    else
    {
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, wWhoPressed);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBtnHelper::ReleaseButton
//
//  Synopsis:   Exit the pressed state.
//
//  Arguments:  fVisual TRUE if we should show visual effects.
//
//  Note:       Checks that the button was actually pressed by the same agency
//              as is trying to release it. This is to cover any possible
//              case in which we get a button or key up without a corresponding
//              down (or get two ups in a row).
//

//----------------------------------------------------------------------------

void
CBtnHelper::ReleaseButton(WORD wWhoPressed, CMessage * pMessage)
{
    if (BTN_GETSTATUS(_wBtnStatus, wWhoPressed))
    {
        // mouse/spcae key pressed and released, clear the bit
        _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, wWhoPressed);

        if (!BTN_PRESSED(_wBtnStatus))                          // If no remaining presses...
        {
            // If this was a command button, there is no value and therefore
            // the call before would not invalidate and Fire OnViewChange
            // Make sure we do it if the pressed state looked different than
            // the released stated.

            if (PressedLooksDifferent(wWhoPressed))
            {
                ChangePressedLook();
            }
            if (pMessage)
            {
                pMessage->SetNodeClk(GetElement()->GetFirstBranch());
                pMessage->dwClkData = CLKDATA_BUTTON;
            }
        }
    }
    else
    {
        if (!MouseIsOver(MAKEPOINTS(pMessage->lParam).x, MAKEPOINTS(pMessage->lParam).y))
        {
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_MOUSEOVER);
        }

        Invalidate();
    }

    // reset double click flag
    _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_DOUBLECLICK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBtnHelper::MouseIsOver
//
//  Synopsis:   TRUE iff this point is over us.
//
//  Arguments:
//
//----------------------------------------------------------------------------

BOOL
CBtnHelper::MouseIsOver(LONG x, LONG y)
{
    CRect rc;
    POINT pt = { x, y };

    GetElement()->GetUpdatedLayout()->GetRect(&rc, COORDSYS_GLOBAL);
    return rc.Contains(pt);
}

//+---------------------------------------------------------------------------
//
//  Member:     PressedLooksDifferent
//
//  Synopsis:   Returns true if the pressed value looks different from the
//              unpressed.
//
//              An up (FALSE) button changes its appearance when pressed,
//              a down (TRUE) button changes when released.
//
//              Some causes of a button being momentarily depressed do not
//              have visual effect. See the notes on SimulateClick for a
//              discussion. If the button does not hold a value, then we check
//              to see whether the source of the button press causes a
//              redraw. After all, since the button does not hold a value,
//              any visual display on press will be reversed on release,
//              bringing us back where we started. So, for buttons that do not
//              hold a value, we permit optimizing by eliminating both draws.
//
//  Arguments:  [wWoPressed] -- bit flags of who has pressed the control.
//
//----------------------------------------------------------------------------

BOOL
CBtnHelper::PressedLooksDifferent(WORD wWho)
{
    // Verify that no extra bits are in the wWho.

    Assert((wWho & ~(PRESSED_ASSIGNVALUE | PRESSED_MNEMONIC | PRESSED_MOUSE | PRESSED_KEYBOARD)) == 0);

    // All sources of clicks cause visible change except PRESSED_ASSIGNVALUE and PRESSED_MNEMONIC
    // for which we don't show the "pressed" state

    return (wWho & (PRESSED_KEYBOARD | PRESSED_MOUSE));
}


#ifdef NEVER
//[TRISTATE]
OLE_TRISTATE
CBtnHelper::BtnValue(void)
{
    return TRISTATE_FALSE;
}

//[TRISTATE]
void
CBtnHelper::BtnSetValue(OLE_TRISTATE triValue)
{
    IGNORE_HR(FireStdControlEvent_Click());
    // Do nothing else.  we don't store a value
}

//[TRISTATE]
OLE_TRISTATE
CBtnHelper::NextValue(void)
{
    if (BtnStyle() == GLYPHSTYLE_OPTION)
    {
        // A click on an Option button always sets to true.
        return TRISTATE_TRUE;
    }
    else if (BtnIsTripleState())
    {
        switch (BtnValue())
        {
        case TRISTATE_MIXED:
            return TRISTATE_TRUE;

        case TRISTATE_TRUE:
            return TRISTATE_FALSE;

        case TRISTATE_FALSE:
            return TRISTATE_MIXED;

        default:
            Assert(0 && "Invalid button value");
            return TRISTATE_FALSE;      // to keep the compiler happy
        }
    }
    else
    {
        // NOTE: if the current value is TRISTATE_MIXED, this returns TRISTATE_TRUE,
        //       as per Word and other apps.  From then on it goes to TRISTATE_FALSE,
        //       to TRISTATE_TRUE and back.

        return (BtnValue() == TRISTATE_TRUE) ? TRISTATE_FALSE : TRISTATE_TRUE;
    }
}

//[TRISTATE]
HRESULT
CBtnHelper::BtnValueChanged(OLE_TRISTATE triValue)
{
    // In my testing, VB4 only fires a click event or otherwise responds to a
    // value assignment if it is in fact different from the current value. This
    // is true of both command and option buttons. Neither VB4 nor Access show
    // visual feedback on value assignment.

    if (triValue != TRISTATE_FALSE)
    {
        if (_pDoc->_fDesignMode)
        {
            SimulateClick(PRESSED_ASSIGNVALUE); // All effects except visual.
        }
        else
        {
            BtnSetValue(triValue);
        }
    }

    return S_OK;
}

//[TRISTATE]
BOOL
CBtnHelper::Pressed()
{
    return BtnValue() == TRISTATE_TRUE ? TRUE : (BTN_PRESSED(_wBtnStatus) ? TRUE : FALSE);
}
#endif

void
CBtnHelper::ChangePressedLook()
{
    const SIZE      s_sizeDepressed = { 1, 1 };
    CDispNode * pDispNode;

    Assert(GetElement());
    Assert(GetElement()->GetUpdatedLayout());

    CLayout *   pLayout   = GetElement()->GetUpdatedLayout();

    if (!pLayout)
        return;

    pDispNode = pLayout->GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->HasInset())
    {

        if (!pLayout->TestLayoutDescFlag(LAYOUTDESC_NOTALTERINSET))
        {
            const CSize &   sizeOldInset = pDispNode->GetInset();
            CSize           sizeNewInset =  _sizeInset
                                        + (BTN_PRESSED(_wBtnStatus)
                                                ? (const CSize &)s_sizeDepressed
                                                : (const CSize &)g_Zero.size);

            if (sizeNewInset != sizeOldInset)
            {
                if (pLayout->OpenView())
                {
                    pDispNode->SetInset(sizeNewInset);
                }
            }
        }
        pLayout->Invalidate();
    }
}

void
CBtnHelper::Invalidate()
{
    Assert(GetElement());
    Assert(GetElement()->GetUpdatedLayout());

    CLayout *   pLayout   = GetElement()->GetUpdatedLayout();

    if (!pLayout)
        return;

    pLayout->Invalidate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\eselect.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eselect.cxx
//
//  Contents:   Select element class, etc..
//
//  Classes:    CSelectElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef _X_ACCBASE_HXX_
#define _X_ACCBASE_HXX_
#include "accbase.hxx"
#endif

#ifndef _X_ACCUTIL_HXX_
#define _X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef _X_TPOINTER_HXX_
#define _X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

//
// we need this thing to compile
// this is defined in winuser.h
//

/*
 * Combobox information
 */
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT  rcItem;
    RECT  rcButton;
    DWORD stateButton;
    HWND  hwndCombo;
    HWND  hwndItem;
    HWND  hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

#ifdef DLOAD1
extern "C"
#endif
BOOL
WINAPI
GetComboBoxInfo(
    HWND hwndCombo,
    PCOMBOBOXINFO pcbi
);

//
// end of winuser story
//

#ifdef _MAC
#ifdef SendMessageA
#undef SendMessageA

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

WINUSERAPI
LRESULT
WINAPI
SendMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  // SendMessageA
#endif  // _MAC

MtDefine(CSelectElement, Elements, "CSelectElement")
MtDefine(CSelectElement_aryOptions_pv, CSelectElement, "CSelectElement::_aryOptions::_pv")

MtDefine(BldOptionsCol, PerfPigs, "Build CSelectElement::SELECT_OPTION_COLLECTION")

DeclareTag(tagSelectWalk, "SelectWalk", "Trace the SELECT walking the OPTIONs");

DeclareTag(tagSelectState, "SelectState", "General SELECT state tracing");
DeclareTag(tagEraseBkgndStack, "EraseBkgndStack", "stack trace when processing EraseBackground");
DeclareTag(tagSelectInval, "Select", "invalidation");
DeclareTag(tagSelectWndProc, "Select", "WM messages");

ExternTag(tagViewHwndChange);

#define CX_BUTTON_DEFAULT_PX 73
#define CY_BUTTON_DEFAULT_PX 23

#define CX_SELECT_DEFAULT_PIXEL 24L

#define SELECT_OPTION_COLLECTION 0
#define NUMBER_OF_SELECT_COLLECTIONS 1

#define _cxx_
#include "select.hdl"

#if DBG == 1
static unsigned s_SelectSize = sizeof(CSelectElement);
#endif

extern DYNLIB g_dynlibOLEACC;       // Needed for WM_GETOBJECT support and accessibility

extern class CFontCache & fc();

extern BOOL  g_fThemedPlatform;

ATOM GetWndClassAtom(UINT uIndex);

//  !!!! WARNING !!!!
//  This array should ALWAYS be kept in sync with the corresponding enum
//  WindowMessages in eselect.hxx !
//
//  CSelectElement::CreateElement contains a check for this synchronization

UINT const CSelectElement::s_aMsgs[][2] =
{
    {CB_ADDSTRING,      LB_ADDSTRING    },
    {CB_GETCOUNT,       LB_GETCOUNT     },
    {CB_GETCURSEL,      LB_GETCURSEL    },
    {CB_SETCURSEL,      LB_SETCURSEL    },
    {CB_GETCURSEL,      LB_GETSEL       },
    {CB_SETCURSEL,      LB_SETSEL       },
    {CB_GETITEMDATA,    LB_GETITEMDATA  },
    {CB_SETITEMDATA,    LB_SETITEMDATA  },
    {CB_GETLBTEXT,      LB_GETTEXT      },
    {CB_GETLBTEXTLEN,   LB_GETTEXTLEN   },
    {CB_DELETESTRING,   LB_DELETESTRING },
    {CB_INSERTSTRING,   LB_INSERTSTRING },
#ifndef WIN16
    {CB_GETTOPINDEX,    LB_GETTOPINDEX  },
    {CB_SETTOPINDEX,    LB_SETTOPINDEX  },
#endif //!WIN16
    {CB_RESETCONTENT,   LB_RESETCONTENT },
    {CB_SETITEMHEIGHT,  LB_SETITEMHEIGHT },
    //  Insert new message pairs here
    {OCM__BASE, OCM__BASE}              //  Arbitrary nonzero value used as guardian element
                                        //  Keep this as the last pair!!
};


const CElement::CLASSDESC CSelectElement::s_classdesc =
{
    {
        &CLSID_HTMLSelectElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE  |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_HASDEFDESCENT,      // _dwFlags
        &IID_IHTMLSelectElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLSelectElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

//  Storage for the listbox and combobox subclassing
static WNDPROC s_alpfnSelectWndProc[2] = {NULL, NULL};
static long    s_lIDSelect = 1;


const CSelectElement::WIDEHOOKPROC CSelectElement::s_alpfnWideHookProc[2] =
{
// WINCE - cut some win95-only calls, so we can drop wselect.cxx from sources
#ifdef WINCE
    NULL, NULL
#else
    &CSelectElement::WComboboxHookProc,
    &CSelectElement::WListboxHookProc
#endif // GAL_VERSION
};

DWORD const CSelectElement::s_dwStyle[] =
{
    WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VSCROLL | CBS_HASSTRINGS | CBS_DROPDOWNLIST,
    WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VSCROLL | LBS_HASSTRINGS | LBS_NOTIFY
};

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::RelIdxFromAbs
//
//  Synopsis:   Maps the current selection from absolute to relative.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::RelIdxFromAbs(long lIndex)
{
    if (lIndex < 0)
        return lIndex;

    if (lIndex >= _aryOptions.Size())
        return -1;
 
    LRESULT lr = lIndex;

    if (_fHasOptGroup)
    {
        Assert( !_aryOptions[lIndex]->_fIsOptGroup );
        lr = -1;
        for ( long i = 0; i <= lIndex; i++ )
        {
            if ( _aryOptions[i]->_fIsOptGroup )
            {
                continue;
            }
            else
            {
                lr++;
            }
        }        
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AbsIdxFromRel
//
//  Synopsis:   Maps the current selection from relative to absolute.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::AbsIdxFromRel(long lIndex)
{
    if (lIndex < 0)
        return lIndex;

    LRESULT lr = lIndex;

    if (_fHasOptGroup)
    {
        for ( long i = 0; i < _aryOptions.Size() && lr >= 0; i++ )
        {
            if ( _aryOptions[i]->_fIsOptGroup )
            {
                continue;
            }
            else
            {
                lr--;
            }
        }
        
        if (lr == lIndex)
        {
            Assert(i == _aryOptions.Size());
            lr = -1;
        }
        else
        {
            Assert(i <= _aryOptions.Size());
            lr = (lr >= 0) ? i : i - 1;
            Assert((lr == i) || !_aryOptions[lr]->_fIsOptGroup);
        }
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetCurSel
//
//  Synopsis:   Sets the newly selected item.
//
//  Arguments:  iNewSel            the new selected entry's index, 0-based
//                                 -1 means no selection
//              fUpdateCollection: TRUE if the Options collection should be traversed
//                                 and the individual _fSELECTED flags updated.
//
//  Note:       Sends the xB_SETCURSEL message to the control if it exists.
//              Stores the new index.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::SetCurSel(int iNewSel, DWORD grfUpdate)
{
    LRESULT lr;

    Assert(!_fMultiple);

    if ( _hwnd && !(grfUpdate & SETCURSEL_DONTTOUCHHWND) )
    {
        lr = SendSelectMessage(Select_SetCurSel, (WPARAM)iNewSel, 0);
    }
    else
    {
        lr = iNewSel >= _aryOptions.Size() ? LB_ERR : iNewSel;
    }

    if (_fListbox && grfUpdate & SETCURSEL_SETTOPINDEX
        && iNewSel >= 0)
    {
        // HACK ALERT (krisma): we shouldn't have to do this
        // because the window's control should do it for us.
        // But for some reason it's not working (see bug 
        // 51945 and all it's dupes).
        SetTopIndex(iNewSel);
    }

    if ( lr != LB_ERR || iNewSel == LB_ERR )
    {
        _iCurSel = iNewSel;

        if ( grfUpdate & SETCURSEL_UPDATECOLL )
        {
            int i;

            for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
            {
                _aryOptions[i]->_fSELECTED = _iCurSel == i;
#if DBG == 1                
                if ( _aryOptions[i]->_fSELECTED )
                    Assert( _aryOptions[i]->_fIsOptGroup == FALSE );
#endif
            }
        }
    }

#if DBG == 1

    // Let's make sure the options collection and _iCurSel are in sync
    if (lr != LB_ERR && _aryOptions.Size() > 0)
    {
        int i;

        for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
        {
            if (_aryOptions[i]->_fSELECTED)
                break;
        }

        Assert (i == _iCurSel);
    }

#endif // DBG == 1

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetCurSel
//
//  Synopsis:   retrieves the current selection's index.
//
//  Note:       Uses the control if it exists.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::GetCurSel(void)
{
    LRESULT lr;

    if ( _hwnd && !_fMultiple)
    {
        lr = SendSelectMessage(Select_GetCurSel, 0, 0);
    }
    else if (!_fMultiple)
    {
        lr = _iCurSel;
    }
    else
    {
        long i;
        long cOptions = _aryOptions.Size();

        Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

        lr = -1;  // if no selection found, selectedIndex will be -1
        for ( i = 0; i < cOptions; i++ )
        {
            if ( _aryOptions[i]->_fSELECTED )
            {
                lr = i;
                Assert( _aryOptions[i]->_fIsOptGroup == FALSE );
                break;
            }
        }
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetSel
//
//  Synopsis:   Sets the selection state of a listbox line.
//
//  Arguments:  lIndex     the index of the line to be changed or -1 if all
//              fSelected  the new selection state
//
//  Note:       Sends the LB_SETSEL message to the control if it exists.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::SetSel(long lIndex, BOOL fSelected, DWORD grfUpdate)
{
    LRESULT lr;

    Assert(_fMultiple);

    if ( _hwnd && !(grfUpdate & SETCURSEL_DONTTOUCHHWND))
    {
        lr = SendSelectMessage(Select_SetSel, (WPARAM)fSelected, (LPARAM)(UINT)lIndex);
    }
    else
    {
        lr = (lIndex >= _aryOptions.Size()) || (lIndex < -1) ? LB_ERR : LB_OKAY;
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetTopIndex
//
//  Synopsis:   Sets the first visible line.
//
//  Arguments:  iNewSel     the new topindex, 0-based
//
//  Note:       Sends the xB_SETTOPINDEX message to the control if it exists.
//              Stores the new index.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::SetTopIndex(int iTopIndex)
{
    LRESULT lr;

#ifndef WIN16
    Assert(_fListbox);

    if ( _hwnd )
    {
        lr = SendSelectMessage(Select_SetTopIndex, (WPARAM)iTopIndex, 0);
    }
    else
#endif // ndef WIN16
    {
        lr = LB_OKAY;
    }

    if (lr != LB_ERR)
    {
        _lTopIndex = iTopIndex;
    }

    return lr;
}



//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AddString
//
//  Synopsis:   Cover for the xB_ADDSTRING handler.
//
//  Arguments:  pstr    the text for the newly inserted line
//
//  Note:       Fakes the action if the control is not around.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::AddString(LPCTSTR pstr)
{
    LRESULT lr;

    if ( _hwnd )
    {
        lr = SendSelectMessage(Select_AddString, 0, pstr ? (LPARAM)pstr : (LPARAM) g_Zero.ach);
    }
    else
    {
        lr = LB_OKAY;
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Init
//
//  Synopsis:   Registers the subclassing windprocs
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::Init()
{
    HRESULT hr   = super::Init();
    ULONG_PTR dw     = 0;

    if (hr)
        goto Cleanup;

    if ( ! GetWndClassAtom(WNDCLASS_COMBOBOX) )
    {
        if (g_fThemedPlatform && IsThemeActive())
            SHActivateContext(&dw);

        hr = THR(RegisterWindowClass(
                WNDCLASS_COMBOBOX,
                SelectElementWndProc,
                0,
                _T("combobox"),
                &s_alpfnSelectWndProc[0]));        

        if (hr)
            goto Cleanup;

        hr = THR(RegisterWindowClass(
                WNDCLASS_LISTBOX,
                SelectElementWndProc,
                0,
                _T("listbox"),
                &s_alpfnSelectWndProc[1]));

        if (hr)
            goto Cleanup;
    }

    _iCurSel = -1;


Cleanup:
    if (dw != 0)
        SHDeactivateContext(dw);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Init2
//
//  Synopsis:   Initialization phase after attributes were set.
//
//  Note:       The control has to be initialized first, as the 2D Div
//              site recalcs from CSite::Init2, which action needs
//              an initialized SELECT.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(InitState());
    if ( hr )
        goto Cleanup;

    hr = THR(super::Init2(pContext));

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLSelectElement2, NULL)
        QI_TEAROFF(this, IHTMLSelectElement4, NULL)
    } // end switch

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::CreateElement
//
//  Synopsis:
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    AssertSz(LB_ERR == CB_ERR, "LB_ERR, CB_ERR error codes changed, need to recode!");
    Assert(s_aMsgs[Select_LastMessage_Guard][0] == OCM__BASE && "Message translation array is BAD!");
    Assert(ARRAY_SIZE(s_aMsgs) == Select_LastMessage_Guard + 1 && "Message translation array size error!");
    Assert(ppElement);

    *ppElement = new CSelectElement(pDoc);

    // If the element is created through DOM enable layout requests
    if (*ppElement && pht->IsDynamic())
        DYNCAST(CSelectElement, *ppElement)->_fEnableLayoutRequests = TRUE;

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


CSelectElement::~CSelectElement()
{
    delete _pCollectionCache;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::UpdateBackgroundBrush
//
//  Synopsis:   Updates the cached brush used to paint the CSS background color
//
//-------------------------------------------------------------------------

void
CSelectElement::UpdateBackgroundBrush(void)
{
    CColorValue ccvBackColor = GetFirstBranch()->GetCascadedbackgroundColor();

    ReleaseCachedBrush(_hBrush);

    if ( ccvBackColor.IsDefined() )
    {
        _hBrush = GetCachedBrush(ccvBackColor.GetColorRef());
    }
    else
    {
        _hBrush = GetCachedBrush(GetSysColorQuick(COLOR_WINDOW));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::InvalidateBackgroundBrush
//
//  Synopsis:   Invalidates the cached brush used to paint the CSS background color
//              It will be re-computed when needed
//
//-------------------------------------------------------------------------

void
CSelectElement::InvalidateBackgroundBrush(void)
{
    ReleaseCachedBrush(_hBrush);
    _hBrush = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::InitState, protected
//
//  Synopsis:   Initializes the private state flags.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::InitState(void)
{
    _fMultiple = GetAAmultiple();

    _fListbox = (_fMultiple || (GetAAsize() > 1));

    _fSendMouseMessagesToDocument = FALSE;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement:NotifyWidthChange
//
//  Synopsis:   Called by the OPTION element whose Text was changed
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::NotifyWidthChange(COptionElement * pOptionChanged)
{
    long lLineLength;

    Assert(pOptionChanged);

    lLineLength = pOptionChanged->MeasureLine();

    if ( (lLineLength > _lMaxWidth ||
          pOptionChanged == _poptLongestText) )
    {
        _sizeDefault.cx = 0;
        ResizeElement();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     DeferUpdateWidth
//
//  Synopsis:   Deferes the call to update the width
//
//  Returns:    None
//
//--------------------------------------------------------------------------

void
CSelectElement::DeferUpdateWidth()
{
    // Kill pending calls if any
    GWKillMethodCall(this, ONCALL_METHOD(CSelectElement, DeferredUpdateWidth, deferredupdatewidth), 0);
    // Defer the update width call
    IGNORE_HR(GWPostMethodCall(this,
                               ONCALL_METHOD(CSelectElement, DeferredUpdateWidth, deferredupdatewidth),
                               0, TRUE, "CSelectElement::DeferredUpdateWidth"));
}

void
CSelectElement::DeferredUpdateWidth(DWORD_PTR dwContext)
{
    _sizeDefault.cx = 0;
    ResizeElement();
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::OnPropertyChange
//
//  Synopsis:   Call notify on the site and all of its children
//
//  Note:       Here we provide for morphing between the list and the combo
//              shape of the control.
//              Due to the weirdness of the Windows listbox control we
//              need to morph (i.e. destroy and recreate the control
//              even when changing the multiselect state of the listbox as
//              simply changing the WS_EXTENDEDSEL bit has no effect.
//
//              The pragma is here because the optimizing compiler chokes
//              on the call to delete[] paryData in cleanup. It's a mystery.
//-------------------------------------------------------------------------

HRESULT
CSelectElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    BOOL fIsNewShapeListbox = _fListbox;
    BOOL fMorph = FALSE;
    BOOL fSizeChanged = FALSE;
    BOOL fMultiSelectChanged = FALSE;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if ( hr )
        goto Cleanup;

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_CSelectElement_multiple )
    {
        //  Multiple
        //  Compute new shape
        fIsNewShapeListbox = GetAAmultiple() || GetAAsize() > 1;
        fMultiSelectChanged = TRUE;
        fMorph = TRUE;
    }

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_CSelectElement_size )
    {
        //  Size
        //  Compute new shape
        fIsNewShapeListbox = GetAAmultiple() || GetAAsize() > 1;
        fSizeChanged = TRUE;
        _fRefreshFont = TRUE;
    }

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_BACKCOLOR )
    {
        InvalidateBackgroundBrush();
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_A_COLOR )
    {
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == STDPROPID_XOBJ_WIDTH ||
         dispid == STDPROPID_XOBJ_HEIGHT ||
         dispid == DISPID_UNKNOWN )
    {
        _sizeDefault.cx = _sizeDefault.cy = 0;
    }

    if ( dispid == DISPID_A_FONTFACE ||
         dispid == DISPID_A_FONTSIZE ||
         dispid == DISPID_A_TEXTDECORATIONLINETHROUGH ||
         dispid == DISPID_A_TEXTDECORATIONUNDERLINE ||
         dispid == DISPID_A_TEXTDECORATIONNONE ||
         dispid == DISPID_A_TEXTDECORATION ||
         dispid == DISPID_A_FONTSTYLE ||
         dispid == DISPID_A_FONTVARIANT ||
         dispid == DISPID_A_FONTWEIGHT ||
         dispid == DISPID_UNKNOWN)
    {
        _sizeDefault.cx = _sizeDefault.cy = 0;
        _fRefreshFont = TRUE;
        ResizeElement();
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == DISPID_A_TEXTTRANSFORM ||
         //dispid == DISPID_A_LETTERSPACING ||
         dispid == DISPID_UNKNOWN)
    {
        _sizeDefault.cx = _sizeDefault.cy = 0;
        ResizeElement();
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == DISPID_CElement_disabled ||
         dispid == DISPID_AMBIENT_USERMODE ||
         dispid == DISPID_UNKNOWN )
    {
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::EnableWindow(_hwnd, IsEditable(TRUE) || IsEnabled());
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    // the direction was changed
    if ( dispid == DISPID_A_DIR || dispid == DISPID_A_DIRECTION )
    {
        _fNeedMorph = TRUE;
    }

    if ( fMorph ||
         _fListbox && ! fIsNewShapeListbox ||
         ! _fListbox && fIsNewShapeListbox )
    {
        _fNeedMorph = TRUE;
    }

    if ( fSizeChanged || fMorph )
    {
        //  Compute new size
        //  Request new layout from the doc.
        _sizeDefault.cx = _sizeDefault.cy = 0;
        ResizeElement();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Morph, protected
//
//  Synopsis:   Change the instantiaited Windows control, preserving data
//
//  Note:       The control needs to be reinstantiated to chenge between
//              combo, single-select list and mulstiselect list.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::Morph(void)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    //  pull the data out into a list
    //  Get rid of the old window
    //  Create the new window
    //  Pump the data into the new window
    //  Compute the new extents
    //  Request new layout from the Doc

    hr = THR(PullStateFromControl());
    if ( hr )
        goto Cleanup;

    DestroyControlWindow();

    _fWindowDirty = TRUE;

    hr = InitState();    //  _fMultiple is set up here
    if ( hr )
        goto Cleanup;

    if ( pDoc && pDoc->_state >= OS_INPLACE )
    {
        hr = THR(EnsureControlWindow());
        if ( hr )
            goto Cleanup;
    }

    _fNeedMorph = FALSE;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Notify
//
//  Synopsis:   Listen for tree notifications
//
//-------------------------------------------------------------------------

void
CSelectElement::Notify(CNotification *pNF)
{
    DWORD       dwData;
    HRESULT     hr = S_OK;
    IStream *   pStream = NULL;
    long        lTopIndex;
    long        lIndex;
    DWORD       dwIndex;

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        if (_fSendMouseMessagesToDocument)
        {
            ((CQueryFocus *)pNF->DataAsPtr())->_fRetVal = TRUE;
        }
        break;
    case NTYPE_ELEMENT_SETFOCUS:
        if (    _hwnd
            &&  _hwnd != ::GetFocus()

            // Take focus only if _fTakeFocus is TRUE (user setting focus through click, TAB, etc.)
            // or if the browser already has focus
            &&  (   ((CSetFocus *)pNF->DataAsPtr())->_fTakeFocus
                 || Doc()->HasFocus()
                )
           )
        {
            //  Lock any focus firing. BecomeCurrent has already done all that.

            CLock Lock(this, ELEMENTLOCK_FOCUS);
            ::SetFocus(_hwnd);
        }
        break;
    case NTYPE_AMBIENT_PROP_CHANGE:
        pNF->Data(&dwData);
        if (dwData == DISPID_AMBIENT_USERMODE ||
            dwData == DISPID_UNKNOWN ||
            dwData == DISPID_AMBIENT_RIGHTTOLEFT)
        {
            if (dwData != DISPID_AMBIENT_RIGHTTOLEFT)
            {
                ::EnableWindow(_hwnd, IsEditable(TRUE) || IsEnabled());
            }
            else
            {
                //  Recreate the control to make sure it is going the
                //  correct direction. We do not have the CParaFormat change
                //  yet and cannot enqueue a layout request here. Therefore
                //  we will set a flag and call Morph() when laying out
                //  (CSelectLayout::CalcSize()).
                _fNeedMorph = TRUE;
            }
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_1:
        if (    Doc()->State() < OS_INPLACE 
            &&  (OLE_SERVER_STATE)(pNF->DataAsDWORD()) >= OS_INPLACE)
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_2:
        Assert (    Doc()->State() < OS_INPLACE 
                &&  (OLE_SERVER_STATE)(pNF->DataAsDWORD()) >= OS_INPLACE );

        hr = THR(OnInPlaceDeactivate());
        if (hr)
            goto Cleanup;
        if (HasLayoutPtr())
        {
            DYNCAST(CSelectLayout, Layout())->_fWindowHidden = TRUE;
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_SAVE_HISTORY_2:
        {
            CDataStream         ds;
            CHistorySaveCtx *   phsc;

            pNF->Data((void **)&phsc);
            hr = THR(phsc->BeginSaveStream((     0x80000000
                                            |   (DWORD)_iHistoryIndex
                                            &   0x0FFFF),
                                            HistoryCode(), &pStream));
            if (hr)
                goto Cleanup;

            ds.Init(pStream);

            // Save TopIndex (index of first visible item)
            if ( _fListbox )
            {
#ifndef WIN16
                // BUGWIN16: Win16 doesn't support Select_GetTopIndex,
                // so am turning this off. is this right ?? vreddy - 7/16/97
                if ( _hwnd )
                {
                    lTopIndex = SendSelectMessage(Select_GetTopIndex, 0, 0);
                }
                else
#endif // ndef WIN16
                {
                    lTopIndex = _lTopIndex;
                }
            }
            else
            {
                lTopIndex = LB_ERR;
            }
            hr = THR(ds.SaveDword(lTopIndex));
            if (hr)
                goto Cleanup;


            // Save the indices of the selected items
            if (_fMultiple)
            {
                for (lIndex = _aryOptions.Size() - 1; lIndex >= 0; lIndex--)
                {
                    if ( _aryOptions[lIndex]->_fSELECTED )
                    {
                        hr = THR(ds.SaveDword(lIndex));
                        if (hr)
                            goto Cleanup;
                    }
                }
            }
            else
            {
                if (_iCurSel != LB_ERR)
                {
                    Assert(GetCurSel() == _iCurSel);
                    hr = THR(ds.SaveDword(_iCurSel));
                    if (hr)
                        goto Cleanup;
                }
            }

            // Use LB_ERR as the terminator
            hr = THR(ds.SaveDword((DWORD)LB_ERR));
            if (hr)
                goto Cleanup;

            hr = THR(phsc->EndSaveStream());
            if (hr)
                goto Cleanup;
        }

        break;

    case NTYPE_END_PARSE:
        // TODO (jbeda) this should probably happen 
        // on NTYPE_DELAY_LOAD_HISTORY
        pStream = NULL;

        if(IsInMarkup())
        {
            IGNORE_HR(GetMarkup()->GetLoadHistoryStream((     0x80000000
                                                        |   (DWORD)_iHistoryIndex
                                                        &   0x0FFFF),
                                                      HistoryCode(),
                                                      &pStream));
        }

        //  The history load logic requires that _aryOptions is up to date.

        _fOptionsDirty = TRUE;

        if (_hwnd)
        {
            // HACKALERT!  (BUG 67310) We need to resync the hwnd to the OM here
            // and resize the control. We're not really morphing, 
            // but setting this flag does everything we need.
            _fNeedMorph = TRUE;
        }
        else
        {
            BuildOptionsCache();
        }

        if (pStream)
        {
            CDataStream ds(pStream);
            BOOL        fFirst = TRUE;

            // Load TopIndex (first visible item)
            hr = THR(ds.LoadDword(&dwIndex));
            if (hr)
                goto Cleanup;
            if (_fListbox && dwIndex != LB_ERR)
            {
                SetTopIndex(dwIndex);
            }

            // Set selection (reset the current selection first)
            if ( _fMultiple )
            {
                int i;

                SetSel(-1, FALSE);
                for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
                {
                    _aryOptions[i]->_fSELECTED = FALSE;
                }
            }
            else
            {
                SetCurSel(-1, SETCURSEL_UPDATECOLL);
            }

            hr = THR(ds.LoadDword(&dwIndex));
            if (hr)
                goto Cleanup;
            while (dwIndex != LB_ERR)
            {
                if (!fFirst && !_fMultiple)
                {
                    // Cannot select more than one item !
                    Assert(FALSE);
                    break;
                }
                fFirst = FALSE;

                // select the item at dwIndex
                if ((long)dwIndex < _aryOptions.Size())
                {
                    LRESULT lr;

                    _aryOptions[dwIndex]->_fSELECTED = TRUE;
                    lr = (_fMultiple) ?
                        SetSel(dwIndex, TRUE) :
                        SetCurSel(dwIndex);

                    hr = (lr == LB_ERR) ? E_FAIL : S_OK;

                    if (hr)
                        goto Cleanup;
                }
                hr = THR(ds.LoadDword(&dwIndex));
                if (hr)
                    goto Cleanup;
           }

        }

        //  Unblock layout requests
        _fEnableLayoutRequests = TRUE;

        //  Kick off a request to ensure the UI
        Layout()->Dirty();
        ResizeElement();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
    case NTYPE_ELEMENT_EXITVIEW_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        ExitTree();
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        if (GetMarkup())
            _fUseThemes = !!(GetMarkup()->GetThemeUsage() == THEME_USAGE_ON);
        EnterTree();
        break;

    case NTYPE_ELEMENT_EXITVIEW_2:
        ExitView();
        break;
    }

Cleanup:
    ReleaseInterface(pStream);
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::EnterTree
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::EnterTree()
{
    HRESULT                    hr = S_OK;
    CMarkup *             pMarkup = GetMarkup(); Assert(pMarkup);
    CMarkupTransNavContext * ptnc = pMarkup->EnsureTransNavContext();

    if (!ptnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _fOptionsDirty  = TRUE;
    _sizeDefault.cx = _sizeDefault.cy = 0;
    _iHistoryIndex  = (unsigned short)ptnc->_dwHistoryIndex++;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::ExitTree
//
//  Synopsis:   Shuts down the SELECT
//
//              Frees private data,
//              destroys the control window,
//              releases the font
//
//-------------------------------------------------------------------------

void
CSelectElement::ExitTree()
{
    _poptLongestText = NULL;
    _lMaxWidth = 0;

    _aryOptions.DeleteAll();

    ExitView();
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::ExitView
//
//
//-------------------------------------------------------------------------

void
CSelectElement::ExitView()
{
    if ( _hFont )
    {
        Verify(DeleteObject(_hFont));
        _hFont = NULL;
    }

    if ( _hBrush )
    {
        ReleaseCachedBrush(_hBrush);
        _hBrush = NULL;
    }

    DestroyControlWindow();
}

//+---------------------------------------------------------------------------
//
//  Member: CSelectElement::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CSelectElement::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_HISTORYCODE:
        return MAKELONG(_fMultiple, Tag());
    }

    return super::GetInfo(gi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetEnabled
//
//  Synopsis:   return not disabled
//
//----------------------------------------------------------------------------

STDMETHODIMP
CSelectElement::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = GetAAdisabled() ? VB_FALSE : VB_TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::EnsureControlWindow, protected
//
//  Synopsis:   Ensure the control window and the correct contents.
//
//  Note:       The Doc must be inplace active here. The SELECT needs the
//              Doc's inplace window to be its parent, otherwise
//              WM_COMMAND based notifications from the SELECT will eventually
//              get lost.
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::EnsureControlWindow()
{
    HRESULT hr;

    hr = THR(CreateControlWindow());
    if ( hr )
        goto Cleanup;

    if ( _fWindowDirty )
    {
        hr = THR(PushStateToControl(TRUE));     //  Indicate being called from Create
        if ( hr )
            goto Cleanup;
    }


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::CreateControlWindow, protected
//
//  Synopsis:   Create the child control window.
//
//  Note:       The Doc must be inplace active here. The SELECT needs the
//              Doc's inplace window to be its parent, otherwise
//              WM_COMMAND based notifications from the SELECT will eventually
//              get lost.
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::CreateControlWindow()
{
    HRESULT            hr                = S_OK;    
    CTreeNode         *pTNode            = GetFirstBranch();
    const CParaFormat *pPF               = NULL;     
    CMarkup           *pMarkup           = GetMarkup();
    ULONG_PTR          dwfTheme          = 0;
    DWORD              dwStyle;
    LPTSTR             lpszClassName;
    DWORD              dwExtStyle;
    UINT               uIndex;

    // $$ktam Used to be layout RTL flag setting here until we yanked RTL from display tree

    if ( _hwnd )
        goto Cleanup;

    TraceTag((tagSelectState, "SELECT %x creating window", this));

    //  Find the parent hwnd
    Assert(Doc() && Doc()->_pInPlace && Doc()->_pInPlace->_hwnd);

    dwStyle = s_dwStyle[_fListbox];

    if ( _fListbox && _fMultiple )
    {
        dwStyle |= LBS_EXTENDEDSEL;
    }

    if ( GetAAdisabled() && (!IsEditable(TRUE)) )
    {
        dwStyle |= WS_DISABLED;
    }

    //
    // some conditions the _fWin95Wide code depends on (benwest 11-13-96):
    // if the following asserts fail it will break code that is rarely run
    //

    // it would be bad if more than one person implements ownerdraw-ness...
    Assert(!(dwStyle & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)));
    // we don't support ordered lists it would wreak havoc on the Optios collection)
    Assert(!(dwStyle & (_fListbox ? LBS_SORT : CBS_SORT)));

#ifndef WIN16
    // adjust the style bits
    dwStyle |= LBS_OWNERDRAWFIXED;
    dwStyle &= (_fListbox ? ~LBS_HASSTRINGS : ~CBS_HASSTRINGS);
#endif

    uIndex = _fListbox ? WNDCLASS_LISTBOX : WNDCLASS_COMBOBOX;
    lpszClassName = (TCHAR *)(DWORD_PTR)GetWndClassAtom(uIndex);

    dwExtStyle = WS_EX_CLIENTEDGE;
// WINCE - cut WS_EX_NOPARENTNOTIFY from CreateWindowEx
#ifndef WINCE
    dwExtStyle |= WS_EX_NOPARENTNOTIFY;
    
    if (pTNode)
        pPF = pTNode->GetParaFormat();

    if(pTNode && pPF && pPF->HasRTL(TRUE))
    {
        dwExtStyle |= WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT;
    }
#endif
    
    _fUseThemes = !!(pMarkup->GetThemeUsage() == THEME_USAGE_ON);

    if (g_fThemedPlatform && 
         (    ( _fListbox && pMarkup->GetThemeUsage() != THEME_USAGE_OFF)
           || (!_fListbox && pMarkup->GetThemeUsage() == THEME_USAGE_ON)))
    {    
        SHActivateContext(&dwfTheme);
    }

    
    _hwnd = ::CreateWindowEx(dwExtStyle,
                             lpszClassName,
                             NULL,
                             dwStyle,
                             0,0,0,0,                           //  Create invisible
                             Doc()->_pInPlace->_hwnd,
                             NULL,
                             g_hInstCore,
                             this);

    if ( ! _hwnd )
        goto Win32Error;

    if (g_fThemedPlatform && 
        (   ( _fListbox && pMarkup->GetThemeUsage() == THEME_USAGE_OFF)
         || (!_fListbox && pMarkup->GetThemeUsage() != THEME_USAGE_ON)))
    {
        COMBOBOXINFO cbi = {0};
        
        cbi.cbSize = sizeof(cbi);
        if ( GetComboBoxInfo(_hwnd, &cbi) )
        {
            SetWindowTheme(cbi.hwndItem, _T(""), _T(""));
            if (pMarkup->GetThemeUsage() == THEME_USAGE_OFF)
                SetWindowTheme(cbi.hwndList, _T(""), _T(""));
        }

        SetWindowTheme(_hwnd, _T(""), _T(""));
    }
    
    _fWindowDirty = TRUE;

Cleanup:
    if (dwfTheme != 0)
        SHDeactivateContext(dwfTheme);

    RRETURN(hr);


Error:
    if ( _hwnd )
    {
        DestroyWindow(_hwnd);
        _hwnd = 0;
    }
    goto Cleanup;

Win32Error:
    hr = GetLastWin32Error();
    goto Error;

}


//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::OnInPlaceDeactivate, protected
//
//  Synopsis:   Handle the doc leaving inplace.
//
//  Note:       Reparent the control window to the global window
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::OnInPlaceDeactivate(void)
{
    if ( _hwnd )
    {
        DestroyControlWindow();
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::DestroyControlWindow, protected
//
//  Synopsis:   Get rid of the control child window.
//
//-------------------------------------------------------------------------

void
CSelectElement::DestroyControlWindow()
{
    if ( _hwnd )
    {
        //  The control has to be emptied before we destroy it
        //  otherwise Win95 sends WM_DELETEITEM messages
        //  after WM_NCDESTROY.

        TraceTag((tagSelectState, "SELECT %x destroying window", this));

        SendSelectMessage(Select_ResetContent, 0, 0);
        DestroyWindow(_hwnd);
        _hwnd = 0;
        _fWindowVisible = FALSE;
        _fSetComboVert = TRUE;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::PushStateToControl, protected
//
//  Synopsis:   Transfer the state stored in the Options array
//              to the child window control.
//
//  Note:       This include display text and selection state.
//
//-------------------------------------------------------------------------
HRESULT
CSelectElement::PushStateToControl(BOOL fFromCreate)
{
    HRESULT hr = S_OK;
    long cOptions;
    long i;
    LRESULT lr;
    BOOL fSelectedSet = FALSE;
    CDoc *  pDoc = Doc();
    int iLastSelected = -1;

    TraceTag((tagSelectState, "SELECT %x pushing state to window", this));
    if (!_hwnd)
        goto Cleanup;

    TraceTag((tagSelectInval, "SEL %d hwnd %x  - SetRedraw(FALSE)",
                    SN(), _hwnd));

    _fNoRedraw = 1;
    ::SendMessage(_hwnd, WM_SETREDRAW, (WPARAM) FALSE,0);

    SendSelectMessage(Select_ResetContent, 0, 0);

    ::SendMessage(_hwnd, WM_SETFONT, (WPARAM) _hFont, MAKELPARAM(FALSE,0));

    //  Restore the <OPTION>s

    hr = THR(BuildOptionsCache());
    if (hr) 
        goto Cleanup;

    cOptions = _aryOptions.Size();

    for ( i = 0; i < cOptions; i++ )
    {
        lr = SendSelectMessage(Select_AddString, 0,
                               _aryOptions[i]->_cstrText ?
                                (LPARAM)(LPTSTR)_aryOptions[i]->_cstrText :
                                (LPARAM)(LPCTSTR)g_Zero.ach);
        if ( lr == LB_ERR )
            goto Win32Error;

        if ( _aryOptions[i]->_fSELECTED )
        {
            Assert( _aryOptions[i]->_fIsOptGroup == FALSE );

            if ( _fMultiple )
            {
                lr = SetSel(i, TRUE);
                if ( lr == LB_ERR )
                    goto Win32Error;
            }
            else
            {
                fSelectedSet = TRUE;
                iLastSelected = i;
            }
        }
    }

#ifndef WIN16
    if ( _fListbox )
    {
        SendSelectMessage(Select_SetTopIndex, (WPARAM)_lTopIndex, 0);
    }
#endif // ndef WIN16

    if ( ! _fMultiple )
    {
        if ( !fSelectedSet )
        {
            SetCurSel(_iCurSel, SETCURSEL_UPDATECOLL);
        }
        else
        {
            SetCurSel(iLastSelected, SETCURSEL_UPDATECOLL | SETCURSEL_SETTOPINDEX);
        }
    }

    TraceTag((tagSelectInval, "SEL %d hwnd %x  - SetRedraw(TRUE)",
                    SN(), _hwnd));

    ::SendMessage(_hwnd, WM_SETREDRAW, (WPARAM) TRUE,0);

    _fNoRedraw = TRUE;
    if (_fMissedPaint)
    {
        ::InvalidateRect(_hwnd, 0, 0);
        _fMissedPaint = FALSE;
    }

    //  Set up visual state
    {
        CRect   rc;

        GetUpdatedLayout()->GetRect(&rc, COORDSYS_GLOBAL);

        if ( _fWindowVisible && fFromCreate)
        {
            // position the new window and show it
            MoveWindow(_hwnd,
                       rc.left,
                       rc.top,
                       rc.right - rc.left,
                       _fListbox ? rc.bottom - rc.top : _lComboHeight,
                       FALSE);

            Doc()->GetView()->SetWindowRgn(_hwnd, &rc, FALSE);
        }

        if ( ! fFromCreate  || _fWindowVisible )
            ShowWindow(_hwnd, (_fWindowVisible
                                    ? SW_SHOW
                                    : SW_HIDE));
    }

    if ( pDoc->_pElemCurrent == this )
    {
        BOOL fOldInhibit = pDoc->_fInhibitFocusFiring;
        pDoc->_fInhibitFocusFiring = TRUE;
        ::SetFocus(_hwnd);
        pDoc->_fInhibitFocusFiring = fOldInhibit;
    }

    _fWindowDirty = FALSE;

Cleanup:
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;

}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::PullStateFromControl, protected
//
//  Synopsis:   Store the child window control's state
//              in the Options array
//
//  Note:       This needs to pull only selection state, everything
//              else should already be in the Options.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::PullStateFromControl()
{
    HRESULT hr = S_OK;
    long cOptions;
#if (DBG == 1 && defined(WIN16))
    long i;
    LRESULT lr;
#endif

    if ( ! _hwnd )
        goto Cleanup;


    Assert(_hFont == (HFONT)::SendMessage(_hwnd, WM_GETFONT, 0, 0));

    cOptions = _aryOptions.Size();
    Assert(SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

    //  save the <OPTION>s
#if DBG == 1 && defined(WIN16)
    for ( i = 0; i < cOptions; i++ )
    {
        {
            TCHAR achBuf[FORMS_BUFLEN];

            lr = SendSelectMessage(Select_GetText, (WPARAM)i, (LPARAM)(LPTSTR)achBuf);
            if ( lr == LB_ERR )
                goto Win32Error;

            Assert(0 == _aryOptions[i]->_cstrText.Length() && TEXT('\0') == *achBuf ||
                   0 == StrCmpC(_aryOptions[i]->_cstrText, achBuf));  //  Hack: direct access!
        }
    }
#endif // DBG


Cleanup:
    RRETURN(hr);

#if (DBG == 1 && defined(WIN16)) // Perf
Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
#endif

}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CSelectElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HRESULT hr = S_OK;

    LOGFONT    lf;
    CUnitValue uvBorder;
    DWORD      dwRawValue;
    BYTE       i;
    BOOL       fRelative         = pCFI->_pcf->_fRelative;
    BOOL       fVisibilityHidden = pCFI->_pcf->_fVisibilityHidden;
    BOOL       fDisplayNone      = pCFI->_pcf->_fDisplayNone;
    BOOL       fNoBreak          = pCFI->_pcf->_fNoBreak;
    BOOL       fRightToLeft      = pCFI->_pcf->_fRTL;
    BOOL       fEditable         = pCFI->_pcf->_fEditable;
    BOOL       fParentFrozen     = pCFI->_pcf->_fParentFrozen;
    WORD       wLayoutFlow       = pCFI->_pcf->_wLayoutFlow;
    BOOL       fWritingModeUsed  = pCFI->_pcf->_fWritingModeUsed;
    CDoc *     pDoc              = Doc();

    pCFI->PrepareCharFormat();
    pCFI->PrepareParaFormat();

    if (!!_fUseThemes != !!(GetMarkup()->GetThemeUsage() == THEME_USAGE_ON) )
        _fNeedMorph = TRUE;

    //  Block CF inheritance by reiniting to defaults
    pCFI->_cf().InitDefault(pDoc->_pOptionSettings, GetMarkup()->GetCodepageSettings(), FALSE);

    // The code used to rely on the fact that styleCursorAuto is 0. Lets be sure it is
    // (InitDefault does a memset to 0)
    Assert(pCFI->_cf()._bCursorIdx == styleCursorAuto);
    
    // Inherit no break behaviour.
    pCFI->_cf()._fNoBreak = fNoBreak;

    // We must inherit visibility.
    pCFI->_cf()._fVisibilityHidden = fVisibilityHidden;
    pCFI->_cf()._fDisplayNone      = fDisplayNone;

    // Inherit direction.
    pCFI->_cf()._fRTL = fRightToLeft;

    // inherit relative ness
    pCFI->_cf()._fRelative = !!fRelative;

    // inherit layout flow
    pCFI->_cf()._wLayoutFlow = wLayoutFlow;

    // inherit how we obtained out layout flow
    pCFI->_cf()._fWritingModeUsed = fWritingModeUsed;

    // inherit editable
    pCFI->_cf()._fEditable = fEditable;

    // inherit frozen
    pCFI->_cf()._fParentFrozen = fParentFrozen;

    DefaultFontInfoFromCodePage(GetMarkup()->GetCodePage(), &lf, pDoc);
    pCFI->_cf()._bCharSet = lf.lfCharSet;
    pCFI->_cf()._fNarrow = IsNarrowCharSet(lf.lfCharSet);
    pCFI->_cf().SetFaceName( lf.lfFaceName);

    pCFI->_cf().SetHeightInNonscalingTwips(10*20); //was abs(twips)

    // Default text color should be system color (davidd)
    pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_WINDOWTEXT);

    pCFI->_pf()._cuvTextIndent.SetPoints(0);

    pCFI->UnprepareForDebug();

    // Border stuff
    uvBorder.SetValue( 2, CUnitValue::UNIT_PIXELS );
    dwRawValue = uvBorder.GetRawValue();

    pCFI->PrepareFancyFormat();
    CColorValue ccv; ccv.SetSysColor(COLOR_WINDOW);
    CUnitValue cuv; cuv.SetRawValue(dwRawValue);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderColor(i, ccv);
        pCFI->_ff()._bd.SetBorderWidth(i, cuv);
        pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSunken);
    }
    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_3DHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_3DSHADOW);
    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetNaturalExtent
//
//  Synopsis:   Negotiate proposed size with the container
//
//  Note:       This method interacts with the resize trackers.
//              It provides integral-height resize feedback for the SELECT.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::GetNaturalExtent(DWORD dwExtentMode, SIZEL *psizel)
{
    SIZE size;
    CDoc *  pDoc = Doc();

    if ( ! psizel )
        return E_FAIL;

    if ( _lFontHeight == 0 )
        return E_FAIL;

    pDoc->DeviceFromHimetric(size, *psizel);
    size.cy -= 6;   //  Adjust for borders
    size.cy -= size.cy % _lFontHeight;   //  Compute integralheight
    size.cy = max(size.cy, _lFontHeight);
    size.cy += 6;
    size.cx = max(size.cx, CX_SELECT_DEFAULT_PIXEL);
    pDoc->HimetricFromDevice(*psizel, size);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::get_selectedIndex
//
//  Synopsis:   SelectedIndex property
//
//  Note:       Single-select:  the selected entry's index or -1
//              Multiselect:    the first selected entry's index or -1
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::get_selectedIndex(long * plSelectedIndex)
{
    HRESULT hr = S_OK;

    if ( ! plSelectedIndex )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    BuildOptionsCache();

    if ( ! _fMultiple )
    {
        *plSelectedIndex = RelIdxFromAbs( _iCurSel );
    }
    else
    {
        long i;
        long cOptions = _aryOptions.Size();

        Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

        *plSelectedIndex = -1;  // if no selection found, selectedIndex will be -1
        for ( i = 0; i < cOptions; i++ )
        {
            if ( _aryOptions[i]->_fSELECTED )
            {
                *plSelectedIndex = RelIdxFromAbs( i );
                break;
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::put_selectedIndex
//
//  Synopsis:   SelectedIndex property
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::put_selectedIndex(long lRelSelectedIndex)
{
    LRESULT lr;
    HRESULT hr = S_OK;
    int i;
    int iOldSel = -1;
    BOOL    fFirePropertyChange = FALSE;
    long lSelectedIndex;

    BuildOptionsCache();

    lSelectedIndex = AbsIdxFromRel( lRelSelectedIndex );

    // this value is used to revert if the database was unable
    // to store the value.
    long iPrevSel = GetCurSel();

    if ( lSelectedIndex >= _aryOptions.Size() ||
         lSelectedIndex < -1 )
    {
        lSelectedIndex = -1;
    }

    if ( ! _fMultiple )
    {
        if ( _iCurSel != lSelectedIndex )
        {
            iOldSel = _iCurSel;
            lr = SetCurSel(lSelectedIndex, SETCURSEL_UPDATECOLL);
            if ( lr == LB_ERR && lSelectedIndex != LB_ERR )
            {
                _iCurSel = lSelectedIndex;
                //
                // NOTE (yinxie): we shouldn't let the window error
                // returned, because it is meaningless for the users
                // goto Win32Error;
            }

            fFirePropertyChange = TRUE;
        }
    }
    else
    {
        iOldSel = GetCurSel();
        lr = SetSel(-1, FALSE);
        if ( lr == LB_ERR )
            goto Win32Error;

        // when lSelectedIndex = -1, we should not select any item
        lr = SetSel(lSelectedIndex, (lSelectedIndex != -1));
        if ( lr == LB_ERR )
            goto Win32Error;

        for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
        {
            if (!fFirePropertyChange && (i == lSelectedIndex) != _aryOptions[i]->_fSELECTED)
            {
                fFirePropertyChange = TRUE;
            }
            _aryOptions[i]->_fSELECTED = i == lSelectedIndex;
        }
    }

#ifndef NO_DATABINDING
    if (!OK(SaveDataIfChanged(ID_DBIND_DEFAULT)))
    {
        SetCurSel(iPrevSel, SETCURSEL_UPDATECOLL);
        fFirePropertyChange = FALSE;
    }
#endif

    if (fFirePropertyChange)
    {
        hr = THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
        if (hr)
            goto Cleanup;
        if (HasValueChanged(iOldSel, GetCurSel()))
        {
            hr = THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                      0,
                                      (PROPERTYDESC *)&s_propdescCSelectElementvalue));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     get_value
//
//  Synopsis:   collection object model, defers to Cache helper
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::get_value(BSTR * pbstrValue)
{
    HRESULT hr = S_OK;
    long i;
    long cOptions;
    COptionElement * pOption;

    if ( ! pbstrValue )
        return E_POINTER;

    *pbstrValue = NULL;

    BuildOptionsCache();

    if ( _aryOptions.Size() < 1 )
        goto Cleanup;

    if ( _fMultiple )
    {
        cOptions = _aryOptions.Size();
        Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

        for ( i = 0; i < cOptions; i++ )
        {
            if ( _aryOptions[i]->_fSELECTED )
                break;
        }

        if ( i >= cOptions )
        {
            i = -1;
        }

    }
    else
    {
        i = _iCurSel;
    }
    if ( i < 0 )
        goto Cleanup;

    pOption = _aryOptions[i];
    if ( ! pOption )
        goto Cleanup;

    hr = THR(pOption->get_PropertyHelper(pbstrValue, (PROPERTYDESC *)&s_propdescCOptionElementvalue));

Cleanup:
    TraceTag((tagSelectState, "SELECT::getValue returning %ls", *pbstrValue));
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     put_value
//
//  Synopsis:   collection object model, defers to Cache helper
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::put_value(BSTR bstrValue)
{
    HRESULT hr = S_OK;
    LRESULT lr;
    long i;
    long cOptions;
    LPCTSTR pstrOptionValue;
    BOOL fFirePropertyChange = TRUE;

    BuildOptionsCache();

    // this value is used to revert if the database was unable
    // to store the value.
    long iPrevSel = GetCurSel();

    if ( ! bstrValue )
    {
        i = -1L;
    }
    else
    {
        cOptions = _aryOptions.Size();

        for ( i = 0; i < cOptions; i++ )
        {
            pstrOptionValue = _aryOptions[i]->GetAAvalue();

            if ( pstrOptionValue )
            {
                if ( 0 == StrCmpC(pstrOptionValue, bstrValue) )
                {
                    break;
                }
            }
        }

        if ( i >= cOptions )
        {
            i = -1;
        }
    }

    if ( _fMultiple )
    {
        lr = SetSel(-1, FALSE);
        if ( lr == LB_ERR )
            goto Win32Error;

        if ( i > -1 )
        {
            lr = SetSel(i, TRUE);
            if ( lr == LB_ERR )
                goto Win32Error;
        }
    }
    else
    {
        SetCurSel(i, SETCURSEL_UPDATECOLL);
    }

#ifndef NO_DATABINDING
    if (!OK(SaveDataIfChanged(ID_DBIND_DEFAULT)))
    {
        SetCurSel(iPrevSel, SETCURSEL_UPDATECOLL);
        fFirePropertyChange = FALSE;
    }
#endif

    TraceTag((tagSelectState, "SELECT::putValue setting %ls", bstrValue));

    if (i != iPrevSel && fFirePropertyChange)
    {
        hr = THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementvalue));
        if (hr)
            goto Cleanup;
        // if the value changed, then the selected element changed too.
        hr = THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Item(SELECT_OPTION_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;

    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(SELECT_OPTION_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::tags(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Tags(SELECT_OPTION_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::urns(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Urns(SELECT_OPTION_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetNewEnum(SELECT_OPTION_COLLECTION, ppEnum));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Add
//
//  Synopsis:   Add item to collection...
//
//-------------------------------------------------------------------------
HRESULT
CSelectElement::add(IHTMLElement * pIElement, VARIANT varIndex)
{
    HRESULT             hr;
    CElement *          pElement;
    COptionElement *    pOption;
    IUnknown *          pUnk;
    long                lItemIndex;

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure this is an <OPTION> element
    hr = THR(pIElement->QueryInterface(IID_IHTMLOptionElement, (void**)&pUnk));
    ReleaseInterface(pUnk);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get index
    hr = THR(VARIANTARGToIndex(&varIndex, &lItemIndex));
    if (hr)
        goto Cleanup;

    if (lItemIndex < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Verify(S_OK == THR(pIElement->QueryInterface(CLSID_CElement, (void **)&pElement)));

    // Bail out if the element is already in the tree - #25130
    // Also bail out if the element wasn't created in this document
    if (pElement->IsInMarkup() || pElement->Doc() != Doc())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pOption = (COptionElement *)pElement;
    hr = THR(AddOptionHelper(pOption, lItemIndex, pOption->_cstrText, FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::GetLength
//
//  Synopsis:   Helper for number of OPTIONS (deals with OPTGROUP)
//
//--------------------------------------------------------------------------

long
CSelectElement::GetLength()
{
    long length = _aryOptions.Size();

    if (_fHasOptGroup)
    {
        for ( long i = 0; i < _aryOptions.Size(); i++ )
        {
            if ( _aryOptions[i]->_fIsOptGroup )
            {
                length--;
            }
        }
    }

    return length;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::get_length
//
//  Synopsis:   length property: the number of entries
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::get_length(long * plLength)
{
    if ( ! plLength )
        RRETURN (SetErrorInfo(E_POINTER));

    BuildOptionsCache();

    *plLength = GetLength();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::put_length
//
//  Synopsis:   Sets length (i.e. the number of entries). Truncates or
//              expands (by padding with dummy elements) the array as needed.
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::put_length(long lLengthNew)
{
    HRESULT             hr = S_OK;
    long                l, lLengthOld;
    CElement *          pElement = NULL;

    if (lLengthNew < 0)
    {
        hr =E_INVALIDARG;
        goto Cleanup;
    }

    BuildOptionsCache();

    lLengthOld = GetLength();
    Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == _aryOptions.Size());

    if (lLengthNew == lLengthOld)
        goto Cleanup;

    if (lLengthNew < lLengthOld)
    {
        // truncate the array
        for (l = lLengthOld-1; l >= lLengthNew; l--)
        {
            hr = THR(RemoveOptionHelper(l));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // pad the array
        for (l = lLengthOld; l < lLengthNew; l++)
        {
            hr = THR(Doc()->CreateElement(ETAG_OPTION, &pElement));
            if (hr)
                goto Cleanup;

            // insert the dummy element
            hr = THR(AddOptionHelper((COptionElement *)pElement, l, NULL, TRUE));
            if (hr)
                goto Cleanup;

            CElement::ClearPtr(&pElement);
        }
    }
Cleanup:
    CElement::ClearPtr(&pElement);
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     remove
//
//  Synopsis:   remove the item in the collection at the given index
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::remove(long lItemIndex)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    if (lItemIndex < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(RemoveOptionHelper(lItemIndex));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//-------------------------------------------------------------------------
//
//  member : RemoveFromColelction
//
//  synopsis : this helper function is the callback from the colelctions
//      called
//-------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::RemoveFromCollection(long lCollection, long lIndex)
{
    HRESULT hr;

    if (lCollection != SELECT_OPTION_COLLECTION)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(remove(lIndex));

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::get_type
//
//  Synopsis:   type property
//
//  Note:       NetScape compatibility, distinguishes between single and multiselect
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::get_type(BSTR * pbstreType)
{
    HRESULT hr;

    if ( ! pbstreType )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    htmlSelectType eType;

    if ( _fMultiple )
    {
        eType = htmlSelectTypeSelectMultiple;
    }
    else
    {
        eType = htmlSelectTypeSelectOne;
    }

    hr = THR(STRINGFROMENUM ( htmlSelectType, (long)eType, pbstreType ));

Cleanup:
    RRETURN ( SetErrorInfo(hr) );
}


MtDefine(BldOptCol, PerfPigs, "Build CSelectElement::OPTIONS_COLLECTION")

//+------------------------------------------------------------------------
//
//  Collection cache items implementation for options collection
//
//-------------------------------------------------------------------------

class COptionsCollectionCacheItem : public CElementAryCacheItem
{
    typedef CElementAryCacheItem super;

protected:
    LONG _lCurrentIndex;
    CPtrAry <COptionElement*>* _paryOptions;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldOptCol))
    COptionsCollectionCacheItem(CPtrAry <COptionElement*>* paryOptions)
    {
        _paryOptions = (CPtrAry <COptionElement*>*)paryOptions;
    }

    CElement *GetNext (void);
    CElement *GetAt ( long lIndex );
    CElement *MoveTo ( long lIndex );
    long Length ( void );
};

//+------------------------------------------------------------------------
//
//  Options collection
//
//-------------------------------------------------------------------------
CElement *
COptionsCollectionCacheItem::GetNext ( void )
{
    return GetAt ( _lCurrentIndex++ );
}

CElement *
COptionsCollectionCacheItem::MoveTo ( long lIndex )
{
    _lCurrentIndex = lIndex;
    return GetAt(lIndex);
}

CElement *
COptionsCollectionCacheItem::GetAt ( long lIndex )
{
    if (lIndex < Length() && lIndex >= 0)
    {
        CSelectElement * pSelect = (*_paryOptions)[0]->GetParentSelect();
        Assert(pSelect->AbsIdxFromRel(lIndex) != -1);
        Assert(pSelect->AbsIdxFromRel(lIndex) < _paryOptions->Size());
        return (*_paryOptions)[pSelect->AbsIdxFromRel( lIndex )];
    }
    return NULL;
}

long 
COptionsCollectionCacheItem::Length ( void )
{
    if ( _paryOptions->Size() > 0 )
    {
        CSelectElement * pSelect = (*_paryOptions)[0]->GetParentSelect();
        return pSelect->GetLength();
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::get_options
//
//  Synopsis:   Returns the IDispatch of the Options collection
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::get_options(IDispatch ** ppElemCol)
{
    HRESULT hr;

    if (!ppElemCol)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElemCol = NULL;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(QueryInterface(IID_IDispatch, (void**)
                ppElemCol));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::EensureOptionCollection
//
//  Synopsis:   makes sure that _pCollectionCache has a cache
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    if (!_pCollectionCache)
    {
        _pCollectionCache =
            new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CSelectElement, EnsureOptionCollection, ensureoptioncollection),
                NULL,
                REMOVEOBJECT_METHOD(CSelectElement, RemoveFromCollection, removefromcollection),
                ADDNEWOBJECT_METHOD(CSelectElement, AddNewOption, addnewoption) );

        if (!_pCollectionCache)
            goto MemoryError;

        hr = THR(_pCollectionCache->InitReservedCacheItems(NUMBER_OF_SELECT_COLLECTIONS,
                                                           NUMBER_OF_SELECT_COLLECTIONS));
        if (hr)
        {
            delete _pCollectionCache;
            _pCollectionCache = NULL;
            goto Cleanup;
        }

        COptionsCollectionCacheItem *pOptionsCollection = new COptionsCollectionCacheItem(&_aryOptions);
        if ( !pOptionsCollection )
            goto MemoryError;

        hr = THR(_pCollectionCache->InitCacheItem ( 0, pOptionsCollection ));
        if (hr)
            goto Cleanup;

        // Turn off default name promotion on the SELECT -> Options collection
        // Nav doesn't support this.
        _pCollectionCache->DontPromoteNames(SELECT_OPTION_COLLECTION);

        // and turn on: options[n]=NULL
        _pCollectionCache->SetCollectionSetableNULL(SELECT_OPTION_COLLECTION,
                                                    TRUE);
    }
    hr = THR(_pCollectionCache->EnsureAry(SELECT_OPTION_COLLECTION));

Cleanup:
    RRETURN(SetErrorInfo(hr));

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::EnsureOptionCollection
//
//  Synopsis:   populates the Options collection with Option elements
//              when it is invoked for the first time.
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::EnsureOptionCollection(long lIndex, long * plCookie)
{
    HRESULT hr = S_OK;

    BuildOptionsCache();

    Assert(plCookie);

    if (*plCookie != _lCollectionLastValid)
    {
        long    cOptions;
        long    lIndex;

        MtAdd(Mt(BldOptionsCol), +1, 0);

        cOptions = _aryOptions.Size();

        _pCollectionCache->ResetAry(SELECT_OPTION_COLLECTION);

        for ( lIndex = 0; lIndex < cOptions; lIndex++ )
        {
            if ( ! _aryOptions[lIndex]->_fIsOptGroup )
            {
                hr = _pCollectionCache->SetIntoAry(SELECT_OPTION_COLLECTION, _aryOptions[lIndex] );
                if ( hr )
                    goto Cleanup;
            }
        }

        *plCookie = _lCollectionLastValid;
    }

Cleanup:
    RRETURN(hr);
}

#ifdef WIN16
#pragma code_seg( "ESELECT_2_TEXT" )
#endif // WIN16

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::RemoveOptionHelper
//
//  Synopsis:   Helper to remove <OPTION> element
//
//  Arguments:  lIndex:         the index of the element
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::RemoveOptionHelper(long lRelIndex)
{
    HRESULT             hr = S_OK;
    long                cOptions;
    long                lIndex;
    COptionElement *    pOption;
    BOOL                fOldLayoutRequestsEnabled = _fEnableLayoutRequests;
    BOOL                fFirePropertyChangeSelIndex = FALSE;
    BOOL                fFirePropertyChangeValue = FALSE;
    LPCTSTR             pstrOldOptionValue;
    BOOL                fDeferUpdateCurSel = FALSE;

    BuildOptionsCache();

    lIndex = AbsIdxFromRel( lRelIndex );
    
    if ( lIndex < 0 )
        goto Cleanup;
    
    cOptions = _aryOptions.Size();
    Assert( !_hwnd || (SendSelectMessage(Select_GetCount, 0, 0) == cOptions) );

    _fEnableLayoutRequests = FALSE;

    if ( lIndex >= cOptions )
        goto Cleanup;

    pOption = _aryOptions[lIndex];
    // We don't care what the value is, only if it exists.
    pstrOldOptionValue = pOption->GetAAvalue();

#if DBG == 1
    CElement *          pOptionCached;

    hr = THR(_pCollectionCache->GetIntoAry(0, lRelIndex, &pOptionCached));
    if (!hr)
    {
        Assert(pOption == pOptionCached);
    }
#endif

    if (GetCurSel() >= lIndex && !_fMultiple)
    {
        fFirePropertyChangeSelIndex = TRUE;

        if ( _iCurSel == lIndex )
        {
            // Here's where we see if the option had a value.
            fFirePropertyChangeValue = !(NULL == pstrOldOptionValue);
            fDeferUpdateCurSel = TRUE;
        }
        else
        {
            --_iCurSel;
            // We do not have to update any _fSELCTEDs here. The 
            // bit on the options does not change, just the options
            // index in the collection
        }
    }

    {
        CMarkupPointer p1( Doc() ), p2( Doc() );

        hr = THR( p1.MoveAdjacentToElement( pOption, ELEM_ADJ_BeforeBegin ) );

        if (hr)
            goto Cleanup;

        hr = THR( p2.MoveAdjacentToElement( pOption, ELEM_ADJ_AfterEnd ) );

        if (hr)
            goto Cleanup;

        hr = THR( pOption->Doc()->Remove( & p1, & p2 ) );

        if (hr)
            goto Cleanup;
    }

    InvalidateCollection();

    if ( _hwnd )
    {
        if (LB_ERR == SendSelectMessage(Select_DeleteString, lIndex, 0))
            goto Win32Error;
    }

    _aryOptions.Delete(lIndex);

    if ( pOption == _poptLongestText )
    {
        _poptLongestText = NULL;
        ResizeElement();
    }

    Assert(cOptions == _aryOptions.Size() + 1);

    if (fDeferUpdateCurSel)
    {
        SetCurSel(-1);
    }

    if (fFirePropertyChangeSelIndex)
    {
        hr = THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
        if (hr)
            goto Cleanup;
        
        if (fFirePropertyChangeValue)
        {
            hr = THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                      0,
                                      (PROPERTYDESC *)&s_propdescCSelectElementvalue));
            if (hr)
                goto Cleanup;
        }
   }

    Assert(_fMultiple || GetCurSel() == _iCurSel);

Cleanup:
    _fEnableLayoutRequests = fOldLayoutRequestsEnabled;
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AddOptionHelper
//
//  Synopsis:   Adds an <OPTION> element
//
//  Arguments:  pOption:        the element to add
//              lIndex:         the index where the element should be added
//              pchText:        the text of the element
//              fDummy:         is this a dummy option use to pad out the list?
//
//  Note:       pchText is really redundant, since it can be obtained from
//              pOption. However, it lets us avoid the call to get_text()
//              if we alreday know the result as in the case of dummy
//              elements.
//-------------------------------------------------------------------------

HRESULT
CSelectElement::AddOptionHelper(COptionElement *    pOption,
                                long                lRelIndex,
                                const TCHAR *       pchText,
                                BOOL                fDummy)
{
    HRESULT         hr = S_OK;
    long            cOptions;
    long            lIndex;
    long            lControlIndex;
    CElement *      pPrevOption;
    CMarkupPointer  pointerInsert( Doc() );
    BOOL            fOldLayoutRequestsEnabled = _fEnableLayoutRequests;

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    // Make sure the OPTION being inserted is not already present in some tree (#41607)
    if (!pOption || pOption->IsInMarkup() || pOption->Doc() != Doc())
        return E_INVALIDARG;

    BuildOptionsCache();

    lIndex = AbsIdxFromRel( lRelIndex );

    cOptions = _aryOptions.Size();
    Assert( !_hwnd || (SendSelectMessage(Select_GetCount, 0, 0) == cOptions));

    if (!pchText)
        pchText = g_Zero.ach;

    _fEnableLayoutRequests = FALSE;

    if ( lIndex == -1 || lIndex >= cOptions) // append
    {
        lControlIndex = cOptions - 1;
    }
    else
    {
        lControlIndex = lIndex - 1;
    }

    if ( lControlIndex >= 0 )
    {
        Assert(lControlIndex < cOptions);
        Assert(cOptions > 0);

        pPrevOption = _aryOptions[lControlIndex];

        hr = THR( pointerInsert.MoveAdjacentToElement(pPrevOption, (ETAG_OPTGROUP == pPrevOption->Tag()) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_AfterEnd));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( pointerInsert.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
        if (hr)
            goto Cleanup;
    }

    //  Do the actual insertion here

        //  This will hopefully kick off the tree notification, which in turn
        //  will trigger the SELECT's new walking code to update the UI
        //  and the object model.

    hr = THR( Doc()->InsertElement( pOption, & pointerInsert, NULL ) );

    if (hr)
        goto Cleanup;

    hr = THR( pointerInsert.MoveAdjacentToElement( pOption, ELEM_ADJ_AfterBegin ) );

    if (hr)
        goto Cleanup;

    hr = THR( Doc()->InsertText( & pointerInsert, pchText, -1 ) );

    if (hr)
        goto Cleanup;
    
#ifndef NO_DATABINDING
    if (!fDummy && !_fMultiple && _iCurSel < 0)
    {
        DBMEMBERS *pdbm = GetDBMembers();

        // if we are bound and no option is currently selected, we check if
        //  the new option matches the bound value.
        if (pdbm && pdbm->FBoundID(this, ID_DBIND_DEFAULT))
        {
            BSTR bstrBound = NULL;

            if (!pdbm->ValueFromSrc(this, ID_DBIND_DEFAULT, &bstrBound))
            {
                BOOL fMatch = !FormsStringCmp(bstrBound, pOption->GetAAvalue());

                // instead of ourselves stuffing the value we just
                //  fetched, we call TransferFromSrc; this takes care
                //  of all the re-entrancy issues for us.
                SysFreeString(bstrBound);
                if (fMatch)
                {
                    IGNORE_HR(pdbm->TransferFromSrc(this, ID_DBIND_DEFAULT));
                }
            }
        }
    }
#endif // ndef NO_DATABINDING

///// Some of the old code revived to handle the insertion synchronously

    if ( lIndex == -1 || lIndex >= cOptions) // append
    {
        hr = THR(_aryOptions.Append(pOption));
        if ( hr )
            goto Cleanup;

        if ( _hwnd )
        {
            lControlIndex = SendSelectMessage(Select_AddString, 0, (LPARAM)pchText);
            if ( lControlIndex == LB_ERR )
                goto Win32Error;

            Assert(lControlIndex == _aryOptions.Size() - 1);
        }
    }
    else // insert
    {
        hr = THR(_aryOptions.Insert(lIndex, pOption));
        if ( hr )
            goto Cleanup;

        if ( _hwnd )
        {
            lControlIndex = SendSelectMessage(Select_InsertString, lIndex, (LPARAM)pchText);
            if ( lControlIndex == LB_ERR )
                goto Win32Error;

            Assert(lControlIndex == lIndex);
        }
    }

    InvalidateCollection();

    pOption->_fInCollection = TRUE;

    DeferUpdateWidth();

    if ( pOption->_fSELECTED )
    {
        if ( ! _fMultiple )
        {
            SetCurSel(lControlIndex, TRUE);
        }
        else
        {
            SetSel(lControlIndex, TRUE);
        }
    }

    Assert(cOptions == _aryOptions.Size() - 1);

Cleanup:
    _fEnableLayoutRequests = fOldLayoutRequestsEnabled;
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSelectElement::SendSelectMessage
//
//  Synopsis:   Sends messages to the hwnd of the select control
//              mapping the abstract messages to the correct LB_*
//              or CB_* Windows messages
//
//  Arguments:  msg:    the abstract message (enumerated type)
//              wParam  pretty obvious I think
//              lParam
//
//----------------------------------------------------------------------------

LRESULT
CSelectElement::SendSelectMessage(WindowMessages msg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    Assert(_hwnd);

#ifndef WIN16
    // subclassed from the unicode enabled control on win95, so we don't want the unicode wrapper
    // to convert any unicode to mbcs!
    return ::SendMessageA(_hwnd, SelectMessage(msg), wParam, lParam);
#else

    return ::SendMessage(_hwnd, SelectMessage(msg), wParam, lParam);
#endif
}


//+---------------------------------------------------------------------------
//
//  Method:     CSelectElement::HandleMessage
//
//  Synopsis:   Window message handler. This same method handles
//              WM_xxx messages and TranslateAccelerator calls,
//              distinction is made based on the CMessage::fPreDispatch bit.
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::HandleMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;

    if (!CanHandleMessage())
        goto Cleanup;


    if ( pMessage->message >= WM_KEYFIRST &&
         pMessage->message <= WM_KEYLAST )
    {
        hr = THR(FireStdEventOnMessage(GetFirstBranch(), pMessage));
        if (S_FALSE != hr)
            goto Cleanup;

        if ( pMessage->message == WM_KEYDOWN  )
        {
            if ( _hwndDropList &&
                 pMessage->wParam == VK_LEFT ||
                 pMessage->wParam == VK_RIGHT )
            {
                hr = S_OK;
                goto Cleanup;
            }

            if (    (pMessage->wParam == VK_F4 || (_hwndDropList && pMessage->wParam == VK_RETURN))
                &&  !(pMessage->dwKeyState & (FSHIFT | FCONTROL | FALT)))
            {
                ::SendMessage(_hwnd, pMessage->message, pMessage->wParam, pMessage->lParam);

                hr = S_OK;
                goto Cleanup;
            }
        }

        if ( _fFocus && 
                        (pMessage->message == WM_KEYDOWN ||
                         pMessage->message == WM_KEYUP ) &&
                         (pMessage->wParam == VK_UP    ||
                          pMessage->wParam == VK_DOWN  ||
                          pMessage->wParam == VK_PRIOR ||
                          pMessage->wParam == VK_NEXT  ||
                          pMessage->wParam == VK_HOME  ||
                          pMessage->wParam == VK_F4    ||
                          pMessage->wParam == VK_END   ||
                          pMessage->wParam == VK_SPACE  ) )
        {
            long lDelta = 0;
            if ( !_fHasOptGroup || !HandleKeyForOptGroup(pMessage->wParam, &lDelta))
            {
                ::SendMessage(_hwnd, pMessage->message, pMessage->wParam, pMessage->lParam);

                if ( _fMultiple && lDelta )
                {
                    for (int i = 0; i < abs(lDelta); i++)
                    {
                        ::SendMessage(_hwnd, pMessage->message, 
                                      (WPARAM)(lDelta < 0 ? VK_UP : VK_DOWN), pMessage->lParam);
                    }
                }
            }

            hr = S_OK;
            goto Cleanup;
        }
    }

    switch (pMessage->message)
    {
    case WM_CONTEXTMENU:
        // no context menu popup for listbox/dropdown when in browse mode,
        // popup control context menu when in author mode.
        //
        if (IsEditable(TRUE))
        {
            hr = THR(OnContextMenu(
                    (short)LOWORD(pMessage->lParam),
                    (short)HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
        }
        else
        {
            hr = S_OK;
        }
        break;

    case WM_SETFOCUS:
        // The document received a WM_SETFOCUS message and is forwarding it to us.
        // The select should be the current site.  Set focus to the select's window.

        Assert(this == Doc()->_pElemCurrent);
        if (_hwnd && _hwnd != ::GetFocus())
        {
            //  Lock any focus firing. BecomeCurrent has already done all that.

            CLock Lock(this, ELEMENTLOCK_FOCUS);
            ::SetFocus(_hwnd);
        }
        break;
    }

    if (hr == S_FALSE)
        hr = THR(super::HandleMessage(pMessage));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT
CSelectElement::ClickAction(CMessage * pMessage)
{
    if ( pMessage )
        goto Cleanup;

    if ( _aryOptions.Size() > 0 )
    {
        if ( _fMultiple )
        {
            int i;

            for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
            {
                _aryOptions[i]->_fSELECTED = FALSE;
            }
            SetSel(-1, FALSE);

            _aryOptions[0]->_fSELECTED = TRUE;
            SetSel(0, TRUE);
        }
        else
        {
            SetCurSel(0, SETCURSEL_UPDATECOLL);
        }
    }

Cleanup:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSelectElement::HandleMouseEvents
//
//  Synopsis:   Window message handler for mouse messages.
//
//  Note:       This handler is shared by the normal WndProc of
//              the SELECT (be it listbox or combobox) and
//              the dynamic subclassing WndProc of the
//              dropdown window of the combobox.
//              This ensures correct event firing for mouse events
//              happening in the dropdown window of the combobox.
//
//----------------------------------------------------------------------------

BOOL
CSelectElement::HandleMouseEvents(HWND hWnd,
                                  UINT msg,
                                  WPARAM wParam,
                                  LPARAM lParam,
                                  BOOL fFromDropDown /*=FALSE*/)
{
    POINT   pt;
    POINT   ptDoc;
    BOOL    fRet = FALSE;
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    BOOL    fFirePropertyChange = FALSE;
    BOOL    fValueChanged = FALSE;

    Assert(pDoc);

    pt.x = (short)LOWORD(lParam);
    pt.y = (short)HIWORD(lParam);

    ptDoc = pt;

    if (pDoc->State() >= OS_INPLACE)
    {
        MapWindowPoints(hWnd, pDoc->_pInPlace->_hwnd, &ptDoc, 1);

        CMessage Message(hWnd, msg, wParam, MAKELPARAM(ptDoc.x, ptDoc.y));    //  Create the Message
        Message.pt = ptDoc;
        hr = THR( Message.SetNodeHit( GetFirstBranch() ) );
        if( hr )
            goto Cleanup;

        LRESULT lResult = NULL; // for calls to CDoc::OnWindowMessage, we don't use it for anything
        BOOL fMouseOverOptGroup = FALSE;

        if ( _fHasOptGroup && !_fMultiple && ( _fListbox || (hWnd == _hwndDropList) ))
        {        
            long lMouseIndex = ::SendMessageA(hWnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));

            if ( (HIWORD(lMouseIndex) == 0) || _fLButtonHold )
            {
                COptionElement * pOption = _aryOptions[LOWORD(lMouseIndex)]; Assert(pOption);

                if ( pOption->_fIsOptGroup )
                {
                    fMouseOverOptGroup = TRUE;
                }
                
                if (msg == WM_LBUTTONDOWN)
                {
                    _fLButtonHold = TRUE;
                }

                /*
                if ( _fLButtonHold && (msg != WM_LBUTTONUP) )
                {
                    RECT comboRect;
                    GetClientRect( hWnd , &comboRect );

                    if ( (pt.y <= comboRect.top + 1) || (pt.y >= comboRect.bottom - 2) )
                    {
                        // Scroll

                        long lCurIndex = LOWORD(lMouseIndex);
                        long iNewSel   = - 1;

                        if ( (pt.y <= comboRect.top + 1) && (lCurIndex > 0) )
                        {                            
                            //Scroll up
                         
                            iNewSel = lCurIndex - 1;

                            if ( _aryOptions[iNewSel]->_fIsOptGroup )
                            {
                                iNewSel = GetNearestOption(iNewSel, TRUE);
                            }                            
                        }
                        else if ( (pt.y >= comboRect.bottom - 2) && (lCurIndex < _aryOptions.Size() - 1))
                        {
                            //Scroll down
                         
                            iNewSel = lCurIndex + 1;

                            if ( _aryOptions[iNewSel]->_fIsOptGroup )
                            {
                                iNewSel = GetNearestOption(iNewSel, FALSE);
                            }                            
                        }

                        if ( iNewSel != -1 )                                
                        {
                            SetCurSel(iNewSel, SETCURSEL_UPDATECOLL);
                        }

                        // Don't let the control process scrolling
                        return TRUE;
                    }
                }
*/
            }
        }

        switch ( msg )
        {
        case WM_LBUTTONDOWN:
            _fLButtonDown = TRUE;
            pDoc->_fCanFireDblClick = TRUE;
            //  falls through
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:

            if (_fSendMouseMessagesToDocument)
                _fSendMouseMessagesToDocument = FALSE;

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr || fMouseOverOptGroup)
                return TRUE;

        // NOTE - Should the select become current on all buttons
        // or just lbuttondown? right now, right now we do it with all

        // if the message came from the doc's hwnd the set currentcy
        // if it came from ours, then by defn, we are already current on the doc
        if (_hwndDropList != hWnd)
        {
            WHEN_DBG(CLayout *pLayout =)
                              GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
            Assert(pLayout);
            
            if (!IsEditable(TRUE) && !IsMasterParentEditable() )
            {
                hr = THR_NOTRACE(BecomeCurrent(0));
                if (S_OK != hr)
                    return TRUE;
            }
            else if (pDoc->_pElemCurrent != this)
            {
                LONG lButton = 0;

                switch( msg )
                {
                    case WM_LBUTTONDOWN:
                    lButton = 1;
                    break;

                    case WM_RBUTTONDOWN:
                    lButton = 2;
                    break;

                    case WM_MBUTTONDOWN:
                    lButton = 4;
                    break;
                }

                _fSendMouseMessagesToDocument = TRUE;

                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                return TRUE;
            }
        }
        break;

        //  Don't bail out from here even if user code cancels the event.
        //  That would prevent the listbox control from seeing the mouseUp
        //  and releasing mouse capture. That would be BAD.
        case WM_LBUTTONUP:

            _fLButtonHold  = FALSE;

            //  The combo seems to get an implicit WM_LBUTTONUP
            //  when the doprdown box is destroyed by an action in
            //  a different window.

            if (_fSendMouseMessagesToDocument)
            {
                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                _fSendMouseMessagesToDocument = FALSE;
                
                return TRUE;
            }

            if ( lParam == 0xFFFFFFFF )
                break;

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if ( S_FALSE != hr || fMouseOverOptGroup )
            {
                _fLButtonDown = FALSE;

                if ( fMouseOverOptGroup )
                {
                    int iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);

                    Assert( !_fMultiple );
                    // If we ended up on an OptGroup because of scrolling
                    // set the old selection back
                    if ( (iCurSel == -1) ||
                        ((iCurSel != -1) && _aryOptions[iCurSel]->_fIsOptGroup ) )
                    {
                        SetCurSel(_iCurSel, SETCURSEL_UPDATECOLL);
                    }
                }
                break;
            }

            if ( _fLButtonDown  )
            {
                int     iCurSel;
                int     iOldSel = _iCurSel;
                BOOL    fSelectionChanged = FALSE;

                _fLButtonDown = FALSE;
                hr = THR(BecomeUIActive());
                if ( hr )
                    break;

                Message.fEventsFired = FALSE;

                iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);

                if (iCurSel != _iCurSel)
                    fSelectionChanged = TRUE;

                if (_fListbox && !_fMultiple && fSelectionChanged)
                {
                    SetCurSel(iCurSel, SETCURSEL_UPDATECOLL);
                    fFirePropertyChange = TRUE;
                    fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                    Fire_onchange_guarded();
#ifndef NO_DATABINDING
                    IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                }

                if (_fListbox || !fSelectionChanged)
                {
                    hr = Fire_onclick() ? S_FALSE : S_OK;

                    if (S_FALSE != hr)
                        break;
                }
                else
                {
                    _fDeferFiringOnClick = TRUE;
                }
            }

            if ( pDoc->_fGotDblClk )
            {
                EVENTINFO clkEvtInfo;

                Message.fEventsFired = FALSE;

                hr = Fire_ondblclick(NULL, -1, &clkEvtInfo ) ? S_FALSE : S_OK;
                pDoc->_fGotDblClk = FALSE;

                Message.fSelectionHMCalled = FALSE;
                if ( clkEvtInfo._pParam )
                {
                    IGNORE_HR( pDoc->HandleSelectionMessage(&Message, FALSE, &clkEvtInfo, HM_Post ));
                }

                if (S_FALSE != hr)
                    break;
            }
            break;

        case WM_MBUTTONUP:
        case WM_RBUTTONUP:

            if (_fSendMouseMessagesToDocument)
            {
                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                _fSendMouseMessagesToDocument = FALSE;

                return TRUE;
            }
            // Follow through with event firing

        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr || fMouseOverOptGroup)
                return TRUE;

            break;

        case WM_MOUSEWHEEL:
            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr)
                return TRUE;

            if ( _fHasOptGroup && !_fListbox && (hWnd != _hwndDropList) )
            {
                BOOL keyHandled = FALSE;
                long iNewSel = -1;

                if (GET_WHEEL_DELTA_WPARAM(wParam) > 0)
                {
                    // equivalent with key-up
                    if (_iCurSel > 0 && _aryOptions[_iCurSel - 1]->_fIsOptGroup)
                    {
                        keyHandled = TRUE;
                        iNewSel = GetNearestOption(_iCurSel - 1, TRUE);
                    }
                }
                else
                {
                    // equivalent with key-down
                    if (_iCurSel < _aryOptions.Size() - 1 && _aryOptions[_iCurSel + 1]->_fIsOptGroup)
                    {
                        keyHandled = TRUE;
                        iNewSel = GetNearestOption(_iCurSel + 1, FALSE);
                    }
                }

                if ( keyHandled )
                {
                    if ( iNewSel != -1 )
                    {
                        SetCurSel(iNewSel, SETCURSEL_UPDATECOLL);
                    }
                    return TRUE;
                }
            }
            break;

        case WM_MOUSEMOVE:
            // We always send mousemove messages to the document so 
            // the onmouseover event will get fired for the element. 
            // EXCEPT when this message is coming from the dropdown 
            // message proc, then we let windows do its thing.
            if (!fFromDropDown)
            {
                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                if (hr)
                    return TRUE;
            }

            // Fall through

        default:
            if (fMouseOverOptGroup)
                return TRUE;
        }
        //  Fire events
    }

    if (fFirePropertyChange)
    {
        THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                             0,
                             (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));

        // If selectedIndex changed, then maybe the value changed too
        if (fValueChanged)
        {
            THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                 0,
                                 (PROPERTYDESC *)&s_propdescCSelectElementvalue));
        }
    }

Cleanup:
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   DropListWndProc
//
//  Synopsis:   Dynamically installed subclassed wndproc for the
//              dropdown window of the combobox
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
DropListWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CSelectElement * pSelect = (CSelectElement *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    return pSelect->DropWndProc(hWnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::DropWndProc
//
//  Synopsis:   Handler for the dropdown window's subclassing WndProc
//              (see above).
//
//  Arguments:  [hWnd]   -- HWND of calling window
//              [msg]    -- msg parameter from calling WNDPROC
//              [wParam] -- wParam parameter from calling WNDPROC
//              [lParam] -- lParam parameter from calling WNDPROC
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
CSelectElement::DropWndProc(
        HWND hWnd,
        UINT msg,
        WPARAM wParam,
        LPARAM lParam)
{
    BOOL fProcessed = FALSE;

    //  User event code may pop up the dropdown list, thereby
    //  NULL-ing the stored original WndProc.
    WNDPROC wndProcTmp = s_pfnDropListWndProc;

    if ( msg >= WM_MOUSEFIRST &&
         msg <= WM_MOUSELAST )
    {
        fProcessed = HandleMouseEvents(hWnd, msg, wParam, lParam, TRUE);
    }

    if ( fProcessed )
    {
        return TRUE;
    }

    if ( WM_NCDESTROY == msg && s_pfnDropListWndProc && _hwndDropList )
    {
        //  Unhook subclassing
        SetWindowLongPtr(_hwndDropList, GWLP_WNDPROC, (LONG_PTR)s_pfnDropListWndProc);
        s_pfnDropListWndProc = NULL;
        SetWindowLongPtr(_hwndDropList, GWLP_USERDATA, 0);
        _hwndDropList = NULL;
    }

    return CallWindowProc(wndProcTmp, hWnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Function:   SelectElementWndProc
//
//  Synopsis:   subclassed wndproc for the HTML SELECT control
//
//              Stolen from the '95 wrapped controls
//
//  Arguments:  [hWnd]   -- hWnd of List Box
//              [msg]    -- message to process
//              [wParam] -- Message's wParam
//              [lParam] -- Message's lParam
//
//  Returns:    Appropriate data depending on message
//
//  Notes:      CONSIDER - this func currently fires events BEFORE calling
//              the button wnd proc.  Should it call first, then
//              fire the event?
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
SelectElementWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CSelectElement * pSelect = (CSelectElement *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceTag((tagSelectWndProc, "msg %d for SEL %d  hwnd %x",
                    msg, (pSelect? pSelect->SN(): 0), hWnd));

    if (!pSelect)
    {
        Assert( msg == WM_NCCREATE );

        CREATESTRUCT *ps = (CREATESTRUCT*) lParam;
        pSelect = (CSelectElement *) ps->lpCreateParams;

        Assert( pSelect );

        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)pSelect );
        SetWindowLong( hWnd, GWL_ID, s_lIDSelect );

        InterlockedIncrement( & s_lIDSelect );

        pSelect->_rgnVisible.SetRectangle(0,0,ps->cx, ps->cy);

    }
    else if (msg == WM_WINDOWPOSCHANGING && pSelect->_fVisibleChanged)
    {
        pSelect->_fVisibleChanged = false;

        WINDOWPOS *pPos = (WINDOWPOS*)lParam;
        HRGN hrgn = pSelect->_rgnVisible.IsRectangle(0,0,pPos->cx, pPos->cy) ? 0
                  : pSelect->_rgnVisible.ConvertToWindows();

        pSelect->Doc()->GetView()->SetWindowRgn(hWnd, hrgn, !(pPos->flags & SWP_NOREDRAW));

        if (!pSelect->_rgnInvalidate.IsEmpty())
        {
#if DBG == 1
            if (IsTagEnabled(tagSelectInval))
            {
                TraceTag((tagSelectInval, "Inval SEL %d  hwnd %x (Pos/VisChange)",
                                            pSelect->SN(),  hWnd));
                DumpRegion(pSelect->_rgnInvalidate);
            }
#endif
            hrgn = pSelect->_rgnInvalidate.ConvertToWindows();
                   pSelect->_rgnInvalidate.SetEmpty();

            ::InvalidateRgn(hWnd, hrgn, 0);
            ::DeleteObject(hrgn);
        }
    }

#if DBG==1
    if (msg == WM_ERASEBKGND)
    {
        TraceTag((tagEraseBkgndStack, "SelectElementWndProc"));
        TraceCallers(tagEraseBkgndStack, 1, 16);
    }
#endif

    // if we get WM_PAINT while we've turned off repainting, remind
    // ourselves to force a paint when we've turned it back on
    if (msg == WM_PAINT && pSelect->_fNoRedraw)
    {
        pSelect->_fMissedPaint = TRUE;
    }

    return pSelect->WndProc( hWnd, msg, wParam, lParam );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::WndProc
//              stolen from CWrappedControl::WrappedCtrlWinProc
//
//  Synopsis:   Handler for messages sent to the sub-classed controls.
//
//  Arguments:  [hWnd]   -- HWND of calling window
//              [msg]    -- msg parameter from calling WNDPROC
//              [wParam] -- wParam parameter from calling WNDPROC
//              [lParam] -- lParam parameter from calling WNDPROC
//
//  History:    20-Apr-94   SumitC      Created
//              23-Apr-94   SumitC      Add MousePointer, WM_MOUSEACTIVATE
//              17-May-94   SumitC      Rbutton context menu
//              24-May-94   SumitC      common Key* and Mouse* events
//              23-Jul-96   LaszloG     revived and applied to the SELECT element
//
//  Notes:      This is used for handling common control functionality, such
//              as firing standard events, and handling standard properties.
//
//              LaszloG:    There's a slight weirdness as this windproc needs
//                          subclass two different Windows WndProcs:
//                          the listbox and the combo
//
//              Important:  This method should NOT be virtual or else it
//                          will blow up in WM_NCCREATE (this would be NULL then).
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
CSelectElement::WndProc(
        HWND hWnd,
        UINT msg,
        WPARAM wParam,
        LPARAM lParam)
{
    HRESULT hr;
    BOOL fProcessed;
    LRESULT lr;
    BOOL    fFirePropertyChange = FALSE;
    BOOL    fValueChanged = FALSE;
    int     iOldSel = -1;

    if ( ! IsConnectedToPrimaryMarkup() )
        goto DefWindowProc;

    if (IsParentFrozen())
    {                       
        if ((msg >= WM_MOUSEFIRST &&
            msg <= WM_MOUSELAST) ||
         // msg == WM_SETCURSOR  ||     // BUGFIX:18794 (chandras), we shouldn't be doing WM_SETCURSOR handling here, 
                                        // WM_SETCURSOR LPARAM is not a point, but id of message and hittest code
            msg == WM_CONTEXTMENU)
        {                                
            CDoc *      pDoc = Doc();
            POINT       pt;
            LRESULT     lresult;
            BOOL        fNeedConversion;

            pt.x = (short)LOWORD(lParam);
            pt.y = (short)HIWORD(lParam);

            if (WM_LBUTTONDOWN == msg)
            {
                pDoc->_fCanFireDblClick = TRUE;
            }

            // check for keyboard generated context menu generated           
            fNeedConversion = (msg != WM_CONTEXTMENU) || (pt.x != -1) || (pt.y != -1);                        

            if (pDoc->State() >= OS_INPLACE)
            {
                if (!fNeedConversion || MapWindowPoints(hWnd, pDoc->_pInPlace->_hwnd, &pt, 1))
                {
                    pDoc->OnMouseMessage (
                        msg,
                        wParam,
                        MAKELPARAM (pt.x, pt.y),
                        &lresult, 
                        pt.x, pt.y);
                }
            }        

            lr = TRUE;
            goto Return;
        }
    }            

    if ( msg >= WM_MOUSEFIRST &&
         msg <= WM_MOUSELAST )
    {     
        fProcessed = HandleMouseEvents(hWnd, msg, wParam, lParam);
        if ( fProcessed )
        {
            lr = TRUE;
            goto Return;
        }
    }

    switch (msg)
    {
    case WM_SETCURSOR:
        {
            CDoc * pDoc = Doc();
            if ( ( IsParentEditable() || IsMasterParentEditable() )
                 && (pDoc->_pElemCurrent != this) )
                {
                    CLayout *pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
                    Assert(pLayout);

                    if (!pLayout->IsAdorned())
                    {
                        SetCursorIDC(IDC_SIZEALL);
                    }
                    else 
                    {
                        SetCursorIDC(IDC_ARROW);
                    }
                    lr = TRUE;
                    goto Return;
                }
        }
        break;

    case WM_SYSCHAR:
    case WM_CHAR:
        if ( ! IsEditable(TRUE) )
        {
            CRect   rc;

            GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->GetRect(&rc, COORDSYS_GLOBAL);

            CMessage Message(hWnd, msg, wParam, MAKELPARAM(rc.left, rc.top));    //  Create the Message

            hr = THR( Message.SetNodeHit( GetFirstBranch() ) );
            if( hr )
            {
                lr = LRESULT(hr);
                goto Return;
            }

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr)
            {
                lr = TRUE;
                goto Return;
            }

        }

        break;

    case WM_SETFOCUS:
        if (this == Doc()->_pElemCurrent &&
            !TestLock(CElement::ELEMENTLOCK_FOCUS) &&
            !Doc()->_fInhibitFocusFiring)
        {
            GWPostMethodCall(this, ONCALL_METHOD(CElement, Fire_onfocus, fire_onfocus), 0, TRUE, "CElement::Fire_onfocus");
        }
        _fFocus = TRUE;
        break;

    case WM_KILLFOCUS:
        if (this == Doc()->_pElemCurrent &&
            !TestLock(CElement::ELEMENTLOCK_BLUR))
        {
            GWPostMethodCall(this, ONCALL_METHOD(CElement, Fire_onblur, fire_onblur), 0, TRUE, "CElement::Fire_onblur");
        }
        _fFocus = FALSE;
        break;

    case WM_SYSCOLORCHANGE:
        InvalidateBackgroundBrush();
        break;

#ifndef WIN16
    //  This is a tricky one. We don't paint here, instead we
    //  catch the dropdown window and subclass it.

    //  SPY revealed that a WM_CTLCOLORLISTBOX message is sent to the
    //  combo HWND when the dropped list wants to paint, so that
    //  its colors can be changed. We use this opportunity to
    //  do the dynamic subclassing, as this message comes early enough
    //  and it carries the HWND of the dropdown list as a bonus.

    //  The case handler falls through to the paint logic so that the
    //  droplist colors can be adjusted.

    case WM_CTLCOLORLISTBOX:
        if ( _fTriggerComboSubclassing && ! _fListbox )
        {
            HWND hwndDropList = (HWND)lParam;
            TCHAR achClassName[512];

            _fTriggerComboSubclassing = FALSE;

            Assert(hwndDropList);
            if ( GetClassName(hwndDropList, achClassName, ARRAY_SIZE(achClassName)) &&
                 0 == _tcscmp(achClassName, TEXT("ComboLBox")) &&
                 NULL == s_pfnDropListWndProc ) //  Guard against double subclassing,
                                                //  which loses the original WndProc
            {
                _hwndDropList = hwndDropList;
                s_pfnDropListWndProc = (WNDPROC)GetWindowLongPtr(hwndDropList, GWLP_WNDPROC);
                SetWindowLongPtr(hwndDropList, GWLP_WNDPROC, (LONG_PTR)DropListWndProc);
                SetWindowLongPtr(hwndDropList, GWLP_USERDATA, (LONG_PTR)this);
            }
        }

        //  !! Falls through !!
    case OCM__BASE + WM_CTLCOLORLISTBOX:
    case OCM__BASE + WM_CTLCOLOREDIT:
    case OCM__BASE + WM_CTLCOLORSTATIC:
        //  get the colors from the style sheet
        //  select appropriate pen and brush into the DC in wParam
        {
            CColorValue ccv;
            HDC hDC = (HDC) wParam;

            if ( GetAAdisabled() )
            {
                SetTextColor(hDC, GetSysColorQuick(COLOR_GRAYTEXT));
            }

            if( !_hBrush )
                UpdateBackgroundBrush();

            lr = (LRESULT)_hBrush;
            goto Return;
        }
#endif // !WIN16

    case OCM__BASE + WM_COMMAND:
        {
            int iCurSel;
            //  process the notifications here
            switch ( GET_WM_COMMAND_CMD(wParam, lParam) )
            {
                case CBN_KILLFOCUS:
                    if ( !_fListbox )
                    {
                        IGNORE_HR(Doc()->InvalidateDefaultSite());
                        break;
                    }

                case LBN_KILLFOCUS:
                    if ( _fListbox )
                    {
                        IGNORE_HR(Doc()->InvalidateDefaultSite());
                        break;
                    }

                case LBN_SELCHANGE:
                    iOldSel = _iCurSel;
                    if ( !_fMultiple )
                    {
                        iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);
                        if ( iCurSel != _iCurSel && _fListbox ) // comboboxes get this message if the list is dropped
                                                               // we don't want to fire anything in that case.
                        {
                            if ( iCurSel != -1 && _aryOptions[iCurSel]->_fIsOptGroup )
                                break;

                            SetCurSel(iCurSel, (SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND));
                            // We must check the value before we fire onchange
                            fFirePropertyChange = TRUE;
                            fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                            Fire_onchange_guarded();

#ifndef NO_DATABINDING
                            // TODO:: Revisit this IGNORE_HR once we have
                            // a more coherent error handlings strategy for
                            // data-binding.  -cfranks 16 Jan 97
                            IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                        }
                    }
                    else
                    {
                        //  Traverse the listbox entries and update the OPTION elements'
                        //  _fSELECTED flag accordingly. If anything changed, fire_onChange.
                        int i;
                        COptionElement * pOption;
                        LRESULT lr;
                        BOOL fFireOnchange = FALSE;

                        for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
                        {
                            pOption = _aryOptions[i];

                            if ( pOption->_fIsOptGroup )
                                continue;

                            lr = SendSelectMessage(Select_GetSel, i, 0);
                            if ( lr == LB_ERR )
                                break;

                            fFireOnchange = fFireOnchange || (!!lr != !!pOption->_fSELECTED);
                            pOption->_fSELECTED = lr;
                        }

                        if ( fFireOnchange )
                        {
                            // We must check the value before we fire onchange
                            fFirePropertyChange = TRUE;
                            fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                            Fire_onchange_guarded();
                        }

#ifndef NO_DATABINDING
                        // NOTE: This may be odd since we don't officially
                        // data bind to multiple slections.  However, I think
                        // the behavior is that the first one is saved, so we
                        // should be consistent and still fire it immediately.
                        IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                    }
                    break;

                case CBN_SELENDOK:
                    if ( ! _fListbox )  //  cannot be multiple
                    {
                        iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);
                        if ( iCurSel != _iCurSel )
                        {
                            if ( iCurSel != -1 && _aryOptions[iCurSel]->_fIsOptGroup )
                                break;

                            iOldSel = _iCurSel;
                            SetCurSel(iCurSel, (SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND));
                            // Sometimes SELENDOK gets called after the control is gone
                            // We don't want to fire onpropertychange is this case.
                            // TODO: (krisma) We may want events to fire if we're not
                            // in the tree. If that's the case, we'll need to take another 
                            // look at this. (This is here to fix 34064.)
                            if (!!(GetFirstBranch()))
                            {
                                fFirePropertyChange = TRUE;
                                fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                            }
                            Fire_onchange_guarded();
#ifndef NO_DATABINDING
                            // NOTE:: Revisit this IGNORE_HR once we have
                            // a more coherent error handlings strategy for
                            // data-binding.  -cfranks 16 Jan 97
                            IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                        }
                        if (_fDeferFiringOnClick)
                        {
                            _fDeferFiringOnClick = FALSE;

                            Fire_onclick();
                        }
                    }
                    break;

                case CBN_DROPDOWN:

                    Assert(!_fListbox);

                    _fTriggerComboSubclassing = TRUE;

                    break;

                case CBN_CLOSEUP:

                    //  Unhook subclassing
#if NEVER
                    if ( s_pfnDropListWndProc && _hwndDropList )
                    {
                        SetWindowLongPtr(_hwndDropList, GWLP_WNDPROC, (LONG_PTR)s_pfnDropListWndProc);
                        s_pfnDropListWndProc = NULL;
                        SetWindowLongPtr(_hwndDropList, GWLP_USERDATA, 0);
                        _hwndDropList = NULL;
                    }
#endif
                    if ( _fLButtonDown )
                    {
                        _fLButtonDown = FALSE;
                    }

                    //  check the selection. If the user tabs out, CBN_SELENDOK is NOT sent
                    //  so the new selection has to be checked here.

                    int iCurSel = GetCurSel();
                    if ( iCurSel != _iCurSel )
                    {
                        iOldSel = iCurSel;
                        SetCurSel(iCurSel, (SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND));
                        fFirePropertyChange = TRUE;
                        fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                        Fire_onchange_guarded();
#ifndef NO_DATABINDING
                        // TODO:: Revisit this IGNORE_HR once we have
                        // a more coherent error handlings strategy for
                        // data-binding.  -cfranks 16 Jan 97

                        // When the user tabs away from the popup list, Trident
                        // changes the current focus element before the SELECT
                        // gets here to change its value.  In this case, we
                        // tell SaveDataIfChanged to treat the SELECT as if it
                        // were still the current focus, so that onbeforeupdate
                        // will fire.  (IE5 bug 74016)
                        IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT,
                                    /* fLoud */ FALSE, /* fForceIsCurrent */ TRUE));
#endif
                    }

                    break;
            }
        }

        //  Don't let any OCM__BASE-offset reflected message enter the normal WndProc

        lr = TRUE;
        goto Return;


    // The select window is being asked for its accessible object. We create
    // and return the native accessible object to have the same accessible 
    // behavior for the select element(s) over the board.
#if !defined(_MAC) && !defined(WIN16)
    case WM_GETOBJECT:

        CAccBase * pAccSelect;
        
        pAccSelect = GetAccObjOfElement( this );
        if ( !pAccSelect )
        {
            lr = E_FAIL;
            goto Return;
        }
        
        static DYNPROC s_dynprocLresultFromObject =
                { NULL, &g_dynlibOLEACC, "LresultFromObject" };

        // Load up the LresultFromObject pointer.
        hr = THR(LoadProcedure(&s_dynprocLresultFromObject));
        if (hr)
        {
            lr = (LRESULT)hr;
            goto Return;
        }   
        
        lr = (*(LRESULT (APIENTRY *)(REFCLSID, WPARAM, IUnknown *))
                                        s_dynprocLresultFromObject.pfn)(IID_IAccessible, 
                                        wParam, 
                                        (IAccessible *)pAccSelect);
    break;
#endif
    }

// WINCE - cut some win95-only calls, so we can drop wselect.cxx from sources
#if (!defined(WINCE) && !defined(WIN16))
    lr = (CALL_METHOD( this, s_alpfnWideHookProc[ _fListbox ], (
         s_alpfnSelectWndProc[_fListbox], hWnd, msg, wParam, lParam )));

    goto Return;
#else

#ifdef WIN16
    if ( msg > LB_FINDSTRINGEXACT && msg <= WM_APP )
#else
    if ( msg >= WM_USER && msg <= WM_APP )
#endif
    {
#ifndef WIN16
        Assert(!(msg >= WM_USER && msg <= WM_APP));
#endif
        lr = TRUE;
        goto Return;
    }
#endif

DefWindowProc:
    lr = CallWindowProc(s_alpfnSelectWndProc[ _fListbox ], hWnd, msg, wParam, lParam);
    //  Falls through

Return:
    if (fFirePropertyChange)
    {
        THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                             0,
                             (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));

        // If selectedIndex changed, then maybe the value changed too
        if (fValueChanged)
        {
            THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                 0,
                                 (PROPERTYDESC *)&s_propdescCSelectElementvalue));
        }
    }
    return lr;
}

//+----------------------------------------------------------------------------
//
//  Memeber: CSelectElement::HasValueChanged
//
//  Has the value of the select element changed?
//
//-----------------------------------------------------------------------------

BOOL
CSelectElement::HasValueChanged(int iOldSel, int iNewSel)
{
    BOOL fReturn = FALSE;
    LPCTSTR pstrOldOptionValue;
    LPCTSTR pstrNewOptionValue;

    Assert (iOldSel < _aryOptions.Size());
    Assert (iNewSel < _aryOptions.Size());

    if (iOldSel == iNewSel)
        goto Return;

    pstrOldOptionValue = (iOldSel > -1) ? _aryOptions[iOldSel]->GetAAvalue()
        : NULL;
    pstrNewOptionValue = (iNewSel > -1) ? _aryOptions[iNewSel]->GetAAvalue()
        : NULL;

    if (!pstrOldOptionValue || !pstrNewOptionValue)
    {
        if (pstrOldOptionValue || pstrNewOptionValue)
        {
            fReturn = TRUE;
        }
        goto Return;
    }

    Assert(pstrOldOptionValue && pstrNewOptionValue);

    fReturn = !_tcsequal(pstrOldOptionValue, pstrNewOptionValue);

Return:
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//
//  Databinding support
//
//
//-----------------------------------------------------------------------------

#ifndef NO_DATABINDING
class CDBindMethodsSelect : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsSelect() : super(VT_BSTR) {}
    ~CDBindMethodsSelect()  {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                          BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsSelect DBindMethodsSelect;

const CDBindMethods *
CSelectElement::GetDBindMethods()
{
    return &DBindMethodsSelect;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound checkbox.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the select, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a bstr.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsSelect::BoundValueToElement(CElement *pElem,
                                         LONG,
                                         BOOL,
                                         LPVOID pvData) const
{
    HRESULT hr = S_OK;
    CSelectElement *pSelect = DYNCAST(CSelectElement, pElem);

    // databinding is shut down for multi-select
    if (!pSelect->_fMultiple)
    {
        hr = pSelect->put_value(*(BSTR *)pvData);
    }

    RRETURN(hr);
}

HRESULT
CDBindMethodsSelect::BoundValueFromElement(CElement *pElem,
                                           LONG,
                                           BOOL,
                                           LPVOID pvData) const
{
    // An S_FALSE return indicates indicates that values shouldn't be
    //  saved to the database.
    HRESULT hr = S_FALSE;
    CSelectElement *pSelect = DYNCAST(CSelectElement, pElem);

    if (pSelect->_fMultiple)
        goto Cleanup;

    // Check to see if there really was a current value.
    if (pSelect->_iCurSel < 0)
        goto Cleanup;

    // Get the current value of the list box, null str if no current value
    hr = pSelect->get_value((BSTR *)pvData);

Cleanup:
    RRETURN1(hr, S_FALSE);

}
#endif // ndef NO_DATABINDING

//+----------------------------------------------------------------------------
//
//  Method:     DoReset
//
//  Synopsis:   implements the HTML form RESET action for the SELECT
//
//  Returns:    S_OK if successful
//              S_FALSE if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CSelectElement::DoReset(void)
{
    HRESULT hr = S_OK;
    long cOptions;
    int i;

    if ( _fMultiple )
    {
        SetSel(-1, FALSE);
    }
    else
    {
        SetCurSel( _fListbox ? -1 : 0, SETCURSEL_UPDATECOLL);
    }

    if ( _fListbox )
    {
        SetTopIndex(0);
    }

    cOptions = _aryOptions.Size();
    Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

    for ( i = 0; i < cOptions; i++ )
    {
        COptionElement * pOptionElement = _aryOptions[i];

        if (pOptionElement)
        {
            pOptionElement->_fSELECTED = pOptionElement->_fDefaultSelected; //  restore objmodel state
            if (pOptionElement->_fDefaultSelected )
            {
                if ( _fMultiple )
                {
                    SetSel(i, TRUE);
                }
                else
                {
                    SetCurSel(i, SETCURSEL_UPDATECOLL);
                    break;
                }
            }
        }
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if there is a value
//              (name && value pair)  ... all data lives in the windows control
//
//  Returns:    S_OK if successful
//              S_FALSE if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CSelectElement::GetSubmitInfo(CPostData * pSubmitData)
{
    LPCTSTR     pstrName = GetAAsubmitname();

    //  no name --> no submit!
    if ( ! pstrName )
        return S_FALSE;

    BuildOptionsCache();

    LPCTSTR     pstrValue = NULL;
    HRESULT     hr = S_FALSE;       //  init hr for no action
    long        lSelectedItem;
    long        i;
    long        cOptions;
    COptionElement * pOptionElement = 0;
    BOOL        fFirstItem;

    // set up for the loop
    if ( _fMultiple )
    {
        // is this a multi select
       cOptions = _aryOptions.Size();
       Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

       lSelectedItem = 0;
    }
    else
    {
        cOptions = 1;
        lSelectedItem = _iCurSel;
        if ( lSelectedItem == -1 )
        {
            goto Cleanup;
        }
    }

    // is single, just go get it. if multiple go around the loop cOptions times, checking each.
    fFirstItem = TRUE;
    for ( i = 0; i < cOptions; i++ )
    {
        long fSelected;

        if ( _fMultiple )
        {
            fSelected = _aryOptions[i]->_fSELECTED;

            if ( !fSelected )
                continue;
        }
        else
        {
           i = _iCurSel;  // set up if not multiple...
        }

        // get the value or the text
        pOptionElement = _aryOptions[i];
        pstrValue = pOptionElement->GetAAvalue();

        if ( !pstrValue )    // if no value or null value, go for text
        {
            // if there is no value= then use the text
            pstrValue = pOptionElement->_cstrText;
        }

        //  NOTE(laszlog): Verify that the check for first item is still needed!
        if (!fFirstItem)
        {
            hr = THR(pSubmitData->AppendItemSeparator());
            if ( hr )
                goto Cleanup;
        }

        TraceTag((tagSelectState, "SELECT %lx Submit name=%ls value=%ls", this, pstrName, pstrValue));
        hr = THR(pSubmitData->AppendNameValuePair(pstrName, pstrValue, GetMarkup()));
        if (hr)
            goto Cleanup;

        fFirstItem = FALSE;

        pstrValue = NULL;
    } // end for loop

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::InvokeEx, IDispatch
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::InvokeEx(DISPID dispidMember,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         IServiceProvider *pSrvProvider)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchInvokeCollection(NULL,
                                  NULL,
                                  _pCollectionCache,
                                  SELECT_OPTION_COLLECTION,
                                  dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL,
                                  pSrvProvider);

    if (hr)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(     // need to go via CElement level
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            pSrvProvider,
            NULL));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetDispID, IDispatchEx
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetDispIDCollection(this,
                                     (GetDispIDPROC) super::GetDispID,
                                     _pCollectionCache,
                                     SELECT_OPTION_COLLECTION,
                                     bstrName,
                                     grfdex,
                                     pid);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetNextDispID, IDispatchEx
//
//----------------------------------------------------------------------------
HRESULT
CSelectElement::GetNextDispID(DWORD grfdex,
                              DISPID id,
                              DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetNextDispIDCollection(this,
#ifndef WIN16
                                         (GetNextDispIDPROC)&super::GetNextDispID,
#else
                                         CBase::GetNextDispID,
#endif
                                         _pCollectionCache,
                                         SELECT_OPTION_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CSelectElement::GetMemberName(
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
#ifndef WIN16
                                         (GetGetMemberNamePROC)super::GetMemberName,
#else
                                         CBase::GetMemberName,
#endif
                                         _pCollectionCache,
                                         SELECT_OPTION_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::AddNewOption
//
// Supports adding option element to the options collection via
// JScript array access e.g.
// options [ 7 ] = new Option();
//----------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::AddNewOption(long lIndex, IDispatch *pObject, long index)
{
    HRESULT             hr = S_OK;
    CElement *          pElement = NULL;
    IUnknown *          pUnk;
    long                lDummy;

    if (index < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure that pObject is an <OPTION> element
    hr = THR(pObject->QueryInterface(IID_IHTMLOptionElement, (void**)&pUnk));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    ReleaseInterface(pUnk);

    if (index == -1)
        index = _aryOptions.Size(); // append

    // index is the ordinal position to add/replace
    // If it exists, replace the existing element.
    // If not extend the options array with default elements
    // up to index-1, then add the new element
    // Verify that pObject is an IOptionElement

    if (index < _aryOptions.Size())
    {
        // remove the current element at 'index'
        hr = THR(RemoveOptionHelper(index));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // pad with dummy elements till index - 1

        for (lDummy = _aryOptions.Size(); lDummy < index; lDummy++)
        {
            hr = THR(Doc()->CreateElement(ETAG_OPTION, &pElement));
            if (hr)
                goto Cleanup;

            // insert the dummy element
            hr = THR(AddOptionHelper(DYNCAST(COptionElement, pElement), lDummy, NULL, TRUE));
            if (hr)
                goto Cleanup;

            CElement::ClearPtr(&pElement);
        }
    }

    // insert the new element at 'index'
    Verify(S_OK == THR(pObject->QueryInterface(CLSID_CElement, (void **)&pElement)));

    // Bail out if the element is already in the tree - #25130
    // Also bail out if the element wasn't created in this document
    if (pElement->IsInMarkup() || pElement->Doc() != Doc())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pElement->AddRef();

    // querying for a CLSID does not get us a ref!

    hr = THR(AddOptionHelper(DYNCAST(COptionElement, pElement), index, DYNCAST(COptionElement, pElement)->_cstrText, FALSE));
    if (hr)
        goto Cleanup;

    CElement::ClearPtr(&pElement);

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::BuildOptionsCache
//
//  Synopsis:   Walk the SELECT's subtree, cache the OPTIONs
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::BuildOptionsCache(void)
{
    HRESULT             hr           = S_OK;

    CTreeNode *         pNode;
    CTreeNode *         pNodeSelect;
    CTreePos *          ptp;

    int                 iSelected;
    int                 iOptionCount;

    if ( ! _fOptionsDirty )
        goto Cleanup;

    // Init current selection index and option counter

    iSelected    = -1;
    iOptionCount = -1;
    
    //  Zap the Options

    InvalidateCollection();

    _poptLongestText = NULL;
    _lMaxWidth = 0;
    _aryOptions.DeleteAll();
    _fHasOptGroup = FALSE;

    //  Walk the runs in the SELECT's scope
    //      Grab all the OPTIONs
    //          stuff them into the SELECT's aryOption
    //          stuff them into the listbox
    //          call the OPTION to cache its text
    //      Disregard all other tags
    //  Let the layout recalc itself

    for (pNodeSelect = GetFirstBranch() ;
         pNodeSelect ;
         pNodeSelect = pNodeSelect->NextBranch() )
    {
        for (ptp = pNodeSelect->GetBeginPos()->NextTreePos();
             ptp != pNodeSelect->GetEndPos();
             ptp = ptp->NextTreePos())
        {
            if (ptp->IsBeginNode())
            {
                pNode = ptp->Branch();
                if ( ptp->IsEdgeScope() && 
                     (pNode->Element()->Tag() == ETAG_OPTION || pNode->Element()->Tag() == ETAG_OPTGROUP))
                {
                    COptionElement * pOption = DYNCAST(COptionElement, pNode->Element());

                    pOption->_fIsGroupOption = FALSE;

                    hr = AppendOption(pOption);
                    if ( hr )
                        goto Cleanup;
                
                    iOptionCount++;
                    if (pOption->_fSELECTED )
                    {
                        Assert( pOption->_fIsOptGroup == FALSE );
                        iSelected = iOptionCount;
                    }

                    if (pNode->Element()->Tag() == ETAG_OPTGROUP)
                    {
                        CTreeNode *         pNodeOpt;
                        CTreePos *          ptpOptGrp;

                        _fHasOptGroup = TRUE;

                        for (ptpOptGrp = pNode->GetBeginPos()->NextTreePos();
                             ptpOptGrp != pNode->GetEndPos();
                             ptpOptGrp = ptpOptGrp->NextTreePos())
                        {
                            if (ptpOptGrp->IsBeginNode())
                            {
                                pNodeOpt = ptpOptGrp->Branch();

                                Assert(pNodeOpt->Element()->Tag() != ETAG_OPTGROUP);

                                if ( ptpOptGrp->IsEdgeScope() && pNodeOpt->Element()->Tag() == ETAG_OPTION)
                                {                                    
                                    COptionElement * pOption2 = DYNCAST(COptionElement, pNodeOpt->Element());
                                    pOption2->_fIsGroupOption = TRUE;
                                    
                                    hr = AppendOption(pOption2);
                                    if ( hr )
                                        goto Cleanup;
                    
                                    iOptionCount++;
                                    if (pOption2->_fSELECTED )
                                    {
                                        iSelected = iOptionCount;
                                    }
                                }
                                ptpOptGrp = pNodeOpt->GetEndPos();
                            }
                        }
                    }
                }
                ptp = pNode->GetEndPos();
            }
        }
    }

    //Set the current selection

    if (_fMultiple)
    {
        _iCurSel = -1;
    }
    else
    {
        // Special case - drop down with no selection defaults to first OPTION
        if ( !_fListbox && (iSelected == -1) && (GetLength() > 0) )
        {
            _iCurSel = iSelected = AbsIdxFromRel( 0 );
            Assert( iSelected >= 0 && iSelected < _aryOptions.Size() );
            _aryOptions[iSelected]->_fSELECTED = TRUE;
            if (_hwnd)
                SendSelectMessage(Select_SetCurSel, (WPARAM)iSelected, 0);
        }
        else
        {         
            _iCurSel = iSelected;
        }
    }

    _fOptionsDirty = FALSE;
    _fWindowDirty  = TRUE;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AppendOption
//
//  Synopsis:   Appends an option to the _aryOptions array
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::AppendOption(COptionElement * pOption)
{
    HRESULT hr;

    Assert(pOption);

    // Assert that we haven't seen this element before
    Assert( -1 == _aryOptions.Find(pOption) );

    hr = pOption->CacheText();
    if ( hr )
        goto Cleanup;

    hr = _aryOptions.Append(pOption);
    if ( hr )
        goto Cleanup;

    pOption->_fInCollection = TRUE;

    if (pOption->_fSELECTED)
    {
        long lControlIndex = _aryOptions.Find(pOption);

        if ( ! _fMultiple )
        {
            SetCurSel(lControlIndex, SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND);
        }
        else
        {
            SetSel(lControlIndex, TRUE, SETCURSEL_DONTTOUCHHWND);
        }
    }

    TraceTag((tagSelectWalk, "Option index %d, text is %ls %s",_aryOptions.Find(pOption),pOption->_cstrText, pOption->_fSELECTED ? "SELECTED" : "" ));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetVisibleRect
//
//  Synopsis:   Sets the bound of visible part of selector window
//
//  Arguments:  rc      ref to bounding rectangle
//
//  Note:       Calling SetVisibleRect cause deferred redefinition
//              of window region; that happens at WM_WINDOWPOSCHANGING
//              event sent by SetWindowPos.
//-------------------------------------------------------------------------
void CSelectElement::SetVisibleRect(const CRect& rc)
{
    if (_rgnVisible == rc)
        return;

    CRegion2 r(rc);
    r.Subtract(_rgnVisible);
    _rgnInvalidate.Union(r);
    _rgnVisible = rc;

    _fVisibleChanged = true;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetVisibleRegion
//
//  Synopsis:   Sets the bound of visible part of selector window
//
//  Arguments:  rgn      ref to new region
//
//  Note:       Calling SetVisibleRegion cause deferred redefinition
//              of window region; that happens at WM_WINDOWPOSCHANGING
//              event sent by SetWindowPos.
//-------------------------------------------------------------------------
void CSelectElement::SetVisibleRegion(const CRegion2& rgn)
{
    if (_rgnVisible == rgn)
        return;

    CRegion2 r(rgn);
    r.Subtract(_rgnVisible);
    _rgnInvalidate.Union(r);
    _rgnVisible = rgn;

    _fVisibleChanged = true;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetNearestOption
//
//  Synopsis:   For the given OptGroup returns the nearest Option 
//              in the direction indicated (fDir = TRUE means UP)
//              If at the end of the list returns -1
//
//-------------------------------------------------------------------------
long CSelectElement::GetNearestOption(long lIndex, BOOL fDir)
{
    Assert( _fHasOptGroup );
    Assert( _aryOptions[lIndex]->_fIsOptGroup );
    Assert( lIndex >= 0 && lIndex < _aryOptions.Size() );

    if (fDir)
    {
        // Search UP
        for(int i = lIndex - 1; i >= 0 && _aryOptions[i]->_fIsOptGroup; i--);
        return i;
    }
    else
    {
        // Search DOWN
        for(int i = lIndex + 1; i < _aryOptions.Size() && _aryOptions[i]->_fIsOptGroup; i++);
        return i < _aryOptions.Size() ? i : -1 ;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::HandleKeyForOptGroup
//
//  Synopsis:   Handles the Up/Down keys in case we are about to select OptGroup
//
//  Arguments:  wParam      key code
//
//  Note:       The function returns true if the selection was OptGroup in which
//              case the nearest eligible option is selected instead
//-------------------------------------------------------------------------
BOOL CSelectElement::HandleKeyForOptGroup(WPARAM wParam, long * lDelta)
{
    Assert( _fHasOptGroup );
    BOOL keyHandled = FALSE;
    long iNewSel = -1;
    long iCurSel =_iCurSel;
    long lPageSize = DEFAULT_COMBO_ITEMS - 3;

    if (_hwndDropList)
    {
        Assert(!_fMultiple);
        iCurSel = ::SendMessageA(_hwndDropList, LB_GETCURSEL, 0, 0);  
    }
    else if (iCurSel == -1)
    {
        Assert(_hwnd);
        Assert(_fListbox);
        iCurSel = ::SendMessageA(_hwnd, LB_GETCURSEL, 0, 0);
        if (!_fMultiple && (iCurSel == -1))
            iCurSel = 0;
    }

    // If no selection ignore keyboard
    if (iCurSel == -1)
    {
        return TRUE;
    }

    switch(wParam)
    {
    case VK_UP:
        iNewSel = iCurSel - 1;
        if (iNewSel >= 0 && _aryOptions[iNewSel]->_fIsOptGroup)
        {
            keyHandled = TRUE;
            iNewSel = GetNearestOption(iNewSel, TRUE);
        }
        break;

    case VK_DOWN:
        iNewSel = iCurSel + 1;
        if ( iNewSel < _aryOptions.Size() )
        {
            if ( _aryOptions[iNewSel]->_fIsOptGroup )
            {
                keyHandled = TRUE;
                iNewSel = GetNearestOption(iNewSel, FALSE);
            }
        }
        else
        {
            iNewSel = -1;
        }        
        break;

    case VK_PRIOR:
        if (_fListbox)
        {
            lPageSize = GetAAsize();
            Assert(lPageSize || _fMultiple);
            lPageSize = (!lPageSize && _fMultiple) ? 3 : lPageSize-1;
            Assert(lPageSize >= 0);
        }

        if (iCurSel - lPageSize <= 0)
        {
            goto Home;
        }
        else if (_aryOptions[iCurSel - lPageSize]->_fIsOptGroup)
        {
            iNewSel = GetNearestOption(iCurSel - lPageSize, TRUE);
            if (iNewSel == -1)
            {
                Assert(_aryOptions[0]->_fIsOptGroup);
                goto Home;
            }
            keyHandled = TRUE;
        }
        break;

    case VK_NEXT:
        if (_fListbox)
        {
            lPageSize = GetAAsize();
            Assert(lPageSize || _fMultiple);
            lPageSize = (!lPageSize && _fMultiple) ? 3 : lPageSize-1;
            Assert(lPageSize >= 0);
        }

        if (iCurSel + lPageSize >= _aryOptions.Size() - 1)
        {
            goto End;
        }
        else if (_aryOptions[iCurSel + lPageSize]->_fIsOptGroup)
        {
            iNewSel = GetNearestOption(iCurSel + lPageSize, FALSE);
            if (iNewSel == -1)
            {
                Assert(_aryOptions[_aryOptions.Size() - 1]->_fIsOptGroup);
                goto End;
            }
            keyHandled = TRUE;
        }
        break;

    case VK_HOME:
Home:        
        if ( _aryOptions[0]->_fIsOptGroup && !_fMultiple )
        {
            keyHandled = TRUE;
            iNewSel = GetNearestOption(0, FALSE);
        }
        break;

    case VK_END:
End:
        iNewSel = _aryOptions.Size() - 1;
        if ( _aryOptions[iNewSel]->_fIsOptGroup && !_fMultiple )
        {
            keyHandled = TRUE;
            iNewSel = GetNearestOption(iNewSel, TRUE);
        }
        break;
    }
        
    if ( keyHandled && iNewSel != -1 )
    {
        if ( _fMultiple )
        {
            keyHandled = FALSE;
            *lDelta = iNewSel - iCurSel;

            switch (wParam)
            {
            case VK_PRIOR:
                *lDelta += lPageSize;
                break;
            case VK_NEXT:
                *lDelta -= lPageSize;
                break;
            case VK_UP:
                *lDelta += 1;
                break;
            case VK_DOWN:
                *lDelta -= 1;
                break;
            }
        }
        else
        {
            SetCurSel(iNewSel, SETCURSEL_UPDATECOLL);
        }
    }

    return keyHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\eoption.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eoption.cxx
//
//  Contents:   Option element class, etc..
//
//  Classes:    COptionElement, etc..
//
//------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include "textxfrm.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "option.hdl"

MtDefine(COptionElement, Elements, "COptionElement")
MtDefine(COptionElementFactory, Elements, "COptionElementFactory")

#if DBG == 1
static unsigned s_OptionSize = sizeof(COptionElement);
#endif

extern class CFontCache & fc();

const CElement::CLASSDESC COptionElement::s_classdesc =
{
    {
        &CLSID_HTMLOptionElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOANCESTORCLICK|
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLOptionElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLOptionElement,     // apfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT COptionElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_OPTION) || pht->Is(ETAG_OPTGROUP));
    Assert(ppElementResult);
    *ppElementResult = new COptionElement(pht->GetTag(), pDoc);

    if (*ppElementResult)
    {
        if (pht->IsDynamic())
            DYNCAST(COptionElement, *ppElementResult)->_fIsDynamic = TRUE;
        if (pht->Is(ETAG_OPTGROUP))
            DYNCAST(COptionElement, *ppElementResult)->_fIsOptGroup = TRUE;

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
COptionElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLOptionElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLOptionElement3, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::GetParentSelect
//
//  Synopsis:   Parent SELECT
//
//-------------------------------------------------------------------------

CSelectElement * 
COptionElement::GetParentSelect(void)
{
    if(!GetFirstBranch())
        return NULL;

    CElement * pElementParent = GetFirstBranch()->Parent()->SafeElement();

    if ( pElementParent )
    {
        if ( pElementParent->Tag() == ETAG_OPTGROUP )
        {
            return ((COptionElement*)pElementParent)->GetParentSelect();
        }
        else if (pElementParent->Tag() != ETAG_SELECT )
        {
            pElementParent = NULL;
        }
    }

    return (CSelectElement*)pElementParent;
}

#if DBG == 1
void
COptionElement::Passivate(void)
{
    CSelectElement * pSelect = GetParentSelect();

    Assert(! pSelect || pSelect->_poptLongestText != this);

    super::Passivate();
}
#endif // DBG

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::Notify
//
//  Synopsis:   Placeholder for the notification stuff
//
//  Note:       The OPTION might need it for managing the SELECT's cache
//
//----------------------------------------------------------------------------

void
COptionElement::Notify(CNotification *pNF)
{
    DWORD           dw = pNF->DataAsDWORD();

    super::Notify(pNF);

    switch(pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        {
            CSelectElement * pSelect = GetParentSelect();

            if ( pSelect )
            {
                pSelect->_fOptionsDirty = TRUE;
                pSelect->Layout()->InternalNotify();
            }
        }

        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        _fInCollection = FALSE;
        if (!(dw & EXITTREE_DESTROY))
        {
            CSelectElement * pSelect = GetParentSelect();

            if (pSelect)
            {
                pSelect->_fOptionsDirty = TRUE;
                pSelect->Layout()->InternalNotify();
            }
        }
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
COptionElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{

    // NOTE - (68121 krisma) If we are printing, and the parent select of 
    // the option is a combobox, and there is no option currently selected,
    // we need to save an empty select so that we print without any options 
    // showing. (By default, a combo box shows the first option.)

    HRESULT hr = S_OK;

    if (pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        CSelectElement * pSelect = GetParentSelect();
        if (pSelect && !pSelect->_fListbox && pSelect->GetCurSel() == -1)
        {
            goto Cleanup;
        }
    }
    hr = super::Save(pStreamWrBuff, fEnd);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::Init2
//
//  Synopsis:   Initialization phase after attributes were set.
//
//  Note:       Save the SELECTED flag into DefaultSelected
//
//-------------------------------------------------------------------------

HRESULT
COptionElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    _fDefaultSelected = _fSELECTED;

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::Getindex
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_index(long * plIndex)
{
    if (!plIndex)
        RRETURN(SetErrorInfoInvalidArg());

    if ( _fInCollection )
    {
        CSelectElement * pSelect  = GetParentSelect();
        long             absIndex = pSelect->_aryOptions.Find(this);

        *plIndex = pSelect->RelIdxFromAbs( absIndex );
    }
    else
    {
        Assert(0 && "We shouldn't get here: getIndex while not in Options collection");
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::put_index
//
//  Synopsis:   Pretends to set the index of the option object
//              This is a silent no-op.
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::put_index(long lIndex)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::get_form
//
//  Synopsis:   Returns the form above the option, if there is one.
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_form(IHTMLFormElement **ppDispForm)
{
    HRESULT          hr = S_OK;
    CFormElement   * pForm;
    CSelectElement * pSelect;

    if (!ppDispForm)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispForm = NULL;

    pSelect = GetParentSelect();

    if (pSelect)
        pForm = pSelect->GetParentForm();
    else
        goto Cleanup; // return S_OK/NULL

    if (pForm)
    {
        hr = THR_NOTRACE(pForm->QueryInterface(IID_IHTMLFormElement,
                                              (void**)ppDispForm));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfoPGet( hr, DISPID_CSite_form));
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::get_text
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_text(BSTR * pbstrText)
{
    HRESULT hr = S_OK;

    if (!pbstrText)
        RRETURN(SetErrorInfoInvalidArg());

    *pbstrText = NULL;

    if (_fIsOptGroup)
        goto Cleanup;

#if (DBG == 1 && defined(WIN16))
    CSelectElement *pSelect;

    //  This code sanity-check the text in the listbox
    //  against the text in the OPTION element to make sure they
    //  are still in sync.

    if ( _fInCollection &&
         NULL != (pSelect = GetParentSelect()) &&
         pSelect->_hwnd
        )
    {
        CStr cstrText;
        long cchText;
        long lIndex;

        lIndex = pSelect->_aryOptions.Find(this);

        Assert(lIndex > -1 );

        cchText = pSelect->SendSelectMessage(CSelectElement::Select_GetTextLen, lIndex, 0);
        if ( cchText == LB_ERR )
            goto Win32Error;

        hr = cstrText.ReAlloc(cchText);
        if ( hr )
            goto Error;

        cchText = pSelect->SendSelectMessage(CSelectElement::Select_GetText,
                                             lIndex,
                                             (LPARAM)(LPTSTR)cstrText);
        if ( cchText == LB_ERR )
            goto Win32Error;

        cstrText.SetLengthNoAlloc(cchText);

        Assert(0 == StrCmpC(_cstrText, cstrText));
    }
#endif

    if ( ! _cstrText.IsNull() )
    {
        hr = _cstrText.AllocBSTR(pbstrText);
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

#if (DBG == 1 && defined(WIN16))

    //  Error handling block for the sanity check above
Error:
    SysFreeString(*pbstrText);
    *pbstrText = NULL;
    goto Cleanup;

Win32Error:
    hr = GetLastWin32Error();
    goto Error;

#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::put_text
//
//  Synopsis:   Set the display text pf the OPTION element
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::put_text(BSTR bstrText)
{
    HRESULT hr = S_OK;

    // Note that VID 6.0 constructed a bad BSTR, without a proper length,
    // but zero terminated. So, we're going to rely on zero termination
    // instead of the length.
    LPTSTR pchText=(LPTSTR)bstrText;

    CSelectElement * pSelect = NULL;
    BOOL fOldEnableLayoutRequests = TRUE;
    BOOL fOldFlagValid = FALSE;

    long lIndex;
    long lSelectedIndex = 0;
    LRESULT lr;

    if (_fIsOptGroup)
        goto Cleanup;

    hr = _cstrText.Set(pchText);
    if ( hr )
        goto Cleanup;

    // invalidate font linking test
    _fCheckedFontLinking = FALSE;

    if ( !IsInMarkup() )
        goto Cleanup;

    pSelect = GetParentSelect();
    if ( pSelect )
    {
        fOldFlagValid = TRUE;
        fOldEnableLayoutRequests = pSelect->_fEnableLayoutRequests;
        pSelect->_fEnableLayoutRequests = FALSE;
    }

    {
        CMarkupPointer p1( Doc() ), p2( Doc() );

        hr = THR( p1.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );

        if (hr)
            goto Cleanup;
                  
        hr = THR( p2.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd ) );

        if (hr)
            goto Cleanup;

        hr = THR( Doc()->Remove( & p1, & p2 ) );

        if (hr)
            goto Cleanup;

        hr = THR( Doc()->InsertText( & p1, pchText, -1 ) );

        if (hr)
            goto Cleanup;
    }

    //  Old code brought back for synchronous update
    if ( _fInCollection && (NULL != pSelect) && pSelect->_hwnd )
    {
        lIndex = pSelect->_aryOptions.Find(this);

        Assert(lIndex > -1 );

        if ( ! pSelect->IsMultiSelect() )
        {
            lSelectedIndex = pSelect->SendSelectMessage(CSelectElement::Select_GetCurSel, 0, 0);
        }

        lr = pSelect->SendSelectMessage(CSelectElement::Select_DeleteString, lIndex, 0);
        if ( lr == LB_ERR )
            goto Win32Error;

        lr = pSelect->SendSelectMessage(CSelectElement::Select_InsertString, lIndex, (LPARAM)(LPTSTR)pchText);
        if ( lr == LB_ERR )
            goto Win32Error;

        if ( ! pSelect->IsMultiSelect() && lSelectedIndex == lIndex )
        {
            pSelect->SetCurSel(lSelectedIndex);
        }

        pSelect->DeferUpdateWidth();
    }

Cleanup:
    if ( fOldFlagValid && pSelect)
    {
        pSelect->_fEnableLayoutRequests = fOldEnableLayoutRequests;
    }
    RRETURN(SetErrorInfo(hr));

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::put_defaultSelected
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::put_defaultSelected(VARIANT_BOOL f)
{
    _fDefaultSelected = (f == VB_TRUE);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::get_defaultSelected
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_defaultSelected(VARIANT_BOOL * pf)
{
    if ( ! pf )
        RRETURN (SetErrorInfo(E_POINTER));

    *pf = _fDefaultSelected ? VB_TRUE : VB_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::GetSelectedHelper
//
//  Synopsis:   Gets the selected state of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::GetSelectedHelper(long * pf)
{
    HRESULT hr = S_OK;

    if (!pf)
        RRETURN(SetErrorInfoInvalidArg());

#if DBG == 1
    CSelectElement *pSelect;
    long lIndex;

    if ( _fSELECTED && ( NULL != (pSelect = GetParentSelect()) ) 
        && !( pSelect->_fMultiple ) && ( pSelect->_aryOptions.Size() > 0 ))
    {
        lIndex = pSelect->_aryOptions.Find(this);
        Assert (lIndex == pSelect->_iCurSel);
    }

#endif // DBG == 1

    *pf = _fSELECTED;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::SetSelectedHelper
//
//  Synopsis:   Gets the selected state of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::SetSelectedHelper(long f)
{
    HRESULT hr = S_OK;
    CSelectElement *pSelect;
    long lIndex;
    LRESULT lr;
    int iOldSel;

    if (_fIsOptGroup)
        goto Cleanup;

    _fSELECTED = f;

    if ( _fInCollection && NULL != (pSelect = GetParentSelect()) )
    {
        iOldSel = pSelect->_iCurSel;
        int iCurSel;
        lIndex = pSelect->_aryOptions.Find(this);

        Assert(lIndex > -1 );
        if ( pSelect->_fMultiple )
        {
            lr = pSelect->SetSel(lIndex, !!f);
            if ( lr == LB_ERR )
                goto Win32Error;
        }
        else
        {
            //  Force collection update
            lr = pSelect->SetCurSel(lIndex, SETCURSEL_UPDATECOLL);
            if ( lr == LB_ERR )
                goto Win32Error;
        }

        iCurSel = pSelect->GetCurSel();
        if (iCurSel != iOldSel)
        {
            hr = THR(pSelect->OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                               0, 
                                               (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
            if (hr)
                goto Cleanup;
            if (pSelect->HasValueChanged(iOldSel, iCurSel))
            {
                hr = THR(pSelect->OnPropertyChange(DISPID_CSelectElement_value, 
                                                   0,
                                                   (PROPERTYDESC *)&s_propdescCSelectElementvalue));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::GetDisplayColors
//
//  Synopsis:   Computes the fore and background colors of the option element
//              based on selection state, styles and Windows color preferences.
//
//----------------------------------------------------------------------------

void
COptionElement::GetDisplayColors(COLORREF * pcrFore, COLORREF * pcrBack, BOOL fListbox)
{
    CColorValue ccv;
    CSelectElement * pSelect;

    Assert(pcrFore);
    Assert(pcrBack);


    //  Set up the textcolor
    if ( (NULL != (pSelect = GetParentSelect())) &&
          pSelect->GetAAdisabled() )
    {
        *pcrFore = GetSysColorQuick(COLOR_GRAYTEXT);
    }
    else if ( fListbox && _fSELECTED )
    {
        *pcrFore = GetSysColorQuick(COLOR_HIGHLIGHTTEXT);
    }
    else if ( (ccv = GetFirstBranch()->GetCascadedcolor()).IsDefined() )
    {
        *pcrFore = ccv.GetColorRef();
    }
    else
    {
        *pcrFore = GetSysColorQuick(COLOR_WINDOWTEXT);
    }

    //Set up the backcolor
    if ( fListbox && _fSELECTED )
    {
        *pcrBack = GetSysColorQuick(COLOR_HIGHLIGHT);
    }
    else if ( (ccv = GetFirstBranch()->GetCascadedbackgroundColor()).IsDefined() )
    {
        *pcrBack = ccv.GetColorRef();
    }
    else
    {
        *pcrBack = GetSysColorQuick(COLOR_WINDOW);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::GetDisplayText
//
//  Synopsis:   Returns the display text according to TEXT_TRANSFORM.
//
//----------------------------------------------------------------------------

CStr *
COptionElement::GetDisplayText(CStr * pcstrBuf, BOOL noIndent /* = FALSE */)
{
    BYTE bTextTransform = GetFirstBranch()->GetCascadedtextTransform();

    Assert(pcstrBuf);

    if ( ( bTextTransform == styleTextTransformNotSet ) ||
         ( bTextTransform == styleTextTransformNone ) )
    {
        if (_fIsGroupOption && !noIndent)
        {
            pcstrBuf->Set(_T("      "));
            pcstrBuf->Append(_cstrText);
            return pcstrBuf;
        }
        else
         return &_cstrText;
    }
    else
    {
        if (_fIsGroupOption && !noIndent)
        {
            CStr cstrTemp;
        
            cstrTemp.Set(_T("      "));
            cstrTemp.Append(_cstrText);

            TransformText( *pcstrBuf,
                           cstrTemp,
                           cstrTemp.Length(),
                           bTextTransform );
        }
        else
        {
            TransformText( *pcstrBuf,
                           _cstrText,
                           _cstrText.Length(),
                           bTextTransform );
        }

        return pcstrBuf;
    }
}

//+---------------------------------------------------------------
//
//  Member   : COptionElement::OnPropertyChange
//
//  Synopsis : Do any work that Options need when a property is
//             changed
//
//+---------------------------------------------------------------
HRESULT
COptionElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    CSelectElement *pSelect;

    if ( NULL != (pSelect = GetParentSelect()) )
    {
            // some changes invalidate collections
        if (dwFlags & ELEMCHNG_UPDATECOLLECTION)
        {
            pSelect->InvalidateCollection();

            // Clear this flag: exclusive or
            dwFlags ^= ELEMCHNG_UPDATECOLLECTION;
        }

        if ( dispid == DISPID_COptionElement_text ||
             dispid == DISPID_UNKNOWN )
        {
            pSelect->DeferUpdateWidth();
        }

        if ( _fIsOptGroup && (dispid == DISPID_COptionElement_label) )
        {
            Assert( Tag() == ETAG_OPTGROUP );
            hr = _cstrText.Set(GetAAlabel());
            if ( hr )
                goto Cleanup;

            if ( _fInCollection && pSelect->_hwnd )
            {
                LRESULT lr;
                long lIndex = pSelect->_aryOptions.Find(this);
                Assert(lIndex > -1 );

                lr = pSelect->SendSelectMessage(CSelectElement::Select_DeleteString, lIndex, 0);
                if ( lr == LB_ERR )
                    goto Win32Error;

                lr = pSelect->SendSelectMessage(CSelectElement::Select_InsertString, lIndex, (LPARAM)(LPTSTR)_cstrText);
                if ( lr == LB_ERR )
                    goto Win32Error;

                pSelect->DeferUpdateWidth();
            }
        }

        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    }

Cleanup:
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

HRESULT
COptionElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    if (_fIsGroupOption)
    {
        Assert(GetFirstBranch());
        CTreeNode *pNodeParent = GetFirstBranch()->Parent();
        Assert(pNodeParent && (pNodeParent->Tag() == ETAG_OPTGROUP));

        Assert(pNodeParent->GetIFF() != -1);
        const CFancyFormat *pff = pNodeParent->GetFancyFormat();

        Assert(!pCFI->_pff->_ccvBackColor.IsDefined());
        if (pff->_ccvBackColor.IsDefined())
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._ccvBackColor = pff->_ccvBackColor;
            pCFI->UnprepareForDebug();
        }
    }

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr)
        goto Cleanup;

    if (_fIsOptGroup)
    {
#if DBG == 1
        Assert(GetFirstBranch());
        CTreeNode *pNodeParent = GetFirstBranch()->Parent();
        Assert(pNodeParent && (pNodeParent->Tag() == ETAG_SELECT));

        long icf = pNodeParent->GetICF();
        Assert(icf != -1);
        const CCharFormat *pcf = GetCharFormatEx(icf);
        Assert(pcf == pCFI->_pcfSrc);
#endif

        pCFI->PrepareCharFormat();

        if (pCFI->_pcfSrc->_fItalic && pCFI->_pcfSrc->_fBold && (pCFI->_pcfSrc->_wWeight == FW_BOLD))
        {
            pCFI->_cf()._fUnderline = TRUE;
            pCFI->_cf()._fBold      = pCFI->_pcfSrc->_fBold;
            pCFI->_cf()._fItalic    = pCFI->_pcfSrc->_fItalic;
            pCFI->_cf()._wWeight    = pCFI->_pcfSrc->_wWeight;
        }
        else
        {
            pCFI->_cf()._fBold      = TRUE;
            pCFI->_cf()._fItalic    = TRUE;
            pCFI->_cf()._wWeight    = FW_BOLD;
            pCFI->_cf()._fUnderline = pCFI->_pcfSrc->_fUnderline;
        }

        pCFI->_cf()._latmFaceName    = pCFI->_pcfSrc->_latmFaceName;
        pCFI->_cf()._bCharSet        = pCFI->_pcfSrc->_bCharSet;
        pCFI->_cf()._bPitchAndFamily = pCFI->_pcfSrc->_bPitchAndFamily;
        pCFI->_cf()._lcid            = pCFI->_pcfSrc->_lcid;
        pCFI->_cf()._yHeight         = pCFI->_pcfSrc->_yHeight;
        pCFI->_cf()._wKerning        = pCFI->_pcfSrc->_wKerning;

        pCFI->_cf()._fExplicitFace   = pCFI->_pcfSrc->_fExplicitFace;
        pCFI->_cf()._fExplicitAtFont = pCFI->_pcfSrc->_fExplicitAtFont;
        pCFI->_cf()._fNarrow         = pCFI->_pcfSrc->_fNarrow;
        pCFI->_cf()._fOverline       = pCFI->_pcfSrc->_fOverline;
        pCFI->_cf()._fStrikeOut      = pCFI->_pcfSrc->_fStrikeOut;
        pCFI->_cf()._fSmallCaps      = pCFI->_pcfSrc->_fSmallCaps;

        pCFI->_cf()._fSuperscript    = pCFI->_pcfSrc->_fSuperscript;
        pCFI->_cf()._fSubscript      = pCFI->_pcfSrc->_fSubscript;
        pCFI->_cf()._fBumpSizeDown   = pCFI->_pcfSrc->_fBumpSizeDown;
        pCFI->_cf()._fPassword       = pCFI->_pcfSrc->_fPassword;
        pCFI->_cf()._fProtected      = pCFI->_pcfSrc->_fProtected;
        pCFI->_cf()._fSizeDontScale  = pCFI->_pcfSrc->_fSizeDontScale;
        pCFI->_cf()._fDownloadedFont = pCFI->_pcfSrc->_fDownloadedFont;
        pCFI->_cf()._fSubSuperSized  = pCFI->_pcfSrc->_fSubSuperSized;
        pCFI->_cf()._fOutPrecision   = pCFI->_pcfSrc->_fOutPrecision;

        pCFI->_cf()._bCrcFont = pCFI->_pcf->ComputeFontCrc();
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member   : COptionElement::MeasureLine
//
//  Synopsis : Measure the length of a single line
//
//+---------------------------------------------------------------
long
COptionElement::MeasureLine(CCalcInfo * pci)
{
    CStr cstrBuffer;
    CStr * pcstrDisplayText;
    long lWidth;
    long cch;
    long lCharWidth = -1;
    CSelectElement * pSelect;
    int i;
    TCHAR * pch;
    const CCharFormat *pcf;
    const CParaFormat *pPF;
    BOOL fRTL;
    UINT taOld = 0;
    CCcs ccs;
    CCalcInfo   CI;

    pSelect = GetParentSelect();

    if ( ! pSelect )
        return -1;

    if ( ! pci )
    {
        CI.Init(pSelect->GetUpdatedLayout());
        pci = &CI;
    }

    pcstrDisplayText = GetDisplayText(&cstrBuffer);

    cch = pcstrDisplayText->Length();

    //  We don't support letterspacing in the listbox for v1.0
    //lWidth = (cch - 1) * GetCascadedletterSpacing().GetPixelValue(pci, CUnitValue::DIRECTION_CX, 0);
    lWidth = 0;

    if (_fIsOptGroup)
        pcf = GetFirstBranch()->GetCharFormat();
    else
        pcf = pSelect->GetFirstBranch()->GetCharFormat();

    pPF = pSelect->GetFirstBranch()->GetParaFormat();
    
    fRTL = pPF->HasRTL(TRUE);
    // ComplexText
    if(fRTL)
    {
        taOld = GetTextAlign(pci->_hdc);
        SetTextAlign(pci->_hdc, TA_RTLREADING | TA_RIGHT);
    }

    if ( ! pcf )
        return -1;  //  <<<< inline return

    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pcf))
        return -1;

    if (CheckFontLinking(pci->_hdc, &ccs) && pcf != NULL)
    {
        // TODO: (benwest) this code won't be necessary after after bug 28568 is resolved...
        // the listbox charformat should be non-scaling but currently isn't.
        CCharFormat cf = *pcf;
        cf.SetHeightInNonscalingTwips(cf._yHeight);
        cf._bCrcFont = cf.ComputeFontCrc();
        // end

        lCharWidth = FontLinkTextOut(pci->_hdc, 0, 0, 0, NULL, *pcstrDisplayText, cch, pci, &cf, FLTO_TEXTEXTONLY);
        if (lCharWidth > 0)
        {
            lWidth += lCharWidth; // width of entire string
        }
    }

    if (lCharWidth < 0)
    {
        for ( i = cch, pch = *pcstrDisplayText;
              i > 0;
              i--, pch++ )
        {
            if ( ! ccs.Include(*pch, lCharWidth) )
            {
                Assert(0 && "Char not in font!");
            }
            lWidth += lCharWidth;
        }
    }

    SetTextAlign(pci->_hdc, taOld);

    ccs.Release();

    return lWidth;
}

//+---------------------------------------------------------------
//
//  Member   : COptionElement::CheckFontLinking
//
//  Synopsis : Returns TRUE iff this option needs font linking.
//
//+---------------------------------------------------------------
BOOL COptionElement::CheckFontLinking(XHDC hdc, CCcs *pccs)
{
    CStr cstrTransformed;
    CStr *pcstrDisplayText;
    LPCTSTR pString;

    if (_fCheckedFontLinking) // assuming only one thread will run this per element
    {
        return _fNeedsFontLinking;
    }

    _fCheckedFontLinking = TRUE;
    _fNeedsFontLinking = FALSE; // init for failure

    pcstrDisplayText = GetDisplayText(&cstrTransformed);
    pString = *pcstrDisplayText;

    if (pString == NULL)
    {
        return FALSE;
    }

    return (_fNeedsFontLinking = NeedsFontLinking(hdc, pccs, pString, _tcslen(pString), Doc()));
}


HRESULT
COptionElement::CacheText(void)
{
    HRESULT hr;

    CTreePos * ptpStart;
    CTreePos * ptpEnd;

    if (Tag() == ETAG_OPTION)
    {
        GetTreeExtent(&ptpStart, &ptpEnd);

        if( !ptpStart || !ptpEnd)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        {
            long    cp = ptpStart->GetCp() + 1;
            long    cch = ptpEnd->GetCp() - cp;

            CTxtPtr tp( GetMarkup(), cp );

            cch = tp.GetPlainTextLength( cch );

            _cstrText.Free();

            hr = _cstrText.ReAlloc(cch);
            if ( hr )
                goto Cleanup;

            Verify( cch == tp.GetPlainText( cch, _cstrText ) );
            _cstrText.SetLengthNoAlloc(cch);
        }
    }
    else
    {
        Assert(Tag() == ETAG_OPTGROUP);

        hr = _cstrText.Set(GetAAlabel());
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Class:      COptionElementFactory
//
//----------------------------------------------------------------------------

const COptionElementFactory::CLASSDESC COptionElementFactory::s_classdesc =
{
    {
        &CLSID_HTMLOptionElementFactory,     // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLOptionElementFactory,      // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnIHTMLOptionElementFactory,         // _apfnTearOff
};

// Get this into CVariant next full build I do

//+---------------------------------------------------------------------------
//
//  Member:     COptionElementFactory::create
//
//  Synopsis:   Manufactures a new COptionElement/
//
//  Note:       Supports the "new Option(...)" JavaScript syntax
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
COptionElementFactory::create(VARIANT varText,
    VARIANT varvalue,
    VARIANT varDefaultSelected,
    VARIANT varSelected,
    IHTMLOptionElement**ppnewElem )
{
    HRESULT hr;
    COptionElement *pOptionElem;
    CElement *pNewElem = NULL;
    CVariant varBSTRText;
    CVariant varBSTRvalue;
    CVariant varBOOLDefaultSelected;
    CVariant varBOOLSelected;

    if ( !ppnewElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppnewElem = NULL;

    // actualy ( [ BSTR text, [ BSTR value, [ BOOL defaultselected, [ BOOL selected] ] ] )
    // Create an Option element 
    hr = THR(_pMarkup->CreateElement(ETAG_OPTION, &pNewElem ));
    if ( hr )
        goto Cleanup;

    pOptionElem = DYNCAST(COptionElement, pNewElem);

    hr = THR(pOptionElem->QueryInterface ( IID_IHTMLOptionElement, (void **)ppnewElem ));

    // Now set up the properties specified ( if present )

    // Text
    hr = THR(varBSTRText.CoerceVariantArg(&varText, VT_BSTR) );
    if ( hr == S_OK )
    {
        hr = THR(pOptionElem->_cstrText.Set ( V_BSTR(&varBSTRText) ));
    }
    if ( !OK(hr) )
        goto Cleanup;

    // Value
    hr = THR(varBSTRvalue.CoerceVariantArg(&varvalue,VT_BSTR) );
    if ( hr == S_OK )
    {
        hr = THR(pOptionElem->SetAAvalue ( V_BSTR(&varBSTRvalue) ));
    }
    if ( !OK(hr) )
        goto Cleanup;

    // defaultSelected
    hr = THR(varBOOLDefaultSelected.CoerceVariantArg(&varDefaultSelected, VT_BOOL));
    if ( hr == S_OK )
    {
        pOptionElem->_fDefaultSelected = V_BOOL(&varBOOLDefaultSelected);
    }
    if ( !OK(hr) )
        goto Cleanup;

    // selected
    hr = THR(varBOOLSelected.CoerceVariantArg(&varSelected, VT_BOOL) );
    if ( hr == S_OK )
    {
        pOptionElem -> _fSELECTED = V_BOOL(&varBOOLSelected) == VB_TRUE ? TRUE : FALSE;
    }
    if ( !OK(hr) )
        goto Cleanup;


Cleanup:
    if (OK(hr))
    {
        hr = S_OK; // not to propagate possible S_FALSE
    }
    else
    {
        ReleaseInterface(*(IUnknown**)ppnewElem);
    }

    CElement::ClearPtr(&pNewElem);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\imgelem.cxx ===
//+---------------------------------------------------------------------
//
//   File:      image.cxx
//
//  Contents:   Img element class, etc..
//
//  Classes:    CImgElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h" // for s_enumdeschtmlReadyState
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx" // AreRatingsEnabled()
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "img.hdl"

ExternTag(tagMsoCommandTarget);
ExternTag(tagTooltip);
MtDefine(CImgElement, Elements, "CImgElement")
MtDefine(CImageElementFactory, Elements, "CImageElementFactory")

#ifndef WIN16
extern NEWIMGTASKFN NewImgTaskArt;
#endif


#ifndef NO_PROPERTY_PAGE
const CLSID * const CImgElement::s_apclsidPages[] =
{
    // Browse-time pages
    &CLSID_CImageBrowsePropertyPage,
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1       
    NULL
};
#endif // NO_PROPERTY_PAGE



const CElement::CLASSDESC CImgElement::s_classdesc =
{
    {
        &CLSID_HTMLImg,                 // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_CARETINS_SL |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_EXBORDRINMOV,       // _dwFlags
        &IID_IHTMLImgElement,           // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLImgElement,    // _pfnTearOff
    NULL                                // _pAccelsRun
};

CImgElement::CImgElement (ELEMENT_TAG eTag, CDoc *pDoc)
      : super(eTag, pDoc)
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    _pMap = NULL;
    _fCanClickImage = FALSE;
    _fNoUIActivateInDesign = TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::Init()
{
    HRESULT hr = S_OK;

    _pImage = new CImgHelper(Doc(), this, FALSE);

    if (!_pImage)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = super::Init();

Cleanup:
    RRETURN(hr);
}

HRESULT
CImgElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert (ppElement);

    *ppElement = new CImgElement(pht->GetTag(), pDoc);

    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CImgElement::GetDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CImgElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pid)
{
    HRESULT         hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

    // Add the hack for the Jeremie test.  If the property we're looking
    // for is  lowSrc, return the dispid for lowsrc.
    if (hr == DISP_E_UNKNOWNNAME && !_tcscmp(bstrName, _T("lowSrc")))
    {
        BSTR    bstrTmp;

        hr = FormsAllocString(_T("lowsrc"), &bstrTmp);
        if (FAILED(hr))
            goto Cleanup;
        hr = THR_NOTRACE(super::GetDispID(bstrTmp, grfdex, pid));
        FormsFreeString(bstrTmp);
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImgElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF(this, IDispatchEx, NULL);
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL);
        QI_HTML_TEAROFF(this, IHTMLImgElement2, NULL);
		QI_TEAROFF(this, IOleCommandTarget, NULL);
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CImgElement::ContextThunk_InvokeExReady(DISPID dispid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT *pvarResult,
                        EXCEPINFO *pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _pImage->_readyStateFired, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

EXTERN_C const GUID CLSID_HTMLObjectElement;

void
CImgElement::EnsureMap()
{
    _pMap = NULL;

    CMarkup * pMarkup = NULL;
    LPCTSTR pchUSEMAP;

    CDoc * pDoc = Doc();
    


    if (pDoc->_fInImageObject) 
    {         
        HRESULT hr = S_OK;
        IOleClientSite * pIOCS = NULL;
        COleSite *pOS = NULL;

        hr = pDoc->GetClientSite(&pIOCS);
        if(!hr)
            hr = IUnknown_QueryService(pIOCS, CLSID_HTMLObjectElement, CLSID_HTMLObjectElement, (void **) &pOS);
        if(!hr)
            pMarkup = pOS->GetMarkup();

        ReleaseInterface(pIOCS);
        
        if (hr)
            return;

        if (pMarkup == NULL)
            return;
        
        
        Assert(ETAG_OBJECT == pOS->Tag());
        CObjectElement * pOE = DYNCAST(CObjectElement, pOS);
        pchUSEMAP = pOE->GetAAuseMap();
    }
    else
    {
        pMarkup = GetMarkup();
        if (pMarkup == NULL)
            return;        
        pchUSEMAP = GetAAuseMap();

    }
 
    CMapElement * pMap = pMarkup->GetMapHead();

    if (pMap == NULL)
        return;

#if DBG==1
    // Checked for a loop in the linked list.  Who would have
    // thought the canonical interview question would actually
    // be useful?
    CMapElement *pPtr1 = pMap;
    CMapElement *pPtr2 = pMap;

    for( ; ; )
    {
        pPtr2 = pPtr2->_pMapNext;
        if( !pPtr2 )    // Ran off end
            break;
        pPtr2 = pPtr2->_pMapNext;
        if( !pPtr2 )    // Ran off end
            break;

        pPtr1 = pPtr1->_pMapNext;

        if( pPtr1 == pPtr2 )
        {
            AssertSz( FALSE, "Loop in linked list of image maps - we're about to go into an infinite loop" );
            break;
        }
    }
#endif // DBG

    if (pchUSEMAP == NULL || *pchUSEMAP == 0)
        return;

    pchUSEMAP = _tcschr(pchUSEMAP, _T('#'));

    if (pchUSEMAP == NULL)
        return;

    pchUSEMAP += 1;

    if (*pchUSEMAP == 0)
        return;

    LONG lSourceIndexMin = LONG_MAX;
    LONG lSourceIndex;
    LPCTSTR pchName;
    BOOL fEqual;

    // Find the map which has the same name and smallest source index

    for (; pMap; pMap = pMap->_pMapNext)
    {
        pchName = pMap->GetAAname();
        fEqual = pchName ? !FormsStringICmp(pchUSEMAP, pchName) : FALSE;

        if (!fEqual)
        {
            pchName = pMap->GetAAid();
            fEqual = pchName ? !FormsStringICmp(pchUSEMAP, pchName) : FALSE;
        }

        if (!fEqual)
        {
            pchName = pMap->GetAAuniqueName();
            fEqual = pchName ? !FormsStringICmp(pchUSEMAP, pchName) : FALSE;
        }

        if (fEqual)
        {
            lSourceIndex = pMap->GetSourceIndex();

            if (lSourceIndex < lSourceIndexMin)
            {
                _pMap = pMap;
                lSourceIndexMin = lSourceIndex;
            }
        }
    }

}

 
//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::Notify
//
//  Synopsis:   Receives notifications
//
//+---------------------------------------------------------------------------

void
CImgElement::Notify(CNotification *pNF)
{
    CAreaElement *  pArea;
    HRESULT         hr = S_OK;
    CElement::CLock  Lock(this);

    super::Notify(pNF);
    Assert(_pImage);

    _pImage->Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        if (!IsEditable(TRUE))
        {
            CQueryFocus *   pQueryFocus = (CQueryFocus *) pNF->DataAsPtr();

            pQueryFocus->_fRetVal = FALSE;

            // uses a client-side image map?
            if (EnsureAndGetMap())
            {
                CAreaElement *  pArea;

                if (S_OK == THR(_pMap->GetAreaContaining(pQueryFocus->_lSubDivision, &pArea)))
                {
                    pQueryFocus->_fRetVal = pArea && (pArea->GetUrl() || pArea->GetAAtabIndex() != htmlTabIndexNotSet);
                }
            }

            // is a server-side image map?
            else if (GetAAisMap())
            {
                CAnchorElement * pAnchor = GetContainingAnchor();
                pQueryFocus->_fRetVal = pAnchor && pAnchor->GetUrl();
            }
        }
        break;
    case NTYPE_ELEMENT_QUERYTABBABLE:
        if (!IsEditable(TRUE))
        {
            CQueryFocus *   pQueryFocus = (CQueryFocus *) pNF->DataAsPtr();

            // Assume that focussability is already checked for, and only make
            // sure that tabIndex is non-negative for subdivision
            Assert(IsFocussable(pQueryFocus->_lSubDivision));
            pQueryFocus->_fRetVal = TRUE;

            // uses a client-side image map?
            if (EnsureAndGetMap())
            {
                CAreaElement *  pArea;

                if (S_OK == THR(_pMap->GetAreaContaining(pQueryFocus->_lSubDivision, &pArea)))
                {
                    Assert(pArea);
                    if (pArea)
                    {
                        short tabIndex = pArea->GetAAtabIndex();

                        if (tabIndex != htmlTabIndexNotSet && tabIndex < 0)
                        {
                            pQueryFocus->_fRetVal = FALSE;
                        }
                    }
                }
            }
        }
        break;
    case NTYPE_ELEMENT_SETFOCUS:
        {
            CHyperlink *    pHyperlink  = NULL;

            // uses a client-side image map?
            if (EnsureAndGetMap())
            {
                CAreaElement *  pArea;

                if (S_OK == THR(_pMap->GetAreaContaining(Doc()->_lSubCurrent, &pArea)))
                {
                    pHyperlink = pArea;
                }
            }

            // is a server-side image map?
            else if (GetAAisMap())
            {
                pHyperlink = GetContainingAnchor();
            }

            if (pHyperlink)
            {
                IGNORE_HR(pHyperlink->SetStatusText());
            }
        }
        break;

    case NTYPE_AREA_TABINDEX_CHANGE:
    case NTYPE_AREA_FOCUS:
        EnsureMap();
        if (_pMap)
        {
            long    l;

            pNF->Data((void **)&pArea);

            if (OK(_pMap->SearchArea(pArea, &l)))
            {
                pNF->SetFlag(NFLAGS_SENDENDED);

                if (pNF->Type() == NTYPE_AREA_FOCUS)
                {
                    //
                    // Search for the area in the map.  If found, then make
                    // myself current.
                    //

                    hr = THR(focusHelper(l));
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    Assert(NTYPE_AREA_TABINDEX_CHANGE == pNF->Type());
                    OnTabIndexChange();
                }
            }
        }
    
    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange( DISPID_CImgElement_useMap, 
                          ((PROPERTYDESC *)&s_propdescCImgElementuseMap)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementuseMap);
        OnPropertyChange( DISPID_CImgElement_src, 
                          ((PROPERTYDESC *)&s_propdescCImgElementsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementsrc);
        OnPropertyChange( DISPID_CImgElement_dynsrc, 
                          ((PROPERTYDESC *)&s_propdescCImgElementdynsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementdynsrc);
        OnPropertyChange( DISPID_CImgElement_lowsrc, 
                          ((PROPERTYDESC *)&s_propdescCImgElementlowsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementlowsrc);
        break;
    }

Cleanup:
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     EnterTree
//
//+---------------------------------------------------------------------------
HRESULT
CImgElement::EnterTree()
{
    EnsureMap();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleMessage
//
//  Synopsis:   Handle messages bubbling when the passed site is non null
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CImgElement::HandleMessage(CMessage * pMessage)
{
    HRESULT hr              = S_FALSE;
    BOOL    fInBrowseMode   = !IsEditable(TRUE);
    TCHAR * pchUrl;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchExpandedUrl  = cBuf;
    IUniformResourceLocator *   pURLToDrag      = NULL;

    EnsureMap();
    if (_pMap)
    {
        CAreaElement *  pArea = NULL;

        IGNORE_HR(_pMap->GetAreaContaining(pMessage->lSubDivision, &pArea));
        if (fInBrowseMode && pArea)
        {
            switch(pMessage->message)
            {
            case WM_CHAR:
            case WM_SYSCHAR:
                switch (pMessage->wParam)
                {
                case VK_RETURN:

                    // For <AREA>, pressing Enter is same as clicking with mouse
                    if (GetCurrentArea())
                    {
                        pMessage->lSubDivision = Doc()->_lSubCurrent;
                        pMessage->SetNodeClk(GetFirstBranch());
                        hr = S_OK;
                    }
                    break ;
                }
                break ;

            case WM_MOUSEWHEEL:
                if (   (pMessage->dwKeyState & FSHIFT)
                    && (((short) HIWORD(pMessage->wParam)) > 0))
                {
                    pMessage->SetNodeClk(GetFirstBranch());
                    hr = S_OK;
                }
                break;

            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                Doc()->SetMouseCapture(
                    MOUSECAPTURE_METHOD(CImgElement, HandleCaptureMessageForArea, handlecapturemessageforarea),
                    this);

                // Set the limits for a mouse move before showing
                // the no entry cursor
                _rcWobbleZone.left   = pMessage->pt.x - g_sizeDragMin.cx;
                _rcWobbleZone.right  = pMessage->pt.x + g_sizeDragMin.cx + 1;
                _rcWobbleZone.top    = pMessage->pt.y - g_sizeDragMin.cy;
                _rcWobbleZone.bottom = pMessage->pt.y + g_sizeDragMin.cy + 1;

                // Can click while mouse is inside wobble zone
                _fCanClickImage = TRUE;
                hr = S_OK;
                break;

            case WM_MOUSEOVER:
                if (!pArea->_fHasMouseOverCancelled)
                {
                    pArea->SetStatusText();
                }
                break;

            case WM_SETCURSOR:
                {
                    TCHAR * pchUrl;

                    if (S_OK == pArea->GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl) && pchUrl)
                    {
                        SetCursorStyle(pArea->GetHyperlinkCursor());
                        MemFreeString(pchUrl);
                        hr = S_OK;
                    }
                }
                break;

            case WM_LBUTTONUP:
                if (_fCanClickImage)    // If click is allowed,
                {
                    Assert(SameScope(pMessage->pNodeHit, this));
                    pMessage->SetNodeClk(GetFirstBranch());
                }
                // Release the mouse capture.
                // Doc()->SetMouseCapture(NULL, NULL);
                TakeCapture(FALSE);
                _fCanClickImage = FALSE;
                hr = S_OK;
                break;

            case WM_RBUTTONUP:
                hr = S_FALSE;

                // Release the mouse capture.
                // Doc()->SetMouseCapture(NULL, NULL, TRUE);
                TakeCapture(FALSE);
                _fCanClickImage = FALSE;
                break;

            case WM_MOUSEMOVE:
                if (!_fCanClickImage)
                    break;

                // If the user moved the mouse outside of the wobble zone,
                if(!PtInRect(&_rcWobbleZone, pMessage->pt))
                {
                    CDoc * pDoc = Doc();

                    _fCanClickImage = FALSE;                     // Disable click
                    SetCursorStyle(IDC_NO);

                    // Release the mouse capture.
                    //pDoc->SetMouseCapture(NULL, NULL, TRUE);
                    TakeCapture(FALSE);

                    // initiate drag-drop
                    if (!pDoc->_fIsDragDropSrc)
                    {
                        // fully resolve URL
                        hr = THR(CMarkup::ExpandUrl(
                            NULL, pArea->GetAAhref(), ARRAY_SIZE(cBuf), pchExpandedUrl, this));
                        if (hr)
                        {
                            hr = S_OK;
                            break;
                        }
                            
                        if (S_OK == THR(CreateLinkDataObject(pchExpandedUrl, NULL, &pURLToDrag)))
                        {
                            if (!DragElement(GetUpdatedLayout(), pMessage->dwKeyState, pURLToDrag, pMessage->lSubDivision))
                            {
                                // release the capture and let someone else handle the
                                // WM_MOUSEMOVE by leaving hr=S_FALSE
                                // pDoc->SetMouseCapture(NULL,NULL);
                                TakeCapture(FALSE);
                                break;
                            }
                        }
                    }
                }
                hr = S_OK;
                break;
            }
        }
    }

    if (!hr)
        goto Cleanup;

    if (fInBrowseMode)
    {
        if (hr == S_FALSE)
        {
            CAnchorElement * pAnchorElement = GetContainingAnchor();

            if (pAnchorElement)
            {
                switch (pMessage->message)
                {

                // Need to handle 'Enter' for server-side image maps (IE5 bug #4091)                        
                case WM_CHAR:
                case WM_SYSCHAR:
                    if (pMessage->wParam == VK_RETURN && GetAAisMap())
                    {
                        // Pressing Enter is same as clicking with mouse
                        pMessage->SetNodeClk(GetFirstBranch());
                        hr = S_OK;
                    }
                    break ;
                case WM_LBUTTONDOWN:
                    // If it is not a image map then this message is really
                    // meant for the anchor element.
                    if (GetAAisMap())
                    {
                        hr = S_OK;
                         Doc()->SetMouseCapture(MOUSECAPTURE_METHOD(CImgElement, HandleCaptureMessageForImage, handlecapturemessageforimage),
                                                this);
                    }
                    else if (!HasCapture())
                    {
                        // NOTE (sujalp): We have to simulate as if the message
                        // was received by the anchor (pAnchorElement) directly and hence
                        // we pass pAnchorElement and not NULL , though it is coming via
                        // the child.
                        hr = THR (pAnchorElement->HandleMessage (pMessage)) ;
                    }
                    break;

                case WM_RBUTTONDOWN:

                    // See sujal's note, above
                    hr = THR(pAnchorElement->HandleMessage(pMessage));
                    break;

                case WM_SETCURSOR:

                    SetCursorStyle(pAnchorElement->GetHyperlinkCursor());

                    hr = pAnchorElement->GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl);
                    if (!hr && pchUrl)
                    {
                        TCHAR *pchFriendlyUrl;
                        BOOL fShowStatusText = TRUE;
                        CDoc * pDoc = Doc();

                        if (GetAAisMap())
                        {
                            Assert(pMessage->IsContentPointValid());
                            pchFriendlyUrl = GetFriendlyUrl(
                                                    pchUrl,
                                                    pDoc->GetPrimaryUrl(),
                                                    pDoc->_pOptionSettings->fShowFriendlyUrl,
                                                    TRUE,
                                                    pMessage->ptContent.x,
                                                    pMessage->ptContent.y);
                        }
                        else
                        {
                            pchFriendlyUrl = GetFriendlyUrl(pchUrl, pDoc->GetPrimaryUrl(),
                                                            pDoc->_pOptionSettings->fShowFriendlyUrl, TRUE);

                            // if previous element under mouse is not the same as current element under the mouse,
                            // set the status text for the anchor that is under (or IS) the curent element.
                            fShowStatusText = DifferentScope(pDoc->_pNodeLastMouseOver, this);
                        }

                        if (fShowStatusText)
                        {
                            pDoc->SetStatusText(pchFriendlyUrl, STL_ROLLSTATUS, GetMarkup());
                        }

                        MemFreeString(pchFriendlyUrl);
                        MemFreeString(pchUrl);
                    }

                    hr = S_OK;
                    break;

                default:
                     ;
                }
            }

            // Prepare for drag-drop
            switch (pMessage->message)
            {
                case WM_LBUTTONDOWN:
                case WM_RBUTTONDOWN:
                    _rcWobbleZone.left   = pMessage->pt.x - g_sizeDragMin.cx;
                    _rcWobbleZone.right  = pMessage->pt.x + g_sizeDragMin.cx + 1;
                    _rcWobbleZone.top    = pMessage->pt.y - g_sizeDragMin.cy;
                    _rcWobbleZone.bottom = pMessage->pt.y + g_sizeDragMin.cy + 1;

                    // Can click while mouse is inside wobble zone
                    _fCanClickImage = TRUE;
                    break;
            }
        }
    }


    // WM_CONTEXTMENU message should always be handled.
    if (pMessage->message == WM_CONTEXTMENU)
    {
        Assert(_pImage);
        hr = THR(_pImage->ShowImgContextMenu(pMessage));
    }

    // And process the message if it hasn't been already.
    if (hr == S_FALSE)
    {
        switch (pMessage->message)
        {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            if (fInBrowseMode)
            {
                // if it was not NULL it was handled before
                Doc()->SetMouseCapture(
                                       MOUSECAPTURE_METHOD(CImgElement, HandleCaptureMessageForImage, handlecapturemessageforimage),
                                       this);
                hr = S_OK;
            }
            break;

#ifndef NO_MENU
        case WM_MENUSELECT:
        case WM_INITMENUPOPUP:
            hr = S_FALSE;
            break;
#endif // NO_MENU

        case WM_SETCURSOR:
            if ( (!IsEditable(/*fCheckContainerOnly*/FALSE) && ! IsMasterParentEditable()) || 
                 (Doc()->IsPointInSelection(pMessage->pt) && Doc()->GetSelectionType() == SELECTION_TYPE_Text))
            {
                SetCursorStyle(IDC_ARROW);
            }
            else 
            {
                hr = super::HandleMessage(pMessage);
                if (hr == S_FALSE)
                {
                   SetCursorStyle(IDC_SIZEALL);
                }
            }
            hr = S_OK;
            break;
        }

        if (hr == S_FALSE)
        {
            hr = THR(super::HandleMessage(pMessage));
        }
    }

Cleanup:
    
    ReleaseInterface(pURLToDrag);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     HandleCaptureMessageForImage
//
//  Synopsis:   Tracks mouse while user is clicking on an IMG in an A
//
//  Arguments:  [pMessage]  -- message
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CImgElement::HandleCaptureMessageForImage (CMessage * pMessage)
{
    HRESULT     hr = S_OK;

    switch (pMessage->message)
    {
    case WM_LBUTTONUP:
        if (_fCanClickImage)
        {
            pMessage->SetNodeClk(GetFirstBranch());
        }
        // Fall thru

    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
        TakeCapture(FALSE);
        // Doc()->SetMouseCapture(NULL, NULL);
        if (pMessage->message == WM_RBUTTONUP)
            hr = S_FALSE;
        break;

    case WM_MOUSEMOVE:
    {
        // If the user moves the mouse outside the wobble zone,
        // show the no-entry , plus disallow a subsequent OnClick
        POINT ptCursor = { LOWORD(pMessage->lParam), HIWORD(pMessage->lParam) };
        CDoc *pDoc = Doc();

        if ( _fCanClickImage && !PtInRect(&_rcWobbleZone, ptCursor))
        {
            _fCanClickImage = FALSE;
        }

        // initiate drag-drop
        if (!_fCanClickImage && !pDoc->_fIsDragDropSrc)
        {
            Assert(!pDoc->_pDragDropSrcInfo);
#ifdef NEVER
            if (!pDoc->_pElementOMCapture)
#endif
            {
                DragElement(GetUpdatedLayout(), pMessage->dwKeyState, NULL, -1);
            }
        }
        // Intentional drop through to WM_SETCURSOR - WM_SETCURSOR is NOT sent
        // while the Capture is set
    }

    case WM_SETCURSOR:
        {
            LPCTSTR idc;
            CAnchorElement * pAnchorElement = GetContainingAnchor();
            CRect   rc;


            GetUpdatedLayout()->GetClientRect(&rc);

            if (pAnchorElement && PtInRect(&rc, pMessage->ptContent))
                idc = pAnchorElement->GetHyperlinkCursor();
            else
                idc = IDC_ARROW;

            SetCursorStyle(idc);
            hr = S_OK;
        }
        break;
    }

    if (hr == S_FALSE)
        hr = THR(super::HandleMessage(pMessage));

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleCaptureMessageForArea
//
//  Synopsis:   Tracks mouse while user is clicking on an IMG with an AREA
//
//  Arguments:  [pMessage]  -- message
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CImgElement::HandleCaptureMessageForArea(CMessage * pMessage)
{
    RRETURN1(HandleMessage(pMessage), S_FALSE);
}


//=------------------------------------------------------------------------=
//
// Function:    DocPtToImgPt
//
// Synopsis:    Converts the point from a position relative to the document
//              to being a position relative to the upper left corner of
//              the iamge.
//
// Arguments:   POINT *ppt - The point to be converted.
//
//=------------------------------------------------------------------------=
void
CImgElement::DocPtToImgPt(POINT *ppt)
{
// TODO: Call CDispNode::GlobalToContentPoint (brendand)
}

//+---------------------------------------------------------------------------
//
//  Member:     FindEnclosingAnchorScope
//
//  Synopsis:   Finds the enclosing <A HREF> tag
//
//  Returns:    NULL if no enclosing <A> or if enclosing <A> has no HREF
//              Otherwise, returns the enclosing <A> element
//
//----------------------------------------------------------------------------

CAnchorElement*
CImgElement::FindEnclosingAnchorScope()
{
    CTreeNode * pNode = GetFirstBranch();

    if (pNode)
    {
        for (pNode = pNode->Parent(); pNode; pNode=pNode->Parent())
        {
            if (pNode->Tag() == ETAG_A)
            {
                if (NULL != (LPTSTR) DYNCAST(CAnchorElement, pNode->Element())->GetAAhref())
                {
                    return DYNCAST(CAnchorElement, pNode->Element());
                }
                else
                {
                    return NULL;
                }
            }
            if (pNode->ShouldHaveLayout())
                break;
        }
    }

    return NULL;
}

HRESULT
CImgElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT             hr          = S_OK;
    CUnitValue          uvBorder    = GetAAborder();
    BYTE                i;
    CAnchorElement *    pAnchor     = FindEnclosingAnchorScope();
    LPCTSTR             szUseMap    = NULL;

    _fBelowAnchor = !!pAnchor;

    if (uvBorder.IsNull())
    {
        // check if the image is inside an anchor
        // or useMap is set and begin with #

        if (    _fBelowAnchor
            ||  (szUseMap = GetAAuseMap()) != NULL && _tcschr(szUseMap, _T('#')))
        {
            uvBorder.SetValue( 2, CUnitValue::UNIT_PIXELS );
        }
    }

    // Set the anchor border
    if (!uvBorder.IsNull())
    {
        COLORREF crColor;
        DWORD dwRawValue = uvBorder.GetRawValue();

        if (_fBelowAnchor)
            crColor = GetAnchorColor(pAnchor);
        else
        {
            if (szUseMap && _tcschr(szUseMap, _T('#')))
            {
                Assert(pCFI->_pNodeContext && SameScope(this, pCFI->_pNodeContext));
                CTreeNode *  pNode = pCFI->_pNodeContext->Parent();
                CColorValue  colorValue;

                while(pNode && pNode->Tag() != ETAG_BODY)
                    pNode = pNode->Parent();
                
                if (pNode)
                {
                    colorValue = DYNCAST(CBodyElement, pNode->Element())->GetAAlink();
                }

                crColor = colorValue.IsDefined() ? colorValue.GetColorRef()
                                               : Doc()->_pOptionSettings->crAnchor();
            }
            else
                crColor = 0x00000000;
        }

        pCFI->PrepareFancyFormat();
        CColorValue ccv; ccv.SetValue(crColor, FALSE);
        CUnitValue cuv; cuv.SetRawValue(dwRawValue);
        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff()._bd.SetBorderColor(i, ccv);
            pCFI->_ff()._bd.SetBorderWidth(i, cuv);
            pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSingle);
        }
        pCFI->UnprepareForDebug();
    }

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr || !_pImage)
        goto Cleanup;

    _pImage->SetImgAnim(pCFI->_pcf->IsDisplayNone()
                        || pCFI->_pcf->IsVisibilityHidden());

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CBlockElement::Save
//
//  Synopsis:   Save the tag to the specified stream.
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    if (fEnd)
        return S_OK;        // No end IMG tag

    CElement * pelAnchorClose = NULL;
    HRESULT hr;

    if (pStmWrBuff->TestFlag(WBF_FOR_RTF_CONV))
    {
        //
        // RichEdit2.0 crashes when it gets rtf with nested field
        // tags (easily generated by the rtf to html converter for
        // <a><img></a> (images in anchors).  To work around this,
        // we close any anchors this image may be in before writing
        // the image tag, and reopen them immediately after.
        //
        pelAnchorClose = GetFirstBranch()->SearchBranchToFlowLayoutForTag(ETAG_A)->SafeElement();
    }

    if (pelAnchorClose)
    {
        hr = pelAnchorClose->WriteTag(pStmWrBuff, TRUE, TRUE);
        if (hr)
            goto Cleanup;
    }

    hr = super::Save(pStmWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (pelAnchorClose)
    {
        hr = pelAnchorClose->WriteTag(pStmWrBuff, FALSE, TRUE);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     GetAnchorColor
//
//  Synopsis:   Link color for anchor is taken from body
//
//  Returns:    COLORREF
//
//----------------------------------------------------------------------------

COLORREF
CImgElement::GetAnchorColor(CAnchorElement * pAnchorElement)
{
    Assert(pAnchorElement->Tag() == ETAG_A);
    return(pAnchorElement->GetLinkColor());
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_CImgElement_useMap:
        // Force a revalidation of the map
        EnsureMap();
        break;
    case DISPID_CImgElement_src:
        if (_pImage)
        {
            hr = _pImage->SetImgSrc(IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
        }
        break;
    case DISPID_CImgElement_lowsrc:
        if (_pImage)
        {
            LPCTSTR szUrl = GetAAsrc();

            if (!szUrl)
            {
                Assert(_pImage);
                hr = _pImage->FetchAndSetImgCtx(GetAAlowsrc(), IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
            }

        }
        break;

#ifndef NO_AVI
    case DISPID_CImgElement_dynsrc:
        if (_pImage)
        {
            hr = _pImage->SetImgDynsrc();
        }
        break;
#endif
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}


#ifndef NO_DATABINDING
class CDBindMethodsImg : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsImg() : super(VT_BSTR, DBIND_ONEWAY) {}
    ~CDBindMethodsImg()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsImg DBindMethodsImg;

const CDBindMethods *
CImgElement::GetDBindMethods()
{
    return &DBindMethodsImg;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound checkbox.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a boolean.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsImg::BoundValueToElement(CElement *pElem,
                                      LONG,
                                      BOOL,
                                      LPVOID pvData) const
{
    // Implement in quickest, but most inefficient way possible:
    RRETURN(DYNCAST(CImgElement, pElem)->put_src(*(BSTR *)pvData));
}
#endif // ndef NO_DATABINDING


CAreaElement *
CImgElement::GetCurrentArea()
{
    CAreaElement * pArea;

    if (HasCurrency())
    {
        EnsureMap();
        if (    _pMap
            && S_OK == _pMap->GetAreaContaining(Doc()->_lSubCurrent, &pArea))
        {
            return pArea;
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::QueryStatus, public
//
//  Synopsis:   Implements QueryStatus for CImgElement
//
//  Notes:      This override of CImgBase::QueryStatus allows special
//              handling of hyperlink context menu entries for images
//              with active areas in client side maps
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    int idm;

    TraceTag((tagMsoCommandTarget, "CImgElement::QueryStatus"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *        pCmd    = &rgCmds[0];
    HRESULT         hr      = S_OK;
    CAreaElement *  pArea   = GetCurrentArea();

    Assert(!pCmd->cmdf);

    // Give first chance to <AREA>
    if (pArea)
    {
        hr = THR_NOTRACE(pArea->QueryStatusHelper(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
        if (hr || pCmd->cmdf)
            goto Cleanup;
    }

    idm = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_PRINTTARGET:
    case IDM_SAVETARGET:

        // Plug a ratings security hole.
        if ((idm == IDM_PRINTTARGET || idm == IDM_SAVETARGET) &&
            S_OK == AreRatingsEnabled())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }
        break;
    case IDM_ADDFAVORITES:
    case IDM_COPYSHORTCUT:
        {
            CAnchorElement * pAnchorElement = GetContainingAnchor();

            if (pAnchorElement && pAnchorElement->GetAAhref())
            {
                pCmd->cmdf = MSOCMDSTATE_UP;
            }
        }
        break;

    case IDM_IMAGE:
        // When a single image is selected, allow to bring up an insert image dialog
        pCmd->cmdf = MSOCMDSTATE_UP;
    }

    if (!pCmd->cmdf)
    {
        Assert(_pImage);
        hr = _pImage->QueryStatus(
                    pguidCmdGroup,
                    1,
                    pCmd,
                    pcmdtext);
        if (!pCmd->cmdf)
        {
            hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));
        }
    }

Cleanup:
    SRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::Exec, public
//
//  Synopsis:   Executes a command on the CImgElement
//
//  Notes:      This override of CImgBase::Exec allows special
//              handling of hyperlink context menu entries for images
//              with active areas in client side maps
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CImgElement::Exec"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int                 idm         = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT             hr          = MSOCMDERR_E_NOTSUPPORTED;
    POINT               pt;
    DWORD               dwPt;
    CAreaElement *      pArea       = GetCurrentArea();
    CAnchorElement *    pAnchorElement = GetContainingAnchor();

    // Give first chance to <AREA>
    if (pArea)
    {
        hr = THR_NOTRACE(pArea->ExecHelper(
                    pguidCmdGroup,
                    nCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut));

        if (hr != MSOCMDERR_E_NOTSUPPORTED)
            goto Cleanup;
    }

    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_SAVETARGET:
    case IDM_PRINTTARGET:

        if (pAnchorElement && GetAAisMap() &&
            (idm == IDM_FOLLOWLINKC || idm == IDM_FOLLOWLINKN))
        {
            if (!pvarargIn ||  V_VT(pvarargIn) != VT_I4)
            {
                AssertSz(0, "Missing argument ptMouse for click on server-side image map");
                break;
            }
            dwPt = (DWORD)V_I4(pvarargIn);
            pt.x = MAKEPOINTS(dwPt).x;
            pt.y = MAKEPOINTS(dwPt).y;
            ScreenToClient(Doc()->_pInPlace->_hwnd, &pt);
            hr = THR(ClickOnServerMap(pt, idm == IDM_FOLLOWLINKN));
        }
        break;

    case IDM_COPYSHORTCUT:
        if (pAnchorElement && pAnchorElement->GetAAhref())
            hr = THR(pAnchorElement->CopyLinkToClipboard(GetAAalt()));
        break;

    case IDM_ADDFAVORITES:

        TCHAR   cBuf[pdlUrlLen];
        TCHAR * pszURL = cBuf;
        TCHAR * pszTitle;

        if (pAnchorElement)
        {
            CDoc * pDoc = Doc();

            hr = THR(CMarkup::ExpandUrl(NULL, 
                    pAnchorElement->GetAAhref(),
                    ARRAY_SIZE(cBuf),
                    pszURL,
                    pAnchorElement));

            pszTitle = (LPTSTR) pAnchorElement->GetAAtitle();
            if (!pszTitle)
                pszTitle = (LPTSTR) GetAAalt();
            if (!pszTitle)
                pszTitle = (LPTSTR) GetAAtitle();

            if (!hr && pszURL)
                hr = pDoc->AddToFavorites(pszURL, pszTitle);
        }
        break;
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED && _pImage)
    {
        hr = THR_NOTRACE(_pImage->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
        hr = THR_NOTRACE(super::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));

Cleanup:
    SRETURN_NOTRACE(hr);
}

HRESULT
CImgElement::ClickOnServerMap(POINT pt, BOOL fOpenInNewWindow)
{
    HRESULT hr      = S_OK;
    TCHAR * szTemp  = NULL;
    CAnchorElement * pAnchorElement = GetContainingAnchor();

// TODO: Call CDispNode::GlobalToContentPoint (brendand)
// (krisma) Or should we assume that the point passed in has
// already been transformed? I vote for the latter.
    hr = THR(Format(FMT_OUT_ALLOC, &szTemp, 0,
        _T("<0s>?<1d>,<2d>"),
        (LPTSTR) pAnchorElement->GetAAhref(),
        (long)pt.x,
        (long)pt.y));
    if (hr)
        goto Cleanup;

    hr = THR(Doc()->FollowHyperlink(szTemp,
                                    (LPTSTR) pAnchorElement->GetAAtarget(),
                                    pAnchorElement,
                                    NULL,
                                    FALSE,
                                    NULL,
                                    fOpenInNewWindow,
                                    NULL,
                                    NULL,
                                    0,
                                    ERROR_SUCCESS,
                                    FALSE,
                                    NULL,
                                    FALSE,
                                    CDoc::FHL_HYPERLINKCLICK|CDoc::FHL_SETDOCREFERER));

    delete szTemp; // must delete temp string, error or no error
Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;
    RRETURN(hr);
}


HRESULT
CImgElement::ClickAction(CMessage * pMessage)
{
    HRESULT             hr              = S_OK;
    CAnchorElement *    pAnchorElement  = GetContainingAnchor();
    BOOL                fOpenInNewWindow;
    POINT               ptClick;

    // If we're a clientside image map, pass it to the area.
    EnsureMap();
    if (_pMap)
    {
        CAreaElement *  pArea;

        hr = THR(_pMap->GetAreaContaining(pMessage ? pMessage->lSubDivision : 0, &pArea));
        if (hr)
            goto Cleanup;

        hr = THR(pArea->ClickAction(pMessage));
        goto Cleanup;
    }

    // Don't handle clicks if not surrouneded by an anchor
    if (!pAnchorElement)
        goto Cleanup;

    // Pass click to anchor if not server-side image map

    if (!GetAAisMap())
    {
        // if we're an image w/o a map in an anchor
        // send the click to the anchor
        hr = THR(pAnchorElement->ClickAction(pMessage));

        goto Cleanup;
    }

    // We come here only when the click is on a server-side image map
    if (pMessage && (pMessage->message == WM_LBUTTONUP || pMessage->message == WM_MOUSEWHEEL))
    {
        // We came here because of mouse click
        Assert(pMessage->IsContentPointValid());
        fOpenInNewWindow = (pMessage->message != WM_MOUSEWHEEL) && (pMessage->dwKeyState & MK_SHIFT);
        ptClick = pMessage->ptContent;
    }
    else
    {
        CRect   rc;

        // We came here because of 'Enter' keystroke or the 'click' method call
        fOpenInNewWindow = FALSE;

        ptClick = g_Zero.pt;
    }

    hr = THR(ClickOnServerMap(ptClick, fOpenInNewWindow));

Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

const CImageElementFactory::CLASSDESC CImageElementFactory::s_classdesc =
{
    {
        &CLSID_HTMLImageElementFactory,      // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLImageElementFactory,       // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnIHTMLImageElementFactory,  // _apfnTearOff
};



HRESULT STDMETHODCALLTYPE
CImageElementFactory::create(VARIANT varWidth, VARIANT varHeight, IHTMLImgElement**ppnewElem )
{
    HRESULT hr;
    CElement    *pElement = NULL;
    CImgElement *pImgElem;
    CVariant varI4Width;
    CVariant varI4Height;

    // We must return into a ptr else there's no-one holding onto a ref!
    if ( !ppnewElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppnewElem = NULL;

    // actualy ( [ long width, long height ] )
    // Create an Image element parented to the root site

    // This is some temproary unfinished code just to test the call
    hr = THR(_pMarkup->CreateElement(ETAG_IMG, &pElement));
    if ( hr )
        goto Cleanup;

    pImgElem = DYNCAST(CImgElement, pElement);

    // Set the flag that indicates we're parented invisibly to the resize
    // this stops unpleasantness with ResizeElement.
    // TODO: Is this necessary any longer (it's a RequestResize carry-over) (brendand)
    pImgElem->_pImage->_fCreatedWithNew = TRUE;

    hr = THR(pImgElem->QueryInterface ( IID_IHTMLImgElement, (void **)ppnewElem ));

    // Set the width & height if supplied
    if (varWidth.vt != VT_EMPTY && varWidth.vt != VT_ERROR)
        pImgElem->_pImage->_fSizeInCtor = TRUE;

    hr = THR(varI4Width.CoerceVariantArg(&varWidth, VT_I4) );
    if ( hr == S_OK )
    {
        hr = pImgElem->putWidth(V_I4(&varI4Width));
    }
    if ( !OK(hr) )
        goto Cleanup;

    hr = THR(varI4Height.CoerceVariantArg(&varHeight, VT_I4) );
    if ( hr == S_OK )
    {
        hr = pImgElem->putHeight(V_I4(&varI4Height));
    }
    if ( !OK(hr) )
        goto Cleanup;

Cleanup:
    if (OK(hr))
    {
        hr = S_OK; // not to propagate possible S_FALSE
    }
    else
    {
        ReleaseInterface(*(IUnknown**)ppnewElem);
    }

    CElement::ClearPtr(&pElement);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member: get_mimeType
//
//----------------------------------------------------------------------------
extern BSTR GetFileTypeInfo(TCHAR * pszFileName);

STDMETHODIMP
CImgElement::get_mimeType(BSTR *pMimeType)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if ( !pMimeType )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pMimeType = NULL;

    hr = _pImage->GetFile(&pchCachedFile);

    if (!hr && pchCachedFile)
    {
        *pMimeType = GetFileTypeInfo(pchCachedFile);
    }

    MemFreeString(pchCachedFile);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileSize
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_fileSize(BSTR *pFileSize)
{
    HRESULT hr = S_OK;
    TCHAR   szBuf[64];
    TCHAR * pchCachedFile = NULL;

    if (pFileSize == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileSize = NULL;

    Assert(_pImage);
    hr = _pImage->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            Format(0, szBuf, ARRAY_SIZE(szBuf), _T("<0d>"), (long)wfd.nFileSizeLow);
            *pFileSize = SysAllocString(szBuf);
        }
    }
    else
    {
        *pFileSize = SysAllocString(_T("-1"));
        hr = S_OK;
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_fileCreatedDate
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CImgElement::get_fileCreatedDate(BSTR * pFileCreatedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileCreatedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileCreatedDate = NULL;

    Assert(_pImage);
    hr = _pImage->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftCreationTime, pFileCreatedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileModifiedDate
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_fileModifiedDate(BSTR * pFileModifiedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileModifiedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileModifiedDate = NULL;

    Assert(_pImage);
    hr = _pImage->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
             // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftLastWriteTime, pFileModifiedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

// TODO (lmollico): get_fileUpdatedDate won't work if src=file://image
//+---------------------------------------------------------------------------
//
// Member: get_fileUpdatedDate
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_fileUpdatedDate(BSTR * pFileUpdatedDate)
{
    HRESULT hr     = S_OK;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pszUrl = cBuf;

    if (pFileUpdatedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileUpdatedDate = NULL;

    hr = THR(CMarkup::ExpandUrl(NULL, GetAAsrc(), ARRAY_SIZE(cBuf), pszUrl, this));

    if (hr)
        goto Cleanup;

    if (pszUrl)
    {
        TCHAR                       strBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

        INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) strBuffer;
        DWORD                       cInfo = MAX_CACHE_ENTRY_INFO_SIZE;

        if (RetrieveUrlCacheEntryFile(pszUrl, pInfo, &cInfo, 0))
        {
            // We always return the local time in a fixed format mm/dd/yyyy to 
            // make it possible to parse. FALSE means we do not want the time.

            hr = THR(ConvertDateTimeToString(pInfo->LastModifiedTime, pFileUpdatedDate, FALSE));

            DoUnlockUrlCacheEntryFile(pszUrl, 0);
        }

    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_href
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_href(BSTR *pHref)
{
    HRESULT hr = S_OK;
    LPCTSTR pchUrl = NULL;

    if (pHref == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pHref = NULL;

#ifndef NO_AVI
    if (_pImage && _pImage->_pBitsCtx)
        pchUrl = _pImage->_pBitsCtx->GetUrl();
    else
#endif // ndef NO_AVI
        if (_pImage && _pImage->_pImgCtx)
        pchUrl = _pImage->_pImgCtx->GetUrl();

    if (pchUrl)
        *pHref = SysAllocString(pchUrl);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_protocol
//
//----------------------------------------------------------------------------
extern TCHAR * ProtocolFriendlyName(TCHAR * szUrl);

STDMETHODIMP
CImgElement::get_protocol(BSTR * pProtocol)
{
    HRESULT hr      = S_OK;
    LPCTSTR pchUrl  = NULL;
    TCHAR * pResult;

    if (pProtocol == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pProtocol = NULL;

#ifndef NO_AVI
    if (_pImage && _pImage->_pBitsCtx)
        pchUrl = _pImage->_pBitsCtx->GetUrl();
    else
#endif // ndef NO_AVI
    if (_pImage && _pImage->_pImgCtx)
        pchUrl = _pImage->_pImgCtx->GetUrl();

    if (pchUrl)
    {
        pResult = ProtocolFriendlyName((TCHAR *)pchUrl);
        if (pResult)
        {
            int z = (_tcsncmp(pResult, 4, _T("URL:"), -1) == 0) ? (4) : (0);
            * pProtocol = SysAllocString(pResult + z);
            SysFreeString(pResult);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

}

//+----------------------------------------------------------------------------
//
// Member: get_nameProp
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_nameProp(BSTR * pName)
{
    *pName = NULL;

    TCHAR   cBuf[pdlUrlLen];
    TCHAR   * pszUrl  = cBuf;
    TCHAR   * pszName = NULL;

    HRESULT   hr      = THR(CMarkup::ExpandUrl(NULL, GetAAsrc(), ARRAY_SIZE(cBuf), pszUrl, this));
    if (!hr)
    {
        pszName = _tcsrchr(pszUrl, _T('/'));
        if (!pszName)
            pszName = pszUrl;
        else
            pszName ++;

        * pName = SysAllocString(pszName);
    }
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Method:     CImgElem::GetSubdivisionCount
//
//  Synopsis:   returns the count of subdivisions
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::GetSubDivisionCount(long *pc)
{
    HRESULT hr = S_OK;

    if (IsEditable(TRUE) || !EnsureAndGetMap())
    {
        hr = THR(super::GetSubDivisionCount(pc));
        goto Cleanup;
    }

    
    *pc = _pMap->GetAreaCount();

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Method:     CImgElem::GetSubdivisionTabs
//
//  Synopsis:   returns the subdivisions tabindices
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::GetSubDivisionTabs(long *pTabs, long c)
{
    HRESULT         hr = S_OK;

    if (!c)
        goto Cleanup;

    EnsureMap();
    if (!_pMap)
        goto Cleanup;

    hr = THR(_pMap->GetAreaTabs(pTabs, c));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Method:     CImgElem::SubDivisionFromPt
//
//  Synopsis:   returns the subdivisions tabindices
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::SubDivisionFromPt(POINT pt, long *plSub)
{
    RECT            rcView;
    HRESULT         hr = S_OK;
    CLayout *       pLayout;

    Assert(GetFirstBranch());

    *plSub = -1;

    EnsureMap();
    if (!_pMap)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pLayout = GetUpdatedLayout();
    pLayout->GetClientRect(&rcView);
    if (PtInRect(&rcView, pt))
    {
        hr = THR(_pMap->GetAreaContaining(pt, plSub));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CAreaElement *  pArea = NULL;
    HRESULT         hr = S_FALSE;
    const CParaFormat  *  pPF = GetFirstBranch()->GetParaFormat();
    BOOL            fRTL = pPF->HasRTL(FALSE);
    CLayout *       pLayout = GetUpdatedLayout();
    CSize           size = g_Zero.size;
    if(fRTL)
    {
        // we are only interested in adjusting the x positioning
        // for RTL direction.
        CRect rcClient;
        pLayout->GetClientRect(&rcClient);
        size.cx = rcClient.Width();
    }

    *ppShape = NULL;

    EnsureMap();

    if (!_pMap)
    {
        hr = THR(super::GetFocusShape(lSubDivision, pdci, ppShape));
        goto Cleanup;
    }

    hr = THR(_pMap->GetAreaContaining(lSubDivision, &pArea));
    if (hr)
        goto Cleanup;

    switch(pArea->_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        {
            CRectShape * pShape = new CRectShape;

            if (!pShape)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pShape->_rect = pArea->_coords.Rect;
            if(fRTL)
            {
                pShape->OffsetShape(-size);
            }

            *ppShape = pShape;
            break;
        }
    case SHAPE_TYPE_CIRCLE:
        {
            CCircleShape * pShape = new CCircleShape;

            if (!pShape)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pShape->Set(pArea->_coords.Circle.lx,
                        pArea->_coords.Circle.ly,
                        pArea->_coords.Circle.lradius);
            if(fRTL)
            {
                pShape->OffsetShape(-size);
            }
            *ppShape = pShape;
            break;
        }
    case SHAPE_TYPE_POLY:
        {
            CPolyShape * pShape;

            if (pArea->_ptList.Size() < 2)
            {
                hr = S_FALSE;
                goto Cleanup;
            }

            pShape = new CPolyShape;
            if (!pShape)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pShape->_aryPoint.Copy(pArea->_ptList, FALSE);
            if(fRTL)
            {
                pShape->OffsetShape(-size);
            }
            *ppShape = pShape;
            break;
        }
    default:
        Assert(FALSE && "Invalid Shape");
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Function:   DoSubDivisionEvents
//
//  Synopsis:   Fire the specified event on the given subdivision.
//
//  Arguments:  [dispidEvent]   -- dispid of the event to fire.
//              [dispidProp]    -- dispid of prop containing event func.
//              [pvb]           -- Boolean return value
//              [pbTypes]       -- Pointer to array giving the types of parms
//              [...]           -- Parameters
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::DoSubDivisionEvents(
    long        lSubDivision,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    BOOL      * pfRet)
{
    CAreaElement *  pArea;

    if (lSubDivision < 0)
        return S_OK;

    EnsureMap();
    if (   _pMap 
        && OK(_pMap->GetAreaContaining(lSubDivision, &pArea))
        && Doc() == pArea->Doc())
    {
        Assert(pArea->GetFirstBranch());
        pArea->BubbleEventHelper(
            pArea->GetFirstBranch(),
            0,
            dispidEvent,
            dispidProp,
            FALSE,
            pfRet);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::ShowTooltip
//
//  Synopsis:   Show the tooltip for this element.
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT         hr = S_OK;
    CAreaElement *  pArea = NULL;
    CStr            strTitle;
    BOOL            fRTL = FALSE;
    CDoc *          pDoc = Doc();

    TraceTag((tagTooltip, "IMG <%d:%d>", pt.x, pt.y));

    if (pDoc->_pInPlace == NULL)
        goto Cleanup;

    // If the mouse is on an <AREA>, show the area's tooltip
    EnsureMap();
    if (_pMap && pmsg->lSubDivision >= 0)
    {
        if (S_OK == THR(_pMap->GetAreaContaining(pmsg->lSubDivision, &pArea)))
        {
            // We only show title tooltip for area
            //

            IGNORE_HR(pArea->GetUrlTitle(&strTitle));
            if (strTitle.Length() > 0)
            {
                CRect   rc, rcImgClient;

                pArea->GetBoundingRect(&rc);

                Assert(_pImage);
                _pImage->Layout()->GetClientRect(&rcImgClient, COORDSYS_GLOBAL);
                rc.OffsetRect(rcImgClient.TopLeft().AsSize());

                if(IsRectEmpty(&rc))
                {
                    rc.left = pt.x - 10;
                    rc.right = pt.x + 10;
                    rc.top = pt.y - 10;
                    rc.bottom = pt.y + 10;
                }

                // Complex Text - determine if element is right to left for tooltip style setting
                fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;

                // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
                CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);
                
                if (!pDoc->_pDocPopup)
                {
                    FormsShowTooltip(
                        strTitle,
                        pDoc->_pInPlace->_hwnd,
                        *pmsg,
                        &rc,
                        (DWORD_PTR) GetMarkup(),
                        (DWORD_PTR) this,
                        fRTL);
                }
            }
            goto Cleanup;
        }
    }

    // check to see if tooltip should display the title property
    //
    hr = THR(super::ShowTooltip(pmsg, pt));
    if (hr == S_OK)
        goto Cleanup;

    Assert(_pImage);
    hr = _pImage->ShowTooltip(pmsg, pt);

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

HRESULT CImgElement::GetHeight(long *pl)
{
    VARIANT v;
    HRESULT hr;

    hr = THR(s_propdescCImgElementheight.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CImgElement::putHeight(long l)
{
    VARIANT v;

    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCImgElementheight.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_AUTOMATION | HANDLEPROP_DONTVALIDATE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}

HRESULT CImgElement::GetWidth(long *pl)
{
    VARIANT v;
    HRESULT hr;

    hr = THR(s_propdescCImgElementwidth.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CImgElement::putWidth(long l)
{
    VARIANT v;

    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCImgElementwidth.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_DONTVALIDATE | HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}

STDMETHODIMP CImgElement::put_height(long l)
{
    RRETURN(SetErrorInfoPSet(putHeight(l), DISPID_CImgElement_width));
}

STDMETHODIMP CImgElement::get_height(long *p)
{
    Assert(_pImage);
    RRETURN (_pImage->get_height(p));
}

STDMETHODIMP CImgElement::put_width(long l)
{
    RRETURN(SetErrorInfoPSet(putWidth(l), DISPID_CImgElement_width));
}

STDMETHODIMP CImgElement::get_width(long *p)
{
    Assert(_pImage);
    RRETURN (_pImage->get_width(p));
}

STDMETHODIMP
CImgElement::get_src(BSTR * pstrFullSrc)
{
    HRESULT hr;
    Assert(_pImage);
    hr = _pImage->get_src(pstrFullSrc);
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------
//
//  member : put_src
//
//  sysnopsis : impementation of the interface src property set
//          since this is a URL property we want the crlf striped out
//
//-------------------------------------------------------------------

STDMETHODIMP
CImgElement::put_src(BSTR bstrSrc)
{
    RRETURN(SetErrorInfo(s_propdescCImgElementsrc.b.SetUrlProperty(bstrSrc,
                        this,
                        (CVoid *)(void *)(GetAttrArray()))));
}


//+----------------------------------------------------------------------------
//
// Methods:     get/set_hspace
//
// Synopsis:    hspace for aligned images is 3 pixels by default, so we need
//              a method to identify if a default value is specified.
//
//-----------------------------------------------------------------------------

STDMETHODIMP CImgElement::put_hspace(long v)
{
    return s_propdescCImgElementhspace.b.SetNumberProperty(v, this, CVOID_CAST(GetAttrArray()));
}

STDMETHODIMP CImgElement::get_hspace(long * p)
{
    HRESULT hr = s_propdescCImgElementhspace.b.GetNumberProperty(p, this, CVOID_CAST(GetAttrArray()));

    if(!hr)
        *p = *p == -1 ? 0 : *p;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : [get_/put_] onload
//
//  synopsis : store in this element's propdesc
//
//+----------------------------------------------------------------------------

HRESULT
CImgElement:: put_onload(VARIANT v)
{
    HRESULT hr = THR(s_propdescCImgElementonload .a.HandleCodeProperty(
                HANDLEPROP_SET | HANDLEPROP_AUTOMATION |
                (PROPTYPE_VARIANT << 16),
                &v,
                this,
                CVOID_CAST(GetAttrArray())));

    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CImgElement:: get_onload(VARIANT *p)
{
    HRESULT hr = THR(s_propdescCImgElementonload.a.HandleCodeProperty(
                    HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                    p,
                    this,
                    CVOID_CAST(GetAttrArray())));

    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CImgElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr=THR(s_enumdeschtmlReadyState.StringFromEnum(_pImage->_readyStateFired, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CImgElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CImgElement::get_readyStateValue(long *plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRetValue = _pImage->_readyStateFired;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


void
CImgElement::Passivate()
{
    if (_pImage)
    {
        _pImage->Passivate();
        delete _pImage;
        _pImage = NULL;
    }
    super::Passivate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\hisvenc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       hisvenc.cxx
//
//  Contents:   History value encoder
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_HISVENC_HXX_
#define X_HISVENC_HXX_
#include "hisvenc.hxx"
#endif

MtDefine(CHistValEncReader, Utilities, "CHistValEncReader")
MtDefine(CHistValEncWriter, Utilities, "CHistValEncWriter")
MtDefine(CHisValConverter,  Utilities, "CHisValConverter")
MtDefine(CHistValEncReaderPchBuf, CHistValEncReader, "CHistValEncReader::_pHistValBuffer")

HRESULT
CHistValEncWriter::UnicodeToWB(TCHAR * pchIn)
{
    HRESULT hr=S_OK;
    int     cch;

    Assert(pchIn);

    // So MultiByteFromWideChar knows what to convert
    _pchBuffer = (TCHAR *)pchIn;
    _cchBuffer = _cchBufferMax = _tcslen(pchIn) + 1;

    hr = THR(MultiByteFromWideChar(FALSE, &cch));

    // Do this to prevent the destructor from trying to
    // free _pchBuffer
     _pchBuffer = NULL;
     _cchBuffer = _cchBufferMax = 0;

    return hr; 
}

HRESULT
CHistValEncReader::WBToUnicode(unsigned char * pchIn)
{
    HRESULT hr=S_OK;
    int     cch;

    Assert(pchIn);

    // So MultiByteFromWideChar knows what to convert
    _pbBuffer = _pbBufferPtr = pchIn;
    _cbBuffer = _cbBufferMax = lstrlenA((const char *)pchIn) + 1;

    hr = THR(WideCharFromMultiByte(FALSE, &cch));

    _pbBuffer = NULL;   // no need to free the writer's memory

    return hr; 
}

HRESULT
CHistValEncReader::MakeRoomForChars(int cch)
{
    if (!_pchBuffer)
    {
        _cchBuffer = _cbBufferMax;      // make the room big enough

        _pchBuffer = (TCHAR *)MemAlloc( Mt(CHistValEncReaderPchBuf),
                                        _cchBuffer * sizeof(TCHAR));
        if (!_pchBuffer)
            RRETURN( E_OUTOFMEMORY );

        _pchEnd = _pchBuffer;

        *_pchEnd = _T('\0');
    }
    else
    {
        AssertSz(FALSE, "CHistValEncReader::MakeRoomForChars : room should be enough");
    }

    CEncodeReader::MakeRoomForChars(cch);
    RRETURN(S_OK);
}

HRESULT
CHisValConverter::Convert(CStr &cstr, CODEPAGE cpFrom, CODEPAGE cpTo)
{
    HRESULT hr = S_OK;
    CHistValEncReader   hvReader(cpTo);
    CHistValEncWriter   hvWriter(cpFrom);

    hr = hvWriter.UnicodeToWB(cstr);

    if (FAILED(hr))
        goto Cleanup;

    hvReader.WBToUnicode((unsigned char *)hvWriter._pbBuffer);

    if (FAILED(hr))
        goto Cleanup;

    cstr.Set(hvReader._pchBuffer);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\imghlper.cxx ===
//+---------------------------------------------------------------------
//
//  File:       imghlper.cxx
//
//  Contents:   Img helper class, etc..
//
//  Classes:    CImgHelper, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHFOLDER_H_
#define X_SHFOLDER_H_
#include "shfolder.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h" // for s_enumdeschtmlReadyState
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_IMGART_HXX_
#define X_IMGART_HXX_
#include "imgart.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h" // for cf_HTML
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

extern BOOL g_fScreenReader;
extern BYTE g_bJGJitState;

extern void SetCachedImageSize(LPCTSTR pchURL, SIZE size);
extern BOOL GetCachedImageSize(LPCTSTR pchURL, SIZE *psize);
#ifndef NO_ART
extern NEWIMGTASKFN NewImgTaskArt;
#endif

extern HRESULT
CreateImgDataObject(CDoc * pDoc, CImgCtx * pImgCtx, CBitsCtx * pBitsCtx,
                    CElement * pElement, CGenDataObject ** ppImgDO);

DWORD g_dwImgIdInc = 0x80000000;

DeclareTag(tagImgBase, "CImgHelper", "Trace events");
DeclareTag(tagNoImgAnim, "CImgHelper", "No Image animation");
DeclareTag(tagImgAnimDirect, "CImgHelper", "Draw img anim frames directly");
ExternTag(tagMsoCommandTarget);

MtDefine(CImgHelperGetUrl, Utilities, "CImgHelper::GetUrl")

#ifndef NO_AVI
ATOM GetWndClassAtom(UINT uIndex);
LRESULT CALLBACK ActiveMovieWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif // ndef NO_AVI

ExternTag(tagLayoutTasks);


static void CopyDibToClipboard(CImgCtx * pImgCtx, CGenDataObject * pDO)
{
    HRESULT hr;
    HGLOBAL hgDib = NULL;
    IStream *pStm = NULL;

    Assert(pImgCtx && pDO);

    hr = CreateStreamOnHGlobal(NULL, FALSE, &pStm);
    if (hr)
        goto Cleanup;
    hr = pImgCtx->SaveAsBmp(pStm, FALSE);

    GetHGlobalFromStream(pStm, &hgDib);

    if (!hr && hgDib)
    {
        pDO->AppendFormatData(CF_DIB, hgDib);
        hgDib = NULL;
    }

Cleanup:
    if (hgDib)
        GlobalFree(hgDib);
    ReleaseInterface(pStm);
}

static void CopyHtmlToClipboard(CElement * pElement, CGenDataObject * pDO)
{
    HRESULT hr;
    CDoc *  pDoc;
    HGLOBAL hgHTML = NULL;
    IStream *pStm = NULL;

    Assert(pElement && pDO);
    pDoc = pElement->Doc();

    CMarkupPointer  mpStart(pDoc), mpEnd(pDoc);

    hr = CreateStreamOnHGlobal(NULL, FALSE, &pStm);
    if (hr)
        goto Cleanup;

    hr = mpStart.MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin);
    if (hr)
        goto Cleanup;
    hr = mpEnd.MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd);
    if (hr)
        goto Cleanup;

    {
        CStreamWriteBuff    StreamWriteBuff(pStm, CP_UTF_8);

        hr = THR( StreamWriteBuff.Init() );
        if( hr )
            goto Cleanup;

        CRangeSaver         rs(
                                &mpStart,
                                &mpEnd,
                                RSF_CFHTML,
                                &StreamWriteBuff,
                                mpStart.Markup());

        StreamWriteBuff.SetFlags(WBF_NO_NAMED_ENTITIES);
        hr = THR(rs.Save());
        if (hr)
            goto Cleanup;
        StreamWriteBuff.Terminate();    // appends a null character
    }

    GetHGlobalFromStream(pStm, &hgHTML);

    if (hgHTML)
    {
        pDO->AppendFormatData(cf_HTML, hgHTML);
    }

Cleanup:
    ReleaseInterface(pStm);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateImgDataObject
//
//  Synopsis:   Create an image data object (supports CF_HDROP, CF_HTML & CF_DIB formats)
//
//----------------------------------------------------------------------------
HRESULT
CreateImgDataObject(CDoc * pDoc, CImgCtx * pImgCtx, CBitsCtx * pBitsCtx,
                    CElement * pElement, CGenDataObject ** ppImgDO)
{
    HRESULT          hr;
    TCHAR *          pchPath = NULL;
    CGenDataObject * pImgDO = NULL;
    IDataObject *    pDO = NULL;

    if (!pImgCtx && !pBitsCtx)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pImgDO = new CGenDataObject(pDoc);
    if (!pImgDO)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Add CF_HDROP format
    if (pBitsCtx)
        hr = pBitsCtx->GetFile(&pchPath);
    else
        hr = pImgCtx->GetFile(&pchPath);
    if (!hr)
        CopyFileToClipboard(pchPath, pImgDO);

    // Add CF_DIB format
    if (pImgCtx && !pBitsCtx)
        CopyDibToClipboard(pImgCtx, pImgDO);

    // Add CF_HTML format
    if (pElement)
        CopyHtmlToClipboard(pElement, pImgDO);

    if (ppImgDO)
    {
        *ppImgDO = pImgDO;
        pImgDO = NULL;
        hr = S_OK;
    }
    else
    {
        // Tell the shell that we want a copy, not a move
        pImgDO->SetPreferredEffect(DROPEFFECT_COPY);

        hr = THR(pImgDO->QueryInterface(IID_IDataObject, (void **)&pDO));
        if (hr)
            goto Cleanup;
        
        // TODO : FerhanE: 
        // With native frames, the SetClipboard was left on the CDoc and that is a security issue.
        // I am moving it to the window. All places but the background image security check passes
        // an owner element, but that one seems to not pass one on purpose. Not clear what the 
        // reasoning is. For now, I am plugging everything but that. I can not think of an exploit on this.
        //
        // We need to make it so that we have a CWindow pointer in this function as a better and long term solution.
        //
        if (pElement)
        {
            CWindow * pWindow = pElement->GetCWindowPtr();

            if (pWindow)
                hr = THR(pWindow->SetClipboard(pDO));
        }
    }

Cleanup:
    // cast to disambiguate between IUnknown's of IDataObject and IDropSource
    ReleaseInterface((IDataObject *) pImgDO);
    ReleaseInterface(pDO);
    MemFreeString(pchPath);
    RRETURN(hr);
}


#define IMP_IMG_FIRE_BOOL(eventName)\
    BOOL CImgHelper::Fire_##eventName() \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            return DYNCAST(CInput, _pOwner)->Fire_##eventName(); \
        } \
        else \
        {\
            return DYNCAST(CImgElement, _pOwner)->Fire_##eventName(); \
        }\
    }

#define IMP_IMG_FIRE_VOID(eventName)\
    void CImgHelper::Fire_##eventName() \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            DYNCAST(CInput, _pOwner)->Fire_##eventName(); \
        } \
        else \
        {\
            DYNCAST(CImgElement, _pOwner)->Fire_##eventName(); \
        }\
    }

#define IMP_IMG_GETAA(returnType, propName)\
    returnType CImgHelper::GetAA##propName () const \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            return DYNCAST(CInput, _pOwner)->GetAA##propName(); \
        } \
        else\
        {\
            return DYNCAST(CImgElement, _pOwner)->GetAA##propName(); \
        }\
    }

#define IMP_IMG_SETAA(paraType, propName)\
    HRESULT CImgHelper::SetAA##propName (paraType pv) \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            return DYNCAST(CInput, _pOwner)->SetAA##propName(pv); \
        } \
        else\
        {\
            return DYNCAST(CImgElement, _pOwner)->SetAA##propName(pv); \
        }\
    }

    IMP_IMG_GETAA (LPCTSTR, alt);

    IMP_IMG_GETAA (LPCTSTR, src);
    IMP_IMG_SETAA (LPCTSTR, src);

    IMP_IMG_GETAA (CUnitValue, border);
    IMP_IMG_GETAA (long, vspace);
    IMP_IMG_GETAA (long, hspace);
    IMP_IMG_GETAA (LPCTSTR, lowsrc);
    IMP_IMG_GETAA (LPCTSTR, vrml);
    IMP_IMG_GETAA (LPCTSTR, dynsrc);
    IMP_IMG_GETAA (htmlStart, start);

    IMP_IMG_GETAA (VARIANT_BOOL, complete);
    IMP_IMG_SETAA (VARIANT_BOOL, complete);

    IMP_IMG_GETAA (long, loop);
    IMP_IMG_GETAA (LPCTSTR, onload);
    IMP_IMG_GETAA (LPCTSTR, onerror);
    IMP_IMG_GETAA (LPCTSTR, onabort);
    IMP_IMG_GETAA (LPCTSTR, name);
    IMP_IMG_GETAA (LPCTSTR, title);
    IMP_IMG_GETAA (VARIANT_BOOL, cache);

    IMP_IMG_FIRE_VOID (onerror);
    IMP_IMG_FIRE_VOID (onload);
    IMP_IMG_FIRE_VOID (onabort);
    IMP_IMG_FIRE_VOID (onreadystatechange);
    IMP_IMG_FIRE_BOOL (onbeforecopy);
    IMP_IMG_FIRE_BOOL (onbeforepaste);
    IMP_IMG_FIRE_BOOL (onbeforecut);
    IMP_IMG_FIRE_BOOL (oncut);
    IMP_IMG_FIRE_BOOL (oncopy);
    IMP_IMG_FIRE_BOOL (onpaste);

CImageLayout *CImgHelper::Layout( CLayoutContext *pLayoutContext /*=NULL*/)
{
    Assert(_pOwner);

    // Return null if we are not rendering the image, i.e. we don't have a CImageLayout
    if (_pOwner->HasSlavePtr())
        return NULL;

    return DYNCAST(CImageLayout ,_pOwner->GetUpdatedLayout( pLayoutContext ));
}

void
CImgHelper::SetImgAnim(BOOL fDisplayNoneOrHidden)
{
    if (!!_fDisplayNoneOrHidden != !!fDisplayNoneOrHidden)
    {
        _fDisplayNoneOrHidden = fDisplayNoneOrHidden;

        if (_fAnimated)
        {
            if (_fDisplayNoneOrHidden)
            {
                if (_lCookie)
                {
                    CImgAnim * pImgAnim = GetImgAnim();

                    if (pImgAnim)
                    {
                        pImgAnim->UnregisterForAnim(this, _lCookie);
                        _lCookie = 0;
                    }
                }
            }
            else
            {
                CImgAnim * pImgAnim = CreateImgAnim();

                if (pImgAnim)
                {
                    if (!_lCookie)
                        pImgAnim->RegisterForAnim(this, (DWORD_PTR) Doc(), g_dwImgIdInc++,
                                                  OnAnimSyncCallback, NULL, &_lCookie);

                    if (_lCookie)
                        pImgAnim->ProgAnim(_lCookie);
                }
            }
        }
    }
}

CImgHelper::CImgHelper (CDoc *pDoc, CSite *pSite, BOOL fIsInput)
{
    _pOwner = pSite;
    _fIsInputImage = fIsInput;
    _fIsInPlace = pDoc ? pDoc->State() >= OS_INPLACE : FALSE;
    _fExpandAltText = (pDoc && pDoc->_pOptionSettings) ?
            (g_fScreenReader || pDoc->_pOptionSettings->fExpandAltText)
            && !pDoc->_pOptionSettings->fShowImages
        : FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     EnterTree
//
//-------------------------------------------------------------------------
HRESULT
CImgHelper::EnterTree()
{
    HRESULT hr = S_OK;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchNewUrl = cBuf;
    CDoc * pDoc = Doc();

    _fIsInPlace = pDoc->State() >= OS_INPLACE;

    if (_readyStateImg == READYSTATE_COMPLETE)
        goto Cleanup;
    //
    // If we are currently doing markup services parsing, we may want to absolutify
    // the src for this image.
    //

    if (_pOwner->GetMarkup()->_fMarkupServicesParsing && pDoc->_fPasteIE40Absolutify && !pDoc->_fNoFixupURLsOnPaste)
    {
        LPCTSTR szUrl;

        Assert( !IsInPrimaryMarkup() );

        if ((szUrl = GetAAsrc()) != NULL && *szUrl)
        {
            hr = THR(
                CMarkup::ExpandUrl(_pOwner->GetMarkup()->GetFrameOrPrimaryMarkup(),
                    szUrl, ARRAY_SIZE(cBuf), pchNewUrl, _pOwner,
                    URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                    LPTSTR( pDoc->_cstrPasteUrl)));
            if (hr)
                goto Cleanup;

            hr = THR( SetAAsrc( pchNewUrl ) );

            if (hr)
                goto Cleanup;
        }
    }

    if (!_pOwner->GetMarkup()->_fInnerHTMLMarkup)
    {
        _fCache = GetAAcache();

        // Ignore HR for the following two cases:
        // if load fails for security or other reason, it's not a problem for Init2
        // of the img element.

        IGNORE_HR(SetImgDynsrc());
        IGNORE_HR(SetImgSrc(IMGF_DEFER_ONWDWNCHAN));    // Don't request resize; don't invalidate frame
    }

Cleanup:

    RRETURN(hr);
}

void
CImgHelper::ExitTree(CNotification * pnf)
{
    CImgCtx * pImgCtx = GetImgCtx();

#ifndef NO_AVI
    if ((_pVideoObj || _hwnd) && !pnf->IsSecondChance())
    {
        pnf->SetSecondChanceRequested();
        return;
    }
#endif

    if (_fIsInPlace)
    {
        _fIsInPlace = FALSE;
        SetActivity();
    }

#ifndef NO_AVI
    SetVideo();
    if (_pVideoObj)
    {
        _pVideoObj->Release();
        _pVideoObj = NULL;
    }
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
#endif // ndef NO_AVI

    if (_pImgCtx && _lCookie)
    {
        CImgAnim * pImgAnim = GetImgAnim();

        if (pImgAnim)
        {
            pImgAnim->UnregisterForAnim(this, _lCookie);
            _lCookie = 0;
            //
            // make sure undo can register animation again
            //
            _fDisplayNoneOrHidden = !_fDisplayNoneOrHidden;
        }
    }

    if( _readyStateImg < READYSTATE_COMPLETE && pnf->IsSecondChance())
    {
        SetImgCtx(NULL, 0);
        SetBitsCtx(NULL);
    }
    else if( pImgCtx )
    {
        pImgCtx->Disconnect();
    }

    if (_hbmCache)
    {
        DeleteObject(_hbmCache);
        _hbmCache = NULL;
    }    
}

//+------------------------------------------------------------------------
//
//  Member:     FetchAndSetImgCtx
//
//-------------------------------------------------------------------------

HRESULT
CImgHelper::FetchAndSetImgCtx(const TCHAR *pchUrl, DWORD dwSetFlags)
{
    CImgCtx *pImgCtx;
    HRESULT hr;

    BOOL fPendingRoot = FALSE;

    // we should not try to invoke mailto and news protocol handlers from an IMG element
    UINT uProt = GetUrlScheme(pchUrl);
    if ((uProt == URL_SCHEME_MAILTO) || (uProt == URL_SCHEME_NEWS))
        return E_ACCESSDENIED;

    if (IsInMarkup())
    {
        fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
    }

    hr = THR(Doc()->NewDwnCtx(DWNCTX_IMG, pchUrl, _pOwner, (CDwnCtx **)&pImgCtx, fPendingRoot));

    if (hr == S_OK)
    {
        SetImgCtx(pImgCtx, dwSetFlags);

        if (pImgCtx)
            pImgCtx->Release();
    }

    RRETURN(hr);
}

HRESULT
CImgHelper::SetImgSrc(DWORD dwSetFlags)
{
    HRESULT hr;
    LPCTSTR szUrl = GetAAsrc();

    if (szUrl)
        hr = FetchAndSetImgCtx(szUrl, dwSetFlags);
    else
        hr = FetchAndSetImgCtx(GetAAlowsrc(), dwSetFlags);

    RRETURN(hr);
}

BOOL MarkupCanAccessLocalUrl(CMarkup *pMarkup, LPCTSTR szUrl)
{
    DWORD   dwZone;
    IInternetSecurityManager *pSecurityManager;
    TCHAR szExpandedURL[pdlUrlLen];
    HRESULT hr;

    if (!pMarkup)
        return FALSE;

    pSecurityManager = pMarkup->GetSecurityManager();

    if (!pSecurityManager)
        return FALSE;

    hr = THR(CMarkup::ExpandUrl(pMarkup, szUrl, ARRAY_SIZE(szExpandedURL), szExpandedURL, NULL));
    if (SUCCEEDED(hr))
    {
        pSecurityManager->MapUrlToZone(szExpandedURL, &dwZone, 0);

        if (dwZone == URLZONE_LOCAL_MACHINE)
        {
            pSecurityManager->MapUrlToZone(CMarkup::GetUrl(pMarkup), &dwZone, 0);
            if (dwZone != URLZONE_LOCAL_MACHINE)
                return FALSE;
        }
    }

    return TRUE;
}

HRESULT
CImgHelper::SetImgDynsrc()
{
    HRESULT hr = S_OK;
    LPCTSTR szDynSrcUrl;

    if (!(Doc()->_dwLoadf  & DLCTL_VIDEOS ))
        goto Cleanup;

    szDynSrcUrl = GetAAdynsrc();
    if (szDynSrcUrl)
    {
        CBitsCtx *pBitsCtx = NULL;

        BOOL fPendingRoot = FALSE;

        // we should not try to invoke mailto and news protocol handlers from an IMG element
        UINT uProt = GetUrlScheme(szDynSrcUrl);
        if ((uProt == URL_SCHEME_MAILTO) || (uProt == URL_SCHEME_NEWS))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        if (IsInMarkup())
        {
            CMarkup *pMarkup = _pOwner->GetMarkup();

            fPendingRoot = pMarkup->IsPendingRoot();
            if (!MarkupCanAccessLocalUrl(pMarkup, szDynSrcUrl))
                hr = E_ACCESSDENIED;
        }

        if (hr == S_OK)
            hr = THR(Doc()->NewDwnCtx(DWNCTX_FILE, szDynSrcUrl,
            _pOwner, (CDwnCtx **)&pBitsCtx, fPendingRoot));

        if (hr == S_OK)
        {
            SetBitsCtx(pBitsCtx);

            if (pBitsCtx)
                pBitsCtx->Release();
        }
    }

Cleanup:
    RRETURN(hr);
}

// if pImgCtx is not secure and the document is secure, hide for security

SSL_SECURITY_STATE SecStateFromSecFlags(DWORD dwFlags);

void
CImgHelper::UpdateHideForSecurity()
{
    DWORD sf;
    SSL_SECURITY_STATE sss;
    SSL_PROMPT_STATE sps;
    BOOL fPendingRoot = FALSE;
    BOOL fHide = FALSE;

    if (!_pImgCtx)
        goto Decided;

    if (IsInMarkup())
    {
        fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
    }

    Doc()->GetRootSslState(fPendingRoot, &sss, &sps);

    if (sss >= SSL_SECURITY_SECURE)
    {
        sf = _pImgCtx->GetSecFlags();

        if (SecStateFromSecFlags(sf) < SSL_SECURITY_SECURE)
        {
            // If document is secure and image was not secure, hide image
            // and show placeholder so that we can't be spoofed

            // (This strategy is only used when an unsecure image was not loaded
            // successfully)

            fHide = TRUE;
        }
    }

Decided:
    if (!!fHide != !!_fHideForSecurity)
    {
        _fHideForSecurity = fHide;
        if (ShouldHaveLayout())
            InvalidateFrame();
    }
}

void
CImgHelper::InvalidateFrame()
{
    // Do nothing if we are not rendering the image, i.e. we don't have CImageLayout
    if (_pOwner->HasSlavePtr())
        return;

    CRect   rcImg;
    if (_fIsInputImage)
    {
        DYNCAST(CInput, _pOwner)->_pImage->GetRectImg(&rcImg);
    }
    else
    {
        DYNCAST(CImgElement, _pOwner)->_pImage->GetRectImg(&rcImg);
    }
    Layout()->Invalidate(&rcImg);
}



void
CImgHelper::SetImgCtx(CImgCtx * pImgCtx, DWORD dwSetFlags)
{
    if (_pImgCtx && _lCookie)
    {
        CImgAnim * pImgAnim = GetImgAnim();

        if (pImgAnim)
        {
            pImgAnim->UnregisterForAnim(this, _lCookie);
            _lCookie = 0;
        }
    }
    _fAnimated = FALSE;

    if (pImgCtx)
    {
        ULONG ulChgOn = IMGCHG_COMPLETE;
        CDoc *pDoc = Doc();

        if (_fIsActive)
            ulChgOn |= IMGCHG_VIEW;
        if (    pDoc->_pOptionSettings
            &&  pDoc->_pOptionSettings->fPlayAnimations 
            && !_pOwner->IsPrintMedia() )
#if DBG==1
        if (!IsTagEnabled(tagNoImgAnim))
#endif
            ulChgOn |= IMGCHG_ANIMATE;

        SIZE sizeImg;
        BOOL fSelectSizeChange = TRUE;
        if ((_fCreatedWithNew || !IsInMarkup()) && !_fSizeInCtor && GetCachedImageSize(pImgCtx->GetUrl(), &sizeImg))
        {
            putWidth(sizeImg.cx);
            putHeight(sizeImg.cy);
            fSelectSizeChange = FALSE;
        }

        ulChgOn |= (((_fCreatedWithNew || !IsInMarkup()) && !_fSizeInCtor && fSelectSizeChange) ? IMGCHG_SIZE : 0);

        // also need size if we've gone through CalcSize without an ImgCtx already
        ulChgOn |= (_fNeedSize ? IMGCHG_SIZE : 0);

        SetReadyStateImg(READYSTATE_UNINITIALIZED);

        pImgCtx->SetCallback(OnDwnChanCallback, this);
        pImgCtx->SelectChanges(ulChgOn, 0, TRUE);
        if (!(pImgCtx->GetState(FALSE, NULL) & (IMGLOAD_COMPLETE | IMGLOAD_STOPPED | IMGLOAD_ERROR)))
            pImgCtx->SetProgSink(CMarkup::GetProgSinkHelper(_pOwner->GetMarkup()));

        pImgCtx->AddRef(); // addref the new before releasing the old
    }

    if (_pImgCtx)
    {
        _pImgCtx->SetProgSink(NULL);
        _pImgCtx->Disconnect();
        _pImgCtx->SetLoad(FALSE, NULL, FALSE);
        if (!pImgCtx)
        {
            _pImgCtx->Release();
            _pImgCtx = NULL;

            if ((dwSetFlags & IMGF_REQUEST_RESIZE) && ShouldHaveLayout())
                ResizeElement(NFLAGS_FORCE);

            UpdateHideForSecurity();
        }

        if (_pImgCtxPending)
        {
            _pImgCtxPending->SetLoad(FALSE, NULL, FALSE);
            _pImgCtxPending->Disconnect();
            _pImgCtxPending->Release();           
        }
  
        _pImgCtxPending = pImgCtx;       
    }
    else
    {
        _pImgCtx = pImgCtx;

        if (    (dwSetFlags & (IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME))
            &&  ShouldHaveLayout())
        {
            if (dwSetFlags & IMGF_REQUEST_RESIZE)
                ResizeElement(NFLAGS_FORCE);
            else
                InvalidateFrame();
        }

        UpdateHideForSecurity();
    }

    // Request layout only if we don't have a pending context.  If we have a
    // pending context, we will request layout when we actually switch to the
    // new context.
    if (!_pImgCtxPending)
    {
        RequestLayout();
    }

    _fSizeChange = FALSE;
    _fNeedSize = FALSE;

    if (pImgCtx)
    {
        if (dwSetFlags & IMGF_DEFER_ONWDWNCHAN)
        {
            GWPostMethodCall(this,
                ONCALL_METHOD(CImgHelper, DeferredOnDwnChan, DeferredOnDwnChan),
                (DWORD_PTR) pImgCtx, TRUE, "CImgHelper::DeferredOnDwnChan");           
        }
        else
        {
            OnDwnChan (pImgCtx);
        }
    }
}


void CImgHelper::RequestLayout()
{
    if (!_pOwner->HasSlavePtr() && ShouldHaveLayout())
    {
        //
        // If there is no pending call to resize the element,
        // post a layout request so that CLayout::EnsureDispNode gets a chance to
        // execute and adjust the opacity of the display node

        // $$ktam: We don't yet support image breaking (multiple layouts for images)
        // so the first/only layout here is fine.

        if (!Layout( GUL_USEFIRSTLAYOUT )->IsSizeThis())
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CImgHelper::SetImgCtx() [lazy layout del]",
                        Layout(),
                        Layout()->_pElementOwner,
                        Layout()->_pElementOwner->TagName(),
                        Layout()->_pElementOwner->_nSerialNumber));
            Layout( GUL_USEFIRSTLAYOUT )->PostLayoutRequest(LAYOUT_MEASURE);
        }
    }
}


void CImgHelper::SetBitsCtx(CBitsCtx *pBitsCtx)
{
    if (_pBitsCtx)
    {
        _pBitsCtx->SetProgSink(NULL);
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef(); // addref then new before releasing the old

        _fStopped = FALSE;

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(_pOwner->GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

HRESULT CImgHelper::putHeight(long l)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->putHeight(l));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->putHeight(l));
    }
}

HRESULT CImgHelper::GetHeight(long *pl)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->GetHeight(pl));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->GetHeight(pl));
    }
}

//
//  OM implementation helper
//
STDMETHODIMP CImgHelper::get_height(long *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsInMarkup())
    {
        hr = THR(GetHeight(p));
    }
    else if (_fCreatedWithNew)
    {
        *p = GetFirstBranch()->GetCascadedheight().GetUnitValue();
    }
    else
    {
        CLayout * pLayout = NULL;
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(_pOwner->EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = _pOwner->GetUpdatedLayout();

        if (!_pOwner->HasVerticalLayoutFlow())
        {
            *p = pLayout->GetContentHeight();
        }
        else
        {
            *p = pLayout->GetContentWidth();
        }

        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());

           pUnitInfo = pdiTemp->GetUnitInfo();
        }

        *p = (!_pOwner->HasVerticalLayoutFlow())
                 ? pUnitInfo->DocPixelsFromDeviceY(*p)
                 : pUnitInfo->DocPixelsFromDeviceX(*p);
    }

Cleanup:
    return hr;
}

HRESULT CImgHelper::putWidth(long l)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->putWidth(l));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->putWidth(l));
    }
}

HRESULT CImgHelper::GetWidth(long *pl)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->GetWidth(pl));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->GetWidth(pl));
    }
}

//
// OM implementation helper
//
STDMETHODIMP CImgHelper::get_width(long *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsInMarkup())
    {
        hr = THR(GetWidth(p));
    }
    else if (_fCreatedWithNew)
    {
        *p = GetFirstBranch()->GetCascadedwidth().GetUnitValue();
    }
    else
    {
        CLayout * pLayout = NULL;
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(_pOwner->EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = _pOwner->GetUpdatedLayout();

        if (!_pOwner->HasVerticalLayoutFlow())
        {
            *p = pLayout->GetContentWidth();
        }
        else
        {
            *p = pLayout->GetContentHeight();
        }
        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());

           pUnitInfo = pdiTemp->GetUnitInfo();
        }
        *p = (!_pOwner->HasVerticalLayoutFlow())
                 ? pUnitInfo->DocPixelsFromDeviceX(*p)
                 : pUnitInfo->DocPixelsFromDeviceY(*p);
    }

Cleanup:
    return hr;
}


void 
CImgHelper::DeferredOnDwnChan (DWORD_PTR pDwnChan)
{   
    // OnDwnChan callback could have already happened, in which case
    // we don't need to do anything
    if ((CDwnChan *)pDwnChan == _pImgCtxPending || 
        (CDwnChan *)pDwnChan == _pImgCtx || 
        (CDwnChan *)pDwnChan == _pBitsCtx)
    {
        OnDwnChan ((CDwnChan *) pDwnChan);    
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CImgHelper::OnDwnChan
//
//-------------------------------------------------------------------------

void
CImgHelper::OnDwnChan(CDwnChan * pDwnChan)
{
    BOOL fPending = FALSE;
    CDoc *pDoc = Doc();
   
    if (!pDoc || !pDoc->PrimaryMarkup())
        return;

    Assert(pDwnChan == _pImgCtxPending || pDwnChan == _pImgCtx || pDwnChan == _pBitsCtx);

    if (pDwnChan == _pImgCtxPending)
    {
        if (_pImgCtxPending->GetState() & (IMGCHG_VIEW | IMGCHG_COMPLETE))
        {
            if (_pImgCtx && _lCookie)
            {
                CImgAnim * pImgAnim = GetImgAnim();

                if (pImgAnim)
                {
                    pImgAnim->UnregisterForAnim(this, _lCookie);
                    _lCookie = 0;
                }
            }

            _pImgCtx->Release();
            _pImgCtx = _pImgCtxPending;
            _pImgCtxPending = NULL;
            fPending = TRUE;
            RequestLayout();
            UpdateHideForSecurity();
        }
    }

#ifdef NO_AVI
    if (pDwnChan == _pImgCtx)
#else
    if (pDwnChan == _pImgCtx && !(_pBitsCtx && _pVideoObj))
#endif
    {
        ULONG ulState;
        SIZE  size;

        TraceTag((tagImgBase, "[%08lX] OnDwnChan (enter) '%ls'", this,
            GetAAsrc()));

        ulState = _pImgCtx->GetState(TRUE, &size);

        if ((ulState & IMGCHG_SIZE) || fPending)
        {
            if (IsInMarkup())
            {
                CTreeNode *pNode;
                CTreeNode::CLock  Lock;

                if( Lock.Init(GetFirstBranch()) )
                    return;

                SetReadyStateImg(READYSTATE_LOADING);
                pNode = GetFirstBranch();
                if (!pNode)
                    return;

                CUnitValue uvWidth = pNode->GetCascadedwidth();
                CUnitValue uvHeight = pNode->GetCascadedheight();

                TraceTag((tagImgBase, "[%08lX] OnChan IMGCHG_SIZE", this));

                if (uvWidth.IsNull() || uvHeight.IsNull() || _fExpandAltText)
                {
                    if (_fCreatedWithNew)
                    {
                        putWidth(size.cx);
                        putHeight(size.cy);
                    }
                    else
                    {
                        TraceTag((tagImgBase, "[%08lX] OnChan ResizeElement", this));
                        CRect rc;

                        GetRectImg(&rc);
                        if (    rc.right - rc.left != size.cx
                            ||  rc.bottom - rc.top != size.cy
                            ||  _fExpandAltText)
                        {
                            ResizeElement();
                        }
                    }

                    if (!(ulState & IMGLOAD_ERROR) && size.cx && size.cy)
                        SetCachedImageSize(_pImgCtx->GetUrl(), size);
                }
            }
            else
            {
                putWidth(size.cx);
                putHeight(size.cy);

                if (!(ulState & IMGLOAD_ERROR) && size.cx && size.cy)
                    SetCachedImageSize(_pImgCtx->GetUrl(), size);
            }
        }

        if (ulState & IMGCHG_VIEW)
        {
            if (_fIsActive)
            {
                long nrc;
                RECT prc[2];
                CRect rectImg;

                TraceTag((tagImgBase, "[%08lX] OnChan IMGCHG_VIEW", this));

                GetRectImg(&rectImg);
                _pImgCtx->GetUpdateRects(prc, &rectImg, &nrc);

                _pOwner->GetUpdatedLayout(GUL_USEFIRSTLAYOUT)->Invalidate(prc, nrc);
            }
        }
        else if (fPending)
        {
            InvalidateFrame();
        }

        if (ulState & IMGCHG_ANIMATE)
        {
            CImgAnim * pImgAnim = CreateImgAnim();

            _fAnimated = TRUE;

            if (pImgAnim)
            {
                if (!_lCookie && !_fDisplayNoneOrHidden)
                {
                    pImgAnim->RegisterForAnim(this, (DWORD_PTR) pDoc, _pImgCtx->GetImgId(),
                                              OnAnimSyncCallback, NULL,
                                              &_lCookie);
                }

                if (_lCookie)
                    pImgAnim->ProgAnim(_lCookie);
            }
        }

        if (ulState & IMGCHG_COMPLETE)
        {
            TraceTag((tagImgBase, "[%08lX] OnChan IMGCHG_COMPLETE", this));
            Assert(_pOwner);
            CElement::CLock  Lock(_pOwner);

            if (ulState & (IMGLOAD_ERROR | IMGLOAD_STOPPED))
            {
                // If document is secure and image had an error on loading, hide partial image
                // data and show placeholder so that we can't be spoofed

                UpdateHideForSecurity();

                if ((_fCreatedWithNew || !IsInMarkup()) && !_fSizeInCtor)
                {
                    GetPlaceHolderBitmapSize(TRUE, &size);
                    putWidth(size.cx + GRABSIZE*2);
                    putHeight(size.cy + GRABSIZE*2);
                }

                if (ulState & IMGLOAD_STOPPED)
                {
                    Fire_onabort();
                }
                else
                {
                    if (_lCookie)
                    {
                        CImgAnim * pImgAnim = GetImgAnim();
                        if (pImgAnim)
                        {
                            pImgAnim->UnregisterForAnim(this, _lCookie);
                            _lCookie = 0;
                        }
                    }

                    Fire_onerror();

                    if (g_bJGJitState == JIT_NEED_JIT)
                    {
                        g_bJGJitState = JIT_PENDING;
                        IGNORE_HR(GWPostMethodCall(pDoc, ONCALL_METHOD(CDoc, FaultInJG, faultinjg), 0, FALSE, "CDoc::FaultInJG"));
                    }
                }

            }

            if (ulState & IMGLOAD_COMPLETE)
            {
                BOOL fPendingRoot = FALSE;

                if (IsInMarkup())
                {
                    fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
                }

                Doc()->OnSubDownloadSecFlags(fPendingRoot, _pImgCtx->GetUrl(), _pImgCtx->GetSecFlags());

                SetReadyStateImg(READYSTATE_COMPLETE);
                SetAAcomplete(TRUE);
            }

            if (_pImgCtx)
            {
                _pImgCtx->SetProgSink(NULL);
            }
            if (!GetFirstBranch())
            {
                TraceTag((tagImgBase, "[%08lX] OnChan (leave)", this));
                return;
            }
        }

        TraceTag((tagImgBase, "[%08lX] OnChan (leave)", this));
    }
#ifndef NO_AVI
    else if (pDwnChan == _pBitsCtx)
    {
        ULONG ulState = _pBitsCtx->GetState();

        if (ulState & DWNLOAD_COMPLETE)
        {
            BOOL fPendingRoot = FALSE;

            if (IsInMarkup())
            {
                fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
            }

            // If unsecure download, may need to remove lock icon on Doc
            pDoc->OnSubDownloadSecFlags(fPendingRoot, _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
            
            // Create the video object if it doesn't exist
            if (!_pVideoObj)
            {
                _pVideoObj = (CIEMediaPlayer *) new (CIEMediaPlayer);
                pDoc->_fBroadcastInteraction = TRUE;
                pDoc->_fBroadcastStop = TRUE;
            }

            if (_pVideoObj)
            {
                TCHAR * pchFile = NULL;

                if (OK(_pBitsCtx->GetFile(&pchFile)) &&
                    OK(_pVideoObj->SetURL(pchFile)))    // Initialize & RenderFile
                    _pVideoObj->SetLoopCount(GetAAloop());
                else
                {
                    _pVideoObj->Release();
                    _pVideoObj = NULL;
                }
                MemFreeString(pchFile);
            }

            ResizeElement();

            SetVideo();

        }
        else if (ulState & DWNLOAD_ERROR)
        {
            if (_pVideoObj)
            {
                _pVideoObj->Release();
                _pVideoObj = NULL;
            }
            if (_hwnd)
            {
                DestroyWindow(_hwnd);
                _hwnd = NULL;
            }
        }

        if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_STOPPED | DWNLOAD_ERROR))
        {
            _pBitsCtx->SetProgSink(NULL);
        }
    }
#endif // NO_AVI
}


//--------------------------------------------------------------------------
//
//  Method:     CImgHelper::ImgAnimCallback
//
//  Synopsis:   Called by the CImgAnim when certain events take place.
//
//--------------------------------------------------------------------------

void
CImgHelper::OnAnimSync(DWORD dwReason, void *pvParam, void **ppvDataOut,
                     IMGANIMSTATE * pImgAnimState)
{
    switch (dwReason)
    {
    case ANIMSYNC_GETIMGCTX:
        *(CImgCtx **) ppvDataOut = _pImgCtx;
        break;

    case ANIMSYNC_GETHWND:
        {
            CDoc * pDoc = Doc();

            *(HWND *) ppvDataOut = pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : NULL;
        }
        break;

    case ANIMSYNC_TIMER:
    #if DBG==1
        if (IsTagEnabled(tagImgAnimDirect))
        {
            if (_fIsActive)
                InvalidateFrame();
            *(BOOL *) ppvDataOut = FALSE;
        }
        else
    #endif
        if (_fIsActive)
        {
            InvalidateFrame();
            *(BOOL *) ppvDataOut = TRUE;
        }
        else
            *(BOOL *) ppvDataOut = FALSE;

        if (pImgAnimState->fLoop)
            Fire_onload();
        break;

    case ANIMSYNC_INVALIDATE:
        if (_fIsActive)
        {
            InvalidateFrame();
            *(BOOL *) ppvDataOut = TRUE;
        }
        else
            *(BOOL *) ppvDataOut = FALSE;
        break;

    default:
        Assert(FALSE);
    }
}

//+-------------------------------------------------------------------------
//
//  Method      CImgHelper::Cleanup
//
//  Synopsis    Shutdown main object by releasing references to
//              other objects and generally cleaning up.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------
void
CImgHelper::CleanupImage ( )
{
#ifndef NO_AVI
    if (_pVideoObj)
    {
        _pVideoObj->Release();
        _pVideoObj = NULL;
    }
#endif // NO_AVI

    SetImgCtx(NULL, 0);
    SetBitsCtx(NULL);

    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }

    if (_hbmCache)
    {
        DeleteObject(_hbmCache);
        _hbmCache = NULL;
    }

    GWKillMethodCall(this, ONCALL_METHOD(CImgHelper, DeferredOnDwnChan, DeferredOnDwnChan), 0);
}

//--------------------------------------------------------------------------
//
//  Method:     CImgHelper::Passivate
//
//  Synopsis:   This function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//--------------------------------------------------------------------------

void
CImgHelper::Passivate ( )
{
    Assert(!IsInMarkup());

    CleanupImage();
}

#ifndef NO_AVI

//+-------------------------------------------------------------------------
//
//  Function:   ActiveMovieWndProc
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
ActiveMovieWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CImgHelper *pImgHelper;

    switch (msg)
    {
    case WM_NCCREATE:
        pImgHelper = (CImgHelper *) ((LPCREATESTRUCTW) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pImgHelper);
        return TRUE;
        break;

    case WM_NCDESTROY:
        pImgHelper = (CImgHelper *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
        if (pImgHelper)
            pImgHelper->_hwnd = NULL;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        return TRUE;
        break;

    case WM_MOUSEMOVE:
        pImgHelper = (CImgHelper *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
        if (pImgHelper && pImgHelper->GetAAstart() == htmlStartmouseover)
            pImgHelper->Replay();
        break;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        POINT ptMap;
        HWND hwndParent = GetParent(hwnd);
        ptMap.x = LOWORD(lParam);
        ptMap.y = HIWORD(lParam);
        MapWindowPoints(hwnd, hwndParent, &ptMap, 1);
        lParam = MAKELPARAM(ptMap.x, ptMap.y);
        return SendMessage(hwndParent, msg, wParam, lParam);
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::SetVideo
//
//  Synopsis:   Checks if we should animate the image
//
//----------------------------------------------------------------------------

void
CImgHelper::SetVideo()
{
    HRESULT hr;
    BOOL fEnableInteraction;
    TCHAR * pszWndClass;

    if (!_pVideoObj)
        return;

    fEnableInteraction = Doc()->_fEnableInteraction;

    if (_fVideoPositioned && _fIsInPlace && fEnableInteraction && !_fStopped)
    {
        CRect rcImg;
        CDoc *pDoc = Doc();

        _pOwner->GetUpdatedLayout()->GetClientRect(&rcImg, COORDSYS_GLOBAL);

        if (!GetWndClassAtom(WNDCLASS_AMOVIE))
        {
            hr = THR(RegisterWindowClass(
                WNDCLASS_AMOVIE,
                ActiveMovieWndProc,
                0,
                NULL, NULL));
            if (hr)
                return;
        }

        pszWndClass = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_AMOVIE);

        if ((_hwnd == NULL) && !_pVideoObj->IsAudio())
        {
            _hwnd = TW32(NULL, CreateWindow(
                pszWndClass,
                NULL,
                WS_CHILD | WS_VISIBLE,
                rcImg.left, rcImg.top,
                rcImg.right - rcImg.left,
                rcImg.bottom - rcImg.top,
                pDoc->GetHWND(),
                NULL,
                g_hInstCore,
                this));

            if (_hwnd == NULL)
                return;
        }

        OffsetRect(&rcImg, -rcImg.left, -rcImg.top);
        _pVideoObj->SetVideoWindow(_hwnd);

        _pVideoObj->SetNotifyWindow(pDoc->GetHWND(), WM_ACTIVEMOVIE, (LONG_PTR)this);
        _pVideoObj->SetWindowPosition(&rcImg);
        _pVideoObj->SetVisible(TRUE);

        if (GetAAstart() == htmlStartfileopen)
            _pVideoObj->Play();

        // We're not interested in playing the entire animation when
        // printing, we just want to get the first frame up, so stop it
        // right away.
        if ( _pOwner->GetMarkup() && _pOwner->GetMarkup()->IsPrintMedia() )
        {
            _pVideoObj->Stop();
        }
    }
    else if (!_fIsInPlace || !fEnableInteraction)
    {

        // remove us from notifications
        _pVideoObj->SetNotifyWindow(NULL, WM_ACTIVEMOVIE, (LONG_PTR)this);

        // Stop the video
        _pVideoObj->Stop();
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::Replay
//
//----------------------------------------------------------------------------

void
CImgHelper::Replay()
{
    if (_pVideoObj)
    {
        if (_pVideoObj->GetStatus() == CIEMediaPlayer::IEMM_Completed)
        {
            _pVideoObj->Seek(0);
            _pVideoObj->SetLoopCount(GetAAloop());
        }

        _pVideoObj->Play();
    }
}

#endif // ndef NO_AVI



//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::SetActivity
//
//  Synopsis:   Turns activity on or off depending on visibility and
//              in-place activation.
//
//----------------------------------------------------------------------------

void
CImgHelper::SetActivity()
{
    if (!!_fIsActive != !!_fIsInPlace)
    {
        CImgCtx * pImgCtx = GetImgCtx();

        _fIsActive = !_fIsActive;

        if (pImgCtx)
        {
            pImgCtx->SelectChanges(_fIsActive ? IMGCHG_VIEW : 0,
                !_fIsActive ? IMGCHG_VIEW : 0, FALSE);
        }
    }
}

BOOL
CImgHelper::IsOpaque()
{
    if (!GetFirstBranch() || !ShouldHaveLayout() || !_pImgCtx)
        return FALSE;

    BOOL fOpaque = (_pImgCtx->GetState() & (IMGTRANS_OPAQUE | IMGLOAD_COMPLETE)) ==
        (IMGTRANS_OPAQUE | IMGLOAD_COMPLETE);
    if (fOpaque)
    {
        BOOL fParentVertical = GetFirstBranch()->IsParentVertical();
        LONG lhSpace = fParentVertical ? GetAAvspace() : GetAAhspace();
        LONG lvSpace = fParentVertical ? GetAAhspace() : GetAAvspace();

        fOpaque = (lvSpace == 0) && (lhSpace != -1 ? (lhSpace == 0) : !IsAligned());
        // In strict CSS1 documets padding reseves space around the image and that makes
        //   the image transparant
        if(fOpaque)
        {
            CTreeNode * pNode = GetFirstBranch();
            CMarkup * pMarkup = _pOwner->GetMarkup();
            if(pMarkup && IsStrictCSS1Document())
            {
                const CFancyFormat * pFF = pNode->GetFancyFormat();
                if(!pFF->GetPadding(SIDE_TOP).IsNull() || !pFF->GetPadding(SIDE_BOTTOM).IsNull()
                  || !pFF->GetPadding(SIDE_LEFT).IsNull() || !pFF->GetPadding(SIDE_RIGHT).IsNull())
                {
                    fOpaque = FALSE;
                }
            }
        }

        
    }

    return fOpaque;
}

//+---------------------------------------------------------------------------
//  Member :     CImgHelper::GetRectImg
//
//  Synopsis   : gets rectImg
//
//+---------------------------------------------------------------------------

void
CImgHelper::GetRectImg(CRect * prectImg)
{
    _pOwner->GetUpdatedLayout(GUL_USEFIRSTLAYOUT)->GetClientRect(prectImg);
}


//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CImgHelper::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateImg(_readyStateImg);
}

//+------------------------------------------------------------------------
//
//  Member:     CImgHelper::SetReadyStateImg
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CImgHelper::SetReadyStateImg(long readyStateImg)
{
    long readyState;

    _readyStateImg = readyStateImg;

    readyState = min ((long)_readyStateImg, _pOwner->GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        Fire_onreadystatechange();

        if (_readyStateImg == READYSTATE_COMPLETE)
            Fire_onload();
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CImgHelper::Notify
//
//  Synopsis:   Listen for inplace (de)activation so we can turn on/off
//              animation
//
//-------------------------------------------------------------------------

void
CImgHelper::Notify(CNotification *pNF)
{
    switch (pNF->Type())
    {
    case NTYPE_DOC_STATE_CHANGE_1:
#ifndef NO_AVI
        if (    _pVideoObj 
            &&  !!_fIsInPlace != (Doc()->State() >= OS_INPLACE) )
        {
            pNF->SetSecondChanceRequested();
            break;
        }
#endif

        // fall through
    case NTYPE_DOC_STATE_CHANGE_2:
        {
            CDoc *  pDoc = Doc();
            
            if (!!_fIsInPlace != (pDoc->State() >= OS_INPLACE))
            {
                CImgCtx * pImgCtx = GetImgCtx();

                DWNLOADINFO dli;

                _fIsInPlace = !_fIsInPlace;
                SetActivity();

#ifndef NO_AVI
                SetVideo();
#endif // ndef NO_AVI

                if( SUCCEEDED( _pOwner->GetMarkup()->InitDownloadInfo(&dli) ) )
                {
                    if (pImgCtx && _fIsInPlace && (pDoc->_dwLoadf & DLCTL_DLIMAGES))
                        pImgCtx->SetLoad(TRUE, &dli, FALSE);

                    if (_pBitsCtx && _fIsInPlace)
                        _pBitsCtx->SetLoad(TRUE, &dli, FALSE);
                }
            }
        }
        break;

    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        {
            CImgCtx * pImgCtx = GetImgCtx();

            if (pImgCtx)
            {
                pImgCtx->SetProgSink(NULL);
                pImgCtx->SetLoad(FALSE, NULL, FALSE);

#ifndef NO_ART
                if (pImgCtx->GetArtPlayer())
                    pNF->SetSecondChanceRequested();
#endif
            }

            if (_pBitsCtx)
            {
                _pBitsCtx->SetProgSink(NULL);
                _pBitsCtx->SetLoad(FALSE, NULL, FALSE);
            }

#ifndef NO_AVI
            if (_pVideoObj)
                pNF->SetSecondChanceRequested();
#endif

            break;
        }

        case NTYPE_STOP_2:
        case NTYPE_MARKUP_UNLOAD_2:
        {
            CImgCtx * pImgCtx = GetImgCtx();
#ifndef NO_AVI
            if (_pVideoObj)
            {
                _pVideoObj->Stop();
                _fStopped = TRUE;
            }
#endif // NO_AVI

#ifndef NO_ART
            if (pImgCtx)
            {
                CArtPlayer * pArtPlayer = pImgCtx->GetArtPlayer();

                if (pArtPlayer)
                {
                    pArtPlayer->DoPlayCommand(IDM_IMGARTSTOP);
                }
            }
#endif NO_ART
        }
        break;

#ifndef NO_AVI
    case NTYPE_ENABLE_INTERACTION_1:
        if (_pVideoObj)
            pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ENABLE_INTERACTION_2:
        SetVideo();
        break;

    case NTYPE_ACTIVE_MOVIE:
        {
            void * pv;;

            pNF->Data(&pv);

            if (_pVideoObj && (pv == this))
                _pVideoObj->NotifyEvent();              // Let the video object know something happened
        }
        break;
#endif

    case NTYPE_ELEMENT_EXITTREE_1:
        GWKillMethodCall(this, ONCALL_METHOD(CImgHelper, DeferredOnDwnChan, DeferredOnDwnChan), 0);
        // fall through ...
    
    case NTYPE_ELEMENT_EXITTREE_2:
        ExitTree(pNF);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CImgHelper::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

HRESULT
CImgHelper::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT hr = S_FALSE;
    BOOL fRTL = FALSE;
    CDoc *pDoc = Doc();

    //  Check if we can display alt property as the tooltip.
    //

    TCHAR * pchString;
    CRect   rc;


    pchString = (LPTSTR) GetAAalt();
    if (pchString == NULL)
        goto Cleanup;

    {
        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        Assert(GetFirstBranch());
    
        // Complex Text - determine if element is right to left for tooltip style setting
        fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;
        _pOwner->GetUpdatedLayout()->GetRect(&rc, COORDSYS_GLOBAL);

        if (!pDoc->_pDocPopup)
        {
            FormsShowTooltip(pchString, pDoc->_pInPlace->_hwnd, *pmsg, &rc, (DWORD_PTR) _pOwner->GetMarkup(), (DWORD_PTR) this, fRTL);
        }
        hr = S_OK;
    }

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::QueryStatus, public
//
//  Synopsis:   Implements QueryStatus for CImgHelper
//
//----------------------------------------------------------------------------

HRESULT
CImgHelper::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    int idm;

    TraceTag((tagMsoCommandTarget, "CImgHelper::QueryStatus"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *    pCmd = &rgCmds[0];
    HRESULT     hr = S_OK;

    Assert(!pCmd->cmdf);

    idm = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (idm)
    {
    case IDM_ADDFAVORITES:
    {
        TCHAR * pchUrl = NULL;

        pCmd->cmdf = (S_OK == GetUrl(&pchUrl)) ?
                        MSOCMDSTATE_UP :
                        MSOCMDSTATE_DISABLED;

        MemFreeString(pchUrl);
        break;
    }

    case IDM_CUT:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforecut())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_COPY:
    {
        TCHAR * pchPath = NULL;

        // Enable if script wants to handle it or we know there is something to copy,
        // otherwise leave it to default
        if (    !Fire_onbeforecopy()
            ||  (_pBitsCtx && (S_OK == THR(_pBitsCtx->GetFile(&pchPath))))
            ||  (_pImgCtx && !_pBitsCtx))
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        MemFreeString(pchPath);
        break;
    }
    case IDM_PASTE:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforepaste())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;

    case IDM_SHOWPICTURE:
    {
        CImgCtx * pImgCtx = GetImgCtx();
        ULONG ulState = pImgCtx
                      ? pImgCtx->GetState()
                      : (_pBitsCtx ? _pBitsCtx->GetState()
                                   : IMGLOAD_NOTLOADED);

        pCmd->cmdf = (ulState & IMGLOAD_COMPLETE) ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
        break;
    }
    case IDM_MP_PRINTPICTURE:
    case IDM_MP_EMAILPICTURE:
    case IDM_SAVEPICTURE:
    {
        if ((_pBitsCtx && (_pBitsCtx->GetState() & DWNLOAD_COMPLETE)) ||
            (_pImgCtx && (_pImgCtx->GetState() & IMGLOAD_COMPLETE)))
            pCmd->cmdf = MSOCMDSTATE_UP;
        else
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
        break;
    }
    case IDM_MP_MYPICS:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_SETWALLPAPER:
        if (Doc()->_pOptionSettings->dwNoChangingWallpaper)
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }
        // fall through
    case IDM_SETDESKTOPITEM:
    {
        ULONG ulState = _pImgCtx ? _pImgCtx->GetState() : IMGLOAD_NOTLOADED;

        pCmd->cmdf = (ulState & IMGLOAD_COMPLETE) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
        break;
    }

#ifndef NO_AVI
    case IDM_DYNSRCPLAY:
    pCmd->cmdf = (_pVideoObj && (_pVideoObj->CanPlay())) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
    break;

    case IDM_DYNSRCSTOP:
    pCmd->cmdf = (_pVideoObj && _pVideoObj->CanStop()) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
    break;
#endif // NO_AVI
#ifndef NO_ART
    case IDM_IMGARTPLAY:
    case IDM_IMGARTSTOP:
    case IDM_IMGARTREWIND:
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        if (_pImgCtx && Doc()->_pOptionSettings->fPlayAnimations)
        {
            CArtPlayer * pArtPlayer = _pImgCtx->GetArtPlayer();

            if (pArtPlayer)
                pCmd->cmdf = pArtPlayer->QueryPlayState(idm) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
        }
        break;
#endif // NO_ART
    }

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::Exec, public
//
//  Synopsis:   Executes a command on the CImgHelper
//
//----------------------------------------------------------------------------

HRESULT
CImgHelper::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CImgHelper::Exec"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int                    idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT                hr = MSOCMDERR_E_NOTSUPPORTED;
    IHTMLSelectionObject * pSel = NULL;

    switch (idm)
    {
    case IDM_CUT:
        Fire_oncut();
        //
        // marka - we normally want to not allow a cut of an image in BrowseMode
        // but if we're in edit mode - we want to allow it.
        //
        // this bug was introduced as now a site selected image will be current
        // we can probably remove this once we make the currency work again as before
        // 
        //
        if ( ! IsEditable(TRUE))
        {
            hr = S_OK;
        }
        break;
    case IDM_COPY:
    {
        //
        // krisma - If there's a text selection,
        // we want to let the editor handle the copy or we'll end up just
        // copying the image. (IE bug 83358)
        //

        if (_pOwner->HasMarkupPtr())
        {
            CDocument *   pDoc = _pOwner->GetMarkup()->Document();
            htmlSelection eType;
            HRESULT       hrTemp;

            // This is to ensure we have a _pCSelectionObject on the document.
            hrTemp = THR(pDoc->get_selection(&pSel));
            if (hrTemp)
            {
                hr = hrTemp;
                goto Cleanup;
            }

            Assert(pDoc->_pCSelectionObject);

            hrTemp = THR(pDoc->_pCSelectionObject->GetType(&eType));
            if (hrTemp)
            {
                hr = hrTemp;
                goto Cleanup;
            }

            if (eType != htmlSelectionText)
            {
                hr = THR(CreateImgDataObject(Doc(), _pImgCtx, _pBitsCtx, _pOwner, NULL));
            }
        }
        else
        {
            EnsureInMarkup();
            hr = THR(CreateImgDataObject(Doc(), _pImgCtx, _pBitsCtx, _pOwner, NULL));
        }

        Fire_oncopy();
        break;
    }
    case IDM_PASTE:
        Fire_onpaste();

        // MarkA's comments above for IDM_CUT apply here also.
        if ( ! IsEditable(TRUE))
        {
            hr = S_OK;
        }
        break;
    case IDM_SHOWPICTURE:
    {
        DWNLOADINFO dli;
        CImgCtx * pImgCtx = GetImgCtx();

        hr = THR( _pOwner->GetMarkup()->InitDownloadInfo(&dli) );
        if( hr )
            goto Cleanup;

        if (pImgCtx)
            pImgCtx->SetLoad(TRUE, &dli, TRUE);    // Reload on error
        else
        {
            THR(_pOwner->OnPropertyChange(
                                    _fIsInputImage ? DISPID_CInput_src :
                                                    DISPID_CImgElement_src,
                                    0,
                                    _fIsInputImage ? (PROPERTYDESC *)&s_propdescCInputsrc : 
                                                     (PROPERTYDESC *)&s_propdescCImgElementsrc));
        }

        hr = S_OK;
        break;
    }

    case IDM_SAVEPICTURE:
        hr = THR(PromptSaveAs());
        break;

    case IDM_MP_EMAILPICTURE:
    {
        ITridentService2 *pTriSvc2 = NULL;
        BSTR              bstrURL  = NULL;

        get_src(&bstrURL);
        if(!bstrURL)
            break;
        
        if (Doc()->_pTridentSvc && 
            SUCCEEDED(Doc()->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2)))
        {
            pTriSvc2->EmailPicture(bstrURL);
            pTriSvc2->Release();
        }

        hr = S_OK;

        break;
    }
    case IDM_MP_PRINTPICTURE:
    {

        CHAR szBuffer[INTERNET_MAX_URL_LENGTH];
        BSTR bstrURL = NULL;

        get_src(&bstrURL);
        if(!bstrURL)
            break;

        wnsprintfA(szBuffer,INTERNET_MAX_URL_LENGTH,"\"%ws\"", bstrURL);

        PrintHTML(NULL, NULL, szBuffer, 0);

        hr = S_OK;
        
        break;

    }
    case IDM_MP_MYPICS:
    {
        TCHAR szCache[MAX_PATH];

        // get mypics folder...
        hr = SHGetFolderPath(NULL, CSIDL_MYPICTURES | CSIDL_FLAG_CREATE, NULL, 0, szCache);

        // if we found something, open it...
        if (hr == S_OK) {
    
            TCHAR szIniFile[MAX_PATH];
            PathCombine(szIniFile, szCache, TEXT("desktop.ini"));
            SHELLEXECUTEINFO ei = { sizeof(SHELLEXECUTEINFO), 0};
            ei.hwnd = NULL;
            ei.lpFile = szCache;
            ei.nShow = SW_SHOWNORMAL;
            if(ShellExecuteEx(&ei))
                hr = S_OK;
            else
                hr = E_FAIL;
        }

        break;

    }

    case IDM_SETDESKTOPITEM:
    case IDM_SETWALLPAPER:
        if (_pImgCtx)
            Doc()->SaveImgCtxAs(_pImgCtx, NULL, idm);
        hr = S_OK;
        break;

    case IDM_ADDFAVORITES:
        TCHAR * pchUrl;
        TCHAR * pszTitle;

        pchUrl = NULL;
        pszTitle = (LPTSTR) GetAAalt();
        if (!pszTitle)
            pszTitle = (LPTSTR) GetAAtitle();

        hr = GetUrl(&pchUrl);
        if (!hr)
            hr = Doc()->AddToFavorites(pchUrl, pszTitle);
        MemFreeString(pchUrl);
        break;
#ifndef NO_AVI
        case IDM_DYNSRCPLAY:
        Replay();
        _fStopped = FALSE;
        hr = S_OK;
        break;
    case IDM_DYNSRCSTOP:
        if (_pVideoObj)
        {
            _pVideoObj->Stop();
            _fStopped = TRUE;
        }
        hr = S_OK;
        break;
#endif // ndef NO_AVI
#ifndef NO_ART
    case IDM_IMGARTPLAY:
    case IDM_IMGARTSTOP:
    case IDM_IMGARTREWIND:
        if (_lCookie && _pImgCtx)
        {
            CImgAnim * pImgAnim = GetImgAnim();
            CArtPlayer * pArtPlayer = _pImgCtx->GetArtPlayer();

            if (pImgAnim && pArtPlayer)
            {
                if (idm == IDM_IMGARTPLAY)
                {
                    pImgAnim->StartAnim(_lCookie);
                    pArtPlayer->DoPlayCommand(IDM_IMGARTPLAY);
                }
                else if (idm == IDM_IMGARTSTOP)
                {
                     pArtPlayer->DoPlayCommand(IDM_IMGARTSTOP);
                     pImgAnim->StopAnim(_lCookie);
                }
                else // idm == IDM_IMGARTREWIND
                {
                    pArtPlayer->DoPlayCommand(IDM_IMGARTREWIND);
                    pImgAnim->StartAnim(_lCookie);
                    pArtPlayer->_fRewind = TRUE;
                }
            }
        }
        break;
#endif // NO_ART
    }

Cleanup:
    ReleaseInterface(pSel);

    RRETURN_NOTRACE(hr);
}

//+-------------------------------------------------------------------
//
//  Member  : ShowImgContextMenu
//
//  synopsis   : Implementation of interface src property get. this
//      should return the expanded src (e.g.  file://c:/temp/foo.jpg
//      rather than foo.jpg)
//
//------------------------------------------------------------------

HRESULT
CImgHelper::ShowImgContextMenu(CMessage * pMessage)
{
    HRESULT hr;

    Assert(pMessage);
    Assert(WM_CONTEXTMENU == pMessage->message);

#ifndef NO_ART
    if (_pImgCtx && _pImgCtx->GetMimeInfo() && _pImgCtx->GetMimeInfo()->pfnImg == NewImgTaskArt)
    {
        hr = THR(_pOwner->OnContextMenu(
                MAKEPOINTS(pMessage->lParam).x,
                MAKEPOINTS(pMessage->lParam).y,
                (!IsEditable(TRUE) && (_pImgCtx->GetArtPlayer())) ?
                    (CONTEXT_MENU_IMGART) : (CONTEXT_MENU_IMAGE)));
    }
    else
#endif
    {
        LPCTSTR pchdynSrc = GetAAdynsrc();
        hr = THR(_pOwner->OnContextMenu(
                MAKEPOINTS(pMessage->lParam).x,
                MAKEPOINTS(pMessage->lParam).y,
                (!IsEditable(TRUE) && (pchdynSrc && pchdynSrc[0]) ) ?
                    (CONTEXT_MENU_IMGDYNSRC) : (CONTEXT_MENU_IMAGE)));
    }
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member  : get_src
//
//  synopsis   : Implementation of interface src property get. this
//      should return the expanded src (e.g.  file://c:/temp/foo.jpg
//      rather than foo.jpg)
//
//------------------------------------------------------------------

STDMETHODIMP
CImgHelper::get_src(BSTR * pstrFullSrc)
{
    HRESULT hr;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR  * pchNewUrl = cBuf;

    if (!pstrFullSrc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pstrFullSrc = NULL;

    hr = THR(CMarkup::ExpandUrl(_pOwner->GetMarkupForBaseUrl(), GetAAsrc(), ARRAY_SIZE(cBuf), pchNewUrl, _pOwner));
    if (hr || (pchNewUrl == NULL))
        goto Cleanup;

    *pstrFullSrc = SysAllocString(pchNewUrl);
    if (!*pstrFullSrc)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------
//
//  member : CImgHelper::GetFile
//
//-------------------------------------------------------------------

HRESULT
CImgHelper::GetFile(TCHAR **ppchFile)
{
    HRESULT hr = E_FAIL;

    Assert(ppchFile);

    *ppchFile = NULL;

#ifndef NO_AVI
    if (_pBitsCtx)
    {
        if (_pBitsCtx->GetState() & DWNLOAD_COMPLETE)
            hr = _pBitsCtx->GetFile(ppchFile);
        else
            hr = S_OK;
    }
    else
#endif // ndef NO_AVI
    if (_pImgCtx)
    {
        if (_pImgCtx->GetState() & DWNLOAD_COMPLETE)
            hr = _pImgCtx->GetFile(ppchFile);
        else
            hr = S_OK;
    }
    else
    {
        // TODO DOM May be we could return anything more informative
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------
//
//  member : CImgHelper::GetUrl
//
//-------------------------------------------------------------------

HRESULT
CImgHelper::GetUrl(TCHAR **ppchUrl)
{
    HRESULT hr = E_FAIL;

    Assert(ppchUrl);

    *ppchUrl = NULL;

#ifndef NO_AVI
    if (_pBitsCtx)
        hr = THR(MemAllocString(Mt(CImgHelperGetUrl), _pBitsCtx->GetUrl(), ppchUrl));
    else
#endif // ndef NO_AVI
    if (_pImgCtx)
        hr = THR(MemAllocString(Mt(CImgHelperGetUrl), _pImgCtx->GetUrl(), ppchUrl));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::PromptSaveAs
//
//  Synopsis:   Brings up the 'Save As' dialog and saves the image.
//
//  Arguments:  pchPath     Returns the file to whic the image was saved.
//
//----------------------------------------------------------------------------

HRESULT
CImgHelper::PromptSaveAs(TCHAR * pchFileName /*=NULL*/, int cchFileName /*=0*/)
{
    if (_pBitsCtx && (_pBitsCtx->GetState() & DWNLOAD_COMPLETE))
        Doc()->SaveImgCtxAs(NULL, _pBitsCtx, IDM_SAVEPICTURE, pchFileName, cchFileName);
    else if (_pImgCtx && (_pImgCtx->GetState() & DWNLOAD_COMPLETE))
        Doc()->SaveImgCtxAs(_pImgCtx, NULL, IDM_SAVEPICTURE, pchFileName, cchFileName);
    RRETURN(S_OK);
}

void
CImgHelper::GetMarginInfo(CParentInfo * ppri,
                          LONG        * plLMargin,
                          LONG        * plTMargin,
                          LONG        * plRMargin,
                          LONG        * plBMargin)
{
    BOOL fParentVertical = GetFirstBranch()->IsParentVertical();
    LONG lhSpace  = fParentVertical ? GetAAvspace() : GetAAhspace();
    LONG lvSpace  = fParentVertical ? GetAAhspace() : GetAAvspace();
    BOOL fUseDefMargin = _pOwner->IsAligned() && !_pOwner->IsAbsolute() && (lhSpace == -1);
    LONG lhMargin = 0;
    LONG lvMargin = 0;

    if (lhSpace < 0)
        lhSpace = 0;
    if (lvSpace < 0)
        lvSpace = 0;

    lhSpace = ppri->DeviceFromDocPixelsX(lhSpace);
    lvSpace = ppri->DeviceFromDocPixelsY(lvSpace);

    if (plLMargin)
    {
        *plLMargin += lhSpace;
        lhMargin   += *plLMargin;
    }
    if (plRMargin)
    {
        *plRMargin += lhSpace;
        lhMargin   += *plRMargin;
    }
    if (plTMargin)
    {
        lvMargin   += *plTMargin;
        *plTMargin += lvSpace;
    }
    if (plBMargin)
    {
        lvMargin   += *plBMargin;
        *plBMargin += lvSpace;
    }
    if (lhMargin > 0 || lvMargin > 0)
    {
        // if vertical margins are defined,
        // Netscape compatibility should goes away.
        // but if just vspace is defined,
        // we still need to preserve this compatibility
        fUseDefMargin = FALSE;
    }

    if (   !IsStrictCSS1Document()  //don't apply netscape compat in Strict mode
        && fUseDefMargin 
        && (plLMargin || plRMargin))
    {
        // (srinib/yinxie) - netscape compatibility, aligned images have
        // a 3 pixel hspace by default
        Assert(ppri);
        long lhSpace = ppri->DeviceFromDocPixelsX( DEF_HSPACE );
        if (plLMargin)
        {
            *plLMargin += lhSpace;
        }
        if (plRMargin)
        {
            *plRMargin += lhSpace;
        }
    }
}

void
CImgHelper::CalcSize(
    CCalcInfo * pci,
    SIZE *      psize)
{
    SIZE            sizeImg;
    CBorderInfo     bi;
    SIZE            sizeBorderHVSpace2;
    CPeerHolder   * pPH = _pOwner->GetLayoutPeerHolder();

    sizeImg = g_Zero.size;

    Assert(pci);
    Assert(psize);

    CDoc *pDoc                   = Doc();
    CTreeNode * pNode            = GetFirstBranch();
    const CFancyFormat * pFF     = pNode->GetFancyFormat();
    const CCharFormat  * pCF     = pNode->GetCharFormat();
    BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
    BOOL fStrictCSS1Document = IsStrictCSS1Document();
    long lParentWidth;
    long lParentHeight  = pci->_sizeParent.cy;
    BOOL fHasWidth;
    BOOL fHasHeight;
    BOOL fMaxWidth;
    BOOL fMaxHeight;
    SIZE sizeNew, sizePlaceHolder;
    BOOL fHasSize;
    ULONG ulState;
    TCHAR * pchAlt = NULL;
    RECT rcText;

    if (IsStrictCSS1Document())
    {
        lParentWidth = pci->_sizeParent.cx;
        fHasWidth    = pFF->UseLogicalUserWidth(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
        fHasHeight   = pFF->UseLogicalUserHeight(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
        fMaxWidth    =  fHasWidth 
                    &&  cuvWidth.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
        fMaxHeight   =  fHasHeight 
                    &&  cuvHeight.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
    }
    else 
    {
        lParentWidth = psize->cx;
        fHasWidth    = !cuvWidth.IsNullOrEnum();
        fHasHeight   = !cuvHeight.IsNullOrEnum();
        fMaxWidth    =  cuvWidth.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
        fMaxHeight   =  cuvHeight.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
    }

    _pOwner->GetBorderInfo( pci, &bi, FALSE, FALSE );

    sizeBorderHVSpace2.cx = bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
    sizeBorderHVSpace2.cy = bi.aiWidths[SIDE_TOP] + bi.aiWidths[SIDE_BOTTOM];

    if (fStrictCSS1Document)
    {
        const CUnitValue & cuvPaddingLeft   = pFF->GetLogicalPadding(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvPaddingTop    = pFF->GetLogicalPadding(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvPaddingRight  = pFF->GetLogicalPadding(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvPaddingBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);

        // NOTE : for both horizontal and vertical paddings we provide lParentWidth as a reference (for percentage values), 
        //        this is done intentionally as per css spec.
        _lPadding[SIDE_LEFT]   = cuvPaddingLeft.XGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingLeft));
        _lPadding[SIDE_TOP]    = cuvPaddingTop.YGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingTop));
        _lPadding[SIDE_RIGHT]  = cuvPaddingRight.XGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingRight));
        _lPadding[SIDE_BOTTOM] = cuvPaddingBottom.YGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingBottom));
    }
    else 
    {
        _lPadding[SIDE_LEFT]   = 
        _lPadding[SIDE_TOP]    = 
        _lPadding[SIDE_RIGHT]  = 
        _lPadding[SIDE_BOTTOM] = 0;

        // NOTE : adjust size provided by parent only if this is not CSS1 strict case.
        lParentWidth  = max(0L, lParentWidth-sizeBorderHVSpace2.cx);
        lParentHeight = max(0L, lParentHeight-sizeBorderHVSpace2.cy);
    }

#ifndef NO_AVI
    if (_pBitsCtx && _pVideoObj)
    {
        ulState = _pBitsCtx->GetState(); // TODO (lmollico): ulState should be an IMGLOAD_*
        fHasSize = OK(_pVideoObj->GetSize(&sizeImg));
    }
    else
#endif // ndef NO_AVI
    if (_pImgCtx)
    {
        if (!_fSizeChange)
        {
            _pImgCtx->SelectChanges(IMGCHG_SIZE, 0, FALSE);

            _fSizeChange = TRUE;
        }
        ulState = _pImgCtx->GetState(FALSE, &sizeImg);
        fHasSize = (sizeImg.cx || sizeImg.cy);
    }
    else
    {
        ulState = IMGLOAD_NOTLOADED;
        fHasSize = FALSE;
        _fNeedSize = TRUE;
    }

    if (!fHasSize && pci->_fTableCalcInfo)
    {
        CTableCalcInfo * ptci = (CTableCalcInfo *) pci;
        ptci->_fDontSaveHistory = TRUE;
    }


    //
    //  This object needs sizing, first determine if we have a layoutBehavior
    //  that wants full delegation.  If not, then do the normal sizing
    //  We do this block of code here, because the variable setup above has
    //  sideeffects in the imgctx and in the tablecalcinfo, and this avoids bugs.
    //---------------------------------------------------------------------------
    if (   pPH 
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
    {
        // There is a peer layout that wants full_delegation of the sizing.        
        POINT pt;

        pt.x = pt.y = 0;

        //NOTE: It doesn't make sense to honor the offsetPoint here
        if (Layout())
            Layout()->DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION,
                                       pPH, pci, *psize, &pt, psize);
    }
    else
    {
        // Normal (non-delegated) size calculation happens here
        if (fHasSize ||
            (_pImgCtx && !_fExpandAltText && GetCachedImageSize(_pImgCtx->GetUrl(), &sizeImg)))
        {
            sizePlaceHolder.cx = sizeNew.cx = pci->DeviceFromDocPixelsX(sizeImg.cx);
            sizePlaceHolder.cy = sizeNew.cy = pci->DeviceFromDocPixelsY(sizeImg.cy);
        }
        else
        {
            SIZE sizeGrab;
            GetPlaceHolderBitmapSize(ulState & (IMGLOAD_ERROR | IMGLOAD_STOPPED),
                                     &sizeNew);
            sizeNew.cx = pci->DeviceFromDocPixelsX(sizeNew.cx);
            sizeNew.cy = pci->DeviceFromDocPixelsY(sizeNew.cy);
            sizeGrab.cx = pci->DeviceFromDocPixelsX(GRABSIZE);
            sizeGrab.cy = pci->DeviceFromDocPixelsY(GRABSIZE);

            pchAlt = (TCHAR *)GetAAalt();

            if (pchAlt && *pchAlt)
            {
                const CCharFormat *pCF = pNode->GetCharFormat();

                CIntlFont intlfont(pci,
                                   pci->_hdc,
                                   _pOwner->GetMarkup()->GetCodePage(),
                                   pCF ? pCF->_lcid : 0,
                                   pDoc->_sBaselineFont,
                                   pchAlt);

                rcText.left = rcText.top = rcText.right = rcText.bottom = 0;
                DrawTextInCodePage(WindowsCodePageFromCodePage(_pOwner->GetMarkup()->GetCodePage()),
                         pci->_hdc, pchAlt, -1, &rcText, DT_CALCRECT | DT_NOPREFIX);

                sizePlaceHolder.cx = sizeNew.cx + 3 * sizeGrab.cx + rcText.right - rcText.left;
                sizePlaceHolder.cy = max(sizeNew.cy, rcText.bottom - rcText.top) + 2 * sizeGrab.cy;
            }
            else
            {
                sizePlaceHolder.cx = sizeNew.cx + 2 * sizeGrab.cx;
                sizePlaceHolder.cy = sizeNew.cy + 2 * sizeGrab.cy;
            }
        }
        if (!fHasWidth || !fHasHeight)
        {
            // If the image Width is set, use it
            if (fHasWidth && !fMaxWidth)
            {
                psize->cx = cuvWidth.XGetPixelValue( pci,
                                        lParentWidth,
                                        pNode->GetFontHeightInTwips(&cuvWidth));
            }
            else
            {
                // if height only is set, then the image should be proportional
                // to the real size sizeNew.cx
                if (fHasHeight && !fMaxHeight && (sizeNew.cy > 0))
                {
                    psize->cx = MulDivQuick(cuvHeight.YGetPixelValue(pci,
                                                            lParentHeight,
                                                            pNode->GetFontHeightInTwips(&cuvHeight)),
                                            sizeNew.cx,
                                            sizeNew.cy);
                }
                else
                {
                    psize->cx = sizePlaceHolder.cx;
                }
            }

            // If the image Height is set, use it
            if (fHasHeight && !fMaxHeight)
            {
                psize->cy = cuvHeight.YGetPixelValue(pci,
                                            lParentHeight,
                                            pNode->GetFontHeightInTwips(&cuvHeight));
            }
            else
            {
                // if width only is set, then the image should be proportional
                // to the real size sizeNew.cx
                if (fHasWidth && !fMaxWidth && (sizeNew.cx > 0))
                {
                    psize->cy = MulDivQuick(cuvWidth.XGetPixelValue(pci,
                                                            lParentWidth,
                                                            pNode->GetFontHeightInTwips(&cuvWidth)),
                                            sizeNew.cy,
                                            sizeNew.cx);
                }
                else
                {
                    psize->cy = sizePlaceHolder.cy;
                }
            }

        }
        else
        {
            if (!fMaxWidth)
                psize->cx = cuvWidth.XGetPixelValue(pci,
                                        lParentWidth,
                                        pNode->GetFontHeightInTwips(&cuvWidth));
            else
                psize->cx = sizePlaceHolder.cx;
            if (!fMaxHeight)
                psize->cy = cuvHeight.YGetPixelValue(pci,
                                        lParentHeight,
                                        pNode->GetFontHeightInTwips(&cuvHeight));
            else
                psize->cy = sizePlaceHolder.cy;
        }

        if (_fExpandAltText && pchAlt && *pchAlt && !fHasSize)
        {
            if (psize->cx < sizePlaceHolder.cx)
                psize->cx = sizePlaceHolder.cx;
            if (psize->cy < sizePlaceHolder.cy)
                psize->cy = sizePlaceHolder.cy;
        }

        if (psize->cx > 0)
            psize->cx += sizeBorderHVSpace2.cx + _lPadding[SIDE_LEFT] + _lPadding[SIDE_RIGHT];
        else
            psize->cx = sizeBorderHVSpace2.cx + _lPadding[SIDE_LEFT] + _lPadding[SIDE_RIGHT];
        if (psize->cy > 0)
            psize->cy += sizeBorderHVSpace2.cy + _lPadding[SIDE_TOP] + _lPadding[SIDE_BOTTOM];
        else
            psize->cy = sizeBorderHVSpace2.cy + _lPadding[SIDE_TOP] + _lPadding[SIDE_BOTTOM];


        // but before we can return we need to give a layoutBehavior a chance
        // to override the default natural sizing.
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            // There is a peer layout that wants to modify the natural sizing 
            POINT pt;

            pt.x = pt.y = 0;

        if (Layout())
            Layout()->DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                       pPH, pci, *psize, &pt, psize);
        }
    } // end else not delegateCalcSize
}

HRESULT
CImgHelper::CacheImage(XHDC hdc, CRect * prcDst, SIZE *pSize, DWORD dwFlags, ULONG ulState)
{
    HRESULT hr = S_OK;
    HDC     hdcMem = NULL;
    HBITMAP hbmSav = NULL;

    hdcMem = GetMemoryDC();
    if (hdcMem == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _xWidCache = prcDst->Width();
    _yHeiCache = prcDst->Height();

    _colorMode = GetDefaultColorMode();

    if (_hbmCache)
        DeleteObject(_hbmCache);

    _hbmCache = CreateCompatibleBitmap(hdc, _xWidCache, _yHeiCache);
    if (_hbmCache == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hbmSav = (HBITMAP) SelectObject(hdcMem, _hbmCache);

    if (!(ulState & IMGTRANS_OPAQUE))
        dwFlags |= DRAWIMAGE_NOTRANS;

    _pImgCtx->DrawEx(XHDC(hdcMem, NULL), prcDst, dwFlags);

Cleanup:
    if (hbmSav)
        SelectObject(hdcMem, hbmSav);
    if (hdcMem)
        ReleaseMemoryDC(hdcMem);

    RRETURN(hr);
}

void
CImgHelper::DrawCachedImage(XHDC hdc, CRect * prcDst, DWORD dwFlags, ULONG ulState)
{
    HDC     hdcMem = NULL;
    HBITMAP hbmSav = NULL;
    DWORD   dwRop;

    hdcMem = GetMemoryDC();
    if (hdcMem == NULL)
        goto Cleanup;

    hbmSav = (HBITMAP) SelectObject(hdcMem, _hbmCache);

    if (ulState & IMGTRANS_OPAQUE)
    {
        dwRop = SRCCOPY;
    }
    else
    {
        _pImgCtx->DrawEx(hdc, prcDst, dwFlags | DRAWIMAGE_MASKONLY);

        dwRop = SRCAND;
    }

    BitBlt(hdc, prcDst->left, prcDst->top,
        prcDst->Width(), prcDst->Height(),
        XHDC(hdcMem, NULL), prcDst->left, prcDst->top, dwRop);

Cleanup:
    if (hbmSav)
        SelectObject(hdcMem, hbmSav);
    if (hdcMem)
        ReleaseMemoryDC(hdcMem);
}

//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object. Note that this function does not save draw
//              info. Derived classes must override Draw() and save draw info
//               before calling this function.
//
//----------------------------------------------------------------------------

void
CImgHelper::Draw(CFormDrawInfo *pDI)
{
    ULONG       ulState;
    XHDC        hdc = pDI->GetDC(TRUE);
    CRect       rcDst(pDI->_rc);

    //
    //  image padding adjustments
    //
    rcDst.left   += _lPadding[SIDE_LEFT];
    rcDst.top    += _lPadding[SIDE_TOP];
    rcDst.right  -= _lPadding[SIDE_RIGHT];
    rcDst.bottom -= _lPadding[SIDE_BOTTOM];


#ifndef NO_AVI
    if (_pBitsCtx && _pVideoObj)
        ulState = _pBitsCtx->GetState();
    else
#endif
    if (_pImgCtx)
        ulState = _pImgCtx->GetState();
    else
        ulState = IMGLOAD_NOTLOADED;

    if (!(ulState & (IMGBITS_NONE | IMGLOAD_NOTLOADED | IMGLOAD_ERROR)) && _fHideForSecurity)
        ulState = IMGLOAD_ERROR;

    if (ulState & (IMGBITS_NONE | IMGLOAD_NOTLOADED | IMGLOAD_ERROR))
    {
        SIZE sizePrint;
        SIZE sizeGrab = {GRABSIZE, GRABSIZE};
        CDoc *pDoc = Doc();
        BOOL fMissing = !!(ulState & IMGLOAD_ERROR);

        if (   fMissing 
            || !GetImgCtx() 
            || !pDoc->_pOptionSettings->fShowImages 
            || pDoc->_pOptionSettings->fShowImagePlaceholder)
        {
            BOOL fPrint = Layout(pDI->GetLayoutContext())->ElementOwner()->GetMarkupPtr()->IsPrintMedia();
            const CCharFormat *pCF = GetFirstBranch()->GetCharFormat();
            COLORREF           fgColor = (pCF && pCF->_ccvTextColor.IsDefined()) ?
                                                    pCF->_ccvTextColor.GetColorRef()
                                                :   RGB(0, 0, 0);

            if (fPrint)        // For Printdoc, convert pixels to printer units
            {
                GetPlaceHolderBitmapSize(fMissing, &sizePrint);
                sizePrint.cx = pDI->DeviceFromDocPixelsX(sizePrint.cx);
                sizePrint.cy = pDI->DeviceFromDocPixelsY(sizePrint.cy);
                sizeGrab.cx = pDI->DeviceFromDocPixelsX(GRABSIZE);
                sizeGrab.cy = pDI->DeviceFromDocPixelsY(GRABSIZE);
            }

            DrawPlaceHolder(pDI, hdc, rcDst,
                (LPTSTR) GetAAalt(),
                _pOwner->GetMarkup()->GetCodePage(), pCF ? pCF->_lcid : 0, pDoc->_sBaselineFont,
                &sizeGrab, fMissing,
                fgColor, _pOwner->GetBackgroundColor(), fPrint ? &sizePrint : NULL, FALSE, pDI->DrawImageFlags());
        }
    }
    else if (_lCookie && _fIsInPlace)
    {
        CImgAnim * pImgAnim = GetImgAnim();

        if (pImgAnim)
            _pImgCtx->DrawFrame(hdc, pImgAnim->GetImgAnimState(_lCookie), &rcDst, NULL, NULL, pDI->DrawImageFlags());
    }
    else if (_pImgCtx)
    {
        DWORD dwFlags = pDI->DrawImageFlags();

        if (_fCache)
        {
            SIZE size;
            LONG xWidDst = rcDst.Width();
            LONG yHeiDst = rcDst.Height();

            _pImgCtx->GetState(FALSE, &size);

            if (    (ulState & IMGLOAD_COMPLETE)
                &&  (size.cx != xWidDst || size.cy != yHeiDst)
                &&  (size.cx != 1 || size.cy != 1))
            {
                HRESULT hr = S_OK;

                if (    _xWidCache != xWidDst
                    ||  _yHeiCache != yHeiDst
                    ||  _colorMode != GetDefaultColorMode())
                {
                    hr = CacheImage(hdc, &rcDst, &size, dwFlags, ulState);
                }

                if (hr == S_OK)
                {
                    DrawCachedImage(hdc, &rcDst, dwFlags, ulState);
                    return;
                }
            }
        }

        _pImgCtx->DrawEx(hdc, &rcDst, dwFlags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\imganim.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       imganim.cxx
//
//  Contents:   Implementation of CImgAnim and CAnimSync classes
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

DeclareTag(tagImgAnim, "CImgAnim", "Trace anim");

MtDefine(CAnimSync, PerThread, "CAnimSync")
MtDefine(CAnimSync_aryClients_pv, CAnimSync, "CAnimSync::_aryClients::_pv")
MtDefine(CImgAnim, PerThread, "CImgAnim")
MtDefine(CImgAnim_aryAnimSync_pv, CImgAnim, "CImgAnim::_aryAnimSync::_pv")

BOOL
CAnimSync::IsEmpty()
{
    return _aryClients.Size() == 0;
}

CImgCtx *
CAnimSync::GetImgCtx()
{
    Assert(!IsEmpty());

    if (!IsEmpty())
    {
        CLIENT * pClient = &_aryClients[0];
        CImgCtx * pImgCtx;

        pClient->pfnCallback(pClient->pvObj, ANIMSYNC_GETIMGCTX,
                             pClient->pvArg, (void **)&pImgCtx, NULL);

        return pImgCtx;
    }
    else
        return NULL;
}

HRESULT
CAnimSync::Register(void * pvObj, DWORD_PTR dwDocId, DWORD_PTR dwImgId,
                    CAnimSync::ASCALLBACK pfnCallback, void * pvArg)
{
    CLIENT client;

    if (IsEmpty())
    {
        CImgCtx * pImgCtx;

        _dwDocId = dwDocId;
        _dwImgId = dwImgId;
        _state = ANIMSTATE_PLAY;

        pfnCallback(pvObj, ANIMSYNC_GETIMGCTX, pvArg, (void **)&pImgCtx, NULL);

        if(!pImgCtx)
            return S_FALSE;
        pImgCtx->InitImgAnimState(&_imgAnimState);
    }

    client.pvObj       = pvObj;
    client.pfnCallback = pfnCallback;
    client.pvArg       = pvArg;

    RRETURN(_aryClients.AppendIndirect(&client));
}

void
CAnimSync::Unregister(void * pvObj)
{
    int cClients = _aryClients.Size(), iClient = 0;

    for ( ; iClient < cClients; iClient++)
    {
        if (_aryClients[iClient].pvObj == pvObj)
        {
            _aryClients.Delete(iClient);
            return;
        }
    }

    AssertSz(FALSE, "CAnimSync: Could not unregister object");
}

void
CAnimSync::OnTimer(DWORD *pdwFrameTimeMS)
{
    BOOL fInvalidated;
    CImgCtx * pImgCtx = GetImgCtx();

    _fInvalidated = FALSE;

    if (pImgCtx)
    {
        if (pImgCtx->NextFrame(&_imgAnimState, GetTickCount(), pdwFrameTimeMS))
        {
            int       cClients = _aryClients.Size();
            CLIENT *  pClient  = _aryClients;

            for ( ; cClients > 0; cClients--, pClient++ )
            {
                pClient->pfnCallback(pClient->pvObj, ANIMSYNC_TIMER,
                                     pClient->pvArg, (void **) &fInvalidated,
                                     &_imgAnimState);

                if (fInvalidated)
                    _fInvalidated = TRUE;

                TraceTag((tagImgAnim, "DrawFrame\n"));
            }

            if (_imgAnimState.fStop)
            {
                _state = ANIMSTATE_STOP;
                _imgAnimState.fStop = FALSE;
            }
        }
    }
    else
        *pdwFrameTimeMS = 0xFFFFFFFF;
}

void
CAnimSync::Invalidate()
{
    int       cClients = _aryClients.Size();
    CLIENT *  pClient  = _aryClients;
    BOOL      fInvalidated;

    _fInvalidated = FALSE;

    for ( ; cClients > 0; cClients--, pClient++ )
    {
        pClient->pfnCallback(pClient->pvObj, ANIMSYNC_INVALIDATE,
                             pClient->pvArg, (void **) &fInvalidated, NULL);

        if (fInvalidated)
            _fInvalidated = TRUE;
    }
}

void
CAnimSync::Update(HWND *pHwnd)
{
    int       cClients = _aryClients.Size();
    CLIENT *  pClient  = _aryClients;
    HWND      hwnd     = NULL;
    HWND      hwndPrev = *pHwnd;

    for ( ; cClients > 0; cClients--, pClient++ )
    {
        pClient->pfnCallback(pClient->pvObj, ANIMSYNC_GETHWND,
                             pClient->pvArg, (void **) &hwnd, NULL);

        if (hwnd && (hwnd != hwndPrev))
        {
            UpdateWindow(hwnd);
            hwndPrev = hwnd;
        }
    }

    if (hwnd)
        *pHwnd = hwnd;
}

void KillImgAnimTimerProc()
{
    KillTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM);  
}

void RestartImgAnimTimerProc()
{
    if (TLS(pImgAnim))
        TLS(pImgAnim)->OnTimer();
}

VOID CALLBACK ImgAnimTimerProc(HWND hWnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    Assert(TLS(pImgAnim));

    if (TLS(pImgAnim))
        TLS(pImgAnim)->OnTimer();
}

CImgAnim * GetImgAnim()
{
    return TLS(pImgAnim);
}

CImgAnim * CreateImgAnim()
{
    if (TLS(pImgAnim) == NULL)
    {
        TLS(pImgAnim) = new CImgAnim();
    }

    return TLS(pImgAnim);
}

void DeinitImgAnim(THREADSTATE *pts)
{
    delete pts->pImgAnim;
    pts->pImgAnim = NULL;
}

CImgAnim::CImgAnim()
    : _aryAnimSync(Mt(CImgAnim_aryAnimSync_pv))
{
    _dwInterval = 0xFFFFFFFF;
}

CImgAnim::~CImgAnim()
{
    KillTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM);
    Assert(_aryAnimSync.Size() == 0);
}

void
CImgAnim::SetInterval(DWORD dwInterval)
{
    _dwInterval = dwInterval;

    if (dwInterval == 0xFFFFFFFF)
    {
        KillTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM);
    }
    else
    {
        // Windows NT rounds the time up to 10.  If time is less
        // than 10, NT spews to the debugger.  Work around
        // this problem by rounding up to 10.

        if (dwInterval < 10)
            dwInterval = 10;

        SetTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM, dwInterval, &ImgAnimTimerProc);
    }
}

void
CImgAnim::SetAnimState(DWORD_PTR dwDocId, ANIMSTATE state)
{
    int cAnimSync;
    CAnimSync **ppAnimSync;
    BOOL fPlay = FALSE;

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (    *ppAnimSync
            && (*ppAnimSync)->_dwDocId == dwDocId
            && (*ppAnimSync)->_state != ANIMSTATE_STOP)
        {
            (*ppAnimSync)->_state = state;
            if (state == ANIMSTATE_PLAY)
                fPlay = TRUE;
        }
    }
    if (fPlay)
        OnTimer();
}

CAnimSync *
CImgAnim::GetAnimSync(LONG lCookie)
{
    Assert(lCookie > 0 && lCookie <= _aryAnimSync.Size());
    Assert(_aryAnimSync[lCookie - 1]);

    return _aryAnimSync[lCookie - 1];
}

IMGANIMSTATE *
CImgAnim::GetImgAnimState(LONG lCookie)
{
    return &(GetAnimSync(lCookie)->_imgAnimState);
}

HRESULT
CImgAnim::FindOrCreateAnimSync(DWORD_PTR dwDocId, DWORD_PTR dwImgId, LONG * plCookie, CAnimSync ** ppAnimSyncOut)
{
    int cAnimSync;
    CAnimSync **ppAnimSync;
    HRESULT hr = S_OK;

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (    *ppAnimSync
            && (*ppAnimSync)->_dwDocId == dwDocId
            && (*ppAnimSync)->_dwImgId == dwImgId)
        {
            *ppAnimSyncOut = *ppAnimSync;
            *plCookie = _aryAnimSync.Size() - cAnimSync + 1;
            goto Cleanup;
        }
    }

    *ppAnimSyncOut = new CAnimSync();
    if (!*ppAnimSyncOut)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _aryAnimSync.Append(*ppAnimSyncOut);
    if (hr)
        goto Cleanup;

    *plCookie = _aryAnimSync.Size();

Cleanup:
    RRETURN(hr);
}

HRESULT
CImgAnim::RegisterForAnim(void * pvObj, DWORD_PTR dwDocId, DWORD_PTR dwImgId,
                          CAnimSync::ASCALLBACK pfnCallback,
                          void * pvArg,
                          LONG * plCookie)
{
    HRESULT hr;
    CAnimSync * pAnimSync;

    hr = FindOrCreateAnimSync(dwDocId, dwImgId, plCookie, &pAnimSync);
    if (hr)
        goto Cleanup;

    hr = pAnimSync->Register(pvObj, dwDocId, dwImgId, pfnCallback, pvArg);
    if (hr)
    {
        if (pAnimSync->IsEmpty())
        {
            CleanupAnimSync(*plCookie);
        }
        *plCookie = 0;
        goto Cleanup;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

void
CImgAnim::CleanupAnimSync(LONG lCookie)
{
    Assert(lCookie > 0 && lCookie <= _aryAnimSync.Size());

    CAnimSync ** ppAnimSync = &_aryAnimSync[lCookie - 1];
    CAnimSync * pAnimSync = *ppAnimSync;

    if (pAnimSync && pAnimSync->IsEmpty())
    {
        delete pAnimSync;
        *ppAnimSync = NULL;

        if (lCookie == _aryAnimSync.Size())
        {
            for (; lCookie-- > 0 && *ppAnimSync == NULL; --ppAnimSync)
            {
                _aryAnimSync.Delete(lCookie);
            }
        }
    }
}

void
CImgAnim::UnregisterForAnim(void * pvObj, LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);

    if (pAnimSync)
    {
        pAnimSync->Unregister(pvObj);
        CleanupAnimSync(lCookie);
    }
}

void
CImgAnim::OnTimer()
{
    int cAnimSync;
    CAnimSync **ppAnimSync;
    DWORD dwInterval = 0xFFFFFFFF;
    DWORD dwFrameTimeMS;
    HWND hwnd = NULL;

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (*ppAnimSync && ((*ppAnimSync)->_state == ANIMSTATE_PLAY))
        {
            (*ppAnimSync)->OnTimer(&dwFrameTimeMS);

            if (dwFrameTimeMS < dwInterval)
                dwInterval = dwFrameTimeMS;
        }
    }

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (*ppAnimSync && ((*ppAnimSync)->_state == ANIMSTATE_PLAY) && (*ppAnimSync)->_fInvalidated)
        {
            (*ppAnimSync)->Update(&hwnd);
        }
    }

    SetInterval(dwInterval);
}

void
CImgAnim::ProgAnim(LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);
    DWORD dwFrameTimeMS;

    if (pAnimSync && (pAnimSync->_state == ANIMSTATE_PLAY))
    {
        CImgCtx * pImgCtx = pAnimSync->GetImgCtx();

        if (pImgCtx)
        {
            if (pImgCtx->NextFrame(GetImgAnimState(lCookie), GetTickCount(), &dwFrameTimeMS))
            {
                pAnimSync->Invalidate();
            }

            if (dwFrameTimeMS < _dwInterval)
                SetInterval(dwFrameTimeMS);
        }
    }
}

void
CImgAnim::StopAnim(LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);

    if (pAnimSync)
    {
        pAnimSync->_state = ANIMSTATE_STOP;
    }
}

void
CImgAnim::StartAnim(LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);

    if (pAnimSync && (pAnimSync->_state != ANIMSTATE_PLAY))
    {
        pAnimSync->_state = ANIMSTATE_PLAY;
        OnTimer();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\imgsize.cxx ===
//+------------------------------------------------------------------------
//
//  File:       imgsize.cxx
//
//  Contents:   Image size cache
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "shfolder.h"

#ifdef UNIX
#ifndef X_MAINWIN_H_
#define X_MAINWIN_H_
#include <mainwin.h>
#endif
#endif

#ifdef _MAC
#include <folders.h>
extern "C" {
Boolean _CopySzToSt(const char* sz, StringPtr st, short cchSt);
void _FSpFormat(const FSSpec* pfss, char* szBuffer);
}
#endif

struct CACHE_ENTRY
{
    DWORD dwHash;
    WORD  wWidth;
    WORD  wHeight;
};

struct CACHE_FILE
{
    DWORD dwMagic;
    DWORD dwVersion;
    DWORD dwHit;
    DWORD dwMiss;
    CACHE_ENTRY aCacheEntry[2046];
};
 
static HANDLE s_hCacheFileMapping;
static CACHE_FILE *s_pCacheFile;
static BOOL   s_fInitializationTried;

#define MAGIC       0xCAC8EF17
#define OBJ_NAME(x) "MSIMGSIZECache" #x
#define FILE_NAME   "MSIMGSIZ.DAT"

//+------------------------------------------------------------------------
//
//  VERSION     Increment this number with each file format change.
//
//-------------------------------------------------------------------------

#define VERSION 1

//+------------------------------------------------------------------------
//
//  Function:   InitImageSizeCache
//
//  Synopsis:   Open the image size cache file.  Create and initialize it
//              if required. 
//
//-------------------------------------------------------------------------

BOOL
InitImageSizeCache()
{
    BOOL   fInitialize = FALSE;
    HANDLE hMutex = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CACHE_FILE * pCacheFile;

    if (s_fInitializationTried)
        return s_pCacheFile != NULL;

    s_fInitializationTried = TRUE;

#ifdef WIN16
//    MessageBox(NULL, "Need to implement InitImageSizeCache", "BUGWIN16", MB_OK);
#else
    hMutex = CreateMutexA(NULL, FALSE, OBJ_NAME(Mutex));
    if (!hMutex)
        goto Cleanup;

    if (WaitForSingleObject(hMutex, 4000) != WAIT_OBJECT_0)
        goto Cleanup;

    // Did another thread initialize when we were not looking?

    if (s_pCacheFile)
        goto Cleanup;

    // Open or create new file mapping.

    s_hCacheFileMapping = OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, OBJ_NAME(Map));
    if (s_hCacheFileMapping)
    {
        BOOL    fVersionMismatch = FALSE;
        pCacheFile = (CACHE_FILE *)MapViewOfFile(
                    s_hCacheFileMapping, 
                    FILE_MAP_ALL_ACCESS,            // access
                    0,                              // offset low
                    0,                              // offset high
                    sizeof(CACHE_FILE));            // number of bytes to map

        if (!pCacheFile)
            goto Cleanup;

        // Punt if some other version of Trident has the file open.

        __try
        {
            fVersionMismatch =      pCacheFile->dwMagic != MAGIC
                                ||  pCacheFile->dwVersion != VERSION;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            goto Cleanup;
        }

        if (fVersionMismatch)
            goto Cleanup;
    }
    else
    {
        // File mapping does not exist.  Open or create file.

        HRESULT hr = S_OK;
        char achBuf[MAX_PATH + sizeof(FILE_NAME) +1];
        int  cch;
#ifdef _MAC
        long    foundDirID;
        short   foundVRefNum;
        FSSpec  FileSpec;

        achBuf[0] = NULL;

        FindFolder(kOnSystemDisk, kSystemFolderType, false, &foundVRefNum, &foundDirID);
        FileSpec.vRefNum = foundVRefNum;
        FileSpec.parID = foundDirID;
        _CopySzToSt(FILE_NAME, FileSpec.name, 64);

        _FSpFormat(&FileSpec, achBuf);
#else
#ifdef UNIX
        cch = MwGetUserWindowsDirectoryA(achBuf, MAX_PATH);
#else
        hr = SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, achBuf);
        if (hr)
            goto Cleanup;

        strcat(achBuf, "\\Microsoft");
        if (!PathFileExistsA(achBuf) && !CreateDirectoryA(achBuf, NULL))
        {
            goto Cleanup;
        }
        strcat(achBuf, "\\Internet Explorer");
        if (!PathFileExistsA(achBuf) && !CreateDirectoryA(achBuf, NULL))
        {
            goto Cleanup;
        }

        cch = strlen(achBuf);
#endif
        if (cch == 0)
            goto Cleanup;

        if (achBuf[cch - 1] != FILENAME_SEPARATOR)
            achBuf[cch++] = FILENAME_SEPARATOR;
        strcpy(&achBuf[cch], FILE_NAME);
#endif // _MAC

        hFile = CreateFileA(
            achBuf,
            GENERIC_READ | GENERIC_WRITE,       // access mode
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share mode
            NULL,                               // security
            OPEN_ALWAYS,                        // disposition
            0,                                  // flags and attributes
            NULL);                              // template file

        if (hFile == INVALID_HANDLE_VALUE)
            goto Cleanup;

        // Do we need to initialize the file?

        if (GetLastError() != ERROR_ALREADY_EXISTS)
            fInitialize = TRUE;
      
        if (GetFileSize(hFile, NULL) != sizeof(CACHE_FILE))
        {
            fInitialize = TRUE;
            SetFilePointer(hFile, sizeof(CACHE_FILE), NULL, FILE_BEGIN);
            SetEndOfFile(hFile);
        }

        // Create the mapping.

        s_hCacheFileMapping = CreateFileMappingA(
                hFile,                          // file
                NULL,                           // security
                PAGE_READWRITE,                 // protect
                0,                              // size low
                0,                              // size high
                OBJ_NAME(Map));                 // name

        if (!s_hCacheFileMapping)
            goto Cleanup;

        // Map view of file.

        pCacheFile = (CACHE_FILE *)MapViewOfFile(
                    s_hCacheFileMapping, 
                    FILE_MAP_ALL_ACCESS,            // access
                    0,                              // offset low
                    0,                              // offset high
                    sizeof(CACHE_FILE));            // number of bytes to map

        if (!pCacheFile)
            goto Cleanup;

        // Reset the contents of the file if we are opening it for the
        // first time or if the file contents do not look right.

        __try
        {
            if (fInitialize ||
                pCacheFile->dwMagic != MAGIC ||
                pCacheFile->dwVersion != VERSION)
            {
                memset(pCacheFile, 0, sizeof(CACHE_FILE));
                pCacheFile->dwMagic = MAGIC;
                pCacheFile->dwVersion = VERSION;
                FlushViewOfFile(pCacheFile, sizeof(CACHE_FILE));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

    }
    
    s_pCacheFile = pCacheFile;

Cleanup:
    if (!s_pCacheFile && s_hCacheFileMapping)
    {
        CloseHandle(s_hCacheFileMapping);
        s_hCacheFileMapping = NULL;
    }

    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }  

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
#endif // ndef WIN16

    return s_pCacheFile != NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   DeinitImageSizeCache
//
//  Synopsis:   Undo action of InitImageSizeCache 
//
//-------------------------------------------------------------------------

void
DeinitImageSizeCache()
{
#ifndef WIN16
    if (s_pCacheFile)
    {
        FlushViewOfFile(s_pCacheFile, sizeof(CACHE_FILE));
        UnmapViewOfFile(s_pCacheFile);
    }
#endif // ndef WIN16
    if (s_hCacheFileMapping)
    {
        CloseHandle(s_hCacheFileMapping);
    }

    s_pCacheFile = NULL;
    s_hCacheFileMapping = NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   HashData
//
//  Synopsis:   Compute hash of bytes.
//
//-------------------------------------------------------------------------

// TODO (garybu) Hash function is duplicated. Should export common fn from shlwapi.

const static BYTE Translate[256] =
{
    1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
    87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
    49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
    12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
    176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
    178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
    102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
    166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
    121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
    193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
    6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
    84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
    249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
    230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
    44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
    163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
};

#define HashData MSHTMLHashData // avoid conflict with shlwapi
void HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash)
{
    DWORD i, j;
    //  seed the hash
    for (i = cbHash; i-- > 0;)
        pbHash[i] = (BYTE) i;

    //  do the hash
    for (j = cbData; j-- > 0;)
    {
        for (i = cbHash; i-- > 0;)
            pbHash[i] = Translate[pbHash[i] ^ pbData[j]];
    }
}

//+------------------------------------------------------------------------
//
//  Function:   GetCachedImageSize
//
//  Synopsis:   Get cached image size, returns FALSE if not found. 
//
//-------------------------------------------------------------------------

BOOL
GetCachedImageSize(LPCTSTR pchURL, SIZE *psize)
{
    CACHE_ENTRY *pCacheEntry;

    struct { DWORD dw; WORD  w; } Hash;

    if (!InitImageSizeCache())
        return FALSE;

    HashData((BYTE *)pchURL, _tcslen(pchURL) * sizeof(TCHAR), (BYTE *)&Hash, sizeof(Hash));
    if (Hash.dw == 0) Hash.dw = 1;

    pCacheEntry = &s_pCacheFile->aCacheEntry[Hash.w % ARRAY_SIZE(s_pCacheFile->aCacheEntry)];

    // The following chunk of code can read bad values because the cache memory 
    // is shared by multiple processes.  We don't bother with the expense
    // of a mutex because we can tolerate fetching a bad image size.

    //
    // read / write to/from Maped file can raise exceptions
    //
    __try
    {
        if (pCacheEntry->dwHash == Hash.dw)
        {
            psize->cx = pCacheEntry->wWidth;
            psize->cy = pCacheEntry->wHeight;
            #if DBG==1
                s_pCacheFile->dwHit += 1;
            #endif
            return TRUE;
        }
    #if DBG==1
        s_pCacheFile->dwMiss += 1;
    #endif
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return FALSE;
}


//+------------------------------------------------------------------------
//
//  Function:   SetCachedImageSize
//
//  Synopsis:   Save image size for future use. 
//
//-------------------------------------------------------------------------

void
SetCachedImageSize(LPCTSTR pchURL, SIZE size)
{
    CACHE_ENTRY *pCacheEntry;

    struct { DWORD dw; WORD  w; } Hash;

    if (!InitImageSizeCache())
        return;

    HashData((BYTE *)pchURL, _tcslen(pchURL) * sizeof(TCHAR), (BYTE *)&Hash, sizeof(Hash));
    if (Hash.dw == 0) Hash.dw = 1;
    pCacheEntry = &s_pCacheFile->aCacheEntry[Hash.w % ARRAY_SIZE(s_pCacheFile->aCacheEntry)];

    // The following chunk of code can confuse GetCachedImageSize because
    // the cache memory is shared by multiple processes.  We don't 
    // bother with the expense of a mutex because we can tolerate fetching a 
    // bad image size.

    //
    // read / write to/from Maped file can raise exceptions
    //

    __try
    {
        pCacheEntry->wWidth = size.cx;
        pCacheEntry->wHeight = size.cy;
        pCacheEntry->dwHash = Hash.dw;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\inputbtn.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inputbtn.cxx
//
//  Contents:   InputBtn element class, etc..
//
//  Classes:    CButton, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_BTNLYT_H_
#define X_BTNLYT_H_
#include <btnlyt.hxx>
#endif

#define _cxx_
#include "inputbtn.hdl"

MtDefine(CButton, Elements, "CButton")

const CElement::CLASSDESC CButton::s_classdescButtonReset =
{
    {
        &CLSID_HTMLButtonElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_CANCEL |            // _dwFlags, button/reset is a cancel button
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |   // don't scroll a button
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLButtonElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLButtonElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};

const CElement::CLASSDESC CButton::s_classdescButtonSubmit =
{
    {
        &CLSID_HTMLButtonElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_DEFAULT |           // _dwFlags, button/submit is a default button
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |   // don't scroll a button
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLButtonElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLButtonElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};

const CElement::CLASSDESC CButton::s_classdescTagButton =
{
    {
        &CLSID_HTMLButtonElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |    // _dwFlags
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |   // don't scroll a button
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLButtonElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLButtonElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};

const CBase::CLASSDESC *
CButton::GetClassDesc() const
{
    switch (GetAAtype())
    {
        case htmlInputReset:
            return (CBase::CLASSDESC *)&s_classdescButtonReset;

        case htmlInputSubmit:
            return (CBase::CLASSDESC *)&s_classdescButtonSubmit;

        default:
            return (CBase::CLASSDESC *)&s_classdescTagButton;
    }
}

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

const CDBindMethods *
CButton::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}
#endif

HRESULT
CButton::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CButton(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

HRESULT
CButton::Init2(CInit2Context * pContext)
{
    HRESULT     hr = S_OK;
    htmlInput   type = GetAAtype();

    if (type!=htmlInputReset  && type!=htmlInputSubmit)
    {
        SetAAtype(htmlInputButton);
    }

    hr = THR(super::Init2(pContext));
    if (!OK(hr))
        goto Cleanup;

Cleanup:

    RRETURN1(hr, S_INCOMPLETE);
}



 //+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if checked
//              (name && value pair)
//
//  Returns:    S_OK if successful
//              S_FALSE if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CButton::GetSubmitInfo(CPostData * pSubmitData)
{
    CStr            cstrValue;
    const TCHAR *   pchName = GetAAsubmitname();
    HRESULT         hr      = GetSubmitValueHelper(&cstrValue);
    if (hr)
        goto Cleanup;


    hr = THR(pSubmitData->AppendNameValuePair(pchName, cstrValue, GetMarkup()));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CButton::GetEnabled
//
//  Synopsis:   return not disabled
//
//----------------------------------------------------------------------------

STDMETHODIMP
CButton::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = !GetAAdisabled();
    return S_OK;
}

DWORD
CButton::GetNonThemedBorderInfo(
    CDocInfo * pdci,
    CBorderInfo *pborderinfo,
    BOOL fAll,
    BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD   nBorders;

    pborderinfo->abStyles[SIDE_TOP]    =
    pborderinfo->abStyles[SIDE_RIGHT]  =
    pborderinfo->abStyles[SIDE_BOTTOM] =
    pborderinfo->abStyles[SIDE_LEFT]   = BTN_PRESSED(_wBtnStatus)
                                                ? fmBorderStyleSunken
                                                : fmBorderStyleRaised;
    nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);

    {
        int xyFlatX = 1;
        int xyFlatY = 1;
        if (pdci)
        {
            xyFlatX = pdci->DeviceFromDocPixelsX(xyFlatX);
            xyFlatY = pdci->DeviceFromDocPixelsY(xyFlatY);
        }
        pborderinfo->aiWidths[SIDE_TOP]    += xyFlatY;
        pborderinfo->aiWidths[SIDE_RIGHT]  += xyFlatX;
        pborderinfo->aiWidths[SIDE_BOTTOM] += xyFlatY;
        pborderinfo->aiWidths[SIDE_LEFT]   += xyFlatX;
    }

    if (!fAllPhysical && HasVerticalLayoutFlow())
    {
        pborderinfo->FlipBorderInfo();
    }
    return nBorders;
}

DWORD
CButton::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    HTHEME  hTheme = GetTheme(THEME_BUTTON);    
    RECT rc;

    if (hTheme)
    {
        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rc))
        {            
            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left);
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom);

            return(DISPNODEBORDER_SIMPLE);
        }

            
    }

    return GetNonThemedBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
}


void
CButton::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_SETFOCUS:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        Layout()->SetDisplayWordWrap(FALSE);
        if (GetAAtype() == htmlInputSubmit)
        {
            SetDefaultElem();
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if (GetAAtype() == htmlInputSubmit)
        {
            if( pNF->DataAsDWORD() & EXITTREE_DESTROY )
            {
                Doc()->_pElemDefault = NULL;
            }
            else
            {
                SetDefaultElem(TRUE);
            }
        }
        break;
    } 
}


HRESULT
CButton::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr;

    hr = THR(super::YieldCurrency(pElemNew));
    if (hr)
        goto Cleanup;

    _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_HASFOCUS);

    // IE bug 33042, see comments in CButtonLayout::GetFocusShape
    if (GetTheme(THEME_BUTTON))
        GetUpdatedLayout(GUL_USEFIRSTLAYOUT)->GetElementDispNode(this)->Invalidate();


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CButton::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CButton::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    RRETURN1(Layout()->GetFocusShape(lSubDivision, pdci, ppShape), S_FALSE);
}



HRESULT BUGCALL
CButton::HandleMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;

    if (!CanHandleMessage())
        goto Cleanup;

    if (!IsEditable(TRUE))
    {
        if (!IsEnabled())
        {
            goto Cleanup;
        }

        hr = BtnHandleMessage(pMessage);
        if (hr == S_FALSE)
        {
            hr = super::HandleMessage(pMessage);
        }
    }
    else
    {
        if (pMessage->message == WM_CONTEXTMENU)
        {
            hr = THR(OnContextMenu(
                    (short)LOWORD(pMessage->lParam),
                    (short)HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
        }
        if (hr == S_FALSE)
            hr = super::HandleMessage(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}



HRESULT
CButton::ClickAction(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CFormElement *  pForm;

    pForm = GetParentForm();
    if (pForm)
    {
        switch (GetAAtype())
        {
            case htmlInputReset:
                pForm->DoReset(TRUE);
                break;

            case htmlInputSubmit:
                pForm->DoSubmit(this, TRUE);
                break;
        }
    }
    RRETURN1(hr, S_FALSE);
}

int
CButton::GetThemeState()
{
    if (!IsEnabled())
    {
        return PBS_DISABLED;
    }
    else if (Pressed())
    {
        return PBS_PRESSED;
    }
    else if (MouseOver())
    {
        return PBS_HOT;
    }
    else
    {
        CDoc *pDoc = Doc();

        if (    pDoc 
            &&  _fDefault
            &&  pDoc->HasFocus())
        {
            return PBS_DEFAULTED;
        }
    }
    return PBS_NORMAL;
}


HRESULT
CButton::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;
    LOGFONT lf;
    CUnitValue uvBorder;
    DWORD dwRawValue;
    BYTE i;
    CDoc * pDoc = Doc();
    CUnitValue cuvBorderWidth;
    HTHEME hTheme = GetMarkup()->GetTheme(THEME_BUTTON);
    
    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    // Set default color and let super override it with the use style
    pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_BTNTEXT);
    pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_BTNFACE);

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->_cf()._bCursorIdx = styleCursorAuto;

    DefaultFontInfoFromCodePage( GetMarkup()->GetCodePage(), &lf, pDoc );
    pCFI->_cf()._wWeight = 400;
    pCFI->_cf()._yHeight = 200; // 10 * 20 twips NS compatibility

    pCFI->_cf()._fBold = FALSE;
    pCFI->_cf()._bCharSet = lf.lfCharSet;
    pCFI->_cf().SetFaceName( lf.lfFaceName);
    pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);
    if (pCFI->_cf().NeedAtFont())
    {
        ApplyAtFontFace(&pCFI->_cf(), pDoc, GetMarkup());
    }

    pCFI->_bBlockAlign     = htmlBlockAlignCenter;

    // Border info
    uvBorder.SetValue( 2, CUnitValue::UNIT_PIXELS );
    dwRawValue = uvBorder.GetRawValue();

    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_BTNFACE);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

    // Since its the same value to which X and Y are being set, logical/physical does not matter here.
    pCFI->_ff().SetOverflowX(styleOverflowHidden);
    pCFI->_ff().SetOverflowY(styleOverflowHidden);

    if (pCFI->_cf()._fVisibilityHidden || pCFI->_cf()._fDisplayNone)
        _fButtonWasHidden = TRUE;

    cuvBorderWidth.SetRawValue(dwRawValue);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, cuvBorderWidth);
    }

    pCFI->_ff()._bd._bBorderSoftEdges = TRUE;
    // End Border info

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;
    
    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // the control is themed
    {        
        // set theme defaults for properties not already set

        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, BP_PUSHBUTTON, PBS_NORMAL, TMT_FONT, &lf))
        {
            long twips;

            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick( lf.lfHeight, TWIPS_PER_INCH, g_sizePixelsPerInch.cy );

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }
    }

    pCFI->_cf().SetHeightInNonscalingTwips( pCFI->_pcf->_yHeight );

    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

HRESULT
CButton::put_status(VARIANT status)
{
    switch(status.vt)
    {
    case VT_NULL:
        _vStatus.vt = VT_NULL;
        break;
    case VT_BOOL:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = V_BOOL(&status);
        break;
    default:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = VB_TRUE;
    }

    Verify(S_OK==OnPropertyChange(DISPID_CButton_status, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCButtonstatus));

    RRETURN(S_OK);
}

HRESULT
CButton::get_status(VARIANT * pStatus)
{
    HRESULT hr = S_OK;

    if ( !pStatus )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_vStatus.vt==VT_NULL)
    {
        pStatus->vt = VT_NULL;
    }
    else
    {
        pStatus->vt = VT_BOOL;
        V_BOOL(pStatus) = V_BOOL(&_vStatus);
    }
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CButton::GetSubmitValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;
    BSTR    bStrValue;

    hr = THR(GetText(&bStrValue, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));
    if (hr)
        goto Cleanup;

    Assert(pstr);
    hr = pstr->SetBSTR(bStrValue);
    FormsFreeString(bStrValue);

Cleanup:
    RRETURN(hr);
}

HRESULT
CButton::GetValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;
    BSTR    bStrValue = NULL;

    hr = THR(GetText(&bStrValue, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));
    if (hr)
        goto Cleanup;

    // HACK: if it is an empty string or null, see if value is set as an expando attribute
    // since value is only a property and not an attribute, it gets set as an expando
    // declaratively.
    if ((!bStrValue || !*bStrValue) && _pAA)
    {
        DISPID dispid;
        hr = THR(GetExpandoDISPID(_T("value"), &dispid, 0));
        if (!hr)
        {
            LPTSTR pchValue = NULL;
            _pAA->FindString(dispid, (LPCTSTR *)&pchValue, CAttrValue::AA_Expando);
            pstr->Set(pchValue);
            goto Cleanup;
        }
    }

    Assert(pstr);
    hr = pstr->SetBSTR(bStrValue);

Cleanup:
    FormsFreeString(bStrValue);
    RRETURN(hr);
}

HRESULT
CButton::SetValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;
    
    Assert( pstr );

    hr = THR( Inject( Inside, TRUE, *pstr, pstr->Length() ) );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CButton::createTextRange
//
//----------------------------------------------------------------------------

HRESULT
CButton::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT hr = S_OK;

    hr = THR( EnsureInMarkup() );
    
    if (hr)
        goto Cleanup;

    hr = THR( GetMarkup()->createTextRange( ppDisp, this ) );
    
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\inputtxt.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inputtxt.cxx
//
//  Contents:   InputTxt element class, etc..
//
//  Classes:    CInput, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_CKBOXLYT_HXX_
#define X_CKBOXLYT_HXX_
#include "ckboxlyt.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif


#define _cxx_
#include "inputtxt.hdl"

DeclareTag(tagAllowMorphing, "CInput", "Allow input one time morphing");

MtDefine(CInput, Elements, "CInput")
MtDefine(CInputSetValueHelperReal, Locals, "CInput::SetValueHelperReal (temp)")
MtDefine(CRadioGroupAry, Elements, "CRadioGroupAry")
MtDefine(CRadioGroupAry_pv, CRadioGroupAry, "CRadioGroupAry::_pv")

HRESULT GetCallerCommandTarget (CBase *pBase, IServiceProvider *pSP, BOOL fFirstScriptSite, IOleCommandTarget **ppCommandTarget);

//
// This is a generic creation function for our input controls
// parser.cpp should point to this function for ETAG_INPUT
//

HRESULT
CreateInputElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement)
{
    HRESULT         hr = S_OK;
    long            iType;
    TCHAR *         pchType;

    Assert(pht->Is(ETAG_INPUT));

    // Fetch type from the attributes and map to enum. Default to input text.

    if (!pht->ValFromName(_T("type"), &pchType) ||
            FAILED(s_enumdeschtmlInput.EnumFromString(pchType, &iType, FALSE)))
    {
        iType = htmlInputText;
    }

    // Map input type enum to create function.

    switch (iType)
    {
        default:
            // Convert bogus Input types to default. These enum values exist only
            // because TEXTAREA, HTMLAREA and SELECT support the type attribute
            // and use these values to specify the type. These values have no
            // meaning when used with an INPUT tag and are mapped to the default
            // value of htmlInputText.
            iType= htmlInputText;
            // fall through
        case htmlInputReset:
        case htmlInputSubmit:
        case htmlInputButton:
        case htmlInputHidden:
        case htmlInputPassword:
        case htmlInputText:
        case htmlInputFile:
        case htmlInputImage:
        case htmlInputRadio:
        case htmlInputCheckbox:
            hr = THR(CInput::CreateElement(pht, pDoc, ppElement, (htmlInput)iType));
            if (hr == S_OK)
                DYNCAST(CInput, *ppElement)->_fScriptCreated = pht->IsDynamic();
            break;
    }

    RRETURN(hr);
}


CElement::ACCELS CInput::s_AccelsInputTxtRun    = CElement::ACCELS (NULL, IDR_ACCELS_INPUTTXT_RUN);

static const TCHAR s_achUtf8[] = TEXT("utf-8");

// Input Class Decriptor
const CElement::CLASSDESC CInput::s_classdescHidden =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,   // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement, // _pfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescPassword =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement, // _pfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescText =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement, // _pfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescBtn =
{
    {
        &CLSID_HTMLInputElement,      // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_NOANCESTORCLICK|
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,       // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                    // _pAccelsRun
};

// Submit Class Decriptor

const CElement::CLASSDESC CInput::s_classdescSubmit =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                                // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                           // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_DEFAULT |             // input/submit is the default button
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                    // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                  // _pAccelsRun
};

// Reset Class Decriptor

const CElement::CLASSDESC CInput::s_classdescReset =
{
    {
        &CLSID_HTMLInputElement,     // _pclsid
        0,                                 // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                    // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                            // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_CANCEL |               // input/reset is the cancel button
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,      // _piidDispinterface
        &s_apHdlDescs,                     // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                   // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescFile =
{
    {
        &CLSID_HTMLInputElement,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_OMREADONLY |        // block OM from accessing value
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _apfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescCheckbox =
{
    {
        &CLSID_HTMLInputElement,      // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,          // _dwFlags
        &IID_IHTMLInputElement,       // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  //_apfnTearOff
    NULL                                     // _pAccelsRun
};


const CElement::CLASSDESC CInput::s_classdescImage =
{
    {
        &CLSID_HTMLInputElement,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_DEFAULT |           // input/image can act as default button -#3397
        ELEMENTDESC_EXBORDRINMOV,       // _dwFlags
        &IID_IHTMLInputElement,    // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                // _pAccelsRun
};
   
static const IID * s_aInputInterface[] =   {
            &IID_IHTMLInputTextElement,         //    htmlInputNotSet = 0,
            &IID_IHTMLInputButtonElement,       //    htmlInputButton = 1,
            &IID_IHTMLOptionButtonElement,      //    htmlInputCheckbox = 2,
            &IID_IHTMLInputFileElement,         //    htmlInputFile = 3,
            &IID_IHTMLInputHiddenElement,       //    htmlInputHidden = 4,
            &IID_IHTMLInputImage,               //    htmlInputImage = 5,
            &IID_IHTMLInputTextElement,         //    htmlInputPassword = 6,
            &IID_IHTMLOptionButtonElement,      //    htmlInputRadio = 7,
            &IID_IHTMLInputButtonElement,       //    htmlInputReset = 8,
            NULL,                               //    htmlInputSelectOne = 9,
            NULL,                               //    htmlInputSelectMultiple = 10,
            &IID_IHTMLInputButtonElement,       //    htmlInputSubmit = 11,
            &IID_IHTMLInputTextElement,         //    htmlInputText = 12,
            NULL,                               //    htmlInputTextarea = 13,
            NULL,                               //    htmlInputRichtext = 14,
            };

CInput::CInput (ELEMENT_TAG etag, CDoc *pDoc, htmlInput type)
: CSite(etag, pDoc)
{
    _fHasInitValue  = FALSE;
    _fInSave        = FALSE;
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    SetType(type);
    SetTypeAtCreate(type);
    switch (type)
    {
    case htmlInputImage:
        _fNoUIActivateInDesign = TRUE;
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
        _fActsLikeButton = TRUE;
        break;
    }
    _icfButton = -1;
}


#ifndef NO_PROPERTY_PAGE
const CLSID * const CInput::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

extern class CFontCache & fc();

BOOL
IsTypeMultiline(htmlInput type)
{
    switch (type)
    {
    case htmlInputButton:
    case htmlInputSubmit:
    case htmlInputReset:
    case htmlInputHidden:
        return TRUE;
    default:
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:
//
//-------------------------------------------------------------------------

HRESULT
CInput::Init()
{
    HRESULT hr = S_OK;

    if (GetType() == htmlInputImage)
    {
        _pImage = new CImgHelper(Doc(), this, TRUE);

        if (!_pImage)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = super::Init();

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;
    CMarkup * pSlaveMarkup = NULL;

    htmlInput           type = GetType();

    // Convert bogus Input types to default. These enum values exist only
    // because TEXTAREA, HTMLAREA and SELECT support the type attribute
    // and use these values to specify the type. These values have no
    // meaning when used with an INPUT tag and are mapped to the default
    // value of htmlInputText.
    if (GetAAtype() != type)
    {
        Assert(type == htmlInputText);
        hr = THR(SetAAtype(type));
        if (hr)
            goto Cleanup;
    }

    switch(type)
    {
    case    htmlInputRadio:

        // Defer clearing the other radio buttons in the group. This would
        // prevent the collections from being accessed prematurely in
        // SetChecked() called from super::Init2(). The clearing would
        // happen in AddToCollections().

        _fDeferClearGroup = TRUE;

        // fall through

    case    htmlInputCheckbox:

        hr = THR(super::Init2(pContext));
        if (type == htmlInputRadio)
        {
            _fDeferClearGroup = FALSE;
        }
        goto Cleanup;

    case    htmlInputImage:
            RRETURN1 (super::Init2(pContext), S_INCOMPLETE);
    }

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    // create inner element
    hr = THR(CreateSlave());
    if (hr)
        goto Cleanup;

    if (HasSlavePtr())
    {
        pSlaveMarkup = GetSlavePtr()->GetMarkup();
        if (pSlaveMarkup)
            pSlaveMarkup->_fNoUndoInfo = TRUE;
    }

    // Set the default value for the control, if any. The default value
    // is specified using the 'value' attribute. If none was specified,
    // submit and reset buttons have their own implicit default values.

    hr = PrivateInit2();
    if (hr)
        goto Cleanup;

    if (pSlaveMarkup)
        pSlaveMarkup->_fNoUndoInfo = FALSE;

#ifdef  NEVER
    if (_fHasInitValue)
    {
        hr = SetValueHelper((TCHAR *) _cstrDefaultValue, _cstrDefaultValue.Length(), FALSE);
        if (hr)
            goto Cleanup;
    }
    else
    {
        UINT    uiBtnDefault    = IDS_BUTTONCAPTION_SUBMIT;
        TCHAR   pszCaption[128];
        int     c;
        
        switch (type)
        {
        case htmlInputReset:
            uiBtnDefault = IDS_BUTTONCAPTION_RESET;
            // fall through
        case htmlInputSubmit:
            c = LoadString(GetResourceHInst(),
                           uiBtnDefault, pszCaption, ARRAY_SIZE(pszCaption));
            if (c)
            {
                hr = THR(SetValueHelper(pszCaption, c));
                if (hr)
                    goto Cleanup;
            }
            break;
        }
    }

    _fTextChanged = FALSE;
#endif

Cleanup:

    RRETURN1(hr, S_INCOMPLETE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CInput::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    HRESULT     hr = S_OK;
    MSOCMD *    pCmd = & rgCmds[0];
    ULONG       cmdID;
    htmlInput   type = GetType();
    
    Assert(Doc());
    Assert(!pCmd->cmdf);

    cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );

    if (type == htmlInputImage)
    {
        Assert(_pImage);
        hr = _pImage->QueryStatus(
                    pguidCmdGroup,
                    1,
                    pCmd,
                    pcmdtext);
        if (!pCmd->cmdf)
        {
            hr = super::QueryStatus(pguidCmdGroup,
                                     1,
                                     pCmd,
                                     pcmdtext);
        }
        RRETURN_NOTRACE(hr);
    }
    else if (IsOptionButton())
    {
        RRETURN_NOTRACE(super::QueryStatus(
            pguidCmdGroup,
            1,
            pCmd,
            pcmdtext));
    }

    switch (cmdID)
    {
    case IDM_COPY:
    case IDM_CUT:
        if (type == htmlInputPassword)
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            return S_OK;
        }
        break;

    case IDM_INSERTOBJECT:
        // Don't allow objects to be inserted in input controls
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        return S_OK;

    case IDM_SELECTALL:
        // Button text should not be selectable in browse mode
        if (!IsEditable(TRUE) && IsButton())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            return S_OK;
        }
        break;

    case IDM_PASTE:
        if (type == htmlInputFile)
        {
            IOleCommandTarget * pCT = NULL;
            
            GetCallerCommandTarget(this, NULL, FALSE, &pCT);
            if (pCT)
            {
                CVariant    Var;

                //
                // If this is a trusted doc, allow it to go through.
                //
                
                pCT->Exec(
                        &CGID_ScriptSite,
                        CMDID_SCRIPTSITE_TRUSTEDDOC,
                        0,
                        NULL,
                        &Var);
                ReleaseInterface(pCT);

                if (V_VT(&Var) == VT_BOOL && V_BOOL(&Var) == VARIANT_TRUE)
                    break;
                
                // Eat up command if being called through om
                hr = S_OK;  
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            }
        }
        break;
    }

    if (!pCmd->cmdf)
    {
        hr = super::QueryStatus(pguidCmdGroup,
                                     1,
                                     pCmd,
                                     pcmdtext);
    }

    RRETURN_NOTRACE(hr);
}


HRESULT
CInput::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int      idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT  hr  = MSOCMDERR_E_NOTSUPPORTED;

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        htmlInput type = GetType();

        switch(type)
        {
        case htmlInputImage:
            Assert(_pImage);
            hr = _pImage->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut);
            break;
        case htmlInputFile:
            if (idm == IDM_PASTE)
            {
                IOleCommandTarget * pCT = NULL;
                CDoc *pDoc = Doc();

                if (pDoc->TestLock(FORMLOCK_QSEXECCMD))
                {
                    hr = E_ACCESSDENIED;
                }
                else
                {                
                    GetCallerCommandTarget(this, NULL, FALSE, &pCT);
                    if (pCT)
                    {
                        CVariant    Var;
                    
                        //
                        // If this is a trusted doc, allow it to go through.
                        //
                    
                        pCT->Exec(
                                &CGID_ScriptSite,
                                CMDID_SCRIPTSITE_TRUSTEDDOC,
                                0,
                                NULL,
                                &Var);
                        ReleaseInterface(pCT);
                    
                        if (V_VT(&Var) == VT_BOOL && V_BOOL(&Var) == VARIANT_TRUE)
                            break;
                    
                        // Eat up command if being called through om
                        hr = E_ACCESSDENIED;  
                    }
                }
            }
            break;
        }

        if (hr == MSOCMDERR_E_NOTSUPPORTED)
        {
            hr = super::Exec(
                    pguidCmdGroup,
                    nCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut);
        }
    }

    RRETURN_NOTRACE(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CInput::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CInput::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    BOOL    fIsButton = IsButton();

    if (GetType() == htmlInputImage)
    {
        RRETURN (super::Save(pStreamWrBuff, fEnd));
    }

    // We do not want to call super here since that would dump what
    // is in the runs.

    Assert(!_fInSave);
    _fInSave = TRUE;

    if (IsOptionButton())
    {
        hr = SaveCheckbox(pStreamWrBuff, fEnd);
        goto Cleanup;
    }

    if (!fIsButton && !fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        DWORD dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

        hr = WriteTag(pStreamWrBuff, fEnd);

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

    if (fIsButton)
    {
        if (!fEnd)
        {
            pStreamWrBuff->BeginPre();
        }

        hr = super::Save(pStreamWrBuff, fEnd);
        if (hr)
            goto Cleanup;

        if(     fEnd 
            &&  (   !pStreamWrBuff->GetElementContext() 
                 || GetFirstCp() >= pStreamWrBuff->GetElementContext()->GetFirstCp() ) )
        {
            pStreamWrBuff->EndPre();
        }
    }

Cleanup:

    Assert(_fInSave); // this will catch recursion
    _fInSave = FALSE;

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Template:   CCharFilter
//
//  Synopsis:   This is a template class that will pre-process an input string
//              character class out of an input string without disturbing
//              the original string. It makes a copy of the string if
//              needed and copies to the stack if possible, allocating
//              only if the string is longer than a certain length.
//
//              Pre-processing will either filter out CR/LF (if !fMultiLine),
//              or converts each of LF, CR-LF and LF-CR to a CR. Also, presence
//              of non-ASCII characters is checked for.
//-----------------------------------------------------------------------------

MtDefine(CCharPreprocessPchAlloc, Locals, "CCharPreprocess::_pchAlloc");

#define BASELEN 64
class CCharPreprocess
{
public:
    CCharPreprocess()  { _pchAlloc = NULL; _chOR = 0; _fPrevIsCR = _fPrevIsLF = FALSE;}
    ~CCharPreprocess() { MemFree(_pchAlloc); }

    HRESULT         Preprocess(const TCHAR *pchIn, ULONG cchIn, BOOL fMultiLine);
    const TCHAR *   Pch() { return const_cast<TCHAR*>(_pchResult); }
    ULONG           Cch() { return _cchResult; }
    BOOL            FAsciiOnly() { return _chOR <= 0x7F; }  

private:
    TCHAR   _ach[BASELEN];
    TCHAR * _pchAlloc;
    TCHAR * _pchResult;
    ULONG   _cchResult;
    TCHAR   _chOR;
    BOOL    _fPrevIsCR;
    BOOL    _fPrevIsLF;
};

HRESULT
CCharPreprocess::Preprocess(const TCHAR *pchIn, ULONG cchIn, BOOL fMultiLine)
{
    const TCHAR *pch;
    TCHAR *pchTo;
    ULONG cch;
    HRESULT hr;

    for (pch = pchIn, cch = cchIn; cch; pch++, cch--)
    {
        _chOR |= *pch;

        if (*pch == _T('\r') || *pch == _T('\n'))
        {
            if (cchIn > BASELEN)
            {
                hr = THR(MemRealloc(Mt(CCharPreprocessPchAlloc), (void**)&_pchAlloc, cchIn * sizeof(TCHAR)));
                if (hr)
                    RRETURN(hr);

                _pchResult = _pchAlloc;
            }
            else
            {
                _pchResult = _ach;
            }

            pchTo = _pchResult;
            memcpy(pchTo, pchIn, (cchIn - cch) * sizeof(TCHAR));
            pchTo += (cchIn - cch);
            _cchResult = (cchIn - cch);

            for (; cch; pch++, cch--)
            {
                _chOR |= *pch;

                if (fMultiLine)
                {
                    if (*pch == _T('\r'))
                    {
                        if (!_fPrevIsLF)
                        {
                            *pchTo++ = _T('\r');
                            _cchResult++;
                            _fPrevIsCR = TRUE;
                        }
                        else
                        {
                            _fPrevIsCR = FALSE;
                        }
                        _fPrevIsLF = FALSE;
                    }
                    else if (*pch == _T('\n'))
                    {
                        if (!_fPrevIsCR)
                        {
                            *pchTo++ = _T('\r');
                            _cchResult++;
                            _fPrevIsLF = TRUE;
                        }
                        else
                        {
                            _fPrevIsLF = FALSE;
                        }
                        _fPrevIsCR = FALSE;
                    }
                    else
                    {
                        *pchTo++ = *pch;
                        _cchResult++;
                        _fPrevIsCR = _fPrevIsLF = FALSE;
                    }
                }
                else
                {
                    if (!(*pch == _T('\r') || *pch == _T('\n')))
                    {
                        *pchTo++ = *pch;
                        _cchResult++;
                    }
                }

            }
            return S_OK;
        }
    }

    _pchResult = const_cast<TCHAR*>(pchIn);
    _cchResult = cchIn;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Method:     SetValueHelper
//
//  Synopsis:   Removes forbidden characters from the string before
//              setting the value.
//
//-------------------------------------------------------------------------

HRESULT
CInput::SetValueHelper(const TCHAR *psz, int c, BOOL fOM /* = TRUE */)
{
    //  This is a no-op for <input type=file>
    //  When the file control needs to update its contents
    //  for the file pick dialog, it will call
    //  SetValueHelperReal directly.

    HRESULT             hr;
    BOOL                fAsciiOnly = FALSE;
    CCharPreprocess     Charf;

    if (TestClassFlag(ELEMENTDESC_OMREADONLY))
        return S_OK;

#ifdef  NEVER   // look at bug 24311 
    if (IsTextOrFile())
    {
        int l = GetAAmaxLength();
        c = min(c, l);
    }
#endif

    // Type is not set until Init2() is called
    Assert (GetType() != htmlInputNotSet);
    hr = Charf.Preprocess(psz, c, IsTypeMultiline(GetType()));
    if (hr)
        RRETURN(hr);

    psz = Charf.Pch();
    c = Charf.Cch();
    fAsciiOnly = Charf.FAsciiOnly();

    RRETURN(THR(SetValueHelperReal(psz, c, fAsciiOnly, fOM)));
}



HRESULT
CInput::SetValueHelperReal(const TCHAR *psz, int c, BOOL fAsciiOnly, BOOL fOM /* = TRUE */)
{
    HRESULT     hr = S_OK;

    if (!HasSlavePtr())
    {
        _cstrDefaultValue.Set(psz, c);
        _fTextChanged = FALSE;
        _fHasInitValue = TRUE;
    }
    else
    {
        CElement *      pElemSlave = GetSlavePtr();

        Assert(pElemSlave->IsInMarkup());

        // Special case - if the current text in the input is the empty string and we 
        // are setting it also to empty don't set _fFiredValuePropChange flag because 
        // it will inhibit firing the first OnPropertyChange on the element

        if (c != 0 || pElemSlave->GetElementCch() != 0)
        {
            hr = THR(pElemSlave->GetMarkup()->FastElemTextSet(pElemSlave, psz, c, fAsciiOnly));
            if (hr)
                goto Cleanup;

            // Set this to prevent OnPropertyChange(_Value_) from firing twice
            // when value is set through OM. This flag is cleared in OnTextChange().
            _fFiredValuePropChange = fOM;
        }

        hr = THR(_cstrLastValue.Set(psz, c));
        _fLastValueSet = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::SetValueHelperInternal(CStr *pstr, BOOL fOM /* = TRUE */)
{
    HRESULT hr = S_OK;
    htmlInput   type = GetType();

    switch (type)
    {
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
    case    htmlInputButton:
    case    htmlInputReset:
    case    htmlInputSubmit:
    case    htmlInputFile:
        hr = THR(SetValueHelper((LPTSTR) *pstr, pstr->Length(), fOM));

#ifndef NO_DATABINDING
        if (SUCCEEDED(hr))
        {
            // if the value is changed by script (or any way besides user
            // typing, or databinding), try to save the value into the
            // database.  But if user cancels this, leave the new value
            // in place.
            hr = SaveDataIfChanged(ID_DBIND_DEFAULT);
            if (SUCCEEDED(hr) || hr == E_ABORT)
                hr = S_OK;
        }
#endif

        _fTextChanged = FALSE;
        break;
    default:
        _fHasInitValue = TRUE;
        _cstrDefaultValue.Set(*pstr);
    }

    RRETURN(hr);
}

HRESULT
CInput::SetValueHelper(CStr *pstr)
{
    return SetValueHelperInternal(pstr);
}


HRESULT
CInput::GetValueHelper(CStr *pstr, BOOL fIsSubmit)
{
    HRESULT hr          = S_OK;

    switch (GetType())
    {
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
    case    htmlInputFile:
    case    htmlInputButton:
    case    htmlInputReset:
    case    htmlInputSubmit:
        // Do not save password contents
        if (_fInSave && !IsEditable(TRUE) && GetType() == htmlInputPassword)
        {
            Assert(!fIsSubmit);
            pstr->Set(_T(""));
            goto Cleanup;
        }

        if (HasSlavePtr())
        {
            hr = THR(GetSlavePtr()->GetPlainTextInScope(pstr));
        }
        else
        {
            pstr->Set(*GetLastValue());
        }
        break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        if (!_fHasInitValue && !_fInSave)
        {
            pstr->Set(_T("on"));
            goto Cleanup;
        }
        //fall through
    default:
        pstr->Set(_cstrDefaultValue);
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::GetValueHelper(CStr *pstr)
{
    HRESULT     hr = S_OK;
    hr = GetValueHelper(pstr, FALSE);
    RRETURN (hr);
}


const CBase::CLASSDESC *
CInput::GetClassDesc() const
{
    switch (GetType())
    {
        case htmlInputReset:
            return (CBase::CLASSDESC *)&s_classdescReset;

        case htmlInputSubmit:
            return (CBase::CLASSDESC *)&s_classdescSubmit;

        case htmlInputButton:
            return (CBase::CLASSDESC *)&s_classdescBtn;

        case htmlInputPassword:
            return (CBase::CLASSDESC *)&s_classdescPassword;

        case htmlInputHidden:
            return (CBase::CLASSDESC *)&s_classdescHidden;

        case htmlInputFile:
            return (CBase::CLASSDESC *)&s_classdescFile;

        case htmlInputCheckbox:
        case htmlInputRadio:
            return (CBase::CLASSDESC *)&s_classdescCheckbox;

        case htmlInputImage:
            return (CBase::CLASSDESC *)&s_classdescImage;

        default:
            return (CBase::CLASSDESC *)&s_classdescText;
    }
}


HRESULT
CInput::CreateElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement, htmlInput type)
{
    Assert(ppElement);

    *ppElement = new CInput(pht->GetTag(), pDoc, type);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


//+---------------------------------------------------------------------------
//
//  Member: CInput::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CInput::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_HISTORYCODE:
        return MAKELONG(GetType(), Tag());
    }

    return super::GetInfo(gi);
}

//+------------------------------------------------------------------------
//
//  Member:     CInput::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------
                
HRESULT
CInput::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    if (!_fScriptCreated)
    {
        // if the type (or interface) has not been changed
        // we only support the old interface
        if (*s_aInputInterface[_typeAtCreate] == iid)
        {
            switch (iid.Data1)
            {
                QI_HTML_TEAROFF(this, IHTMLInputImage, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputHiddenElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputTextElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLOptionButtonElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputButtonElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputFileElement, NULL);

                default:
                    AssertSz(FALSE, "Invalid interface IID");
            }
            goto Cleanup;
        }
        else
        {
            int i;

            // all possible interfaces are in between htmlInputNotSet
            // and htmlInputImage
            for (i =  (int)htmlInputNotSet; i <= (int)htmlInputImage; i++)
            {
                if (*s_aInputInterface[i] == iid)
                {
                    RRETURN (E_NOINTERFACE);
                }
            }
        }
    }

    switch(GetType())
    {
    case htmlInputImage:
        switch (iid.Data1)
        {
            QI_TEAROFF(this, IDispatchEx, NULL);
            QI_HTML_TEAROFF(this, IHTMLElement2, NULL);
            QI_HTML_TEAROFF(this, IHTMLInputElement, NULL);
            QI_HTML_TEAROFF(this, IHTMLInputElement2, NULL);
        }
        break;
    default:
        switch (iid.Data1)
        {
            QI_HTML_TEAROFF(this, IHTMLInputElement, NULL);
            QI_HTML_TEAROFF(this, IHTMLInputElement2, NULL);
        }
        break;
    }

Cleanup:

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

HRESULT
CInput::EnterTree()
{
    htmlInput             type    = GetType();
    HRESULT               hr      = S_OK;
    CMarkup *             pMarkup = GetMarkup(); Assert(pMarkup);
    CMarkupTransNavContext * ptnc = pMarkup->EnsureTransNavContext();

    if (!ptnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _iHistoryIndex  = (unsigned short)ptnc->_dwHistoryIndex++;

#if DBG==1
    if (!IsTagEnabled(tagAllowMorphing))
#endif
    
    // no morphing allowed once the element is entering the tree
    _fHasMorphed = TRUE;
    
    switch (type)
    {
    case    htmlInputFile:
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
        DYNCAST(CInputLayout, Layout())->SetDisplayWordWrap(FALSE);
        GetUpdatedLayout()->_fAllowSelectionInDialog = TRUE;
        break;

    case    htmlInputSubmit:
        SetDefaultElem();
        // fall through
    case    htmlInputButton:
    case    htmlInputReset:
        DYNCAST(CInputLayout, Layout())->SetDisplayWordWrap(FALSE);
        break;
    case    htmlInputRadio:
            _fDeferClearGroup = TRUE;
    case    htmlInputCheckbox:
        {
            VARIANT_BOOL    checked  = VARIANT_FALSE;

            hr = S_OK;

            get_PropertyHelper(&checked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);

            SetChecked(checked);
            if (type == htmlInputRadio)
            {
                _fDeferClearGroup = FALSE;
            }

            _fLastValue = !!checked;
        }
        break;
    case    htmlInputImage :
        SetDefaultElem();
        break;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::LoadHistoryValue()
{
    HRESULT         hr = S_OK;
    CStr            cstrVal;
    DWORD           dwTemp;
    IStream        *pStream = NULL;
    BOOL            fHistorySet = FALSE;
    VARIANT_BOOL    checked = VARIANT_FALSE;
    VARIANT_BOOL    defaultChecked = VARIANT_FALSE;
    CMarkup *       pMarkup = GetMarkup();
    DWORD           dwHistoryIndex = 0x80000000 | (DWORD)_iHistoryIndex & 0x0FFFF;

    if( !pMarkup )
        goto NoHistory;

    hr = THR(pMarkup->GetLoadHistoryStream(dwHistoryIndex, HistoryCode(), &pStream));
    if (hr)
    {
        if (IsOptionButton())
            goto NoHistory;
        else
            goto Cleanup;
    }

    if (pStream)
    {
        CDataStream ds(pStream);

        if (IsOptionButton())
        {
            if (OK(THR(ds.LoadDword(&dwTemp))))
            {
                checked = (VARIANT_BOOL)(BOOL)dwTemp;
                fHistorySet = TRUE;
            }
        }
        else
        {
            Assert(IsTextOrFile());
            DWORD   dwEncoding;

            // Load encoding changing history
            hr = THR(ds.LoadDword(&dwEncoding));
            if (hr)
                goto Cleanup;

            if (!dwEncoding)
            {
                
                // load value
                hr = THR(ds.LoadCStr(&cstrVal));
                if (hr)                
                    goto Cleanup;

                // load _fTextChanged
                hr = THR(ds.LoadDword(&dwTemp));
                if (hr)
                    goto Cleanup;

                _fTextChanged = dwTemp ? TRUE : FALSE;
                
                if (_fTextChanged)
                {
                    hr = THR(SetValueHelperInternal(&cstrVal));
                    if (hr)
                        goto Cleanup;

                    IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                               0, 
                                               (PROPERTYDESC *)&s_propdescCInputvalue));
                }
            }
        }
    }
NoHistory:
    if (IsOptionButton())
    {
        hr = S_OK;

#if DBG==1
        if (!fHistorySet)      // This should already be set when we enter the tree
        {
            get_PropertyHelper(&defaultChecked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);
            Assert((!!defaultChecked) == (!!_fChecked));
        }
#endif

        if (fHistorySet)
        {
            get_PropertyHelper(&defaultChecked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);
            if ((!!defaultChecked) != (!!checked))
                SetChecked(checked);
        }

        _fLastValue = !!checked;
    }

Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     DoReset
//
//  Synopsis:   Called from CForm::Reset(). this helper assistes the form reset
//      operation by restoreing the default value to the value of this input
//      element
//
//----------------------------------------------------------------------------

HRESULT
CInput::DoReset(void)
{
    HRESULT hr = S_OK;

    switch(GetType())
    {
    case    htmlInputFile:
        hr = THR(SetValueHelperReal(NULL, 0));

        if (hr == S_OK)
            IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                       0, 
                                       (PROPERTYDESC *)&s_propdescCInputvalue));
        break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        VARIANT_BOOL bCheck;
        hr = THR(get_PropertyHelper(&bCheck, (PROPERTYDESC *)&s_propdescCInputdefaultChecked));

        if (hr)
            goto Cleanup;

        hr = THR(put_checked(bCheck));
        break;
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
        hr = SetValueHelperInternal( &_cstrDefaultValue);
        break;
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
CInput::GetSubmitInfoForImg(CPostData * pSubmitData)
{
    HRESULT     hr;
    LPCTSTR     pchName = GetAAsubmitname();

    // Write x coord
    if (pchName)
    {
        hr = THR(pSubmitData->AppendEscaped(pchName, GetMarkup()));
        if (hr)
            goto Cleanup;
        hr = THR(pSubmitData->Append(".x"));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pSubmitData->Append("x"));
        if (hr)
            goto Cleanup;
    }
    hr = THR(pSubmitData->AppendValueSeparator());
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->Append(_pt.x));
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->AppendItemSeparator());
    if (hr)
        goto Cleanup;

    // Write y coord
    if (pchName)
    {
        hr = THR(pSubmitData->AppendEscaped(pchName, GetMarkup()));
        if (hr)
            goto Cleanup;
        hr = THR(pSubmitData->Append(".y"));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pSubmitData->Append("y"));
        if (hr)
            goto Cleanup;
    }
    hr = THR(pSubmitData->AppendValueSeparator());
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->Append(_pt.y));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if there is a value
//              (name && value pair)
//
//  Returns:    S_OK if successful
//              E_NOTIMPL if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CInput::GetSubmitInfo(CPostData * pSubmitData)
{
    htmlInput   type = GetType();
    LPCTSTR     pstrName;
    CFormElement    *pForm;
    ULONG       cElements;
    CStr        cstrValue;
    HRESULT     hr = S_FALSE;

    if (type == htmlInputImage)
    {
        RRETURN(GetSubmitInfoForImg(pSubmitData));
    }

    pstrName = GetAAsubmitname();

    //  no name --> no submit!
    if ( ! pstrName )
        return S_FALSE;

    hr = GetValueHelper(&cstrValue, TRUE);

    if (hr)
        goto Cleanup;

    if (type == htmlInputFile)
    {
        if (_fDirtiedByOM && !(HasMarkupPtr() && GetMarkup()->IsMarkupTrusted()))
        {
            // Null out the contents, set focus back to the control and cancel the submit operation
            AssertSz(FALSE, "Attempted security breach - trying to submit InputFile dirtied through OM");
            _fDirtiedByOM = FALSE;
            IGNORE_HR(SetValueHelperReal(NULL, 0, TRUE, FALSE));
            IGNORE_HR(BecomeCurrent(0));
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
        else
        {
            RRETURN1(THR(pSubmitData->AppendNameFilePair(pstrName, cstrValue, GetMarkup())), S_FALSE);
        }
    }

    pForm = GetParentForm();

    if (!pForm)
        goto Cleanup;

    cElements  = pForm->_pCollectionCache->SizeAry(CFormElement::FORM_SUBMIT_COLLECTION);

    if (IsOptionButton())
    {
        VARIANT_BOOL  bCheck;
        HRESULT hr = THR(get_checked(&bCheck));

        if (hr || !bCheck)
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    if ( _tcsiequal( pstrName, TEXT("_charset_")) && htmlInputHidden == type)
    {
        TCHAR   achCharset[MAX_MIMECSET_NAME];

        if (pSubmitData->_fCharsetNotDefault && pForm->Utf8InAcceptCharset())
        {
            Assert(sizeof(s_achUtf8) <= sizeof(achCharset));
            memcpy(achCharset, s_achUtf8, sizeof(s_achUtf8));
        }
        else
        {
            hr = THR(GetMlangStringFromCodePage(
                pSubmitData->_cpInit ? 
                pSubmitData->_cpInit :
                pSubmitData->GetCP(GetMarkup()), 
                achCharset,
                ARRAY_SIZE(achCharset)));
            if (hr)
                goto Cleanup;
        }

        hr = THR(pSubmitData->AppendNameValuePair(pstrName, 
            achCharset, GetMarkup()));
    }    
    else if ( type != htmlInputText || _tcsicmp( pstrName, TEXT("isindex")) )
    {
        hr = THR(pSubmitData->AppendNameValuePair(pstrName, cstrValue, GetMarkup()));
    }
    else
    {
        Assert (htmlInputText == type);
        // For <ISINDEX ...> we don't submit the "name=" part.
        /* NASA fix (bug 27359)
            If the ISINDEX textbox is the first element we're submitting
            (not necessarily the first element on the form), we don't
            submit the name-value pair.
        */
        if (!pSubmitData->Size())
        {
            hr = THR(pSubmitData->AppendEscaped(cstrValue, GetMarkup()));
        }
        else
        {
            hr = THR(pSubmitData->AppendNameValuePair(pstrName, cstrValue, GetMarkup()));
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT CInput::DoClick(CMessage * pMessage, CTreeNode *pNodeContext,
                              BOOL fFromLabel, EVENTINFO* pEvtInfo /*= NULL */, BOOL fFromClick )
{
    HRESULT hr = S_OK;

    if (IsOptionButton())
    {
        hr = DoClickCheckbox(pMessage, pNodeContext, fFromLabel, pEvtInfo);
    }
    else 
    {
        hr = super::DoClick(pMessage, pNodeContext, fFromLabel, pEvtInfo, fFromClick);
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::GetEnabled
//
//  Synopsis:   return not disabled
//
//----------------------------------------------------------------------------

STDMETHODIMP
CInput::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = !GetAAdisabled();
    return S_OK;
}

HRESULT BUGCALL
CInput::select(void)
{
    HRESULT             hr          = S_OK;
    CMarkup *           pMarkup;
    CDoc *              pDoc        = Doc();
    CMarkupPointer      ptrStart(pDoc);
    CMarkupPointer      ptrEnd(pDoc); 
    IMarkupPointer *    pIStart; 
    IMarkupPointer *    pIEnd; 
    SELECTION_TYPE eType = SELECTION_TYPE_Text;
    BOOL fEqual;
    
    if (!HasSlavePtr() || !IsInMarkup())
        goto Cleanup;
    pMarkup = GetSlavePtr()->GetMarkup();
    if (!pMarkup)
        goto Cleanup;

#if 0
    hr = pDoc->SetEditContext(this, TRUE, FALSE);
#else
    // We need to make this current because that's the only
    // way selection works right now. GetCurrentSelectionRenderingServices()
    // looks for the current element. MarkA should fix this.
    hr = BecomeCurrent(0);
#endif
    if (hr)
        goto Cleanup;

    hr = ptrStart.MoveToCp(1, pMarkup);
    if (hr)
        goto Cleanup;
    hr = ptrEnd.MoveToCp(pMarkup->GetTextLength() - 1, pMarkup);
    if (hr)
        goto Cleanup;
    Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
    Verify(S_OK == ptrEnd.QueryInterface(IID_IMarkupPointer, (void**)&pIEnd));

    Verify( S_OK == pIStart->IsEqualTo( pIEnd, & fEqual ));

    if ( fEqual )
    {
        eType = SELECTION_TYPE_Caret;
    }
    
    hr = pDoc->Select(pIStart, pIEnd, eType );
    pIStart->Release();
    pIEnd->Release();
Cleanup:
    if (S_FALSE == hr)
        hr = S_OK;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CInput::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    htmlInput type = GetType();

    switch (dispid)
    {
    case DISPID_CInput_type:
        {
           htmlInput typeNew = GetAAtype();

           // NOTE: (krisma) if we should ever want to turn on infinite morphing,
           // just remove the next bit of code. You can then probably get rid of
           // the _fHasMorphed flag.
           if (_fHasMorphed || type != htmlInputText)
           {
                // We need to set the type back to it's old value.
                hr = SetAAtype(type);
                if (hr)
                    goto Cleanup;

                hr = OLECMDERR_E_NOTSUPPORTED;
                goto Cleanup;
           }
           // End of morph-limiting code.
           else
           {

           // The following types are valid, but we realy just want a textbox.
           if (typeNew == htmlInputNotSet         ||
               typeNew == htmlInputSelectOne      ||
               typeNew == htmlInputSelectMultiple ||
               typeNew == htmlInputTextarea       ||
               typeNew == htmlInputRichtext)
           {
               typeNew = htmlInputText;
               hr = SetAAtype(typeNew);
               if (hr)
                   goto Cleanup;
           }

           // Do we realy have to do anything?
           if (typeNew == type)
               break;

           if ((typeNew == htmlInputCheckbox  ||
                typeNew == htmlInputRadio     ||
                typeNew == htmlInputImage)    &&
               (type    != htmlInputCheckbox  &&
                type    != htmlInputRadio     &&
                type    != htmlInputImage))
           {
                Assert (HasSlavePtr());
                CElement * pElemSlave = DelSlavePtr();

                // Stop listening to events on the slave
                SetupSlaveEventSink(FALSE, pElemSlave);

                pElemSlave->DelMasterPtr();
                pElemSlave->Release();
           }

           // delete the image helper
           if (type == htmlInputImage)
           {
               Assert(_pImage);
               _fNoUIActivateInDesign = FALSE;      //  TRUE for InputImage, FALSE otherwise.
               _pImage->CleanupImage();
               delete _pImage;
               _pImage = NULL;
           }
            
           _fActsLikeButton =  (typeNew == htmlInputButton
                             || typeNew == htmlInputReset
                             || typeNew == htmlInputSubmit);

           SetType(typeNew);

           if (HasLayoutPtr())
           {
               CLayout * pLayout;
           
               pLayout = DelLayoutPtr();
               pLayout->Detach();
               pLayout->Release();
           }

           // If we're changing from a password, we have to remove the value
           if (type == htmlInputPassword)
           {
               hr = SetValueHelperReal(_T(""), 0, TRUE, FALSE);
           }

           if (typeNew == htmlInputImage)
           {
               _fNoUIActivateInDesign = TRUE;       //  TRUE for InputImage, FALSE otherwise.
               // if the new type is input image, create the imbedded input image instance
               _pImage = new CImgHelper(Doc(), this, TRUE);
               if (!_pImage)
               {
                   hr = E_OUTOFMEMORY;
                   goto Cleanup;
               }
           }

           dwFlags |= ELEMCHNG_CLEARCACHES | ELEMCHNG_SITEREDRAW | ELEMCHNG_REMEASUREINPARENT;
           _fHasMorphed = TRUE;

           hr = PrivateInit2();
           if (hr)
               goto Cleanup;
           }
        }
        break;

    case DISPID_CInput_value:
        _fTextChanged = TRUE;
        break;

    case DISPID_CElement_submitName:
        {
            // DISPID_CInput_name gets changes to DISPID_CElement_submitName before we get here
            // and that prevents onpropertychange from firing for the name property (bug 30267)
            // This call gets us to fire onpropertychage if the name is changed.
            hr = OnPropertyChange(DISPID_CInput_name, 
                                  dwFlags, 
                                  (PROPERTYDESC *)&s_propdescCInputname);
            if (hr)
                goto Cleanup;
        }
        break;
    case DISPID_CInput_readOnly:
        if (IsTextOrFile())
            _fReadOnly = !!GetAAreadOnly();
        break;

    case DISPID_CInput_src:
        if (_pImage && type == htmlInputImage)
        {
            hr = _pImage->SetImgSrc(IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
        }
        break;
    case DISPID_CInput_lowsrc:
        if (_pImage && type == htmlInputImage)
        {
            LPCTSTR szUrl = GetAAsrc();

            if (!szUrl)
            {
                Assert(_pImage);
                hr = _pImage->FetchAndSetImgCtx(GetAAlowsrc(), IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
            }

        }
        break;

#ifndef NO_AVI
    case DISPID_CInput_dynsrc:
        if (_pImage && GetType() == htmlInputImage)
        {
            hr = _pImage->SetImgDynsrc();
        }
        break;
#endif
    }

    hr = (THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc)));

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::BecomeUIActive
//
//  Synopsis:   Check imeMode to set state of IME.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
CInput::BecomeUIActive()
{
    HRESULT hr = S_OK;
    htmlInput   type = GetType();

    hr = THR(super::BecomeUIActive());
    if (hr)
        goto Cleanup;

    if (type == htmlInputText)
    {
        hr = THR(SetImeState());
        if (hr)
            goto Cleanup;
    }

Cleanup:    
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CInput::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    HRESULT     hr;
    htmlInput   type        = GetType();
    CLayout *   pLayout     = Layout();

    Assert(ppShape);

    switch(type)
    {
    case htmlInputCheckbox:
    case htmlInputRadio:
        if (HasSlavePtr())
        {
            hr = super::GetFocusShape(lSubDivision, pdci, ppShape);
        }
        else
        {
            hr = DYNCAST(CCheckboxLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        }
        break;
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
        hr = DYNCAST(CInputButtonLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        break;
    case htmlInputFile:
        hr = DYNCAST(CInputFileLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        break;
    case htmlInputImage:
        if (HasSlavePtr())
        {
            hr = super::GetFocusShape(lSubDivision, pdci, ppShape);
        }
        else
        {
            hr = DYNCAST(CInputImageLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        }
        break;
    default:
        // Never want focus rect for text/password
        *ppShape = NULL;
        hr = S_FALSE;
        break;
    }
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::RequestYieldCurrency
//
//  Synopsis:   Check if OK to Relinquish currency
//
//  Arguments:  BOOl fForce -- if TRUE, force change and ignore user cancelling the
//                             onChange event
//
//  Returns:    S_OK: ok to yield currency
//
//--------------------------------------------------------------------------

HRESULT
CInput::RequestYieldCurrency(BOOL fForce)
{
    CStr    cstr;
    HRESULT hr = S_OK;
    BOOL    fIsText = IsTextOrFile();
    BOOL    fIsOptionButton = IsOptionButton();

    if(IsButton())
        RRETURN1(super::RequestYieldCurrency(fForce), S_FALSE);

    if ((fIsText && (hr = GetValueHelper(&cstr)) == S_OK) ||
        (fIsOptionButton && _fLastValue != _fChecked))
    {
        BOOL fFire =  fIsText ? (FormsStringCmpLoc(cstr, *GetLastValue()) != 0)
            : (_fLastValue != _fChecked);

        if (!fFire)
            goto Cleanup;

        if (!Fire_onchange())   //JS event
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    
        if (!IsInMarkup())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = super::RequestYieldCurrency(fForce);
        if (hr == S_OK)
        {
            if (fIsText)
            {
                _cstrLastValue.Set(cstr);
                _fLastValueSet = TRUE;
            }
            else 
            {
                Assert(fIsOptionButton);
                _fLastValue = _fChecked;
            }
        }
    }

Cleanup:
    if (fForce && FAILED(hr))
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pSiteNew    New site that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
CInput::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr;

    _fDoReset = FALSE;
    hr = THR(super::YieldCurrency(pElemNew));
    if (hr)
        goto Cleanup;

    switch(GetType())
    {
    case    htmlInputFile:
        if (_fButtonHasFocus)
        {
            BtnHelperKillFocus();
        }
        break;
    case    htmlInputButton:
    case    htmlInputSubmit:
    case    htmlInputReset:
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_HASFOCUS);
            GetUpdatedLayout()->Invalidate();
            break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_HASFOCUS);
            break;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT BUGCALL
CInput::HandleMessage(CMessage * pMessage)
{
    HRESULT     hr = S_FALSE;
    htmlInput   type = GetType();

    switch(type)
    {
    case    htmlInputButton:
    case    htmlInputReset:
    case    htmlInputSubmit:
        hr = HandleButtonMessage(pMessage);
        break;
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
        hr = HandleTextMessage (pMessage);
        break;
    case    htmlInputFile:
        hr = HandleFileMessage (pMessage);
        break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        hr = HandleCheckboxMessage (pMessage);
        break;
    case    htmlInputImage:
        hr = HandleImageMessage (pMessage);
        break;
    default:
        AssertSz(FALSE, "Invalid input element");
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT BUGCALL
CInput::HandleFileMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;
    BOOL fButtonMessage = FALSE;
    BOOL fTextEditMessage = FALSE;

    switch ( pMessage->message )
    {
    case WM_SETFOCUS:
        if ( _fButtonHasFocus )
        {
            BtnHelperSetFocus();
            fButtonMessage = TRUE;
        }
        else
        {
            fTextEditMessage = TRUE;
        }

        break;

    case WM_KILLFOCUS:
        if ( _fButtonHasFocus )
        {
            fButtonMessage = TRUE;
            hr = S_OK;
        }
        else
        {
            fTextEditMessage = TRUE;
        }

        break;

    case WM_KEYDOWN:
        if ( pMessage->wParam == VK_TAB )
        {
            if ( pMessage->dwKeyState & FSHIFT )
            {
                //  BackTAB
                if ( _fButtonHasFocus )
                {
                    CDoc    *pDoc = Doc();
                    BtnHelperKillFocus();
                    // set caret
                    if (pDoc->_pCaret)
                    {
                        pDoc->_pCaret->Show( FALSE );
                    }
                    hr = S_OK;
                }
                else
                {
                    fTextEditMessage = TRUE;
                }
            }
            else
            {
                //  Forward TAB
                if ( _fButtonHasFocus )
                {
                    fTextEditMessage = TRUE;
                    fButtonMessage = TRUE;
                }
                else
                {
                    BtnHelperSetFocus();
                    hr = S_OK;
                }
            }
        }
        else
        {
            fButtonMessage = _fButtonHasFocus;
            fTextEditMessage = ! fButtonMessage;
        }

        break;

    default:

        if ( HasCapture() )
        {
            fButtonMessage = _fButtonHasCapture;
        }
        else
        {
            CInputFileLayout * pLayout = DYNCAST(CInputFileLayout, GetUpdatedLayout());

            if (pLayout)
            {
                CRect  rc;
                CPoint pt = pMessage->coordinateSystem == COORDSYS_GLOBAL ? pMessage->pt : pMessage->ptContent;
                HTHEME hTheme = GetTheme(THEME_BUTTON); // only care about button case

                pLayout->GetButtonRect(&rc);

                pLayout->TransformPoint(&pt, pMessage->coordinateSystem, COORDSYS_BOX);
                
                fButtonMessage = rc.Contains(pt);

                if (    hTheme
                    &&  (pMessage->message == WM_MOUSEMOVE || pMessage->message == WM_MOUSELEAVE))
                {
                    UINT msgOriginal = pMessage->message;

                    if (    pMessage->message == WM_MOUSEMOVE  
                        &&  !MouseOver()
                        &&  fButtonMessage)
                    {
                        //
                        // mouse over button part from text part
                        //
                        pMessage->message = WM_MOUSEOVER;
                        hr = THR(BtnHandleMessage(pMessage));
                        pMessage->message = msgOriginal;
                        goto Cleanup;
                    }

                    else if (MouseOver() &&  !fButtonMessage)
                    {
                        //
                        // mouse leave from button part
                        //
                        pMessage->message = WM_MOUSELEAVE;
                        hr = THR(BtnHandleMessage(pMessage));
                        pMessage->message = msgOriginal;
                        goto Cleanup;
                    }
               }
            }

            if ( !fButtonMessage &&
                 pMessage->message == WM_LBUTTONDOWN )
            {
                BtnHelperKillFocus();
            }
            else if ( pMessage->message >= WM_KEYFIRST &&
                      pMessage->message <= WM_KEYLAST )
            {
                fButtonMessage = _fButtonHasFocus;
            }
        }

        fTextEditMessage = ! fButtonMessage;

        break;
    }


    if ( fButtonMessage )
    {
        _fBtnHelperRequestsCurrency = TRUE;
        if (    pMessage->message != WM_LBUTTONDOWN
            ||  !BecomeCurrent(pMessage->lSubDivision, NULL, pMessage))
        {
            hr = THR(BtnHandleMessage(pMessage));
        }
        _fBtnHelperRequestsCurrency = FALSE;
    }
    if ( fTextEditMessage )
    {
        hr = THR(HandleTextMessage(pMessage));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
// Member:      CInputImage::HandleMessage
//
// Synopsis:    Handle window message
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CInput::HandleImageMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;

    // Use hyperlink cursor (IE3 compat.)
    if (WM_SETCURSOR == pMessage->message)
    {
        SetCursorStyle(MAKEINTRESOURCE(IDC_HYPERLINK));
        hr = S_OK;
        goto Cleanup;
    }
    // WM_CONTEXTMENU message should always be handled.
    else if (WM_CONTEXTMENU == pMessage->message)
    {
        Assert(_pImage);
        hr = THR(_pImage->ShowImgContextMenu(pMessage));
    }
    else if (!IsEditable(TRUE))
    {
        hr = BtnHandleMessage(pMessage);
    }
    if (hr == S_FALSE)
    {
        // image does not have their own handlemessage
        hr = super::HandleMessage(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT BUGCALL
CInput::HandleButtonMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;
    BOOL    fEditable = IsEditable( TRUE );

    if (!CanHandleMessage())
        goto Cleanup;

    if (!fEditable)
    {
        if (!IsEnabled())
            goto Cleanup;

        hr = BtnHandleMessage(pMessage);
        if (hr == S_FALSE)
        {
            hr = super::HandleMessage(pMessage);
        }
    }
    else
    {
        if (pMessage->message == WM_CONTEXTMENU)
        {
            hr = THR(OnContextMenu(
                    (short)LOWORD(pMessage->lParam),
                    (short)HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
        }
        if (hr == S_FALSE)
        {
            hr = super::HandleMessage(pMessage);
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT BUGCALL
CInput::HandleTextMessage(CMessage * pMessage)
{
    HRESULT         hr = S_FALSE;
    CFormElement *  pForm;
    BOOL            fEditable = IsEditable(TRUE);
    BOOL            fEnabled  = IsEnabled();

    Assert(IsTextOrFile());

    if ( !CanHandleMessage() ||
         (!fEditable && !fEnabled) )
    {
        goto Cleanup;
    }

    if (!fEditable && _fDoReset)
    {
        if (pMessage->message == WM_KEYDOWN)
        {
            if (pMessage->wParam == VK_ESCAPE)
            {
                pForm = GetParentForm();
                if (pForm)
                {
                    _fDoReset = FALSE;
                    hr = THR(pForm->DoReset(TRUE));
                    if (hr != S_FALSE)
                        goto Cleanup;
                }
            }
            else
            {
                _fDoReset = FALSE;
            }
        }
    }

    switch (pMessage->message)
    {
        case WM_CHAR:
            if (pMessage->wParam == VK_RETURN)
            {
                BOOL    fOnlyTextbox;

                pForm = GetParentForm();
                if (pForm)
                {
                    hr = THR(pForm->FOnlyTextbox(this, &fOnlyTextbox));
                    if (FAILED(hr))
                        goto Cleanup;
                    if (fOnlyTextbox)
                    {
                        IGNORE_HR(pForm->DoSubmit(this, TRUE));
                        hr = S_OK;
                        goto Cleanup;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
            break;


        // We handle all WM_CONTEXTMENUs
        case WM_CONTEXTMENU:
            hr = THR(OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
            goto Cleanup;
    }

    if (!fEditable  &&
        pMessage->message == WM_KEYDOWN &&
        pMessage->wParam == VK_ESCAPE)
    {
        _fDoReset = TRUE;
        SetValueHelperInternal(GetLastValue(), FALSE);

        hr = S_FALSE;
        goto Cleanup;
    }

    // Since we let TxtEdit handle messages we do JS events after
    // it comes back
    Assert(S_FALSE == hr);
    hr = super::HandleMessage(pMessage);

Cleanup:

    RRETURN1(hr, S_FALSE);
}


HRESULT
CInput::ClickAction(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    htmlInput       type = GetType();

    switch(type)
    {
    case    htmlInputButton:
        // Do nothing;
        break;
    case    htmlInputReset:
    case    htmlInputSubmit:
        hr = ClickActionButton(pMessage);
        break;
    case    htmlInputFile:
        hr = ClickActionFile(pMessage);
        break;
    case    htmlInputCheckbox:
        if (BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE))
        {
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_TRISTATE);
            GetUpdatedLayout()->Invalidate();
        }
        else
        {
            put_checked(_fChecked ? VB_FALSE : VB_TRUE);
        }
        break;
    case    htmlInputRadio:
        // Do nothing if unnamed (Netscape Compat.)
        if (!_fChecked && GetAAname())
            put_checked(VB_TRUE);
        break;
    case    htmlInputImage:
        hr = ClickActionImage(pMessage);
        goto Cleanup;
        break;
    default:
        hr = super::ClickAction(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CInput::ClickActionButton(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CFormElement *  pForm;

    pForm = GetParentForm();
    if (pForm)
    {
        switch (GetType())
        {
            case htmlInputReset:
                hr = THR(pForm->DoReset(TRUE));
                break;

            case htmlInputSubmit:
                hr = THR(pForm->DoSubmit(this, TRUE));
                break;
        }
        if (hr == S_FALSE)
            hr = S_OK;
    }
    RRETURN1(hr, S_FALSE);
}

HRESULT
CInput::ClickActionImage(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CFormElement *  pForm;

    if (pMessage &&
        pMessage->message >= WM_MOUSEFIRST &&
        pMessage->message <= WM_MOUSELAST)
    {
        _pt.x = pMessage->ptContent.x;
        _pt.y = pMessage->ptContent.y;
    }
    else
    {
        GetUpdatedLayout()->GetPosition(&_pt, COORDSYS_FLOWCONTENT);
    }

    pForm = GetParentForm();
    if (pForm)
    {
        pForm->DoSubmit(this, TRUE);
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::ClickActionFile
//
//  Synopsis:   Display the File Open... common dialog here.
//
//----------------------------------------------------------------------------

HRESULT
CInput::ClickActionFile(CMessage * pMessage)
{
    HRESULT hr                      = S_OK;
    TCHAR   achBuf[FORMS_BUFLEN];
    CStr    cstr;
    BSTR    bstr                    = NULL;

    // Do not click if the control is readonly (#67776)
    if (_fReadOnly)
        goto Cleanup;

    // Do nothing unless the click is in the button portion (indicated
    // by non-zero click data)
    if (pMessage && 0 == pMessage->dwClkData)
        goto Cleanup;

    hr = THR(GetValueHelper(&cstr));
    if ( hr )
        goto Cleanup;

    if ( cstr )
    {
        _tcsncpy(achBuf, cstr, FORMS_BUFLEN);
        achBuf[FORMS_BUFLEN-1] = 0;
    }
    else
    {
        *achBuf = 0;
    }

    hr = THR(FormsGetFileName(FALSE,
                              Doc()->_pInPlace->_hwnd,
                              IDS_UPLOADFILE,
                              achBuf,
                              ARRAY_SIZE(achBuf), (LPARAM)0));

    if ( FAILED(hr) )
        goto Cleanup;

    if ( S_OK == hr )
    {
        BOOL fFire =  FormsStringCmpLoc(achBuf, *GetLastValue()) != 0;

        hr = THR(SetValueHelperReal(achBuf, _tcslen(achBuf), FALSE));
        if ( hr )
            goto Cleanup;

        if (fFire)
        {
            if (!Fire_onchange())   //JS event
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                       0, 
                                       (PROPERTYDESC *)&s_propdescCInputvalue));
        }
    }
    else
    {
        //  S_FALSE means the user cancelled the dialog
        hr = S_OK;
    }

Cleanup:
    SysFreeString(bstr);

    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

THEMECLASSID
CInput::GetInputThemeClsId() const
{
    switch(GetType())
    {
    case    htmlInputCheckbox:
    case    htmlInputRadio:
    case    htmlInputButton:
    case    htmlInputSubmit:
    case    htmlInputReset:
        return THEME_BUTTON;
    case    htmlInputText:
    case    htmlInputFile:
    case    htmlInputTextarea:
    case    htmlInputPassword:
        return THEME_EDIT;
    }
    return THEME_NO;
}

HRESULT
CInput::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT         hr = S_OK;
    enum _htmlInput type = GetType();
    CDoc *          pDoc;
    LOGFONT         lf;
    BYTE            i;
    BOOL            fIsButton;
    CUnitValue      uvBorderWidth(2, CUnitValue::UNIT_PIXELS);
    HTHEME          hTheme = NULL;
    
    switch(type)
    {
    case    htmlInputImage:
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        hr = super::ApplyDefaultFormat(pCFI);
        goto Cleanup;
    }

    pDoc        = Doc();
    fIsButton   = IsButton();

    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();
    pCFI->PrepareParaFormat();

    hTheme = GetMarkup()->GetTheme(GetInputThemeClsId());

    DefaultFontInfoFromCodePage( GetMarkup()->GetCodePage(), &lf, pDoc );

    //
    // set char format
    //
    
    pCFI->_cf()._wWeight = 400;
    pCFI->_cf()._yHeight = 200; // 10 * 20 twips NS compatibility
    // pCFI->_cf()._yHeight = 160; // 8 * 20 twips IE3 compatibility    

    // Themed password control requires 0x25cf character. So we need to
    // pickup a font which supports it.
    // HACKHACK (grzegorz): Use always Tahoma font in this situation.
    if (g_fThemedPlatform && htmlInputPassword == GetType())
    {
        _tcsncpy(lf.lfFaceName, _T("Tahoma"), LF_FACESIZE);
    }

    pCFI->_cf()._fBold = FALSE;
    if (fIsButton)
    {
        // Set default color and let super override it with the use style
        pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_BTNTEXT);
        pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_BTNFACE);

        pCFI->_bBlockAlign     = htmlBlockAlignCenter;

        pCFI->_ff()._bd._bBorderSoftEdges = TRUE;

        pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_BTNFACE);
        pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
        pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
        pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

        if (pCFI->_cf()._fVisibilityHidden || pCFI->_cf()._fDisplayNone)
            _fButtonWasHidden = TRUE;

        //
        // Add default padding
        //
    }
    else
    {
        // No vertical spacing between para's
        pCFI->_ff()._cuvSpaceBefore.SetPoints(0);
        pCFI->_ff()._cuvSpaceAfter.SetPoints(0);

        pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_WINDOWTEXT);
        pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_WINDOW);

        // border
        pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
        pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
        pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
        pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

        //
        // Add default padding
        //
        CUnitValue      uv;

        uv.SetValue(TEXT_INSET_DEFAULT_LEFT, CUnitValue::UNIT_PIXELS);

        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff().SetPadding(i, uv);
        }
    }

    // Since its the same value to which X and Y are being set, logical/physical does not matter here.
    pCFI->_ff().SetOverflowX(styleOverflowHidden);
    pCFI->_ff().SetOverflowY(styleOverflowHidden);

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->_cf()._bCursorIdx = styleCursorAuto;
    pCFI->_pf()._cuvTextIndent.SetPoints(0);

    pCFI->_cf()._bCharSet = lf.lfCharSet;
    pCFI->_cf().SetFaceName( lf.lfFaceName);

    if (pCFI->_cf().NeedAtFont())
    {
        ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
    }

    pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);

    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, uvBorderWidth);
        if (!fIsButton)
            pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSunken);
    }

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    pCFI->PrepareParaFormat();
    pCFI->PrepareCharFormat();    
    pCFI->PrepareFancyFormat();
    
    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // set theme defaults
    {                    
        // set theme defaults for properties not already set
 
        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, fIsButton ? BP_PUSHBUTTON : EP_EDITTEXT, 
                                              fIsButton ? PBS_NORMAL : ETS_NORMAL, TMT_FONT, &lf))
        {
            long twips;

            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick( lf.lfHeight, TWIPS_PER_INCH, g_sizePixelsPerInch.cy );

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }    
    }


    pCFI->_pf()._fPreInner = TRUE;

    if (type == htmlInputHidden && !IsEditable(TRUE))
    {
        pCFI->_cf()._fDisplayNone = TRUE;
    }

    // font height in CharFormat is already nonscaling size in twips
    pCFI->_cf().SetHeightInNonscalingTwips( pCFI->_pcf->_yHeight );

    if (type == htmlInputPassword)
    {
        pCFI->_cf()._fPassword = TRUE;
    }

    pCFI->UnprepareForDebug();

    FixupEditable(pCFI);

Cleanup:
    RRETURN(hr);
}

//
// this is really a 3D array
//
// checkbox, radio
// checked, unchecked, mixed
// 4 states: normal, hot, pressed, disabled
//

static int aryOptionButtonThemeState[2][3][4]=
{
    {
        {CBS_UNCHECKEDNORMAL, CBS_UNCHECKEDHOT, CBS_UNCHECKEDPRESSED, CBS_UNCHECKEDDISABLED},
        {CBS_CHECKEDNORMAL,   CBS_CHECKEDHOT,   CBS_CHECKEDPRESSED,   CBS_CHECKEDDISABLED},
        {CBS_MIXEDNORMAL,     CBS_MIXEDHOT,     CBS_MIXEDPRESSED,     CBS_MIXEDDISABLED},
    },
    {
        {RBS_UNCHECKEDNORMAL, RBS_UNCHECKEDHOT, RBS_UNCHECKEDPRESSED, RBS_UNCHECKEDDISABLED},
        {RBS_CHECKEDNORMAL,   RBS_CHECKEDHOT,   RBS_CHECKEDPRESSED,   RBS_CHECKEDDISABLED},
        {-1,                  -1,               -1,                   -1},
    }
};

int
CInput::GetThemeState()
{

    switch (GetType())
    {
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
    
        if (!IsEnabled())
        {
            return PBS_DISABLED;
        }
        else if (Pressed())
        {
            return PBS_PRESSED;
        }
        else if (MouseOver())
        {
            return PBS_HOT;
        }
        else
        {
            CDoc *pDoc = Doc();

            if (    pDoc 
                &&  _fDefault
                &&  pDoc->HasFocus())
            {
                return PBS_DEFAULTED;
            }
        }
        break;
    case htmlInputRadio:
    case htmlInputCheckbox:
    {
        int i, j, k;
        VARIANT_BOOL    checked;

        i = GetType() == htmlInputRadio ? 1 : 0;

        GetChecked(&checked);

        j = checked ? 1 : 0;

        //
        // this is a checkbox and mixed
        //

        if (!i && BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE))
        {
            j = 2;
        }

        if (!IsEnabled())
        {
            k = 3;
        }
        else if (Pressed())
        {
            k = 2;
        }
        else if (MouseOver())
        {
            k = 1;
        }
        else
        {
            k = 0;
        }

        Assert(aryOptionButtonThemeState[i][j][k] > 0);
        return aryOptionButtonThemeState[i][j][k];
    }
    case htmlInputText:
    case htmlInputTextarea:
    case htmlInputPassword:
        if (!IsEnabled())
        {
            return ETS_DISABLED;
        }
        return ETS_NORMAL;

    case htmlInputFile:
        if (!IsEnabled())
        {
            return PBS_DISABLED;
        }
        else if (Pressed())
        {
            return PBS_PRESSED;
        }
        else if (MouseOver())
        {
            return PBS_HOT;
        }
        else
        {
            CDoc *pDoc = Doc();

            if (    pDoc 
                &&  _fButtonHasFocus
                &&  pDoc->HasFocus())
            {
                return PBS_DEFAULTED;
            }
        }
        break;
    default:
        break;
    }

    //
    // PBS_NORMAL can represent normal case for all controls
    //

    return PBS_NORMAL;
}

DWORD
CInput::GetNonThemedBorderInfo(
    CDocInfo * pdci,
    CBorderInfo *pborderinfo,
    BOOL fAll,
    BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD   nBorders;

    Assert(IsButton());
    pborderinfo->abStyles[SIDE_TOP]    =
    pborderinfo->abStyles[SIDE_RIGHT]  =
    pborderinfo->abStyles[SIDE_BOTTOM] =
    pborderinfo->abStyles[SIDE_LEFT]   = BTN_PRESSED(_wBtnStatus)
                                                ? fmBorderStyleSunken
                                                : fmBorderStyleRaised;
    nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);

    {
        int xyFlatX = 1;
        int xyFlatY = 1;
        if (pdci)
        {
            xyFlatX = pdci->DeviceFromDocPixelsX(xyFlatX);
            xyFlatY = pdci->DeviceFromDocPixelsY(xyFlatY);
        }
        pborderinfo->aiWidths[SIDE_TOP]    += xyFlatY;
        pborderinfo->aiWidths[SIDE_RIGHT]  += xyFlatX;
        pborderinfo->aiWidths[SIDE_BOTTOM] += xyFlatY;
        pborderinfo->aiWidths[SIDE_LEFT]   += xyFlatX;
    }

    if (!fAllPhysical && HasVerticalLayoutFlow())
    {
        pborderinfo->FlipBorderInfo();
    }
    
    return nBorders;
}

DWORD
CInput::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD   nBorders;
    HTHEME  hTheme = NULL;
    RECT rc;

    // for themed controls, we report no border
    // because the theming engine draws everything.
    // we don't want to draw our own border, so 
    // we report that there's none to draw.

    switch (GetType())
    {
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
    {  
        hTheme = GetTheme(GetInputThemeClsId());

        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rc))
        {   
            nBorders = GetNonThemedBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left);            
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom);

            nBorders = DISPNODEBORDER_SIMPLE;
        }
        else
        {
            nBorders = GetNonThemedBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
        }
        break;
    }
    case htmlInputFile:
        hTheme = GetTheme(GetInputThemeClsId());

        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rc))
        {   
            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left);            
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom);

            nBorders = DISPNODEBORDER_SIMPLE;
        }
        else
        {
            nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);
            if (!fAllPhysical && HasVerticalLayoutFlow())
            {
                pborderinfo->FlipBorderInfo();
            }
        }

        if (!_fRealBorderSize)
        {
            // We reserve space for the fake button in the extra right border
            BOOL fRightToLeft = GetFirstBranch()->GetParaFormat(FCPARAM)->HasRTL(FALSE);
            
            pborderinfo->aiWidths[(!fRightToLeft ? SIDE_RIGHT : SIDE_LEFT)] += 
                DYNCAST(CInputFileLayout, GetUpdatedLayout( GUL_USEFIRSTLAYOUT ))->_sizeButton.cx
                + (pdci ? pdci->DeviceFromDocPixelsX(cxButtonSpacing) : cxButtonSpacing);
        }
        nBorders = DISPNODEBORDER_COMPLEX;
        break;
    case htmlInputText:
    case htmlInputPassword:
        
        hTheme = GetTheme(GetInputThemeClsId());
        
        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, GetThemeState(), &g_Zero.rc, &rc))
        {                        

            // The reason we are adding one to the result from
            // GetThemeBackgroundExtent is that in the Luna 
            // theme, edit controls have a border that is
            // one pixel smaller than non-themed controls.
            // This will ensure that we draw the Luna input
            // controls the same size as non-themed controls.
            // However, this will not be the case if other
            // themes come along that have a size other than
            // one pixel. This will then have to be revisited.
            // This is the best solution for now because future
            // themes will not break or look dumb, they just 
            // might be bigger than current controls.

            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left + 1);            
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right + 1);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top + 1);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom + 1);

            nBorders = DISPNODEBORDER_SIMPLE;
            break;                        
        }
        
        // FALL THROUGH TO THE DEFAULT IF NO THEME OR THEME FAILS

    default:
        nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);
        if (!fAllPhysical && HasVerticalLayoutFlow())
        {
            pborderinfo->FlipBorderInfo();
        }
    }

    return nBorders;
}

void
CInput::Notify(CNotification *pNF)
{
    IStream *       pStream = NULL;
    HRESULT         hr = S_OK;
    CStr            cstrVal;
    htmlInput       type = GetType();
    
    // Defer clearing the other radio buttons in the group. This would
    // prevent the collections from being accessed prematurely in
    // SetChecked() called from super::Init2(). The clearing would
    // happen in AddToCollections().
    if (type == htmlInputRadio 
        && pNF->IsType(NTYPE_DELAY_LOAD_HISTORY))
    {
        _fDeferClearGroup = TRUE;
    }

    super::Notify(pNF);
    if (type == htmlInputImage)
    {
        Assert(_pImage);
        _pImage->Notify(pNF);
    }

    switch (pNF->Type())
    {

    case NTYPE_ELEMENT_GOTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && type == htmlInputText )
        {
            hr = THR( select());
        }                 
    }        
    break;

    case NTYPE_ELEMENT_LOSTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && type == htmlInputText )
        {
            Doc()->DestroyAllSelection();
        }                 
    }        
    break;
    
    case NTYPE_ELEMENT_QUERYTABBABLE:
        if (GetType() == htmlInputRadio)
        {
            CElement * pElemCurrent = Doc()->_pElemCurrent;

            //
            // this is the current element or this is a radio of different group
            // AND this radio is checked or there is no checked radio
            //
            ((CQueryFocus *)pNF->DataAsPtr())->_fRetVal = 
                                            IsEditable(TRUE)
                                            ||
                                            ((      this == pElemCurrent 
                                                ||  !FInSameGroup(pElemCurrent))
                                            && 
                                             (      _fChecked
                                                ||  ChkRadioGroup(GetAAname()) == S_FALSE)
                                            );
        }
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        switch (type)
        {
        case    htmlInputRadio:
        case    htmlInputCheckbox:
            _fLastValue = _fChecked;
            // fall through
        case    htmlInputButton:
        case    htmlInputReset:
        case    htmlInputSubmit:
            _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
            break;
        case    htmlInputFile:
            {
                CSetFocus * pSetFocus       = (CSetFocus *)pNF->DataAsPtr();
                CMessage *  pMessage        = pSetFocus->_pMessage;
                unsigned    fButtonHadFocus = _fButtonHasFocus;

                if ( pMessage && 
                    ( (pMessage->message == WM_LBUTTONDOWN) || 
                      (pMessage->message == WM_RBUTTONDOWN) ) )
                {
                    CRect rc;
                    DYNCAST(CInputFileLayout, GetUpdatedLayout())->GetButtonRect(&rc);
                    _fButtonHasFocus = rc.Contains(pMessage->ptContent);
                }
                //  if the button helper is requesting or we come in with a BackTab
                if ( _fBtnHelperRequestsCurrency ||
                     pMessage &&
                     pMessage->message == WM_KEYDOWN &&
                     pMessage->wParam == VK_TAB &&
                     pMessage->dwKeyState & FSHIFT )
                {
                    BtnHelperSetFocus();
                }
                else if ( fButtonHadFocus && !_fButtonHasFocus)
                {
                    BtnHelperKillFocus();
                }
            }
            break;
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        switch (type)
        {
        case htmlInputImage :
        case htmlInputSubmit :
            if( pNF->DataAsDWORD() & EXITTREE_DESTROY )
            {
                Doc()->_pElemDefault = NULL;
            }
            else
            {
                SetDefaultElem(TRUE);
            }
            break;
        case htmlInputFile :
            if (_icfButton != -1)
            {
                TLS(_pCharFormatCache)->ReleaseData( _icfButton ); _icfButton = -1;
            }
            break;
        case htmlInputRadio :
            if (_fChecked && !(pNF->DataAsDWORD() & EXITTREE_DESTROY))
            {
                DelRadioGroup(GetAAname());
            }
            break;
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:

        switch (type)
        {
        case    htmlInputFile:
        case    htmlInputText:
        case    htmlInputHidden:
            hr = THR(LoadHistoryValue());
            if (!OK(hr))
            {
                // See comments for _cstrLastValue in inputtxt.hxx
                if (_cstrLastValue == NULL && htmlInputHidden == type)
                    SetValueHelper(_T("  "), 2);
    
                hr = S_OK;
            }
            break;
        case    htmlInputRadio:
            hr = THR(LoadHistoryValue());
            _fDeferClearGroup = FALSE;
            break;
        case    htmlInputCheckbox:
            hr = THR(LoadHistoryValue());
            break;
        }
        break;
        
    case NTYPE_SAVE_HISTORY_1:
        switch (type)
        {
        case htmlInputText :
        case htmlInputHidden :
        case htmlInputFile :
        case htmlInputCheckbox :
        case htmlInputRadio :
            pNF->SetSecondChanceRequested();
        }

        break;

    case NTYPE_SAVE_HISTORY_2:
        Assert(    type == htmlInputText || type == htmlInputHidden || type == htmlInputFile
                || type == htmlInputCheckbox || type == htmlInputRadio );
        {
            CDataStream         ds;
            CHistorySaveCtx *   phsc;
            DWORD               dwHistoryIndex =    0x80000000
                                                |   (DWORD)_iHistoryIndex
                                                &   0x0FFFF;

            pNF->Data((void **)&phsc);
            hr = THR(phsc->BeginSaveStream(dwHistoryIndex, HistoryCode(), &pStream));
            if (hr)
                goto Cleanup;

            ds.Init(pStream);

            if (!IsOptionButton())
            {
                Assert (IsTextOrFile());

                hr = THR(ds.SaveDword(_fChangingEncoding ? 1 : 0));
                if (hr)
                    goto Cleanup;
                if (!_fChangingEncoding)
                {
                    // save value
                    hr = THR(GetValueHelper(&cstrVal));
                    if (hr)
                        goto Cleanup;
                    hr = THR(ds.SaveCStr(&cstrVal));
                    if (hr)
                        goto Cleanup;
                    
                    // save _fTextChanged
                    hr = THR(ds.SaveDword(_fTextChanged ? 1 : 0));
                    if (hr)
                        goto Cleanup;
                }
            }
            else
            {
                hr = THR(ds.SaveDword((DWORD)_fChecked));
                if (hr)
                    goto Cleanup;
            }

            hr = THR(phsc->EndSaveStream());
            if (hr)
                goto Cleanup;
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_BASE_URL_CHANGE:
        // send onpropertychange calls for all properties that are
        // effected by this change
        OnPropertyChange( DISPID_CInput_src, 
                          ((PROPERTYDESC *)&s_propdescCInputsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCInputsrc);
        OnPropertyChange( DISPID_CInput_dynsrc, 
                          ((PROPERTYDESC *)&s_propdescCInputdynsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCInputdynsrc);
        OnPropertyChange( DISPID_CInput_lowsrc, 
                          ((PROPERTYDESC *)&s_propdescCInputlowsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCInputlowsrc);
        break;        

    case NTYPE_SET_CODEPAGE:
        if (IsTextOrFile())
        {
            _fChangingEncoding = TRUE;
        }
        break;
    }

Cleanup:
    ReleaseInterface(pStream);
    return;
}


#ifndef NO_DATABINDING
class CDBindMethodsRadio : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;
    
public:
    CDBindMethodsRadio() : super(VT_BSTR) {}
    ~CDBindMethodsRadio()   {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                    BOOL fHTML, LPVOID pvData) const;
                    
    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                     BOOL fHTML, LPVOID pvData) const;

};

class CDBindMethodsInputTxtBase : public CDBindMethodsText
{
    typedef CDBindMethodsText super;
public:
    CDBindMethodsInputTxtBase() : super(0)   {}
    ~CDBindMethodsInputTxtBase()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;
    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                         BOOL fHTML, LPVOID pvData) const;
};

class CDBindMethodsCheckbox : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsCheckbox() : super(VT_BOOL) {}
    ~CDBindMethodsCheckbox()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                          BOOL fHTML, LPVOID pvData) const;

};


//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound checkbox.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a boolean.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsCheckbox::BoundValueToElement(CElement *pElem,
                                           LONG,
                                           BOOL,
                                           LPVOID pvData) const
{
    CInput *pCheckbox = DYNCAST(CInput, pElem);

    Assert( pCheckbox->GetType() == htmlInputCheckbox || pCheckbox->GetType() == htmlInputRadio );

    HRESULT hr = THR(pCheckbox->SetChecked(*(VARIANT_BOOL *)pvData,
                                  FALSE /* don't SaveData */));
    if (!hr)
        Verify(!pElem->OnPropertyChange(DISPID_CInput_checked, 
                                        0, 
                                        (PROPERTYDESC *)&s_propdescCInputchecked));
    RRETURN(hr);
}

HRESULT
CDBindMethodsCheckbox::BoundValueFromElement(CElement *pElem,
                                             LONG,
                                             BOOL,
                                             LPVOID pvData) const
{
    CInput *pCheckbox = DYNCAST(CInput, pElem);

    RRETURN(pCheckbox->GetChecked((VARIANT_BOOL *)pvData));
}

static const CDBindMethodsInputTxtBase DBindMethodsInputTxtBase;
static const CDBindMethodsCheckbox DBindMethodsCheckbox;
static const CDBindMethodsRadio DBindMethodsRadio;

const CDBindMethods *
CInput::GetDBindMethods()
{
    htmlInput type = GetType();

    switch(type)
    {
    case htmlInputPassword:
    case htmlInputHidden:
    case htmlInputText:
    case htmlInputFile:
    case htmlInputReset:
    case htmlInputSubmit:
    case htmlInputButton:
        return (CDBindMethods *)&DBindMethodsInputTxtBase;
    case htmlInputCheckbox:
        return (CDBindMethods *)&DBindMethodsCheckbox;
    case htmlInputRadio:
        return (CDBindMethods *)&DBindMethodsRadio; 
    default:
        return NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound radio button group.  Only called if 
//            DBindKind allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a bstr
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsRadio::BoundValueToElement(CElement *pElem,
                    LONG,
                    BOOL,
                    LPVOID pvData) const
{
    // Search for a radio button with value equal to pcData
    HRESULT hr;
    CInput *pRadio = DYNCAST(CInput, pElem);
    LPCTSTR lpName=pRadio->GetAAname();         // NAME= field from INPUT tag

    if (lpName)
    {
        // Clear the currently set radiobutton.
        IGNORE_HR(pRadio->TraverseGroup( 
                    lpName, 
                    VISIT_METHOD(CInput, Clear, clear),
                    0,
                    TRUE));

        // check the button whose value appears in the data
        hr = THR(pRadio->TraverseGroup( lpName,
                    VISIT_METHOD(CInput, SetByValue, setbyvalue),
                    (DWORD_PTR) pvData,
                    TRUE));
    }
    else
    {
        // the user forgot the NAME field, bind to just this button.
        hr = pRadio->SetByValue((DWORD_PTR)pvData);
        
        // If there's no NAME field, then this is just a single button, so
        // if binding doesn't match, we must shut the button off ourselves.
        // Can't depend on mutual exclusion to do it.
        if (hr == S_FALSE)
        {
            IGNORE_HR(pRadio->SetChecked(VB_FALSE, FALSE /* don't SaveData */));
            Verify(!pElem->OnPropertyChange(DISPID_CInput_checked, 
                                            0, 
                                            (PROPERTYDESC *)&s_propdescCInputchecked));
        }
    }

    // failure to find a matching NAME is not a failure
    if (hr == S_FALSE)
        hr = S_OK;
    
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function: BoundValueFromElement, CDBindMethods
//
//  Synopsis: Transfer data from bound radio button group.  Only called if 
//            DBindKind allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a bstr
//
//  Returns:  S_OK      no problems
//            S_FALSE   No radio button was checked!
//                      BEWARE! This is a very possible state for a bound
//                      radio button to be in, if the value in the database
//                      did not match any of the Value fields of radio buttons.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsRadio::BoundValueFromElement(CElement *pElem,
                      LONG,
                      BOOL,
                      LPVOID pvData) const
{
    // Get the value form the radio button in this group that is set.
    HRESULT hr;
    CInput *pRadio = DYNCAST(CInput, pElem);
    LPCTSTR lpName=pRadio->GetAAname();         // NAME= field from INPUT tag
    * (BSTR *) pvData = NULL;

    if (lpName)
    {
        hr = THR(pRadio->TraverseGroup( lpName,
                    VISIT_METHOD(CInput, GetValue, getvalue),
                    (DWORD_PTR) pvData,
                    TRUE));
    }
    else
    {
        // the user forgot the NAME field, look at just this button
        hr = pRadio->GetValue((DWORD_PTR)pvData);
    }

    RRETURN1(hr, S_FALSE);
}


HRESULT
CDBindMethodsInputTxtBase::BoundValueFromElement(CElement * pElem,
                                                 LONG       id,
                                                 BOOL       fHTML,
                                                 LPVOID     pvData) const
{
    HRESULT     hr;
    CStr        cstr;
    BSTR *      pBstr   = (BSTR *) pvData;

    Assert(pBstr);
    // shouldn't be called for one-way bindings
    Assert((_dwTransfer & DBIND_ONEWAY) == 0);

#if DBG==1
    {
        DBINFO dbi;

        Assert(id == ID_DBIND_DEFAULT);
        Assert(DBindKind(pElem, id, &dbi) > DBIND_NONE);
        Assert(dbi._vt == VT_BSTR);
    }
#endif // DBG == 1

    hr = THR(DYNCAST(CInput, pElem)->GetValueHelper(&cstr));
    if (hr)
        goto Cleanup;

    hr = cstr.AllocBSTR(pBstr);

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: transfer bound data to input text element.  We need to override
//            the CElement implementation to remember the value being
//            transferred as the "last value".  This keeps the onchange event
//            from firing simply because the value is databound.
//
//  Arguments:
//            [id]      - ID of binding point.
//            [fHTML]   - is HTML-formatted data called for?
//            [pvData]  - pointer to data to transfer, in the expected data
//                        type.  For text-based transfers, must be BSTR.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsInputTxtBase::BoundValueToElement ( CElement *pElem,
                                                 LONG id,
                                                 BOOL fHTML,
                                                 LPVOID pvData ) const
{
    CInput *    pInput = DYNCAST(CInput, pElem);
    BSTR *      pBstr = (BSTR *) pvData;
    HRESULT     hr;


    hr = THR(pInput->SetValueHelper((TCHAR *) *pBstr, FormsStringLen(*pBstr)));
    if (hr)
        goto Cleanup;

    // Remember the value
    // Call GetValueHelper instead of using pvData directly. This is because
    // the control may modify the given value (e.g. CR-LF munging - bug 3763).
    hr = THR(pInput->GetValueHelper(&pInput->_cstrLastValue));

    // We should call pInput->SetValueHelper with fOM set to FALSE
    // in order to fire onpropertychange, since we have to
    // call onpropertychange anyway for the cases where layout is not
    // created or not listening, we prefer do it here.
    Verify(!pElem->OnPropertyChange(DISPID_A_VALUE, 0, (PROPERTYDESC *)&s_propdescCInputvalue));

Cleanup:
    RRETURN(hr);
}
#endif // ndef NO_DATABINDING


//+---------------------------------------------------------------------------
//
//  Member:     CInput::createTextRange
//
//----------------------------------------------------------------------------
HRESULT
CInput::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT         hr = S_OK;
    CAutoRange *    pAutoRange = NULL;
    CMarkup *       pMarkupSlave;
    CElement *      pElemSlave;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!HasSlavePtr())
        goto Cleanup;
    
    pElemSlave = GetSlavePtr();
    pMarkupSlave = pElemSlave->GetMarkup();
    pAutoRange = new CAutoRange( pMarkupSlave, pElemSlave );

    if (!pAutoRange)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the lookaside entry for this range
    pAutoRange->SetNext( pMarkupSlave->DelTextRangeListPtr() );
    hr = THR( pMarkupSlave->SetTextRangeListPtr( pAutoRange ) );
    if (hr)
        goto Cleanup;

    hr = THR( pAutoRange->Init() );

    if (hr)
        goto Cleanup;

    Assert( GetSlavePtr() == pElemSlave && GetSlavePtr()->GetMarkup() == pMarkupSlave );

    hr = THR_NOTRACE( pAutoRange->SetTextRangeToElement( pElemSlave ) );

    Assert( hr != S_FALSE );

    if (hr)
        goto Cleanup;

    *ppDisp = pAutoRange;
    pAutoRange->AddRef();

Cleanup:
    if (pAutoRange)
    {
        pAutoRange->Release();
    }

    RRETURN( SetErrorInfo( hr ) );
}


void
CInput::BtnHelperSetFocus(void)
{
    CDoc *  pDoc = Doc();

    Assert (GetType() == htmlInputFile);

    _fButtonHasFocus = TRUE;

    _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
    ChangePressedLook();

    pDoc->GetView()->SetFocus(this, 0);

    // Hide the caret
    if (pDoc->_pCaret)
    {
        pDoc->_pCaret->Hide();
    }
}

void
CInput::BtnHelperKillFocus(void)
{
    Assert (GetType() == htmlInputFile);
    BTN_RESETSTATUS(_wBtnStatus);
    ChangePressedLook();
    _fButtonHasFocus = FALSE;
    Doc()->GetView()->SetFocus(this, 0);
}


HRESULT
CInput::DoClickCheckbox(CMessage * pMessage /*=NULL*/, CTreeNode *pNodeContext /*=NULL*/,
                          BOOL fFromLabel /*=FALSE*/, EVENTINFO* pEvtInfo /*= NULL*/ )
{
    HRESULT hr          = S_OK;
    BOOL    fOldChecked = !!_fChecked;
    WORD    wOldStatus  = _wBtnStatus;

    if (!IsEnabled() && !IsEditable(TRUE))
        goto Cleanup;

    if(!pNodeContext)
        pNodeContext = GetFirstBranch();

    if(!pNodeContext)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!TestLock(ELEMENTLOCK_CLICK))
    {
        CLock     Lock(this, ELEMENTLOCK_CLICK);
        CTreeNode::CLock NodeLock;

        hr = THR( NodeLock.Init(pNodeContext) );
        if( hr )
            goto Cleanup;

        // Set check before firing onclick (Netscape Compat.)
        IGNORE_HR(ClickAction(pMessage));
        if (Fire_onclick(pNodeContext, -1, pEvtInfo ))
            goto Cleanup;

        // Click event was cancelled, so restore old value (Netscape Compat.)
        if (fOldChecked == !!_fChecked)
        {
            _wBtnStatus = wOldStatus;
            GetUpdatedLayout()->Invalidate();
        }
        else
        {
            put_checked(_fChecked ? VB_FALSE : VB_TRUE);
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::Getchecked, Setchecked
//
//  Synopsis:   Functions that are called by the vtable when properties
//              are requested.
//
//--------------------------------------------------------------------------

HRESULT
CInput::put_checked(VARIANT_BOOL checked)
{
    HRESULT hr;

    hr = SetErrorInfo(SetChecked(checked));
    if (FAILED(hr))
        goto Cleanup;

    if (!_fChecked)
    {
        CFormElement    * pForm = GetParentForm();

        if (pForm)
        {
            if (!pForm->_fInTraverseGroup)
                DelRadioGroup(GetAAname());
        }
        else
        {
            CMarkup     * pMarkup = GetMarkup();

            if (pMarkup && !pMarkup->_fInTraverseGroup)
                DelRadioGroup(GetAAname());
        }
    }

    Verify(!OnPropertyChange(DISPID_CInput_checked, 
                             0, 
                             (PROPERTYDESC *)&s_propdescCInputchecked));

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::get_checked(VARIANT_BOOL * pchecked)
{
    if ( !pchecked )
        return ( SetErrorInfo(E_INVALIDARG));

    return(SetErrorInfo(GetChecked(pchecked)));
}

HRESULT
CInput::put_status(VARIANT status)
{
    switch(status.vt)
    {
        case VT_NULL:
        _vStatus.vt = VT_NULL;
        break;
        case VT_BOOL:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = V_BOOL(&status);
        break;
        default:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = VB_TRUE;
    }

    Verify(S_OK==OnPropertyChange(DISPID_CInput_status, 
                                  0, 
                                  (PROPERTYDESC *)&s_propdescCInputstatus));

    RRETURN(S_OK);
}

HRESULT
CInput::get_status(VARIANT * pStatus)
{
    if (_vStatus.vt==VT_NULL)
    {
        pStatus->vt = VT_NULL;
    }
    else
    {
        pStatus->vt = VT_BOOL;
        V_BOOL(pStatus) = V_BOOL(&_vStatus);
    }
RRETURN(S_OK);
}


// status is an altternative NS name for "checked"
HRESULT
CInput::put_status(VARIANT_BOOL checked)
{
   RRETURN(SetErrorInfo(put_checked(checked)));
}

HRESULT
CInput::get_status(VARIANT_BOOL * pchecked)
{
    if ( !pchecked )
        return ( SetErrorInfo(E_INVALIDARG));
    return(GetChecked(pchecked));
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::GetChecked, SetChecked
//
//  Synopsis:   Helper properties that are implemented for CBtnHelper
//
//--------------------------------------------------------------------------


HRESULT
CInput::SetChecked(VARIANT_BOOL checked, BOOL fSaveData)
{
    HRESULT hr            = S_OK;
    unsigned fCheckedOrig = _fChecked;
    BOOL fIsRadio         = (GetType() == htmlInputRadio);
    BOOL fIsInMarkup      = IsInMarkup();

    if (fIsRadio)
    {
        // if there a state change or the setting is to Off...
        //  just call the super. otherwise we have to turn off
        //  any other radiobuttons in our group which are on.
        if (checked == -(VARIANT_BOOL)_fChecked)
            goto Cleanup;

        // if fSaveData is FALSE, we're being called on behalf of BoundValueToElement,
        // and so the current group is already cleared.

        if (checked && fSaveData && fIsInMarkup)
        {
            // if only if multiple default checked radios need traversegroup
            // if (AddRadioGroup(GetAAname()) == S_FALSE && !_fDeferClearGroup)

            LPCTSTR     lpGroupName = GetAAname();

            if (AddRadioGroup(lpGroupName) == S_FALSE || !_fDeferClearGroup)
            {
                // Clear the currently set radiobutton.
                IGNORE_HR(TraverseGroup(lpGroupName,
                                        VISIT_METHOD(CInput, Clear, clear),
                                        0,
                                        TRUE));
            }
        }
    }

    _fChecked = checked;

#ifndef NO_DATABINDING
    if (fSaveData && fIsInMarkup)
    {
        hr = SaveDataIfChanged(ID_DBIND_DEFAULT);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }
        else                    // if we can't save bound value, ignore change
        {
            DBMEMBERS * pdbm = GetDBMembers();
            if (fIsRadio && pdbm)
            {
                // we have to set all the buttons in the group back to their
                // original state (bug 61432).  The simplest way to do this
                // is to just reread the value from the database.
                IGNORE_HR(pdbm->TransferFromSrc(this, ID_DBIND_DEFAULT));
            }
            else
            {
                _fChecked = fCheckedOrig;
            }
        }
    }
#endif

    if (IsEditable(TRUE))
        put_BoolHelper(-(VARIANT_BOOL)_fChecked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);

    if (_fChecked != fCheckedOrig && fIsInMarkup && IsOptionButton() && HasLayoutPtr())
    {
        GetLayoutPtr()->Invalidate();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::GetChecked(VARIANT_BOOL * pchecked)
{
    *pchecked = _fChecked ? VB_TRUE : VB_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Member:      CInput::SaveCheckbox
//
// Synopsis:    saves the checkbox/radiobutton
//

//----------------------------------------------------------------------------
HRESULT CInput::SaveCheckbox(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd )
{
    // in run mode the CHECKED and DEFAULTCHECKED properties are
    // not insync, which is intentional to allow the reset functionallity
    // if we save in run we allways want to save the current state
    // (e.g. for printing) therefore we temporarly set the default checked
    // value and then reset it again after saving...
    HRESULT hr;
    VARIANT_BOOL bCurstate = GetAAdefaultChecked();
    DWORD dwIgnore;

    if( !_fChecked )
    {
        (*GetAttrArray())->FindSimpleInt4AndDelete( DISPID_CInput_defaultChecked, &dwIgnore );
    }
    else
    {
        SetAAdefaultChecked(_fChecked);
    }

    hr = super::Save(pStreamWrBuff, fEnd);

    if( !bCurstate )
    {
        (*GetAttrArray())->FindSimpleInt4AndDelete( DISPID_CInput_defaultChecked, &dwIgnore );
    }
    else
    {
        SetAAdefaultChecked(bCurstate);
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
// Member:      CInput::HandleCheckboxMessage
//
// Synopsis:    Handle window message
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CInput::HandleCheckboxMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;
                            
    BOOL    fRunMode = !IsEditable(TRUE) && ! IsMasterParentEditable() ;
                           
    if (GetType() == htmlInputRadio)
    {
        BOOL    fAlt = pMessage->dwKeyState & FALT;
        BOOL    fCtrl = pMessage->dwKeyState & FCONTROL;

        if (fRunMode && !fAlt && !fCtrl && pMessage->message == WM_KEYDOWN)
        {
            // try to handle the message right here
            switch(pMessage->wParam)
            {
            case VK_LEFT:
            case VK_UP:
                BTN_RESETSTATUS(_wBtnStatus);
                NavigateToNext(pMessage, FALSE);
                hr = S_OK;
                break;

            case VK_RIGHT:
            case VK_DOWN:
                BTN_RESETSTATUS(_wBtnStatus);
                NavigateToNext(pMessage, TRUE);
                hr = S_OK;
                break;
            }
        }

        if (hr != S_FALSE)
            goto Cleanup;
    }

    if (IsEnabled() && ( fRunMode || 
                        ( Doc()->_pElemCurrent == this && pMessage->htc != HTC_BEHAVIOR ) ))
    {
        hr = BtnHandleMessage(pMessage);
        if (hr != S_FALSE)
            goto Cleanup;
    }

    hr = super::HandleMessage(pMessage);

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::RenderGlyph
//
//  Synopsis:   renders the glyph for the button
//
//  Arguments:  [hdc] -- HDC to render into
//              [prc] -- rect to render info
//
//  Returns:    HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CInput::RenderGlyph(CFormDrawInfo * pDI, LPRECT prc)
{
    UINT            dfcs     = 0;
    VARIANT_BOOL    checked;
    HTHEME          hTheme = GetTheme(GetInputThemeClsId());

    Assert(IsOptionButton());

    if (hTheme)
    {
        XHDC            hdc    = pDI->GetDC(TRUE);        
        if (hdc.DrawThemeBackground(    hTheme,
                                        (GetType() == htmlInputRadio)
                                            ? BP_RADIOBUTTON
                                            : BP_CHECKBOX,
                                        GetThemeState(),
                                        prc,
                                        0))
            return S_OK;
    }

    GetChecked(&checked);
    if (checked)
        dfcs |= DFCS_CHECKED;

    if(BTN_PRESSED(_wBtnStatus))
        dfcs |= DFCS_PUSHED;

    if (!IsEnabled())
        dfcs |= DFCS_INACTIVE;

    switch (BtnStyle())
    {
    case GLYPHSTYLE_NONE:
        Assert(0);
        break;

    case GLYPHSTYLE_CHECK:
        dfcs |= DFCS_BUTTONCHECK;
        if (BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE))
        {
            dfcs |= DFCS_CHECKED | DFCS_BUTTON3STATE;
        }

        break;

    case GLYPHSTYLE_OPTION:
        dfcs |= DFCS_BUTTONRADIO;
        break;
    }

    FormsDrawGlyph(pDI, prc, DFC_BUTTON, dfcs);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CInput::FInSameGroup
//
//  Synopsis:   Check if the given site another radio button in the same
//              group as this one.
//
//-------------------------------------------------------------------------

BOOL
CInput::FInSameGroup(CElement * pElem)
{
    // Make sure pSite is a radio button
    Assert(pElem);
    if (!(pElem->Tag() == ETAG_INPUT &&
        DYNCAST(CInput, pElem)->GetAAtype() == htmlInputRadio))
    {
        return FALSE;
    }

    // Make sure they are in the same scope
    if (GetParentForm() != pElem->GetParentForm())
        return FALSE;

    LPCTSTR pnameThis = GetAAname();
    LPCTSTR pnameOther = DYNCAST(CInput, pElem)->GetAAname();

    return (pnameThis
        &&  pnameOther
        &&  FormsStringICmp(pnameThis, pnameOther) == 0);
}

//+------------------------------------------------------------------------
//
//  Member:     CInput::ClearGroup
//
//  Synopsis:   Clear the other radio buttons in the same group (if deferred
//              in Init2()).
//
//-------------------------------------------------------------------------
HRESULT
CInput::ClearGroup ( CRadioGroupAry * pRadioGroupArray )
{
    HRESULT             hr          = S_OK;
    LPCTSTR             pchName     = GetAAname();
    CFormElement *      pForm       = GetParentForm();
    RadioGroupEntry *   pEntry;
    int                 i;
    BOOL                fAddEntry;

    Assert(GetType() == htmlInputRadio);

    if (!pchName)
    goto Cleanup;

    Assert( pRadioGroupArray );

    // search for this group
    fAddEntry = TRUE;
    for (i = pRadioGroupArray->Size(), pEntry = *pRadioGroupArray; i > 0; i--, pEntry++)
    {
        if (pEntry->_pParentForm == pForm &&
            0 == FormsStringICmp(pEntry->_pRadio->GetAAname(), pchName))
        {
            if (_fChecked)
            {
                // Clear the previous button
                if (pEntry->_pRadio->_fChecked)
                    pEntry->_pRadio->put_checked(FALSE);

                pEntry->_pRadio = this;
            }
            else
            {
            }
            fAddEntry = FALSE;
                break;
        }
    }

    if (fAddEntry)
    {
        hr = THR(pRadioGroupArray->Grow(pRadioGroupArray->Size() + 1));
        if (hr)
            goto Cleanup;
        pEntry = &pRadioGroupArray->Item(pRadioGroupArray->Size() - 1);
        pEntry->_pRadio = this;
        pEntry->_pParentForm = pForm;
        if (hr)
            goto Cleanup;     
    }
Cleanup:
    RRETURN(hr);            
}


//+--------------------------------------------------------
//
//  Member:     CInput::Clear
//
//  Synopsis:   CCheckbox override, since CRadioElements are mutually exclusive
//
//-------------------------------------------------------------------------

HRESULT 
CInput::Clear(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        put_checked(FALSE);
    }
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Function: GetElementDataBound, CElement
//
//  Synopsis: For the given site, find whichever site handles its databinding.
//            (Note that the returned site might not have any databinding
//            specified at all.)  This method allows one bound radio button
//            to act as a binding proxy for all of the buttons in a group.
//
//  Return:   either site itself, or else some other bound radiobutton in the
//            same group.
//
//-----------------------------------------------------------------------------
CElement *
CInput::GetElementDataBound()
{
    CElement *pElement = this;

    if (GetType() == htmlInputRadio)
    {
        IGNORE_HR(TraverseGroup(
            GetAAname(),
            VISIT_METHOD(CInput, FindBoundRadioElement, findboundradioelement),
            (DWORD_PTR) &pElement,
            TRUE));
    }
    else
    {
        pElement = super::GetElementDataBound();
    }

    return pElement;
}

HRESULT
CInput::FindBoundRadioElement(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

#ifndef NO_DATABINDING   
    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        if (GetDBMembers() != NULL)
        {
            * (CElement **) dw = this;
            hr = S_OK;
        }
    }
#endif // ndef NO_DATABINDING

    RRETURN1(hr, S_FALSE);
}
    

//+--------------------------------------------------------
//
//  Member:     CInput::SetByValue
//
//  Synopsis:   CCheckbox override, sice CRadioElements are mutually exclusive
//
//-------------------------------------------------------------------------

HRESULT 
CInput::SetByValue(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        CStr    cstrValue;
        HRESULT hr1 = GetValueHelper(&cstrValue);

        if (hr1)
        {
            hr = hr1;
            goto Cleanup;
        }
        
        if (FormsStringCmpLoc(*(BSTR *) dw, cstrValue) == 0)
        {
            // (sambent) SetByValue is only called from BoundValueToElement
            // so call SetChecked with the flag that suppresses the call to
            // SaveDataIfChanged.  This avoids redundant fetching from the database.
            hr = THR(SetChecked(VB_TRUE, FALSE /* don't SaveData */));
            Verify(!OnPropertyChange(DISPID_CInput_checked, 
                                     0, 
                                     (PROPERTYDESC *)&s_propdescCInputchecked));
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+--------------------------------------------------------
//
//  Member:     CInput::GetValue
//
//  Synopsis:   CCheckbox override, sice CRadioElements are mutually exclusive
//
//-------------------------------------------------------------------------

HRESULT
CInput::GetValue(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        if (_fChecked)
            hr = THR(get_PropertyHelper((BSTR *) dw, (PROPERTYDESC *)&s_propdescCInputvalue));
    }
    RRETURN1(hr, S_FALSE);
}


//+--------------------------------------------------------
//
//  Member:     CInput::NavigateToNext
//
//  Synopsis:   Make the radio element after this one current.
//
//-------------------------------------------------------------------------

void
CInput::NavigateToNext(CMessage * pMessage, BOOL fForward)
{
    CElement *     pElement = NULL;

    TraverseGroup( 
        GetAAname(), 
        VISIT_METHOD(CInput, GetNext, getnext),
        (DWORD_PTR) &pElement,
        fForward);

    if (pElement)
    {
        IGNORE_HR(pElement->BecomeCurrentAndActive());
        IGNORE_HR(pElement->ScrollIntoView());
        IGNORE_HR(pElement->DoClick(pMessage));
    }
}


HRESULT
CInput::GetNext(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        CElement ** ppElement = (CElement **) dw;

        if (*ppElement)
        {
            *ppElement = this;
            hr = S_OK;
        }            
        else if (this == Doc()->_pElemCurrent)
            *ppElement = this;
    }
    RRETURN1(hr, S_FALSE);
}


HRESULT CInput::GetHeight(long *pl)
{
    VARIANT v;
    HRESULT hr;

    Assert(GetType() == htmlInputImage);
    hr = THR(s_propdescCInputheight.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CInput::putHeight(long l)
{
    VARIANT v;

    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCInputheight.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_AUTOMATION | HANDLEPROP_DONTVALIDATE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}

HRESULT CInput::GetWidth(long *pl)
{
    VARIANT v;
    HRESULT hr;

    Assert(GetType() == htmlInputImage);
    hr = THR(s_propdescCInputwidth.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CInput::putWidth(long l)
{
    VARIANT v;

    Assert(GetType() == htmlInputImage);
    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCInputwidth.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_DONTVALIDATE | HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}


STDMETHODIMP CInput::put_height(long l)
{
    RRETURN(SetErrorInfoPSet(putHeight(g_uiDisplay.DeviceFromDocPixelsY(l)), DISPID_CInput_height));
}

STDMETHODIMP CInput::get_height(long *p)
{
    HRESULT hr = S_OK;

    if ( !p )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((GetType() == htmlInputImage && _pImage))
        RRETURN (_pImage->get_height(p));

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_height));
}

STDMETHODIMP CInput::put_align(BSTR bstrAlign)
{
    RRETURN(s_propdescCInputalign.b.SetEnumStringProperty(
                bstrAlign,
                this,
                (CVoid *)(void *)(GetAttrArray()) ));
}

STDMETHODIMP CInput::get_align(BSTR *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if (GetType() != htmlInputImage)
        goto Cleanup;

    hr = s_propdescCInputalign.b.GetEnumStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CInput::put_width(long l)
{
    RRETURN(SetErrorInfoPSet(putWidth(g_uiDisplay.DeviceFromDocPixelsX(l)), DISPID_CInput_width));
}

STDMETHODIMP CInput::get_width(long *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if ((GetType() == htmlInputImage && _pImage))
        hr = _pImage->get_width(p);

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_width));
}

STDMETHODIMP
CInput::get_src(BSTR * pstrFullSrc)
{
    HRESULT hr = S_OK;

    if (!pstrFullSrc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pstrFullSrc = NULL;

    if ((GetType() == htmlInputImage && _pImage))
    {
        hr = _pImage->get_src(pstrFullSrc);
    }
    else
    {
        hr = s_propdescCInputsrc.b.GetUrlProperty(pstrFullSrc, this, CVOID_CAST(GetAttrArray()));
    }

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_src));
}

//+------------------------------------------------------------------
//
//  member : put_src
//
//  sysnopsis : impementation of the interface src property set
//          since this is a URL property we want the crlf striped out
//
//-------------------------------------------------------------------

STDMETHODIMP
CInput::put_src(BSTR bstrSrc)
{
    RRETURN(SetErrorInfo(s_propdescCInputsrc.b.SetUrlProperty(bstrSrc,
                    this,
                    (CVoid *)(void *)(GetAttrArray()))));
}

/*

HRESULT STDMETHODCALLTYPE CInput::put_ie4vtblslot(BSTR)
{
    Assert(GetType() == htmlInputImage);
    return (E_ACCESSDENIED);
}
*/

//+----------------------------------------------------------------------------
//
// Methods:     get/set_hspace
//
// Synopsis:    hspace for aligned images is 3 pixels by default, so we need
//              a method to identify if a default value is specified.
//
//-----------------------------------------------------------------------------

STDMETHODIMP CInput::put_hspace(long v)
{
    RRETURN(s_propdescCInputhspace.b.SetNumberProperty(v, this, CVOID_CAST(GetAttrArray())));
}

STDMETHODIMP CInput::get_hspace(long * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if ((GetType() == htmlInputImage && _pImage))
    {
        HRESULT hr = s_propdescCInputhspace.b.GetNumberProperty(p, this, CVOID_CAST(GetAttrArray()));

        if(!hr)
            *p = *p == -1 ? 0 : *p;
    }

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_hspace));
}

//+----------------------------------------------------------------------------
//
//  Member : [get_/put_] onload
//
//  synopsis : store in this element's propdesc
//
//+----------------------------------------------------------------------------

HRESULT
CInput:: put_onload(VARIANT v)
{
    HRESULT hr = S_OK;

    if ((GetType() == htmlInputImage && _pImage))
    {
        hr = THR(s_propdescCInputonload .a.HandleCodeProperty(
                HANDLEPROP_SET | HANDLEPROP_AUTOMATION |
                (PROPTYPE_VARIANT << 16),
                &v,
                this,
                CVOID_CAST(GetAttrArray())));
    }

    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CInput:: get_onload(VARIANT *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    p->vt = VT_NULL;

    if ((GetType() == htmlInputImage && _pImage))
    {
        hr = THR(s_propdescCInputonload.a.HandleCodeProperty(
                    HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                    p,
                    this,
                    CVOID_CAST(GetAttrArray())));
    }
Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+----------------------------------------------------------------------------
//
//  Member:     CInput:get_strReadyState
//
//
//+------------------------------------------------------------------------------

HRESULT
CInput::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if (GetType() != htmlInputImage)
    {
        goto Cleanup;
    }

    hr=THR(s_enumdeschtmlReadyState.StringFromEnum(_pImage->_readyStateFired, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CInput::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CInput::get_readyStateValue(long *plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRetValue = _pImage->_readyStateFired;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CInput::ContextThunk_InvokeExReady(DISPID dispid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT *pvarResult,
                        EXCEPINFO *pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    if (GetType() == htmlInputImage)
    {
        Assert(_pImage);

        hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(ReadyStateInvoke(
                                            dispid,
                                            wFlags,
                                            _pImage->_readyStateFired,
                                            pvarResult));
    }
    hr = THR_NOTRACE(super::ContextInvokeEx(
                                dispid,
                                lcid,
                                wFlags,
                                pdispparams,
                                pvarResult,
                                pexcepinfo,
                                pSrvProvider,
                                pUnkContext ? pUnkContext : (IUnknown*)this));

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CInput::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

HRESULT
CInput::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT hr = S_FALSE;
    CDoc *pDoc = Doc();

    if (pDoc->_pInPlace == NULL)
        goto Cleanup;

    // check to see if tooltip should display the title property
    //
    hr = THR(super::ShowTooltip(pmsg, pt));
    if (hr == S_OK || GetType() != htmlInputImage)
        goto Cleanup;

    Assert(_pImage);
    hr = _pImage->ShowTooltip(pmsg, pt);

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

void
CInput::Passivate()
{
    if (_pImage)
    {
        _pImage->Passivate();
        delete _pImage;
        _pImage = NULL;
    }

    switch (GetType())
    {
    case htmlInputButton:
    case htmlInputSubmit:
    case htmlInputReset:
    case htmlInputFile:
    case htmlInputText:
    case htmlInputPassword:
    case htmlInputHidden:
        if (HasSlavePtr())
        {
            CElement * pElemSlave = GetSlavePtr();

            // Stop listening to events on the slave
            SetupSlaveEventSink(FALSE, pElemSlave);
        }
        break;
    }

    super::Passivate();
}

HRESULT
CInput::PrivateInit2()
{
    HRESULT     hr = S_OK;
    htmlInput   type = GetType();
    UINT    uiBtnDefault    = IDS_BUTTONCAPTION_SUBMIT;
    TCHAR   pszCaption[128];
    int     c;

    switch (type)
    {
    case htmlInputReset:
        uiBtnDefault = IDS_BUTTONCAPTION_RESET;
        // fall through
    case htmlInputSubmit:
        if (_fHasInitValue || TLS(nUndoState) != UNDO_BASESTATE)
            break;
        c = LoadString(GetResourceHInst(),
                   uiBtnDefault, pszCaption, ARRAY_SIZE(pszCaption));
        if (c)
        {
            hr = THR(SetValueHelper(pszCaption, c));
            if (hr)
                goto Cleanup;
        }
        break;
    case htmlInputFile:
        {
            //remove initital value from input file
            // set value to a empty string
            // ascii only
            // not OM
            if (TLS(nUndoState) == UNDO_BASESTATE)
                hr = SetValueHelperReal(_T(""), 0, TRUE, FALSE);
        }
        // fall through
    case htmlInputText:
    case htmlInputPassword:
        _fReadOnly = !!GetAAreadOnly();
        break;
    }

    // Do we need to create a inner element?
    if (!IsOptionButton() && type != htmlInputImage && !HasSlavePtr())
    {
        hr = THR(CreateSlave());
        if (hr)
            goto Cleanup;
    }

    // If we are in the middle of an undo operation, trust that the undo
    // queue has enough information to restore the value.
    if (!_fHasMorphed && _fHasInitValue && TLS(nUndoState) == UNDO_BASESTATE)
    {
        hr = SetValueHelper((TCHAR *) _cstrDefaultValue,
                            _cstrDefaultValue.Length(), FALSE);
        if (hr)
            goto Cleanup;
    }

    _fTextChanged = FALSE;

Cleanup:

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::CreateSlave
//
//  Synopsis:   Creates the slave element for the input
//
//--------------------------------------------------------------------------
HRESULT
CInput::CreateSlave()
{
    CMarkup *       pInputMarkup = NULL;
    CElement  *     pElemSlave = NULL;
    CDoc *          pDoc = Doc();
    HRESULT         hr = S_OK;

    Assert(!HasSlavePtr());

    hr = THR(pDoc->CreateMarkup( &pInputMarkup, GetWindowedMarkupContext(), TRUE));
    if (hr)
        goto Cleanup;
    pElemSlave = pInputMarkup->Root();
    SetViewSlave(pElemSlave);
    pInputMarkup->Release();
    pInputMarkup = NULL;

    // Transfer ownership of the owns runs bit from element-owner to element-content
    pElemSlave->_fOwnsRuns = _fOwnsRuns;
    _fOwnsRuns = FALSE;

    // Listen to all events on the slave
    SetupSlaveEventSink(TRUE, pElemSlave);

Cleanup:
    if( pInputMarkup )
        pInputMarkup->Release();

    RRETURN(hr);
}

//HACKHACK 47681 : ignore height/width for inputs/no image
//+-------------------------------------------------------------------------
//
//  Method:     CInput::GetDispID
//
//  Synopsis:   need to ignore height and width
//
//--------------------------------------------------------------------------

STDMETHODIMP
CInput::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr = S_OK;
    STRINGCOMPAREFN pfnCompareString = (grfdex & fdexNameCaseSensitive)
                                                   ? StrCmpC : StrCmpIC;

    if (GetType() != htmlInputImage &&
        (pfnCompareString(s_propdescCInputheight.a.pstrName, bstrName) == 0 ||
        pfnCompareString(s_propdescCInputwidth.a.pstrName, bstrName) == 0))
    {
        // ignore height and width
        if (grfdex & fdexNameEnsure)
        {
            hr = AddExpando(bstrName, pid);
        }
        else
        {
            *pid = DISPID_UNKNOWN;
            hr  = DISP_E_UNKNOWNNAME;
        }
    }
    else
    {
        hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));
    }
    
    RRETURN(hr);
}

// end of HACKHACK 47681 -> remmeber removing map to in inputtxt.pdl

//+--------------------------------------------------------------
//
//  Member:     CInput::AddRadioGroup(LPCTSTR lpstrGrpName);
//
//  Synopsis:   Add a new radio group name,
//
//              S_OK:       name added
//              S_FALSE:    the name is already there
//
//---------------------------------------------------------------
HRESULT
CInput::AddRadioGroup(LPCTSTR lpstrGrpName)
{
    CFormElement *pForm      = GetParentForm();
    CMarkup      *pMarkup    = GetMarkup(); Assert(pMarkup);
    RADIOGRPNAME *pGroupName = pForm ? pForm->_pRadioGrpName : pMarkup->GetRadioGroupName();
    RADIOGRPNAME *pNew;
    RADIOGRPNAME *pPrev = 0;
    int          iCompResult = 1;

    if (!lpstrGrpName || !lpstrGrpName[0])
        return S_FALSE;

    while (pGroupName)
    {
        iCompResult = FormsStringICmp(lpstrGrpName, pGroupName->lpstrName);
        if (iCompResult == 0)
            return S_FALSE;

        // the new one should be inserted in the order
        if (iCompResult < 0)
            break;

        pPrev = pGroupName;
        pGroupName = pGroupName->_pNext;
    }

    pNew = new RADIOGRPNAME();
    if (!pNew)
        return E_OUTOFMEMORY;

    pNew->lpstrName =SysAllocString(lpstrGrpName);
    if (!pNew->lpstrName)
    {
        delete pNew;
        return E_OUTOFMEMORY;
    }

    if (pPrev)
    {
        pPrev->_pNext = pNew;
    }
    else
    {
        if (pForm)
        {
            pForm->_pRadioGrpName = pNew;
        }
        else
        {
            pMarkup->SetRadioGroupName(pNew);
        }
    }

    pNew->_pNext = pGroupName;

    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CInput::DelRadioGroup(LPCTSTR lpstrGrpName);
//
//  Synopsis:   delete a radio group name,
//
//              S_OK:       name deleted
//              S_FALSE:    name not found
//
//---------------------------------------------------------------
HRESULT
CInput::DelRadioGroup(LPCTSTR lpstrGrpName)
{
    CMarkup      *pMarkup    = GetMarkup(); Assert(pMarkup);
    CFormElement *pForm      = GetParentForm();
    RADIOGRPNAME *pGroupName = pForm ? pForm->_pRadioGrpName : pMarkup->GetRadioGroupName();
    RADIOGRPNAME *pPrev      = 0;
    int          iCompResult = 1;

    if (!lpstrGrpName || !lpstrGrpName[0])
        return S_FALSE;

    while (pGroupName)
    {
        iCompResult = FormsStringICmp(lpstrGrpName, pGroupName->lpstrName);
        if (iCompResult == 0)
        {
            if (pPrev)
            {
                pPrev->_pNext = pGroupName->_pNext;
            }
            else
            {
                if (pForm)
                {
                    pForm->_pRadioGrpName = pGroupName->_pNext;
                }
                else
                {
                    pMarkup->SetRadioGroupName(pGroupName->_pNext);
                }
            }
            SysFreeString((BSTR)pGroupName->lpstrName);
            delete pGroupName;
            return S_OK;
        }

        if (iCompResult < 0)
            return S_FALSE;

        pPrev = pGroupName;
        pGroupName = pGroupName->_pNext;
    }

    return S_FALSE;
}


//+--------------------------------------------------------------
//
//  Member:     CInput::ChkRadioGroup(LPCTSTR lpstrGrpName);
//
//  Synopsis:   Check to see if the radio group is already there
//
//              S_OK:       yes
//              S_FALSE:    no
//
//---------------------------------------------------------------
HRESULT
CInput::ChkRadioGroup(LPCTSTR lpstrGrpName)
{
    CMarkup      *pMarkup    = GetMarkup(); Assert(pMarkup);
    CFormElement *pForm      = GetParentForm();
    RADIOGRPNAME *pGroupName = pForm ? pForm->_pRadioGrpName : pMarkup->GetRadioGroupName();
    int          iCompResult = 1;

    if (!lpstrGrpName || !lpstrGrpName[0])
        return S_OK;

    while (pGroupName)
    {
        iCompResult = FormsStringICmp(lpstrGrpName, pGroupName->lpstrName);
        if (iCompResult == 0)
            return S_OK;

        if (iCompResult < 0)
            return S_FALSE;
        pGroupName = pGroupName->_pNext;
    }

    return S_FALSE;
}


HRESULT
CInput::TraverseGroup(LPCTSTR strGroupName, PFN_VISIT pfn, DWORD_PTR dw, BOOL fForward)
{
    HRESULT hr = S_OK;

    // get the form this lives on
    //
    CFormElement * pForm = GetParentForm();

    if (pForm)
    {
        hr = THR(pForm->FormTraverseGroup(strGroupName, pfn, dw, fForward));
    }
    else
    {
        // Let the markup handle it
        
        CMarkup * pMarkup = GetMarkup();

        if (pMarkup)
            hr = THR(pMarkup->MarkupTraverseGroup(strGroupName, pfn, dw, fForward));
    }
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::SetIndeterminateHelper, GetIndeterminateHelper
//
//  Synopsis:   Helper function to get/set Indeterminate
//
//--------------------------------------------------------------------------

HRESULT
CInput::SetIndeterminateHelper(long indeterminate)
{
    _wBtnStatus = (indeterminate==VB_TRUE)?
                    BTN_SETSTATUS(_wBtnStatus, FLAG_TRISTATE) :
                    BTN_RESSTATUS(_wBtnStatus, FLAG_TRISTATE);

    if ((GetType() == htmlInputCheckbox) && !TLS(fInInitAttrBag))
    {
        GetUpdatedLayout()->Invalidate();
    }

    return S_OK;
}

HRESULT
CInput::GetIndeterminateHelper(long * pindeterminate)
{
    *pindeterminate = BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE)?VB_TRUE:VB_FALSE;

    return S_OK;
}

void
CInput::SetupSlaveEventSink(BOOL fAdvise, CElement * pElemSlave)
{
    Assert(pElemSlave);
    Assert(!fAdvise || pElemSlave == GetSlavePtr());

    if (fAdvise)
    {
        pElemSlave->DoAdvise(DIID_HTMLElementEvents, DISPID_A_EVENTSINK, &_SinkSlaveEvent, NULL, NULL);
        pElemSlave->SetEventsShouldFire();
    }
    else
    {
        pElemSlave->DoUnadvise(&_SinkSlaveEvent, DISPID_A_EVENTSINK);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
/// CSinkSlaveEvent
///

HRESULT
CSinkSlaveEvent::Invoke(
                        DISPID dispidMember,
                        REFIID riid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,
                        EXCEPINFO * pexcepinfo,
                        UINT * puArgErr)
{
    HRESULT                 hr              = S_OK;
    CElement *              pElemMaster     = CONTAINING_RECORD(this, CInput, _SinkSlaveEvent);
    CTreeNode *             pNodeMaster     = pElemMaster->GetFirstBranch();
    CElement *              pElemSlave      = pElemMaster->GetSlavePtr();

    Assert(pElemMaster->HasSlavePtr());

    CTreeNode *             pNodeSlave      = pElemSlave->GetFirstBranch();
    EVENTPARAM *            pParam          = pElemMaster->Doc()->_pparam;
    CStr                    strEventName;
    const PROPERTYDESC *    pPropDesc       = NULL;

    if (!pNodeMaster)
        goto Cleanup;

    hr = strEventName.Set(_T("on"));
    if (hr)
        goto Cleanup;

    Assert(pParam);
    hr = strEventName.Append(pParam->GetType());
    if (hr)
        goto Cleanup;

    pPropDesc = pElemMaster->FindPropDescForName(strEventName);

    // Don't fire the mouse transition events; these are taken care
    // of by the general viewlink logic in FireStdEventOnMessage for
    // WM_MOUSEOVER and WM_MOUSELEAVE
    switch (pPropDesc->GetDispid())
    {
    case DISPID_EVPROP_ONMOUSEOVER:
    case DISPID_EVPROP_ONMOUSEOUT:
    case DISPID_EVPROP_ONMOUSEENTER:
    case DISPID_EVPROP_ONMOUSELEAVE:
        goto Cleanup;
    }

    // Transform the event paramater from slave to master
    pParam->SetNodeAndCalcCoordinates(pNodeMaster, TRUE);
    if (pParam->_pNodeFrom == pNodeSlave)
    {
        pParam->_pNodeFrom = pNodeMaster;
    }
    if (pParam->_pNodeTo == pNodeSlave)
    {
        pParam->_pNodeTo = pNodeMaster;
    }
    if (pParam->_pElement)
    {
        pParam->_pElement->SubRelease();
        pParam->_pElement = pElemMaster;
        pElemMaster->SubAddRef();
    }

    // Fire the event on the master
    hr = pElemMaster->FireEvent(
            // SRamani says that this cast is "safe"
            (const PROPERTYDESC_BASIC *)pPropDesc,
            FALSE,
            pNodeMaster,
            0);

    V_VT(pvarResult) = VT_BOOL;
    V_BOOL(pvarResult) = (hr == S_FALSE) ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\tableom.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tableom.cxx
//
//  Contents:   CTable object model and interface implementations
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_CLRNGPRS_HXX_
#define X_CLRNGPRS_HXX_
#include <clrngprs.hxx>
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::createTHead
//
//  Synopsis:   Table OM method implementation
//
//  Arguments:  ppHead - return value
//
//----------------------------------------------------------------------------

HRESULT
CTable::createTHead(IDispatch** ppHead)
{
    HRESULT     hr = S_OK;

    if (ppHead)
    {
        *ppHead = NULL;
    }

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->createTHead(ppHead);

Cleanup:

    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::deleteTHead
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteTHead()
{
    HRESULT     hr = S_OK;

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->deleteTHead();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::createTFoot
//
//  Synopsis:   Table OM method implementation
//
//  Arguments:  ppFoot - return value
//
//----------------------------------------------------------------------------

HRESULT
CTable::createTFoot(IDispatch** ppFoot)
{
    HRESULT     hr = S_OK;

    if (ppFoot)
    {
        *ppFoot = NULL;
    }

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->createTFoot(ppFoot);

Cleanup:

    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::deleteTFoot
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteTFoot()
{
    HRESULT     hr = S_OK;

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->deleteTFoot();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable :: createCaption
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::createCaption(IHTMLTableCaption** ppCaption)
{
    HRESULT         hr = S_OK;

    if (ppCaption)
    {
        *ppCaption = NULL;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->createCaption(ppCaption);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable :: deleteCaption
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteCaption()
{
    HRESULT         hr;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->deleteCaption();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_tHead
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_tHead(IHTMLTableSection** ppHead)
{
    CTableLayout * pTableLayout;
    HRESULT hr;

    if (!ppHead)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHead = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();

    if (hr)
        goto Cleanup;

    if (pTableLayout->_pHead)
    {
        hr = pTableLayout->_pHead->QueryInterface(IID_IHTMLTableSection, (void **)ppHead);
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_tFoot
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_tFoot(IHTMLTableSection ** ppFoot)
{
    CTableLayout * pTableLayout = TableLayoutCache();
    HRESULT hr = S_OK;

    if (!ppFoot)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFoot = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (pTableLayout->_pFoot)
    {
        hr = pTableLayout->_pFoot->QueryInterface(IID_IHTMLTableSection, (void **)ppFoot);
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_rows
//
//  Synopsis:   Table OM method implementation. Return the rows collection
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_rows(IHTMLElementCollection ** ppRows)
{
    HRESULT hr;

    if (!ppRows)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppRows = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(TABLE_ROWS_COLLECTION));
    if ( hr )
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(TABLE_ROWS_COLLECTION, (IDispatch **)ppRows));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_tBodies
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_tBodies(IHTMLElementCollection ** ppSections)
{
    HRESULT hr;

    if (!ppSections)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    *ppSections = NULL;

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(TABLE_BODYS_COLLECTION));
    if ( hr )
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(TABLE_BODYS_COLLECTION, (IDispatch **)ppSections));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_caption
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_caption(IHTMLTableCaption **ppCaption)
{
    HRESULT     hr = S_OK;
    CTableCaption * pCaption;
    CTableLayout *  pTableLayout;

    if (!ppCaption)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCaption = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pCaption = pTableLayout->GetFirstCaption();

    if (pCaption)
    {
        hr = THR(pCaption->QueryInterface(IID_IHTMLTableCaption ,(void **)ppCaption));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableSection::get_rows
//
//  Synopsis:   Table OM method implementation. Return the rows collection
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::get_rows(IHTMLElementCollection ** ppRows)
{
    HRESULT hr;

    if (!ppRows)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppRows = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache(ROWS_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(ROWS_COLLECTION, (IDispatch **)ppRows));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable2::cells
//
//  Synopsis:   Table OM 
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_cells(IHTMLElementCollection ** ppCells)
{
    HRESULT hr;

    if (!ppCells)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCells = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // do the work to get the Cells Collection
    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());  // TABLE_CELL_COLLECTION
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(TABLE_CELLS_COLLECTION, (IDispatch**)ppCells));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable2::cells
//
//  Synopsis:   Table OM method implementation. Return the cells collection
//
//----------------------------------------------------------------------------

HRESULT
CTable::cells(BSTR szRange, IHTMLElementCollection ** ppCells)
{
    HRESULT hr;
    CStr                    strNormRange;

    if (!ppCells)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCells = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    if(_tcslen(szRange) == 0)
    {

        // Return the whole collection
        hr = THR(_pCollectionCache->GetDisp(TABLE_CELLS_COLLECTION, (IDispatch**)ppCells));
    }
    else
    {
        CCellRangeParser        cellRangeParser(szRange);
        RECT                    rectRange;

        if(cellRangeParser.Failed())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        strNormRange.Set(cellRangeParser.GetNormalizedRangeName());

        // do the work to get the Cells Collection
        // Create a collection cache if we don't already have one.
        hr = THR(EnsureCollectionCache());
        if (hr)
            goto Cleanup;

        cellRangeParser.GetRangeRect(&rectRange);

        hr = THR(_pCollectionCache->EnsureAry(TABLE_CELLS_COLLECTION));
        if (hr)
            goto Cleanup;

        hr = THR(_pCollectionCache->GetDisp(TABLE_CELLS_COLLECTION,  strNormRange,
                        CacheType_CellRange, (IDispatch**)ppCells, FALSE, &rectRange));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTable::insertRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::insertRow(long iRow, IDispatch **ppRow)
{
    HRESULT         hr;
    CTableSection * pSection;
    CTableLayout *  pTableLayout = TableLayoutCache();
    int             cRows;

    if (ppRow)
    {
        *ppRow = NULL;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    ////////////////////////////////////////////////////////////////////////////////////////////
    // winse 24231 a-naande 5-28-2002
    // it isn't necessary to completely rebuild the table for every additional row, it causes
    // a performance hit when building large tables with script
    pTableLayout->MarkTableLayoutCacheCurrent();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRows = pTableLayout->GetRows();

    if (iRow < - 1 || iRow > cRows)
    {
        pTableLayout->MarkTableLayoutCacheDirty();
        hr = pTableLayout->EnsureTableLayoutCache();

        if (hr)
            goto Cleanup;

        cRows = pTableLayout->GetRows();

        if (iRow < - 1 || iRow > cRows)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (iRow == -1 || iRow == cRows)
    {
        hr = pTableLayout->ensureTBody();
        if (hr)
            goto Cleanup;

        if (!pTableLayout->HasBody())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pSection = pTableLayout->_aryBodys[max(0, (pTableLayout->_aryBodys.Size() - 1))];

        if (cRows && pTableLayout->_pFoot)
        {
            pSection = pTableLayout->_pFoot;
        }

        if (!pSection)
        {
            hr = S_OK;
            goto Cleanup;
        }

        iRow = pSection->_cRows;    // insert after the last row
    }
    else
    {
        iRow = pTableLayout->VisualRow2Index(iRow);
        pSection = pTableLayout->GetRow(iRow)->Section();
        if (!pSection)
        {
            hr = S_OK;
            goto Cleanup;
        }
        iRow -= pSection->_iRow;    // relative to the section row index
    }

    Assert(pSection);
    hr = pSection->insertRow(iRow, ppRow);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTable::deleteRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteRow(long iRow)
{
    CTableRow *     pRowDelete;
    CTableLayout *  pTableLayout = TableLayoutCache();
    int             cRows;
    HRESULT         hr;
    BOOL            fIncrementalUpdatePossible;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRows = pTableLayout->GetRows();

    if (iRow == -1)
    {
        iRow = pTableLayout->GetRows() - 1;
    }

    if (iRow < 0 || iRow >= cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    iRow = pTableLayout->VisualRow2Index(iRow);

    pRowDelete = pTableLayout->_aryRows[iRow];
    Assert (pRowDelete);

    fIncrementalUpdatePossible = !pRowDelete->_fCrossingRowSpan       && 
                                  pTableLayout->_fAllRowsSameShape    && 
                                  pTableLayout->_aryRows.Size() != 1  && 
                                 !pRowDelete->_fParentOfTC;

    hr = pTableLayout->deleteElement(pRowDelete, fIncrementalUpdatePossible);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTable2::moveRow, moveRowHelper
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::moveRow(long iRow, long iRowTarget, IDispatch **ppRow)
{
    RRETURN(moveRowHelper(iRow, iRowTarget, ppRow));
}

HRESULT
CTable::moveRowHelper(long iRow, long iRowTarget, IDispatch **ppRow, BOOL fConvertRowIndices)
{
    CTableLayout    * pTableLayout;
    CTableRow       * pRowMoving = NULL;
    CTableRow       * pRowNeighbor;
    IHTMLElement    * pElemMoving = NULL;
    IHTMLElement    * pElemNeighbor = NULL;
    IMarkupServices * pMarkupServices = NULL;
    CDoc            * pDoc;
    IMarkupPointer  * pmpRowMovingBegin = NULL;
    IMarkupPointer  * pmpRowMovingEnd = NULL;
    IMarkupPointer  * pmpRowTarget = NULL;
    int               cRows;
    BOOL              fMoveToEnd = FALSE;
    HRESULT           hr = S_OK;

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (ppRow)
    {
        *ppRow = NULL;
    }

    if (iRow == iRowTarget)
        goto Cleanup;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRows = pTableLayout->GetRows();

    if (iRow == -1)
        iRow = cRows-1;
    if (iRowTarget == -1)
        iRowTarget = cRows-1;

    if (   iRow < 0 || iRow >= cRows
        || iRowTarget < 0 || iRowTarget >= cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (iRow == iRowTarget)
        goto Cleanup;

    // If row is moved down and since it is to become row number iRowTarget,
    // we need to add the number of rows disappearing to the bottom index.
    if (iRow < iRowTarget)
        iRowTarget += 1; // c

    if (iRowTarget >= cRows)
    {
        fMoveToEnd = TRUE;
        iRowTarget = cRows-1;
    }

    // Convert visual row index to internal row index.
    if (fConvertRowIndices)
    {
        iRow = pTableLayout->VisualRow2Index(iRow);
        iRowTarget = pTableLayout->VisualRow2Index(iRowTarget);
    }

    pRowMoving = pTableLayout->GetRow(iRow);
    pRowNeighbor = pTableLayout->GetRow(iRowTarget);
    pDoc = Doc();

    Assert(pRowMoving && pRowNeighbor && pDoc);

    hr = THR(pDoc->QueryInterface(IID_IMarkupServices, (LPVOID *) &pMarkupServices));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkupServices->CreateMarkupPointer(&pmpRowMovingBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkupServices->CreateMarkupPointer(&pmpRowMovingEnd));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkupServices->CreateMarkupPointer(&pmpRowTarget));
    if (hr)
        goto Cleanup;

    hr = THR(pRowMoving->QueryInterface(IID_IHTMLElement, (LPVOID *) &pElemMoving));
    if (hr)
        goto Cleanup;

    hr = THR(pRowNeighbor->QueryInterface(IID_IHTMLElement, (LPVOID *) &pElemNeighbor));
    if (hr)
        goto Cleanup;

    hr = THR(pmpRowMovingBegin->MoveAdjacentToElement(pElemMoving, ELEM_ADJ_BeforeBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pmpRowMovingEnd->MoveAdjacentToElement(pElemMoving, ELEM_ADJ_AfterEnd));
    if (hr)
        goto Cleanup;

    hr = THR(pmpRowTarget->MoveAdjacentToElement(pElemNeighbor, fMoveToEnd?ELEM_ADJ_AfterEnd:ELEM_ADJ_BeforeBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pTableLayout->moveElement(pMarkupServices, pmpRowMovingBegin, pmpRowMovingEnd, pmpRowTarget));

Cleanup:

    if (!hr && ppRow && pRowMoving)
    {
        hr = THR(pRowMoving->QueryInterface(IID_IDispatch, (LPVOID *) ppRow));
    }

    ReleaseInterface(pElemMoving);
    ReleaseInterface(pElemNeighbor);
    ReleaseInterface(pMarkupServices);

    ReleaseInterface(pmpRowMovingBegin);
    ReleaseInterface(pmpRowMovingEnd);
    ReleaseInterface(pmpRowTarget);

    RRETURN(hr);
}


//*********************************************************************
// CTable::GetDispID, IDispatch
//
//*********************************************************************

STDMETHODIMP
CTable::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr;
    LONG            lDisp;

    // Now let CBase to search for the dispid
    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

    if(hr == DISP_E_UNKNOWNNAME)
    {
        // This may be a tbl["a3:c6"] syntax, check of presence of the : or ..
        if(_tcschr(bstrName, _T(':')) || _tcsstr(bstrName, _T("..")))
        {
            // Create an atom to pass the string to the Invoke
            CAtomTable * pTable = GetAtomTable();
            hr = THR_NOTRACE(pTable->AddNameToAtomTable(bstrName, &lDisp));
            if(hr)
                goto Cleanup;
            lDisp += DISPID_COLLECTION_MIN;
            *pid = lDisp;
        }
    }

Cleanup:
    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}


#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

HRESULT
CTable::ContextThunk_InvokeEx (DISPID dispid, LCID lcid, WORD wFlags, DISPPARAMS *    pdispparams,
    VARIANT * pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;
    HRESULT    hr;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    if(dispid >= DISPID_COLLECTION_MIN && 
       dispid <= DISPID_COLLECTION_MAX)
    {
        CAtomTable * pTable = GetAtomTable();
        IHTMLElementCollection * pCol;
        const TCHAR            * pProrName;
        BSTR                     bstrName;
        
        hr = THR(pTable->GetNameFromAtom (dispid - DISPID_COLLECTION_MIN, &pProrName));
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(pProrName, &bstrName));
        if(hr)
            goto Cleanup;
        hr = THR(cells(bstrName, &pCol));
        FormsFreeString(bstrName);
        if(hr)
            goto Cleanup;
        V_VT(pvarResult) = VT_DISPATCH;
        V_DISPATCH(pvarResult) = pCol;
    }
    else
    {          
        hr = THR_NOTRACE(super::ContextInvokeEx (dispid, lcid, wFlags, pdispparams, pvarResult,
                       pexcepinfo, pSrvProvider, pUnkContext ? pUnkContext : (IUnknown*)this));
    }
        
Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableSection::insertRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::insertRow(long iRow, IDispatch** ppRow)
{
    CElement      * pNewElement = NULL;
    CElement      * pAdjacentElement = NULL;
    HRESULT         hr;
    Where           where;
    BOOL            fIncrementalUpdatePossible;
    CTable        * pTable;
    CTableLayout  * pTableLayout;

    if (ppRow)
        *ppRow = NULL;

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow < -1 || iRow > _cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( Doc()->CreateElement( ETAG_TR, & pNewElement ) );
    
    if (hr)
        goto Cleanup;

    Assert (pNewElement);

    // OM: iRow == -1                    means add the row at the end of the rows collection
    // OM: iRow == sizeof the collection means the same as iRow == -1
    // OM: iRow == good                  means insert as a row (iRow)

    where = BeforeBegin;                // insert the row before the "iRow"
    if (iRow == -1 || iRow == _cRows)
    {
        if (_cRows)
        {
            where = AfterEnd;           // insert after the last row
            iRow = _cRows - 1;
        }
        else
        {
            where = AfterBegin;         // insert After <TBODY> tag
            iRow = 0;
            pAdjacentElement = this;
        }
    }

    if (!pAdjacentElement)
    {
        Assert (iRow >= 0 && iRow < _cRows);
        pAdjacentElement = pTableLayout->_aryRows[_iRow + iRow];
        Assert (pAdjacentElement);
    }
    
    fIncrementalUpdatePossible = !_cRows                             ||     // in case of empty section, OR
                                  (where == AfterBegin && iRow == 0) ||     // in case of inserting first row to the section, OR
                                                                            // in case next row doesn't cross rowspans
                                  !pTableLayout->_aryRows[_iRow + iRow]->_fCrossingRowSpan;

    if (fIncrementalUpdatePossible)
        pTableLayout->_iInsertRowAt = _iRow + iRow + (where == AfterEnd? 1 : 0);
    hr = pTableLayout->insertElement(pAdjacentElement, pNewElement, where, fIncrementalUpdatePossible);
    pTableLayout->_iInsertRowAt = -1;
    if (hr)
        goto Cleanup;

    Assert(pNewElement->Tag() == ETAG_TR);
    DYNCAST(CTableRow, pNewElement)->_fCompleted = TRUE;

    if (ppRow)
    {
        hr = pNewElement->QueryInterface(IID_IHTMLTableRow, (void **)ppRow);
    }

Cleanup:
    CElement::ReleasePtr(pNewElement);

    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableSection::deleteRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::deleteRow(long iRow)
{
    CTableRow     * pRowDelete;
    CTableLayout  * pTableLayout;
    CTable        * pTable;
    HRESULT         hr;
    BOOL            fIncrementalUpdatePossible;

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow == -1)
    {
        iRow = _cRows - 1;
    }

    if (iRow < 0 || iRow >= _cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pRowDelete = pTableLayout->_aryRows[iRow + _iRow];
    Assert (pRowDelete);

    fIncrementalUpdatePossible = !pRowDelete->_fCrossingRowSpan       && 
                                  pTableLayout->_fAllRowsSameShape    && 
                                  pTableLayout->_aryRows.Size() != 1  &&
                                 !pRowDelete->_fParentOfTC;

    hr = pTableLayout->deleteElement(pRowDelete, fIncrementalUpdatePossible);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableSection2::moveRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::moveRow(long iRow, long iRowTarget, IDispatch **ppRow)
{
    CTable * pTable = Table();
    HRESULT  hr;

    if (!pTable)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    if (   iRow < -1 || iRow >= _cRows
        || iRowTarget < -1 || iRow >= _cRows )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    if (iRow == -1)
        iRow = _cRows-1;
    if (iRowTarget == -1)
        iRowTarget = _cRows-1;

    hr = THR(pTable->moveRowHelper(iRow + _iRow, iRowTarget + _iRow, ppRow, FALSE));

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableRow::get_rowIndex
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::get_rowIndex(long *plIndex)
{
    CTableLayout    * pTableLayout;
    CTable          * pTable;
    CTableRowLayout * pRowLayout;
    long              cRowsHead;
    long              cRowsFoot;
    HRESULT           hr;

    if (!plIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pTable = Table();
    if (!pTable)
    {
        *plIndex = -1;
        hr = S_OK;
        goto Cleanup;
    }

    *plIndex = 0;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    pRowLayout = RowLayoutCache();

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRowsHead = (pTableLayout->_pHead ? pTableLayout->_pHead->_cRows : 0);
    cRowsFoot = (pTableLayout->_pFoot ? pTableLayout->_pFoot->_cRows : 0);

    //
    // THEAD rows are first in the table
    //

    if (pRowLayout->RowPosition() < cRowsHead)
    {
        *plIndex = pRowLayout->RowPosition();
    }

    //
    // TBODY rows are after the THEAD, but before the TFOOT
    //

    else if (pRowLayout->RowPosition() >= (cRowsHead + cRowsFoot))
    {
        *plIndex = pRowLayout->RowPosition() - cRowsFoot;
    }

    //
    // TFOOT rows are after the THEAD and TBODY
    //

    else
    {
        Assert(pRowLayout->RowPosition() >= cRowsHead && pRowLayout->RowPosition() < (cRowsHead + cRowsFoot));
        *plIndex = pTableLayout->GetRows() - cRowsFoot + pRowLayout->RowPosition() - cRowsHead;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableRow::get_sectionRowIndex
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::get_sectionRowIndex(long *plIndex)
{
    HRESULT hr = S_OK;
    CTableSection *pSection;
    CTable        *pTable;
    CTableLayout  *pTableLayout;

    if (!plIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTable = Table();
    if (!pTable)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pSection = Section();
    if (pSection)
    {
        *plIndex = _iRow - pSection->_iRow;
    }
    else
    {
        *plIndex = -1;
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableRow::get_cells
//
//  Synopsis:   Table OM method implementation. Return the cells collection
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::get_cells(IHTMLElementCollection ** ppCells)
{
    HRESULT hr;

    if (!ppCells)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCells = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // do the work to get the Cells Collection
    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache(CELLS_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(CELLS_COLLECTION, (IDispatch**)ppCells));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableRow::insertCell
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::insertCell(long iCell, IDispatch** ppCell)
{
    CElement    *pNewElement = NULL;
    CTableCell  *pCell = NULL;
    CElement    *pAdjacentElement = NULL;
    HRESULT      hr;
    Where        where;
    int          i, iRealCell  = 0;
    int          cAryCellsSize = 0;
    int          cCells        = 0;;
    CTable      *pTable;
    CTableLayout *pTableLayout;
    BOOL        fIncrementalUpdatePossible, fLastCell = FALSE;
    CTableRowLayout *pRowLayout = RowLayoutCache();
    
    Assert (pRowLayout);

    if (ppCell)
    {
        *ppCell = NULL;
    }

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    pTableLayout = pTable->TableLayoutCache();

    ///////////////////////////////////////////////////////////////////////////////////
    // winse 24231 a-naande 5-28-2002
    // if we are adding a cell to the end it isn't necessary to rebuild the table from
    // scratch, when building large tables with script recreating the table with every
    // insertCell causes a huge performance loss
    BOOL fAddCell = iCell == -1 || iCell == pRowLayout->_cRealCells;
    if(fAddCell)
    {
        pTableLayout->MarkTableLayoutCacheCurrent();
    }
    else
    {
        pTableLayout->MarkTableLayoutCacheDirty();
    }

    // do the work to get the Cells Collection
    // Create a collection cache if we don't already have one.
    // this needs to be done since our collection may not be uptodate    
    hr = THR(EnsureCollectionCache(CELLS_COLLECTION));
        
    
    if (hr)
        goto Cleanup;

    // OM: iCell == -1                    means add the cell at the end of the cells collection
    // OM: iCell == sizeof the collection means the same as iCell == -1
    // OM: iCell == good                  means insert as a cell (iCell)

    cAryCellsSize = pRowLayout->_aryCells.Size();
    cCells        = pRowLayout->_cRealCells;
    
    if (iCell < -1 || iCell > cCells)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    hr = Doc()->CreateElement(ETAG_TD, &pNewElement);
    if (hr)
        goto Cleanup;

    Assert (pNewElement);

    where = BeforeBegin;                // insert the row before the "iCell"
    if (iCell == -1 || iCell == cCells)
    {
        if (cCells)
        {
            where = AfterEnd;           // insert after the last cell
            iCell = cCells - 1;
        }
        else
        {
            where = AfterBegin;         // insert After <TR> tag
            pAdjacentElement = this;
        }
        fLastCell = TRUE;
    }

    if (!pAdjacentElement)
    {
        Assert (iCell >= 0 && iCell < cCells);
        for (i = 0; i < cAryCellsSize; i++)
        {
            pCell = pRowLayout->_aryCells[i];
            if (IsReal(pCell) && iCell == iRealCell)
            {
                fLastCell = FALSE;
                break;
            }
            if (IsReal(pCell))
            {
                iRealCell++;
                Assert (iRealCell < cCells);
            }
        }

        //  (bug # 111131) It valid for IsReal(pCell) to retun false here
        //  when the cell is empty due to display:none. But Cell() should 
        //  always be used in subsequent checks and assignings.

        // Assert (IsReal(pCell));

        pAdjacentElement = Cell(pCell);
        if (!Cell(pCell))
        {
            // insert the cell before the </TR> tag
            pAdjacentElement = this;
            where = BeforeEnd;
            fLastCell = FALSE;
        }
    }
    
    fIncrementalUpdatePossible =  !_fCrossingRowSpan && fLastCell && (fAddCell || cCells + 1 <= cAryCellsSize || pTableLayout->_aryRows.Size() == 1);
    hr = pTableLayout->insertElement(pAdjacentElement, pNewElement, where, fIncrementalUpdatePossible);
    
    ///////////////////////////////////////////////////////////////////////////////////
    // winse 24231 a-naande 5-17-2002
    // add the cell if necessary, the first cell in the row will be added by insertElement
    if(fAddCell && pRowLayout->_aryCells.Size() > 0 && pRowLayout->_aryCells[0] != pNewElement)pRowLayout->AddCell((CTableCell*)pNewElement);
    if (hr)
    {
        goto Cleanup;
    }

    if (pTableLayout)
        pTableLayout->MarkTableLayoutCacheDirty();

    if (ppCell)
    {
        hr = pNewElement->QueryInterface(IID_IHTMLTableCell, (void **)ppCell);
    }

Cleanup:
    CElement::ReleasePtr(pNewElement);

    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableRow::deleteCell
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::deleteCell(long iCell)
{
    HRESULT         hr = S_OK;
    CTableCell **   ppCell;
    CTableCell *    pCellDelete;
    long            cCells, iReal;
    CTableRowLayout * pRowLayout;
    CTable          * pTable;
    CTableLayout    * pTableLayout;

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pRowLayout = RowLayoutCache();
    if (iCell < -1 || iCell >= pRowLayout->_aryCells.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    iReal       = -1;
    pCellDelete = NULL;
    for (ppCell = pRowLayout->_aryCells, cCells = pRowLayout->_aryCells.Size();
        cCells > 0;
        ppCell++, cCells--)
    {
        if (IsReal(*ppCell))
        {
            iReal++;
            pCellDelete = *ppCell;

            if (iReal == iCell)
                break;
        }
    }

    if (    iReal < 0
        ||  (   iCell >= 0
            &&  iCell != iReal))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    Assert(pCellDelete);
    Assert(IsReal(pCellDelete));

    hr = pTable->TableLayoutCache()->deleteElement(pCellDelete);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableCell::get_index
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableCell::get_cellIndex(long *plIndex)
{
    HRESULT     hr = S_OK;
    CTableRow * pRow;
    CTableRowLayout *pRowLayout;
    int         i;
    int         iRealCell = 0;
    CTableCell *pCell;
    CTable       * pTable;
    CTableLayout * pTableLayout;

    if (!plIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pRow = Row();
    if (!pRow)
    {
        iRealCell = -1;
        hr = S_OK;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTable = Table();
    if (pTable)
    {
        pTableLayout = pTable->TableLayoutCache();
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
    }

    pRowLayout = pRow->RowLayoutCache();
    for (i = 0; i < pRowLayout->_aryCells.Size(); i++)
    {
        pCell = pRowLayout->_aryCells[i];
        if (Cell(pCell) == this)
        {
            break;
        }
        if (IsReal(pCell))
        {
            iRealCell++;
        }
    }

    Assert (iRealCell < pRowLayout->_cRealCells);
  

Cleanup:
    if (plIndex)
        *plIndex = iRealCell;

    RRETURN(SetErrorInfo( hr ));
}


//+------------------------------------------------------------------------
//
//  Member:     put_colSpan, IHTMLTable
//
//  Synopsis:   change the colSpan
//
//  Arguments:  cColSpan       new col span
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::put_colSpan(long cColSpan)
{
    CTable * pTable = Table();
    HRESULT hr = S_OK;
    long    cOldColSpan = ColSpan();

    if (cColSpan < 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pTable && pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (cColSpan > MAX_COL_SPAN && cOldColSpan == MAX_COL_SPAN)
    {
        goto Cleanup;   // nothing to do
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;


    {   // Just do it, and be ready do undo it...
        CParentUndo pu(Doc());
        
        if( IsEditable(/*fCheckContainerOnly*/FALSE) )
            pu.Start( IDS_UNDOPROPCHANGE );

        // this is a fancy way of calling the base implementation
        hr = s_propdescCTableCellcolSpan.b.SetNumberProperty(cColSpan, this, CVOID_CAST(GetAttrArray()));
        if (!hr && pTable)
        {
            pTable->TableLayoutCache()->Fixup(FALSE);
        }

        pu.Finish( hr );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+------------------------------------------------------------------------
//
//  Member:     get_colSpan, IHTMLTable
//
//  Synopsis:   return the colSpan
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::get_colSpan(long * p)
{
    if (p)
    {
        *p = ColSpan();
    }
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     put_rowSpan, IHTMLTable
//
//  Synopsis:   change the rowSpan
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::put_rowSpan(long cRowSpan)
{
    CTable * pTable = Table();
    HRESULT hr;

   if (cRowSpan < 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    if (pTable && pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    {   // Just do it, and be ready do undo it...
        CParentUndo pu(Doc());
        
        if( IsEditable(/*fCheckContainerOnly*/FALSE) )
            pu.Start( IDS_UNDOPROPCHANGE );

        // this is a fancy way of calling the base implementation
        hr = s_propdescCTableCellrowSpan.b.SetNumberProperty(cRowSpan, this, CVOID_CAST(GetAttrArray()));
        if (!hr && pTable)
        {
            pTable->TableLayoutCache()->Fixup(FALSE);
        }

        pu.Finish( hr );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+------------------------------------------------------------------------
//
//  Member:     get_rowSpan, IHTMLTable
//
//  Synopsis:   return the rowSpan
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::get_rowSpan(long * p)
{
    HRESULT        hr = S_OK;
    int            iRowSpan = 1;
    CTable       * pTable;
    CTableLayout * pTableLayout;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTable = Table();
    if (pTable)
    {
        pTableLayout = pTable->TableLayoutCache();
        hr = pTableLayout->EnsureTableLayoutCache();
        if (!hr)
            iRowSpan = RowSpan();
    }
    
    if (p)
    {
        *p = iRowSpan;
    }

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\table.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       table.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include <othrguid.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include <detail.hxx>
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include <ltable.hxx>
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include <ltrow.hxx>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "table.hdl"

MtDefine(CTable, Elements, "CTable")
MtDefine(BldRowsCol, PerfPigs, "Build CTable::TABLE_ROWS_COLLECTION")
MtDefine(BldBodysCol, PerfPigs, "Build CTable::TABLE_BODYS_COLLECTION")
MtDefine(BldCellsCol, PerfPigs, "Build CTable::TABLE_CELLS_COLLECTOIN")

ExternTag(tagTableRecalc);
extern void __cdecl WriteHelp(HANDLE hFile, TCHAR *format, ...);
extern void WriteString(HANDLE hFile, TCHAR *pszStr);


const ELEMENT_TAG s_atagTSection[] = {ETAG_TBODY, ETAG_THEAD, ETAG_TFOOT, ETAG_NULL};

#ifndef NO_PROPERTY_PAGE
const CLSID * const CTable::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CTable::s_classdesc =
{
    {
        &CLSID_HTMLTable,               // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOPCTRESIZE,        // _dwFlags
        &IID_IHTMLTable,                // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTable,         // _pfnTearOff
    NULL                                // _pAccelsRun
};


HRESULT
CTable::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_TABLE));
    Assert(ppElement);

    *ppElement = new CTable(pDoc);
    RRETURN( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


CTable::CTable(CDoc *pDoc)
    : super(ETAG_TABLE, pDoc)
{
    _fOwnsRuns    = TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     CTable::destructor, CBase
//
//  Note:       The collection cache must be deleted in the destructor, and
//              not in Passivate, because collection objects we've handed out
//              (via get_rows) merely SubAddRef the table.
//-------------------------------------------------------------------------

CTable::~CTable()
{
    delete _pCollectionCache;

}


//+------------------------------------------------------------------------
//
//  Member:     CTable::Notify
//
//  Synopsis:   Catch the leave-tree notification
//
//-------------------------------------------------------------------------

void
CTable::Notify(CNotification *pNF)
{
    CTableLayout *  pTableLayout;
    HRESULT         hr;
    DWORD           dw;

    pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pNF->IsType(NTYPE_ELEMENT_EXITTREE_1))
    {
        _fEnableDatabinding = FALSE;
    }

    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        dw = pNF->DataAsDWORD();
        if (!(dw & ENTERTREE_PARSE))
        {
            pTableLayout->_fDontSaveHistory = TRUE;
        }
        if (!(dw & ENTERTREE_PARSE) && !(dw & ENTERTREE_MOVE))  // if the element cretead NOT via PARSing nor MOVing HTML
        {
            pTableLayout->_fCompleted = TRUE; // we are not going to have NTYPE_END_PARSE notification to set the _fCompleted bit
        }
        _fEnableDatabinding = TRUE;

        // Load the history stream
        // TODO (jbeda) this should probably happen during NTYPE_DELAY_LOAD_HISTORY
        IGNORE_HR(GetMarkup()->GetLoadHistoryStream(GetSourceIndex(), 
                                                    HistoryCode(), 
                                                    &_pStreamHistory));

        _iDocDotWriteVersionEnterTree = Doc()->_iDocDotWriteVersion;
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        pTableLayout->ClearTopTableLayoutCache(); // Don't hold refs to the tree after our element leaves it

        // Whenever we clear the TLC, we have to mark it dirty in case the element
        // reenters the tree at some point.
        pTableLayout->MarkTableLayoutCacheDirty();

        // 47172: Make sure we don't think we're hanging on to the caption dispnode.
        pTableLayout->_fHasCaptionDispNode = FALSE;
        if (pTableLayout->GetTableBorderRenderer())
            pTableLayout->GetTableBorderRenderer()->_pDispNode = NULL;

        ClearInterface(&_pStreamHistory);
        break;

        break;

    case NTYPE_END_PARSE:
        Assert (!pTableLayout->_fCompleted && "NTYPE_END_PARSE notification happened more then once");

        if (_iDocDotWriteVersionEnterTree != Doc()->_iDocDotWriteVersion)
        {
            // there were document.write in between <TABLE> and </TABLE> parsing
            pTableLayout->_fDontSaveHistory = TRUE;
            ClearInterface(&_pStreamHistory);     // don't use history
            if (pTableLayout->_fUsingHistory)     // if we are already using History
            {
                if(pTableLayout->_fCompleted)
                    pTableLayout->Resize();       // then, ensure full resize.
            }
        }
        if (!pTableLayout->_fCompleted)           // (even with the above Assert), make sure we don't do this more then ONCE
        {
            hr = pTableLayout->EnsureCells();
            if (hr)
                return;

            hr = pTableLayout->ensureTBody();
            if (hr)
                return;

            pTableLayout->_fCompleted = TRUE;     // loading/parsing of the table is complete.

    #ifndef NO_DATABINDING
            DBMEMBERS * pdbm = GetDBMembers();
            if (pdbm)
            {
                pdbm->MarkReadyToBind();
            }
    #endif // ndef NO_DATABINDING

            ResizeElement();
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        if (   !pTableLayout->_fDontSaveHistory  
            && pTableLayout->_fCompleted
            && pTableLayout->_fCalcedOnce
            && !pTableLayout->_fTLCDirty
            && pTableLayout->_aryRows.Size() >= 1
            && pTableLayout->GetCols() >= 1
            && !pTableLayout->IsFixed() 
            && !IsDatabound())
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_SAVE_HISTORY_2:
        // Do not save history for small tables or for tables that are already using "fixed" style
        //  or for tables that haven't been finished being parsed (bug 57537)
        if (   !pTableLayout->_fDontSaveHistory  
            && pTableLayout->_fCompleted
            && pTableLayout->_fCalcedOnce
            && !pTableLayout->_fTLCDirty
            && pTableLayout->_aryRows.Size() >= 1
            && pTableLayout->GetCols() >= 1
            && !pTableLayout->IsFixed() 
            && !IsDatabound())
        {
            CHistorySaveCtx *   phsc;

            pNF->Data((void **)&phsc);
            hr = pTableLayout->SaveHistoryValue(phsc);
        }

        break;
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     CTable::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CTable::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLTable)
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTable, NULL)
        QI_TEAROFF(this, IHTMLTable2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTable3, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CTable::Init2(), CElement
//
//  Synopsis:   called after calls to: Init(), InitAttrBag()
//
//-------------------------------------------------------------------------

HRESULT
CTable::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (!OK(hr))
        goto Cleanup;

    _readyStateTable = FormsIsEmptyString(GetAAdataSrc()) ? READYSTATE_COMPLETE : READYSTATE_LOADING;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTable::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    const CCharFormat * pCF;
    CColorValue ccvBorderColor;
    CTreeNode * pNodeBody;
    BOOL        fVisibilityHidden;
    BOOL        fDisplayNone;
    BOOL        fHasBgImage;
    BOOL        fHasBgColor;
    BOOL        fDisabled;
    BOOL        fEditable;
    BOOL        fRelative;
    BOOL        fNoBreak;
    BOOL        fHaveBorderColor = FALSE;
    LONG        fRTL;
    LONG        lCursorIndex;
    COLORREF    cr;
    BYTE        i;
    HRESULT     hr = S_OK;
    CTableLayout *pTableLayout = TableLayoutCache();
    CMarkup *   pMarkup;
    CDoc *      pDoc = Doc();
    BYTE        uLayoutGridModeInner;
    BYTE        uLayoutGridMode;
    BYTE        wLayoutFlow;
    BOOL        fHasInlineBg;
    BOOL        fWritingModeUsed;


    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    // cache the values before init default
    fVisibilityHidden = pCFI->_cf()._fVisibilityHidden;
    fDisplayNone      = pCFI->_cf()._fDisplayNone;
    fRTL              = pCFI->_cf()._fRTL;
    fHasBgColor       = pCFI->_cf()._fHasBgColor;
    fHasBgImage       = pCFI->_cf()._fHasBgImage;
    fDisabled         = pCFI->_cf()._fDisabled;
    fEditable         = pCFI->_cf()._fEditable;
    fRelative         = pCFI->_cf()._fRelative;
    lCursorIndex      = pCFI->_cf()._bCursorIdx;
    fNoBreak          = pCFI->_cf()._fNoBreak;
  
    uLayoutGridModeInner    = pCFI->_cf()._uLayoutGridModeInner;
    uLayoutGridMode         = pCFI->_cf()._uLayoutGridMode;
    wLayoutFlow             = pCFI->_cf()._wLayoutFlow;
    fHasInlineBg            = pCFI->_cf()._fHasInlineBg;
    fWritingModeUsed        = pCFI->_cf()._fWritingModeUsed;

    pMarkup = GetMarkupPtr();
    
    if (    !pMarkup
        ||  !pMarkup->PaintBackground() )
    {
        cr = 0;
        ccvBorderColor.SetValue(cr, FALSE);
    }
    else
    {
        ccvBorderColor = GetAAborderColor();
        if (ccvBorderColor.IsDefined())
        {
            fHaveBorderColor = TRUE;

            cr = ccvBorderColor.GetColorRef();
        }
        else
        {
            CLayout * pParentLayout = GetUpdatedParentLayout(GUL_USEFIRSTLAYOUT);
            cr = GetSysColorQuick(COLOR_BTNHIGHLIGHT);
            if (pParentLayout && (0x00FFFFFF & pParentLayout->ElementOwner()->GetInheritedBackgroundColor()) == (0x00FFFFFF & cr))
            {
                cr = GetSysColorQuick(COLOR_BTNFACE);
            }

            ccvBorderColor.SetValue(cr, FALSE);
        }

        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight = GetAAborderColorLight();
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = GetAAborderColorDark();
    }

    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderColor(i, ccvBorderColor);
    }

    if (!pCFI->_ff()._bd._ccvBorderColorLight.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorLight.SetValue(cr, FALSE);
    if (!pCFI->_ff()._bd._ccvBorderColorHilight.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorHilight.SetValue(cr, FALSE);

    if (    pMarkup
        &&  pMarkup->PaintBackground()
        &&  !fHaveBorderColor )
    {
        cr = GetSysColorQuick(COLOR_BTNSHADOW);
    }

    if (!pCFI->_ff()._bd._ccvBorderColorDark.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorDark.SetValue(cr, FALSE);
    if (!pCFI->_ff()._bd._ccvBorderColorShadow.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorShadow.SetValue(cr, FALSE);

    // Tables don't allow any character formatting information to leak through
    // except for font names & inline style display, and layout grid
    // However this does not apply for Strict CSS1 Document

    // the logic: 
    // if no markup available - behave like in non CSS1 compat mode;
    // if there is a markup - check it for CSS1 flag;
    
    if (    !pMarkup // (olego 02/15/02) fix for Windows Bug # 542527
        ||  !pMarkup->IsStrictCSS1Document()) 
    {
        pCFI->_cf().InitDefault(
            pDoc->_pOptionSettings,
            pMarkup ? pMarkup->GetCodepageSettings() : NULL,
            pCFI->_cf()._fExplicitFace);


        // restore of init default
        pCFI->_cf()._fVisibilityHidden = fVisibilityHidden;
        pCFI->_cf()._fDisplayNone      = fDisplayNone;
        pCFI->_cf()._fRTL              = fRTL;
        pCFI->_cf()._fHasBgColor       = fHasBgColor;
        pCFI->_cf()._fHasBgImage       = fHasBgImage;
        pCFI->_cf()._fDisabled         = fDisabled;
        pCFI->_cf()._fEditable         = fEditable;
        pCFI->_cf()._fRelative         = fRelative;
        pCFI->_cf()._bCursorIdx        = lCursorIndex;
        pCFI->_cf()._fNoBreak          = fNoBreak;
        pCFI->_cf()._uLayoutGridModeInner   = uLayoutGridModeInner;
        pCFI->_cf()._uLayoutGridMode        = uLayoutGridMode;
        pCFI->_cf()._wLayoutFlow       = wLayoutFlow;
        pCFI->_cf()._fHasInlineBg      = fHasInlineBg;
        pCFI->_cf()._fWritingModeUsed  = fWritingModeUsed;

        // if we do not want text alignment to be inheritted by the table
        // from its parent
        pCFI->_bCtrlBlockAlign  = pCFI->_bBlockAlign;
        pCFI->_bBlockAlign      = htmlBlockAlignNotSet;

        // Now get the text color default value from the body tag.
        // We do it this way because color attribute values don't leak into
        // tables.
        pNodeBody = GetFirstBranch()->SearchBranchToRootForTag( ETAG_BODY );
        if (pNodeBody)
        {
            pCF = pNodeBody->GetCharFormat();
            pCFI->_cf()._ccvTextColor = pCF->_ccvTextColor;
        }
    }

    // This is where to put the code to inherit character attributes created by
    // styles.
    /* */

    pCFI->PrepareParaFormat();

    // set up for potential EMs, ENs, and ES Conversions
    pCFI->_pf()._lFontHeightTwips = pCFI->_cf().GetHeightInTwips( pDoc );
    if (pCFI->_pf()._lFontHeightTwips <=0)
        pCFI->_pf()._lFontHeightTwips = 1;

    // Tables don't inherit vertical alignment from containing tables.
    pCFI->_pf()._bTableVAlignment = htmlCellVAlignNotSet;

    // iniitalize the default paragraph property for PRE, if we are inside PRE it shouldn't effect the cells
    pCFI->_pf()._fPre      = FALSE;
    pCFI->_pf()._fPreInner = FALSE;
    pCFI->_pf()._cuvTextIndent = 0;

    pCFI->UnprepareForDebug();

    hr = super::ApplyDefaultFormat( pCFI );

    pCFI->PrepareFancyFormat();

    // TODO (olego IE6 20201) cleanup initialization of table related layouts' data at the 
    // time other when calculating layout (like these below). This 1) forces table / table 
    // row layout to have the same lifetime as corresponding elements; 2) is buggy because 
    // it does not check for different compute formats modes and sometime picks up bits 
    // from uninitialized fields of formats. 3) Etc... 

    if (!(pCFI->_eExtraValues & ComputeFormatsType_GetValue))   // IE6 15607
    {
        // This initialization should be done at compute format time 
        // because it is used as early as at table construction (AddRow, AddCell, etc). 
        pTableLayout->_fFixed = pCFI->_ff()._bTableLayout;
        pTableLayout->_fCollapse = pCFI->_ff()._bd._bBorderCollapse;
    }

    // Clear the border default and the cache on table.
    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = FALSE;
    pTableLayout->_fBorderInfoCellDefaultCached = FALSE;

    pCFI->UnprepareForDebug();

    RRETURN( hr );
}



//+------------------------------------------------------------------------
//
//  Collection cache items implementation for TABLE collection
//
//-------------------------------------------------------------------------

class CTableRowsCollectionCacheItem : public CTableCollectionCacheItem
{
    typedef CTableCollectionCacheItem super;

protected:
#if NEED_A_SOURCE_ORDER_ITERATOR
    unsigned    _fAryRowsInSourceOrder: 1;
#else
    int         _iRow;  // index to _aryRows array for _lCurrentIndex
#endif

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldRowsCol))
    CTableRowsCollectionCacheItem(CTable *pTable) {_pTableLayout = pTable->TableLayoutCache(); }
    CElement *GetNext (void);
    CElement *GetAt ( long lIndex );
    long Length ( void );
};

class CTableBodysCollectionCacheItem : public CTableCollectionCacheItem
{
    typedef CTableCollectionCacheItem super;

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldBodysCol))
    CTableBodysCollectionCacheItem(CTable *pTable) {_pTableLayout = pTable->TableLayoutCache(); }
    CElement *GetAt ( long lIndex );
    long Length ( void );
};

//+------------------------------------------------------------------------
//
//  Generic TABLE collection (abstract class)
//
//-------------------------------------------------------------------------
CElement *
CTableCollectionCacheItem::GetNext ( void )
{
    return GetAt ( _lCurrentIndex++ );
}

CElement *
CTableCollectionCacheItem::MoveTo ( long lIndex )
{
    _lCurrentIndex = lIndex;
    return GetAt(lIndex);
}

//+------------------------------------------------------------------------
//
//  TABLE ROWS collection
//
//-------------------------------------------------------------------------

CElement *
CTableRowsCollectionCacheItem::GetNext ( void )
{
    if (_lCurrentIndex++ < _pTableLayout->_aryRows.Size())
    {
        CTableRow * pRow = _pTableLayout->_aryRows[_iRow];
        _iRow = _pTableLayout->GetNextRow(_iRow);
        return pRow;
    }
    return NULL;
}

CElement *
CTableRowsCollectionCacheItem::GetAt ( long lIndex )
{
    Assert ( lIndex >= 0 );
    if (lIndex < _pTableLayout->_aryRows.Size())
    {
#if NEED_A_SOURCE_ORDER_ITERATOR
        return _fAryRowsInSourceOrder
            ? _pTableLayout->_aryRows[lIndex] 
            : _pTableLayout->GetRowInSourceOrder(lIndex)
#else
        _iRow = _pTableLayout->VisualRow2Index(lIndex);
        _lCurrentIndex = lIndex;
        return _pTableLayout->_aryRows[_iRow];
#endif
    }
    return NULL;
}

long 
CTableRowsCollectionCacheItem::Length ( void )
{
#if NEED_A_SOURCE_ORDER_ITERATOR
    _fAryRowsInSourceOrder = _pTableLayout->IsAryRowsInSourceOrder();
#endif
    return _pTableLayout->_aryRows.Size();
}

//+------------------------------------------------------------------------
//
//  TABLE BODYS collection
//
//-------------------------------------------------------------------------

CElement *
CTableBodysCollectionCacheItem::GetAt ( long lIndex )
{
    Assert ( lIndex >= 0 );
    return (lIndex < _pTableLayout->_aryBodys.Size())?_pTableLayout->_aryBodys[lIndex] : NULL;
}

long 
CTableBodysCollectionCacheItem::Length ( void )
{
    return _pTableLayout->_aryBodys.Size();
}


//+------------------------------------------------------------------------
//
//  TABLE CELLS collection
//
//-------------------------------------------------------------------------

CElement *
CTableCellsCollectionCacheItem::MoveTo ( long lIndex )
{
    int iRowIndex;

    _lCurrentCellIndex = lIndex;
    iRowIndex = SetCurrentRowAndGetRowIndex(lIndex);
    if (iRowIndex >= 0)
    {
        return super::MoveTo(iRowIndex);
    }
    return NULL;
}

CElement *
CTableCellsCollectionCacheItem::GetNext ( void )
{
    _lCurrentCellIndex++;
    if (_pRowLayout && _lCurrentIndex < _pRowLayout->_cRealCells)
    {
        return super::GetNext();
    }
    else
    {
        int iRow = _pRowLayout? _pTableLayout->GetNextRowSafe(_pRowLayout->RowPosition()) : _pTableLayout->GetFirstRow();  // get next row in visual order
        while (iRow < _pTableLayout->_aryRows.Size())
        {
            CTableRowLayout *pRowLayout = _pTableLayout->_aryRows[iRow]->RowLayoutCache();
            if (pRowLayout)
            {
                _pRowLayout = pRowLayout;
                if (CTableRowCellsCollectionCacheItem::MoveTo(0))   // if there are cells in this row 
                    return CTableRowCellsCollectionCacheItem::GetNext();    //then return the 0 and prepare for the next
                else
                    iRow = _pTableLayout->GetNextRowSafe(_pRowLayout->RowPosition());
            }
        }
    }
    return NULL;
}


CElement *
CTableCellsCollectionCacheItem::GetAt ( long lIndex )
{
    int iRowIndex = SetCurrentRowAndGetRowIndex(lIndex);
    if (iRowIndex >= 0)
    {
        return super::GetAt(iRowIndex);
    }
    return NULL;
}

int  
CTableCellsCollectionCacheItem::SetCurrentRowAndGetRowIndex(int lIndex)
{
    int cRows = _pTableLayout->_aryRows.Size();
    if (cRows)
    {
        int cR, iRow;
        int cRealCells = 0;
        for (cR = cRows, iRow = _pTableLayout->GetFirstRow();
            cR > 0;
            cR--, iRow = _pTableLayout->GetNextRow(iRow))   // get next row in visual order
        {
            _pRowLayout = _pTableLayout->_aryRows[iRow]->RowLayoutCache();
            if (lIndex < cRealCells + _pRowLayout->_cRealCells)
            {
                break;
            }
            cRealCells += _pRowLayout->_cRealCells;
        }

        return lIndex - cRealCells;   // relative to the row index
    }
    return -1;
}

long 
CTableCellsCollectionCacheItem::Length ( void )
{
    int i, cRows;
    int cRealCells = 0;
    cRows = _pTableLayout->_aryRows.Size();
    for (i = 0; i < cRows; i++)
    {
        cRealCells += _pTableLayout->_aryRows[i]->RowLayoutCache()->_cRealCells;
    }
    return cRealCells;
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the table's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTable::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    hr = TableLayoutCache()->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,          // double cast needed for Win16.
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CTable, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(NUMBER_OF_TABLE_COLLECTION, NUMBER_OF_TABLE_COLLECTION));
        if (hr)
            goto Error;

        CTableRowsCollectionCacheItem *pRowsCollection = new CTableRowsCollectionCacheItem(this);
        if ( !pRowsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( TABLE_ROWS_COLLECTION, pRowsCollection ));
        if (hr)
            goto Cleanup;

        CTableBodysCollectionCacheItem *pBodysCollection = new CTableBodysCollectionCacheItem(this);
        if ( !pBodysCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( TABLE_BODYS_COLLECTION, pBodysCollection ));
        if (hr)
            goto Cleanup;

        CTableCellsCollectionCacheItem *pCellsCollection = new CTableCellsCollectionCacheItem(this);
        if ( !pCellsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( TABLE_CELLS_COLLECTION, pCellsCollection ));
        if (hr)
            goto Cleanup;
        
        //
        // Collection cache now owns this item & is responsible for freeing it
        //
    }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the table rows collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTable::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    Assert ( lIndex < NUMBER_OF_TABLE_COLLECTION  && plCollectionVersion); // parameter validation

    HRESULT hr = S_OK;

    CTableLayout *pTableLayout = TableLayoutCache();
    if ( pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        *plCollectionVersion = pTableLayout->_iCollectionVersion;   // to mark it done
    }

    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member: CTable::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CTable::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_ISCOMPLETED:
        return (TableLayoutCache()->_fCompleted ? TRUE : FALSE);
    }

    return super::GetInfo(gi);
}


#if DBG == 1
TCHAR g_achTabs[] = _T("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");
#define PRINTLN(f) WriteHelp(pF, _T("<0s>")_T(##f)_T("\n"), &g_achTabs[ARRAY_SIZE(g_achTabs) - iTabs]


void
CTableCol::Print(HANDLE pF, int iTabs)
{
    TCHAR           achBuf[30];
    const TCHAR *   psz;

    PRINTLN("\n*** COL ***\n") );
    psz = GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_iCol: <1d>"), _iCol);
    PRINTLN("_cCols: <1d>"), _cCols);
    PRINTLN("CELLS = <1s>"), achBuf);

    GetFirstBranch()->GetCascadedwidth().FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableColwidth.a);
    PRINTLN("WIDTH = <1s>"), achBuf);
}

void
CTableColCalc::Print(HANDLE pF, int iTabs)
{
    TCHAR achBuf[30];

    PRINTLN("\n*** COLCALC ***\n") );
    PRINTLN("_xMin: <1d>"), _xMin); // Moved to ColCalc
    PRINTLN("_xMax: <1d>"), _xMax);
    PRINTLN("_xWidth: <1d>"), _xWidth);
    _uvWidth.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableColwidth.a);
}


#endif // DBG == 1


//+------------------------------------------------------------------------
//
//  Member :    InvalidateCollections()
//
//  Synopsis :  invalidate the table's and documents collection caches
//
//-------------------------------------------------------------------------


void CTable::InvalidateCollections()
{
    CTableLayout * pTableLayout = TableLayoutCache();

    if (pTableLayout)
    {
        int i;

        pTableLayout->_iCollectionVersion++;  // this will tell the cache collection manager that our collection is updated

        if (_pCollectionCache)
            _pCollectionCache->Invalidate();  // this will reset collection version number

        for (i=0; i < pTableLayout->_aryBodys.Size(); i++)
        {
            pTableLayout->_aryBodys[i]->InvalidateCollections(this);
        }

        if (pTableLayout->_pHead)
        {
            pTableLayout->_pHead->InvalidateCollections(this);
        }
        if (pTableLayout->_pFoot)
        {
            pTableLayout->_pFoot->InvalidateCollections(this);
        }

        for (i=0; i<pTableLayout->_aryRows.Size(); i++)
        {
            pTableLayout->_aryRows[i]->InvalidateCollections();
        }
    }
}


HRESULT
CTable::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT        hr;
    CTableCaption *pCaption;
    CTableCaption **ppCaption;
    int            cC;
    CTableLayout  *pTableLayout = TableLayoutCache();

    switch(dispid)
    {
    case DISPID_CTable_cellSpacing: 
        // note, the cellSpacing is a part of the padding for the captions,
        // so we need make sure we remeasure them

        for (cC = pTableLayout->_aryCaptions.Size(), ppCaption = pTableLayout->_aryCaptions;
             cC > 0;
             cC--, ppCaption++)
        {

            pCaption = (*ppCaption);
            if (pCaption->Tag() == ETAG_CAPTION)
            {
                pCaption->RemeasureElement(0);
            }
        }
        pTableLayout->ResetMinMax();

        // Make sure super is asking for a layout.
        Assert(dwFlags | ELEMCHNG_SIZECHANGED);
        break;
         
    case DISPID_CTable_cellPadding: // "
        dwFlags |= ELEMCHNG_REMEASUREALLCONTENTS;

    case DISPID_A_BORDERWIDTH:      // CalculateBorderAndSpacing
    case DISPID_A_BORDERTOPWIDTH:   // "
    case DISPID_A_BORDERRIGHTWIDTH: // "
    case DISPID_A_BORDERBOTTOMWIDTH:// "
    case DISPID_A_BORDERLEFTWIDTH:  // "
    case DISPID_CTable_border:      // "

        // Whenever a table (border) property change has the ability
        // to toggle table cell borders on and off, we need to
        // remeasure all contents, so that the dispnodes can be updated.
        // If the table is collapsing borders and the borders on the
        // table are toggled on or off, this affects cell layouts
        // because their borders along the table edges be deactivated
        // or activated.  (45145, 50744)
        if (pTableLayout->CollapseBorders() || DISPID_CTable_border == dispid)
            dwFlags |= ELEMCHNG_REMEASUREALLCONTENTS;

        // fall through
    case DISPID_CTable_width:       // because Calc'MinMax sets MM to xWidth.
    case DISPID_A_BORDERCOLLAPSE:   // because every cell minmax will change

        pTableLayout->ResetMinMax();

        // Make sure super is asking for a layout.
        Assert(dwFlags | ELEMCHNG_SIZECHANGED);
        break;
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}

void CTableRow::DataTransferRequested() 
{ 
    Assert(Table());
    Assert(Table()->TableLayoutCache());

    // only allow a post dataTransferRequest if
    // 1. we are in a table
    // 2. we are not in the middle (bug 91460)
    if (   _iRow != -1         
        && _iRow+1 == Table()->TableLayoutCache()->GetRows())    
    {
        _fNeedDataTransfer = TRUE; 
    }
}

CTableRow *CTableCell::Row() const
{
    return DYNCAST(CTableRow, GetParentAncestorSafe(ETAG_TR));
}

CTableSection *CTableCell::Section() const
{
    return DYNCAST(CTableSection, GetParentAncestorSafe(s_atagTSection));
}

CTable *CTableCell::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTable *CTableRow::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTableSection *CTableRow::Section() const
{
    return DYNCAST(CTableSection, GetParentAncestorSafe(s_atagTSection));
}

CTable *CTableSection::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTable *CTableCol::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTableCalcInfo::CTableCalcInfo(CCalcInfo * pci, CTable *pTable, CTableLayout *pTableLayoutCache)
{
    Init(pci);
    _dwFlags            = 0;
    _pme                = NULL;
    _pTable             = pTable;
    _pTableLayoutCache  = pTableLayoutCache;
    _pTableLayout       = pci->GetLayoutContext() == NULL ? _pTableLayoutCache 
        : (CTableLayoutBlock *)_pTable->GetUpdatedLayout(pci->GetLayoutContext());
    Assert(_pTableLayout);
    _fTableCalcInfo     = TRUE;

    if (pci->_fTableCalcInfo)
    {
        _cNestedCalcs = ((CTableCalcInfo *)pci)->_cNestedCalcs + 1; 
        _cGlobalNestedCalcs = ((CTableCalcInfo *)pci)->_cGlobalNestedCalcs + 1; 
        _fGlobalNormalCalc = ((CTableCalcInfo *)pci)->_fGlobalNormalCalc; 
        _fGlobalSetCalc = ((CTableCalcInfo *)pci)->_fGlobalSetCalc; 
    }
    else
    {
        _cNestedCalcs = 0;
        _cGlobalNestedCalcs = 0;
    }

    //  table should start with clear _fIgnorePercentChild 
    _fIgnorePercentChild = FALSE;
}

CTableCalcInfo::CTableCalcInfo(CTable *pTable, CTableLayoutBlock *pTableLayoutBlock)
        :CCalcInfo (pTableLayoutBlock)
{
    Assert(GetLayoutContext() == pTableLayoutBlock->LayoutContext());
    _dwFlags            = 0;
    _pme                = NULL;
    _pTable             = pTable;
    _pTableLayoutCache  = pTable->TableLayoutCache();
    _pTableLayout       = pTableLayoutBlock;
    _fTableCalcInfo     = TRUE;
    Assert (_pTableLayoutCache && _pTableLayoutCache->_cNestedLevel != - 1);
    _cNestedCalcs       = _pTableLayoutCache->_cNestedLevel; 
    _cGlobalNestedCalcs = _pTableLayoutCache->_cNestedLevel; 

    //  table should start with clear _fIgnorePercentChild 
    _fIgnorePercentChild = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\tcell.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tcell.cxx
//
//  Contents:   CTableCell and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

MtDefine(CTableCell, Elements, "CTableCell")
MtDefine(CTableCaption, Elements, "CTableCaption")
MtExtern(CharFormatSteal)
MtExtern(ParaFormatSteal)
MtExtern(FancyFormatSteal)

ExternTag(tagTableRecalc);
ExternTag(tagTableCalc);
ExternTag(tagFormatCaches);

CElement::ACCELS CTableCell::s_AccelsTCellRun    = CElement::ACCELS (&CTxtSite::s_AccelsTxtSiteRun,    IDR_ACCELS_TCELL_RUN);

#ifndef NO_PROPERTY_PAGE
const CLSID * const CTableCell::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CTableCell::s_classdesc =
{
    {
        &CLSID_HTMLTableCell,           // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_TEXTSITE       |
        ELEMENTDESC_NOOFFSETCTX    |
        ELEMENTDESC_NOBKGRDRECALC  |
        ELEMENTDESC_TABLECELL,          // _dwFlags
        &IID_IHTMLTableCell,            // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableCell,     // _pfnTearOff
    &s_AccelsTCellRun                   // _pAccelsRun
};


HRESULT
CTableCell::CreateElement(CHtmTag *pht,
                  CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CTableCell(pht->GetTag(), pDoc);
    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLTableCell2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::EnterTree, CElement
//
//  Synopsis:   Add the cell to the table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::EnterTree()
{
    HRESULT hr = S_OK;

    if (!GetMarkup()->_fInnerHTMLMarkup)
    {
        CTable *pTable = Table();
        CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

        // Only maintain the table layout cache incrementally until the table
        // has finished parsing.
        if (pTableLayout && (!pTableLayout->IsCompleted() || pTableLayout->_fTableOM))
        {
            if (IsCaption(Tag()))
            {
                CTableCaption * pCaption = DYNCAST(CTableCaption, this);

                Assert(pTableLayout);
                hr = pTableLayout->AddCaption(pCaption);
            }
            else
            {
                CTableRow *pRow = Row();
                if (pRow)
                {
                    CTableRowLayout * pRowLayout = pRow->RowLayoutCache();

                    Assert(pRowLayout);
                    hr = pRowLayout->AddCell(this);
                }
                else
                {
                    if (pTableLayout)
                        pTableLayout->MarkTableLayoutCacheDirty();
                }
            }
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::OnPropertyChange
//
//  Synopsis:   Process property changes on the cell
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;
    CTableCellLayout * pCellLayout = Layout();

    if (pCellLayout)
    {
        switch (dispid)
        {
        case DISPID_A_POSITION:
        // case DISPID_A_DISPLAY:   // this will be handled by ::Notify
            pCellLayout->HandlePositionDisplayChange();
            break;

        case DISPID_A_BORDERWIDTH:
        case DISPID_A_BORDERTOPWIDTH:
        case DISPID_A_BORDERRIGHTWIDTH:
        case DISPID_A_BORDERBOTTOMWIDTH:
        case DISPID_A_BORDERLEFTWIDTH:
            pCellLayout->ResetMinMax();
            break;

        case DISPID_IHTMLTABLECELL_ROWSPAN/*(DISPID_TABLECELL+1)*/:
        case DISPID_IHTMLTABLECELL_COLSPAN/*(DISPID_TABLECELL+2)*/: 
            {
                CTable           * pTable = Table();
                CTableLayout     * pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

                if (pTableLayout) 
                {
                    pTableLayout->Fixup();
                }
            }
            break;
        }
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}

                    
//+------------------------------------------------------------------------
//
//  Member:     CTableCell::Save
//
//  Synopsis:   Save the cell to the stream
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::Save(CStreamWriteBuff *pStmWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = super::Save(pStmWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (fEnd && pStmWrBuff->TestFlag(WBF_FORMATTED_PLAINTEXT))
    {
        // Save a space between <TD> tags duing plaintext save.
        hr = pStmWrBuff->Write(_T(" "));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCell::RowSpan, CTableCell
//
//  Synopsis:   Returns number of rows cell spans
//
//  Returns:    rows
//
//-------------------------------------------------------------------------

int
CTableCell::RowSpanHelper(int cRowSpan)
{
#if DBG==1
    CTableLayout * pTableLayout = Table()->TableLayoutCache();
#endif
    Assert(pTableLayout->IsTableLayoutCacheCurrent());

    CTableSection * pSection = Section();
    int iRowIdx = max(RowIndex(), 0);
    int cRowsLeftInSection   = pSection->_iRow + pSection->_cRows - iRowIdx;

    if (!cRowsLeftInSection)
    {
        // this can happen when a cell is cut out of a tree (treestress bug 72131)
        // and it winds up getting notifications in the process
        return 1;
    }

    // Rows left in sections include this table cell's row.
    Assert(cRowsLeftInSection >= 1 && cRowsLeftInSection <= pSection->_cRows);

    // Don't return a span going past the end of the section (or the number
    // of rows in the table for that matter).
    if (cRowSpan > cRowsLeftInSection)
    {
        // Section sanity check.
        Assert(pSection->_iRow + pSection->_cRows <= pTableLayout->GetRows());
        return cRowsLeftInSection;
    }
    else
    {
        // Since we are within the section we know we didn't pass the end
        // of the table.  Assert that.
        Assert(iRowIdx + cRowSpan <= pTableLayout->_aryRows.Size());

        return cRowSpan;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCell::ApplyCellFormat
//
//  Synopsis:   Apply attributes
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::ApplyCellFormat(CFormatInfo *pCFI)
{
    CColorValue ccvBorderColor;
    CUnitValue  cuvZeroPoints, cuvZeroPercent, cuvInheritedWidth;
    LONG        lZeroPoints, lZeroPercent;
    BYTE        i;
    HRESULT     hr;

    BOOL fComputeFFOnly = pCFI->_pNodeContext->_iCF != -1;

    // Dont inherit down the no-break bit
    if (pCFI->_pcf->_fNoBreakInner)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fNoBreakInner = FALSE;
        pCFI->UnprepareForDebug();
    }
    
    cuvZeroPoints.SetPoints(0);
    lZeroPoints = cuvZeroPoints.GetRawValue();
    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    lZeroPercent = cuvZeroPercent.GetRawValue();

    if (!fComputeFFOnly)
    {
        if (Tag() == ETAG_TH)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fBold = TRUE;
            pCFI->_cf()._wWeight = 700;
            pCFI->UnprepareForDebug();
        }
    }

    // Override inherited colors as necessary
    ccvBorderColor = GetAAborderColor();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->PrepareFancyFormat();

        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff()._bd.SetBorderColor(i, ccvBorderColor);
        }

        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight =
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;

        pCFI->UnprepareForDebug();
    }

    ccvBorderColor = GetAAborderColorLight();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
        pCFI->UnprepareForDebug();
    }

    ccvBorderColor = GetAAborderColorDark();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
        pCFI->UnprepareForDebug();
    }

    if (pCFI->_pff->_bd._bBorderColorsSetUnique)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._bBorderColorsSetUnique = FALSE;
        pCFI->UnprepareForDebug();
    }

    CUnitValue cuvNull; cuvNull.SetNull();
    for (i = 0; i < SIDE_MAX; i++)
    {
        if (    !pCFI->_pff->_bd.GetBorderWidth(i).IsNull()
            ||  pCFI->_pff->_bd.GetBorderStyle(i) != (BYTE)-1)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bd.SetBorderWidth(i, cuvNull);
            pCFI->_ff()._bd.SetBorderStyle(i, (BYTE)-1);
            pCFI->UnprepareForDebug();
        }
    }

    if (!fComputeFFOnly)
    {
        // Don't inherit blockquote indentation for all of the cells.

        if (    pCFI->_ppf->_cuvLeftIndentPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvLeftIndentPercent.GetRawValue() != lZeroPercent
            ||  pCFI->_ppf->_cuvRightIndentPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvRightIndentPercent.GetRawValue() != lZeroPercent
            ||  pCFI->_ppf->_cuvOffsetPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvNonBulletIndentPoints.GetRawValue() != lZeroPoints
            ||  !pCFI->_ppf->_cListing.IsReset())
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvLeftIndentPoints = cuvZeroPoints;
            pCFI->_pf()._cuvLeftIndentPercent = cuvZeroPercent;
            pCFI->_pf()._cuvRightIndentPoints = cuvZeroPoints;
            pCFI->_pf()._cuvRightIndentPercent = cuvZeroPercent;
            pCFI->_pf()._cuvOffsetPoints = cuvZeroPoints;
            pCFI->_pf()._cuvNonBulletIndentPoints = cuvZeroPoints;
            pCFI->_pf()._cListing.Reset();
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Save and clear out any inherited width
    //


    cuvInheritedWidth = pCFI->_pff->GetWidth();
    if (!cuvInheritedWidth.IsNull())
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff().ClearWidth();
        pCFI->UnprepareForDebug();
    }

    //
    // Apply standard formats
    //

    Assert(pCFI->_pNodeContext && SameScope(pCFI->_pNodeContext, this));
    hr = THR( ApplyDefaultFormat(pCFI) );
    if (hr)
        goto Cleanup;

    //
    // Clear all margin values
    // NOTE: Margins are not supported on cells or captions
    //

    if (    pCFI->_pff->_cuvSpaceBefore.GetRawValue() != lZeroPoints
        ||  pCFI->_pff->_cuvSpaceAfter.GetRawValue() != lZeroPoints
        ||  !pCFI->_pff->GetMargin(SIDE_TOP).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_RIGHT).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_BOTTOM).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_LEFT).IsNull())
    {
        //
        // Note: (srinib) when margins are implemented  on table cell's,
        // verify ApplyInnerOuterFormats for margins.
        //
        CUnitValue uvNull(0, CUnitValue::UNIT_NULLVALUE);

        pCFI->PrepareFancyFormat();
        pCFI->_ff()._cuvSpaceBefore = cuvZeroPoints;
        pCFI->_ff()._cuvSpaceAfter = cuvZeroPoints;
        pCFI->_ff().SetExplicitMargin(SIDE_TOP, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_RIGHT, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_BOTTOM, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_LEFT, FALSE);
        pCFI->_ff().SetMargin(SIDE_TOP, uvNull);
        pCFI->_ff().SetMargin(SIDE_RIGHT, uvNull);
        pCFI->_ff().SetMargin(SIDE_BOTTOM, uvNull);
        pCFI->_ff().SetMargin(SIDE_LEFT, uvNull);
        pCFI->_ff()._fHasMargins = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // If there was no explicit width on the cell, use the inherited width
    //

    if (pCFI->_pff->GetWidth().IsNull())
    {
        _fInheritedWidth = TRUE;

        pCFI->PrepareFancyFormat();
        pCFI->_ff().SetWidth(cuvInheritedWidth);
        pCFI->UnprepareForDebug();
    }

    if (!fComputeFFOnly)
    {
        if (Tag() == ETAG_CAPTION || Tag() == ETAG_TC)
        {
            // Note: The caption.pdl specifies the align as DISPID_A_BLOCKALIGN - which means
            // it gets written into the _blockAlign - but caption has two extra ( vertical )
            // enum values that we need to map onto the equivalent vertical alignment values.
            // The code that handles this maping you can find in ApplyParagraphAlignment() (cpfp.cxx)

            // Map Caption enum to ControlAlign enum
            if (    pCFI->_ppf->_bTableVAlignment == htmlCaptionVAlignTop
                ||  pCFI->_ppf->_bTableVAlignment == htmlCaptionAlignTop)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignTop;
                DYNCAST(CTableCaption,this)->_uLocation = CTableCaption::CAPTION_TOP;
                pCFI->UnprepareForDebug();
            }
            else if (   pCFI->_ppf->_bTableVAlignment == htmlCaptionVAlignBottom
                    ||  pCFI->_ppf->_bTableVAlignment == htmlCaptionAlignBottom)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignBottom;
                DYNCAST(CTableCaption,this)->_uLocation = CTableCaption::CAPTION_BOTTOM;
                pCFI->UnprepareForDebug();
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

static HRESULT VerticalAlignFromCellVAlign(CFormatInfo * pCFI)
{
    //
    // Set only block align.
    // 

    HRESULT hr = S_OK;
    htmlControlAlign   ca;  

    switch ((htmlCellVAlign)pCFI->_ppf->_bTableVAlignment)
    {
    case htmlCellVAlignNotSet:
        ca = htmlControlAlignNotSet;
        break;
    case htmlCellVAlignTop:
        ca = htmlControlAlignTop;
        break;
    case htmlCellVAlignMiddle:
        ca = htmlControlAlignMiddle;
        break;
    case htmlCellVAlignBottom:
        ca = htmlControlAlignBottom;
        break;
    case htmlCellVAlignBaseline:
        ca = htmlControlAlignBaseline;
        break;
    default:
        ca = htmlControlAlignNotSet;   // keep compiler happy
        Assert(0);
        hr = E_INVALIDARG;
        break;
    }

    if (pCFI->_pff->_bControlAlign != ca)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bControlAlign = ca;
        pCFI->UnprepareForDebug();
    }

    RRETURN(hr);
}

// Look at two different elements and determine if their formats might be different.
static BOOL PotentiallyDifferentFormats (CElement *pElement1, CElement *pElement2)
{
    // If both are missing, then we're the same.
    if (pElement1 != NULL || pElement2 != NULL)
    {
        // Let's compare class and ID.
        if (pElement2 != NULL && pElement1 != NULL)
        {
            LPCTSTR pstr;
            LPCTSTR pstr1;

            // Are there classes at all?
            pstr=pElement2->GetAAclassName();
            pstr1=pElement1->GetAAclassName();
            if (pstr1 != NULL || pstr != NULL)
            {
                if (pstr1 != NULL && pstr != NULL)
                {
                    if (_tcscmp(pstr, pstr1) != 0)
                        goto Cleanup;
                }
                else
                    goto Cleanup;
            }

            // Same thing for the IDs.
            pstr1=pElement2->GetAAid();
            pstr=pElement1->GetAAid();
            if (pstr1 != NULL || pstr != NULL)
            {
                if (pstr1 != NULL && pstr != NULL)
                {
                    if (_tcscmp(pstr, pstr1) != 0)
                        goto Cleanup;
                }
                else
                    goto Cleanup;
            }
        }
        // One element exists the other is NULL.
        else
            goto Cleanup;
    }

    return FALSE;

Cleanup:
    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::CheckSameFormat
//
//  Synopsis:   Check if the other cell in the other row/col has the same
//              format and use it if it is...
//-------------------------------------------------------------------------

BOOL
CTableCell::CheckSameFormat
(
    CTreeNode  * pNodeTarget,
    CTableCell * pCell1,
    CTableRow * pRow,
    CTableRow * pRow1,
    CTableCol * pCol,
    CTableCol * pCol1
)
{
    Assert(this == pNodeTarget->Element());

    // If we are computing formats for pseudo elements, then we cannot steal formats
    // since the formats we will compute will be different than the normal stolen
    // formats because of the first line/letter settings (bug 87707)
    if (GetMarkup()->HasCFState() || !pCell1->_fStealingAllowed)
        return FALSE;

    BOOL fSameRow = pRow == pRow1;
    BOOL fSameCol = pCol == pCol1;
    BOOL fPotentiallyDifferent=FALSE;   // Optimism.
    // Do we have the same class or ID as the column we're comparing?
    if (fSameRow)
    {
        fPotentiallyDifferent = PotentiallyDifferentFormats (pCol, pCol1);
    }
    else if (fSameCol)
    {
        fPotentiallyDifferent = PotentiallyDifferentFormats (pRow, pRow1);
    }

    if (fPotentiallyDifferent)
    {
        return FALSE;
    }

    CTreeNode * pNodeCell1 = pCell1->GetFirstBranch();
    CTreeNode * pNodeRow   = pRow->GetFirstBranch();
    CTreeNode * pNodeRow1  = pRow1->GetFirstBranch();
    CTreeNode * pNodeCol   = pCol? pCol->GetFirstBranch() : NULL;
    CTreeNode * pNodeCol1  = pCol1? pCol1->GetFirstBranch() : NULL;

    if (pNodeCell1->_iFF >= 0)
    {
        const CFancyFormat *pFF = GetFancyFormatEx(pNodeCell1->_iFF);

        if (pFF->_pszFilters || pFF->_fHasExpressions)
            return FALSE;
    }

    if (pNodeRow1->_iFF >= 0)
    {
        const CFancyFormat *pFF = GetFancyFormatEx(pNodeRow1->_iFF);

        // Table rows don't have filters
        if (pFF->_fHasExpressions)
            return FALSE;
    }

    if (HasPeerHolder() && GetPeerHolder()->TestFlagMulti(CPeerHolder::NEEDAPPLYSTYLE))
    {
        return FALSE;
    }

    if (pNodeCell1->_iPF >= 0 &&
        (_pAA == NULL && pCell1->_pAA == NULL ||
         (_pAA != NULL && pCell1->_pAA != NULL && _pAA->Compare(pCell1->_pAA)) ) &&
        ((pNodeRow->_iPF >= 0 && pRow == pRow1) ||
            (pNodeRow1->_iPF >= 0 &&
            pNodeRow->_iPF == pNodeRow1->_iPF &&
            pNodeRow->_iCF == pNodeRow1->_iCF &&
            pNodeRow->_iFF == pNodeRow1->_iFF)) &&
        ((!pCol && !pCol1) ||
            (pCol && pCol1 && ((pNodeCol->_iPF >= 0 && pCol == pCol1) ||
                               (pNodeCol1->_iPF >= 0 &&
                                pNodeCol->_iPF == pNodeCol1->_iPF &&
                                pNodeCol->_iCF == pNodeCol1->_iCF &&
                                pNodeCol->_iFF == pNodeCol1->_iFF)))))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Function:   ApplyFormatUptoTable
//
//  Synopsis:   Apply format of all the elements above the passed element (p)
//              upto the table element (not including the table element)
//
//              We need this function because of ETAG_TC elemnts exclude
//              ETAG_TABLE elements when we apply the format to them.
//
//  Arguments:  pCFI - Format Info needed for cascading
//              p - Element to start from
//
//  Note:       This is a recursive function. It can be written in a generic
//              way if anybody would need this function (we could of passed
//              the ETAG_TABLE as a parameter). But since there is no need
//              for it yet (it is remainig as a part of the table code)
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::ApplyFormatUptoTable(CFormatInfo * pCFI)
{
    CTreeNode * pNodeParent = pCFI->_pNodeContext->Parent();
    HRESULT     hr = S_OK;

    if (pNodeParent->Tag() != ETAG_TABLE)
    {
        pCFI->_pNodeContext = pNodeParent;
        hr = ApplyFormatUptoTable(pCFI);
        if (hr)
            goto Cleanup;
        pCFI->_pNodeContext = pNodeParent;
        hr = THR(pNodeParent->Element()->ApplyDefaultFormat(pCFI));
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCell::ComputeFormatsVirtual
//
//  Synopsis:   Compute Char and Para formats induced by this element and
//              every other element above it in the HTML tree.
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//  Note:       We override this here to put our defaults into the format
//              FIRST, and also to cache vertical alignment here in the object
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget)
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    // (KTam) This is bogus, the only reason we ask for layout in this fn
    // is so we can check _fDisplayNoneCell (which ought to be obtained
    // from the cell element).  In the meantime, first layout is OK.
    CTableCellLayout   *pLayout = Layout(GUL_USEFIRSTLAYOUT);
    CTableCol *         pCol = NULL;
    CTableCol *         pColGroup = NULL;
    CTableRow *         pRow = NULL;
    CTableSection *     pSection = NULL;
    ELEMENT_TAG         etag;
    CTable *            pTable;
    CTableLayout *      pTableLayout = NULL;
    const CParaFormat * pPFRow = NULL;
    const CParaFormat * pPFCol = NULL;
    const CParaFormat * pPFColGroup = NULL;
    HRESULT             hr = S_OK;
    CUnitValue          cuvColWidth;
    CUnitValue          cuvZeroPoints;
    CUnitValue          cuvZeroPercent;
    WHEN_DBG( BOOL      fDisableTLCAssert = FALSE; )
    CTreeNode         * pNodeTable;
    CTreeNode         * pNodeRow = NULL;
    CTreeNode         * pNodeCol = NULL;
    CTreeNode         * pNodeColGroup = NULL;
    CTableCell        * pCellNeighbor = NULL;
    CTableCol *         pColNeighbor = NULL;
    CTreeNode         * pNodeInherit;
    THREADSTATE *       pts = GetThreadState();
    LONG                lZeroPoints;
    BOOL                fComputeFFOnly = pNodeTarget->_iCF != -1;
    BOOL                fSetWidthFromCol = FALSE;
    COMPUTEFORMATSTYPE  eExtraValues = pCFI->_eExtraValues;

    if(eExtraValues == ComputeFormatsType_GetInheritedIntoTableValue)
    {
        // It is not violated, we just want to disable the format stealing stuff when
        // the puprose of calling ComputeFormats is to get the inherited value.
        goto TableStructureViolated;
    }


    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    cuvZeroPoints.SetPoints(0);
    lZeroPoints = cuvZeroPoints.GetRawValue();

    Assert(pCFI);
    Assert( SameScope( this, pNodeTarget ) );

    etag         = Tag();
    pTable       = Table();

    // If we are not in a table, we are messed up, and we'll just
    // use the CElement::ComputeFormat handling.
    if (!pTable)
        goto TableStructureViolated;

    pNodeTable   = pTable->GetFirstBranch();
    pTableLayout = pTable->TableLayoutCache();

    WHEN_DBG( fDisableTLCAssert = pTableLayout->_fDisableTLCAssert;
              pTableLayout->_fDisableTLCAssert = TRUE; )

    // Note:  We are not doing a pTableLayout->EnsureTableLayoutCache()
    // even though the current version might be dirty (can happen in
    // databinding).  In those cases we WANT to work with the old version
    // in case elements would disappear on us.

    // if there are no attributes to worry about try to use an other cell's format
    if (!IsCaption(etag))
    {
        Assert(!pCol || SameScope(pCol->GetFirstBranch()->Ancestor(ETAG_COLGROUP), pColGroup));

        pSection  = Section();
        pRow      = Row();
        pColGroup = pTableLayout->GetColGroup(ColIndex());
        pCol      = pTableLayout->GetCol(ColIndex());

        if (!pRow || !pSection)
            goto TableStructureViolated;

        // make sure row and col cached it's format...
        pNodeRow = pRow->GetFirstBranch();
        pPFRow = pNodeRow->GetParaFormat();
        if (pColGroup)
        {
            pNodeColGroup = pColGroup->GetFirstBranch();
            if (pNodeColGroup)
                pPFColGroup = pNodeColGroup->GetParaFormat();
        }
        if (pCol)
        {
            pNodeCol = pCol->GetFirstBranch();
            pPFCol = pNodeCol->GetParaFormat();
        }

        if (   (eExtraValues == ComputeFormatsType_Normal) 
            && pTableLayout->IsTableLayoutCacheCurrent() 
            && !pLayout->_fDisplayNoneCell)
        {
            CTableRow *       pRowNeighbor;
            CTableRowLayout * pRowLayout = pRow->RowLayoutCache();
            int               iCol = ColIndex(), iRow;

            iRow = pRow->_iRow;   // faster then  = RowIndex()

            // try to steal format from the cell in the same column from the previous data-bound section
            if (pTableLayout->IsGenerated(iRow) && pSection != pTableLayout->_aryBodys[0])
            {
                // use the template's format
                iRow = iRow - pSection->_iRow; // relative row number
                Assert (iRow < pSection->_cRows);
                if((pTableLayout->_aryBodys[0]->_iRow + iRow) >= 0)
                {
                    pRowNeighbor = pTableLayout->_aryRows[pTableLayout->_aryBodys[0]->_iRow + iRow];
                    if (pRowNeighbor && pRowNeighbor->RowLayoutCache()->GetCells() > iCol)
                    {
                        pCellNeighbor = Cell(pRowNeighbor->RowLayoutCache()->_aryCells[iCol]);
                        if (pCellNeighbor && CheckSameFormat(pNodeTarget, pCellNeighbor, pRow, pRowNeighbor, pCol, pCol))
                        {
                            goto StealFormat;
                        }
                    }
                }
            }

            // try to steal format from the cell in the same row from the previous column 
            if (      iCol > 0 && iCol <= pRowLayout->GetCells()            
                   && (pCellNeighbor = pRowLayout->GetCell(iCol-1)) != this  
                   && pCellNeighbor
                   && pCellNeighbor->Section() == pSection
                   && pTableLayout->GetColGroup(iCol-1) == pColGroup
                   && (pColNeighbor = pTableLayout->GetCol(iCol-1)) == pCol
                   && pCellNeighbor->Tag() == etag)
            {
                if (CheckSameFormat(pNodeTarget, pCellNeighbor, pRow, pRow, pCol, pColNeighbor))
                {
                    goto StealFormat;
                }
            }

            // try to steal format from the cell in the same column from the previous row
            if (iRow > 0 && iRow <= pTableLayout->GetRows())
            {
                pRowNeighbor = pTableLayout->GetRow(iRow-1);
                CTableRowLayout *pRowNeighborLayout = pRowNeighbor->RowLayoutCache();
                if (pRowNeighborLayout->GetCells() > iCol                       &&
                    (pCellNeighbor = pRowNeighborLayout->GetCell(iCol)) != this &&
                    pCellNeighbor                                               &&
                    IsReal(pRowNeighborLayout->_aryCells[iCol])                 &&
                    pCellNeighbor->Section() == pSection                        &&
                    pCellNeighbor->Tag() == etag)
                {
                    Assert(pCellNeighbor->Layout(GUL_USEFIRSTLAYOUT)->ColGroup() == pColGroup);
                    if (CheckSameFormat(pNodeTarget, pCellNeighbor, pRow, pRowNeighbor, pCol, pCol))
                    {
                        goto StealFormat;
                    }
                }
            }
        }
    }

    if (etag == ETAG_TC)
        pNodeInherit = pNodeTable->Parent();
    else if(etag == ETAG_CAPTION)
        pNodeInherit = pNodeTable;
    else if (!pCol || !pColGroup)
        pNodeInherit = pNodeRow;
    else
        pNodeInherit = pNodeTable;

    if (    pNodeInherit->_iCF == -1
        ||  pNodeInherit->_iFF == -1)
    {
        SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

        hr = THR(pNodeInherit->Element()->ComputeFormats(pCFI, pNodeInherit));

        SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

        if (hr)
            goto Cleanup;
    }

    Assert(pNodeInherit->_iCF >= 0);
    Assert(pNodeInherit->_iPF >= 0);
    Assert(pNodeInherit->_iFF >= 0);
    //
    // NOTE: From this point forward any errors must goto Error instead of Cleanup!
    //

    pCFI->Reset();

    //
    // Setup Fancy Format
    //

    if (IsCaption(etag))
    {
        pCFI->_iffSrc = pts->_iffDefault;
        pCFI->_pffSrc = pCFI->_pff = pts->_pffDefault;
        Assert(pCFI->_pffSrc->_pszFilters == NULL);
    }
    else
    {
        pCFI->_iffSrc = pNodeInherit->_iFF;
        pCFI->_pffSrc = pCFI->_pff = &(*pts->_pFancyFormatCache)[pCFI->_iffSrc];
        pCFI->_fHasExpandos = (pCFI->_pff->_iExpandos >= 0);

        if (pCFI->_pff->_pszFilters)
        {
            // note: we are letting the cell inherit zoom and rotation from row, because row can't have a layout
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._pszFilters = NULL;
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Setup Char and Para formats
    //

    pCFI->_icfSrc = pNodeInherit->_iCF;
    pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
    pCFI->_ipfSrc = pNodeInherit->_iPF;
    pCFI->_ppfSrc = pCFI->_ppf = &(*pts->_pParaFormatCache)[pCFI->_ipfSrc];

    //
    // Apply formats
    //

    if (etag == ETAG_TC)
    {
        // We treat <TC> (text in between table cells) as if the text is outside the
        // table for Netscape compatibility, so do not apply the table's format.

        pCFI->_pNodeContext = pNodeTarget;
        hr = ApplyFormatUptoTable(pCFI);
        if (hr)
            goto Error;
    }

    if (!fComputeFFOnly)
    {
        // Because we're re-using the pCFI between applies, we need to explictly
        // clear those members that we don't want to "inherit" as we apply.
        // For example, width/height should not be inherited from the table

        if (    pCFI->_ppf->_bBlockAlign != htmlAlignNotSet
            ||  pCFI->_ppf->_cuvRightIndentPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvLeftIndentPoints.GetRawValue() != lZeroPoints)
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._bBlockAlign = htmlAlignNotSet;
            pCFI->_pf()._cuvRightIndentPoints.SetRawValue(lZeroPoints);
            pCFI->_pf()._cuvLeftIndentPoints.SetRawValue(lZeroPoints);
            pCFI->UnprepareForDebug();
        }
    }

    //
    //  Initialize padding with the CELLPADDING attribute
    //

    if (etag != ETAG_CAPTION)
    {
        CUnitValue uvPadding = pTable->GetAAcellPadding();

        if (uvPadding.IsNull())
        {
            uvPadding.SetValue(1, CUnitValue::UNIT_PIXELS);
        }

        if (uvPadding.GetPixelValue())
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetPadding(SIDE_LEFT, uvPadding);
            pCFI->_ff().SetPadding(SIDE_RIGHT, uvPadding);
            pCFI->_ff().SetPadding(SIDE_TOP, uvPadding);
            pCFI->_ff().SetPadding(SIDE_BOTTOM, uvPadding);
            pCFI->UnprepareForDebug();
        }
    }

    else if (!pTableLayout->_fCollapse)
    {
        // Add caption spacing for Netscape compatibility.
        CUnitValue          uvPadding = pTable->GetAAcellPadding();
        CUnitValue          uvSpacing = pTable->GetAAcellSpacing();
        CUnitValue          uvBorder  = pTable->GetAAborder();
        CUnitValue          uv;
        htmlCaptionVAlign   valign;
        long                cyPaddingBottom;

        if (uvPadding.IsNull())
        {
            uvPadding.SetValue(1, CUnitValue::UNIT_PIXELS);
        }

        if (uvSpacing.IsNull())
        {
            uvSpacing.SetValue(2, CUnitValue::UNIT_PIXELS);
        }

        if (uvBorder.IsNull())
        {
            uvBorder.SetValue(0, CUnitValue::UNIT_PIXELS);
        }

        if (    uvPadding.GetPixelValue()
            ||  uvSpacing.GetPixelValue()
            ||  uvBorder.GetPixelValue())
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetPadding(SIDE_TOP, uvPadding);

            uv.SetValue(uvPadding.GetPixelValue() + uvSpacing.GetPixelValue() + uvBorder.GetPixelValue(), CUnitValue::UNIT_PIXELS);
            pCFI->_ff().SetPadding(SIDE_LEFT, uv);
            pCFI->_ff().SetPadding(SIDE_RIGHT, uv);

            CAttrArray::FindSimple( *GetAttrArray(), &s_propdescCTableCaptionvAlign.a, (DWORD *)&valign);

            if (valign == htmlCaptionVAlignNotSet)
            {
                CAttrArray::FindSimple( *GetAttrArray(), &s_propdescCTableCaptionalign.a, (DWORD *)&valign);

                valign = (valign == htmlCaptionAlignBottom
                                ? htmlCaptionVAlignBottom
                                : htmlCaptionVAlignTop);
            }

            // Netscape: doesn't adjust TOP for a caption, instead it adjust the bottom of the "TOP" captions
            cyPaddingBottom = uvPadding.GetPixelValue() + (valign == htmlCaptionVAlignBottom
                                                                ? uvSpacing.GetPixelValue()
                                                                : uvBorder.GetPixelValue() + (2 * uvSpacing.GetPixelValue()));

            uv.SetValue(cyPaddingBottom, CUnitValue::UNIT_PIXELS);
            pCFI->_ff().SetPadding(SIDE_BOTTOM, uv);
            pCFI->UnprepareForDebug();
        }
    }

    if (!fComputeFFOnly)
    {
        if (pCFI->_pcf->_fRelative)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fRelative = FALSE;
            pCFI->UnprepareForDebug();
        }
    }

    if (etag != ETAG_CAPTION && etag != ETAG_TC)
    {
        if (pCol || pColGroup)
        {
            if (pColGroup)
            {
                pCFI->_pNodeContext = pColGroup->GetFirstBranch();
                hr = THR(pColGroup->ApplyDefaultFormat(pCFI));
                if (hr)
                    goto Error;
            }

            if (pCol)
            {
                pCFI->_pNodeContext = pCol->GetFirstBranch();
                hr = THR(pCol->ApplyDefaultFormat(pCFI));
                if (hr)
                    goto Error;
            }

            // Cache column width.
            // Table is always horizontal => width is in physical coordinate system.
            cuvColWidth = pCFI->_pff->GetWidth();
            fSetWidthFromCol = !cuvColWidth.IsNull();

            pCFI->_pNodeContext = pSection->GetFirstBranch();
            hr = THR(pSection->ApplyDefaultFormat(pCFI));
            if (hr)
                goto Error;

            Assert (pNodeRow);
            pCFI->_pNodeContext = pNodeRow;
            hr = THR(pRow->ApplyDefaultFormat(pCFI));
            if (hr)
                goto Error;

        }

        if (!fComputeFFOnly)
        {
            // (alexa) The following is a precedence order for each attribute (HTML3 Table Model Spec),
            // where x > y denotes that x takes precedence over y
            // for ALIGN (_blockAlign), CHAR and CHAROFF
            // cell > column > column groups > row > row groups > default
            // for VALIGN (_bTableVAlignment), LANG, DIR, STYLE
            // cell > row > row groups > column > column groups > table > default

            // 1a. Set default ALIGN property
            if (pCFI->_bBlockAlign == htmlBlockAlignNotSet &&
                etag == ETAG_TH)
            {
                // By default, htmlAlignNotSet is htmlAlignLeft, so do not set it to
                // htmlAlignLeft it will mess up alignment on contained sites which
                // are not aligned left by default (ex. HR).
                pCFI->_bBlockAlign = htmlBlockAlignCenter;

            }

            // 2a. Apply horizontal alignment for table cells in different order
            if (pPFRow->_bBlockAlignInner != htmlBlockAlignNotSet)
            {
                pCFI->_bBlockAlign = pPFRow->_bBlockAlignInner;
            }

            // 3a. then apply alignment from column groups
            if (pPFColGroup && pPFColGroup->_bBlockAlign != htmlBlockAlignNotSet)
            {
                pCFI->_bBlockAlign = pPFColGroup->_bBlockAlign;
            }

            // 3b. then inherit align from columns
            if (pPFCol && pPFCol->_bBlockAlign != htmlBlockAlignNotSet)
            {
                pCFI->_bBlockAlign = pPFCol->_bBlockAlign;
            }

            // 4a. Cell will apply its own ALIGN format if specified when we call ApplyCellFormat()

            // 1b. Set default VALIGN format if it was not set by COLs and Rows already,
            // if it was set, the correct precedence already took place during
            // COL and ROW ApplyFormat() above.
            if (pCFI->_ppf->_bTableVAlignment == htmlCellVAlignNotSet)
            {
                Assert(etag == ETAG_TH || etag == ETAG_TD || etag == ETAG_TC);
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignMiddle;
                pCFI->UnprepareForDebug();
            }
        }
    }
    else
    {
        if (!fComputeFFOnly)
        {
            // set the default ALIGN/VALIGN format for CAPTION
            pCFI->_bBlockAlign = (etag == ETAG_CAPTION)? htmlBlockAlignCenter : htmlBlockAlignNotSet;

            if (pCFI->_ppf->_bTableVAlignment != htmlCellVAlignTop)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignTop;
                pCFI->UnprepareForDebug();
            }
        }
    }

    if (    pCFI->_pff->_cuvSpaceBefore.GetRawValue() != lZeroPoints
        ||  pCFI->_pff->_cuvSpaceAfter.GetRawValue() != lZeroPoints
        ||  !pCFI->_pff->GetWidth().IsNull()
        ||  !pCFI->_pff->GetPosition(SIDE_TOP).IsNull()
        ||  !pCFI->_pff->GetPosition(SIDE_LEFT).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_TOP).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_RIGHT).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_BOTTOM).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_RIGHT).IsNull()
        ||  pCFI->_pff->_bDisplay != styleDisplayNotSet
        ||  pCFI->_pff->_bPositionType != stylePositionNotSet
        ||  pCFI->_pff->_fPositioned
        ||  pCFI->_pff->_fAutoPositioned
        ||  pCFI->_pff->_fScrollingParent
        ||  pCFI->_pff->_fZParent
        ||  pCFI->_pff->_iExpandos != -1
        ||  pCFI->_pff->_iCustomCursor != -1
        ||  pCFI->_pff->_iPEI != -1
        ||  pCFI->_pff->_fHasExpressions != 0
        ||  pCFI->_pff->_lZIndex != 0
        ||  pCFI->_pff->_pszFilters
        ||  pCFI->_pff->_bPageBreaks != 0
        ||  pCFI->_pff->HasCSSVerticalAlign()
        ||  pCFI->_pff->GetVerticalAlign() != styleVerticalAlignNotSet
        ||  pCFI->_pff->_fLayoutFlowChanged
        ||  fSetWidthFromCol)
    {
        CUnitValue uvNull(0, CUnitValue::UNIT_NULLVALUE);

        pCFI->PrepareFancyFormat();
        pCFI->_ff()._cuvSpaceBefore.SetValue(0, CUnitValue::UNIT_POINT);
        pCFI->_ff()._cuvSpaceAfter.SetValue(0, CUnitValue::UNIT_POINT);
        pCFI->_ff().ClearWidth();
        // set the correct width (column width)
        if (fSetWidthFromCol)
        {
            pCFI->_ff().SetWidth(cuvColWidth);
        }
        pCFI->_ff().SetPosition(SIDE_TOP, uvNull);
        pCFI->_ff().SetPosition(SIDE_LEFT, uvNull);
        pCFI->_ff().SetExplicitMargin(SIDE_TOP, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_RIGHT, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_BOTTOM, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_LEFT, FALSE);
        pCFI->_ff().SetMargin(SIDE_TOP, uvNull);
        pCFI->_ff().SetMargin(SIDE_RIGHT, uvNull);
        pCFI->_ff().SetMargin(SIDE_BOTTOM, uvNull);
        pCFI->_ff().SetMargin(SIDE_LEFT, uvNull);
        pCFI->_ff()._bDisplay = styleDisplayNotSet;
        pCFI->_ff()._bPositionType = stylePositionNotSet;
        pCFI->_ff()._lZIndex = 0;
        pCFI->_ff()._fPositioned = FALSE;
        pCFI->_ff()._fAutoPositioned = FALSE;
        pCFI->_ff()._fScrollingParent = FALSE;
        pCFI->_ff()._fZParent = FALSE;
        pCFI->_ff()._pszFilters = NULL;
        pCFI->_ff()._bPageBreaks = 0;
        pCFI->_ff()._iExpandos = -1;
        pCFI->_ff()._iCustomCursor = -1   ;     
        pCFI->_ff()._iPEI = -1;
        pCFI->_ff()._fHasExpressions = FALSE;
        pCFI->_ff().SetCSSVerticalAlign(FALSE);
        pCFI->_ff().SetVerticalAlign(styleVerticalAlignNotSet);
        pCFI->_ff()._fLayoutFlowChanged = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // Due to the complexity of alignment, we must keep these values
    // synchronised.
    //
    pCFI->_bCtrlBlockAlign = pCFI->_bBlockAlign;

    // copy the display & visibility values onto the pCFI, so if
    // visibility/display style change, pcf is correctly updated.
    pCFI->_fDisplayNone      = pCFI->_pcf->_fDisplayNone;
    pCFI->_fVisibilityHidden = pCFI->_pcf->_fVisibilityHidden;

    // Apply the cell itself
    pCFI->_pNodeContext = pNodeTarget;
    hr = THR(ApplyCellFormat(pCFI));
    if (hr)
        goto Error;

    // Transfer the cascading table valign into the vertical align
    hr = VerticalAlignFromCellVAlign(pCFI);
    if (hr)
        goto Error;

    // Vertical alignment for layouts has no meaning (TD has a layout),
    // so it is safe to turn off _fNeedsVerticalAlign flag.
    // We are doing this for perf reasons, when TD has a "vertical-align" property set.
    // In case of vertical text we set _fNeedsVerticalAlign to TRUE in ApplyDefaultFormat, 
    // because of middle vertical alignment of vertical text. So in this case don't 
    // turn off this flag.
    if (   pCFI->_pcf->_fNeedsVerticalAlign
        && !fComputeFFOnly
        && !pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fNeedsVerticalAlign = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // NETSCAPE: If the user specified both WIDTH and NOWRAP, ignore NOWRAP if a fixed
    //           WIDTH was supplied (e.g., in pixels, not percent).
    //           PRE tags within the cell should still apply.
    //
    {
        // Since table is always horizontal, we get physical width.
        const CUnitValue & cuvWidth = pCFI->_pff->GetWidth();
        if (    pCFI->_fNoBreak
            &&  !cuvWidth.IsNull()
            &&  !cuvWidth.IsPercent())
        {
            pCFI->_fNoBreak = FALSE;
        }
    }

    hr = ApplyInnerOuterFormats(pCFI);
    if (hr)
        goto Error;

    if (   Tag() == ETAG_CAPTION
        && (pCFI->_pff->_bPositionType != stylePositionNotSet
        ||  pCFI->_pff->_fPositioned))
    {
        // don't support positioning on captions
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bPositionType = stylePositionNotSet;
        pCFI->_ff()._fPositioned = FALSE;
        pCFI->UnprepareForDebug();
    }

    {
        CMarkup * pMarkup = GetMarkup();
        if ((_fHasFilterSitePtr || pCFI->_fHasFilters) && !pMarkup->IsPrintMedia())
        {
            ComputeFilterFormat(pCFI);
        }
    }

    if(eExtraValues == ComputeFormatsType_Normal)
    {
        hr = THR(pNodeTarget->CacheNewFormats(pCFI));
        pCFI->_cstrFilters.Free();  // Arrggh!!! NOTE (michaelw)  This should really happen 
                                    // somewhere else (when you know where, put it there)
                                    // Fix CElement::ComputeFormats also
        if (hr)
            goto Error;

        // TODO (michaelw) Why do this after caching the new format?
        //                   Why not do it before and not be affected
        //                   by some strange new error return
        //

        // Update expressions in the recalc engine
        //
        // If we had expressions or have expressions then we need to tell the recalc engine
        // 
        if (pCFI->_pff->_fHasExpressions)
        {
            Doc()->AddExpressionTask(this);
            pCFI->NoStealing();
        }
    }

Cleanup:

    // Set the _fBlockNess cache bit on the node to save a little time later.
    // Need to do this here because we don't call super.
    pNodeTarget->_fBlockNess = TRUE;

    WHEN_DBG( pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);

Error:
    pCFI->Cleanup();
    goto Cleanup;

StealFormat:
    pNodeInherit = pCellNeighbor->GetFirstBranch();
    Assert(   (pNodeTarget->_iPF == -1) 
           || (pNodeTarget->_iCF == -1)
           || (pNodeTarget->_iFF == -1));

    pNodeTarget->_iPF = pNodeInherit->_iPF;
    if (pNodeTarget->_iPF >= 0)
        pts->_pParaFormatCache->AddRefData( pNodeTarget->_iPF );

    pNodeTarget->_iCF = pNodeInherit->_iCF;
    if (pNodeTarget->_iCF >= 0)
        pts->_pCharFormatCache->AddRefData( pNodeTarget->_iCF );

    pNodeTarget->_iFF = pNodeInherit->_iFF;
    if (pNodeTarget->_iFF >= 0)
        pts->_pFancyFormatCache->AddRefData( pNodeTarget->_iFF );

    MtAdd(Mt(CharFormatSteal), 1, 0);
    MtAdd(Mt(ParaFormatSteal), 1, 0);
    MtAdd(Mt(FancyFormatSteal), 1, 0);
    _fInheritedWidth = pCellNeighbor->_fInheritedWidth;

    goto Cleanup;

TableStructureViolated:

    WHEN_DBG( if (pTableLayout) pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )
    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);
    return super::ComputeFormatsVirtual(pCFI, pNodeTarget);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableCell::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableCell::Notify(CNotification *pNF)
{
    HRESULT hr = S_OK;

    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        hr = EnterTree();
        break;
    case NTYPE_ELEMENT_EXITTREE_1:
        if (Tag() == ETAG_TC && !(pNF->DataAsDWORD() & EXITTREE_DESTROY) )
        {
            CTable * pTable = Table();
            CTableLayout * pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

            if (pTableLayout && pTableLayout->IsRepeating())
            {
                Assert(pTable->IsDatabound());
                int             ic, cC;
                CTableCaption  *pCaption;
                CTableCaption **ppCaption;

                for (cC = pTableLayout->_aryCaptions.Size(), ic = 0, ppCaption = pTableLayout->_aryCaptions;
                     cC > 0;
                     cC--, ppCaption++, ic++)
                {
                    pCaption = *ppCaption;
                    if (pCaption == this)
                    {
                        pTableLayout->DeleteCaption(ic);
                        break;
                    }
                }
            }
        }
        break;
    }

    return;
}




#define _cxx_
#include "caption.hdl"


const CElement::CLASSDESC CTableCaption::s_classdesc =
{
    {
        &CLSID_HTMLTableCaption,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_TEXTSITE    |
        ELEMENTDESC_TABLECELL   |
        ELEMENTDESC_NOBKGRDRECALC,      // _dwFlags
        &IID_IHTMLTableCaption,         // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableCaption,  // _pfnTearOff
    &s_AccelsTCellRun                   // _pAccelsRun
};


HRESULT
CTableCaption::CreateElement(CHtmTag *pht,
                  CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CTableCaption(pht->GetTag(), pDoc);
    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}



// copy constructor
CHeightUnitValue::CHeightUnitValue (const CUnitValue &uv)
: CNiceUnitValue(uv)
{
}
// copy constructor
CHeightUnitValue::CHeightUnitValue (const CHeightUnitValue &uv)
: CNiceUnitValue(uv)
{
}

// copy constructor
CWidthUnitValue::CWidthUnitValue (const CUnitValue &uv)
: CNiceUnitValue(uv)
{
}

// copy constructor
CWidthUnitValue::CWidthUnitValue (const CWidthUnitValue &uv)
: CNiceUnitValue(uv)
{
}

// copy constructor
CNiceUnitValue::CNiceUnitValue (const CUnitValue &uv)
: CUnitValue(uv)
{
}

int CTableCell::RowIndex() const
{
    Assert( Tag() != ETAG_CAPTION && Tag() != ETAG_TC );
    CTableRow *pRow = Row();
    return (pRow) ? pRow->_iRow : -1;
}

// Returns true if currect cell is in given range of cells
BOOL
CTableCell::IsInRange(RECT *pRect)
{
    if (IsDisplayNone() || GetFirstBranch()->GetFancyFormat()->_bPositionType == stylePositionabsolute)
        return FALSE;

    int nRow = RowIndex();
    int nCol = ColIndex();

    if(nRow < pRect->top  || nRow > pRect->bottom ||
            nCol < pRect->left || nCol > pRect->right)
        return FALSE;

    return TRUE;
}


BOOL
CTableCell::IsNoPositionedElementsUnder()
{
    CTreeNode *  pNodeSelf = GetFirstBranch();
    CTreePos  *  ptp = pNodeSelf->GetBeginPos();
    for (;;)
    {
        ptp = ptp->NextTreePos();
        Assert (ptp);
        switch( ptp->Type() )
        {
        case CTreePos::NodeEnd:
            if (ptp->Branch() == pNodeSelf && ptp->IsEdgeScope())
                return TRUE;
        case CTreePos::NodeBeg:
            if (ptp->Branch()->GetFancyFormat()->_fPositioned)
                goto Cleanup;
        }
    }
Cleanup:
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\marquee.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inputtxt.cxx
//
//  Contents:   InputTxt element class, etc..
//
//  Classes:    CInputTxtBase, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_MARQLYT_HXX_
#define X_MARQLYT_HXX_
#include "marqlyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#define _cxx_
#include "marquee.hdl"

DeclareTag(tagMarquee,          "Marquee", "Trace Marquee Ticks")
MtDefine(CMarquee, Elements, "CMarquee")
MtDefine(CMarqueeTask, CMarquee, "CMarqueeTask")

//+-------------------------------------------------------------------
// CMarqueeTask methods
//---------------------------------------------------------------------

CMarqueeTask::CMarqueeTask(CMarquee *pMarquee)
{
    _pMarquee = pMarquee;
}

void
CMarqueeTask::OnRun(DWORD dwTimeout)
{
    _pMarquee->OnRun(dwTimeout);
}



#ifndef NO_PROPERTY_PAGE
const CLSID * const CMarquee::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

const CElement::CLASSDESC CMarquee::s_classdesc =
{
    {
        &CLSID_HTMLMarqueeElement,      // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_TEXTSITE       |
        ELEMENTDESC_CANSCROLL      |
        ELEMENTDESC_ANCHOROUT      |
        ELEMENTDESC_NOBKGRDRECALC,      // _dwFlags
        &IID_IHTMLMarqueeElement,       // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLMarqueeElement,  // _pfnTearOff
    &CTxtSite::s_AccelsTxtSiteRun       // _pAccelsRun
};

HRESULT
CMarquee::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CMarquee(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


HRESULT
CMarquee::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;

    Doc()->_fBroadcastInteraction = TRUE;

    hr = THR(super::Init2(pContext));

    _pMarqueeTask  = NULL;

    if (!OK(hr))
        goto Cleanup;

    Layout()->_fContentsAffectSize = TRUE;

    // These we do not set inside InitScrollParam
    _fStop = FALSE;
    _fDone = FALSE;
    _fFirstRun = TRUE;
    _fIsVisible = TRUE;

    _direction = GetAAdirection();
    InitScrollParams();

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}

void
CMarquee::InitScrollParams()
{
    _lLoop = GetAAloop();

    _fSwitch = GetAAbehavior() == htmlMarqueeBehavioralternate;
    _fSlide = GetAAbehavior() == htmlMarqueeBehaviorslide;
    _lScrollBy = GetAAscrollAmount();
    _lScrollDelay = GetAAscrollDelay();
    _fTrueSpeed = GetAAtrueSpeed();

    if (_lScrollDelay < 60 && !_fTrueSpeed)
    {
        _lScrollDelay = 60;
    }

    Assert(_lScrollDelay > 0);

    if (_lLoop > 0 &&
        !_fSwitch &&
        !_fSlide &&
        (_direction == htmlMarqueeDirectionright ||
         _direction == htmlMarqueeDirectiondown))
    {
        // THe way we do scrolling we're going to lose
        // one loop in the right and down case
        _lLoop++;
    }

    // In the new layout world wordwrap is set when the marquee is
    // inserted in the tree.

    // We were asked to allow looping on slide behavior. The default loop value though is -1
    // which usually means loop for ever. But this is not good for Slide so we have to
    // make a special case here
    if (_fSlide && _lLoop < 0)
    {
        _lLoop = 1;
    }
}



void
CMarquee::OnRun(DWORD dwTimeout)
{
    long    lScrollDelta;
    long    lSwitchPoint;
    long    *plPos;
    long    *plPos2;       
    long    lScroll;
    long    lText;
    long    lMargin;
    long    lMargin2;

    long    lPosStart;
    long    lPosEnd;

    BOOL    fTooBig;

    BOOL    fShouldSwitch;
    BOOL    fPassedEdge;

    BOOL    fLeftOrUp       = TRUE;
    BOOL    fLeftOrRight    = TRUE;
    BOOL    fClearFirstRun  = TRUE;
    htmlMarqueeDirection    dirOpposite = _direction;
    htmlMarqueeBehavior     behavior;

    #if DBG==1
    __int64 t1, t2, tfrq;
    QueryPerformanceCounter((LARGE_INTEGER *)&t1);
    QueryPerformanceCounter((LARGE_INTEGER *)&t2);
    QueryPerformanceFrequency((LARGE_INTEGER *)&tfrq);
    #endif


    // we should stop the Task under these conditions
    if (_fDone || _fStop || _lLoop == 0 || IsEditable(TRUE))
        return;
    if (0 == _dwOldTimeout)
    {
        _dwOldTimeout = dwTimeout;
    }


    DWORD dwTimeDelta = dwTimeout - _dwOldTimeout;


    if (dwTimeout > _dwOldTimeout)
    {
        lScrollDelta = MulDivQuick(_lScrollBy, dwTimeDelta, _lScrollDelay); //GetAAscrollDelay());
    }
    else
    {
        // overflow case
        lScrollDelta = _lScrollBy;
    }

    TraceTag((tagMarquee, "OnRun: trueSpeed=%ld Delay %ld last %ld tks ago Amount %ld Delta %ld", _fTrueSpeed ? 1 : 0,_lScrollDelay, dwTimeout - _dwOldTimeout, _lScrollBy, lScrollDelta));

    _dwOldTimeout = dwTimeout;

    if (_fFirstRun)
    {
        Fire_onstart();
    }

    switch (_direction)
    {
    case    htmlMarqueeDirectionleft:
            fLeftOrUp       = TRUE;
            dirOpposite     = htmlMarqueeDirectionright;
            break;
    case    htmlMarqueeDirectionright:
            fLeftOrUp       = FALSE;
            dirOpposite     = htmlMarqueeDirectionleft;
            break;
    case    htmlMarqueeDirectionup:
            fLeftOrRight    = FALSE;
            dirOpposite     = htmlMarqueeDirectiondown;
            break;
    case    htmlMarqueeDirectiondown:
            fLeftOrUp       = FALSE;
            fLeftOrRight    = FALSE;
            dirOpposite     = htmlMarqueeDirectionup;
            break;
    default:
            AssertSz(0, "Wrong htmlMarqueeDirection enum value");
    }


    plPos       = fLeftOrRight ? &_lXPos : &_lYPos;
    plPos2      = fLeftOrRight ? &_lYPos : &_lXPos;
    lScroll     = fLeftOrRight ? _sizeScroll.cx : _sizeScroll.cy;

    if (!lScroll)
        goto Cleanup;

    lMargin     = fLeftOrRight ? _lXMargin : _lYMargin;
    lMargin2    = fLeftOrRight ? _lYMargin : _lXMargin;
    lText       = lScroll - 2*lMargin;

    lPosStart   = fLeftOrUp ? 0 : lScroll - lMargin;
    lPosEnd     = fLeftOrUp ? lScroll - lMargin : 0;

    if (fLeftOrRight)
    {
        fTooBig = fLeftOrUp ? _fToBigForSwitch : !_fToBigForSwitch;
    }
    else
    {
        fTooBig = !fLeftOrUp;
    }

    behavior = GetAAbehavior();
    switch (behavior)
    {
    case    htmlMarqueeBehaviorslide:
            if (_fFirstRun)
            {
                *plPos = lPosStart;
            }
    case    htmlMarqueeBehavioralternate:
            lSwitchPoint = fTooBig ?  lText : lMargin;
            if (behavior == htmlMarqueeBehavioralternate && _fFirstRun)
            {
                *plPos = fTooBig ? lMargin : lText;
            }
            else
            {
                fShouldSwitch = fLeftOrUp ? (*plPos >= lSwitchPoint) : (*plPos <= lSwitchPoint);
                if (fShouldSwitch)
                {
                    // Count this scroll, if we have an active loop count
                    if (_lLoop > 0)
                    {
                        _lLoop--;
                        if (_lLoop == 0)
                        {
                            _fDone = TRUE;
                            if (!Fire_onfinish())
                            {
                                _lLoop=-1; // On finish was cancelled so we continue for ever.
                            }
                            goto Cleanup;
                        }
                    }

                    if (behavior == htmlMarqueeBehaviorslide)
                    {
                        *plPos = 0;
                        Fire_onstart();
                    }
                    else    // alternate
                    {
                        *plPos = lSwitchPoint ;
                        Fire_onbounce();
                        _direction = dirOpposite;
                        goto Cleanup;
                    }
                }
                else
                {
                    *plPos += fLeftOrUp ? lScrollDelta : -lScrollDelta;
                    fPassedEdge = fLeftOrUp ? *plPos > lSwitchPoint : *plPos < lSwitchPoint;
                    if (fPassedEdge)
                    {   
                        // Dont baunce behind the edge
                        *plPos = lSwitchPoint;
                    }
                }
            }
            break;
    default:
            {
                BOOL    fGoToofar = fLeftOrUp ? (*plPos >= lPosEnd) : (*plPos <= lPosEnd);
                if (fGoToofar)
                {
                    *plPos = lPosStart;
                    Fire_onstart();
                    // Count this scroll, if we have an active loop count
                    if (_lLoop > 0)
                    {
                        _lLoop--;
                        if (_lLoop == 0)
                        {
                            if (!Fire_onfinish())
                            {
                                _lLoop=-1; // On finish was cancelled so we continue for ever.
                            }
                            goto Cleanup;
                        }
                    }
                }
                *plPos += fLeftOrUp ? lScrollDelta : -lScrollDelta;
            }
    }

    *plPos2 = lMargin2;

    if (Doc()->State() >= OS_INPLACE)
    {
        // clear _fFirstRun before scrolling, since scrolling can call out to
        // external code and cause (this) to be deleted [IE6 36161]
        _fFirstRun = FALSE;
        fClearFirstRun = FALSE;
        Layout()->ScrollTo(_lXPos, _lYPos);
    }

#if DBG==1
    QueryPerformanceCounter((LARGE_INTEGER *)&t2);
    TraceTag((tagMarquee, "OnRun: ScrollView took %ld ticks", GetTickCount() - dwTimeout));
    TraceTag((tagMarquee, "ScrollView done in %ld", (LONG)(((t2 - t1) * 1000000) / tfrq)));
#endif

Cleanup:
    if (fClearFirstRun)
        _fFirstRun = FALSE;

    return;
}


#ifdef NEVER
TXTBACKSTYLE
CMarquee::GetBackStyle() const
{
    return ((CMarquee *) this)->GetCascadedbackgroundColor().IsDefined() ? TXTBACK_OPAQUE : TXTBACK_TRANSPARENT;
}
#endif


HRESULT BUGCALL
CMarquee::stop()
{
    _fStop = TRUE;
    // this will cause the OnRun to start from where it stopped
    _dwOldTimeout = 0;
    return S_OK;
}

HRESULT BUGCALL
CMarquee::start()
{
    _fStop = FALSE;
    return S_OK;
}

void
CMarquee::SetMarqueeTask(void)
{
    CDoc * pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();

    if (    pMarkup
        &&  !pMarkup->IsPrintMedia()
        &&  !IsDisplayNone()
        &&  pDoc->_fEnableInteraction
        &&  IsConnectedToPrimaryWindow())
    {
        if (_pMarqueeTask == NULL)
        {
            _pMarqueeTask = new CMarqueeTask(this);
            if (_pMarqueeTask)
            {
                _pMarqueeTask->SetInterval(_lScrollDelay);
            }
        }
    }
    else
    {
        if (_pMarqueeTask)
        {
            _pMarqueeTask->Terminate();
            _pMarqueeTask->Release();
            _pMarqueeTask = NULL;
        }
    }

}


void
CMarquee::Passivate()
{
    SetMarqueeTask();
    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CMarquee::Notify
//
//  Synopsis:   Listen for inplace (de)activation so we can turn on/off
//              Scrolling
//
//-------------------------------------------------------------------------

void
CMarquee::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_EXITTREE_1:
        if (_pMarqueeTask)
        {
            _pMarqueeTask->Terminate();
            _pMarqueeTask->Release();
            _pMarqueeTask = NULL;
        }
        break;
    case NTYPE_ELEMENT_ENTERTREE:
    case NTYPE_ELEMENT_ENTERVIEW_1:
    case NTYPE_ENABLE_INTERACTION_1:
    case NTYPE_DOC_STATE_CHANGE_1:
        SetMarqueeTask();
        break;
    }
}


#ifndef NO_DATABINDING
class CDBindMethodsMarquee : public CDBindMethodsText
{
    typedef CDBindMethodsText super;
public:
    CDBindMethodsMarquee() : super(DBIND_ONEWAY|DBIND_HTMLOK) {}
    ~CDBindMethodsMarquee()     {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;
};

static const CDBindMethodsMarquee DBindMethodsMarquee;

const CDBindMethods *
CMarquee::GetDBindMethods()
{
    return &DBindMethodsMarquee;
}

//+---------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound marquee.
//
//  Arguments:
//            [id]      - ID of binding point.  For the select, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer. must be BSTR.
//
//----------------------------------------------------------------------------

HRESULT
CDBindMethodsMarquee::BoundValueToElement(CElement *pElem,
                                          LONG id,
                                          BOOL fHTML,
                                          LPVOID pvData) const
{
    HRESULT hr;

    hr = THR(super::BoundValueToElement(pElem, id, fHTML, pvData));
    if (hr)
        goto Cleanup;

    pElem->ResizeElement();

Cleanup:
    RRETURN(hr);
}
#endif // ndef NO_DATABINDING


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CMarquee::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {

    case DISPID_CMarquee_direction:
        {
            _direction = GetAAdirection();

            // We need a full recalc since margins are direction dependent
            // and we need to update the display to have the correct scroll
            // params
            ResizeElement();
            break;
        } 
    case DISPID_CMarquee_behavior:
    case DISPID_CMarquee_loop:
        {
            _fStop = FALSE;
            _fDone = FALSE;
            _fFirstRun = TRUE;
            // Fall through
        }
    case DISPID_CMarquee_scrollDelay:
    case DISPID_CMarquee_scrollAmount:
    case DISPID_CMarquee_width:
    case DISPID_CMarquee_height:
            // InitScrollParams will be called later
            break;
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    if (OK(hr))
    {
        InitScrollParams();
        SetMarqueeTask();
    }

    RRETURN(hr);    
}


HRESULT
CMarquee::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    // we inherit everything
    // In order to avoid inheriting the code below should be compiled

    // override parent's format to default on all formats, so we get only styles
//    pCFI->_cf.InitDefault(Doc()->_pOptionSettings, FALSE);
//    pCFI->_pf.InitDefault();
//    pCFI->_ff.InitDefault();

    pCFI->_bCtrlBlockAlign = pCFI->_bBlockAlign;
    pCFI->_bBlockAlign     = htmlBlockAlignNotSet;

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->PrepareCharFormat();
    pCFI->_cf()._bCursorIdx = styleCursorAuto;
    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));

    pCFI->PrepareFancyFormat();
    if (!pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetOverflowX(styleOverflowHidden);
        pCFI->_ff().SetOverflowY(styleOverflowVisible);
    }
    else
    {
        pCFI->_ff().SetOverflowY(styleOverflowHidden);
        pCFI->_ff().SetOverflowX(styleOverflowVisible);
    }
    pCFI->UnprepareForDebug();

    // Default to percent width (element's coordinate system).
    pCFI->PrepareFancyFormat();
    if (pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetHeightPercent(pCFI->_ff().IsHeightPercent() | pCFI->_ff().GetHeight().IsNullOrEnum());
    }
    else
    {
        pCFI->_ff().SetWidthPercent(pCFI->_ff().IsWidthPercent() | pCFI->_ff().GetWidth().IsNullOrEnum());
    }
    pCFI->UnprepareForDebug();
    // TODO: should consider doing this with DISPLAY_CHANGE/VISIBILITY_CHANGE
    pCFI->PrepareCharFormat();
    if (!pCFI->_cf()._fVisibilityHidden && !pCFI->_cf()._fDisplayNone)
    {
        if (!_fIsVisible && GetMarkup() && !GetMarkup()->IsPrintMedia())
        {
            _fIsVisible = TRUE;
            if (_pMarqueeTask == NULL)
            {
                _pMarqueeTask = new CMarqueeTask(this);
                if (_pMarqueeTask)
                {
                    _pMarqueeTask->SetInterval(_lScrollDelay);
                }
            }
        }
    }
    else
    {
        _fIsVisible = FALSE;
    }
    pCFI->UnprepareForDebug();

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\tcalc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tcalc.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include <_disp.h>
#endif


//+-------------------------------------------------------------------------
//
//  Method:     AdjustForCell
//
//  Synopsis:   Promote the cell width into the column (if certain
//              criteria are met)
//
//  Arguments:  pTable  - Table pointer
//              iPixels - user specified pixel width of the cell (0 if none)
//              puvWidth- user specifed Unit Value
//                             BOOL                   fUnsizedColumn,
//                             BOOL                   fFirstRow,
//                             CCalcInfo *            pci,
//                             int                    xMin,
//                             int                    xMax
//
//--------------------------------------------------------------------------

void
CTableColCalc::AdjustForCell(CTableLayout *         pTableLayout,
                             int                    iPixels,
                             const CWidthUnitValue *puvWidth,
                             BOOL                   fUnsizedColumn,
                             BOOL                   fFirstRow,
                             CCalcInfo *            pci,
                             int                    xMin,
                             int                    xMax)
{

    // cache width attribute in column (if appropriate)
    Assert (pTableLayout);

    if ((fUnsizedColumn || fFirstRow) && puvWidth->IsSpecified())
    {
        // set column unit width if smaller then the cell width
        if (!IsWidthSpecified())
        {
            if(!_fDontSetWidthFromCell)
            {
                // NETSCAPE: DON'T propagate the PIXEL width of the cell to the column if there are more then
                // 1 cell in that column
                if (puvWidth->IsSpecifiedInPixel())
                {
                    if (iPixels)    // bugfix: if width is set through style width:0px, then it will be ignored.
                    {
                        _uvWidth = *puvWidth;
                        SetPixelWidth(pci, iPixels);
                        _fWidthFromCell = TRUE;
                    }
                }
                else
                {
                    _uvWidth = *puvWidth;
                    _fWidthFromCell = TRUE;
                }
            }
        }
        else if (puvWidth->IsSpecifiedInPercent())
        {
            if (IsWidthSpecifiedInPercent())
            {
                // set it if smaller
                if (GetWidthUnitValue() < puvWidth->GetUnitValue())
                {
                    _uvWidth = *puvWidth;
                }
            }
            else
            {
                // percent has precedence over normal width
                _uvWidth = *puvWidth;
            }
        }
        else if (!IsWidthSpecifiedInPercent())
        {
            // set if smaller
            if (GetPixelWidth(pci, pTableLayout->ElementOwner()) < iPixels)
            {
                _uvWidth = *puvWidth;
                SetPixelWidth(pci, iPixels);
            }
        }
    }

    // adjust column width

    if (fUnsizedColumn || fFirstRow || pTableLayout->_fAlwaysMinMaxCells)
    {
        if (_xMax < xMax)
        {
            _xMax = xMax;

            //NETSCAPE: if the new MAX is greater and the column width was set from the cell,
            //          don't propagate the user's width to the column.
            if (_fWidthFromCell && IsWidthSpecifiedInPixel() && !puvWidth->IsSpecified())
            {
                // reset the column uvWidth
                _fDontSetWidthFromCell = TRUE;
                ResetWidth();
            }
            if (!fUnsizedColumn && !puvWidth->IsSpecifiedInPercent())
            {
                _xMin   =
                _xWidth = _xMax;
            }
        }
        if (_xMin < xMin)
        {
            _xMin = xMin;
        }

        // this will adjust col max to user setting
        AdjustMaxToUserWidth(pci, pTableLayout);

        // use col max
        // xMax = _xMax;
    }

    _fAdjustedForCell = TRUE;
    return;
}


//+-------------------------------------------------------------------------
//
//  Method:     AdjustForCol
//
//  Synopsis:   Promote the cell width into the column (if certain
//              criteria are met)
//
//  Arguments:  pTable  - Table pointer
//              iPixels - user specified pixel width of the cell (0 if none)
//              pci     - CalcInfo,
//
//--------------------------------------------------------------------------

void
CTableColCalc::AdjustForCol(const CWidthUnitValue *puvWidth,
                            int                    iColWidth,
                            CCalcInfo             *pci,
                            int                    cColumns)
{
    _uvWidth = *puvWidth;

    if (IsWidthSpecifiedInPixel())
    {
        SetPixelWidth(pci, iColWidth);
        _xMin = _xMax = _xWidth = iColWidth;
    }
    else
    {
        if (cColumns != 1)
        {
            int ip = GetPercentWidth();
            SetPercentWidth(ip/cColumns);
        }
        _xMin = 1;
        _xMax = pci->_sizeParent.cx;
        _xWidth = iColWidth;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\tdraw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tdraw.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include <othrguid.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

MtDefine(CTableDrawSiteList_aryElements_pv, Locals, "CTable::DrawSiteList aryElements::_pv")
MtDefine(CTable_pBorderInfoCellDefault, CTable, "CTable::_pBorderInfoCellDefault")

ExternTag(tagTableRecalc);

extern const WORD s_awEdgesFromTableFrame[];
const WORD s_awEdgesFromTableFrame[htmlFrameborder+1] =
{
    BF_RECT,        // not set case, use all edges
    0,
    BF_TOP,
    BF_BOTTOM,
    BF_TOP | BF_BOTTOM,
    BF_LEFT,
    BF_RIGHT,
    BF_LEFT | BF_RIGHT,
    BF_RECT,
    BF_RECT
};


extern const WORD s_awEdgesFromTableRules[];
const WORD s_awEdgesFromTableRules[htmlRulesall+1] =
{
    BF_RECT,    // not set case, use all edges
    0,
    0,
    BF_TOP | BF_BOTTOM,
    BF_LEFT | BF_RIGHT,
    BF_RECT,
};


//+---------------------------------------------------------------------------
//
//  Member:     CTableCell::GetBorderInfo
//
//  Synopsis:   fill out border information
//
//----------------------------------------------------------------------------

DWORD
CTableCell::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    // (t-michda) I added four default parameters so a format context could be included.
    return Layout( pdci->GetLayoutContext() )->GetCellBorderInfo(pdci, pborderinfo, fAll, fAllPhysical, 0, NULL, NULL, NULL FCCOMMA FCPARAM);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetBorderInfo
//
//  Synopsis:   fill out border information
//
//----------------------------------------------------------------------------

DWORD
CTable::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    return TableLayoutCache()->GetTableBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\tdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tdata.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include <saver.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include <othrguid.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include <detail.hxx>
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include <rowbind.hxx>
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

ExternTag(tagTableRecalc);

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

class CDBindMethodsTable : public CDBindMethods
{
    typedef CDBindMethods super;

public:
    CDBindMethodsTable()    {}
    ~CDBindMethodsTable()   {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                         BOOL fHTML, LPVOID pvData) const;

    // Notification that data is ready (or not ready)
    virtual void    OnDataReady ( CElement *pElem, BOOL fReady ) const;

    // Notification that the source instance has changed
    virtual HRESULT InstanceChanged(CElement *pElem, CInstance *pSrcInstance) const;

protected:
    virtual DBIND_KIND DBindKindImpl(CElement *pElem,
                                     LONG id,
                                     DBINFO *pdbi) const;
    virtual BOOL    IsReadyImpl(CElement *pElem) const;
};

static const CDBindMethodsTable DBindMethodsTable;

const CDBindMethods *
CTable::GetDBindMethods()
{
    return &DBindMethodsTable;
}

//+----------------------------------------------------------------------------
//
//  Function: DBindKindImpl, CDBindMethods
//
//  Synopsis: Indicate whether or not element is or can be databound, and
//            optionally return additional info about binding -- a DISPID
//            or other ID used for transfer, and the desired data type
//            to be used for transfer.
//  Arguments:
//            [id]    - bound id
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL
//
//  Returns:  Binding status: one of
//              DBIND_NONE
//              DBIND_SINGLEVALUE
//              DBIND_ICURSOR
//              DBIND_IROWSET
//              DBIND_TABLE
//            For Table, returns DBIND_NONE or DBIND_TABLE.
//
//-----------------------------------------------------------------------------
DBIND_KIND
CDBindMethodsTable::DBindKindImpl(CElement *pElem, LONG id, DBINFO *pdbi) const
{
    DBIND_KIND dbk = DBIND_NONE;    // pdbi, if any, initialized by wrapper

    Assert(pElem->Tag() == ETAG_TABLE);

    if (id == ID_DBIND_DEFAULT)
    {
        dbk = DBIND_TABLE;
        if (pdbi)
        {
            pdbi->_vt = DBTYPE_HCHAPTER;
            pdbi->_dwTransfer = DBIND_NOTIFYONLY | DBIND_ONEWAY;
        }
    }

    return dbk;
}

//+----------------------------------------------------------------------------
//
//  Function: IsReadyImpl, CDBindMethods
//
//  Synopsis: Indicate whether or element is ready to be bound.
//
//  Arguments:  pEleme  table element being queried
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethodsTable::IsReadyImpl(CElement *pElem) const
{
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function: InstanceChanged, CDBindMethods
//
//  Synopsis: Notification that the source instance has a new HROW.
//
//  Arguments:  pElem           table element being queried
//              pSrcInstance    its source instance (holds the HROW)
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsTable::InstanceChanged(CElement *pElem, CInstance *pSrcInstance) const
{
    HRESULT hr;
    CTable *pTable = DYNCAST(CTable, pElem);

    // We're only supposed to get here for inner tables in a hierarchy
    Assert(!FormsIsEmptyString(pTable->GetAAdataFld()));

    // ReplaceProvider(NULL) just queues up a ReBind request with the dbtask
    hr = THR(pTable->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->ReplaceProvider(NULL));

    RRETURN(hr);
}

#endif // ndef NO_DATABINDING

//+------------------------------------------------------------------------
//
//  Member:     CTable::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CTable::Save(CStreamWriteBuff *pStmWrBuff, BOOL fEnd)
{
    HRESULT hr;

    if (!fEnd)
    {
        // remember whether stream is building the repeating template
        _fBuildingTemplate = !!pStmWrBuff->TestFlag(WBF_DATABIND_MODE);

        // turn off "building-template" mode;  this allows nested tables to inject
        // their header/footer/caption into the template
        pStmWrBuff->ClearFlags(WBF_DATABIND_MODE);
    }

    hr = THR(super::Save(pStmWrBuff, fEnd));

    if (fEnd)
    {
        // restore the original value of "building-template" mode
        if (_fBuildingTemplate)
            pStmWrBuff->SetFlags(WBF_DATABIND_MODE);
        else
            pStmWrBuff->ClearFlags(WBF_DATABIND_MODE);
    }

    RRETURN(hr);
}


#ifndef NO_DATABINDING
//+---------------------------------------------------------------------------
//
//  Member:     OnDataReady
//
//  Synopsis:   Notification that datasource is ready to provide data
//
//  Retruns:    nothing
//
//----------------------------------------------------------------------------

void
CDBindMethodsTable::OnDataReady(CElement *pElem, BOOL fReady) const
{
    CTable *pTable = DYNCAST(CTable, pElem);
    CTableLayout *pTableLayout = pTable->TableLayoutCache();

    Assert(pTableLayout);
    
    if (fReady)
    {
        IGNORE_HR(pTableLayout->Populate());
    }
    else
    {
        CDetailGenerator *pDG = pTableLayout->_pDetailGenerator;

        if (pDG)
        {
            if (pTable->_fEnableDatabinding)
            {
                IGNORE_HR(pTableLayout->DeleteGeneratedRows());
                IGNORE_HR(pDG->RestoreTemplate());
            }

            pTableLayout->_pDetailGenerator = NULL;
            pTableLayout->_fRefresh = FALSE;
            pTableLayout->ResetMinMax();
            
            pDG->Detach();
            delete pDG;
        }
    }
}

HRESULT
CDBindMethodsTable::BoundValueToElement(CElement *, LONG, BOOL, LPVOID) const
{
    Assert(FALSE);
    return E_UNEXPECTED;
}

HRESULT
CDBindMethodsTable::BoundValueFromElement(CElement *, LONG, BOOL, LPVOID) const
{
    Assert(FALSE);
    return E_UNEXPECTED;
}
#endif // ndef NO_DATABINDING

//+---------------------------------------------------------------------------
//
//  Member:     Refresh (regenerate)
//
//  Synopsis:   Populate the table with repeated rows when setting the new
//              RepeatSrc property.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::refresh()
{
    HRESULT hr = S_OK;

#ifndef NO_DATABINDING
    // Table delegates refresh to table layout.
    hr = TableLayoutCache()->refresh();
#endif // ndef NO_DATABINDING
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     nextPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the next pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::nextPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->nextPage();
#endif
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     previousPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the previous pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::previousPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->previousPage();
#endif
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     firstPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the first pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::firstPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->firstPage();
#endif
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     lastPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the last pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::lastPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->lastPage();
#endif
    RRETURN(SetErrorInfo(hr));
}



//+------------------------------------------------------------------------
//
//  Member:     put_dataPageSize, IHTMLTable
//
//  Synopsis:   change the page size
//
//  Arguments:  v       new page size
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTable::put_dataPageSize(long v)
{
    HRESULT hr;
    CTableLayout *pTableLayout;

    // sanitize
    if (v < 0)
        v = 0;
    
    // set the new page size
    hr = s_propdescCTabledataPageSize.b.SetNumberProperty(v, this, CVOID_CAST(GetAttrArray()));

    // tell the repetition agent
    pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (!hr && pTableLayout->_pDetailGenerator)
        IGNORE_HR(pTableLayout->_pDetailGenerator->SetPageSize(v));

    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     get_dataPageSize, IHTMLTable
//
//  Synopsis:   return the page size
//
//  Arguments:  v       where to store page size
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTable::get_dataPageSize(long * p)
{
        return s_propdescCTabledataPageSize.b.GetNumberProperty(p, this, CVOID_CAST(GetAttrArray()));
}

//+------------------------------------------------------------------------
//
//  Member:     FindRepeatingContext, public
//
//  Synopsis:   find the enclosing repeated element with the given dataSrc
//              and dataFld attributes
//
//  Arguments:  strDataSrc  look for an element with this dataSrc attribute
//              strDataFld     ... and this dataFld attribute
//              ppElement   enclosing element
//              ppInstance  instance of repetition that contains me
//
//  Returns:    S_OK        found it
//              S_FALSE     found a syntactically enclosing element, but it's not
//                          repeating, *ppInstance will be NULL
//              E_FAIL      couldn't find an enclosing element

HRESULT
CTable::GetInstanceForRow(CTableRow *pRow, CRecordInstance **ppInstance)
{
    HRESULT hr;
    Assert(pRow);
    
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->IsRepeating())
    {
        CDetailGenerator *pDG = pTableLayout->_pDetailGenerator;
        CRecordInstance *pRecInstance = pDG->GetInstanceForRow(pRow->_iRow);

        *ppInstance = pRecInstance;
        hr = (pRecInstance)? S_OK : E_FAIL;
    }
    else
#endif
    {
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::IsRepeating
//
//----------------------------------------------------------------------------

BOOL
CTable::IsRepeating()
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->IsRepeating() : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetDataSrc
//
//----------------------------------------------------------------------------

LPCTSTR
CTable::GetDataSrc()
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->GetDataSrc() : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetDataFld
//
//----------------------------------------------------------------------------

LPCTSTR
CTable::GetDataFld()
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->GetDataFld() : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::IsFieldKnown
//
//----------------------------------------------------------------------------

BOOL
CTable::IsFieldKnown(LPCTSTR strField)
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->IsFieldKnown(strField) : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::AddDataboundElement
//
//----------------------------------------------------------------------------

HRESULT
CTable::AddDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining, LPCTSTR strField)
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    AssertSz(pDG, "Can't add databound element to a non-repeating table");
    return pDG->AddDataboundElement(pElement, id, pRowContaining, strField);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetProvider
//
//----------------------------------------------------------------------------

CDataSourceProvider *
CTable::GetProvider()
{
    return GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->GetProvider();
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CTable::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateTable(_readyStateTable);
}

//+------------------------------------------------------------------------
//
//  Member:     CTable::SetReadyStateTable
//
//  Synopsis:   Use this to set the ready state;
//              it fires onreadystate change if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CTable::SetReadyStateTable(long readyStateTable)
{
    long readyState;

    _readyStateTable = readyStateTable;

    readyState = min ((long)_readyStateTable, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        if (_readyStateTable == READYSTATE_INTERACTIVE)
        {
            // now, we are about to populate the table, we can use incremental recalc
            Assert(ShouldHaveLayout());
            TableLayoutCache()->ResetIncrementalRecalc();
        }

        // if the readystate is changing because we're leaving the tree
        // (and hence detaching the detail generator), don't fire any
        // events.  It's too late, anyway.  (IE6 bug 25897)
        if (!_fExittreePending)
        {
            Fire_onreadystatechange();
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTable:get_readyState
//
//  Synopsis:  this is for the OM and uses the long _lReadyState
//      to determine the string returned.
//
//+------------------------------------------------------------------------------

HRESULT
CTable::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(_readyStateTable, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CTable::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\wselect.cxx ===
//+---------------------------------------------------------------------
//
//   File:      wselect.cxx
//
//  Contents:   Unicode support for CSelectElement on win95.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

extern class CFontCache & fc();

MtDefine(CSelectElementAddString, CSelectElement, "CSelectElement::_pchItem")

//
// A few wrapper functions that cache system data we use a lot
//

inline
int Margin(void)
{
    static int iMargin = -1;

    return iMargin != -1 ? iMargin : (iMargin = 2*GetSystemMetrics(SM_CXBORDER));
}

#ifdef WIN16
#define _MAKELCID(x,y)  MAKELCID(x)
#else
#define _MAKELCID(x,y)  MAKELCID(x,y)
#endif

//+------------------------------------------------------------------------
//
//  Function:   LcidFromCP, static to this file.
//
//  Synopsis:   Attempts to convert a code page to a correct lcid
//
//  Arguments:  uCodePage -- a win95 code page (e.g. 1252)
//
//  Note:   Returns 0 if either the code page is unrecognized or the code
//          page cannot uniquely be assigned an lcid.  This happens, for
//          instance, with latin 1 (cp 1252), which is used for both
//          english and german locales.
//
//-------------------------------------------------------------------------
LCID LcidFromCP(UINT uCodePage)
{
    switch (uCodePage)
    {
        case 874: // thai
            return _MAKELCID(MAKELANGID(LANG_THAI, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 932: // japan
            return _MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 936: // simpl. chi
            return _MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT);
        case 949: // korean
            return _MAKELCID(MAKELANGID(LANG_KOREAN, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 950: // trad. chi
            return _MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL), SORT_DEFAULT);
        case 1250: // 3.1 e. euro
            return 0;
        case 1251: // 3.1 cyrillic
            return _MAKELCID(MAKELANGID(LANG_RUSSIAN, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1252: // 3.1 latin 1
            return 0;
        case 1253: // 3.1 greek
            return _MAKELCID(MAKELANGID(LANG_GREEK, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1254: // 3.1 turkish
            return _MAKELCID(MAKELANGID(LANG_TURKISH, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1255: // hebrew
            return _MAKELCID(MAKELANGID(LANG_HEBREW, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1256: // arabic
            return _MAKELCID(MAKELANGID(LANG_ARABIC, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1257: // baltic
            return 0;
        default:
            return 0;
    }
}

#ifndef WIN16
//+------------------------------------------------------------------------
//
//  Function:   PrivateToUpper, static to this file.
//
//  Synopsis:   Attempts to convert a WCHAR to uppercase using a locale
//              derived from the supplied cp.
//
//  Arguments:  chSource -- WCHAR to convert
//              BYTE abSource[] -- WCHAR in mbcs form
//                  abSource[1] must be 0 if char is sbc
//                  abSource[0] may be 0 if no mbcs char is available
//              uCodePage -- windows code page of the char (in mbcs)
//
//  Note:   Unfortunately on win95 LCMapStringW is stubbed, so we can't
//          reliably do a pure unicode case insensitive search.  That is, we
//          must use LCMapStringA.
//
//          Worse, at present we don't have an exact lcid for the characters
//          we examine, so we have to check for an exact match between the
//          supplied cp and an lcid.  If we don't find one, we return the
//          original wchar.
//
//          Unicode values between 0x0020 and 0x007f are always converted.
//
//-------------------------------------------------------------------------
WCHAR PrivateToUpper(WCHAR chSource, BYTE abSource[2], UINT uCodePage)
{
    LCID lcid;
    BOOL fUsedDefChar;
    BYTE abDest[2];
    int cbSize;

    // filter out the trivial case
    if ((chSource >= L'a') && (chSource <= L'z'))
        return chSource - L'a' + L'A';

    // filter out other trivial cases
    if ((chSource >= L'A') && (chSource <= L'Z'))
        return chSource;

    lcid = LcidFromCP(uCodePage);

    if (lcid == 0)
    {
        // we don't recognize the code page or it spans more than one LCID
        return chSource;
    }

    if (abSource[0] == 0)
    {
        // need to get an mbcs version of the char -- LCMapStringW stubbed on win95
        cbSize = WideCharToMultiByte(uCodePage, 0, &chSource, 1, (char *)abSource, 2, NULL, &fUsedDefChar);
        if (cbSize < 1 || fUsedDefChar)
            return chSource;
        if (cbSize == 1)
            abSource[1] = 0; // for compare below
    }
    else
    {
        cbSize = abSource[1] == 0 ? 1 : 2;
    }

    cbSize = LCMapStringA(lcid, LCMAP_UPPERCASE, (LPCSTR)abSource, cbSize, (LPSTR)&abDest, 2);

    if (cbSize > 0)
    {
        // got it, convert to unicode if necessary
        if (*((WORD *)abSource) != *((WORD *)abDest))
            MultiByteToWideChar(uCodePage, MB_ERR_INVALID_CHARS, (char *)abDest, cbSize, &chSource, 1);
    }

    return chSource;
}
#endif //!WIN16

//+------------------------------------------------------------------------
//
//  Function:   GenericDrawItem, static to this file.
//
//  Synopsis:   Handle WM_DRAWITEMs for both listboxes and comboboxes.
//
//  Arguments:  uGetItemMessage -- LB_GETITEMDATA or CB_GETITEMDATA
//
//-------------------------------------------------------------------------
void
CSelectElement::GenericDrawItem(LPDRAWITEMSTRUCT pdis, UINT uGetItemMessage)
{
    long idx = -1;
    int itemAction = pdis->itemAction;
    int itemID     = pdis->itemID;
    int itemState  = pdis->itemState;
    COptionElement * pOption = NULL;
    XHDC hDC(pdis->hDC, NULL);
    BOOL fRTL;
    UINT taOld = 0;

    Assert(LB_ERR == CB_ERR); // need a third parameter if this changes!

    if ( itemID >= 0  &&  itemID < _aryOptions.Size() )
    {
        pOption = _aryOptions[itemID]; Assert(pOption);

        if ( pOption->_fIsOptGroup )
        {
            if (!itemID && (itemAction & ODA_FOCUS))
                idx = GetNearestOption(itemID, FALSE);

            if (idx != -1)
            {
                Assert(idx > 0);
                pdis->rcItem.top += (idx*_lFontHeight);
                pdis->rcItem.bottom = pdis->rcItem.top + _lFontHeight;
            }
            else
            {
                itemAction &= ~ODA_FOCUS;
                itemState  &= ~(ODS_SELECTED | ODS_FOCUS);
            }
        }
    }    

    if ( pOption && (itemAction & (ODA_SELECT | ODA_DRAWENTIRE)) )
    {     
        if ( ! pOption->IsInMarkup() )
            return;

        if (itemState & ODS_SELECTED)
        {
            FillRect(hDC, &pdis->rcItem, GetSysColorBrush(COLOR_HIGHLIGHT));
        }
        else
        {
            //  Get the style sheet background color
            CColorValue ccv = pOption->GetFirstBranch()->GetCascadedbackgroundColor();
            HBRUSH hbrush;

            if ( ccv.IsDefined() )
            {
                hbrush = GetCachedBrush(ccv.GetColorRef());
                FillRect(hDC, &pdis->rcItem, hbrush);
                ReleaseCachedBrush(hbrush);
            }
            else
            {
                FillRect(hDC, &pdis->rcItem, (HBRUSH)GetCurrentObject(hDC, OBJ_BRUSH));
            }
        }

        WCHAR * pzItem = pOption->_cstrText;

        if ((pzItem != NULL) && (pzItem != (WCHAR *)LB_ERR))
        {
            int iOldBkMode = SetBkMode(hDC, TRANSPARENT);
            COLORREF crOldColor = 0;
            COLORREF cr;
            CColorValue ccv;
            CStr cstrTransformed;
            CStr * pcstrDisplayText;
            const CCharFormat *pcf;
            const CParaFormat *pPF;
            CCcs  ccs;
            int iRet = -1;
            UINT fuOptions = ETO_CLIPPED;

            if (itemState & ODS_DISABLED)
            {
                cr = GetSysColorQuick(COLOR_GRAYTEXT);
            }
            else if (itemState & ODS_SELECTED)
            {
                cr = GetSysColorQuick(COLOR_HIGHLIGHTTEXT);
            }
            else if ( (ccv = pOption->GetFirstBranch()->GetCascadedcolor()).IsDefined() )
            {
                cr = ccv.GetColorRef();
            }
            else
            {
                cr = GetSysColorQuick(COLOR_WINDOWTEXT);
            }

            crOldColor = SetTextColor(hDC, cr);

            //  Do the textTransform here
            pcstrDisplayText = pOption->GetDisplayText(&cstrTransformed, 
                                                       !!(itemState & ODS_COMBOBOXEDIT) );

            // ComplexText
            pPF = GetFirstBranch()->GetParaFormat();

            fRTL = pPF->HasRTL(TRUE);
            if(fRTL)
            {
                taOld = GetTextAlign(hDC);
                SetTextAlign(hDC, TA_RTLREADING | TA_RIGHT);
                fuOptions |= ETO_RTLREADING;
            }
            
            if (pOption->_fIsOptGroup)
                pcf = pOption->GetFirstBranch()->GetCharFormat();
            else
                pcf = GetFirstBranch()->GetCharFormat();

            if (pcf)
            {
                CDocInfo dci(this);

                if (!fc().GetCcs(&ccs, hDC, &dci, pcf))
                    return;
             
                if (pOption->_fIsOptGroup || pOption->CheckFontLinking(hDC, &ccs))
                {
                    // this option requires font linking
                    iRet = FontLinkTextOut(hDC,
                                           !fRTL ? pdis->rcItem.left + Margin() 
                                                 : pdis->rcItem.right - Margin(),
                                           pdis->rcItem.top,
                                           fuOptions ,
                                           &pdis->rcItem,
                                           *pcstrDisplayText,
                                           pcstrDisplayText->Length(),
                                           &dci,
                                           pcf,
                                           FLTO_TEXTOUTONLY);
                }
            }

            if (iRet < 0)
            {
                // no font linking
                VanillaTextOut(&ccs, hDC,
                               !fRTL ? pdis->rcItem.left + Margin() 
                                     : pdis->rcItem.right - Margin(),
                               pdis->rcItem.top,
                               fuOptions ,
                               &pdis->rcItem,
                               *pcstrDisplayText,
                               pcstrDisplayText->Length(),
                               GetMarkup()->GetCodePage(),
                               NULL);

                if (_hFont && g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
                {
                    // Workaround for win95 gdi ExtTextOutW underline bugs.
                    DrawUnderlineStrikeOut(pdis->rcItem.left+Margin(),
                                           pdis->rcItem.top,
                                           pOption->MeasureLine(NULL),
                                           hDC,
                                           _hFont,
                                           &pdis->rcItem);
                }
            }

            if (itemState & ODS_FOCUS)
            {
                DrawFocusRect(hDC, &pdis->rcItem);
            }

            if (itemState & (ODS_SELECTED | ODS_DISABLED))
            {
                SetTextColor(hDC, crOldColor);
            }

            SetBkMode(hDC, iOldBkMode);

            ccs.Release();

            if(fRTL)
                SetTextAlign(hDC, taOld);
        }
    }

    if (itemAction & ODA_FOCUS)
    {
        DrawFocusRect(hDC, &pdis->rcItem);

        if (idx != -1)
        {
            Assert(idx > 0);
            pdis->rcItem.top -= (idx*_lFontHeight);
            pdis->rcItem.bottom = pdis->rcItem.top + _lFontHeight;
        }
    }
    else
        Assert(idx == -1);
}

#ifndef WIN16
//+------------------------------------------------------------------------
//
//  Function:   GenericCharToItem, static to this file.
//
//  Synopsis:   WM_CHARTOITEM handler for both listboxes and comboboxes.
//              Translates a keypress into the matching list item.
//
//-------------------------------------------------------------------------
LRESULT
CSelectElement::GenericCharToItem (HWND hCtlWnd,
                                   WORD wKey,
                                   WORD wCurrentIndex)
{
    int sCurrentIndex = (unsigned)wCurrentIndex;
    WCHAR chUniKey;
    int iSearch, iCount;
    int cbSize;
    UINT uKbdCodePage, uCtlCodePage;
    CHARSETINFO ci;
    HDC hFontDC;
    UINT uCharSet;
    const WCHAR * pwc;
    char strKey[2];

    iCount = _aryOptions.Size();
    Assert(SendSelectMessage(Select_GetCount, 0, 0) == iCount);

    if ( iCount <= 0)
        return -1;

    // get the current keyboard code page
    // uses TCI_SRCLOCALE (0x1000) flag, documented in gdi.c
    if (TranslateCharsetInfo((DWORD *)GetKeyboardLayout(0), &ci, 0x1000))
        uKbdCodePage = ci.ciACP;
    else
        uKbdCodePage = CP_ACP;

    // check for dbcs
    if ( !IsWindowUnicode( hCtlWnd ) )
    {          
        if (IsDBCSLeadByteEx(uKbdCodePage, HIBYTE(wKey) != 0))
        {
            // lead byte must precede trail byte for MBTWC call below....
            strKey[0] = HIBYTE(wKey);
            strKey[1] = LOBYTE(wKey);
            cbSize = 2;
        }
        else
        {
            strKey[0] = LOBYTE(wKey);
            cbSize = 1;
        }

        // get the unicode char
        if (MultiByteToWideChar(uKbdCodePage, MB_ERR_INVALID_CHARS, strKey, cbSize, &chUniKey, 1) != 1)
            return -1;
    }
    else
    {
        chUniKey = (WCHAR) wKey; 
    }
    
    // and an uppercase version in the case 0x0020 <= chUniKey <= 0x007f
    chUniKey = PrivateToUpper(chUniKey, (BYTE *)&wKey, uKbdCodePage);

    // get the ctl code page from its font
    uCtlCodePage = 0xffff;
    if ((hFontDC = ::GetDC(hCtlWnd)) != NULL)
    {
        uCharSet = GetTextCharsetInfo(hFontDC, NULL, 0);
        ::ReleaseDC(hCtlWnd, hFontDC);
        if (uCharSet != DEFAULT_CHARSET)
        {
            if (TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &ci, TCI_SRCCHARSET))
                uCtlCodePage = ci.ciACP;
        }
    }

    //
    // Look for it.  This code assumes the strings are unordered --> we could be
    // n / log n times faster if this ever changes!
    //

    wKey = 0; // use this as a buffer below

    for (iSearch = sCurrentIndex + 1; iSearch < iCount; iSearch++)
    {
        if (_aryOptions[iSearch]->_fIsOptGroup)
            continue;

        //  Guard against empty OPTIONs
        pwc = _aryOptions[iSearch]->_cstrText;
        if ( ! pwc )
        {
            pwc = g_Zero.ach;
        }

        if (PrivateToUpper(*pwc,
                           (BYTE *)&wKey,
                           uCtlCodePage) == chUniKey)
            return iSearch;
    }
    // If no element selected, set sCurrentIndex to the last element index
    if (sCurrentIndex > iCount)
        sCurrentIndex = iCount-1;
    for (iSearch = 0; iSearch <= sCurrentIndex; iSearch++)
    {
        if (_aryOptions[iSearch]->_fIsOptGroup)
            continue;

        //  Guard against empty OPTIONs
        pwc = _aryOptions[iSearch]->_cstrText;
        if ( ! pwc )
        {
            pwc = g_Zero.ach;
        }

        if (PrivateToUpper(*pwc,
                           (BYTE *)&wKey,
                           uCtlCodePage) == chUniKey)
            return iSearch;
    }

    return -1;
}
#endif //!WIN16

//+------------------------------------------------------------------------
//
//  Function:   WListboxHookProc
//
//  Synopsis:   Handles owner-draw ctl messages, also manages string related
//              ctl commands (LB_ADDSTRING, etc.).
//
//  Arguments:  pfnWndProc -- default WNDPROC to pass message to.
//
//  Note:       Called from the subclassed ctl's wndproc, CSelectElement::SelectElementWndProc.
//
//-------------------------------------------------------------------------
LRESULT BUGCALL
CSelectElement::WListboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR *pzItemText;
    long lSelectedIndex = -1;

    switch (message)
    {

        //
        // Reflected messages courtesy of CDoc::OnWindowMessage
        //

        case OCM__BASE + WM_DRAWITEM:
            GenericDrawItem((LPDRAWITEMSTRUCT) lParam, LB_GETITEMDATA);
            return TRUE;

        case OCM__BASE + WM_MEASUREITEM:
            //
            //  Laszlog:
            // We get one of these at creation time to determine the field height.
            // Use the font's height.
            //
            {
                LPMEASUREITEMSTRUCT pmi = (LPMEASUREITEMSTRUCT)lParam;

                Assert(pmi);
                Assert(this);

                pmi->itemHeight = _lFontHeight;
            }
            return TRUE;

        case OCM__BASE + WM_COMPAREITEM:
            // Not currently used by CSelectElement.
            // TODO (benwest) support this
            return LB_OKAY;

#ifndef WIN16
        case OCM__BASE + WM_CHARTOITEM:
            //
            // lb sends one of these when a user types a key into the list.
            // Convert the char to unicode and search for a match.
            //
            return GenericCharToItem((HWND)lParam, LOWORD(wParam), HIWORD(wParam));
#endif // ndef WIN16

        case OCM__BASE + WM_GETTEXT:
            //
            // use the selected item to look up the item currently displayed in the static part
            // This is a private message for OLEACC.DLL. They need the string in unicode
            // but the ANSI SendMessage/DefWndProc pair marshals the string and destroys it.
            // It is chooped off after the first 0 byte.
            //
            lSelectedIndex = SendMessageA(hWnd, LB_GETCURSEL, 0, 0);

        case WM_USER + LB_GETTEXT:
            if (-1 == lSelectedIndex)
                lSelectedIndex = wParam;

            if (-1 == lSelectedIndex)
            {
                *(WCHAR *)lParam = 0;
                return LB_OKAY;
            }

            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, LB_GETITEMDATA, lSelectedIndex, 0)) != (WCHAR *)LB_ERR)
            {
                wcscpy((WCHAR *)lParam, pzItemText);
                return wcslen(pzItemText);
            }
            return LB_ERR;

        case LB_GETTEXTLEN:
            // not currently sent by CSelectElement, but it compliments LB_GETTEXT
            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, LB_GETITEMDATA, wParam, 0)) != (WCHAR *)LB_ERR)
                return wcslen(pzItemText);
            return LB_ERR;
    }

    return CallWindowProc(pfnWndProc, hWnd, message, wParam, lParam);
}

//+------------------------------------------------------------------------
//
//  Function:   WComboboxHookProc
//
//  Synopsis:   Handles owner-draw ctl messages, also manages string related
//              ctl commands (CB_ADDSTRING, etc.).
//
//  Arguments:  pfnWndProc -- default WNDPROC to pass message to.
//
//  Note:       Called from the subclassed ctl's wndproc, CSelectElement::SelectElementWndProc.
//
//-------------------------------------------------------------------------
LRESULT BUGCALL
CSelectElement::WComboboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR *pzItemText;
    long lSelectedIndex = -1;

    switch (message)
    {

        //
        // Reflected messages courtesy of CDoc::OnWindowMessage
        //

        case OCM__BASE + WM_DRAWITEM:
            GenericDrawItem((LPDRAWITEMSTRUCT) lParam, CB_GETITEMDATA);
            return TRUE;

        case OCM__BASE + WM_MEASUREITEM:
            //
            // We get one of these at creation time to determine the field height.
            //  Laszlog:
            // We get one of these at creation time to determine the field height.
            // Use the font's height.
            //
            {
                LPMEASUREITEMSTRUCT pmi = (LPMEASUREITEMSTRUCT)lParam;

                Assert(pmi);
                Assert(this);

                pmi->itemHeight = _lFontHeight;
            }
            return TRUE;

        case OCM__BASE + WM_COMPAREITEM:
            // Not currently used by CSelectElement.
            // TODO (benwest): support this
            return CB_OKAY;

        //
        // ctl messages we need to augment
        //

        case OCM__BASE + WM_GETTEXTLENGTH:
            // Private message for OLEACC.DLL to get the length of the curently selected string.
            // we need this because the regular WM_GETTEXLENGTH message keeps returning 4 all the time.
            lSelectedIndex = SendMessageA(hWnd, CB_GETCURSEL, 0, 0);

        case CB_GETLBTEXTLEN:
            if (-1 == lSelectedIndex)
                lSelectedIndex = wParam;

            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, CB_GETITEMDATA, lSelectedIndex, 0)) != (WCHAR *)CB_ERR)
                return wcslen(pzItemText);
                
             return CB_ERR;

        case WM_USER + CB_GETLBTEXT:
            lSelectedIndex = wParam;

        case OCM__BASE + WM_GETTEXT:
            //
            // use the selected item to look up the item currently displayed in the static part
            // This is a private message for OLEACC.DLL. They need the string in unicode
            // but the ANSI SendMessage/DefWndProc pair marshals the string and destroys it.
            // It is chooped off after the first 0 byte.
            //
            if (-1 == lSelectedIndex)
                lSelectedIndex = SendMessageA(hWnd, CB_GETCURSEL, 0, 0);

            if (-1 == lSelectedIndex)
            {
                *(WCHAR *)lParam = 0;
                return CB_OKAY;
            }

            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, CB_GETITEMDATA, lSelectedIndex, 0)) != (WCHAR *)CB_ERR)
            {
                wcscpy((WCHAR *)lParam, pzItemText);
                return wcslen(pzItemText);
            }
            return CB_ERR;

#ifndef WIN16
        case WM_CHARTOITEM:
            //
            // cb sends one of these when a user types a key into the list.
            // Convert the char to unicode and search for a match.
            //
            return GenericCharToItem(hWnd/*(HWND)lParam*/, LOWORD(wParam), HIWORD(wParam));
#endif // ndef WIN16

    }

    return CallWindowProc(pfnWndProc, hWnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\wselect.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//   File:      wselect.h
//
//  Contents:   Unicode support for CSelectElement on win95.
//
//------------------------------------------------------------------------

#ifndef I_WSELECT_H_
#define I_WSELECT_H_
#pragma INCMSG("--- Beg 'wselect.h'")

LRESULT CALLBACK WListboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK WComboboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#pragma INCMSG("--- End 'wselect.h'")
#else
#pragma INCMSG("*** Dup 'wselect.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\trowcol.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       table.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

MtDefine(CTableRow, Elements, "CTableRow")
MtDefine(CTableRow_aryCells_pv, CTableRow, "CTableRow::_aryCells::_pv")
MtDefine(CTableCol, Elements, "CTableCol")
MtDefine(CTableSection, Elements, "CTableSection")
MtDefine(BldRowCellsCol, PerfPigs, "Build CTableRow::CELLS_COLLECTION")
MtDefine(BldSectionRowsCol, PerfPigs, "Build CTableSection::ROWS_COLLECTION")
MtDefine(CharFormatSteal, ComputeFormats, "CharFormat steal from nearby row/col/cell")
MtDefine(ParaFormatSteal, ComputeFormats, "ParaFormat steal from nearby row/col/cell")
MtDefine(FancyFormatSteal, ComputeFormats, "FancyFormat steal from nearby row/col/cell")

const CElement::CLASSDESC CTableRow::s_classdesc =
{
    {
        &CLSID_HTMLTableRow,            // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |
        0,                              // _dwFlags
        &IID_IHTMLTableRow,             // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableRow,      // _pfnTearOff
    NULL                                // _pAccelsRun
};


HRESULT
CTableRow::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_TR));
    Assert(ppElement);

    *ppElement = new CTableRow(pDoc);
    RRETURN( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::destructor, CBase
//
//  Note:       The collection cache must be deleted in the destructor, and
//              not in Passivate, because collection objects we've handed out
//              (via get_cells) merely SubAddRef the row.
//-------------------------------------------------------------------------

CTableRow::~CTableRow()
{
    delete _pCollectionCache;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::Passivate, CBase
//
//-------------------------------------------------------------------------

void
CTableRow::Passivate()
{
    super::Passivate();
}

//+----------------------------------------------------------------------------
//
//  Member:     CTableRow::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CTableRow::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLTableRow)
        QI_HTML_TEAROFF(this, IHTMLTableRow, NULL)
        QI_HTML_TEAROFF(this, IHTMLTableRow2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTableRow3, NULL)
        QI_TEAROFF(this, IHTMLTableRowMetrics, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::ComputeFormatsVirtual
//
//  Synopsis:   Compute Char and Para formats induced by this element and
//              every other element above it in the HTML tree.
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//  Note:       We override this here to put our defaults into the format
//              FIRST, and also to cache vertical alignment here in the object
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget )
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    HRESULT hr;
    CTableRowLayout *pRowLayout;

    Assert(pNodeTarget && SameScope(this, pNodeTarget));

    pRowLayout = RowLayoutCache();
    Assert(pRowLayout);

    //check row above
    //TODO: (alexa) for data-binding we should take comparable row in a previous GENERATED section instead of a previous row
    if (pRowLayout->RowPosition() > 0)
    {
        CTable    * pTable = Table();

        // If we can't find our table, the table structure is messed up and
        // our compute formats behave like a CElement.
        if (!pTable)
            goto DontStealFormat;

        CTableLayout * pTableLayout = pTable->TableLayoutCache();
        CTableRow * pRow;
        CTreeNode * pNodeRow;

        {
            WHEN_DBG(
                BOOL fDisableTLCAssert = pTableLayout->_fDisableTLCAssert;
                pTableLayout->_fDisableTLCAssert = TRUE; )

            pRow = (pRowLayout->RowPosition()-1 < pTableLayout->GetRows()) 
                        ? pTableLayout->GetRow(pRowLayout->RowPosition()-1) 
                        : NULL;

            WHEN_DBG(
                pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )
        }

        pNodeRow = pRow ? pRow->GetFirstBranch() : NULL;

        //
        // Proxy Alert!
        //
        // Notice that to do this optimization we are comparing the parent
        // of pElementTarget to that of pRow.  pElementTarget is in the
        // tree (and may be a proxy), while pRow may not be in the tree.
        // But, if the parent of pRow is the parent of pElementTarget, then
        // pRow is in the tree.
        //

        // We do not use this optimization when ComputeFormats is called for getttng a value
        if(pCFI->_eExtraValues != ComputeFormatsType_Normal ||
               !pTableLayout->IsTableLayoutCacheCurrent()   ||
               !pRow                                        ||
               pRow->_fHasPendingRecalcTask)
            goto DontStealFormat;

        if (pNodeRow && pNodeRow->_iPF >= 0 && pNodeRow->_iCF >= 0 && pNodeRow->_iFF >= 0 &&
            SameScope(pNodeTarget->Parent(), pNodeRow->Parent()) && pRow->_fStealingAllowed &&
            (_pAA == NULL && pRow->_pAA == NULL ||
             _pAA != NULL && pRow->_pAA != NULL && _pAA->Compare(pRow->_pAA)) )
        {
            THREADSTATE * pts = GetThreadState();

            // At least one of the caches is dirty.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iCF == -1 || pNodeTarget->_iFF == -1);

            // The caches that were not dirty, have to match with the corresponding caches of
            // the previous row.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iPF == pNodeRow->_iPF);
            Assert(pNodeTarget->_iCF == -1 || pNodeTarget->_iCF == pNodeRow->_iCF);
            Assert(pNodeTarget->_iFF == -1 || pNodeTarget->_iFF == pNodeRow->_iFF);

            //
            // Selectively copy down each of the dirty caches.
            //

            if (pNodeTarget->_iPF == -1)
            {
                pNodeTarget->_iPF = pNodeRow->_iPF;
                (pts->_pParaFormatCache)->AddRefData( pNodeRow->_iPF );
                MtAdd(Mt(ParaFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iCF == -1)
            {
                pNodeTarget->_iCF = pNodeRow->_iCF;
                (pts->_pCharFormatCache)->AddRefData( pNodeRow->_iCF );
                MtAdd(Mt(CharFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iFF == -1)
            {
                pNodeTarget->_iFF = pNodeRow->_iFF;
                (pts->_pFancyFormatCache)->AddRefData( pNodeRow->_iFF );
                MtAdd(Mt(FancyFormatSteal), 1, 0);
            }

            // Set the _fBlockNess cache bit on the node to save a little time later.
            // Need to do this here because we don't call super.
            pNodeTarget->_fBlockNess = TRUE;

            hr = S_OK;
            goto Cleanup;
        }
    }

DontStealFormat:

    hr = THR(super::ComputeFormatsVirtual( pCFI, pNodeTarget ));

Cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    CColorValue ccvBorderColor;
    CColorValue ccvColor;
    HRESULT     hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    pCFI->PrepareFancyFormat();

    // Override inherited colors as necessary
    ccvBorderColor = GetAAborderColor();
    if ( ccvBorderColor.IsDefined() )
    {
        long    i;

        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff()._bd.SetBorderColor(i, ccvBorderColor);
        }

        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight =
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
    }

    ccvBorderColor = GetAAborderColorLight();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
    }

    ccvBorderColor = GetAAborderColorDark();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
    }

    pCFI->UnprepareForDebug();

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::Save(CStreamWriteBuff *pStmWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;

    hr = super::Save(pStmWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (fEnd && pStmWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        hr = pStmWrBuff->NewLine();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::OnPropertyChange
//
//  Synopsis:   Process property changes to table row element.
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;
    CTable *pTable = NULL;
    BOOL    fPropagateChange = FALSE;
    BOOL    fSpecialProperty = FALSE;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    switch (dispid)
    {
    case DISPID_A_DISPLAY:
    case DISPID_A_POSITION:
        pTable = Table();
        if (pTable)
        {
            CTableLayout *pTableLayout = pTable->TableLayoutCache();
            Assert (pTableLayout);
            if (_fHaveRowSpanCells || _fCrossingRowSpan)
            {
                pTableLayout->MarkTableLayoutCacheDirty();
            }
            pTableLayout->Resize();
        }
        break;

    case DISPID_A_VISIBILITY:
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_BACKCOLOR:
        // If the backgroundcolor or image changes, let the affected table
        // cells know, so that they can update their display tree nodes.
        fPropagateChange = TRUE;
        fSpecialProperty = TRUE;
        break;

    default:
        if (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED |
                       ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS))
        {
            fPropagateChange = TRUE;
        }
        break;
    }

    if (fPropagateChange)
    {
        hr = THR(PropagatePropertyChangeToCells(dispid, dwFlags, fSpecialProperty));
        //if (hr)
        //    goto Cleanup;
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::PropagatePropertyChangeToCells
//
//  Synopsis:   Helper function to propagate property changes from
//              table elements to cells.  Called by CTableSection::
//              and CTableRow::OnPropertyChange().
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::PropagatePropertyChangeToCells(DISPID dispid, 
                                          DWORD dwFlags, 
                                          BOOL fSpecialProperty)
{
    CTableRowLayout * pRowLayout = RowLayoutCache();
    CTableCell     ** ppCell;
    CTableCell      * pCell;
    CTableCellLayout * pCellLayout;
    int               cColSpan, cCols, cCells;
    HRESULT           hr = S_OK;
    CTable           *pTable = Table();
    CTableLayout     *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

    if (!pRowLayout)
        goto Cleanup;
  
    if (!pTableLayout)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    for (cCols = pRowLayout->_aryCells.Size(), ppCell = pRowLayout->_aryCells ;  
         cCols > 0; 
         cCols -= cColSpan, ppCell += cColSpan)
    {
        pCell = Cell(*ppCell);
        pCellLayout = pCell ? pCell->Layout() : NULL;

        if (pCell && pCellLayout)
        {
            cColSpan = pCell->ColSpan();
            if (fSpecialProperty)
            {
                hr = THR(pCellLayout->OnPropertyChange(dispid, dwFlags));
                if (hr)
                    goto Cleanup;
            }
            else if (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED))
            {
                pCellLayout->SetSizeThis( TRUE ); // cell needs to be sized
            }
            else 
            {
                Assert (dwFlags & (ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS));
                pCell->RemeasureElement(dwFlags & ELEMCHNG_REMEASUREALLCONTENTS
                                        ? NFLAGS_FORCE
                                        : 0); // make sure we remeasure this cell
                if (pTableLayout->IsFixed())
                {
                    pTableLayout->ResetIncrementalRecalc();  // hack, bug #75881, need to force fixed table to calc.
                    // pRowLayout->SetSizeThis( TRUE );   // the right solution would be to set _fSizeThis
                    // and let CalculateLayout to call CalculateRow for this layout (obvisouly we would need to
                    // enusre LAYOUT_FORCE flag via notification to trigger that logic).
                }
            }
        }
        else
        {
            cColSpan = 1;
        }
    }

    if (pRowLayout->_pDisplayNoneCells)
    {
        for (cCells = pRowLayout->_pDisplayNoneCells->Size(), ppCell = *pRowLayout->_pDisplayNoneCells ;  cCells > 0; cCells--, ppCell++)
        {
            hr = THR((*ppCell)->Layout()->OnPropertyChange(dispid, dwFlags));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  ROW CELLS collection
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
// Note: the GetNext interface is LITTLE BIT STRANGE (I am being polite to OM team: alexa):
//       it should of being called GetCurrent and Prepare for the Next
//-------------------------------------------------------------------------

CElement *
CTableRowCellsCollectionCacheItem::MoveTo ( long lIndex )
{
    _lCurrentIndex = lIndex;
    return CTableRowCellsCollectionCacheItem::GetAt(lIndex);
}


CElement *
CTableRowCellsCollectionCacheItem::GetNext ( void )
{
    CTableCell *pCell = NULL, *pCellNext;
    int i, cCols;
    
    if (_iCurrentCol < 0)
    {
        return GetAt(_lCurrentIndex++);
    }
    else if (_pRowLayout && _lCurrentIndex < _pRowLayout->_cRealCells)
    {
        // 1. Get Current
        // 2. Prepare for the next
        BOOL    fDisplayNone = _pRowLayout->_pDisplayNoneCells != NULL && _cDisplayNone < _pRowLayout->_pDisplayNoneCells->Size();

        Assert ( _iCurrentCol >= 0 && (_iCol >= 0 || _cDisplayNone >= 0) );
        cCols = _pRowLayout->_aryCells.Size();
        Assert (_iCol < cCols);

        if (_iCol >= 0)
        {
            pCell = _pRowLayout->_aryCells[_iCol];
            Assert (IsReal(pCell));
            // Prepare for the next
            i = _iCol + pCell->ColSpan();
        }
        else
        {
            Assert (_cDisplayNone >= 0);
            pCell = (*_pRowLayout->_pDisplayNoneCells)[_cDisplayNone];
            i =  pCell->ColIndex();
            if (++_cDisplayNone >= _pRowLayout->_pDisplayNoneCells->Size())
            {
                fDisplayNone = FALSE;
            }
        }


        _lCurrentIndex ++;
        _iCol = -1;
        _iCurrentCol = -1;

        while (i < cCols)
        {
            if (fDisplayNone && (*_pRowLayout->_pDisplayNoneCells)[_cDisplayNone]->ColIndex() == i)
            {
                _iCurrentCol = i;
                break;
            }
            pCellNext = _pRowLayout->_aryCells[i];
            if (IsReal(pCellNext))
            {
                _iCol = i;
                _iCurrentCol = i;
                break;
            }
            i++;
        }

    }

    return pCell;
}

CElement *
CTableRowCellsCollectionCacheItem::GetAt ( long lIndex )
{
    int         i;
    CTableCell  *pCell = NULL;
    int         iRealCell = 0;

    _iCol = -1;
    _iCurrentCol = -1;
    _cDisplayNone = -1;

    Assert ( lIndex >= 0);
    Assert (_pRowLayout);
    if (lIndex < _pRowLayout->_cRealCells)
    {

        BOOL            fDisplayNone = _pRowLayout->_pDisplayNoneCells != NULL;
        int             cDisplayNoneCells = 0;
        int             iDisplayNoneCol   = -1;
        CTableCell   **ppDisplayNoneCells = NULL;

        int  cCells = _pRowLayout->_aryCells.Size();
        if (fDisplayNone)
        {
            cDisplayNoneCells = _pRowLayout->_pDisplayNoneCells->Size();
            ppDisplayNoneCells = (*_pRowLayout->_pDisplayNoneCells);
            _cDisplayNone = 0;
            iDisplayNoneCol = (*ppDisplayNoneCells)->ColIndex();
        }
        for (i = 0; i < cCells || fDisplayNone; i++)
        {
            if (fDisplayNone && i == iDisplayNoneCol)
            {
                if (iRealCell == lIndex)
                {
                    pCell = *ppDisplayNoneCells;
                    break;
                }
                else
                {
                    _cDisplayNone++;
                    cDisplayNoneCells--;
                    if (!cDisplayNoneCells)
                    {
                        fDisplayNone = FALSE;
                    }
                    else
                    {
                        ppDisplayNoneCells++;
                        iDisplayNoneCol = (*ppDisplayNoneCells)->ColIndex();
                    }
                    iRealCell++;
                    i--;
                    continue;
                }
            }
            pCell = _pRowLayout->_aryCells[i];
            if ( IsReal(pCell) )
            {
                if (iRealCell == lIndex)
                {
                    _iCol = i;
                    break;
                }
                else
                {
                    iRealCell++;
                    i += pCell->ColSpan() - 1;    // - 1 to account for i++
                }
            }
        }

        _iCurrentCol = i;
        Assert (iRealCell < _pRowLayout->_cRealCells && pCell);
    }
    return pCell;
}

long 
CTableRowCellsCollectionCacheItem::Length ( void )
{
    if (_pRowLayout)
        return _pRowLayout->_cRealCells;
    else
        return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the row's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::EnsureCollectionCache(long lIndex)
{
    HRESULT hr = S_OK;

    CTable *pTable = Table();
    if (pTable)
    {
        CTableLayout * pTableLayout = pTable->TableLayoutCache();
        Assert (pTableLayout);
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
    }
    
    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CTableRow, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(1, 1));
        if (hr)
            goto Error;

        CTableRowCellsCollectionCacheItem *pCellsCollection = new CTableRowCellsCollectionCacheItem(this);
        if ( !pCellsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( CELLS_COLLECTION, pCellsCollection ));
        if (hr)
            goto Cleanup;

        //
        // Collection cache now owns this item & is responsible for freeing it
        //

    }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the cells collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    CTable       *pTable = Table();
    CTableLayout *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;

    Assert (_pCollectionCache);

    CTableRowCellsCollectionCacheItem *pCellsCollection = (CTableRowCellsCollectionCacheItem *) _pCollectionCache->GetCacheItem (lIndex);

    Assert (pCellsCollection);
    pCellsCollection->_iCol = -1;           // Next item must be recomputed
    pCellsCollection->_iCurrentCol = -1;

    if ( pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        *plCollectionVersion = pTableLayout->_iCollectionVersion;   // to mark it done
    }
    RRETURN(hr);
}

const CTableSection::CLASSDESC CTableSection::s_classdesc =
{
    {
        &CLSID_HTMLTableSection,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOLAYOUT,           // _dwFlags
        &IID_IHTMLTableSection,         // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableSection   // _pfnTearOff
};


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLTableSection2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTableSection3, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CTableSection::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_THEAD) || pht->Is(ETAG_TFOOT) || pht->Is(ETAG_TBODY));
    Assert(ppElement);
    *ppElement = new CTableSection(pht->GetTag(), pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableSection::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableSection::Notify(CNotification *pNF)
{
    DWORD           dw = pNF->DataAsDWORD();

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        {
            CTable       *pTable = Table();

            if (pTable)
            {
                CTableLayout *pTableLayout = pTable->TableLayoutCache();
                Assert (pTableLayout);

                if (!(dw & ENTERTREE_PARSE) && !pTableLayout->_fEnsureTBody)
                {
                    pTableLayout->_fDontSaveHistory = TRUE;
                }
                if (dw & ENTERTREE_MOVE)   // if it is a MOVETREE notification
                {
                    // we are moved from another tree
                    if (pTableLayout->_fPastingRows)
                    {
                        Assert (pTable->IsDatabound() && pTableLayout->IsRepeating());
                        pTableLayout->AddSection(this);
                    }
                    else
                    {
                        pTableLayout->MarkTableLayoutCacheDirty();
                    }
                }
                else
                {
                    EnterTree();
                }
            }
        }
        break;
    case NTYPE_ELEMENT_EXITTREE_1:
        if (!(dw & EXITTREE_DESTROY))
        {
            CTable          *pTable = Table();

            if (!pTable)
                break;

           CTableLayout    *pTableLayout = pTable->TableLayoutCache();
           Assert(pTableLayout);

           if (!(dw & EXITTREE_MOVE))      // if it is not a move tree
            {

                // don't update the caches for individual rows in case of :1) shutdown; 2) data-binding removing rows
                if (!(pTableLayout->_fRemovingRows || pTable->_fExittreePending))
                {
                    // Don't hold refs to the tree after our element leaves it
                    pTableLayout->BodyExitTree(this);
                    pTableLayout->MarkTableLayoutCacheDirty();
                }
            }
        }

        break;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::EnterTree, CElement
//
//  Synopsis:   Add section to table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::EnterTree()
{
    HRESULT        hr = S_OK;
    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

    // Only maintain the table layout cache incrementally until the table
    // has finished parsing.
    if (pTableLayout)
    {
        if (!pTableLayout->IsCompleted() || pTableLayout->_fTableOM)
        {
            hr = pTableLayout->AddSection(this);
        }
        else
        {
            pTableLayout->MarkTableLayoutCacheDirty();
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    // clear back color, width/height, control blockalign coming from the table
    pCFI->_bCtrlBlockAlign = htmlBlockAlignNotSet;

    pCFI->PrepareFancyFormat();

    pCFI->_ff().ClearWidth();
    pCFI->_ff().ClearHeight();
    pCFI->_ff()._bPageBreaks = 0;

    pCFI->UnprepareForDebug();

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    if ( pCFI->_pff->_bPositionType != stylePositionNotSet )
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bPositionType = stylePositionNotSet;
        pCFI->UnprepareForDebug();
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::OnPropertyChange
//
//  Synopsis:   Process property changes to table row element.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;
    CTable       * pTable = NULL;
    CTableLayout * pTableLayout = NULL;
    BOOL           fSpecialProperty = FALSE;
    BOOL           fPropagateChange = FALSE;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    pTable = Table();
    pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

    if (!pTableLayout)
        goto Cleanup;
    
    switch (dispid)
    {
    case DISPID_A_DISPLAY:
    // not supported on section: case DISPID_A_POSITION:
        pTableLayout->Resize();
        break;

    // If the backgroundcolor or image changes, let the affected table
    // cells know, so that they can update their display tree nodes.
    case DISPID_A_VISIBILITY:
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_BACKCOLOR:
        fSpecialProperty = TRUE;
        fPropagateChange = TRUE;
        break;

    default:
        fPropagateChange = (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED |
                                            ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS));
        break;
    }

    if (fPropagateChange)
    {
        int            iRow;

        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
        for (iRow = _iRow ; iRow < _iRow + _cRows ; iRow++)
        {
            CTableRow * pRow = pTableLayout->GetRow(iRow);
            Assert(pRow);

            hr = THR(pRow->PropagatePropertyChangeToCells(dispid, dwFlags, fSpecialProperty));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::destructor, CBase
//
//  Note:       The collection cache must be deleted in the destructor, and
//              not in Passivate, because collection objects we've handed out
//              (via get_rows) merely SubAddRef the table.
//-------------------------------------------------------------------------

CTableSection::~CTableSection()
{
    delete _pCollectionCache;
}

class CTableSectionRowsCollectionCacheItem : public CTableCollectionCacheItem
{
protected:
    CTableSection *_pSection;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldSectionRowsCol))
    CTableSectionRowsCollectionCacheItem(CTableSection *pSection) 
    {
        _pSection = pSection; 
        CTable *pTable = pSection->Table();
        if (pTable)
        {
            _pTableLayout = pTable->TableLayoutCache(); 
        }
    }
    CElement *GetAt ( long lIndex );
    long Length ( void );
};


CElement *CTableSectionRowsCollectionCacheItem::GetAt ( long lIndex )
{
    Assert ( lIndex >= 0 );
    return (lIndex < _pSection->_cRows && _pTableLayout)? _pTableLayout->_aryRows[_pSection->_iRow + lIndex] : NULL;
}

long CTableSectionRowsCollectionCacheItem::Length ( void )
{
    return _pSection->_cRows;
}

//+------------------------------------------------------------------------
//
//  Member:     InvalidateCollections
//
//  Synopsis:   Invalidate the collection of the section and all
//              contained rows
//
//-------------------------------------------------------------------------

void CTableSection::InvalidateCollections(CTable *pTable)
{
    Assert(pTable);
    CTableLayout *pTableLayout = pTable->TableLayoutCache();

    if (_pCollectionCache)
        _pCollectionCache->Invalidate();    // this will reset collection version number

    for (int i = _iRow; i < _iRow + _cRows; i++)
    {
        pTableLayout->_aryRows[i]->InvalidateCollections();
    }
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the table's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::EnsureCollectionCache( long lIndex )
{
    HRESULT hr = S_OK;

    CTable *pTable = Table();
    if (pTable)
    {
        CTableLayout * pTableLayout = pTable->TableLayoutCache();
        Assert (pTableLayout);
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
    }

    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                (PFN_CVOID_ENSURE)&CTableSection::EnsureCollections);
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(1, 1));
        if (hr)
            goto Error;

        CTableSectionRowsCollectionCacheItem *pRowsCollection = new CTableSectionRowsCollectionCacheItem(this);
        if ( !pRowsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( ROWS_COLLECTION, pRowsCollection ));
        if (hr)
            goto Cleanup;

        //
        // Collection cache now owns this item & is responsible for freeing it
        //
   }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the table rows collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    CTable *pTable = Table();
    CTableLayout *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;
    if ( pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        *plCollectionVersion = pTableLayout->_iCollectionVersion;   // to mark it done
    }
    RRETURN (hr);
}



const CTableCol::CLASSDESC CTableCol::s_classdesc =
{
    {
        &CLSID_HTMLTableCol,            // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOLAYOUT,           // _dwFlags
        &IID_IHTMLTableCol,             // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableCol       // _pfnTearOff
};


#ifdef NEVER_USED_CODE

//+---------------------------------------------------------------------------
//
//  Member:     CTableSection::GetCellFromRowCol
//
//  Synopsis:   Returns the cell located at table grid position (iRow,iCol)
//
//  Arguments:  iRow [in]         -- visual row index
//              iCol [in]         -- visual col index
//              ppTableCell [out] -- table cell at (iRow,iCol)
//
//  Returns:    Returns S_OK with pointer to table cell.  The pointer will
//              be NULL when the cell at the specified position doesn't exist
//              or is a non-real cell part of another cell's row- or columnspan.
//
//  Note:       The rows and column indices are relative to the section
//              origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::GetCellFromRowCol(int iRow, int iCol, CTableCell **ppTableCell)
{
    CTableRow * pTableRow;
    CTableCell *pTableCell;
    HRESULT     hr = S_OK;
    CTableLayout * pTableLayout = Table() ? Table()->TableLayoutCache() : NULL;

    if (!ppTableCell)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppTableCell = NULL;

    if (!pTableLayout)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow < 0 || iRow >= _cRows || iCol < 0 || iCol >= pTableLayout->GetCols())
        goto Cleanup;

    // Obtain row from iRow.
    iRow = iRow + _iRow;
    Assert(iRow >= 0 && iRow < pTableLayout->GetRows());
    pTableRow = pTableLayout->_aryRows[iRow];
    Assert(pTableRow && !"NULL row in legal range");

    // Obtain col from iCol.
    Assert(pTableRow->RowLayoutCache() && "Row without CTableRowLayout");
    pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];

    if (IsReal(pTableCell))
        *ppTableCell = pTableCell;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableSection::GetCellsFromRowColRange
//
//  Synopsis:   Returns an array of the cells located in the inclusive range
//              spanned by (iRowTop,iColLeft)-(iRowBottom,iColRight)
//
//  Arguments:  iRowTop    [in]     -- visual top row index
//              iColLeft   [in]     -- visual left col index
//              iRowBottom [in]     -- visual row index
//              iColRight  [in]     -- visual col index
//              paryCells  [in,out] -- array of table cells in range (allocated
//                                     by caller)
//
//  Returns:    Returns S_OK with array of table cells.
//
//  Note:       The rows and column indices are relative to the section
//              origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::GetCellsFromRowColRange(int iRowTop, int iColLeft, int iRowBottom, int iColRight, CPtrAry<CTableCell *> *paryCells)
{
    CTableRow *    pTableRow;
    CTableCell *   pTableCell;
    HRESULT        hr;
    CTableLayout * pTableLayout = Table() ? Table()->TableLayoutCache() : NULL;
    int            cRows, iRow, iCol;

    if (!pTableLayout)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    iRowTop = max(0, iRowTop);
    iRowBottom = min(pTableLayout->GetCols()-1, iRowBottom);
    iColLeft = max(0, iColLeft);
    iColRight = min(_cRows-1, iColRight);
    cRows = iRowBottom - iRowTop + 1;

    if (!paryCells || cRows <= 0 || iColLeft > iColRight)
    {
        hr = paryCells ? S_OK : E_POINTER;
        goto Cleanup;
    }

    // Loop from top row to bottom row.
    for (iRow = iRowTop + _iRow ; cRows ; cRows--, iRow++)
    {
        pTableRow = pTableLayout->_aryRows[iRow];
        Assert(pTableRow && !"NULL row in legal range");

        // Loop from left col to right col.
        for (iCol = iColLeft ; iCol <= iColRight ; iCol++)
        {
            Assert(pTableRow->RowLayoutCache() && "Row without CTableRowLayout");
            pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];
            if (IsReal(pTableCell))
            {
                // Add cell to array.
                paryCells->Append(pTableCell);
            }
        }
    }

Cleanup:
    RRETURN(hr);
}
#endif



HRESULT
CTableCol::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_COLGROUP) || pht->Is(ETAG_COL));
    Assert(ppElement);
    *ppElement = new CTableCol(pht->GetTag(), pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCol::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLTableCol2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCol::EnterTree, CElement
//
//  Synopsis:   Add col/colgroup to table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::EnterTree()
{
    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;
    
    if(pTableLayout)
    {
        // Only maintain the table layout cache incrementally until the table
        // has finished parsing.
        if (pTableLayout->IsCompleted())
        {
            pTableLayout->MarkTableLayoutCacheDirty();
        }
        else
        {
            hr = ( Tag() == ETAG_COLGROUP ) ?
                THR(pTableLayout->AddColGroup(this)) :
                THR(pTableLayout->AddCol(this));
        }
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCol::ComputeFormatsVirtual
//
//  Synopsis:   Compute Char and Para formats induced by this element and
//              every other element above it in the HTML tree.
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//  Note:       We override this here to put our defaults into the format
//              FIRST, and also to cache vertical alignment here in the object
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget)
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    HRESULT hr;

    Assert(pNodeTarget && SameScope(this, pNodeTarget));

    //check column left

    // iCol is -1 if col is not in markup, and 0 if it is the first, ...
    if (_iCol >= 0)
    {
        CTable * pTable = Table();

        if (!pTable)
            goto DontStealFormat;

        // Note:  We are not doing a pTableLayout->EnsureTableLayoutCache()
        // even though the current version might be dirty (can happen in
        // databinding).  In those cases we WANT to work with the old version
        // in case elements would disappear on us.

        CTableLayout * pTableLayout = pTable->TableLayoutCache();

        WHEN_DBG( BOOL fDisableTLCAssert = pTableLayout->_fDisableTLCAssert; pTableLayout->_fDisableTLCAssert = TRUE; )
        CTableCol * pCol = pTableLayout->GetCol(_iCol - 1);
        WHEN_DBG( pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )

        CTreeNode * pNodeCol = pCol ? pCol->GetFirstBranch() : NULL;

        //
        // See comment in CTableRow::ComputeFormats
        //

        if (pCol && pNodeCol && pNodeCol->_iPF >= 0 && pNodeCol->_iCF >= 0 && pNodeCol->_iFF >= 0 &&
            pCol->_fStealingAllowed &&
            SameScope(pNodeTarget->Parent(), pNodeCol->Parent()) &&
            (_pAA == NULL && pCol->_pAA == NULL ||
             _pAA != NULL && pCol->_pAA != NULL && _pAA->Compare(pCol->_pAA)) )
        {
            THREADSTATE * pts = GetThreadState();

            // At least one of the caches is dirty.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iCF == -1 || pNodeTarget->_iFF == -1);

            // The caches that were not dirty, have to match with the corresponding caches of
            // the previous column.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iPF == pNodeCol->_iPF);
            Assert(pNodeTarget->_iCF == -1 || pNodeTarget->_iCF == pNodeCol->_iCF);
            Assert(pNodeTarget->_iFF == -1 || pNodeTarget->_iFF == pNodeCol->_iFF);

            //
            // Selectively copy down each of the dirty caches.
            //

            if (pNodeTarget->_iPF == -1)
            {
                pNodeTarget->_iPF = pNodeCol->_iPF;
                (pts->_pParaFormatCache)->AddRefData( pNodeCol->_iPF );
                MtAdd(Mt(ParaFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iCF == -1)
            {
                pNodeTarget->_iCF = pNodeCol->_iCF;
                (pts->_pCharFormatCache)->AddRefData( pNodeCol->_iCF );
                MtAdd(Mt(CharFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iFF == -1)
            {
                pNodeTarget->_iFF = pNodeCol->_iFF;
                (pts->_pFancyFormatCache)->AddRefData( pNodeCol->_iFF );
                MtAdd(Mt(FancyFormatSteal), 1, 0);
            }

            // Set the _fBlockNess cache bit on the node to save a little time later.
            // Need to do this here because we don't call super.
            pNodeTarget->_fBlockNess = TRUE;

            hr = S_OK;
            goto Cleanup;
        }
    }

DontStealFormat:

    hr = THR(super::ComputeFormatsVirtual(pCFI, pNodeTarget));

Cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    // clear back color, width/height and alignment coming from the table

    if (Tag() == ETAG_COLGROUP)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff().ClearWidth();
        pCFI->_ff().ClearHeight();
        pCFI->_ff()._bPageBreaks = 0;
        pCFI->UnprepareForDebug();

        pCFI->_bBlockAlign     = htmlBlockAlignNotSet;
        pCFI->_bCtrlBlockAlign = htmlBlockAlignNotSet;
    }

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureCols
//
//  Synopsis:   Make sure the table column count includes this column
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CTableCol::EnsureCols()
{
    CTableLayout * pTableLayout = Table() ? Table()->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;
    int c;

    if (pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;

        c = pTableLayout->GetCols();
        Assert (_iCol + Cols() <= c);
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableColCalc::AdjustMaxToUserWidth
//
//  Synopsis:   Adjust max width to user set width when appropriate
//
//-------------------------------------------------------------------------

void
CTableColCalc::AdjustMaxToUserWidth(CCalcInfo * pci, CTableLayout * pTableLayout)
{
    if (IsWidthSpecified() && !IsWidthSpecifiedInPercent())
    {
        _xMax = GetPixelWidth(pci, pTableLayout->ElementOwner(), 2 * pTableLayout->CellPaddingX());
    }
    if (_xMax < _xMin)
    {
        _xMax = _xMin;
    }
}

HRESULT
CTableCol::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT        hr = S_OK;
    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    CTableCell   * pCell;
    CTableRow    * pRow;
    int            i, iLast, cR, iRow;
    BOOL           fDirtyCache;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if(hr || !pTableLayout)
        goto Cleanup;


    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    iLast = _iCol + _cCols;
    
    fDirtyCache = FALSE;

    // walk all the cells of this column and mark them dirty/clear caches
    for (cR = pTableLayout->GetRows(), iRow = pTableLayout->GetFirstRow();
        cR > 0;
        cR--, iRow = pTableLayout->GetNextRow(iRow))
    {
        pRow = pTableLayout->_aryRows[iRow];
        if ( pRow == NULL )
            continue;
        for (i = _iCol; i < iLast; i++)
        {
            pCell = Cell(pRow->RowLayoutCache()->GetCell(i));
            if ( pCell == NULL )
                continue;

            //TODO: add ppropdesc param to onpropertychange after making sure that dispid is not SPAN (or making adjustments)
            hr = THR( pCell->OnPropertyChange(dispid, dwFlags) );       // NOTE: this can make current layout cache dirty
            if (hr)
                goto Cleanup;
            if (!pTableLayout->IsTableLayoutCacheCurrent())
            {
                fDirtyCache = TRUE;
                pTableLayout->MarkTableLayoutCacheCurrent();
            }
        }
    }

    if (fDirtyCache)
        pTableLayout->MarkTableLayoutCacheDirty();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableCol::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableCol::Notify(CNotification *pNF)
{
    DWORD dw = pNF->DataAsDWORD();

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        if (Table())
        {
            EnterTree();
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if (!(dw & EXITTREE_DESTROY))
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

            if (!pTableLayout)
                break;

            // if column / colgroup leaves the tree because of other reasons than markup destroying 
            // need to update TableLayoutCache to prevent accessing out-of-date data 
            // (CTableCell::ComputeFormatsVirutal is one such a place)
            pTableLayout->Fixup();
        }
        break;
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableRow::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableRow::Notify(CNotification *pNF)
{
    DWORD           dw = pNF->DataAsDWORD();

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
            RowLayoutCache();
            _iRow = -1;

            if (!(dw & ENTERTREE_PARSE) && !(dw & ENTERTREE_MOVE))  // if the element cretead NOT via PARSing nor MOVing HTML
            {
                _fCompleted = TRUE; // we are not going to have NTYPE_END_PARSE notification to set the _fCompleted bit
            }
            if (pTableLayout)
            {
                if (!(dw & ENTERTREE_PARSE))
                {
                    pTableLayout->_fDontSaveHistory = TRUE;
                }
                if (dw & ENTERTREE_MOVE)   // if it is a MOVTREE notification
                {
                    // the subtree was moved
                    if (pTableLayout->_fPastingRows)
                    {
                        Assert (pTable->IsDatabound() && pTableLayout->IsRepeating());
                        pTableLayout->AddRow(this, FALSE);
                    }
                    else
                    {
                        pTableLayout->MarkTableLayoutCacheDirty();
                    }
                }
                else
                {
                    EnterTree();
                }
            }
            break;
        }

    case NTYPE_ELEMENT_EXITTREE_1:
        if (!(dw & EXITTREE_DESTROY))
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

            if (!pTableLayout)
                break;

            // don't update the rows caches for individual rows in case of :1) shutdown; 2) data-binding removing rows
            // But, don't hold refs to the tree after our element leaves it
            if (    !pTableLayout->_fRemovingRows 
                &&  !GetMarkup()->_fTemplate 
                &&  (   !pTable->_fExittreePending 
                    //  (bug # 2623) row caches should be updated when leaving windowed markup. 
                    //  In situation when something holds a reference to the row and use the reference 
                    //  after table is destroyed this row may return pointer to "dead" cells thru non-updated 
                    //  caches. 
                    ||  GetMarkup()->IsConnectedToPrimaryMarkup())   )
            {
                ExitTree(pTableLayout);
            }
        }

        break;

    case NTYPE_END_PARSE:
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

            Assert (!_fCompleted && "NTYPE_END_PARSE notification happened more then once");

            _fCompleted = TRUE;     // loading/parsing of the row is complete.

            if (pTableLayout && pTableLayout->_fAllRowsSameShape && pTableLayout->_cCols != pTableLayout->_cTotalColSpan)
            {
                pTableLayout->_fAllRowsSameShape = FALSE;
            }
        }
        break;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::EnterTree, CElement
//
//  Synopsis:   Add row to table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::EnterTree()
{
    HRESULT hr = S_OK;

    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

    if (pTableLayout)
    {
        // Only maintain the table layout cache incrementally until the table
        // has finished parsing.
        if (pTableLayout->IsCompleted() && !pTableLayout->_fTableOM)
        {
            pTableLayout->MarkTableLayoutCacheDirty();
        }
        else
        {
            pTableLayout->_cRowsParsed++;
            hr = pTableLayout->AddRow(this);
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN(hr);
}


void
CTableRow::ExitTree(CTableLayout *pTableLayout)
{
    CTableRowLayout *pRowLayout = RowLayoutCache();
    
    Assert (pRowLayout);

    // 1. clear row layout cache, this also invalidates the collection
    pRowLayout->ClearRowLayoutCache();
    
    // 2. delete from the array of rows and update table caches accordingly
    pTableLayout->RowExitTree(_iRow, Section());

    _iRow = -1;
}


// TableRow needs to expose client* properties, but it doesn't
// inherit from IHTMLControlElement.  Since interfaces are
// immutable, to fix 60731 we add a new interface IHTMLTableRowMetrics
// to expose the client* properties.

//+----------------------------------------------------------
//
//  member  :   get_clientWidth, IHTMLTableRowMetrics
//
//  synopsis    :   returns a long value of the client window
//      width (not counting scrollbar, borders..)
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientWidth( long * pl)
{
    HRESULT hr=S_OK;
    RECT    rect;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    RowLayoutCache()->GetClientRect(&rect, CLIENTRECT_CONTENT);

    *pl = g_uiDisplay.DocPixelsFromDeviceX(rect.right - rect.left);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientHeight, IHTMLTableRowMetrics
//
//  synopsis    :   returns a long value of the client window
//      Height of the body
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientHeight( long * pl)
{
    HRESULT hr=S_OK;
    RECT    rect;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    RowLayoutCache()->GetClientRect(&rect, CLIENTRECT_CONTENT);

    *pl = g_uiDisplay.DocPixelsFromDeviceY(rect.bottom - rect.top);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientTop, IHTMLTableRowMetrics
//
//  synopsis    :   TableRows can't have borders (in 4.x), so
//      just return 0.  This needs to exist so that scripts
//      can walk up the offsetParent chain from inside tables
//      and sum clientTops + offsetTops.
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientTop( long * pl)
{
    HRESULT hr=S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------
//
//  member  :   get_clientLeft, IHTMLTableRowMetrics
//
//  synopsis    :   TableRows can't have borders (in 4.x), so
//      just return 0.  This needs to exist so that scripts
//      can walk up the offsetParent chain from inside tables
//      and sum clientTops + offsetTops.
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientLeft( long * pl)
{
    HRESULT hr=S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\adosecur.h ===
#ifndef _ADOSECURITY_H_
#define _ADOSECURITY_H_

interface IADOSecurity: public IUnknown
    {
    public:
		virtual HRESULT STDMETHODCALLTYPE SetURL(BSTR bstrURL) = 0;
		virtual HRESULT STDMETHODCALLTYPE SetSafe(BOOL fSafe) = 0;
    };

// {782D16AE-905F-11d1-AC38-00C04FC29F8F}
DEFINE_GUID(IID_IADOSecurity, 0x782d16ae, 0x905f, 0x11d1, 0xac, 0x38, 0x0, 0xc0, 0x4f, 0xc2, 0x9f, 0x8f);

// {332c4425-26cb-11d0-b483-00c04fd90119}
DEFINE_GUID(IID_IHTMLDocument2, 0x332c4425, 0x26cb, 0x11d0, 0xb4, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0x01, 0x19);

// {79eac9ee-baf9-11ce-8c82-00aa004ba90b}
DEFINE_GUID(IID_IInternetSecurityManager, 0x79eac9ee, 0xbaf9, 0x11ce, 0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

// {7b8a2d94-0ac9-11d1-896c-00c04Fb6bfc4}
DEFINE_GUID(CLSID_InternetSecurityManager, 0x7b8a2d94, 0x0ac9, 0x11d1, 0x89, 0x6c, 0x00, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\builtin\textarea.cxx ===
//+---------------------------------------------------------------------
//
//   File:      textarea.cxx
//
//  Contents:   <TEXTAREA> <HTMLAREA>
//
//  Classes:    CTextarea, CRichtext
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXt_H_
#include "_text.h"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

EXTERN_C const GUID DIID_HTMLInputTextElementEvents;

#define _cxx_
#include "textarea.hdl"

MtDefine(CRichtext, Elements, "CRichtext")
MtDefine(CTextArea, Elements, "CTextArea")


CElement::ACCELS CRichtext::s_AccelsTextareaRun    = CElement::ACCELS (NULL, IDR_ACCELS_INPUTTXT_RUN);

//+------------------------------------------------------------------------
//
//  Member:     CElement::s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------


const CElement::CLASSDESC CTextArea::s_classdesc =
{
    {
        &CLSID_HTMLTextAreaElement,     // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLTextAreaElement,      // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTextAreaElement, // _pfnTearOff
    &s_AccelsTextareaRun                // _pAccelsRun
};

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::CreateElement()
//
//  Synopsis:   called by the parser to create an instance
//
//-------------------------------------------------------------------------

HRESULT
CTextArea::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CTextArea(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------
HRESULT
CTextArea::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    HRESULT hr  = S_OK;

    Assert(!_fInSave);
    _fInSave = TRUE;

    if (!fEnd)
    {
        pStmWrBuff->BeginPre();
    }

    hr = super::Save(pStmWrBuff, fEnd);

    if(hr)
        goto Cleanup;

    if (    fEnd 
        &&  (   !pStmWrBuff->GetElementContext() 
             || GetFirstCp() >= pStmWrBuff->GetElementContext()->GetFirstCp() ) )
    {
        pStmWrBuff->EndPre();
    }

    Assert(_fInSave); // this will catch recursion
    _fInSave = FALSE;

Cleanup:
    RRETURN(hr);
}

DWORD
CTextArea::GetBorderInfo(
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fAll,
    BOOL            fAllPhysical
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    HTHEME hTheme   = GetTheme(THEME_EDIT);

    if (!hTheme)
    {
        return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    }
    else
    {
        RECT rcBg;

        THR(GetThemeBackgroundExtent(
                                            hTheme,
                                            NULL,
                                            EP_EDITTEXT,
                                            ETS_NORMAL,
                                            &g_Zero.rc,
                                            &rcBg
                                        ));

        pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rcBg.left);            
        pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rcBg.right);
        pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rcBg.top);
        pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rcBg.bottom);

        return DISPNODEBORDER_SIMPLE;
    }

}

void
CTextArea::GetPlainTextWithBreaks(TCHAR * pchBuff)
{
    Assert(pchBuff);
    Assert(Layout()->GetMultiLine());

    Layout()->GetPlainTextWithBreaks( pchBuff );
}

long
CTextArea::GetPlainTextLengthWithBreaks()
{
    Assert(ShouldHaveLayout());
    Assert(Layout()->GetMultiLine());

    return Layout()->GetPlainTextLengthWithBreaks();
}

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::GetSubmitValue()
//
//  Synopsis:   returns the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CTextArea::GetSubmitValue(CStr *pstr)
{
    HRESULT hr          = S_OK;

    // Make sure the site is not detached. Otherwise, we
    // cannot get to the runs
    if (!IsInMarkup())
        goto Cleanup;

    if (GetAAwrap() == htmlWrapHard)
    {
        long len = GetPlainTextLengthWithBreaks();
        if (len > 1)
        {
            IGNORE_HR(pstr->SetLengthNoAlloc(0));
            hr = THR(pstr->ReAlloc(len));
            if (hr)
                goto Cleanup;
            GetPlainTextWithBreaks(*pstr);
        }
        else
        {
            hr = THR(GetValueHelper(pstr));
        }
    }
    else
    {
        hr = THR(GetValueHelper(pstr));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::ApplyDefaultFormat()
//
//  Synopsis:
//
//-------------------------------------------------------------------------

HRESULT
CTextArea::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    BYTE i;
    CDoc *              pDoc     = Doc();
    CODEPAGESETTINGS *  pCS      = GetMarkup()->GetCodepageSettings();
    HTHEME              hTheme   = GetMarkup()->GetTheme(THEME_EDIT);
    CUnitValue          uv;

    if (!pCS)
        pCS = pDoc->PrimaryMarkup()->GetCodepageSettings();

    COLORREF            crWindow = GetSysColorQuick(COLOR_WINDOW);
    HRESULT             hr       = S_OK;

    pCFI->PrepareFancyFormat();

    if (   !pCFI->_pff->_ccvBackColor.IsDefined()
        ||  pCFI->_pff->_ccvBackColor.GetColorRef() != crWindow)
    {
        pCFI->_ff()._ccvBackColor = crWindow;
    }

    pCFI->PrepareCharFormat();
    pCFI->PrepareParaFormat();

    pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_WINDOWTEXT);

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->_cf()._bCursorIdx = styleCursorAuto;

    pCFI->_cf()._fBold = FALSE;

    pCFI->_cf()._wWeight = FW_NORMAL; //FW_NORMAL = 400
    pCFI->_cf()._yHeight = 200;       // 10 * 20, 10 points
    
    // Thai does not have a fixed pitch font. Leave it as proportional
    if (GetMarkup()->GetCodePage() != CP_THAI)
    {
        pCFI->_cf()._bPitchAndFamily = FIXED_PITCH;
        pCFI->_cf().SetFaceNameAtom(pCS->latmFixedFontFace);
        if (pCFI->_cf().NeedAtFont())
        {
            ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
        }
    }

    pCFI->_cf()._bCharSet = pCS->bCharSet;
    pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);
    pCFI->_pf()._cuvTextIndent.SetPoints(0);
    pCFI->_fPre = TRUE;

    //
    // Prepare fancy format
    //

    // No vertical spacing between para's
    pCFI->_ff()._cuvSpaceBefore.SetPoints(0);
    pCFI->_ff()._cuvSpaceAfter.SetPoints(0);

    // Border info
    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

    uv.SetValue(2, CUnitValue::UNIT_PIXELS);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, uv);
        pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSunken);
    }
    // End Border info

    //
    // Add default padding and scrolling
    //
    
    uv.SetValue(TEXT_INSET_DEFAULT_LEFT, CUnitValue::UNIT_PIXELS);

    Assert(TEXT_INSET_DEFAULT_LEFT == TEXT_INSET_DEFAULT_RIGHT);
    Assert(TEXT_INSET_DEFAULT_LEFT == TEXT_INSET_DEFAULT_TOP);
    Assert(TEXT_INSET_DEFAULT_LEFT == TEXT_INSET_DEFAULT_BOTTOM);

    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff().SetPadding(i, uv);
    }

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    pCFI->PrepareFancyFormat();
    pCFI->PrepareCharFormat();

    // In the if statement logical/physical does not matter since we check both
    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // the control is themed
    {
        RECT                rcBg;        
        // set theme defaults for properties not already set

        if (!THR(GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rcBg)))
        {    
            if (!pCFI->_fPaddingLeftSet)
            {
                uv.SetValue( -rcBg.left + TEXT_INSET_DEFAULT_LEFT, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_LEFT, uv);
            }
            if (!pCFI->_fPaddingRightSet)
            {
                uv.SetValue( rcBg.right + TEXT_INSET_DEFAULT_RIGHT, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_RIGHT, uv);
            }
            if (!pCFI->_fPaddingTopSet)
            {
                uv.SetValue( -rcBg.top + TEXT_INSET_DEFAULT_TOP, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_TOP, uv);
            }
            if (!pCFI->_fPaddingBottomSet)
            {
                uv.SetValue( rcBg.bottom + TEXT_INSET_DEFAULT_BOTTOM, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_BOTTOM, uv);
            }
        }                   

        LOGFONT lf;

        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, TMT_FONT, &lf))
        {
            long    twips;            
            
            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick(lf.lfHeight,TWIPS_PER_INCH,g_sizePixelsPerInch.cy);

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }
    }

    if (    pCFI->_pff->GetOverflowX() == (BYTE)styleOverflowNotSet
        ||  pCFI->_pff->GetOverflowY() == (BYTE)styleOverflowNotSet)
    {
        BOOL fVerticalLayoutFlow = pCFI->_pcf->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCFI->_pcf->_fWritingModeUsed;


        if (pCFI->_pff->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed) == (BYTE)styleOverflowNotSet)
        {
            styleOverflow overflow = GetAAwrap() != htmlWrapOff
                                    ? styleOverflowHidden
                                    : styleOverflowScroll;
            if (!fVerticalLayoutFlow)
            {
                pCFI->_ff().SetOverflowX(overflow);
            }
            else
            {
                pCFI->_ff().SetOverflowY(overflow);
            }
        }

        if (pCFI->_pff->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed) == (BYTE)styleOverflowNotSet)
        {
            if (!fVerticalLayoutFlow)
            {
                pCFI->_ff().SetOverflowY(styleOverflowScroll);
            }
            else
            {
                pCFI->_ff().SetOverflowX(styleOverflowScroll);
            }
        }
    }

    // font height in CharFormat is already nonscaling size in twips
    pCFI->_cf().SetHeightInNonscalingTwips( pCFI->_cf()._yHeight );

    pCFI->UnprepareForDebug();

    FixupEditable(pCFI);

Cleanup:
    RRETURN(hr);
}

// Richtext member functions

const CElement::CLASSDESC CRichtext::s_classdesc =
{
    {
        &CLSID_HTMLRichtextElement,      // _pclsid
        0,                               // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                          // _pcpi
        ELEMENTDESC_TEXTSITE          |
        ELEMENTDESC_SHOWTWS           |
        ELEMENTDESC_ANCHOROUT         |
        ELEMENTDESC_NOBKGRDRECALC     |
        ELEMENTDESC_CANSCROLL         |
        ELEMENTDESC_HASDEFDESCENT     |
        ELEMENTDESC_NOTIFYENDPARSE,      // _dwFlags
        &IID_IHTMLTextAreaElement,       // _piidDispinterface
        &s_apHdlDescs,                   // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTextAreaElement, // _pfnTearOff
    &s_AccelsTextareaRun        // _pAccelsRun
};

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::CreateElement()
//
//  Synopsis:   called by the parser to create instance
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CRichtext(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}



//+------------------------------------------------------------------------
//
//  Member:     CRichtext::Init2()
//
//  Synopsis:   called by the parser to initialize instance
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;

    hr = THR(super::Init2(pContext));
    if (!OK(hr))
        goto Cleanup;

#ifdef  NEVER
    if (Tag() == ETAG_HTMLAREA)
    {
        SetAAtype(htmlInputRichtext);
    }
    else
#endif
    {
        Assert(Tag() == ETAG_TEXTAREA);
        SetAAtype(htmlInputTextarea);
    }

    _fReadOnly = !!GetAAreadOnly();

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}


//+------------------------------------------------------------------------
//
//  Member:     CRichtext::EnterTree
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::EnterTree()
{
    HRESULT                    hr = S_OK;
    CMarkup *             pMarkup = GetMarkup(); Assert(pMarkup);
    CMarkupTransNavContext * ptnc = pMarkup->EnsureTransNavContext();

    if (!ptnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _iHistoryIndex  = (unsigned short)ptnc->_dwHistoryIndex++;

Cleanup:
    RRETURN(hr);
}

int
CRichtext::GetThemeState()
{
    //
    // TODO: need more states
    //
    if (!IsEnabled())
    {
        return ETS_DISABLED;
    }
    return ETS_NORMAL;
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr          = S_OK;

    switch (dispid)
    {
    case DISPID_CRichtext_wrap:
        Layout()->SetWrap();
        break;

    case DISPID_CRichtext_readOnly:
        _fReadOnly = !!GetAAreadOnly();
        // update the editability in the edit context
        break;

    case DISPID_CRichtext_value:
        _fTextChanged = TRUE;
        break;
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CRichtext::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD   * pCmd = & rgCmds[0];
    ULONG      cmdID;

    Assert(!pCmd->cmdf);

    cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );
    switch (cmdID)
    {
    case IDM_INSERTOBJECT:
        // Don't allow objects to be inserted in TEXTAREA
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        return S_OK;

    default:
        RRETURN_NOTRACE(super::QueryStatus(
            pguidCmdGroup,
            1,
            pCmd,
            pcmdtext));
    }
}


HRESULT
CRichtext::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int      idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT  hr  = MSOCMDERR_E_NOTSUPPORTED;

    switch (idm)
    {
    case IDM_SELECTALL:
        select();
        hr = S_OK;
        break;
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = super::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut);
    }

    RRETURN_NOTRACE(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::DelayLoadHistoryValue()
//
//  Synopsis:   DelayedLoadHistory will call this
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::DelayLoadHistoryValue()
{
    HRESULT hr      = S_OK;
    CStr    cstrVal;
    DWORD   dwTemp;
    DWORD   dwScrollPos = 0;
    CMarkup * pMarkup = GetMarkup();
    DWORD   dwHistoryIndex = 0x80000000 | (DWORD)_iHistoryIndex & 0x0FFFF;

    // Load the history stream
    IGNORE_HR(pMarkup->GetLoadHistoryStream(dwHistoryIndex, 
                                HistoryCode(), 
                                &_pStreamHistory));

    if (_pStreamHistory && !pMarkup->_fUserInteracted)
    {
        CDataStream ds(_pStreamHistory);
        DWORD   dwEncoding;

        // Load encoding changing history
        hr = THR(ds.LoadDword(&dwEncoding));
        if (hr)
            goto Cleanup;

        if (!dwEncoding)
        {            
            // load value
            hr = THR(ds.LoadCStr(&cstrVal));
            if (hr)
                goto Cleanup;

            // load _fTextChanged
            hr = THR(ds.LoadDword(&dwTemp));
            if (hr)
                goto Cleanup;

            _fTextChanged = dwTemp ? TRUE : FALSE;

            if (_fTextChanged)
            {
                hr = THR(SetValueHelperInternal(&cstrVal));
                if (hr)
                    goto Cleanup;

                IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                           0, 
                                           (PROPERTYDESC *)&s_propdescCRichtextvalue));
            }
        }

        // load scroll pos
        hr = THR(ds.LoadDword(&dwScrollPos));
        if (hr)
            goto Cleanup;

        {
            CLayout *pLayout = Layout();
            CDispNode   *pDispNode = pLayout->GetElementDispNode();
            if (pDispNode && pDispNode->IsScroller())
            {
                pLayout->ScrollToY(dwScrollPos);
            }
        }

        //
        // we might insert new elements, we need to ensure the tree cache
        // is up to date
        //
    }
Cleanup:
    ClearInterface(&_pStreamHistory);
    RRETURN(hr);
}

/*
//+------------------------------------------------------------------------
//
//  Member:     CRichtext::LoadHistoryValue()
//
//  Synopsis:   Load history
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::LoadHistoryValue()
{
    HRESULT hr = S_OK;
    CStr    cstrVal;
    DWORD   dwTemp;

    if (_pStreamHistory)
    {
        CDataStream ds(_pStreamHistory);
    }
Cleanup:
    RRETURN(hr);
}

*/

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::SaveHistoryValue()
//
//  Synopsis:   save history:
//                              - value
//                              - _fTextChanged
//                              - scroll position
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::SaveHistoryValue(CHistorySaveCtx *phsc)
{
    CDataStream ds;
    HRESULT     hr      = S_OK;
    IStream *   pStream = NULL;
    CStr        cstrVal;
    DWORD       dwHistoryIndex;

    Assert(phsc);
    if (!phsc)
        goto Cleanup;

    dwHistoryIndex = 0x80000000 | (DWORD)_iHistoryIndex & 0x0FFFF;
    hr = THR(phsc->BeginSaveStream(dwHistoryIndex, HistoryCode(), &pStream));
    if (hr)
        goto Cleanup;

    ds.Init(pStream);

    hr = THR(ds.SaveDword(_fChangingEncoding ? 1 : 0));
    if (hr)
        goto Cleanup;
    if (!_fChangingEncoding)
    {
        // save value
        hr = THR(GetValueHelper(&cstrVal));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveCStr(&cstrVal));
        if (hr)
            goto Cleanup;

        // save _fTextChanged
        hr = THR(ds.SaveDword(_fTextChanged ? 1 : 0));
        if (hr)
            goto Cleanup;
    }

    // save scroll pos
    hr = THR(ds.SaveDword(Layout()->GetYScroll()));
    if (hr)
        goto Cleanup;

    hr = THR(phsc->EndSaveStream());
    if (hr)
        goto Cleanup;
Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CRichtext::Notify()
//
//  Synopsis:   handle notifications
//
//-------------------------------------------------------------------------

void
CRichtext::Notify(CNotification *pNF)
{
    IMarkupPointer* pStart = NULL;
    IHTMLElement* pIElement = NULL;
    HRESULT hr = S_OK;
    BOOL fRefTaken = FALSE;
    
    if (pNF->Type() != NTYPE_DELAY_LOAD_HISTORY)
    {
        super::Notify(pNF);
    }
    switch (pNF->Type())
    {

    case NTYPE_ELEMENT_GOTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && IsEditable(/*fCheckContainerOnly*/FALSE) )
        {
            CDoc* pDoc = Doc();
            fRefTaken = TRUE;
            hr = THR( pDoc->CreateMarkupPointer( & pStart ));
            if ( hr )
                goto Cleanup;
            
            hr = THR( this->QueryInterface( IID_IHTMLElement, (void**) & pIElement ));
            if ( hr )
                goto Cleanup;

            hr = THR( pStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeEnd ) );
            if ( hr )
                goto Cleanup;

            hr = THR( pDoc->Select( pStart, pStart, SELECTION_TYPE_Caret));                
            if ( hr )
                goto Cleanup;
        }                 
    }            
    break;

    case NTYPE_ELEMENT_LOSTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && IsEditable(/*fCheckContainerOnly*/FALSE) )
        {
            Doc()->DestroyAllSelection();
        }                 
    }        
    break;

    case NTYPE_SAVE_HISTORY_1:
        pNF->SetSecondChanceRequested();
        break;
 
    case NTYPE_SAVE_HISTORY_2:
        {
            CHistorySaveCtx *   pCtx = NULL;

            pNF->Data((void **)&pCtx);
            IGNORE_HR(SaveHistoryValue(pCtx));
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        IGNORE_HR(DelayLoadHistoryValue());
        super::Notify(pNF);
        break;

    case NTYPE_END_PARSE:
        GetValueHelper(&_cstrDefaultValue);
        _fLastValueSet = FALSE;
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        ClearInterface(&_pStreamHistory);
        break;

    case NTYPE_SET_CODEPAGE:
        _fChangingEncoding = TRUE;
        break;
    }

Cleanup:
    if ( fRefTaken )
    {
        ReleaseInterface( pStart );
        ReleaseInterface( pIElement );
    }
    
}


//+------------------------------------------------------------------------
//
//  Member:     CRichtext::GetValueHelper()
//
//  Synopsis:   returns the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::GetValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;

    if (Tag()==ETAG_TEXTAREA)
    {
        hr = THR(GetPlainTextInScope(pstr));
    }
    else
    {
        BSTR    bStrValue;

#ifdef  NEVER
        Assert(Tag()==ETAG_HTMLAREA);
#endif
        hr = THR(GetText(&bStrValue, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));;
        if (hr)
            goto Cleanup;

        Assert(pstr);
        hr = pstr->SetBSTR(bStrValue);
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::GetSubmitValue()
//
//  Synopsis:   returns the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::GetSubmitValue(CStr *pstr)
{
    RRETURN(GetValueHelper(pstr));
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::GetWordWrap()
//
//  Synopsis:   Callback to tell if the word wrap should be done
//
//-------------------------------------------------------------------------

BOOL
CRichtext::GetWordWrap() const
{
    return  htmlWrapOff == GetAAwrap() ? FALSE : TRUE;
}

HRESULT
CRichtext::SetValueHelperInternal(CStr *pstr, BOOL fOM /* = TRUE */)
{
    HRESULT hr = S_OK;
    int c= pstr->Length();

#ifdef  NEVER
    Assert(Tag()==ETAG_HTMLAREA || Tag()==ETAG_TEXTAREA);
#else
    Assert(Tag()==ETAG_TEXTAREA);
#endif
    Assert(pstr);

#ifdef  NEVER
    hr = THR( Inject( Inside, Tag() == ETAG_HTMLAREA, *pstr, c ) );
#else
    hr = THR( Inject( Inside, FALSE, *pstr, c ) );
#endif

#ifndef NO_DATABINDING
    if (SUCCEEDED(hr))
    {
        hr = SaveDataIfChanged(ID_DBIND_DEFAULT);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }
    }
#endif

    // Set this to prevent OnPropertyChange(_Value_) from firing twice
    // when value is set through OM. This flag is cleared in OnTextChange().
    _fFiredValuePropChange = fOM;

    // TODO, make sure this is covered when turns the HTMLAREA on
    _cstrLastValue.Set(*pstr, c);
    _fLastValueSet = TRUE;
    _fTextChanged = FALSE;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::SetValueHelper()
//
//  Synopsis:   set the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::SetValueHelper(CStr *pstr)
{
    return SetValueHelperInternal(pstr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if there is a value
//              (name && value pair)
//
//  Returns:    S_OK if successful
//              E_NOTIMPL if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CRichtext::GetSubmitInfo(CPostData * pSubmitData)
{
    LPCTSTR pstrName = GetAAsubmitname();

    //  no name --> no submit!
    if ( ! pstrName )
        return S_FALSE;

    CStr    cstrValue;
    HRESULT hr = GetSubmitValue(&cstrValue);
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->AppendNameValuePair(pstrName, cstrValue, GetMarkup()));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRichtext::createTextRange
//
//----------------------------------------------------------------------------
HRESULT
CRichtext::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT hr = S_OK;

    hr = THR( EnsureInMarkup() );
    
    if (hr)
        goto Cleanup;

    hr = THR( GetMarkup()->createTextRange( ppDisp, this ) );
    
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

HRESULT BUGCALL
CRichtext::select(void)
{
    HRESULT             hr          = S_OK;
    CMarkup *           pMarkup     = GetMarkup();
    CDoc *              pDoc        = Doc();
    CMarkupPointer      ptrStart(pDoc);
    CMarkupPointer      ptrEnd(pDoc); 
    IMarkupPointer *    pIStart; 
    IMarkupPointer *    pIEnd; 

    if (!pMarkup)
        goto Cleanup;

#if 0
    hr = pDoc->SetEditContext(this, TRUE, FALSE);
#else
    hr = BecomeCurrent(0);
#endif
    if (hr)
        goto Cleanup;

    hr = ptrStart.MoveToCp(GetFirstCp(), pMarkup);
    if (hr)
        goto Cleanup;
    hr = ptrEnd.MoveToCp(GetLastCp(), pMarkup);
    if (hr)
        goto Cleanup;
    Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
    Verify(S_OK == ptrEnd.QueryInterface(IID_IMarkupPointer, (void**)&pIEnd));
    hr = pDoc->Select(pIStart, pIEnd, SELECTION_TYPE_Text);
    pIStart->Release();
    pIEnd->Release();
Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CRichtext::RequestYieldCurrency
//
//  Synopsis:   Check if OK to Relinquish currency
//
//  Arguments:  BOOl fForce -- if TRUE, force change and ignore user cancelling the
//                             onChange event
//
//  Returns:    S_OK: ok to yield currency
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::RequestYieldCurrency(BOOL fForce)
{
    CStr    cstr;
    HRESULT hr = S_OK;

    if ((hr = GetValueHelper(&cstr)) == S_OK)
    {
        BOOL fFire =  FormsStringCmpLoc(cstr,
                            _fLastValueSet ?
                                _cstrLastValue : _cstrDefaultValue)
                        != 0;

        if (!fFire)
            goto Cleanup;

        if (!Fire_onchange())   //JS event
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = super::RequestYieldCurrency(fForce);
        if (hr == S_OK)
        {
            _cstrLastValue.Set(cstr);
            _fLastValueSet = TRUE;
        }
    }

Cleanup:
    if (fForce && FAILED(hr))
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CRichText::BecomeUIActive
//
//  Synopsis:   Check imeMode to set state of IME.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::BecomeUIActive()
{
    HRESULT hr = S_OK;

    hr = THR(super::BecomeUIActive());
    if (hr)
        goto Cleanup;

    hr = THR(SetImeState());
    if (hr)
        goto Cleanup;

Cleanup:    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CRichtext::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pSiteNew    New site that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr;

    _fDoReset = FALSE;

    Assert(ShouldHaveLayout());

    hr = THR(super::YieldCurrency(pElemNew));

    RRETURN(hr);
}


HRESULT BUGCALL
CRichtext::HandleMessage(CMessage * pMessage)
{
    HRESULT         hr = S_FALSE;
    CFormElement *  pForm;
    BOOL    fEditable = IsEditable(TRUE);

    if ( !CanHandleMessage() ||
         (!fEditable && !IsEnabled()) )
    {
        goto Cleanup;
    }

    if (!fEditable && _fDoReset)
    {
        if (pMessage->message == WM_KEYDOWN && pMessage->wParam == VK_ESCAPE)
        {
            pForm = GetParentForm();
            if (pForm)
            {
                _fDoReset = FALSE;
                hr = THR(pForm->DoReset(TRUE));
                if (hr != S_FALSE)
                    goto Cleanup;
            }
        }
        else if (pMessage->message >= WM_KEYFIRST &&
                pMessage->message <= WM_KEYLAST &&
                pMessage->wParam != VK_ESCAPE)
        {
            _fDoReset = FALSE;
        }
    }

    switch (pMessage->message)
    {
        case WM_RBUTTONDOWN:
            // Ignore right-click (single click) if the input text box has focus.
            // This prevents the selected contents in an input text control from
            // being loosing selection.

            //
            // marka - we only do this for browse mode. Why ? We want going UI Active
            // to be under mshtmled's rules (ie first click site select, second drills in)
            //
            if ( ! IsEditable(/*fCheckContainerOnly*/TRUE) )
            {
                hr = THR(BecomeCurrent(pMessage->lSubDivision));
            }                
            goto Cleanup;
            
        // We handle all WM_CONTEXTMENUs
        case WM_CONTEXTMENU:
            hr = THR(OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
            goto Cleanup;
    }

    if (!fEditable &&
        pMessage->message == WM_KEYDOWN &&
        pMessage->wParam == VK_ESCAPE)
    {
        _fDoReset = TRUE;
        SetValueHelperInternal(_fLastValueSet ? &_cstrLastValue : &_cstrDefaultValue, FALSE);
        hr = S_FALSE;
        goto Cleanup;
    }

    // Let supper take care of event firing
    // Since we let TxtEdit handle messages we do JS events after
    // it comes back
    hr = super::HandleMessage(pMessage);

Cleanup:

    RRETURN1(hr, S_FALSE);
}


HRESULT
CRichtext::put_status(VARIANT status)
{
    switch(status.vt)
    {
    case VT_NULL:
        _vStatus.vt = VT_NULL;
        break;
    case VT_BOOL:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = V_BOOL(&status);
        break;
    default:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = VB_TRUE;
    }

    Verify(S_OK==OnPropertyChange(DISPID_CRichtext_status, 
                                  0, 
                                  (PROPERTYDESC *)&s_propdescCRichtextstatus));

    RRETURN(S_OK);
}

HRESULT
CRichtext::get_status(VARIANT * pStatus)
{
    if (_vStatus.vt==VT_NULL)
    {
        pStatus->vt = VT_NULL;
    }
    else
    {
        pStatus->vt = VT_BOOL;
        V_BOOL(pStatus) = V_BOOL(&_vStatus);
    }
    RRETURN(S_OK);
}


HRESULT
CRichtext::DoReset(void)
{
    RRETURN(SetValueHelperInternal(&_cstrDefaultValue));
}

#ifndef NO_DATABINDING
class CDBindMethodsTextarea : public CDBindMethodsText
{
    typedef CDBindMethodsText super;
public:
    CDBindMethodsTextarea() : super(0)   {}
    ~CDBindMethodsTextarea()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;
};

static const CDBindMethodsTextarea DBindMethodsTextarea;

const CDBindMethods *
CRichtext::GetDBindMethods()
{
    return &DBindMethodsTextarea;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: transfer bound data to textarea element.  We need to override
//            the CElement implementation to remember the value being
//            transferred as the "last value".  This keeps the onchange event
//            from firing simply because the value is databound.
//
//  Arguments:
//            [id]      - ID of binding point.
//            [fHTML]   - is HTML-formatted data called for?
//            [pvData]  - pointer to data to transfer, in the expected data
//                        type.  For text-based transfers, must be BSTR.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsTextarea::BoundValueToElement ( CElement *pElem,
                                                 LONG id,
                                                 BOOL fHTML,
                                                 LPVOID pvData ) const
{
    HRESULT hr = super::BoundValueToElement(pElem, id, fHTML, pvData);    // do the transfer
    if (!hr)
    {
        // NOTE: We were relying on OnTextChange to fire PropertyChange
        // event for value, but this is not reliable if the page is loading
        // and our layout is not listening to notification yet.
        // 

        Assert(pElem->Tag() == ETAG_TEXTAREA);
        CRichtextLayout *pLayout = DYNCAST(CRichtext, pElem)->Layout();

        if (!pLayout || !pLayout->IsListening())
        {
            Verify(!pElem->OnPropertyChange(DISPID_A_VALUE, 0));
        }
        // remember the value
        CRichtext *pElemRT = DYNCAST(CRichtext, pElem);
        pElemRT->_cstrLastValue.Set(*(LPCTSTR*)pvData);
        pElemRT->_fLastValueSet = TRUE;
    }
    return hr;
}
#endif // ndef NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\binder.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1996
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Source Binder objects
//
//  Classes:    CDataSourceBinder
//
//  History:    10/1/96     (sambent) created

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_MSTDWRAP_H_
#define X_MSTDWRAP_H_
#include "mstdwrap.h"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

MtDefine(DataBind, Mem, "Data Binding")
MtDefine(CDataSourceBinder, DataBind, "CDataSourceBinder")
MtDefine(CCurrentRecordInstance, DataBind, "CCurrentRecordInstance")
MtDefine(CDataSourceProvider, DataBind, "CDataSourceProvider")
MtDefine(CDataSourceProvider_aryAdvisees_pv, CDataSourceProvider, "CDataSourceProvider::_aryAdvisees::_pv")

/////////////////////////////////////////////////////////////////////////////
/////                    CDataSourceBinder methods                      /////
/////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
//  Member:     Passivate
//
//  Synopsis:   revert to pre-init state
//

HRESULT
CDataSourceBinder::Passivate()
{
    HRESULT hr;

    // During binding, we may trigger events that cause the binder to go away.
    // If so, simply set a flag and do the real shutdown later (see TryToBind).
    // An example of this situation (which only Neetu would ever dream of):
    // I'm the first element trying to bind to provider foo, doing so triggers
    // foo.ondatasetcomplete, the handler changes dataFld on my element.
    if (_fBinding)
    {
        _fAbort = TRUE;
        hr = S_OK;
        goto Cleanup;
    }

    if (_fOnTaskList)
    {
        CDataBindTask *pdbt = GetDataBindTask();
        if (pdbt)
        {
            pdbt->RemoveDeferredBinding(this);
        }
    }

    hr = UnBind();

    ClearInterface(&_pConsumer);

    delete this;

Cleanup:
    return hr;
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   go away
//

CDataSourceBinder::~CDataSourceBinder()
{
    Assert("Passivate must be called first" &&
        !_pConsumer && !_pProvider
        );
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     GetDataBindTask
//
//  Synopsis:   return the task that owns me

CDataBindTask *
CDataSourceBinder::GetDataBindTask()
{
    CMarkup *pMarkup = _pelConsumer->GetMarkup();
    
    return pMarkup ? pMarkup->GetDataBindTask() : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     SetReady
//
//  Synopsis:   set the "readiness" of the binder.  If it becomes ready, notify
//              the task that it's worth trying to bind.

void
CDataSourceBinder::SetReady(BOOL fReady)
{
    _fNotReady = !fReady;
    if (fReady && _fOnTaskList)
    {
        GetDataBindTask()->SetWaiting();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Register
//
//  Synopsis:   register myself with the databinding task
//

HRESULT
CDataSourceBinder::Register(const DBSPEC *pdbs)
{
    Assert("consumer required" && _pelConsumer);
    Assert("consumer already set" && !_pConsumer);
    Assert("provider already set" && !_pProvider && !_cstrProviderName);

    BSTR bstrElement=NULL, bstrDataset=NULL;
    HRESULT hr = S_OK;
    CDataBindTask *pDBTask;

    _pDoc = _pelConsumer->Doc();
    Assert("consumer must belong to a CDoc" && _pDoc);

    // get provider info
    FormsSplitFirstComponent(pdbs->_pStrDataSrc, &bstrElement, &bstrDataset);
    hr = _cstrProviderName.Set(bstrElement);
    if (!hr)
        hr = _cstrDataMember.Set(bstrDataset);
    if (hr)
        goto Cleanup;

    // defer the actual binding
    pDBTask = GetDataBindTask();
    if (!pDBTask)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pDBTask->AddDeferredBinding(this);
    if (hr)
        goto Cleanup;

Cleanup:
    FormsFreeString(bstrElement);
    FormsFreeString(bstrDataset);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     TryToBind (called by CDataBindTask)
//
//  Synopsis:   try to bind to my provider
//

HRESULT
CDataSourceBinder::TryToBind()
{
    HRESULT hr = E_FAIL;
    CDataMemberMgr *pDataMemberManager;
    DBIND_KIND dbk;
    DBSPEC dbs;
    DWORD dwFilter;

    // The element's gotta want to bind.
    dbk = CDBindMethods::DBindKind(_pelConsumer, _idConsumer);
    if (dbk == DBIND_NONE)
        goto Cleanup;       // hr is E_FAIL

    if (S_OK != CDBindMethods::GetDBSpec(_pelConsumer, _idConsumer, &dbs,
                                   DBIND_SETFILTER|DBIND_CURRENTFILTER) )
        goto Cleanup;

    // The element's spec and its inherent binding preference must agree.
    dwFilter = (dbk == DBIND_SINGLEVALUE) ? DBIND_CURRENTFILTER : DBIND_SETFILTER;
    if (!dbs.FFilter(dwFilter, _pelConsumer->Tag()==ETAG_TABLE))
        goto Cleanup;

    // set the re-entrancy flag (see Passivate)
    _fBinding = TRUE;

    // set up consumer
    if (!_pConsumer)
    {
        hr = CConsumer::Create(this, &_pConsumer);
        if (hr)
            goto Cleanup;
    }

    Assert(_pConsumer);
    Assert(!_pProvider);

    // get the HTML element designated as the DataSrc
    if (!_pelProvider)
    {
        hr = THR_NOTRACE(FindProviderByName(&_pelProvider));
        if (hr)
            goto Cleanup;
    }

    // ask it for a CDataSourceProvider
    _pelProvider->EnsureDataMemberManager();
    pDataMemberManager = _pelProvider->GetDataMemberManager();
    if (pDataMemberManager)
    {
        hr = pDataMemberManager->GetDataSourceProvider(_cstrDataMember, &_pProvider);
    }
    else
    {
        hr = E_FAIL;
    }

    // if something went wrong, hook up the null provider
    if (hr)
    {
        hr = CDataSourceProvider::Create(NULL, _pDoc, _cstrDataMember, &_pProvider);  // null provider
        if (hr)
            goto Cleanup;
    }

    // getting the provider may cause me to die (see Passivate).
    // if so, carry out my death now.
    if (_fAbort)
        goto Cleanup;

    // do the actual binding
    Assert(_pProvider);
    _pProvider->AdviseDataProviderEvents(this);
    hr = Bind();

    // if it didn't work, don't hang on to the provider
    if (hr)
    {
        if (_pProvider)
        {
            _pProvider->UnadviseDataProviderEvents(this);
            _pProvider->Release();
            _pProvider = NULL;
        }
        _pelProvider = NULL;
    }

Cleanup:
    _fBinding = FALSE;

    if (_fAbort)
    {
        Passivate();        // calls "delete this", no work after here
        hr = S_OK;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     Bind (public - called SetProvider)
//
//  Synopsis:   hook up the consumer to the provider
//

HRESULT
CDataSourceBinder::Bind()
{
    HRESULT hr;

    Assert(_pConsumer);
    _pelConsumer->AddRef();         // keep consumer alive while binding

    hr = _pConsumer->Bind();
    if (hr == E_NOINTERFACE)        // this means we've bound to the null provider
        hr = S_OK;

    if (!hr && !_fAbort)
    {
        _pConsumer->FireOnDataReady(TRUE);
    }

    Verify(_pelConsumer->Release());

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     DetachBinding (public)
//
//  Synopsis:   detach the binding
//

HRESULT
CDataSourceBinder::DetachBinding()
{
    if (!_pDoc->TestLock(FORMLOCK_UNLOADING))
    {
        _dbop = BINDEROP_UNBIND;
        GetDataBindTask()->AddDeferredBinding(this);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     UnBind (public)
//
//  Synopsis:   unhook the consumer from the provider
//

HRESULT
CDataSourceBinder::UnBind()
{
    HRESULT hr=S_OK;

    if (_pConsumer)
    {
        _pConsumer->FireOnDataReady(FALSE);
        hr = _pConsumer->UnBind();
        if (hr == E_NOINTERFACE)            // bound to null provider
            hr = S_OK;
    }

    if (_pProvider)
    {
        _pProvider->UnadviseDataProviderEvents(this);
        _pProvider->Release();
        _pProvider = NULL;
    }

    _pelProvider = NULL;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     ReBind (public)
//
//  Synopsis:   rehook the consumer to the (possibly new) provider
//

HRESULT
CDataSourceBinder::ReBind()
{
    HRESULT hr;

    hr = UnBind();
    if (!hr)
    {
        hr = TryToBind();
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataEvents (public)
//
//  Synopsis:   make sure data events can fire for my "consumer"
//

HRESULT
CDataSourceBinder::EnsureDataEvents()
{
    HRESULT hr;
    CDataMemberMgr *pDataMemberManager;

    _pelConsumer->EnsureDataMemberManager();
    pDataMemberManager = _pelConsumer->GetDataMemberManager();

    if (pDataMemberManager)
    {
        hr = pDataMemberManager->IsReady();
        if (!hr)
        {
            // It's enough to simply ask for the provider and release it.
            // This creates it, and it will live on in the OleSite's cache.
            CDataSourceProvider *pProvider = NULL;
            IGNORE_HR(pDataMemberManager->GetDataSourceProvider(NULL, &pProvider));
            if (pProvider)
            {
                pProvider->Release();
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     FindProviderByName (private - called by SetProvider)
//
//  Synopsis:   find an element corresponding to _cstrProviderName
//

HRESULT
CDataSourceBinder::FindProviderByName(CElement **ppelProvider)
{
    HRESULT     hr;

    Assert(GetProviderName() != 0);
    Assert(ppelProvider);
    Assert(_pDoc);

    // DataSrc is supposed to be #<IDRef>
    if (*((LPTSTR)GetProviderName()) != _T('#'))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(_pelConsumer->GetMarkup());

    // ask the Consumer for the named element, don't use the '#' in the name match.
    hr = THR_NOTRACE(_pelConsumer->GetMarkup()->GetElementByNameOrID((LPTSTR)GetProviderName() + 1,
                                                ppelProvider));

    // If the lookup failed then stop everything.  It returns S_FALSE if
    // more than one element with that name exists;  we'll use the first one.
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     SubstituteProvider (private, called by CConsumer) 
//
//  Synopsis:   substitute the new provider for the current one.  This should
//              only be called in the early stages of binding.  It's used by
//              hierarchically-bound tables, whose dataSrc gives a top-level
//              provider;  the real provider must be computed during binding
//              by examining the repeating context.
//

void
CDataSourceBinder::SubstituteProvider(CDataSourceProvider *pProviderNew)
{
    CDataSourceProvider *pProviderOld = _pProvider;

    _pProvider = pProviderNew;
    
    if (pProviderNew)
    {
        pProviderNew->AddRef();
        pProviderNew->AdviseDataProviderEvents(this);
    }
    
    if (pProviderOld)
    {
        pProviderOld->UnadviseDataProviderEvents(this);
        pProviderOld->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     ReplaceProvider (public, called by CDataSourceProvider) 
//
//  Synopsis:   cope with provider changing its interfaces
//

HRESULT
CDataSourceBinder::ReplaceProvider(CDataSourceProvider *pdspNewProvider)
{
    HRESULT hr = S_OK;

    if (!_pDoc->TestLock(FORMLOCK_UNLOADING))
    {
        _dbop = BINDEROP_REBIND;
        GetDataBindTask()->AddDeferredBinding(this);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\bmkcoll.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_BMKCOLL_H_
#define X_BMKCOLL_H_
#include "bmkcoll.hxx"
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <adoid.h>
#endif

#ifndef X_ADO_ADOINT_H_
#define X_ADO_ADOINT_H_
#include <adoint.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#define _cxx_
#include "bmkcoll.hdl"

EXTERN_C const GUID CLSID_HTMLDocument;
typedef Recordset15 IADORecordset;    // beats me why ADO doesn't use I...
typedef ADORecordsetConstruction IADORecordsetConstruction;

MtDefine(CBookmarkCollection, ObjectModel, "CBookmarkCollection");
MtDefine(CBookmarkCollection_aryBookmarks_pv, CBookmarkCollection, "CBookmarkCollection::_aryBookmarks::_pv");


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CBookmarkCollection
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CBookmarkCollection::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLBookmarkCollection,   // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::~CBookmarkCollection (destructor)
//
//  Synopsis : Release all the variants
//
//----------------------------------------------------------------

CBookmarkCollection::~CBookmarkCollection()
{
    VARIANT *pVar;
    int i;

    for (pVar=_aryBookmarks, i=_aryBookmarks.Size();  i>0;  ++pVar, --i)
    {
        VariantClear(pVar);
    }
    _aryBookmarks.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::Init
//
//  Synopsis : Convert a list of HROWs to ADO bookmarks, and use these
//             to fill the collection.
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::Init(const HROW *rghRows, ULONG cRows, IADORecordset *pADO)
{
    HRESULT hr = S_OK;
    _ADORecordset *pADOClone = NULL;
    IADORecordsetConstruction *pADOConstruction = NULL;
    IRowPosition *pRowPos = NULL;
    const HROW *pHRow;
    HCHAPTER hChapter = DB_NULL_HCHAPTER;
    HROW hrow = DB_NULL_HROW;
    DWORD dwFlags;
    VARIANT varBmk;

    // get a copy of the recordset, so as not to disturb currency on the main one
    hr = pADO->_xClone(&pADOClone);

    // get the row position from the clone, and get its chapter
    if (!hr)
        hr = pADOClone->QueryInterface(IID_IADORecordsetConstruction,
                                       (void**)&pADOConstruction);
    if (!hr)
        hr = pADOConstruction->get_RowPosition((IUnknown**)&pRowPos);
    if (!hr)
        hr = pRowPos->GetRowPosition(&hChapter, &hrow, &dwFlags);

    // get room for the variants that hold the bookmarks
    Assert(_aryBookmarks.Size() == 0);
    if (!hr)
        hr = _aryBookmarks.EnsureSize(cRows);
    if (hr)
        goto Cleanup;

    // get an ADO bookmark for each row, and add it to the array
    VariantInit(&varBmk);
    for (pHRow = rghRows; cRows > 0; --cRows, ++pHRow)
    {
        hr = pRowPos->ClearRowPosition();
        if (!hr)
            hr = pRowPos->SetRowPosition(hChapter, *pHRow, DBPOSITION_OK);
        if (!hr)
            hr = pADOClone->get_Bookmark(&varBmk);
        if (!hr && V_VT(&varBmk) != VT_EMPTY)
        {
            VARIANT *pVar = NULL;
            hr = _aryBookmarks.AppendIndirect(NULL, &pVar);
            if (!hr && pVar)
            {
                VariantCopy(pVar, &varBmk);
            }
            VariantClear(&varBmk);
        }
    }

    hr = S_OK;      // clamp any errors found while building the array

Cleanup:
    ReleaseChapterAndRow(hChapter, hrow, pRowPos);
    ReleaseInterface(pRowPos);
    ReleaseInterface(pADOConstruction);
    ReleaseInterface(pADOClone);
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::PrivateQueryInterface
//
//  Synopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLBookmarkCollection)
        {
           *ppv = (IHTMLBookmarkCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::length
//
//  Sysnopsis : IHTMLBookmarkCollection interface method
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryBookmarks.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::item
//
//  Sysnopsis : IHTMLBookmarkCollection interface method
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::item(long lIndex, VARIANT *pVarBookmark)
{
    HRESULT hr = S_OK;

    if (!pVarBookmark)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryBookmarks.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantCopy(pVarBookmark, &_aryBookmarks[lIndex]);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::_newEnum
//
//  Sysnopsis : IHTMLBookmarkCollection interface method
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryBookmarks.EnumVARIANT(VT_I4,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\consumer.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1996
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Consumer objects
//
//  Classes:    CDataSourceBinder::CConsumer (abstract)
//                  CNullConsumer
//                  CTableConsumer
//                  CCurrentRecordConsumer
//                  CRowsetConsumer
//                  CCursorConsumer
//
//  History:    10/1/96     (sambent) created

// The concrete classes derived from CDataSourceBinder::CConsumer are
// declared in this file, which makes them unknown to the rest of the world.
// The function CConsumer::Create acts as a
// factory -- creating the appropriate concrete consumer or provider.
//
// To support a new type of consumer, derive a new class from CConsumer, and
// add code to CConsumer::Create to create an instance.


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DBINDING_HXX_
#define X_DBINDING_HXX_
#include "dbinding.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_DLCURSOR_HXX_
#define X_DLCURSOR_HXX_
#include "dlcursor.hxx"
#endif

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include <vbcursor/ocdb.h>
#endif

#ifndef X_VBCURSOR_OCDBID_H_
#define X_VBCURSOR_OCDBID_H_
#include <vbcursor/ocdbid.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h>
#endif

#ifndef X_VBCURSOR_OLEBIND_H_
#define X_VBCURSOR_OLEBIND_H_
#include <vbcursor/olebind.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

EXTERN_C const IID IID_IADORecordset15; // for GetDataMember from Java
EXTERN_C const IID IID_DataSource;      // for QI impl of CDataSourceConsumer


/////////////////////////////////////////////////////////////////////////////
/////                       Consumer Classes                            /////
/////////////////////////////////////////////////////////////////////////////

/////-------------------------------------------------------------------/////
///// null consumer.  Used when binding fails.  Always returns error.   /////
/////-------------------------------------------------------------------/////

MtDefine(CNullConsumer, DataBind, "CNullConsumer")

class CNullConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CNullConsumer))
    CNullConsumer(CDataSourceBinder *pBinder) : super(pBinder) {}
    virtual HRESULT Bind() { return E_FAIL; }
    virtual HRESULT UnBind() { return E_FAIL; }
    virtual void    FireOnDataReady(BOOL fReady) {}
};


/////-------------------------------------------------------------------/////
/////                   Table consumer                                  /////
/////-------------------------------------------------------------------/////

MtDefine(CTableConsumer, DataBind, "CTableConsumer")

class CTableConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CTableConsumer))
    CTableConsumer(CDataSourceBinder *pBinder):
        super(pBinder), _pdlcCursor(NULL), _bstrDataSrc(NULL), _bstrDataFld(NULL) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual HRESULT GetDLCursor(CDataLayerCursor **pdlc);
    virtual HRESULT GetDataSrcAndFld(BSTR *, BSTR *);
    virtual void    FireOnDataReady(BOOL fReady);
    virtual ~CTableConsumer() {}
private:
    CDataLayerCursor    *_pdlcCursor;   // my DLCursor
    BSTR                _bstrDataSrc;   // my full dataSrc
    BSTR                _bstrDataFld;   // my full dataFld
};


//+-------------------------------------------------------------------------
// Member:              Bind (CTableConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CTableConsumer::Bind()
{
    HRESULT hr = S_OK;
    CDataSourceProvider *pProvider = NULL;
    IRowset *pRowset = NULL;
    CTable *pTable = DYNCAST(CTable, GetElementConsumer());
    Assert(pTable);
    Assert(GetProvider());
    LPCTSTR strDataSrc = pTable->GetAAdataSrc();
    LPCTSTR strDataFld = pTable->GetAAdataFld();
    
    if (strDataFld == NULL)
    {
        // normal table
        pProvider = GetProvider();
        FormsAllocString(strDataSrc, &_bstrDataSrc);
    }
    else
    {
        // hierarchical table
        BSTR bstrColumn=NULL, bstrJunk;
        LPCTSTR strTail;
        CElement *pElemOuter, *pElemRepeat;
        CRecordInstance *pRecInstance = NULL;
        CDataSourceProvider *pProviderParent = NULL;
        
        // look for enclosing repeated table
        hr = pTable->FindDatabindContext(strDataSrc, strDataFld,
                                            &pElemOuter, &pElemRepeat, &strTail);

        // if there is one, use its provider as the source for a subprovider
        if (!hr && pElemOuter)
        {
            CTable *pTableOuter = DYNCAST(CTable, pElemOuter);
            CTableRow *pRow = DYNCAST(CTableRow, pElemRepeat);
            LPCTSTR strDataFldOuter = pTableOuter->GetDataFld();
            UINT cDataFldLength;
            LPTSTR pch;
            
            pProviderParent = pTableOuter->GetProvider();
            hr = pTableOuter->GetInstanceForRow(pRow, &pRecInstance);
            if (hr)
                goto CleanupHierarchy;
            
            FormsAllocString(pTableOuter->GetDataSrc(), &_bstrDataSrc);
            FormsSplitFirstComponent(strTail, &bstrColumn, &bstrJunk);
            FormsFreeString(bstrJunk);
            
            cDataFldLength = (strDataFldOuter ? _tcslen(strDataFldOuter) : 0) +
                              1 +
                              (strTail ? _tcslen(strTail) : 0) +
                              1;
            pch = new TCHAR[cDataFldLength];
            if (pch == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto CleanupHierarchy;
            }
                
            if (strDataFldOuter)
            {
                _tcscpy(pch, strDataFldOuter);
                _tcscat(pch, _T("."));
                _tcscat(pch, bstrColumn);
            }
            else
            {
                _tcscpy(pch, bstrColumn);
            }
            FormsAllocString(pch, &_bstrDataFld);
            
            delete pch;
        }
        
        // if not, perhaps the table is current-record bound to hierarchy
        else if (!hr && strTail)
        {
            CCurrentRecordInstance *pCRI = NULL;
            hr = GetProvider()->QueryDataInterface(IID_ICurrentRecordInstance,
                                        (void**)&pCRI);
            if (!hr)
            {
                FormsAllocString(strDataSrc, &_bstrDataSrc);
                FormsAllocString(strDataFld, &_bstrDataFld);
                FormsSplitFirstComponent(strTail, &bstrColumn, &bstrJunk);
                FormsFreeString(bstrJunk);
                
                pProviderParent = GetProvider();
                hr = pCRI->GetCurrentRecordInstance(&pRecInstance);
            }
            ReleaseInterface(pCRI);
        }

        // if we found a hierarchical context, use the subprovider
        if (!hr && pRecInstance)
        {
            Assert(pProviderParent);
            HROW hrow = pRecInstance->GetHRow();
            CXfer *pXfer;

            // if there's a good HROW, get the provider we'll use to bind
            if (hrow != DB_NULL_HROW)
            {
                hr = pProviderParent->GetSubProvider(&pProvider, bstrColumn, hrow);
                if (!hr)
                    SubstituteProvider(pProvider);
                if (pProvider)
                    pProvider->Release();       // ref now owned by _pProvider
            }

            if (!hr)
            {
                hr = CXfer::CreateBinding(pTable, ID_DBIND_DEFAULT, strTail,
                                        pProviderParent, pRecInstance,
                                        &pXfer, /* fDontTransfer */ TRUE);
            }
        }

CleanupHierarchy:
        FormsFreeString(bstrColumn);
    }

    if (pProvider == NULL)
    {
        hr = E_FAIL;
    }
    if (hr)
        goto Cleanup;
    
    // get the provider's rowset
    hr = pProvider->QueryDataInterface(IID_IRowset, (void**)&pRowset);
    if (hr)
        goto Cleanup;

    // set up my DLCursor to use the rowset
    _pdlcCursor = new CDataLayerCursor(NULL);
    if (!_pdlcCursor)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pdlcCursor->Init(pRowset, pProvider->GetChapter(),
                        CDataLayerCursor::DLC_SinkNotifications |
                        CDataLayerCursor::DLC_FilterNotificationsToChapter);
    if (hr == E_NOINTERFACE)
    {
        hr = E_FAIL;        // E_NOINTERFACE from Bind() means "null provider"
    }

Cleanup:
    ReleaseInterface(pRowset);
    pTable->SetReadyStateTable(hr==S_OK ? READYSTATE_LOADING : READYSTATE_COMPLETE);

    return hr;
}

//+-------------------------------------------------------------------------
// Member:              UnBind (CTableConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CTableConsumer::UnBind()
{
    CElement *pelConsumer = GetElementConsumer();
    CDataBindingEvents *pdbe = pelConsumer->GetDBMembers()->GetDataBindingEvents();

    // for hierarchical tables, detach from the RecordInstance
    if (pdbe)
        pdbe->DetachBinding(pelConsumer, ID_DBIND_ALL);

    // all I gotta do is tell my DLCursor to die
    if (_pdlcCursor)
    {
        _pdlcCursor->Release();
        _pdlcCursor = NULL;
    }

    FormsFreeString(_bstrDataSrc);
    FormsFreeString(_bstrDataFld);
    _bstrDataSrc = _bstrDataFld = NULL;
    
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              GetDLCursor (CTableConsumer, public)
//
// Synopsis:    return my DLCursor

HRESULT
CTableConsumer::GetDLCursor(CDataLayerCursor **pdlc)
{
    Assert(pdlc);
    *pdlc = _pdlcCursor;
    return _pdlcCursor ? S_OK : E_FAIL;
}


//+-------------------------------------------------------------------------
// Member:              GetDataSrcAndFld (CTableConsumer, public)
//
// Synopsis:    return my full dataSrc and dataFld

HRESULT
CTableConsumer::GetDataSrcAndFld(BSTR *pbstrDataSrc, BSTR *pbstrDataFld)
{
    HRESULT hr;
    BSTR bstrDataSrc, bstrDataFld = NULL;   // this is just to appease the LINT
    
    hr = FormsAllocString(_bstrDataSrc, &bstrDataSrc);
    if (!hr)
    {
        hr = FormsAllocString(_bstrDataFld, &bstrDataFld);
        if (hr)
            FormsFreeString(bstrDataSrc);
    }

    if (!hr)
    {
        *pbstrDataSrc = bstrDataSrc;
        *pbstrDataFld = bstrDataFld;
    }
    else
    {
        *pbstrDataSrc = NULL;
        *pbstrDataFld = NULL;
    }
        
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CTableConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CTableConsumer::FireOnDataReady(BOOL fReady)
{
    CElement *pelConsumer = GetElementConsumer();

    Assert(pelConsumer->GetDBindMethods());
    pelConsumer->GetDBindMethods()->OnDataReady(pelConsumer, fReady);
}


/////-------------------------------------------------------------------/////
/////                   CCurrentRecordConsumer                          /////
/////-------------------------------------------------------------------/////

MtDefine(CCurrentRecordConsumer, DataBind, "CCurrentRecordConsumer")

class CCurrentRecordConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CCurrentRecordConsumer))
    CCurrentRecordConsumer(CDataSourceBinder *pBinder) : super(pBinder) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual void    FireOnDataReady(BOOL fReady);
    virtual ~CCurrentRecordConsumer() {}
};


//+-------------------------------------------------------------------------
// Member:              Bind (CCurrentRecordConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CCurrentRecordConsumer::Bind()
{
    HRESULT hr;
    CDataSourceProvider *pProvider = GetProvider();
    CElement *pelConsumer = GetElementConsumer();
    CCurrentRecordInstance *pCRI = 0;
    CRecordInstance *priCurrent;

    Assert(pProvider);

    // get the provider's current record instance
    hr = pProvider->QueryDataInterface(IID_ICurrentRecordInstance,
                                        (void**)&pCRI);
    if (hr)
        goto Cleanup;
    hr = pCRI->GetCurrentRecordInstance(&priCurrent);
    if (hr)
        goto Cleanup;

    // attach an Xfer to the instance
    hr = CXfer::CreateBinding(pelConsumer, IdConsumer(), NULL, pProvider, priCurrent);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pCRI);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:              UnBind (CCurrentRecordConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CCurrentRecordConsumer::UnBind()
{
    CElement *pelConsumer = GetElementConsumer();
    CDataBindingEvents *pdbe = pelConsumer->GetDBMembers()->GetDataBindingEvents();

    if (pdbe)
        pdbe->DetachBinding(pelConsumer, IdConsumer());

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CCurrentRecordConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CCurrentRecordConsumer::FireOnDataReady(BOOL fReady)
{
    // nothing to do - once we've attached the Xfer to the instance,
    // the Xfer does all the work.  [CurrentRecord consumers use
    // "push model" data binding.]
    // The function does have to be here, so that this is an instantiable
    // class.
}


/////-------------------------------------------------------------------/////
/////                        CCursorConsumer                            /////
/////-------------------------------------------------------------------/////

MtDefine(CCursorConsumer, DataBind, "CCursorConsumer")

class CCursorConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CCursorConsumer))
    CCursorConsumer(CDataSourceBinder *pBinder): super(pBinder), _pCursor(0) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual void    FireOnDataReady(BOOL fReady);
    virtual HRESULT GetICursor(ICursor **ppCursor);
    virtual ~CCursorConsumer() {}
private:
    ICursor     *_pCursor;      // my ICursor interface (from provider)
};


//+-------------------------------------------------------------------------
// Member:              Bind (CCursorConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CCursorConsumer::Bind()
{
    HRESULT hr;
    CDataSourceProvider *pProvider = GetProvider();

    Assert(pProvider);
    Assert(!_pCursor);

    // get the provider's cursor
    hr = pProvider->QueryDataInterface(IID_ICursor,
                                        (void**)&_pCursor);
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Member:              UnBind (CCursorConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CCursorConsumer::UnBind()
{
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CCursorConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CCursorConsumer::FireOnDataReady(BOOL fReady)
{
    HRESULT             hr;
    COleSite            *pOleSiteConsumer = DYNCAST(COleSite, GetElementConsumer());
    CLASSINFO           *pci= pOleSiteConsumer->GetClassInfo();
    BOOL                fBound;
    BOOL                bOwnedXfer;
    IBoundObject        *pBO = 0;
    VARIANT             var;

    Assert(pci);
    Assert(pci->dispidCursor != DISPID_UNKNOWN);

    if (!fReady)
        ClearInterface(&_pCursor);

    // See if my control supports IBoundObject
    hr = THR_NOTRACE(pOleSiteConsumer->QueryControlInterface(IID_IBoundObject,
                                                      (void **)&pBO));
    if (!hr)
    {
        // IBoundObject supported: signal the cursor is changing.
        // This will cause my control to call the COleSite::Client's
        // IBoundObjectSite::GetCursor.
        Assert(pBO);
        fBound = (_pCursor != 0);
        hr = THR(pBO->OnSourceChanged(pci->dispidCursor, fBound, &bOwnedXfer));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // IBoundObject not supported: use dispatch to set consumer's Cursor
        VariantInit(&var);
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = _pCursor;
        pOleSiteConsumer->CacheDispatch();
        hr = pOleSiteConsumer->SetProperty((UINT)(~0UL),
                            pci->dispidCursor, VT_UNKNOWN, &var);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pBO);
}


//+-------------------------------------------------------------------------
// Member:              GetICursor (CCursorConsumer, public)
//
// Synopsis:    return my ICursor - called by control's IBoundObjectSite

HRESULT
CCursorConsumer::GetICursor(ICursor **ppCursor)
{
    *ppCursor = _pCursor;
    if (_pCursor)
        _pCursor->AddRef();
    return S_OK;
}



/////-------------------------------------------------------------------/////
/////                        CDataSourceConsumer                        /////
/////-------------------------------------------------------------------/////

MtDefine(CDataSourceConsumer, DataBind, "CDataSourceConsumer")
MtDefine(CDataSourceConsumer_aryListeners_pv, CDataSourceConsumer, "CDataSourceConsumer::_aryListeners::_pv")

class CDataSourceConsumer: public CDataSourceBinder::CConsumer, public DataSource
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CDataSourceConsumer))
    CDataSourceConsumer(CDataSourceBinder *pBinder):
        super(pBinder), _fPropertySet(FALSE), _aryListeners(Mt(CDataSourceConsumer_aryListeners_pv)) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual void    FireOnDataReady(BOOL fReady);
    virtual void    Passivate();

    // IUnknown members
    ULONG   STDMETHODCALLTYPE AddRef() { return super::AddRef(); }
    ULONG   STDMETHODCALLTYPE Release() { return super::Release(); }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv);

    // DataSource members
    HRESULT STDMETHODCALLTYPE getDataMember(DataMember bstrDM, REFIID riid, IUnknown** ppunk);
    HRESULT STDMETHODCALLTYPE getDataMemberName(long lIndex, DataMember* pbstrDM);
    HRESULT STDMETHODCALLTYPE getDataMemberCount(long* plCount);
    HRESULT STDMETHODCALLTYPE addDataSourceListener(DataSourceListener* pDSL);
    HRESULT STDMETHODCALLTYPE removeDataSourceListener(DataSourceListener* pDSL);

private:
    CPtrAry<DataSourceListener *>  _aryListeners;  // DataSource Listeners
    unsigned    _fPropertySet:1;    // true if I've pushed myself into control's property
};


//+-------------------------------------------------------------------------
// Member:              Bind (CDataSourceConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CDataSourceConsumer::Bind()
{
    HRESULT hr = S_OK;

    if (!_fPropertySet)
    {
        // first time - push myself into control's DataSource property
        VARIANT var;
        IUnknown *punkThis = (IUnknown*)(DataSource*)this;

        CElement *pelConsumer = GetElementConsumer();
        LONG id = IdConsumer();
        const CDBindMethods *pdbm = pelConsumer->GetDBindMethods();

        VariantInit(&var);
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = punkThis;
        punkThis->AddRef();
        hr = pdbm->BoundValueToElement(pelConsumer, id, /* fHTML */ FALSE,
                                       &var);
        VariantClear(&var);
        if (hr)
            goto Cleanup;
        _fPropertySet = TRUE;

        // Databinding should not save undo information
        pelConsumer->Doc()->FlushUndoData();
    }
    else
    {
        // already connected - notify listeners that data member is changed
        for (int i=_aryListeners.Size()-1; i>=0; --i)
        {
            _aryListeners[i]->dataMemberChanged(NULL);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              UnBind (CDataSourceConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CDataSourceConsumer::UnBind()
{
    // nothing to do.
    // It may seem tempting to notify my listeners that the data member has changed,
    // but we shouldn't do that until Bind() is called.  When the provider is
    // changing, UnBind() is followed by Bind();  the notification should happen
    // during Bind() because most likely the listeners are going to immediately
    // call GetDataMember, and we want to be hooked up to the new provider when
    // that happens.
    //
    // The only other time UnBind() is called is while shutting down the binding
    // completely, in which case there's no point in notifying the listeners.

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CDataSourceConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CDataSourceConsumer::FireOnDataReady(BOOL fReady)
{
    // nothing to do.  Function exists so class can instantiate.
}


//+-------------------------------------------------------------------------
// Member:              Passivate (CDataSourceConsumer, public)
//
// Synopsis:    release my resources

void
CDataSourceConsumer::Passivate()
{
    // release my listeners.  Array is deleted/freed in destructor.
    for (int i=_aryListeners.Size()-1; i>=0; --i)
    {
        _aryListeners[i]->Release();
    }

    super::Passivate();
}


//+-------------------------------------------------------------------------
// Member:              QueryInterface (CDataSourceConsumer, IUnknown, public)
//
// Synopsis:    return desired interface

HRESULT
CDataSourceConsumer::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punk = 0;

    if (IsEqualIID(riid, IID_DataSource))
    {
        punk = (DataSource*) this;
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        punk = (IUnknown*)(DataSource*)this;
    }

    if (punk)
    {
        punk->AddRef();
        hr = S_OK;
    } else
        hr = E_NOINTERFACE;

    *ppv = punk;
    return hr;
}


//+-------------------------------------------------------------------------
// Member:              getDataMember (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    return desired data-transfer interface

HRESULT
CDataSourceConsumer::getDataMember(DataMember bstrDM, REFIID riid, IUnknown** ppunk)
{
    HRESULT hr = E_NOINTERFACE;
    IUnknown *punkInterface = 0;
    CDataSourceProvider *pProvider = GetProvider();

    if (IsEqualIID(riid, IID_IUnknown))
    {
        switch (DYNCAST(COleSite, GetElementConsumer())->OlesiteTag())
        {
        case COleSite::OSTAG_ACTIVEX:
            hr = pProvider->QueryDataInterface(IID_IRowPosition, (void**)&punkInterface);
            break;

        case COleSite::OSTAG_APPLET:
            hr = pProvider->QueryDataInterface(IID_IADORecordset15, (void**)&punkInterface);
            break;
        }
    }
    else
    {
        hr = pProvider->QueryDataInterface(riid, (void**)&punkInterface);
    }

    // if the provider returns E_NOINTERFACE, we'll just say we have no data
    if (hr == E_NOINTERFACE)
    {
        hr = S_OK;
        Assert(punkInterface == NULL);
    }
    
    if (!hr && punkInterface)
    {
        *ppunk = punkInterface;
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              getDataMemberName (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    return name of given data member

HRESULT
CDataSourceConsumer::getDataMemberName(long lIndex, DataMember* pbstrDM)
{
    return E_NOTIMPL;       // we return Count=0, so this should never get called
}


//+-------------------------------------------------------------------------
// Member:              getDataMemberCount (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    return number of data members

HRESULT
CDataSourceConsumer::getDataMemberCount(long* plCount)
{
    if (plCount)
        *plCount = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              addDataSourceListener (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    add a DataSourceListener to my notification list

HRESULT
CDataSourceConsumer::addDataSourceListener(DataSourceListener* pDSL)
{
    if (pDSL)
    {
        pDSL->AddRef();
        _aryListeners.Append(pDSL);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              removeDataSourceListener (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    remove a DataSourceListener from my notification list

HRESULT
CDataSourceConsumer::removeDataSourceListener(DataSourceListener* pDSL)
{
    int i = _aryListeners.Find(pDSL);
    if (i>=0)
    {
        _aryListeners[i]->Release();
        _aryListeners.Delete(i);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              Release (CConsumer, IUnknown, public)
//
// Synopsis:    decrease refcount, passivate and die if 0

ULONG
CDataSourceBinder::CConsumer::Release()
{
    ULONG ulRefs = --_ulRefs;

    if (_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        delete this;
    }

    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:              Create (CConsumer, static public)
//
// Synopsis:    factory method - create a consumer

HRESULT
CDataSourceBinder::CConsumer::Create(CDataSourceBinder *pBinder,
                                     CConsumer **ppConsumer)
{
    CElement *pelConsumer = pBinder->GetElementConsumer();
    LONG id = pBinder->IdConsumer();
    HRESULT hr = S_OK;
    CConsumer *pConsumer = NULL;

    Assert(pelConsumer && ppConsumer);

    switch (CDBindMethods::DBindKind(pelConsumer, id, NULL))
    {
    case DBIND_SINGLEVALUE:
        pConsumer = new CCurrentRecordConsumer(pBinder);
        break;

    case DBIND_IDATASOURCE:
        pConsumer = new CDataSourceConsumer(pBinder);
        break;

    case DBIND_ICURSOR:
        pConsumer = new CCursorConsumer(pBinder);
        break;

    case DBIND_IROWSET:
        pConsumer = new CNullConsumer(pBinder);
        break;

    case DBIND_TABLE:
        pConsumer = new CTableConsumer(pBinder);
        break;

    default:
        pConsumer = new CNullConsumer(pBinder);
        break;
    }

    if (!pConsumer)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    *ppConsumer = pConsumer;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\dbinding.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       dbinding.cxx
//
//  Contents:   HTML Elements Data Binding Extensions
//
//  class CDataBinder  -  knows what we are binding (column/property).
//                        Has a protocol for Setting/Getting data
//                        to/from the HTML elements.
//
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include <elemdb.hxx>
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include <mshtmlrc.h>
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_SIMPDC_H_
#define X_SIMPDC_H_
#include "simpdc.h"
#endif

DeclareTag(tagCRecordInstance, "CRecordInstance", "Row Instance");
DeclareTag(tagDBtransfer, "Databinding", "data transfer values");
PerfDbgTag(tagDataTransfer,   "Databinding", "Data transfer");
MtDefine(CXfer, DataBind, "CXfer")
MtDefine(CXferThunk, DataBind, "CXferThunk")
MtDefine(CHRowAccessor, DataBind, "CHRowAccessor")
MtDefine(CRecordInstance, DataBind, "CRecordInstance")
MtDefine(CRecordInstance_aryPXfer_pv, CRecordInstance, "CRecordInstance::_aryPXfer::_pv")

////////////////////////////////////////////////////////////////////////////////
//
//  CRecordInstance
//
////////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     constructor
//
//-------------------------------------------------------------------------
CRecordInstance::CRecordInstance(CDataLayerCursor *pDLC, HROW hRow) :
    _pDLC(pDLC),
    _hRow(0),    // so that SetHRow() call won't have suprise side-effect
    _aryPXfer(Mt(CRecordInstance_aryPXfer_pv))
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::constructor() -> %p", this ));

    _pDLC->AddRef();
    IGNORE_HR(SetHRow(hRow));

    Assert(_aryPXfer.Size() == 0);

    IS_VALID(this);
}


//+------------------------------------------------------------------------
//
//  Member:     destructor
//
//-------------------------------------------------------------------------
CRecordInstance::~CRecordInstance()
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::constructor() -> %p", this ));

    IS_VALID(this);

    Assert(!_hRow                                &&
           (_aryPXfer.Size() == 0)               && "Detach not called.");

    if (_pDLC)
    {
        _pDLC->Release();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detaches RecordInstance and all Xfer's associated w/ this
//              RecordInstance.  Likewise, change all CElements pointed to
//              to no longer point back to the Xfer.
//-------------------------------------------------------------------------
void
CRecordInstance::Detach (BOOL fClear)
{
    TraceTag((tagCRecordInstance, "CRecordInstance::Detach() -> %p", this));

    IS_VALID(this);

    // DeleteXFers before discarding HROW, so that we don't try to stuff
    //  null information into all of the bound elements.
    DeleteXfers(fClear);                        // Remove all XFers.

    IGNORE_HR(SetHRow(0));                      // Release the HROW
}


//+------------------------------------------------------------------------
//
//  Member:     OkToChangeHRow
//
//  Synopsis:   See if it's OK to change my HROW association right now.
//              May validate-and-save the current site on the page.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CRecordInstance::OkToChangeHRow()
{
    TraceTag((tagCRecordInstance, "CRecordInstance::OkToChangeHRow() -> %p ()",
             this ));
             
    HRESULT hr = S_OK;
    const int cXfers = _aryPXfer.Size();
    int i;

    // it's always OK to move off the null HROW
    if (_hRow == DB_NULL_HROW)
        goto Cleanup;

    for (i=0; !hr && i<cXfers; ++i)
    {
        CXfer *pXfer = _aryPXfer[i];
        CElement *pElem;

        if (!pXfer)
            continue;

        if (pXfer->FOneWay())
            continue;
        
        pElem = pXfer->GetDestElement();


        // For Sites, we need to possibly check DISPID_VALID, and we need to
        //  save via a virtual method on the site which takes care of raising
        //  events if the site is current, cancelling posted messages, etc.
        // For elements, we do the save
        //  ourselves, because we've resisted putting a SaveDataIfChanged
        //  method on CElement becuase of VTable bloat.
        // TODO: much of the logic here duplicates that found elsewhere;
        //  this redundancy will lead to maintenance problems.  (JJD)
        //  The DISPID_VALID stuff duplicates RequestYieldCurrency, but
        //  we don't call it ourselves because we support binding to arbitrary
        /// params.
        if (pElem->ShouldHaveLayout())
        {
            LONG idBound = pXfer->IdElem();
            
            if (idBound == 0)   // TODO: what's the right check to decide if
                                //  we need to the the DISPID_VALID check,
                                //  normally done by
                                //  CSite::RequestYieldCurrency()?
            {
                CElement *pElemCurrent = pElem->Doc()->_pElemCurrent;

                if (pElemCurrent->ShouldHaveLayout() &&
                    pElemCurrent->GetElementDataBound() == pElem)
                {
                    if (!pElemCurrent->IsValid())
                    {
                        // TODO   Need to display error message here.
                        //          May not be able to handle synchronous
                        //          display, so consider deferred display.
                        hr = E_FAIL;
                        continue;
                    }
                }
            }

            hr = pElem->SaveDataIfChanged(idBound, /* fLoud */ TRUE);
            if (hr == S_FALSE)
            {
                hr = S_OK;      // if user reverted to database, that's just fine
            }
        }
        else
        {
#if DBG == 1
            DBINFO dbi;

            Verify(DBIND_SINGLEVALUE == CDBindMethods::DBindKind(pElem,
                                                                 pXfer->IdElem(),
                                                                 &dbi));
#endif
        }
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     SetHRow
//
//  Synopsis:   Assign a new HRow to this Instance, releasing the old HROW
//              and addrefing the new HROW..
//
//  Arguments:  [hRow]      new HROW
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CRecordInstance::SetHRow (HROW hRow)
{
    TraceTag((tagCRecordInstance, "CRecordInstance::SetHRow() -> %p (%ul)",
             this, hRow ));

    IS_VALID(this);

    HRESULT             hr = S_OK;

    // Valid RecordInstance data?

    if (_hRow || hRow)
    {
        // AddRef the new hrow we now hold onto.
        if (hRow)
        {
            _pDLC->AddRefRows(1, &hRow);
        }

        // Release the hRow we're holding onto.
        if (_hRow)
        {
            _pDLC->ReleaseRows(1, &_hRow);
        }

        _hRow = hRow;
        IGNORE_HR(TransferToDestination ());
    }
    else
    {
        // Had better be zero already if the cookie is invalid.
        Assert(hRow == 0);
        Assert(_hRow == hRow);
    }

    RRETURN(hr);
}


HRESULT
CRecordInstance::AddBinding(CXfer *pXfer, BOOL fDontTransfer,
                                BOOL fTransferOK)
{
    HRESULT hr;

    pXfer->EnableTransfers(fTransferOK);

    hr = _aryPXfer.Append(pXfer);
    if (hr)
    {
        goto Error;
    }

    if (_hRow && !fDontTransfer)
    {
        IGNORE_HR(pXfer->TransferFromSrc());
    }

Cleanup:
    RRETURN(hr);

Error:
    pXfer->Detach();
    delete pXfer;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     RemoveBinding
//
//  Synopsis:   Remove one or all Xfers associated with this element.
//
//  Arguments:  [pElement] - element whose binding(s) are being removed
//              [id]       - either individual binding ID being removed,
//                           or else ID_DBIND_ALL, to remove all Xfers
//                           associated with the element
//
//-------------------------------------------------------------------------
void
CRecordInstance::RemoveBinding (CElement *pElement, LONG id)
{
    Assert("valid element required" && pElement);
    TraceTag((tagCRecordInstance,
              "CRecordInstance::DeleteXfers() -> %p", this));

    IS_VALID(this);

    for (int i = _aryPXfer.Size() - 1; i >= 0; i--)
    {
        if (_aryPXfer[i] && pElement==_aryPXfer[i]->GetDestElement())
        {
            if (id == ID_DBIND_ALL || id == _aryPXfer[i]->IdElem())
            {
                // Disconnect CElement from Xfer (destination no longer bound).
                _aryPXfer[i]->Detach();
                delete _aryPXfer[i];
                _aryPXfer.Delete(i);
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     DeleteXfers
//
//  Synopsis:   Remove all Xfers associated with this row instance.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
void
CRecordInstance::DeleteXfers (BOOL fClear)
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::DeleteXfers() -> %p", this));

    IS_VALID(this);

    for (int i = _aryPXfer.Size() - 1; i >= 0; i--)
    {
        if (_aryPXfer[i])
        {
            // clear the element, if requested
            if (fClear)
                _aryPXfer[i]->ClearValue();

            // Disconnect CElement from Xfer (destination no longer bound).
            _aryPXfer[i]->Detach();
            delete _aryPXfer[i];
        }
    }

    // Remove the Xfer slot
    _aryPXfer.DeleteAll();
}


//+------------------------------------------------------------------------
//
//  Member:     TransferToDestination
//
//  Synopsis:   Process each Xfer associated with this RecordInstance
//              transfering data from the source to the destination.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CRecordInstance::TransferToDestination ()
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::TransferToDestination() -> %p", this));

    IS_VALID(this);

    HRESULT     hr = S_OK;
    HRESULT     hrT;
    int         iMaxIdx;

    iMaxIdx = _aryPXfer.Size() - 1;
    for (int i = 0; i <= iMaxIdx; i++)
    {
        if (!_aryPXfer[i])
            continue;

        hrT = _aryPXfer[i]->TransferFromSrc();

        // don't let one failure abort additional transfers, but
        //  return the first failure.
        if (hrT && !hr)
        {
            hr = hrT;
        }
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
// Member:      On Fields Changed (public)
//
// Synopsis:    notify my Xfer's that columns have changed
//
// Arguments:   cColumns        count of changed columns
//              aColumns        index of each changed column
//
// Returns:     S_OK

HRESULT
CRecordInstance::OnFieldsChanged(HROW hrow, DBORDINAL cColumns, DBORDINAL aColumns[])
{
    if (_pDLC->IsSameRow(hrow, _hRow))
    {
        const int cXfers = _aryPXfer.Size();
        for (int i=0; i<cXfers; ++i)
        {
            if (_aryPXfer[i])
                _aryPXfer[i]->ColumnsChanged(cColumns, aColumns);
        }
    }
    return S_OK;
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method, called by macro IS_VALID(p)
//
BOOL
CRecordInstance::IsValidObject ()
{
    Assert(this);
    Assert(_pDLC);

    return TRUE;
}


char s_achCRecordInstance[] = "CRecordInstance";

//+---------------------------------------------------------------------------
//
//  Member:     Dump
//
//  Synopsis:   Dump function, called by macro DUMP(p,dc)
//
void
CRecordInstance::Dump (CDumpContext&)
{
    IS_VALID(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
//  Synopsis:   GetClassName function. (virtual)
//
char *
CRecordInstance::GetClassName ()
{
    return s_achCRecordInstance;
}
#endif  // DBG == 1



////////////////////////////////////////////////////////////////////////////////
//
//  CXfer
//
////////////////////////////////////////////////////////////////////////////////

DeclareTag(tagCXfer, "CXfer", "CXfer Instance");


//+------------------------------------------------------------------------
//
//  Member:     CreateBinding (static)
//
//-------------------------------------------------------------------------

HRESULT
CXfer::CreateBinding(CElement *pElement,  LONG id, LPCTSTR strDataFld,
                    CDataSourceProvider *pProvider,
                    CRecordInstance *pSrcInstance,
                    CXfer **ppXfer /* = NULL */,
                    BOOL fDontTransfer /* = FALSE */)
{
    HRESULT hr = S_OK;
    DBIND_KIND dbk;
    DBINFO  dbi;
    DBSPEC dbs;
    CXferThunk *pXT = NULL;
    CXfer *pXfer = NULL;

    // Do all checks before memory allocation, for simple error handling.
    dbk = CDBindMethods::DBindKind(pElement, id, &dbi);
    if (dbk != DBIND_SINGLEVALUE && dbk != DBIND_TABLE)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // we will need to find out if DATAFORMATAS=HTML was specified
    Verify(!CDBindMethods::GetDBSpec(pElement, id, &dbs));

    // if dataformatas=localized-text is set (and is appropriate), mark the target type
    if (dbs.FLocalized() && dbi._vt == VT_BSTR)
    {
        dbi._vt.SetLocalized(TRUE);
    }
    
    // get a thunk from the provider
    if (strDataFld == NULL)
    {
        strDataFld = dbs._pStrDataFld;
    }
    pXT = pProvider->GetXT(strDataFld, dbi._vt);
    if (pXT == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // create a CXfer to govern the binding
    pXfer = new CXfer;
    if (pXfer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // initialize it
    hr = pXfer->Init(pElement, pSrcInstance, pXT, id, dbs.FHTML(), dbi._dwTransfer);

    // add it to the instance's notify list
    if (!hr)
        hr = pSrcInstance->AddBinding(pXfer, fDontTransfer);
    if (hr)
        goto Cleanup;
    
Cleanup:
    if (ppXfer)
        *ppXfer = pXfer;
    
    RRETURN1(hr, S_FALSE);
}


HRESULT
CXfer::ConnectXferToElement()
{
    HRESULT hr  = S_OK;
    DBMEMBERS *pdbm;

    if (!_pDestElem)
        goto Cleanup;

    hr  = _pDestElem->EnsureDBMembers();
    if (hr)
        goto Cleanup;

    pdbm = _pDestElem->GetDBMembers();

    hr = pdbm->GetDataBindingEvents()->AddXfer(this);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//-------------------------------------------------------------------------

HRESULT
CXfer::Init(CElement *pElem, CInstance *pSrcInstance, CXferThunk *pXT,
                LONG id, BOOL fHTML, DWORD dwTransfer)
{
    HRESULT hr;

    _pDestElem = pElem;
    _pSrcInstance = pSrcInstance;
    _pXT = pXT;
    _idElem = id;
    _fHTMLSpecified = fHTML;
    _dwTransfer = dwTransfer;

    _pXT->AddRef();
    hr = ConnectXferToElement();

    IS_VALID(this);
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     destructor
//
//-------------------------------------------------------------------------
CXfer::~CXfer ()
{
    TraceTag((tagCXfer, "CXfer::destructor() -> %p", this));

    IS_VALID(this);

    Assert(!_pDestElem && !_pSrcInstance && !_pXT && "Detach not called.");
}


//+------------------------------------------------------------------------
//
//  Member:     SetDestElement
//
//  Synopsis:   Change the CElement associated with this Xfer.
//
//  Arguments:  [pDestElem]     new CElement associated w/ Xfer.
//
//  Returns:    none
//
//-------------------------------------------------------------------------
HRESULT
CXfer::SetDestElement (CElement *pDestElem)
{
    TraceTag((tagCXfer, "CXfer::SetDestElement() -> %p (%p)", this, pDestElem));

    IS_VALID(this);

    DisonnectXferToElement();

    _pDestElem = pDestElem;

    return ConnectXferToElement();
}


//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detach the Xfer from the CElement.
//
//  Arguments:  none
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CXfer::Detach ()
{
    TraceTag((tagCXfer, "CXfer::Detach() -> %p", this));

    IS_VALID(this);

    DisonnectXferToElement();

    _pSrcInstance = NULL;
    ClearInterface(&_pXT);
}


//+------------------------------------------------------------------------
//
//  Member:     DisonnectXferToElement
//
//  Synopsis:   Disconnect CElement and Xfer connection to each other.
//
//  Arguments:  none
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CXfer::DisonnectXferToElement ()
{
    TraceTag((tagCXfer, "CXfer::Detach() -> %p", this));

    IS_VALID(this);

    if (_pDestElem)
    {
        // Sever CElement connection to an XFer.
        _pDestElem->GetDBMembers()->GetDataBindingEvents()->_aryXfer.DeleteByValue(this);

        // Sever Xfer connections to a CElement.
        _pDestElem = NULL;
    }
}


HRESULT
CXfer::TransferToSrc (DWORD *pdwStatus)
{
    HRESULT hr = S_OK;
    VARIANT     var;
    VOID        *pData;
    BOOL fWasTransferring;

    Assert(*pdwStatus == DBSTATUS_S_OK);    // caller must initialize
    VariantInit(&var);
    
    // Note that it is up to callers to avoid calling us when _fTransferringToDest.
    // This division of responsibility is necessary because we sometime decide to
    //  save synchronously, but don't actually do the save asynchronously.
    if (_pDestElem == NULL || _pSrcInstance == NULL || _pXT == NULL
            || _fTransferringToDest)
    {
        Assert(FALSE);
        hr = E_UNEXPECTED;
        goto Done;
    }

    if (_fDontTransfer)
    {
        hr = S_OK;
        goto Done;
    }

    // read-only binding always "succeeds"
    if (_dwTransfer & DBIND_ONEWAY)
        goto Done;

    fWasTransferring = _fTransferringToSrc;
    _fTransferringToSrc = TRUE;

    // prepare the variant which will receive the element's value.
    pData = _pXT->PvInitVar(&var);

    // get the value from the element
    hr = THR(_pDestElem->GetDBindMethods()->BoundValueFromElement(
                _pDestElem,
                IdElem(),
                FHTML(),
                pData ) );

    // set the status to indicate if it's null
    if (pData == &var.bstrVal && V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL)
    {
        *pdwStatus = DBSTATUS_S_ISNULL;
    }
    
    // transfer the data to the Rowset
    if (!hr)
    {
        hr = THR(_pXT->ValueToSrc(_pSrcInstance, pData, pdwStatus, _pDestElem));
    }
    
    _fTransferringToSrc = fWasTransferring;
    if (hr)
        goto Cleanup;

    // store the database value back into the element (so we get the
    // provider's converions, if any)
    IGNORE_HR(TransferFromSrc());

Cleanup:
    VariantClear(&var);
Done:
    RRETURN(hr);
}
    

HRESULT
CXfer::TransferFromSrc ()
{
    HRESULT         hr = S_OK;
    BOOL            fWasTransferring;
    WHEN_DBG(ULONG ulRefElement;)

    if (_fDontTransfer || _fTransferringToSrc)
    {
        goto Cleanup;
    }

    if (_pDestElem == NULL || _pSrcInstance == NULL || _pXT == NULL)
    {
        Assert(FALSE);
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    _pDestElem->AddRef();           // keep element alive while we change it
    
    fWasTransferring = _fTransferringToDest;
    _fTransferringToDest = TRUE;

    if (_dwTransfer & DBIND_NOTIFYONLY) // element just wants notification, not data
    {
        hr = THR(_pDestElem->GetDBindMethods()->InstanceChanged(_pDestElem, _pSrcInstance));
    }

    else                        // element wants data
    {
        HRESULT hrT;
        VARIANT     var;
        VOID       *pData;

        VariantInit(&var);
        pData = _pXT->PvInitVar(&var);

        PerfDbgLog1(tagDataTransfer, _pDestElem, "+DataTransfer to %ls",
                    _pDestElem->TagName());
        
        hr = THR(_pXT->ValueFromSrc(_pSrcInstance, pData, _pDestElem));

        PerfDbgLog(tagDataTransfer, _pDestElem, "got DB value, sending to element");

#if DBG==1
        if (var.vt == VT_BSTR)
            TraceTag((tagDBtransfer, "%ls %d gets bound value '%.200ls'",
                _pDestElem->TagName(), _pDestElem->_nSerialNumber,
                var.bstrVal));
        else
            TraceTag((tagDBtransfer, "%ls %d gets bound value of type %u value 0x%x",
                _pDestElem->TagName(), _pDestElem->_nSerialNumber,
                var.vt, var.iVal));
#endif

        // even on failure to fetch data from source, we want to put
        //  SOMETHING -- our empty-equivalent data -- into the element
        hrT = THR(_pDestElem->GetDBindMethods()->BoundValueToElement(
                    _pDestElem,
                    IdElem(),
                    FHTML(),
                    pData ) );
        if (!hr)
        {
            hr = hrT;
        }

        PerfDbgLog(tagDataTransfer, _pDestElem, "-DataTransfer");

        VariantClear(&var);

        // Databinding should not save undo information
        _pDestElem->Doc()->FlushUndoData();
    }
    
    // remember whether or not we achieved success
    _fError = (hr != S_OK);

    _fTransferringToDest = fWasTransferring;
    WHEN_DBG(ulRefElement = ) _pDestElem->Release();
    AssertSz(ulRefElement>0, "element unexpectedly destroyed during data transfer");

Cleanup:
    RRETURN(hr);
}


HRESULT
CXfer::ClearValue()
{
    HRESULT hr = S_OK;
    VARIANT var;
    VOID *pNull;
    
    Assert(_pDestElem && _pXT);
    
    if (_dwTransfer & DBIND_NOTIFYONLY) // element just wants notification, not data
        goto Cleanup;
    
    // set up null value
    pNull = _pXT->PvInitVar(&var);
    
    // transfer the null value
    hr = THR( _pDestElem->GetDBindMethods()->BoundValueToElement(
                _pDestElem,
                IdElem(),
                FHTML(),
                pNull ) );

    // Databinding should not save undo information
    _pDestElem->Doc()->FlushUndoData();

Cleanup:
    RRETURN(hr);
}


HRESULT
CXfer::CompareWithSrc ()
{
    HRESULT         hr = S_OK;
    
    VARIANT     var;
    VOID        *pData;
    
    VARIANT     varElem;
    VOID        *pElemData;

    VariantInit(&var);
    VariantInit(&varElem);

    // if we are comparing and we had a previous error, we do nothing and
    //  report a match with S_OK
    if (_fError)
        goto Done;

    // if we are comparing, and we are in the act of transferring back
    //  to the element, then we want to do nothing and return S_OK.
    if (_fTransferringToDest)
        goto Done;
    
    if (_pDestElem == NULL || _pSrcInstance == NULL || _pXT == NULL)
    {
        Assert(FALSE);
        hr = E_UNEXPECTED;
        goto Done;
    }

    Assert(CTypeCoerce::FVariantType(_vtElem.BaseType()));
    
    // compare on a read-only binding always returns true
    if (_dwTransfer & DBIND_ONEWAY)
        goto Done;
   
    pData = _pXT->PvInitVar(&var);    
    pElemData = _pXT->PvInitVar(&varElem);

    // get element's value
    hr = _pDestElem->GetDBindMethods()->BoundValueFromElement(_pDestElem,
                                                           IdElem(),
                                                           FHTML(),
                                                           pElemData);
    if (hr)
    {
        // S_FALSE is an expected return, which means the element is not in
        // a state where it has reasonable data to compare to.  An example
        // of this is a radio button with no buttons pressed, a state that
        // can be achieved if the databinding value matched no buttons.
        // We must suppress the S_FALSE here because our callers become upset
        // on any non-S_OK hr's.
        if (hr==S_FALSE)
        {
            hr = S_OK;
        }
        goto Cleanup;
    }

    // get database value
    hr = _pXT->ValueFromSrc(_pSrcInstance, pData, _pDestElem);
    if (hr)
    {
        if (hr == DB_E_DELETEDROW)
        {
            // moving away from a deleted record - the move-away code wants
            // to compare the current value with the (unavailable) database
            // value.  This condition would never occur if our data sources
            // gave us good deleted-rows notifications, but until ADC does,
            // we have to take some action.  We report that any value
            // matches the contents of a deleted-row, so that we won't
            // trigger save logic.
            hr = S_OK;
        }
        goto Cleanup;
    }

    // compare the values
    hr = CTypeCoerce::IsEqual(VT_VARIANT,
                              &varElem,
                              &var );

    // if we we have a mis-match, and we know that the source is read-only,
    //  let's report E_ACCESSDENIED now.
    if (hr == S_FALSE && !_pXT->IsWritable(_pSrcInstance))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

Cleanup:
    VariantClear(&var);
    VariantClear(&varElem);
Done:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
// Member:      Columns Changed (public)
//
// Synopsis:    if my column has changed, get the new data
//
// Arguments:   cColumns    count of changed columns
//              aColumns    index of each changed column
//
// Returns:     S_OK

HRESULT
CXfer::ColumnsChanged(DBORDINAL cColumns, DBORDINAL aColumns[])
{
    HRESULT hr = S_OK;
    HRESULT hrTemp;

    if (_pXT)
    {
        _pDestElem->AddRef();       // keep element alive while we change it
        for (ULONG k=0; k<cColumns; ++k)
        {
            if (_pXT->IdSrc() == aColumns[k])
            {
                hrTemp = TransferFromSrc();
                if (hrTemp)                     // return last error (arbitrarily)
                    hr = hrTemp;
            }
        }
        _pDestElem->Release();
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     ShowDiscardMessage
//
//  Synopsis:   Build and show the right message to prompt the user
//              if she wants changed discarded, and return results.
//
//  Arguments:  hrError  - error code of the failure
//              dwStatus - for DB_E_ERRORSOCCURRED only, status code
//              pnResult - where to put the value return by MessageBox.
//                         It is up to caller to initialize with sensible
//                         value in case error occurs.
//
//  Returns:    HRESULT
//

HRESULT
CXfer::ShowDiscardMessage (HRESULT hrError, DWORD dwStatus, int *pnResult)
{
    TCHAR   achBufError[FORMS_BUFLEN];
    int     errorDescr = 0;
    DBSPEC  dbs = {NULL, NULL, NULL};
    HRESULT hr;

    Verify(!CDBindMethods::GetDBSpec(PElemOwner(), IdElem(), &dbs, DBIND_SINGLEFILTER));
    Assert(dbs._pStrDataFld);

    switch (hrError)
    {
    case OLE_E_CANTCONVERT:
    case DB_E_UNSUPPORTEDCONVERSION:
    case DB_E_CANTCONVERTVALUE:
        errorDescr = IDS_EE_DB_COERCE;
        break;
        
    case DB_E_DELETEDROW:
        errorDescr = IDS_EE_DB_DELROW;
        break;
        
    case E_ACCESSDENIED:
    case DB_E_READONLYACCESSOR:
    case DB_SEC_E_PERMISSIONDENIED:
        errorDescr = IDS_EE_DB_READ;
        break;
        
    case DB_E_INTEGRITYVIOLATION:
    case DB_E_SCHEMAVIOLATION:
        errorDescr = IDS_EE_DB_SCHEMA;
        break;

    case DB_E_CANCELED:
        errorDescr = IDS_EE_DB_CANCELED;
        break;

    case DB_E_ERRORSOCCURRED:
        switch (dwStatus)
        {
        case DBSTATUS_E_CANTCONVERTVALUE:
        case DBSTATUS_E_DATAOVERFLOW:
        case DBSTATUS_E_SIGNMISMATCH:
            errorDescr = IDS_EE_DB_COERCE;
            break;

        case DBSTATUS_E_PERMISSIONDENIED:
            errorDescr = IDS_EE_DB_READ;
            break;

        case DBSTATUS_E_SCHEMAVIOLATION:
        case DBSTATUS_E_INTEGRITYVIOLATION:
            errorDescr = IDS_EE_DB_SCHEMA;
            break;

        default:
            errorDescr = IDS_EE_DB_OTHER_STATUS;
            break;
        }
        break;
        
    }

    if (errorDescr == 0)
    {
        hr = THR(GetErrorText(hrError, achBufError, ARRAY_SIZE(achBufError)));
    }
    else
    {
        hr = THR(Format(0,
                        achBufError,
                        ARRAY_SIZE(achBufError),
                        MAKEINTRESOURCE(errorDescr),
                        hrError,
                        dwStatus));
    }
    if (hr)
        goto Cleanup;

    hr = THR(_pDestElem->ShowMessage(pnResult,
                                MB_YESNO|MB_ICONEXCLAMATION|/*MB_HELP|*/MB_DEFBUTTON1|
                                MB_APPLMODAL,
                                0,             // help context..
                                IDS_MSG_DB_CANTSAVE,
                                dbs._pStrDataFld,
                                achBufError));
Cleanup:
    RRETURN(hr);
}

#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method, called by macro IS_VALID(p)
//
BOOL
CXfer::IsValidObject ()
{
    Assert(this);

    return TRUE;
}


char s_achCXfer[] = "CXfer";

//+---------------------------------------------------------------------------
//
//  Member:     Dump
//
//  Synopsis:   Dump function, called by macro DUMP(p,dc)
//
void
CXfer::Dump (CDumpContext&)
{
    IS_VALID(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
//  Synopsis:   GetClassName function. (virtual)
//
char *
CXfer::GetClassName ()
{
    return s_achCXfer;
}
#endif  // DBG == 1


////////////////////////////////////////////////////////////////////////////////
//
//  CDataBindingEvents
//
//  This now-poorly named class contains all databinding method calls initiated
//  by the bound element.
//
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::SaveIfChanged
//
//  Synopsis:   If appropriate, save value back to data source for
//              either one binding, or all bindings.  Fires any
//              events appropriate.
//              
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID of the particular binding
//                           within pElement.  ID_DBIND_ALL indicates
//                           all bindings.
//              [fLoud]    - Should a failure bring an alert up
//                           on the user's screen?
//              [fForceIsCurrent]    - Treat pElement as if it were the
//                           current focus element, even if it isn't
//
//  Returns:    S_OK       - Success (or no actual binding)
//              S_FALSE    - user reverted value to database version
//              E_ABORT    - user cancelled update
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::SaveIfChanged(CElement * pElement, LONG id, BOOL fLoud,
                                    BOOL fForceIsCurrent)
{
    CXfer     **ppXfer;
    int         i;
    DWORD       dwCookie;
    
    BOOL        fWasInSave = _fInSave;
    
    _fInSave = TRUE;                // recursion detection
    
    CDoc       *pDoc = pElement->Doc();
    BOOL        fCurrent = fForceIsCurrent ||
                            (pElement->ShouldHaveLayout() &&
                            pDoc->_pElemCurrent == pElement);

    BOOL        fBeforeFired = FALSE;
    BOOL        fErrorFired = FALSE;
    BOOL        fAlerted = FALSE;
    BOOL        fRevert = FALSE;    // initialization not really needed
    BOOL        fDoDefault = TRUE;  // initialization not really needed

    // TODO: are Lock and BlockNewUndoUnits really needed on save TO src?
    CDoc::CLock Lock(pDoc, SERVERLOCK_TRANSITION);
    pElement->AddRef();             // stabilize pointer
    HRESULT hr = pDoc->BlockNewUndoUnits(&dwCookie);
    
    if (hr)
        goto Cleanup;

    // set up loop variables to either do one ID, or else all of them
    if (id == ID_DBIND_ALL)
    {
        ppXfer = _aryXfer;
        i = _aryXfer.Size();
    }
    else
    {
        ppXfer = FindPXfer(pElement, id);

        // if this ID isn't bound just report sucess
        if (!ppXfer)
            goto Unblock;

        i = 1;
    }

    for (/* i, ppXfer initialized above */ ;
         i > 0;
         i--, ppXfer++)
    {
        CXfer *pXfer = *ppXfer;
        DWORD dwStatus = DBSTATUS_S_OK;

        Assert(!hr);    // we quit on failure
        
        hr = pXfer->CompareWithSrc();   //  includes IsWritable check
        if (!hr)
            continue;

        // even if we know that update will fail (that is, even if we got
        //  an error code from the comparison), we might still fire
        //  onbeforeupdate.
        
        if (!fBeforeFired && (fCurrent && !fWasInSave))
        {
            // either set fBeforeFired to TRUE, or bail out leaving
            //  it false, which will cause AfterUpdate to not be fired.
            fBeforeFired = pElement->Fire_onbeforeupdate();
            if (!fBeforeFired)
            {
                hr = E_ABORT;
                goto Unblock;
            }

            // don't crash if bindings yanked from underneath us by script
            if (ppXfer < (CXfer **) _aryXfer
                || ppXfer >= &_aryXfer[_aryXfer.Size()]
                || *ppXfer != pXfer)
            {
                goto Unblock;
            }
        }

        // try to write the new value, if it looks like writing is allowed
        if (!FAILED(hr))
        {
            hr = pXfer->TransferToSrc(&dwStatus);
            if (!hr)
                continue;
        }

        // something went wrong.  We'll either fail now, or else
        //  we'll consider what an <OnErrorUpdate and alert> might
        //  indicate.
        if (fLoud || (fCurrent && !fWasInSave))
        {
            if (!fErrorFired)
            {
                // in the unlikely case that we're nested inside another
                //  onerrorUpdate invocation, bail out rather than risk
                //  infinite recursion.
                if (_fInErrorUpdate)
                    goto Unblock;
                    
                _fInErrorUpdate = TRUE;
                fDoDefault = pElement->Fire_onerrorupdate();
                _fInErrorUpdate = FALSE;
                
                fErrorFired = TRUE;
                
                // don't crash if bindings yanked from underneath us by script
                if (ppXfer < (CXfer **) _aryXfer
                    || ppXfer >= &_aryXfer[_aryXfer.Size()]
                    || *ppXfer != pXfer)
                {
                    goto Unblock;
                }

                if (!pXfer->CompareWithSrc())
                {
                    hr = S_OK;
                    continue;
                }
            }

            Assert(hr);     // we're still working with failure
            
            if (fDoDefault && fLoud)
            {
                if (!fAlerted)
                {
                    int nResult = IDYES; // insurance that on failure, we'll revert
                        
                    // revert value if ShowDiscardMessage fails, or if
                    // user picks revert option
                    fRevert =  (pXfer->ShowDiscardMessage (hr, dwStatus, &nResult)
                                || IDYES == nResult );
                    fAlerted = TRUE;
                }


                if (fRevert)
                {
                    hr = S_FALSE;
                    IGNORE_HR(pXfer->TransferFromSrc());
                    continue;
                }
            }
        }

        // nobody fixed our failure
        Assert(hr);
        goto Unblock;
    }

Unblock:
    if (fBeforeFired && !fErrorFired)
    {
        pElement->Fire_onafterupdate();
    }
    pDoc->UnblockNewUndoUnits(dwCookie);

Cleanup:
    _fInSave = fWasInSave;
    pElement->Release();        // remove stabilizing reference
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::TransferFromSrc
//
//  Synopsis:   Copy the database value back into the element.
//              Used to revert changes the user may have made.
//              
//
//  Arguments:  [pElement] - Destination element
//              [id]       - The ID for the particular binding
//                           destination within pElement.
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::TransferFromSrc(CElement *pElement, LONG id)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;

    if (id == ID_DBIND_ALL)
    {
        HRESULT hrt;
        int i;
        for (i=0, ppXfer=&_aryXfer[0]; i<_aryXfer.Size(); ++i, ++ppXfer)
        {
            Assert(pElement == (*ppXfer)->GetDestElement());
            hrt = (*ppXfer)->TransferFromSrc();
            if (!hr)
                hr = hrt;       // remember first error
        }
    }
    else
    {
        ppXfer = FindPXfer(pElement, id);
        if (!ppXfer)
            goto Cleanup;

        Assert(pElement == (*ppXfer)->GetDestElement());
        hr = (*ppXfer)->TransferFromSrc();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::ValueFromSrc
//
//  Synopsis:   Fetch the database value which would be put into the
//              element if a full transfer were accomplished.  Up to
//              caller to initialize receiving memory, and make sure
//              it is of right size to accommodate the element's
//              data type.
//              
//
//  Arguments:  [pElement] - Destination element
//              [id]       - The ID for the particular binding
//                           destination within pElement.
//              [lpv]      - where to put the value
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::ValueFromSrc(CElement *pElement, LONG id, LPVOID lpv)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;

    ppXfer = FindPXfer(pElement, id);
    if (!ppXfer)
        goto Cleanup;

    Assert(pElement == (*ppXfer)->GetDestElement());

    hr = (*ppXfer)->ValueFromSrc(lpv);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::CheckSrcWritable
//
//  Synopsis:   Check whether not we could propagate a change from
//              the given ID of the given element to its data source.
//              
//
//  Arguments:  [pElement] - Destination element
//              [id]       - The ID for the particular binding
//                           destination of pElement.
//
//  Returns:    S_OK       - Not bound or OK to write
//              S_FALSE    - Write-to-source is suppressed because we
//                           are in act of propgating value from source
//                           to destination, and don't want to ping-pong
//                           the value between source and destination.
//              E_*        - error
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::CheckSrcWritable(CElement *pElement, LONG id)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;
    CXfer       *pXfer;
    CXferThunk  *pXT;

    ppXfer = FindPXfer(pElement, id);

    if (!ppXfer)
        goto Cleanup;

    pXfer = *ppXfer;

    Assert(pElement == pXfer->GetDestElement());

    if (pXfer->FTransferringToDest())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

        
    pXT = pXfer->GetXT();

    if (!pXT->IsWritable(pXfer->GetSrcInstance()))
    {
        hr = E_ACCESSDENIED;    // TODO: is this the right code?
        goto Cleanup;
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::CompareWithSrc
//
//  Synopsis:   Check whether not the data source and element
//              contents hold equal values.
//              
//
//  Arguments:  [pElement] - Destination element tempate
//              [id]       - The ID for the particular binding
//                           destination of pElement.
//
//  Returns:    S_OK       - Values match.
//              S_FALSE    - Non-match.
//              E_*        - error
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::CompareWithSrc(CElement *pElement, LONG id)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;
    
    ppXfer = FindPXfer(pElement, id);

    if (!ppXfer)
        goto Cleanup;

    Assert(pElement == (*ppXfer)->GetDestElement());

    hr = (*ppXfer)->CompareWithSrc();

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::Detach
//
//  Synopsis:   Detach the element from the event sink.
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding
//                           source within pElement.  Or ID_DBIND_ALL
//                           to indicate all bindings
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

void
CDataBindingEvents::DetachBinding(CElement *pElement, LONG id)
{
    int i;
    CXfer **ppXfer;

    // we loop ppXfer backwards to avoid unnecessary memory copying as
    //  we delete from _aryXfer
    if (id == ID_DBIND_ALL)
    {
        i = _aryXfer.Size();
        ppXfer = &_aryXfer[i-1];
    }
    else
    {
        ClearValue(pElement, id);
        ppXfer = FindPXfer(pElement, id);
        i =  ppXfer ? 1 : 0;
    }

    for ( ; i> 0; i--, ppXfer--)
    {
        CRecordInstance *pRecInstance = DYNCAST(CRecordInstance, (*ppXfer)->GetSrcInstance());
        LONG idElem = (*ppXfer)->IdElem();

        Assert(pElement == (*ppXfer)->GetDestElement());
        if (pElement != (*ppXfer)->GetDestElement())
            continue;

        _aryXfer.Delete(ppXfer-(CXfer **)_aryXfer);
        pRecInstance->RemoveBinding(pElement, idElem);  // deletes Xfer
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::ClearValue
//
//  Synopsis:   Clear the value in the element to a null-equivalent.
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding
//                           source within pElement.  ID_DBIND_ALL
//                           is not allowed.
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::ClearValue(CElement *pElement, LONG id)
{
    Assert(id != ID_DBIND_ALL);

    HRESULT hr = S_OK;
    CXfer **ppXfer = FindPXfer(pElement, id);

    if (pElement->Doc()->TestLock(FORMLOCK_LOADING | FORMLOCK_UNLOADING))
        goto Cleanup;

    if (ppXfer == NULL)
        goto Cleanup;

    Assert(pElement == (*ppXfer)->GetDestElement());
    hr = (*ppXfer)->ClearValue();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::EnableTransfers
//
//  Synopsis:   Enable data transfer for this binding.  Called when an
//              object becomes ready.
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding.
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::EnableTransfers(CElement *pElement, LONG id, BOOL fTransferOK)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;
    int         i;

    // initialize variables for loop below
    if (id == ID_DBIND_ALL)
    {
        i = _aryXfer.Size();
        ppXfer = _aryXfer;
    }
    else
    {
        i = 1;
        ppXfer = FindPXfer(pElement, id);
    }

    if (ppXfer == NULL)
        goto Cleanup;
    
    for (/* i, ppXfer */; i>0; --i, ++ppXfer)
    {
        Assert(pElement == (*ppXfer)->GetDestElement());
        (*ppXfer)->EnableTransfers(fTransferOK);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::FindPXfer, private
//
//  Synopsis:   Find the slot in _aryXfer which holds binding to the
//              given ID,if any.
//              
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding
//                           source within pElement.
//
//  Returns:    ppXfer or NULL
//
//---------------------------------------------------------------
CXfer **
CDataBindingEvents::FindPXfer(CElement *pElement, LONG id)
{
    CXfer **ppXfer;
    int    i;

    Assert(id != ID_DBIND_ALL);
    
    for (i = _aryXfer.Size(), ppXfer = _aryXfer;
         i > 0;
         i--, ppXfer++)
    {
        if ((*ppXfer)->IdElem() == id)
        {
            return ppXfer;
        }
    }

    return NULL;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CXferThunk
//
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::Create, static
//
//  Synopsis:   Create and init CXferThunk with all information necessary
//              for eventual resolution of the source reference, and
//              instantiation of mechanism for accomplishing transfer.
//
//
//  Arguments:  [pDLC]     - Cursor for data source
//              [strField] - Name of column
//              [vtDest]   - Datatype of value desired
//              [pSDC]     - Data conversion object (usually NULL)
//              [ppXT]     - Where to return a pointer to the XferThunk
//
//  Returns:    S_OK       - XferThunk successfully created
//              S_FALSE    - no XferThunk needed for this element
//              E_*        - error
//
//
//---------------------------------------------------------------

HRESULT
CXferThunk::Create(CDataLayerCursor *pDLC, LPCTSTR strField, CVarType vtDest,
                    ISimpleDataConverter *pSDC, CXferThunk **ppXT)
{
    CXferThunk *pXT = NULL;
    CTypeCoerce::CAN_TYPE cantDest;
    HRESULT hr;
    DBORDINAL uColID;

    // initilize in case of failure
    *ppXT = NULL;

    hr = CTypeCoerce::CanonicalizeType(vtDest.BaseType(), cantDest);
    if (hr)
        goto Cleanup;

    // allocate the memory
    pXT = new CXferThunk();
    if (pXT == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // initialize with one reference
    pXT->_ulRefCount = 1;

    hr = THR(pDLC->GetColumnNumberFromName(strField, uColID));
    if (hr)
        goto Cleanup;

    pXT->_idSrc = uColID;

    pXT->_vtDest = vtDest;
    pXT->_cantDest = cantDest;
    Assert(pXT->_fAccessorError == FALSE);
    Assert(!pXT->_pAccessor);
    Assert(pXT->_dbtSrc == VT_EMPTY);
    pXT->_fWriteSrc = TRUE;
    pXT->_pSDC = pSDC;

    hr = pXT->EnsureAccessor(pDLC);

Cleanup:
    if (!hr)
    {
        *ppXT = pXT;
    }
    else
    {
        delete pXT;
    }
    
    RRETURN(hr);
}


HRESULT
CXferThunk::QueryInterface (REFIID riid, LPVOID * ppv)
{
    HRESULT hr;

    Assert(ppv);

    if (riid == IID_IUnknown)
    {
        *ppv = this;
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}


ULONG
CXferThunk::AddRef (void)
{
    return ++_ulRefCount;
}


ULONG
CXferThunk::Release (void)
{

    if (--_ulRefCount == 0)
    {
        _ulRefCount = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }

    return _ulRefCount;
}


CXferThunk::~CXferThunk()
{
    if (_pAccessor)
    {
        _pAccessor->Detach();
        _pAccessor = NULL;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::EnsureAccessor, private
//
//  Synopsis:   If we haven't ever tried to get an accessor before, try
//              to get one now.  If it fails for a non-recoverable reason
//              set _fAccessorError flag so we don't keep trying.
//
//  Arguments:  [pDLC]    - DataLayerCursor through which we get the
//                          OLE-DB accessor.
//
//  Returns:    S_OK:       We got an accessor.
//              S_FALSE:    We couldn't get an accessor due to a persistent
//                          error (e.g. the column name referenced in the
//                          DATAFLD doesn't exist).
//              E_*         Error of some sort 
//
//                         * * * * WARNING * * * * 
//  NOTE THAT THIS FUNCTION CAN RETURN S_OK AND YET STILL LEAVE _pAccessor NULL!
//
//---------------------------------------------------------------
HRESULT
CXferThunk::EnsureAccessor(CDataLayerCursor *pDLC)
{
    HRESULT hr = S_OK;

    if (!_pAccessor && !_fAccessorError)
    {
        // TODO: for now, we assume that we will be fetching
        //  from HROWs.  When we add IDispatch-based sources,
        //  we'll need to do better.
        CHRowAccessor *pHRowAccessor = new CHRowAccessor;
        if (!pHRowAccessor)
        {
            hr = E_OUTOFMEMORY;            
            goto Cleanup;
        }

        hr = pHRowAccessor->Init(this, pDLC);
        if (hr)
        {
            delete pHRowAccessor;
            // TODO:: We really should report this error someday, someway,
            // and differentiate from recoverable and non-recoverable errors.
            // For now, we presume all accessor creation failures are non-recov.
            hr = S_OK;                  // look like we succeeded
            _fAccessorError = TRUE;
        }
        else
        {
            _fAccessorError = FALSE;
            _pAccessor = pHRowAccessor;
        }
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CXferThunk::ValueFromSrc, public
//
//  Synopsis:   Fetch a bound value suiable for stuffing into a destination
//              element.  It is up to caller to ensure that receiving
//              memory buffer is suitable for receiving the element's
//              desired type, and to whatever memory initialization is
//              required.
//
//  Arguments:  [pSrc]     - Source instance.  Concrete type must
//                           match that expected my the CXferThunk.
//              [lpv]      - destination memory buffer
//
//  Returns:    S_OK:       All OK.
//              E_*         Error of some sort
//
//---------------------------------------------------------------

HRESULT
CXferThunk::ValueFromSrc (CInstance *pSrc, LPVOID lpv, CElement *pElem)
{
    HRESULT hr;

    hr = _pAccessor ? THR(_pAccessor->ValueFromSrc(this, pSrc, lpv, pElem))
                    : E_FAIL;
    
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::TransferToSrc, public
//
//  Synopsis:   Accomplish a transfer from a destination element
//              back to its source instance.
//
//  Arguments:  [pSrc]     - Source instance.  Concrete type must
//                           match that expected my the CXferThunk.
//              [pCEDest]  - destination element instance
//              [pdwStatus] - used to pass pack status information
//                            from OLE DB
//
//---------------------------------------------------------------

HRESULT
CXferThunk::ValueToSrc(CInstance *pSrc, LPVOID lpv, DWORD *pdwStatus, CElement *pElem)
{
    HRESULT hr;

    hr = _pAccessor ? THR(_pAccessor->ValueToSrc(this, pSrc, lpv, pdwStatus, pElem))
                    : E_FAIL;
    
    RRETURN(hr);
}

BOOL
CXferThunk::IsWritable(CInstance *pSrc)
{
    BOOL fRet = FALSE;

    if (_pAccessor)
    {
        if (!_fWriteSrc)
        {
            goto Cleanup;
        }
        fRet = _pAccessor->IsSrcWritable(pSrc);
    }

Cleanup:
    return fRet;
}

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::PvInitVar, public
//
//  Synopsis:   Initialize variant based on the type desired by an
//              XferThunk's element, and return a pointer either to
//              beginning of the variant or to the data-portion,
//              depending on what the element wants.
//
//  Arguments:  [pvar]     - variant to be initalized
//
//  Returns:    Pointer to beginning or data portion of variant.
//
//  Notes:
//      Arranges that:
//      1) If the variant isn't further manipulated, VariantClear
//         will be harmless.
//      2) If we are doing some cheating where the data fetch is going
//         simulate a variant, or we are otherwise going to rely
//         on VariantClear to release a value, the VT will have been
//         set correctly
//      3) If things go wrong, we'll pass an appropriate empty-equivalent
//         value
//
//---------------------------------------------------------------

VOID *
CXferThunk::PvInitVar(VARIANT *pvar, CVarType vt)
{
    VOID *pv = pvar;
    
#ifdef UNIX
    CY_INT64(&pvar->cyVal) = 0;
#else
    pvar->cyVal.int64 = 0;
#endif
    if (vt.BaseType() == VT_VARIANT)
    {
        pvar->vt = VT_EMPTY;
    }
    else
    {
        pvar->vt = vt.BaseType();
        if (!vt.FInVariant())
        {
            pv = &pvar->iVal;
        }
    }
    return pv;
}

VOID *
CXferThunk::PvInitVar(VARIANT *pvar) const
{
    return PvInitVar(pvar, _vtDest);
}

// DBData type used to fetch and set database data
// we may fetch the data into the beginning of the variant, or
// else directly into the data portion, depending on the datatype
struct DBData {
    DWORD   dwStatus;
    VARIANT var_data;
};

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::Init, CAccessor
//
//  Synopsis:   Initialize a helper object for a CXferThunk for
//              accomplishing a transfer from HROW sources.
//
//  Arguments:  [pXT]      - The owning CXferThunk.
//
//---------------------------------------------------------------

HRESULT
CXferThunk::CHRowAccessor::Init(CXferThunk *pXT, CDataLayerCursor *pDLC)
{
    IS_VALID(pXT);

    CVarType  vtDest = pXT->_vtDest;
    DBBINDING binding;
    DBTYPE    dbType;
    HRESULT   hr;
    const CDataLayerCursor::ColumnInfo *pCI;
    size_t    oIn = 0;

    Assert(vtDest != VT_EMPTY);
    Assert(pDLC);

    hr = THR(pDLC->GetPColumnInfo(pXT->IdSrc(), &pCI));
    if (hr)
    {
        goto Cleanup;
    }

    dbType = pCI->dwType;

    // Let's plan our access and conversion strategies.  First, we figure out
    //  how to interact with the database.

    // under certain special circumstances, we don't use the provider's data
    //  type for the Rowset accessor.
    
    Assert(vtDest.BaseType() != DBTYPE_WSTR && vtDest.BaseType() != DBTYPE_STR);
    if (dbType != vtDest.BaseType())        // A type coercion is necessary.
    {
        // see if DSO wants us to use its SimpleDataConverter
        Assert(!pXT->_fUseSDC);
        if (pXT->_pSDC)
        {
            DBTYPE dbTypeTemp;
            
            switch (dbType)
            {
            // map date-like types into DBTYPE_DATE
            case DBTYPE_DATE:
            case DBTYPE_DBDATE:
            case DBTYPE_DBTIME:
            case DBTYPE_DBTIMESTAMP:
                dbTypeTemp = DBTYPE_DATE;
                break;

            // map fixed-point numeric types into DBTYPE_DECIMAL
            case DBTYPE_NUMERIC:
                dbTypeTemp = DBTYPE_DECIMAL;
                break;

            default:
                dbTypeTemp = dbType;
                break;
            }
            
            if (S_OK == pXT->_pSDC->CanConvertData(dbTypeTemp, vtDest.BaseType()))
            {
                pXT->_fUseSDC = TRUE;
                dbType = dbTypeTemp;
            }
        }

        if (!pXT->_fUseSDC)
        {
            // If control wants a string, let's
            //  Assume that provider can deal with WSTRs and BSTRs.

            // Note that all of our conversion code requires BSTRs.
            switch(vtDest.BaseType())
            {
            case DBTYPE_BSTR:
                if(dbType != DBTYPE_R8 && dbType != DBTYPE_R4)  dbType = DBTYPE_BSTR;
                break;

            case DBTYPE_VARIANT:
                // if the control wants a variant and the database has a non-variant
                // type, get the provider to convert to BSTR first.
                if (!CTypeCoerce::FVariantType(dbType))
                    dbType = DBTYPE_BSTR;
                break;
                
            default:
                if (dbType == DBTYPE_STR || dbType == DBTYPE_WSTR)
                {
                    dbType = DBTYPE_BSTR;
                }
                break;
            }
        }
    }
    Assert(pXT->_fUseSDC || (dbType != DBTYPE_WSTR && dbType != DBTYPE_STR));
    Assert(!pXT->_fUseSDC || CTypeCoerce::FVariantType(dbType));

    
    Assert(pXT->_dbtSrc == dbType || pXT->_dbtSrc == VT_EMPTY);
    pXT->_dbtSrc = dbType;

    // now figure out how we will convert what we fetch from the database
    //  to what the consumer desires

    // following values 0-filled at "new" time
    Assert(pXT->_cantSrc == CTypeCoerce::TYPE_NULL);  // used as conversion flg

    // when exchanging values with the HROW, should we pass a pointer into the
    //  data portion of a variant, or to the variant as a whole?
    // (Note: VT_DECIMAL overlays the entire variant)
    if (dbType != VT_VARIANT && dbType != VT_DECIMAL)
    {
        oIn = FIELD_OFFSET(VARIANT, iVal);
    }
        
    // If a type coercsion will be required, lay the groundwork
    if (dbType != vtDest.BaseType())
    {
        if (dbType == VT_NULL)
        {
            hr = OLE_E_CANTCONVERT;
        }
        else if (pXT->_fUseSDC)
        {
            hr = S_OK;
            pXT->_cantSrc = dbType;
        }
        else
        {
            hr = CTypeCoerce::CanonicalizeType(dbType, pXT->_cantSrc);

            // we use _cantSrc to indicate whether or not coercion needed
            Assert(hr || pXT->_cantSrc != CTypeCoerce::TYPE_NULL);
        }
        if (hr)
        {
            goto Cleanup;
        }
    }

    binding.iOrdinal = pXT->IdSrc();
    binding.obStatus = FIELD_OFFSET(DBData, dwStatus);
    binding.obValue = FIELD_OFFSET(DBData, var_data) + oIn;
    binding.pBindExt = 0;
    binding.cbMaxLen = 0;
    binding.dwFlags = 0;
    binding.wType = dbType;
    binding.eParamIO = DBPARAMIO_NOTPARAM;
    binding.dwPart = DBPART_STATUS | DBPART_VALUE;
    binding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    binding.bPrecision = 0;
    binding.bScale = 0;


    hr = THR_NOTRACE(pDLC->CreateAccessor(_hAccessor,
                        DBACCESSOR_ROWDATA, &binding, 1 ));
    if (hr)
    {
        goto Cleanup;
    }

    // remember whether the column is writeable
    pXT->_fWriteSrc = ((pCI->dwFlags &
                        (DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_WRITEUNKNOWN)) != 0);

    // if we succeeded, keep DLCursor alive during my lifetime
    _pDLC = pDLC;
    _pDLC->AddRef();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::Detach, CAccessor
//
//  Synopsis:   Destroy a CHRowAccessor, releasing any resources it
//              owns, along with its own memory.
//
//---------------------------------------------------------------

void
CXferThunk::CHRowAccessor::Detach()
{
    if (_hAccessor)
    {
        Assert(_pDLC);
        _pDLC->ReleaseAccessor(_hAccessor);
        Assert(_hAccessor == NULL);
    }
    
    if (_pDLC)
        _pDLC->Release();
    
    delete this;
}

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::ValueFromSrc, CAccessor
//
//  Synopsis:   Accomplish the actual transfer from the HROW source,
//              to a memory location expecting the bound-element's native
//              data type.
//
//  Arguments:  [pXT]      - The owning CXferThunk.
//              [pSrc]     - source instance
//              [lpvData]  - where to put the data.  It is up to caller
//                           to 0 initialize!
//
//  Returns:    S_OK:       All OK..
//              E_*         Error of some sort
//
//---------------------------------------------------------------

HRESULT
CXferThunk::CHRowAccessor::ValueFromSrc (const CXferThunk *pXT,
                                         CInstance *pSrc,
                                         LPVOID lpvData,
                                         CElement *pElemBound) const
{
    // shouldn't need this const_cast, but the IS_VALID macros
    //  weren't designed to take into account const methods.
    Assert(IS_VALID(const_cast<CXferThunk::CHRowAccessor *>(this)));
    
    HRESULT     hr = S_OK;
    CRecordInstance *pRecInstance;
    HROW        hRow;

    pRecInstance = DYNCAST(CRecordInstance, pSrc);

    hRow = pRecInstance->GetHRow();

    // if we have a NULL hrow, we skip any fetch from the Rowset, and
    //  rely on the fact that we've already initialized pOut in a manner
    //  consisting with pushing empty data into the destination element.
    if (hRow != DB_NULL_HROW)
    {
        DBData      dbValue;
        VOID       *pSrcData;
        
        // prepare the variant which will receive the database value.
        pSrcData = CXferThunk::PvInitVar(&dbValue.var_data, pXT->_dbtSrc);

        hr = THR(_pDLC->GetData(hRow, _hAccessor, (void *) &dbValue));
        Assert(FAILED(hr) || hr == S_OK);

        // VT_DECIMAL overlaps VARIANT completely.  Some providers write
        // into the DECIMAL.wReserved field, wiping out the VARIANT.vt field
        // that we carefully set up in PvInitVar.  Protect against such badness.
        if (pXT->_dbtSrc == VT_DECIMAL)
        {
            dbValue.var_data.vt = VT_DECIMAL;
        }
        
        if (!hr)
        {
            CVarType vtDest = pXT->_vtDest;
            
            if (dbValue.dwStatus == DBSTATUS_S_ISNULL)
            {
                // We got a NULL; rely on pre-clearing of lpvData by caller.
                // However, if destination wants VT_NULL, then he has
                //  pre-initialized vt to VT_EMPTY, and we want VT_NULL.
                if (vtDest.BaseType() == VT_VARIANT)
                {
                    ((VARIANT *) lpvData)->vt = VT_NULL;
                }
            }
            else
            {
                BYTE *pDest = (BYTE *) lpvData;
                CTypeCoerce::CAN_TYPE cantSrc = pXT->_cantSrc;
                CTypeCoerce::CAN_TYPE cantDest = pXT->_cantDest;
                
                if (vtDest.FInVariant())
                {
                    pDest += FIELD_OFFSET(VARIANT, iVal);
                }
                
                if (cantSrc == CTypeCoerce::TYPE_NULL)
                {
                    // no conversion required, just copy the data bits to caller's
                    //  buffer
                    memcpy(pDest, pSrcData, CTypeCoerce::MemSize(cantDest));
                    // owner of lpvData now has reponsibility for freeing
                    //  any BSTR's etc.
                }
                else if (pXT->_fUseSDC)
                {
                    // SimpleDataConverter converts between variants, but
                    // pDest usually doesn't point into a variant.  So we
                    // convert into a temp variant, then copy the value.
                    VARIANT varTemp;
                    IHTMLElement *pHTMLElement = NULL;
                    
                    VariantInit(&varTemp);
                    if (pElemBound)
                    {
                        IGNORE_HR(pElemBound->QueryInterface(IID_IHTMLElement,
                                                        (void**)&pHTMLElement));
                    }

                    hr = pXT->_pSDC->ConvertData(dbValue.var_data,
                                                        vtDest.BaseType(),
                                                        pHTMLElement,
                                                        &varTemp);
                    if (!hr)
                    {
                        memcpy(pDest, &varTemp.iVal, CTypeCoerce::MemSize(cantDest));
                    }
                    else
                    {
                        dbValue.dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                        hr = DB_E_CANTCONVERTVALUE;
                    }
                    VariantClear(&dbValue.var_data);
                    ReleaseInterface(pHTMLElement);
                }
                else
                {
                    // conversion required, do it
                    hr = THR(CTypeCoerce::ConvertData(cantSrc,
                                                      pSrcData,
                                                      cantDest,
                                                      pDest ) );
                    // caller is not repsonsible for our variant data;
                    //  free it.
                    VariantClear(&dbValue.var_data);
                }
            }
        }
        else
        {
            // if what went wrong was missing data, we treat it like
            // VT_EMPTY success.  We rely on caller pre-initializing
            // his receiving buffer.
            if (hr == DB_E_ERRORSOCCURRED)
            {
                if (dbValue.dwStatus == DBSTATUS_E_UNAVAILABLE)
                {
                    hr= S_OK;
                    // proceed with normal comparison or transfer
                }
            }
        }
    }
    

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::ValueToSrc, CAccessor
//
//  Synopsis:   Accomplish the actual transfer to the HROW source,
//              on behalf of the owning CXferThunk
//
//  Arguments:  [pXT]      - The owning CXferThunk.
//              [pSrc]     - source instance
//              [lpvData]  - pointer to data
//              [pdwStatus] - place for OLE DB status
//
//---------------------------------------------------------------

HRESULT
CXferThunk::CHRowAccessor::ValueToSrc(const CXferThunk *pXT,
                                      CInstance *pSrc,
                                      LPVOID lpvData,
                                      DWORD *pdwStatus,
                                      CElement *pElemBound) const
{
    HRESULT     hr;
    CRecordInstance *pRecInstance;
    HROW        hRow;
    DBData      dbValue;
    VOID       *pSrcData;
    
    CTypeCoerce::CAN_TYPE cantSrc = pXT->_cantSrc;
    DBTYPE      dbtSrc = pXT->_dbtSrc;
    CVarType    vtDest = pXT->_vtDest;
    
    // shouldn't need this const_cast, but the IS_VALID macros
    //  weren't designed to take into account const methods.
    Assert(IS_VALID(const_cast<CXferThunk::CHRowAccessor *>(this)));

    Assert(*pdwStatus == DBSTATUS_S_OK || *pdwStatus == DBSTATUS_S_ISNULL);    // caller-initialized
    dbValue.dwStatus = *pdwStatus;      // initialize for normal transfer

    pRecInstance = DYNCAST(CRecordInstance, pSrc);
    
    hRow = pRecInstance->GetHRow();

    // if NULL HROW, we can't transfer any data to it
    if (hRow == DB_NULL_HROW)
    {
        hr = E_FAIL;
        goto Done;
    }

    // Just because we think the element likes to give us, say
    //  strings in a variant, doesn't mean that it really does!
    if (vtDest.FInVariant() && ((VARIANT *) lpvData)->vt != vtDest.BaseType())
    {
        Assert(!"bound parameter of inconsistent datatype");
        hr = E_FAIL;    // TODO: error code?
        goto Done;
    }
    
    // prepare the structure which we will use to exchange data with
    //  the database.
    pSrcData = CXferThunk::PvInitVar(&dbValue.var_data, dbtSrc);
    
    // Determine if we want NULL-equivalent data in the source column,
    //  or a more "normal" transfer.
    if (vtDest.BaseType() == VT_VARIANT
        && (((VARIANT *) lpvData)->vt == VT_NULL
            || (dbtSrc != VT_VARIANT
                && ((VARIANT *) lpvData)->vt == VT_EMPTY ) ) )
    {
        dbValue.dwStatus = DBSTATUS_S_ISNULL;
        if (dbtSrc == VT_VARIANT)
        {
            dbValue.var_data.vt = VT_NULL;
        }
    }
    else
    {
        // locals are not really named intuitively -- we are transferring
        //  from Dest to Src
        BYTE *pDest = (BYTE *) lpvData;
        CTypeCoerce::CAN_TYPE cantDest = pXT->_cantDest;
        
        if (vtDest.FInVariant())
        {
            pDest += FIELD_OFFSET(VARIANT, iVal);
        }
        
        if (cantSrc == CTypeCoerce::TYPE_NULL)
        {
            // no conversion required, just copy the data bits to caller's
            //  buffer
            memcpy(pSrcData, pDest, CTypeCoerce::MemSize(cantDest));
        }
        else if (pXT->_fUseSDC)
        {
            // SimpleDataConverter uses variants, so copy into a temp
            // variant, then convert.
            VARIANT varTemp;
            IHTMLElement *pHTMLElement = NULL;
            
            V_VT(&varTemp) = vtDest.BaseType();
            memcpy(&varTemp.iVal, pDest, CTypeCoerce::MemSize(cantDest));

            if (pElemBound)
            {
                IGNORE_HR(pElemBound->QueryInterface(IID_IHTMLElement,
                                                (void**)&pHTMLElement));
            }

            hr = pXT->_pSDC->ConvertData(varTemp, dbtSrc,
                                            pHTMLElement, &dbValue.var_data);
            ReleaseInterface(pHTMLElement);
            
            if (hr)
            {
                dbValue.dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                hr = DB_E_CANTCONVERTVALUE;
                goto Cleanup;
            }
        }
        else
        {
            // conversion required, do it
            hr = THR(CTypeCoerce::ConvertData(cantDest,
                                              pDest,
                                              cantSrc,
                                              pSrcData ) );
            if (hr)
            {
                goto Cleanup;
            }
        }
    }
        
    hr = THR(_pDLC->SetData(hRow, _hAccessor, (void *) &dbValue));
    if (cantSrc != CTypeCoerce::TYPE_NULL)
    {
        VariantClear(&dbValue.var_data);
    }
    
Cleanup:
    *pdwStatus = dbValue.dwStatus;
    
Done:
    RRETURN(hr);
}

BOOL
CXferThunk::CHRowAccessor::IsSrcWritable(CInstance *pSrc) const
{
    return (DYNCAST(CRecordInstance, pSrc)->GetHRow() != NULL);
}


#if DBG==1
char s_achCXferThunk[] = "CXferThunk";

char*
CXferThunk::GetClassName()
{
    return s_achCXferThunk;
}

BOOL
CXferThunk::IsValidObject ()
{
    Assert(this);
    Assert(_vtDest.BaseType() != VT_EMPTY);
    Assert(!_pAccessor || _dbtSrc != VT_EMPTY);
    Assert(!_pAccessor || _pAccessor->IsValidObject ());
    return TRUE;
}

void
CXferThunk::Dump (CDumpContext&)
{
    IS_VALID(this);
}

char s_achCHRowAccessor[] = "CHRowAccessor";

char*
CXferThunk::CHRowAccessor::GetClassName()
{
    return s_achCHRowAccessor;
}

BOOL
CXferThunk::CHRowAccessor::IsValidObject ()
{
    Assert(this);
    return TRUE;
}

void
CXferThunk::CHRowAccessor::Dump (CDumpContext&)
{
    IS_VALID(this);
}
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\detail.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       detail.cxx
//
//  Contents:   HTML Tables Repeating Extensions
//
//  History:
//
//  Jul-96      AlexA   Creation
//  8/14/96     SamBent Support record generator as a lightweight task
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include <tpointer.hxx>
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include <csite.hxx>
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include <_txtsave.h>
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>       // for DB_S_UNWANTEDREASON
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_DRECGEN_HXX_
#define X_DRECGEN_HXX_
#include "drecgen.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#if defined(PRODUCT_PROF)
//#  define PROFILE_REPEATED_TABLES
#endif

#ifdef PROFILE_REPEATED_TABLES
#include <icapexp.h>
#endif

DeclareTag(tagDetail,"src\\site\\builtin\\detail.cxx","Detail");
DeclareTag(tagTableProgress, "Databinding", "Trace table progress");
PerfDbgTag(tagTableExpand,  "Databinding", "Trace table expansion");
PerfDbgTag(tagRecRequest,   "Databinding", "Trace record requests");

MtDefine(CDetailGenerator, DataBind, "CDetailGenerator")
MtDefine(CDetailGenerator_aryRecInstance_pv, CDetailGenerator, "CDetailGenerator::_aryRecInstance::_pv");

const LARGE_INTEGER LINULL = {0, 0};    // for IStream->Seek()
const RECORDINDEX  RECORDINDEX_INVALID  = MAXLONG;

// helper function to encapsulate a useful assert
static inline CTableLayout *
TableLayout(CTable *pTable)
{
    Assert(pTable);
    CTableLayout *pLayout = pTable->TableLayoutCache();
    Assert(pLayout);  // Table layout owns the DG, so it must exist
    return pLayout;
}


//+------------------------------------------------------------------------
//
//  class       CDetailGenerator
//
//  Member:     constructor
//
//-------------------------------------------------------------------------

CDetailGenerator::CDetailGenerator() :
      _aryRecInstance(Mt(CDetailGenerator_aryRecInstance_pv))
{
    TraceTag((tagDetail, "CDetailGenerator::constructor() -> %p", this));

    _reqCurrent._riBot = -1;            // prepare for NewRecord on an empty table
}




//+------------------------------------------------------------------------
//
//  class       CDetailGenerator
//
//  Member:     destructor
//
//-------------------------------------------------------------------------

CDetailGenerator::~CDetailGenerator ()
{
    TraceTag((tagDetail, "CDetailGenerator::destructor() -> %p", this));

    Assert (!_pRecordGenerator);
    Assert (!_bstrHtmlText);
}


//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Release all my resources.
//
//-------------------------------------------------------------------------

void
CDetailGenerator::Detach()
{
    TraceTag((tagDetail, "CDetailGenerator::Detach() -> %p", this));
    
    ReleaseGeneratedRows();
    SetReadyState(FALSE);

    // stop my hookup task
    if (_pDGTask)
    {
        _pDGTask->Release();
        _pDGTask = NULL;
    }

    ReleaseProgress();
    
    // Detach from the cursor
    if (_pDLC)
    {
        _pDLC->SetDLCEvents(0);
        _pDLC->Release();
        _pDLC = NULL;
    }

    // Release the template (both text and elements)
    FormsFreeString(_bstrHtmlText);
    _bstrHtmlText = NULL;

    // Release dataSrc and dataFld strings
    FormsFreeString(_bstrDataSrc);
    FormsFreeString(_bstrDataFld);
    _bstrDataSrc = _bstrDataFld = NULL;

    if (_pMarkup)
    {
        _pMarkup->SubRelease();
        _pMarkup = NULL;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     ReleaseGeneratedRows
//
//  Synopsis:   Release resources for generated rows
//
//-------------------------------------------------------------------------

void
CDetailGenerator::ReleaseGeneratedRows()
{
    // don't change readystate here - it could lead to unwanted reentrancy.
    // Instead, callers of this routine should call SetReadyState when the
    // coast is clear. (Bug 83183)
    CancelRequest(FALSE);

    // Release the RecordInstances
    for (int i = _aryRecInstance.Size() - 1; i >= 0; i--)
    {
        _aryRecInstance[i]->Detach();
        delete _aryRecInstance[i];
    }
    _aryRecInstance.DeleteAll();

    // Release the record generator
    if (_pRecordGenerator)
    {
        _pRecordGenerator->Detach();
        delete _pRecordGenerator;
        _pRecordGenerator = NULL;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     ReleaseRecords
//
//  Synopsis:   Release resources for generated rows
//
//-------------------------------------------------------------------------

void
CDetailGenerator::ReleaseRecords(RECORDINDEX riFirst, RECORDINDEX riLast)
{
    if (riFirst <= riLast)
    {
        // release the rows
        if (_pTable->_fEnableDatabinding)
        {
            int             iRowStart = RecordIndex2RowIndex(riFirst);
            int             iRowFinish = RecordIndex2RowIndex(riLast + 1) - 1;
            TableLayout(_pTable)->RemoveRowsAndTheirSections(iRowStart, iRowFinish);
        }
        // release the record instances
        for (int i=riLast; i>=riFirst; --i)
        {
            _aryRecInstance[i]->Detach();
            delete _aryRecInstance[i];
            _aryRecInstance.Delete(i);
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   Initialization
//
//  Arguments:  [pdlc]       -- pointer to the data layer cursor
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::Init (CDataLayerCursor         *pDLC,
                        CTable                   *pTable,
                        unsigned int              cInsertNewRowAt,
                        int                       cPageSize)
{
    TraceTag((tagDetail, "CDetailGenerator::Init() -> %p", this));

    HRESULT hr;

    Assert (pTable);
    _pTable = pTable;
    _pMarkup = _pTable->GetMarkup();
    if (_pMarkup)
        _pMarkup->SubAddRef();
    _iFirstGeneratedRow = cInsertNewRowAt;
    _cPageSize = cPageSize;

    // cache my table's provider
    _pProvider = _pTable->GetProvider();

    // get the full dataSrc and dataFld
    _pTable->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->
                GetDataSrcAndFld(&_bstrDataSrc, &_bstrDataFld);
    
    // attach to the cursor
    AssertSz(pDLC, "need a valid cursor");
    _pDLC = pDLC;
    _pDLC->AddRef();
    _pDLC->SetDLCEvents(this);

    // set up my hookup task
    _pDGTask = new CDGTask(this);
    if (!_pDGTask)
        goto MemoryError;

    // Create a record generator for assync CElements population.
    _pRecordGenerator = new CRecordGenerator ();
    if (!_pRecordGenerator)
        goto MemoryError;
    hr = _pRecordGenerator->Init(_pDLC, this);
    if (hr)
        goto Error;

    // this code sets my state so that I can survive
    // a call to nextPage before I even start generating records
    _reqCurrent.Activate(CDataLayerBookmark::TheFirst, 0, 0, 0);
    _reqCurrent.Deactivate();

Cleanup:
    RRETURN (hr);

MemoryError:
    hr = E_OUTOFMEMORY;
Error:
    Detach();
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     IsFieldKnown
//
//  Synopsis:   Determine whether the first component of the given
//              field describes a column in my datasource
//
//  Arguments:  strField    field path (dot-separated components)
//
//  Returns:    TRUE/FALSE
//
//-------------------------------------------------------------------------

BOOL
CDetailGenerator::IsFieldKnown(LPCTSTR strField)
{
    BSTR bstrHead, bstrTail;
    BOOL bResult;
    DBORDINAL ulOrdinal;

    if (!FormsIsEmptyString(strField))
    {
        // try entire field first, in case there's a column named "a.b.c" (IE6 14000)
        bResult = (S_OK == _pDLC->GetColumnNumberFromName(strField, ulOrdinal));

        if (!bResult)
        {
            FormsSplitAtDelimiter(strField, &bstrHead, &bstrTail);
            bResult = (S_OK == _pDLC->GetColumnNumberFromName(bstrHead, ulOrdinal));

            FormsFreeString(bstrHead);
            FormsFreeString(bstrTail);
        }
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     AddDataboundElement
//
//  Synopsis:   An element has entered the tree that wants to bind to the
//              record that generated one of my rows.  Post a request
//              to hook it up to the data.
//
//  Arguments:  pElement        the newly arrived element
//              id              id of binding
//              pRowContaining  the row governing pElement
//              strField        the element's dataFld (or a portion thereof)
//                              describing which column to bind
//
//----------------------------------------------------------------------------

HRESULT
CDetailGenerator::AddDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining,
                                LPCTSTR strField)
{
    HRESULT hr = S_OK;

    // if we're restoring the original template, ignore the request
    if (_fRestoringTemplate)
        goto Cleanup;
    
    // if pElement is a table, create a binder and do it the regular way
    if (pElement->Tag() == ETAG_TABLE)
    {
        hr = pElement->CreateDatabindRequest(id);
    }

    // otherwise add it to the DGTask's list - we'll hook it up later
    else
    {
        hr = _pDGTask->AddDataboundElement(pElement, id, pRowContaining, strField);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     HookUpDataboundElement
//
//  Synopsis:   Hook up an element to the data.
//
//  Arguments:  pElement        the newly arrived element
//              id              id of binding
//              pRowContaining  the row governing pElement
//              strField        the element's dataFld (or a portion thereof)
//                              describing which column to bind
//
//----------------------------------------------------------------------------

HRESULT
CDetailGenerator::HookUpDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining,
                                LPCTSTR strField)
{
    HRESULT hr = E_FAIL;
    CRecordInstance *pInstance;

    // check that the element, row, and table still have the right
    // relationship and are still in the tree
    if (pElement->IsInMarkup() && pRowContaining->IsInMarkup())
    {
        CTreeNode *pNodeElt = pElement->GetFirstBranch();
        AssertSz(pNodeElt, "IsInMarkup lied!");
        CTreeNode *pNodeRow = pNodeElt->SearchBranchToRootForScope(pRowContaining);
        
        if (pNodeRow)
        {
            CTreeNode *pNodeTable = pNodeRow->Ancestor(ETAG_TABLE);
            
            if (pNodeTable && pNodeTable->Element() == _pTable)
            {
                if (pNodeTable->Element()->IsConnectedToPrimaryWindow())
                {
                    hr = S_OK;
                }
            }
        }
    }
    if (hr)
        goto Cleanup;

    hr = _pTable->GetInstanceForRow(pRowContaining, &pInstance);
    if (hr)
        goto Cleanup;
    
    hr = CXfer::CreateBinding(pElement, id, strField, _pProvider, pInstance);
    if (SUCCEEDED(hr))
        hr = S_OK;      // S_FALSE just means object/applet wasn't ready yet

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnMetaDataAvail
//
//  Synopsis:   Call back from the record generator
//              (the meta data has arived/ Cursor is ready).
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::OnMetaDataAvailable()
{
    TraceTag((tagDetail, "CDetailGenerator::OnMetaDataAvail() -> %p", this));

    HRESULT             hr = S_OK;
    RRETURN(hr);
}




//+------------------------------------------------------------------------
//
//  Member:     OnRecordsAvailable
//
//  Synopsis:   Call back from the record generator
//              (new records are available).
//
//  Argumnets:  [pTask]     -- task pointer
//              [cRecords]  -- number of records available
//
//  Returns:    HRESULT (S_FALSE is permited, means that we have read
//              everything that was available);
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::OnRecordsAvailable(ULONG cRecords)
{
    TraceTag((tagDetail, "CDetailGenerator::OnRecordsAvailable() -> %p %ul",
                        this, cRecords));
    PerfDbgLog1(tagRecRequest, this, "got %lu records", cRecords);
    PerfDbgLog1(tagTableExpand, GetHost(), "+OnRecordsAvailable %lu", cRecords);

    HRESULT             hr;
    ULONG               cFetched;
    ULONG               cDetails = 0;
    HROW                ahRows[cBufferCapacity];
    LONG                cNewRows;
    ULONG               cRecordsSupplied = cRecords;
    RECORDINDEX         riFirst;

    Assert(cRecords <= cBufferCapacity);

    // determine how many templates we need to create
    if (_reqCurrent.IsForward())
    {
        riFirst = FirstAvailableIndex();
        cNewRows = riFirst + cRecords - RecordCount();
    }
    else
    {
        riFirst = (GetCurrentIndex()==RECORDINDEX_INVALID) ? -1 : GetCurrentIndex();
        cNewRows = cRecords - (riFirst + 1);
    }

    // ignore records that exceed the page size
    // (this can happen if Inserts occur during the request)
    if (_cPageSize > 0 && RecordCount()+cNewRows > _cPageSize)
    {
        LONG cNewRowsAmended = (RecordCount() < _cPageSize) ? _cPageSize - RecordCount() : 0;
        cRecords -= (cNewRows - cNewRowsAmended);
        cNewRows = cNewRowsAmended;
    }

    // get the records from the generator
    hr = _pRecordGenerator->FetchRecords(cRecords, ahRows, &cFetched);
    Assert(cFetched == cRecords);

    // paste a bunch of rows into the table, and update current position
    if (_reqCurrent.IsForward())
    {
        if (cNewRows > 0)
        {
            hr = Clone(cNewRows);
            if (hr)
                goto Cleanup;
            SetCurrentIndex( riFirst );
        }
    }
    else
    {
        if (cNewRows > 0)
        {
            hr = Clone(cNewRows, 0);
            if (hr)
                goto Cleanup;
            SetCurrentIndex( riFirst + cNewRows );
        }
    }

    // build detail objects from the records
    for (cDetails=0; cDetails<cRecords; ++cDetails)
    {
        RECORDINDEX riCurrent = GetCurrentIndex();

        hr = CreateDetail(ahRows[cDetails], &riCurrent);
        if (hr)
            goto Cleanup;

        SetCurrentIndex(AdvanceRecordIndex(riCurrent));

        _reqCurrent._fGotRecords = TRUE;
    }

Cleanup:
    // advance the progress item
    if (_dwProgressCookie)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pTable->GetMarkup());

        _reqCurrent._cRecordsRetrieved += cRecordsSupplied;
        pProgSink->SetProgress(_dwProgressCookie, PROGSINK_SET_POS, 0, NULL, 0,
                                      _reqCurrent._cRecordsRetrieved, 0);
    }
    
    // release the records
    _pRecordGenerator->ReleaseRecords(cRecordsSupplied);

    PerfDbgLog1(tagTableExpand, GetHost(), "-OnRecordsAvailable %lu", cRecords);
    RRETURN(hr);
}


HRESULT
CDetailGenerator::OnRequestDone(BOOL fEndOfData)
{
    HRESULT hr = S_OK;

    if (_cPageSize > 0 && fEndOfData)
    {
        // if we paged off the end of the data, delete any extra templates
        if (_reqCurrent.GotRecords())
        {
            RECORDINDEX riCurrent = GetCurrentIndex();

            if (riCurrent != RECORDINDEX_INVALID)
            {
                if (_reqCurrent.IsForward())
                {
                    // we fell of the bottom.  Delete rows at the end
                    ReleaseRecords(riCurrent, RecordCount() - 1);
                }
                else
                {
                    // we fell off the top.  Delete rows at the beginning
                    ReleaseRecords(0, riCurrent);

                    // make sure we're displaying dataPageSize rows
                    if (RecordCount() < _cPageSize)
                    {
                        SetBookmarks();
                        MakeRequest(_reqCurrent._dlbBot, 1,
                                    _cPageSize - RecordCount(), RecordCount());
                        goto Cleanup;
                    }
                }
            }
        }

        // if several next/prev page requests combined to overshoot the end of
        // the data, back up and try again
        else    // !_reqCurrent.GotRecords()
        {
            if (_reqCurrent.IsForward() && _reqCurrent._lOffset > _cPageSize)
            {
                MakeRequest(_reqCurrent._dlbStart,
                            _reqCurrent._lOffset - _cPageSize,
                            _cPageSize, 0);
                goto Cleanup;
            }
            if (!_reqCurrent.IsForward() && _reqCurrent._lOffset < -_cPageSize)
            {
                MakeRequest(_reqCurrent._dlbStart,
                            _reqCurrent._lOffset + _cPageSize,
                            -_cPageSize, RecordCount()-1);
                goto Cleanup;
            }
        }
    }

    // remember bookmarks for top and bottom rows
    EndRequest();
    // WARNING: EndRequest() changes table.readyState, which may call scripts
    // that change the world - e.g. removing table.dataSrc.  So "this" may
    // not even exist after this point.

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetHrow
//
//  Synopsis:   return the HROW associated with the given index.
//              return DB_NULL_HROW if index out of bounds

HROW
CDetailGenerator::GetHrow(RECORDINDEX ri)
{
    return (ri<0 || ri>=RecordCount())  ? DB_NULL_HROW
                                        : _aryRecInstance[ri]->GetHRow();
}


//+------------------------------------------------------------------------
//
//  Member:     RecordIndex2RecordNumber
//
//  Synopsis:   Compute the record number (offset from beginning of dataset)
//              for the record with the given index
//
//  Arguments:  ri      index of desired record
//
//  Returns:    index of corresponding record in database
//              -1      if record not found or error

long
CDetailGenerator::RecordIndex2RecordNumber(RECORDINDEX ri)
{
    HRESULT hr = E_FAIL;
    DBCOUNTITEM ulPosition = (DBCOUNTITEM)-1;
    DBCOUNTITEM ulSize;
    HROW hrow;

    // get the corresponding hrow
    hrow = GetHrow(ri);
    if (hrow == DB_NULL_HROW)
        goto Cleanup;

    // find its position in the dataset
    hr = _pDLC->GetPositionAndSize(hrow, &ulPosition, &ulSize);
    if (hr)
        goto Cleanup;

Cleanup:
    return hr ? -1 : (LONG)ulPosition;
}


//+------------------------------------------------------------------------
//
//  Member:     AssignHrowToRecord
//
//  Synopsis:   Send the given HROW to the record at the given index
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::AssignHrowToRecord(HROW hrow, RECORDINDEX ri)
{
    HRESULT hr;
    CRecordInstance *pRecInstance;

    Assert(0<=ri && ri<RecordCount());

    pRecInstance = _aryRecInstance[ri];
    hr = pRecInstance->SetHRow(hrow);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     NewRecord
//
//  Synopsis:   Called from CTabularDataAgent upon arrival of a new record
//              in the Rowset.  For now, we always assume this new record
//              arrived at the end of the rowset.
//
//  Arguments:  none
//
//  Returns:    S_OK
//
//-------------------------------------------------------------------------
HRESULT
CDetailGenerator::NewRecord()
{
    HRESULT hr = S_OK;

    // If a request is active, it'll pick up the new record in due course.
    if (_reqCurrent.IsActive())
        goto Cleanup;

    // We only care if we're either displaying the whole table, or if the
    // last page we displayed on the table was not complete
    if (_cPageSize==0 || _reqCurrent._riBot+1 < _cPageSize)
    {
        // request more records
        RECORDINDEX riStart = _reqCurrent._riBot + 1;
        CDataLayerBookmark dlbStart = (riStart<=0)? CDataLayerBookmark::TheFirst
                                                    : _reqCurrent._dlbBot;
        LONG lOffset = (riStart<=0)? 0 : 1;
        LONG cRecords = _cPageSize==0 ? MAXLONG : _cPageSize - riStart;

        hr = MakeRequest(dlbStart, lOffset, cRecords, riStart);
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CreateDetail
//
//  Synopsis:   Create an instance of an repeated elements from their templates,
//              1. Clone the template (or reuse the instance)
//              2. RefreshData for the Elements instance
//              3. add the detail (Elements) to the host.
//
//  Arguments:  [hrow]      -- HROW to generate detail for.
//              pRECORDINDEX  -- [in] address of RECORDINDEX to re-use
//                    [out] if not null, pointer to the RECORDINDEX used
//
//  Returns:    S_OK, if the detail was careted
//              S_FALSE if reached end of Element set
//              otherwise returns an error
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::CreateDetail (HROW hrow, RECORDINDEX  *pri)
{
    TraceTag((tagDetail, "CDetailGenerator::CreateDetail() -> %p (%ul)", this, hrow));

    HRESULT             hr;
    RECORDINDEX         ri = RECORDINDEX_INVALID;

    if (pri && *pri!=RECORDINDEX_INVALID)
    {
        ri = *pri;
    }
    else
    {
        // We create the record with HROW 0, then change the HROW afterward.  This
        //  prevents a bug in which we manipulate the element tree while we walk it
        hr = CreateRecordInstance(&ri);

        if (FAILED(hr))
        {
            Assert(ri == RECORDINDEX_INVALID);
            goto Error;
        }

        // we got a new record index
        Assert (ri != RECORDINDEX_INVALID);
        Assert (ri < RecordCount());
    }

    {
        // actually transfer the values.  Turn off table recalc during transfer.
        CElement::CLock Lock(GetHost(), CElement::ELEMENTLOCK_BLOCKCALC);
        PerfDbgLog1(tagTableExpand, GetHost(), "+ChangeHRow %x", hrow);
        hr = AssignHrowToRecord(hrow, ri);
        PerfDbgLog1(tagTableExpand, GetHost(), "-ChangeHRow %x", hrow);
    }
    if (hr)
        goto Error;

Cleanup:
    if (pri)
    {
        *pri = ri;
    }
    RRETURN (hr);

Error:
    DeleteDetail(ri);
    ri = RECORDINDEX_INVALID;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CreateRecordInstance
//
//  Synopsis:   Create a record instance and return index where it's stored
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDetailGenerator::CreateRecordInstance (RECORDINDEX *pri)
{
    HRESULT             hr = S_OK;
    CRecordInstance    *pRecInstance;
    RECORDINDEX         ri = RECORDINDEX_INVALID;

    pRecInstance = new CRecordInstance(_pDLC, DB_NULL_HROW);
    if (!pRecInstance)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // add the new instance to my array, either at the indicated position or
    // at the end
    if (pri && *pri != RECORDINDEX_INVALID)
    {
        ri = *pri;
        hr = _aryRecInstance.Insert(ri, pRecInstance);
    }
    else
    {
        ri = RecordCount();
        hr = _aryRecInstance.Append(pRecInstance);
    }
    if (hr)
        goto Error;

Cleanup:
    if (pri)
        *pri = hr ? RECORDINDEX_INVALID : ri;
    RRETURN(hr);

Error:
    pRecInstance->Detach();
    delete pRecInstance;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     PrepareForCloning
//
//  Synopsis:   prepare the repeated Elements of the table to Clone.
//              (Save the Element templates into a stream).
//              create a parser
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::PrepareForCloning()
{
    TraceTag((tagDetail, "CDetailGenerator::PrepareForCloning() -> %p", this));

    HRESULT hr = S_OK;

#ifndef NO_DATABINDING
    if (!_bstrHtmlText)     // else it is a refresh case
    {
        //
        // Save the table without header and footer to a null-terminated
        // stream.  Save only inside the runs of the <TABLE>.
        //
        hr = TableLayout(_pTable)->GetTemplate(&_bstrHtmlText);
    }
#endif

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Clone
//
//  Synopsis:   Clone the detail (template)..
//              Generate all the Elements from the template Elements.
//
//  Arguments:  nTemplates      number of templates to clone
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::Clone(UINT nTemplates, RECORDINDEX riClone)
{
    TraceTag((tagDetail, "CDetailGenerator::Clone() -> %p", this));

    HRESULT hr;
    UINT i;

    Verify(TableLayout(_pTable)->OpenView());

    // add the new rows
    hr = AddTemplates(nTemplates, riClone);

    // update my array of instances
    for (i=0; i<nTemplates; ++i)
    {
        RECORDINDEX ri = riClone;
        hr = CreateRecordInstance(&ri);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     AddTemplates
//
//  Synopsis:   add template rows to the table.  Don't do anything more -
//              RestoreTemplate relies on this.
//
//  Arguments:  nTemplates      number of templates to clone
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::AddTemplates(UINT nTemplates, RECORDINDEX ri)
{
    HRESULT         hr = S_OK;
    if (_pTable->_fEnableDatabinding)
    {
        BSTR    bstrTemplates = NULL;
        OLECHAR *pStr;
        UINT i;
        int iRow;
        CTableSection *pSectionInsertBefore = NULL;
        CTableLayout * pTableLayout = TableLayout(_pTable);
        static const OLECHAR * oszPreamble = _T("<TABLE>");
        static const OLECHAR * oszPostamble = _T("</TABLE>");
        const UINT cTemplateLength = FormsStringLen(_bstrHtmlText);
        const UINT cLength = wcslen(oszPostamble) +
                            nTemplates * cTemplateLength +
                            wcslen(oszPostamble) + 1;

        // allocate the string and prepare to copy
        hr = FormsAllocStringLen(NULL, cLength, &bstrTemplates);
        if (hr)
            goto Cleanup;
        pStr = bstrTemplates;

        // copy the preamble
        wcscpy(pStr, oszPreamble);
        pStr += wcslen(oszPreamble);

        // copy the template body the requested number of times
        for (i=0; i<nTemplates; ++i)
        {
            if (cTemplateLength > 0)
                wcscpy(pStr, _bstrHtmlText);
            pStr += cTemplateLength;
        }

        // copy the postamble
        wcscpy(pStr, oszPostamble);

        // locate where to paste in the cloned rows

        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;

        iRow = ri==RECORDINDEX_INVALID ? -1 : RecordIndex2RowIndex(ri);
        if (0 <= iRow && iRow < pTableLayout->GetRows())
        {
            pSectionInsertBefore = pTableLayout->_aryRows[iRow]->Section();
        }

        // paste the result into the main table
        PerfDbgLog1(tagTableExpand, GetHost(), "+PasteRows %u", nTemplates);
        hr = PasteRows(bstrTemplates, pSectionInsertBefore);
        PerfDbgLog1(tagTableExpand, GetHost(), "-PasteRows %u", nTemplates);
        if (hr)
            goto Cleanup;

    Cleanup:
        // deallocate the string
        FormsFreeString(bstrTemplates);
    }

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     PasteRows
//
//  Synopsis:   paste generated rows into the tree
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::PasteRows(BSTR bstrTemplates, CTableSection *pSectionInsertBefore)
{
    HRESULT             hr;
    BOOL                fSaveDataBindingEnabled;
    CMarkup *           pMarkupOut = NULL;
    CMarkup *           pMarkupTable = _pTable->GetMarkup();
    CDoc *              pDoc = _pTable->Doc();

    Assert(pMarkupTable);
    Assert(pDoc);

    CTableLayout *      pTableLayout = TableLayout(_pTable);
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    BSTR                bstrTagName = NULL;
    CTreeNode *         pNode;

    CMarkupPointer mpStart(pDoc), mpFinish(pDoc), mpTarget(pDoc);    

    // memo to world:  we're pasting rows, don't interfere
    fSaveDataBindingEnabled = pMarkupTable->SetDataBindingEnabled(FALSE);
    pTableLayout->PastingRows(TRUE, pSectionInsertBefore);
    
    // locate the target
    if (pSectionInsertBefore == NULL)
    {
        hr = mpTarget.MoveAdjacentToElement(_pTable, ELEM_ADJ_BeforeEnd);
    }
    else
    {
        hr = mpTarget.MoveAdjacentToElement(pSectionInsertBefore, ELEM_ADJ_BeforeBegin);
    }
    if (hr)
        goto Cleanup;
    
    // create the source, and narrow the range to include just the new TBODY
    hr = THR(pDoc->ParseString(bstrTemplates, 
                                PARSE_ABSOLUTIFYIE40URLS, 
                                &pMarkupOut, 
                                &mpStart, 
                                &mpFinish, 
                                pMarkupTable));
 
    if (hr)
        goto Cleanup;
        
    Assert(pMarkupOut);

    pMarkupOut->_fTemplate = TRUE;

    while (!hr && !(context==CONTEXT_TYPE_EnterScope && 0==FormsStringCmp(bstrTagName, _T("TABLE"))))
    {
        hr = mpStart.Right(TRUE, &context, &pNode, NULL, NULL, NULL);
        FormsFreeString(bstrTagName);
        bstrTagName = NULL;
        if (!hr)
        {
            Assert(pNode);
            hr = pNode->Element()->get_tagName(&bstrTagName);
        }
    }
    context = CONTEXT_TYPE_None;
    while (!hr && !(context==CONTEXT_TYPE_EnterScope && 0==FormsStringCmp(bstrTagName, _T("TABLE"))))
    {
        hr = mpFinish.Left(TRUE, &context, &pNode, NULL, NULL, NULL);
        FormsFreeString(bstrTagName);
        bstrTagName = NULL;
        if (!hr)
        {
            Assert(pNode);
            hr = pNode->Element()->get_tagName(&bstrTagName);
        }
    }

    // move the new TBODY into the main tree
    if (!hr)
        hr = pDoc->Move(&mpStart, &mpFinish, &mpTarget);

    // memo to world:  we're done now
    pTableLayout->PastingRows(FALSE);
    pMarkupTable->SetDataBindingEnabled(fSaveDataBindingEnabled);

Cleanup:
    // Databinding should not save undo information
    pDoc->FlushUndoData();

    // cleanup
    if (pMarkupOut)
        pMarkupOut->Release();

    FormsFreeString(bstrTagName);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Generate
//
//  Synopsis:   populate the host (table/repeater) with the Elements
//              Generate all the Elements from the template Elements.
//              (is called when populating 1st time).
//
//  Returns:    HRESULT, (S_FALSE means the end of Element set was reached).
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::Generate()
{
    TraceTag((tagDetail, "CDetailGenerator::Generate() -> %p", this));

    Assert(_pRecordGenerator);
    Assert(_aryRecInstance.Size() == 0);            // No record instances yet.

    HRESULT hr;

    hr = _pRecordGenerator->RequestMetaData();
    if (hr)
        goto Cleanup;

    if (_cPageSize<0)                   // Clip negatives.
        _cPageSize = 0;

    // Request to generate all the Elements
    hr = MakeRequest(CDataLayerBookmark::TheFirst, 0,
                        _cPageSize ? _cPageSize : MAXLONG, 0);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     RestoreTemplate
//
//  Synopsis:   Put the template back into the table.  Called when dataSrc
//              changes, and we need to go back to the original state.
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::RestoreTemplate()
{
    HRESULT hr;
    BOOL fRestoringTemplateSave = _fRestoringTemplate;

    // this works because AddTemplates just pastes the template into the
    // table.
    _fRestoringTemplate = TRUE;
    hr = AddTemplates(1);
    _fRestoringTemplate = fRestoringTemplateSave;

    RRETURN(hr);
}


HRESULT
CDetailGenerator::nextPage()
{
    TraceTag((tagDetail, "CDetailGenerator::next() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        CDataLayerBookmark dlb = _reqCurrent._dlbStart;
        LONG lOffset = _reqCurrent._lOffset + _cPageSize;
        LONG cSize = _cPageSize;
        RECORDINDEX riStart = 0;

        if (!_reqCurrent.IsActive())
        {
            dlb = _reqCurrent._dlbBot;
            lOffset = 1;
        }

        else if (_reqCurrent.IsForward())
        {
            // defaults are already correct for extending a forward move
        }

        else
        {
            cSize = -_cPageSize;
            riStart = RecordCount() > 0 ? RecordCount() - 1 : RECORDINDEX_INVALID;

            // ignore, if reversing direction past starting point
            if (lOffset > 0)
                goto Cleanup;
        }

        hr = MakeRequest(dlb, lOffset, cSize, riStart);
    }

Cleanup:
    return hr;
}

HRESULT
CDetailGenerator::previousPage()
{
    TraceTag((tagDetail, "CDetailGenerator::next() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        CDataLayerBookmark dlb = _reqCurrent._dlbStart;
        LONG lOffset = _reqCurrent._lOffset - _cPageSize;
        LONG cSize = -_cPageSize;
        RECORDINDEX riStart = RecordCount() > 0 ? RecordCount() - 1 : RECORDINDEX_INVALID;

        if (!_reqCurrent.IsActive())
        {
            dlb = _reqCurrent._dlbTop;
            lOffset = -1;
        }

        else if (!_reqCurrent.IsForward())
        {
            // defaults are already correct for extending a reverse move
        }

        else
        {
            cSize = _cPageSize;
            riStart = 0;

            // ignore, if reversing direction past starting point
            if (lOffset < 0)
                goto Cleanup;
        }

        hr = MakeRequest(dlb, lOffset, cSize, riStart);
    }

Cleanup:
    return hr;
}


HRESULT
CDetailGenerator::firstPage()
{
    TraceTag((tagDetail, "CDetailGenerator::firstPage() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        hr = MakeRequest(CDataLayerBookmark::TheFirst, 0, _cPageSize, 0);
    }

    return hr;
}


HRESULT
CDetailGenerator::lastPage()
{
    TraceTag((tagDetail, "CDetailGenerator::lastPage() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        hr = MakeRequest(CDataLayerBookmark::TheLast, 0, -_cPageSize,
                RecordCount() - 1);
    }

    return hr;
}


HRESULT
CDetailGenerator::SetPageSize(long cPageSize)
{
    HRESULT hr = S_OK;

    // if the new size is the same as the old, do nothing
    if (cPageSize == _cPageSize)
        goto Cleanup;

    // set the new page size
    _cPageSize = cPageSize;

    // if the new size is 0, regenerate the full table
    if (_cPageSize == 0)
    {
        hr = MakeRequest(CDataLayerBookmark::TheFirst, 0, MAXLONG, 0);
        goto Cleanup;
    }

    // if the table is shrinking, delete rows from the end
    if (_cPageSize < RecordCount())
    {
        ReleaseRecords(_cPageSize, RecordCount() - 1);
        SetBookmarks();
    }

    // if there's an active request, we use the top bookmark so that
    // we'll repopulate the entire table and guarantee that there are no
    // gaps or overlap (as there might be if we used the bottom bookmark)
    if (_reqCurrent.IsActive())
    {
        SetBookmarks();
        hr = MakeRequest(_reqCurrent._dlbTop, 0, _cPageSize, 0);
    }
    
    // if the (inactive) table is growing, add records at the end
    else if (_cPageSize > RecordCount())
    {
        hr = MakeRequest(_reqCurrent._dlbBot, 1,
                        _cPageSize - RecordCount(), RecordCount());
    }
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     DeleteDetail
//
//  Synopsis:   Delete the detail section
//
//  Arguments:  [RECORDINDEX] -- cookie of a new detail
//
//  Note:       the detail might be partialy populated, in this case it is the
//              last one constructed (cloned).
//
//-------------------------------------------------------------------------

void
CDetailGenerator::DeleteDetail (RECORDINDEX  riDelete)
{
    int iRowDelete;

    if (riDelete == RECORDINDEX_INVALID)
        goto Done;

    // detach and delete the record
    _aryRecInstance[riDelete]->Detach();
    delete _aryRecInstance[riDelete];
    _aryRecInstance.Delete(riDelete);

    // delete the corresponding rows from the table
    if (_pTable->_fEnableDatabinding)
    {
        iRowDelete = RecordIndex2RowIndex(riDelete);
        TableLayout(_pTable)->RemoveRowsAndTheirSections(iRowDelete, iRowDelete + GetTemplateSize() - 1);
    }

Done:
    return;
}



//+------------------------------------------------------------------------
//
//  Member:     AdvanceRecordIndex
//
//  Synopsis:   get the next RecordIndex, using the current iteration direction
//
//  Arguments:  [riPrev]         -- previous RecordIndex
//
//-------------------------------------------------------------------------

RECORDINDEX
CDetailGenerator::AdvanceRecordIndex(RECORDINDEX riPrev)
{
    if (riPrev != RECORDINDEX_INVALID)
    {
        if (_reqCurrent.IsForward())
        {
            if (++riPrev >= RecordCount())
                riPrev = RECORDINDEX_INVALID;
        }
        else
        {
            if (--riPrev < 0)
                riPrev = RECORDINDEX_INVALID;
        }
    }
    return riPrev;
}



//+------------------------------------------------------------------------
//
//  Member:     RetreatRecordIndex
//
//  Synopsis:   get the previous RecordIndex, using the current iteration direction
//
//  Arguments:  [riPrev]         -- previous RecordIndex
//
//-------------------------------------------------------------------------

RECORDINDEX
CDetailGenerator::RetreatRecordIndex(RECORDINDEX riPrev)
{
    if (_reqCurrent.IsForward())
        riPrev = ((riPrev == RECORDINDEX_INVALID) ? RecordCount() : riPrev) - 1;
    else
        riPrev = ((riPrev == RECORDINDEX_INVALID) ? -1 : riPrev) + 1;
    return riPrev;
}



//+==========================================================================
//
// Request to record generator
//

//+------------------------------------------------------------------------
//
//  Member:     Activate (CRecRequest)
//
//  Synopsis:   initialize a new request
//

void
CDetailGenerator::CRecRequest::Activate(const CDataLayerBookmark& dlbStart,
                                LONG lOffset, LONG cRecords, RECORDINDEX riStart)
{
    _dlbStart   = dlbStart;
    _lOffset    = lOffset;
    _riCurrent  = riStart;
    _cRecords   = cRecords;
    _fActive    = TRUE;
    _fGotRecords = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     MakeRequest
//
//  Synopsis:   make a request to the record generator
//
//  Arguments:  dlbStart        bookmark for starting location
//              lOffset         offset from bookmark to first record desired
//              cRecords        number of records desired (ULMAX = all records)

HRESULT
CDetailGenerator::MakeRequest(const CDataLayerBookmark& dlbStart, LONG lOffset,
                                LONG cRecords, RECORDINDEX riStart)
{
    const ULONG CHUNK_SIZE = 10;
    HRESULT hr;
    RECORDINDEX riRequest = riStart;
    IProgSink *pProgSink = NULL;
    DBCOUNTITEM ulMax = cRecords >= 0 ? cRecords : -cRecords;
    DWORD dwProgressCookieNew;

    // cancel the active request (if any)
    hr = CancelRequest(FALSE);
    if (hr)
        goto Cleanup;

    PerfDbgLog3(tagRecRequest, GetHost(), "+RecReqest off=%ld count=%ld index=%ld",
                lOffset, cRecords, riStart);
#ifdef PROFILE_REPEATED_TABLES
    StartCAP();         // for perf of repeated tables - ends in EndRequest
#endif

    // start the new request
    if (riRequest >= RecordCount())
        riRequest = RECORDINDEX_INVALID;
    _reqCurrent.Activate(dlbStart, lOffset, cRecords, riRequest);

    hr = _pRecordGenerator->RequestRecordsAtBookmark(dlbStart, lOffset, cRecords);
    if (hr)
    {
        CancelRequest();
        goto Cleanup;
    }

    // put the table into "chunk" mode.
    TableLayout(_pTable)->SetDirtyRowThreshold(CHUNK_SIZE);
    _fInteractive = TRUE;

    // if it's an open-ended task, ask the cursor how long
    if (cRecords == MAXLONG)
    {
        Assert(_pDLC);
        IGNORE_HR(_pDLC->GetSize(&ulMax));
    }

    // start up a progress item to track table expansion
    _reqCurrent._cRecordsRetrieved = 0;
    pProgSink = CMarkup::GetProgSinkHelper(_pTable->GetMarkup());

    hr = THR(pProgSink->AddProgress(PROGSINK_CLASS_DATABIND, &dwProgressCookieNew));
    if (hr)
        goto SetReadyState;
    TraceTag((tagTableProgress, "AddProgress %x for table %d (%x)",
                dwProgressCookieNew, _pTable->_nSerialNumber, _pTable));

    ReleaseProgress();
    _dwProgressCookie = dwProgressCookieNew;
    
    hr = THR(pProgSink->SetProgress(_dwProgressCookie,
            PROGSINK_SET_STATE | PROGSINK_SET_IDS | PROGSINK_SET_POS | PROGSINK_SET_MAX,
            PROGSINK_STATE_LOADING, NULL, IDS_LOADINGTABLE, 0, ulMax));
    if (hr)
        goto SetReadyState;

SetReadyState:
    // setting the ready state fires an event and may cause reentrancy
    _pTable->SetReadyStateTable(READYSTATE_INTERACTIVE);
    // (this) is no longer valid!!!

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CancelRequest
//
//  Synopsis:   cancel an active request to the record generator
//

HRESULT
CDetailGenerator::CancelRequest(BOOL fSetReadyState)
{
    HRESULT hr = S_OK;

    if (_reqCurrent.IsActive())
    {
        PerfDbgLog(tagRecRequest, GetHost(), "request cancelled");
        IGNORE_HR(_pRecordGenerator->CancelRequest());
        IGNORE_HR(EndRequest(fSetReadyState));
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     EndRequest
//
//  Synopsis:   post processing, when request terminates
//

HRESULT
CDetailGenerator::EndRequest(BOOL fSetReadyState)
{
    HRESULT hr = S_OK;
    Assert(_reqCurrent.IsActive());

    // if request produced new records, remember bookmarks for top and bottom rows
    if (_reqCurrent.GotRecords())
    {
        SetBookmarks();
    }

    _reqCurrent.Deactivate();

    // change the table's readystate
    if (fSetReadyState && _pDLC->IsComplete())
    {
        SetReadyState();
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     SetBookmarks
//
//  Synopsis:   remember a bookmark for the first and last displayed records.
//              This association is used when moving to the next/previous page
//              of a paged table.

void
CDetailGenerator::SetBookmarks()
{
    CDataLayerBookmark dlb;

    if (RecordCount() > 0)
    {
        if (S_OK == _pDLC->CreateBookmark(GetHrow(0), &dlb))
        {
            _reqCurrent._dlbTop = dlb;
            _reqCurrent._riTop = 0;
        }

        if (S_OK == _pDLC->CreateBookmark(GetHrow(RecordCount()-1), &dlb))
        {
            _reqCurrent._dlbBot = dlb;
            _reqCurrent._riBot = RecordCount() - 1;
        }
    }
}


//+-------------------------------------------------------------------------
// Member:              FindHrow
//
// Synopsis:    Locate the position in the table where the given hrow belongs
//
// Arguments:   hrow        the desired hrow
//              pri         pointer to return value:  index where hrow should be
//                          inserted, or RECORDINDEX_INVALID if hrow doesn't
//                          belong in the active area
//
// Returns:             S_OK        hrow found, *pri set to its index
//              S_FALSE     hrow not found, *pri set to where it belongs
//              E_FAIL      error or hrow out of bounds, *pri set to INVALID

HRESULT
CDetailGenerator::FindHrow(HROW hrow, RECORDINDEX *pri)
{
    CDataLayerBookmark dlbSearch;
    HRESULT hr;

    hr = _pDLC->CreateBookmark(hrow, &dlbSearch);
    if (hr)
        goto Cleanup;

    hr = FindBookmark(dlbSearch, pri);

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
// Member:              FindBookmark
//
// Synopsis:    Locate the position in the table where the given bookmark belongs
//
// Arguments:   dlb         the desired hrow
//              pri         pointer to return value:  index where hrow should be
//                          inserted, or RECORDINDEX_INVALID if dlb doesn't
//                          belong in the active area
//
// Returns:             S_OK        dlb found, *pri set to its index
//              S_FALSE     dlb not found, *pri set to where it belongs
//              E_FAIL      error or dlb out of bounds, *pri set to INVALID

HRESULT
CDetailGenerator::FindBookmark(const CDataLayerBookmark& dlbSearch, RECORDINDEX *pri)
{
    RECORDINDEX riFirst = FirstActiveIndex();
    RECORDINDEX riLast = LastActiveIndex();
    RECORDINDEX riLow=riFirst, riHigh=riLast+1, riMid;
    CDataLayerBookmark dlbMid;
    HRESULT hr;

    // binary search
    while (riLow < riHigh)
    {
        riMid = (riLow + riHigh)/2;
        hr = _pDLC->CreateBookmark(GetHrow(riMid), &dlbMid);
        if (hr)
            goto Cleanup;

        if (dlbMid < dlbSearch)
            riLow = riMid + 1;
        else
            riHigh = riMid;
    }

    // now see if the hrow already exists
    if (riLow > riLast)
        hr = S_FALSE;
    else
    {
        hr = _pDLC->CreateBookmark(GetHrow(riLow), &dlbMid);
        if (hr)
            goto Cleanup;
        if (dlbMid != dlbSearch)
            hr = S_FALSE;
    }

Cleanup:
    // return INVALID if any errors occurred, or if the answer is out of range
    // (except in the special case of a nonpaged, fully-expanded table)
    if (FAILED(hr) ||
        (_reqCurrent.IsActive() && riLow > LastActiveIndex()) ||
        (!_reqCurrent.IsActive() && _cPageSize > 0 && riLow >= _cPageSize) )
        riLow = RECORDINDEX_INVALID;
    *pri = riLow;

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
// Member:      InsertBeforeCurrentPage (private helper)
//
// Synopsis:    When a new row is inserted before the current page of
//              a paged table, this routine decides whether it should
//              be displayed.  
//
// Arguments:   hrow    - new row.  Caller ensures it belongs before current page
//
// Returns:     index where the new row should be displayed.  Namely:
//                  0                       - it should be displayed
//                  RECORDINDEX_INVALID     - it should not be displayed

RECORDINDEX
CDetailGenerator::InsertBeforeCurrentPage(HROW hrow)
{
    Assert(_cPageSize > 0);
    RECORDINDEX riReturn = RECORDINDEX_INVALID;

    // don't display if we're still populating, or if we're already showing
    // a full page.
    if (_reqCurrent.IsActive() || RecordCount() >= _cPageSize)
        return RECORDINDEX_INVALID;

    // now it makes sense to add a record at the top of an incomplete
    // page.  Next check if the new record is really the last undisplayed
    // record.
    CDataLayerBookmark dlbNew;
    HROW hrowNext = DB_NULL_HROW;
    DBCOUNTITEM cRows;
    HRESULT hr = _pDLC->CreateBookmark(hrow, &dlbNew);
    if (!hr)
    {
        // find the next hrow after the new one
        hr = _pDLC->GetRowsAt(dlbNew, 1, 1, &cRows, &hrowNext);
        if (!hr && cRows == 1)
        {
            // if it's the first displayed row, we can display the new one
            if (RecordCount() > 0 && hrowNext == GetHrow(0))
            {
                riReturn = 0;
            }
        }
        // if it's the last row of all, and we're not displaying anything,
        // we can display the new one
        // COMPAT (sambent)  RDS returns DB_E_BADSTARTPOSITION when we ask for
        // the next row after the last one, instead of DB_S_ENDOFROWSET like
        // the doc says it's supposed to.  We'll treat it the same, but
        // I don't like it.  (see IE5 98023)
        else if (RecordCount() == 0 &&
                    (hr == DB_S_ENDOFROWSET || hr == DB_E_BADSTARTPOSITION))
        {
            riReturn = 0;
        }

        // release the row we obtained
        if (hrowNext != DB_NULL_HROW)
            _pDLC->ReleaseRows(1, &hrowNext);
    }

    return riReturn;
}


//+-------------------------------------------------------------------------
// Member:              AllChanged (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::AllChanged()
{
    CElement * pElement = GetHost();

    // Make sure it's a table site.
    if (pElement->Tag()==ETAG_TABLE)
    {
        DYNCAST(CTable, pElement)->refresh();     // refresh it.
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              RowsChanged (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::RowsChanged(DBCOUNTITEM cRows, const HROW *ahRows)
{
    RECORDINDEX ri;

    for (ULONG k=0; k<cRows; ++k)
        if (S_OK == FindHrow(ahRows[k], &ri))
            AssignHrowToRecord(ahRows[k], ri);
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FieldsChanged (public, CDataLayerCursorEvents)
//
// Synopsis:    forward notification to all my instances
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::FieldsChanged(HROW hRow, DBORDINAL cColumns, DBORDINAL aColumns[])
{
    RECORDINDEX ri;

    if (S_OK == FindHrow(hRow, &ri))
        IGNORE_HR(_aryRecInstance[ri]->OnFieldsChanged(hRow, cColumns, aColumns));
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      RowsInserted (public, CDataLayerCursorEvents)
//
// Synopsis:    add new rows to the table
//
// Arguments:   cRows       number of new rows
//              ahRows      HROWs for the new rows
//
// Returns:     HRESULT

HRESULT
CDetailGenerator::RowsInserted(DBCOUNTITEM cRows, const HROW *ahRows)
{
    HRESULT hr = S_OK;
    DBCOUNTITEM cRowsInserted = 0;

    for (ULONG iRow=0; iRow<cRows; ++iRow)
    {
        // locate the new row in the up-to-date area of the table.
        RECORDINDEX riInsert = RECORDINDEX_INVALID;
        Verify(S_OK != FindHrow(ahRows[iRow], &riInsert));

        // ignore insert if not in bounds.  The new row is either outside
        // the current page of the table, or the active request will find it
        // soon anyway.
        if (riInsert == 0 && _cPageSize > 0)
            riInsert = InsertBeforeCurrentPage(ahRows[iRow]);
        if (riInsert == RECORDINDEX_INVALID)
            continue;

        // insert a new row at the desired place
        hr = Clone(1, riInsert);
        if (hr)
            goto Cleanup;
        hr = CreateDetail(ahRows[iRow], &riInsert);
        if (hr)
            goto Cleanup;

        // if we've exceeded the page size, trim
        if (_cPageSize > 0 && RecordCount() > _cPageSize)
        {
            DeleteDetail(RecordCount() - 1);
        }

        // tell the active request what happened
        if (_reqCurrent.IsActive())
        {
            RECORDINDEX riCurrent = GetCurrentIndex();
            if (riCurrent != RECORDINDEX_INVALID &&
                (_reqCurrent.IsForward() && riCurrent > riInsert))
            {
                SetCurrentIndex(AdvanceRecordIndex(riCurrent));
            }
        }

        ++ cRowsInserted;
    }

Cleanup:
    // if rows arrived, we told the table not to recalc while we pasted stuff in.
    // Tell it to recalc now.
    if (cRowsInserted > 0)
    {
        TableLayout(_pTable)->Resize();

        // adjust bookmarks, if necessary
        SetBookmarks();
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              Deleting Rows (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::DeletingRows(DBCOUNTITEM cRows, const HROW *ahRows)
{
    return S_OK;
}



HRESULT
CDetailGenerator::RowsDeleted(DBCOUNTITEM cRows, const HROW *ahRows)
{
    HRESULT hr = S_OK;
    int iRow;
    int cRecordsDeleted = 0;
    RECORDINDEX riDelete = 0;   // force first delete to do a full search

    // delete in reverse order - this is slightly gentler for shifting rows
    for (iRow = cRows-1;  iRow >=0;  --iRow)
    {
        HROW hrowDelete = ahRows[iRow];

        // check for special case:  deleting a bunch of consecutive rows
        if (riDelete > 0 && GetHrow(riDelete-1) == hrowDelete)
        {
            riDelete = riDelete - 1;
        }
        // otherwise do a linear search
        else
        {
            for (riDelete = RecordCount()-1;  riDelete >= 0;  --riDelete)
            {
                if (GetHrow(riDelete) == hrowDelete)
                    break;
            }
        }

        // if we found a record to delete, do so
        if (riDelete >= 0)
        {
            DeleteDetail(riDelete);
            ++ cRecordsDeleted;

            // tell the active request what happened
            if (_reqCurrent.IsActive())
            {
                RECORDINDEX riCurrent = GetCurrentIndex();
                if (riCurrent != RECORDINDEX_INVALID &&
                    (_reqCurrent.IsForward() && riCurrent > riDelete))
                {
                    SetCurrentIndex(RetreatRecordIndex(riCurrent));
                }
            }
        }
    }

    // if we did any work, adjust for it
    if (cRecordsDeleted > 0)
    {
        SetBookmarks();

        // for paged tables, fill in the end from database
        if (_cPageSize > 0)
        {
            MakeRequest(_reqCurrent._dlbBot, +1,
                            _cPageSize - RecordCount(), RecordCount());
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              DeleteCancelled (public, CDataLayerCursorEvents)
//
// Synopsis:    notification that a delete-row operation is cancelled.
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::DeleteCancelled(DBCOUNTITEM cRows, const HROW *ahRows)
{
    return S_OK;
}


HRESULT
CDetailGenerator::RowsAdded()
{
    NewRecord();
    return S_OK;
}


HRESULT
CDetailGenerator::PopulationComplete()
{
    SetReadyState();

    return S_OK;
}


void
CDetailGenerator::SetReadyState(BOOL fResize /* = TRUE */)
{
    if (!_reqCurrent.IsActive() && _pDGTask->IsIdle())
    {
        // take the table out of "chunk" mode and do a full recalc/redisplay
        CTableLayout *pTableLayout = TableLayout(_pTable);
        pTableLayout->SetDirtyRowThreshold(0);
        if (fResize && _pTable->GetFirstBranch())
        {
            pTableLayout->_fDatabindingRecentlyFinished = TRUE;
            pTableLayout->Resize();
        }

        if (_fInteractive)
        {
#ifdef PROFILE_REPEATED_TABLES
            StopCAP();      // for perf of repeated tables - starts in MakeRequest
#endif
            PerfDbgLog(tagRecRequest, GetHost(), "-RecRequest");
            
            // we can't call ReleaseProgress from here, because of 
            // the possible reentrancy from table.onreadystate change.
            // Instead, imitate it with local variables.
            CMarkup *pMarkup = _pTable->GetMarkup();
            if (pMarkup == NULL)
                pMarkup = _pMarkup;
            IProgSink *pProgSink = CMarkup::GetProgSinkHelper(pMarkup);
            DWORD dwProgCookie = _dwProgressCookie;
            _dwProgressCookie = 0;
            WHEN_DBG( CTable *pTable = _pTable; )   // for TraceTag only!
            WHEN_DBG ( int nSerialNumber = _pTable->_nSerialNumber; )   // TraceTag only
            
            _fInteractive = FALSE;
            _pTable->SetReadyStateTable(READYSTATE_COMPLETE);
            // because table.onreadystatechange may alter the page,
            // assume (this) is no longer valid
            
            // ReleaseProgress();
            if (dwProgCookie && pProgSink)
            {
                TraceTag((tagTableProgress, "DelProgress (ready state) %x for table %d (%x)",
                            dwProgCookie, nSerialNumber, pTable));
                pProgSink->DelProgress(dwProgCookie);
            }
        }
    }
}


void
CDetailGenerator::ReleaseProgress()
{
    // release the progress item that's tracking table expansion
    if (_dwProgressCookie)
    {
        CMarkup *pMarkup = _pTable->GetMarkup();
        if (pMarkup == NULL)
            pMarkup = _pMarkup;
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(pMarkup);

        if (pProgSink)
        {
            TraceTag((tagTableProgress, "Release Progress %x for table %d (%x)",
                        _dwProgressCookie, _pTable->_nSerialNumber, _pTable));
            pProgSink->DelProgress(_dwProgressCookie);
        }
        _dwProgressCookie = 0;
    }
}

void CDetailGenerator::AccumulateServicedRows()
{
    // notify table that this row was serviced and hooked up (data was transfered)
    TableLayout(_pTable)->AccumulateServicedRows();
}

/////////////////////////////////////////////////////////////////////////////
//
//      CDGTask  -  this task is responsible for hooking up databound
//                  elements that have been added to a repeated table
//

MtDefine(CDGTask, DataBind, "CDGTask");
MtDefine(CDGTask_aryBindRequest_pv, CDGTask, "CDGTask::_aryBindRequest::_pv");

CDGTask::CDGTask(CDetailGenerator *pDG) :
    CTask(TRUE),
    _pDG(pDG),
    _aryBindRequest(Mt(CDGTask_aryBindRequest_pv))
{
}

//+---------------------------------------------------------------------------
//
//  Member:     AddDataboundElement
//
//  Synopsis:   An element has entered the tree that wants to bind to the
//              record that generated one of my rows.  Post a request
//              to hook it up to the data.
//
//  Arguments:  pElement        the newly arrived element
//              id              id of binding
//              pRowContaining  the row governing pElement
//              strField        the element's dataFld (or a portion thereof)
//                              describing which column to bind
//
//----------------------------------------------------------------------------

HRESULT
CDGTask::AddDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining,
                                LPCTSTR strField)
{
    HRESULT hr = S_OK;

    CBindRequestRecord *pBindRequest = _aryBindRequest.Append();
    if (pBindRequest)
    {
        UINT cbField;

        pBindRequest->pElement = pElement;
        pBindRequest->id = id;
        pBindRequest->pRowContaining = pRowContaining;
        pRowContaining->DataTransferRequested();
        cbField = lstrlen(strField);
        if (cbField)                    //duplicate strField into our own buffer
        {
            pBindRequest->strField = new TCHAR[cbField+1];
            if (pBindRequest->strField)
                lstrcpy(pBindRequest->strField, strField);
        }
        pElement->AddRef();         // don't let element die
        pRowContaining->AddRef();   // or row, either
        SetBlocked(FALSE);          // get scheduled to run
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     OnRun (CTask)
//
//  Synopsis:   Hook up all the elements currently on my list.
//
//----------------------------------------------------------------------------

void
CDGTask::OnRun(DWORD dwTimeout)
{
    UINT i;
    UINT cSize = _aryBindRequest.Size();
    CTableRow * pRow = NULL;
    
    // hook up the instances to the cloned rows
    for (i = 0;  i < cSize;  ++i)
    {
        // copy the current request.  We can't use a pointer to it, because
        // new requests might arrive and reallocate the array.
        CBindRequestRecord request = _aryBindRequest[i];
        
        IGNORE_HR(_pDG->HookUpDataboundElement(request.pElement,
                                    request.id,
                                    request.pRowContaining,
                                    request.strField));

        if (pRow != request.pRowContaining)
        {
            pRow = request.pRowContaining;
            pRow->DataTransferServiced();
            _pDG->AccumulateServicedRows();
        }
        if (request.strField)
            delete [] request.strField;
        request.pElement->Release();  // addref'd when added to array
        request.pRowContaining->Release();  // addref'd when added to array
    }


    // now delete the requests I've serviced.  More requests may have arrived
    // during the loop above, so be careful.  This is why we cache the array
    // size before looping.
    _aryBindRequest.DeleteMultiple(0, cSize-1);

    // if there are new elements on my list, schedule myself to run again
    SetBlocked( _aryBindRequest.Size() == 0 );

    // set table's readystate
    _pDG->SetReadyState();
}


//+---------------------------------------------------------------------------
//
//  Member:     OnTerminate (CTask)
//
//  Synopsis:   Release elements currently on my list.
//
//----------------------------------------------------------------------------

void
CDGTask::OnTerminate()
{
    UINT i;
    CBindRequestRecord *pBindRequest;
    UINT cSize = _aryBindRequest.Size();
    
    // release any unserviced requests
    for (pBindRequest=_aryBindRequest, i=cSize;
         i > 0;
         ++pBindRequest, --i)
    {
        pBindRequest->pElement->Release();  // addref'd when added to array
        pBindRequest->pRowContaining->Release();  // addref'd when added to array
    }

    // delete all requests.
    _aryBindRequest.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\convert.cxx ===
//+---------------------------------------------------------------------------
//
//  Maintained by: Jerry, Terry and Ted
//
//  Microsoft DataDocs
//  Copyright (C) Microsoft Corporation, 1994-1996
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  File:       site\dbind\convert.cxx
//
//  Contents:   Core conversion code.
//
//  Classes:    CTypeCoerce
//
//  Functions:  None.
//

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DBINDING_HXX_
#define X_DBINDING_HXX_
#include "dbinding.hxx"
#endif

/////////////////////////////////////////////////////////////////////////////
//  Steps to add a new type for conversion:
//
//      1.  Add a new canonical type to CAN_TYPE list.
//
//      2.  Modify CanonicalizeType to canonicalize a new DBTYPE (VARTYPE) to
//          the CAN_TYPE value.  NOTE: Be careful of any overlap between DBTYPE
//          and VARTYPE, currently there are none.
//
//      3.  Update the JumpTable to include the address of routines to do the
//          actual conversion.
//
//      4.  Add CallStr entry for new TYPE_xxxx (convert from type to string)
//          add CallThru entry for new TYPE_xxxx.
//
//      5.  Test it.
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
//  The following the conversion matrix of database types to OLE types and
//  vice versa.
//
//
// FROM                                    TO
// ====                                    ==
//
//         Null  I2    I4    R4    R8    CY    DATE  BSTR  BOOL  VARI 
//         ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
//  Empty  *NuNu XNuI2 XNuI4 XNuR4 XNuR8 XNuCY XNuDT XNuBS XNuBO XNuVA
//  I2     XI2Nu *I2I2 XI2I4 XI2R4 XI2R8  I2CY  I2DT  I2BS  I2BO  I2VA
//  I4     XI4Nu  I4I2 *I4I4  I4R4 XI4R8  I4CY  I4DT  I4BS  I4B0  I4VA
//  R4     XR4Nu  R4I2  R4I4 *R4R4 XR4R8  R4CY  R4DT  R4BS  R4B0  R4VA
//  R8     XR8Nu  R8I2  R8I4  R8R4 *R8R8  R8CY  R8DT  R8BS  R8BO  R8VA
//  CY     XCYNu  CYI2  CYI4  CYR4  CYR8 *CYCY  CYDT  CYBS  CYBO  CYVA
//  DATE   XDTNu  DTI2  DTI4  DTR4  DTR8  DTCY *DTDT  DTBS  DTBO  DTVA
//  BSTR   XBSNu  BSI2  BSI4  BSR4  BSR8  BSCY  BSDT *BSBS  BSBP  BSVA
//  BOOL   XBONu XBOI2 XBOI4 XBOR4 XBOR8  BOCY  BODT  BOBS *BOBO  BOVA
//  VARI   XVANu  VAI2  VAI4  VAR4  VAR8  VACY  VADT  VABS  VABO *VAVA
//
//
//  Key
//  ===
//
//  *     = copy                  Nu    null
//  Xxxxx = upcast                I2    short
//                                I4    long
//                                R4    float
//                                R8    double
//                                CY    currency
//                                DATE  date
//                                BSTR  BSTR
//                                BOOL  boolean
//
// NOTE:
// =====
//
//      The above table is a static array named JumpTable located in the routine
//      ConvertData.
//
////////////////////////////////////////////////////////////////////////////////

// NO_CONVERSION  - Signals that the types are identical.
// PROCESS_UPCAST - Signals that the type can be upcast to the to type w/o worry
//                  of overflow checking.
// PROCESS_NOCALL - Signals processing must be done but the there is no routine
//                  to call.
#define NO_CONVERSION   ((void *)0)
#define PROCESS_UPCAST  ((void *)1)
#define PROCESS_NOCALL  ((void *)~0)



//+---------------------------------------------------------------------------
//
//  Member:     CanonicalizeType (public static member)
//
//  Synopsis:   Canonicalize the DBTYPE and VARTYPES.  Notice that the types
//              match one for one except for types > DBTYPE_STR which are than
//              canonicalized.
//
//              The canonicalizing is based on the values for DBTYPE_xxxx (the
//              VT_xxxx values <= 13 match exactly the DBTYPEs the VTs largest
//              value is 72).  We are interested in I2, I4, R4, R8, CY, DATE,
//              BSTR, BOOL, and VARIANT
//
//                  DBTYPE_EMPTY          0     (Remove Group 1)
//                  DBTYPE_NULL           1     (Group 1)
//                  DBTYPE_I2             2
//                  DBTYPE_I4             3
//                  DBTYPE_R4             4
//                  DBTYPE_R8             5
//                  DBTYPE_CY             6
//                  DBTYPE_DATE           7
//                  DBTYPE_BSTR           8
//                  DBTYPE_DISPATCH       9     (Remove Group 2)
//                  DBTYPE_ERROR         10     (Remove)
//                  DBTYPE_BOOL          11
//                  DBTYPE_VARIANT       12
//                  DBTYPE_UNKNOWN       13     (Remove Group 3)
//                  DBTYPE_ARRAY       8192     (Remove)
//                  DBTYPE_BYREF      16384     (Remove)
//                  DBTYPE_RESERVED   32768     (Remove)
//                  DBTYPE_UI1          128     (Remove)
//                  DBTYPE_I8            20     (Remove)
//                  DBTYPE_GUID          72     (Remove)
//                  DBTYPE_VECTOR      4096     (Remove)
//                  DBTYPE_STR          129     (Remove)
//                  DBTYPE_WSTR         130     (Remove)
//                  DBTYPE_NUMERIC      131     (Remove)
//
//  Arguments:  None
//
//  Returns:    Returns the canonical type (CAN_TYPE)
//

HRESULT
CTypeCoerce::CanonicalizeType (DBTYPE dbType, CAN_TYPE & canType)
{
    static const CAN_TYPE aTypeSimple[] =
    {
        /* DBTYPE_EMPTY     */ TYPE_END,
        /* DBTYPE_NULL      */ TYPE_NULL,
        /* DBTYPE_I2        */ TYPE_I2,
        /* DBTYPE_I4        */ TYPE_I4,
        /* DBTYPE_R4        */ TYPE_R4,
        /* DBTYPE_R8        */ TYPE_R8,
        /* DBTYPE_CY        */ TYPE_CY,
        /* DBTYPE_DATE      */ TYPE_DATE,
        /* DBTYPE_BSTR      */ TYPE_BSTR,
        /* DBTYPE_IDISPATCH */ TYPE_END,
        /* DBTYPE_ERROR     */ TYPE_END,
        /* DBTYPE_BOOL      */ TYPE_BOOL,
        /* DBTYPE_VARIANT   */ TYPE_VARIANT,
    };
    
    Assert(DBTYPE_EMPTY == 0);
    Assert(DBTYPE_NULL == DBTYPE_EMPTY+1);
    Assert(DBTYPE_I2 == DBTYPE_NULL + 1);
    Assert(DBTYPE_I4 == DBTYPE_I2 + 1);
    Assert(DBTYPE_R4 == DBTYPE_I4 + 1);
    Assert(DBTYPE_R8 == DBTYPE_R4 + 1);
    Assert(DBTYPE_CY == DBTYPE_R8 + 1);
    Assert(DBTYPE_DATE == DBTYPE_CY + 1);
    Assert(DBTYPE_BSTR == DBTYPE_DATE + 1);
    Assert(DBTYPE_IDISPATCH == DBTYPE_BSTR + 1);
    Assert(DBTYPE_ERROR == DBTYPE_IDISPATCH + 1);
    Assert(DBTYPE_BOOL == DBTYPE_ERROR + 1);
    Assert(DBTYPE_VARIANT == DBTYPE_BOOL + 1);
    Assert(DBTYPE_IUNKNOWN == DBTYPE_VARIANT + 1);
    Assert(DBTYPE_WSTR >  DBTYPE_IUNKNOWN);
    Assert(DBTYPE_HCHAPTER >  DBTYPE_IUNKNOWN);
    

    HRESULT     hr = S_OK;
    
    canType = TYPE_END;
    
    if (dbType < ARRAY_SIZE(aTypeSimple))
    {
        canType = aTypeSimple[dbType];
    }
    else if (dbType == DBTYPE_HCHAPTER)
    {
        canType = TYPE_CHAPTER;
    }

    if (canType == TYPE_END)
    {
        hr = OLE_E_CANTCONVERT;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     BoolFromStr, private helper (static)
//
//  Synopsis:   used instead of OLE Automation's normal VARIANTBoolFromStr
//              because OLE's conversions aren't compatible enough with
//              Netscape's javascript conversions.
//
//  Arguments:  OLECHAR *       String to convert to BOOL
//
//  Returns:    VARIANT_BOOL    VB_TRUE (0xffff) or VB_FALSE (0x0000)
//                              (be careful, VARIANT_BOOLs are only 16 bits,
//                              normal Win32 Bools are 32 bits!)
//
VARIANT_BOOL
CTypeCoerce::BoolFromStr(OLECHAR *pValueIn)
{
    // The NULL string is FALSE, all other strings are TRUE
    return (pValueIn==NULL || *pValueIn==0) ? VB_FALSE : VB_TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CallStr (private static member)
//
//  Synopsis:   Call low-level OLE conversion VarBstrFromXXXX.
//
//  Arguments:  pCall   - Function to call.
//              inType  - Type of pIn
//              pIn     - Value of data
//              outType - Type of pOut
//              pOut    - Value of data
//
//  Returns:    Returns HRESULT from VarBstrFromXXXX.
//

// The generic function pointer types which CallStr uses.
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmI2)(short, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmI4)(long, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmR4)(float, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmR8)(double, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmCy)(CY, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmDate)(DATE, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmBool)(VARIANT_BOOL, LCID, unsigned long,
                                         BSTR FAR*);

HRESULT
CTypeCoerce::CallStr (void *pCall,
                      CAN_TYPE inType, void * pIn,
                      void * pOut)
{
    HRESULT hr = E_UNEXPECTED;

    BSTR bstr = 0;

    switch (inType)
    {
        case TYPE_I2:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmI2)pCall) (*(short *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_I4:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmI4)pCall) (*(long *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_R4:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmR4)pCall) (*(float *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_R8:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmR8)pCall) (*(double *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_CY:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmCy)pCall) (*(CY *)pIn, LOCALE_NOUSEROVERRIDE, 0,
                                      &bstr);
            break;
        case TYPE_DATE:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmDate)pCall) (*(DATE *)pIn, LOCALE_USER_DEFAULT, 0,
                                        &bstr);
            break;
        case TYPE_BOOL:
            Assert(pCall != PROCESS_NOCALL);
            // We actually ignore what's in the table and special case this
            // to do sort of Netscape compatible conversions.
#ifdef NEVER            
            // THIS CODE IS IFDEF'D NEVER UNTIL WE'RE SURE PM WON'T CHANGE
            // THEIR MIND AGAIN ABOUT HOW THIS CONVERSION WORKS
            bstr =  SysAllocString(*(VARIANT_BOOL *)pIn ?
                                   _T("true") : NULL);
            // TODO:: Should we consider trying to detect a rather
            // unlikely E_NOMEMORY on allocating "true", here?
            hr = S_OK;
#else
            hr = VarBstrFromBool(*(VARIANT_BOOL *)pIn, LOCALE_USER_DEFAULT, 0, &bstr);
#endif
            break;
        default:
            Assert(!"In type is unknown, or conversion unnecessary!");
    }

    if (!hr)
    {
        *(BSTR *)pOut = bstr;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CallThru (private static member)
//
//  Synopsis:   Call low-level OLE conversion VarXXXXFromXXXX where the to type
//              is never Bstr.
//
//  Arguments:  pCall   - Function to call.
//              inType  - Type of pIn
//              pIn     - Value of data
//              pOut    - Value of data
//
//  Returns:    Returns HRESULT from VarXXXXFromXXXX.
//

// The generic function pointer types which CallThru uses.
typedef HRESULT (STDMETHODCALLTYPE *FromI2)(short, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromI4)(long, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromR4)(float, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromR8)(double, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromDate)(DATE, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromCy)(CY, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromBool)(VARIANT_BOOL, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromBStr)(OLECHAR *, LCID, unsigned long, void *);

HRESULT
CTypeCoerce::CallThru (void * pCall, CAN_TYPE inType, void * pIn, void * pOut)
{
    Assert(pCall && pCall != PROCESS_NOCALL);

    HRESULT hr;

    switch (inType)
    {
        case TYPE_I2:
            hr = (*(FromI2)pCall) (*(short *)pIn, pOut);
            break;
        case TYPE_I4:
            hr = (*(FromI4)pCall) (*(int *)pIn, pOut);
            break;
        case TYPE_R4:
            hr = (*(FromR4)pCall) (*(float *)pIn, pOut);
            break;
        case TYPE_R8:
            hr = (*(FromR8)pCall) (*(double *)pIn, pOut);
            break;
        case TYPE_CY:
            hr = (*(FromCy)pCall) (*(CY *)pIn, pOut);
            break;
        case TYPE_DATE:
            hr = (*(FromDate)pCall) (*(DATE *)pIn, pOut);
            break;
        case TYPE_BSTR:
            hr = (*(FromBStr)pCall) (*(BSTR *)pIn, LOCALE_USER_DEFAULT, 0,
                                     pOut);
            break;
        case TYPE_BOOL:
            hr = (*(FromBool)pCall) (*(VARIANT_BOOL *)pIn, pOut);
            break;
        default:
            Assert(!"In type is unknown.");
            hr = OLE_E_CANTCONVERT;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     ConvertData (public static member)
//
//  Synopsis:   Given two buffer and type pairs convert the input type to the
//              output type.
//
//  Arguments:  typeIn      - type of data in input buffer
//              pValueIn    - input buffer (data to convert)
//              typeOut     - type of data in output buffer after conversion
//              pValueOut   - output buffer (data to convert to)
//
//  Returns:    S_OK        everything is fine
//              E_xxxx      any VarNNNFromNNN low-level OLE conversion functions
//

HRESULT
CTypeCoerce::ConvertData (CAN_TYPE typeIn, void * pValueIn,
                          CAN_TYPE typeOut, void * pValueOut)
{
    // This array is static and located in this routine so it is only initial-
    // ized once -- the first time this routine is called.
    static void * JumpTable[MAX_CAN_TYPES][MAX_CAN_TYPES] =
    {
        //  *NuNu XNuI2 XNuI4 XNuR4 XNuR8 XNuCY XNuDT XNuBS XNuBO XNuVA
        {   NO_CONVERSION,   PROCESS_UPCAST,  PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  PROCESS_UPCAST,  PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  PROCESS_UPCAST      },

        //  XI2Nu  *I2I2 XI2I4 XI2R4 XI2R8  I2CY  I2DT  I2BS  I2BO  I2VA
        {   PROCESS_UPCAST,  NO_CONVERSION,   PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  &VarCyFromI2,    &VarDateFromI2,  &VarBstrFromI2,
            &VarBoolFromI2,  PROCESS_UPCAST      },

        //  XI4Nu  I4I2 *I4I4  I4R4 XI4R8  I4CY  I4DT  I4BS   I4B0  I4BA
        {   PROCESS_UPCAST,  &VarI2FromI4,    NO_CONVERSION,   &VarR4FromI4,
            PROCESS_UPCAST,  &VarCyFromI4,    &VarDateFromI4,  &VarBstrFromI4,
            &VarBoolFromI4,  PROCESS_UPCAST      },

        //  XR4Nu  R4I2  R4I4 *R4R4 XR4R8  R4CY  R4DT  R4BS  R4B0  R4VA
        {   PROCESS_UPCAST,  &VarI2FromR4,    &VarI4FromR4,    NO_CONVERSION,
            PROCESS_UPCAST,  &VarCyFromR4,    &VarDateFromR4,  &VarBstrFromR4,
            &VarBoolFromR4,  PROCESS_UPCAST      } ,

        //  XR8Nu  R8I2  R8I4  R8R4 *R8R8  R8CY  R8DT  R8BS  R8BO  R8VA
        {   PROCESS_UPCAST,  &VarI2FromR8,    &VarI4FromR8,    &VarR4FromR8,
            NO_CONVERSION,   &VarCyFromR8,    &VarDateFromR8,  &VarBstrFromR8,
            &VarBoolFromR8,  PROCESS_UPCAST      },

        //  XCYNu  CYI2  CYI4  CYR4  CYR8 *CYCY  CYDT  CYBS  CYBO  CYVA
        {   PROCESS_UPCAST,  &VarI2FromCy,    &VarI4FromCy,    &VarR4FromCy,
            &VarR8FromCy,    NO_CONVERSION,   &VarDateFromCy,  &VarBstrFromCy,
            &VarBoolFromCy,  PROCESS_UPCAST      },

        //  XDTNu  DTI2  DTI4  DTR4  DTR8  DTCY *DTDT  DTBS  DTBO  DTVA
        {   PROCESS_UPCAST,  &VarI2FromDate,  &VarI4FromDate,  &VarR4FromDate,
            &VarR8FromDate,  &VarCyFromDate,  NO_CONVERSION,   &VarBstrFromDate,
            &VarBoolFromDate,PROCESS_UPCAST    },

        //  XBSNu  BSI2  BSI4  BSR4  BSR8  BSCY  BSDT *BSBS  BSBP  BSVA
        {   PROCESS_UPCAST,  &VarI2FromStr,   &VarI4FromStr,   &VarR4FromStr,
            &VarR8FromStr,   &VarCyFromStr,   &VarDateFromStr, NO_CONVERSION,
            PROCESS_UPCAST, PROCESS_UPCAST      },

        //  XBONu  XBOI2 XBOI4 XBOR4 XBOR8  BOCY  BODT  BOBS *BOBO  BOVA
        {   PROCESS_UPCAST,  PROCESS_UPCAST, PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  &VarCyFromBool, &VarDateFromBool,&VarBstrFromBool,
            NO_CONVERSION,   PROCESS_UPCAST     },

        //  XVANu   VAI2  VAI4  VAR4  VAR8  VACY  VADT  VABS  VABO *VAVA
        {   PROCESS_UPCAST,  PROCESS_UPCAST, PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  PROCESS_UPCAST, PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  NO_CONVERSION       }
    };

    HRESULT     hr = OLE_E_CANTCONVERT;
    VARIANT     *pVarIn = (VARIANT *)pValueIn;
    VARIANT     *pVarOut = (VARIANT *)pValueOut;

    Assert(typeIn != TYPE_CHAPTER);
    Assert(typeOut != TYPE_CHAPTER);
    Assert(pValueIn && pValueOut);

    void * pFunc = JumpTable[typeIn][typeOut];

    // How do we convert?
    if (pFunc == PROCESS_UPCAST)
    {
        // Upcast.
        switch (typeIn)
        {
        case TYPE_NULL:
            hr = S_OK;

            switch (typeOut)
            {
            case TYPE_I2:
                *(short *)pValueOut = 0;
                break;
            case TYPE_I4:
                *(long *)pValueOut = 0;
                break;
            case TYPE_R4:
                *(float *)pValueOut = 0.0F;
                break;
            case TYPE_R8:
                *(double *)pValueOut = 0;
                break;
            case TYPE_CY:
                ((CY *)pValueOut)->Lo = 0;
                ((CY *)pValueOut)->Hi = 0;
                break;
            case TYPE_DATE:
                *(DATE *)pValueOut = 0;
                break;
            case TYPE_BSTR:
                *(BSTR *)pValueOut = 0;
                break;
            case TYPE_BOOL:
                *(VARIANT_BOOL *)pValueOut = 0;
                break;
            case TYPE_VARIANT:
                pVarOut->vt = VT_EMPTY;
                break;
            default:
                Assert(!"Can't cast this empty");
                break;            
            }
            break;
        
        case TYPE_I2:
            if (typeOut == TYPE_I4)
                *(long *)pValueOut = *(short *)pValueIn;
            else if (typeOut == TYPE_R4)
                *(float *)pValueOut = *(short *)pValueIn;
            else if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(short *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_I2;
                pVarOut->iVal = *(short *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this short");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_I4:
            if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(long *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_I4;
                pVarOut->lVal = *(long *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this long");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_R4:
            if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(float *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_R4;
                pVarOut->fltVal = *(float *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this float");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_R8:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_R8;
                pVarOut->dblVal = *(double *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this double");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_CY:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_CY;
                pVarOut->cyVal = *(CY *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this CY");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_DATE:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_DATE;
                pVarOut->date = *(DATE *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this date");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_BSTR:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_BSTR;
                pVarOut->bstrVal = *(BSTR*)pValueIn;
            }
            else if (typeOut == TYPE_BOOL)
            {
                // Special conversion rules for Checkbox-like elements
                // TODO:: 0 is probably not the proper Locale, &
                // NOUSEROVERRIDE is probably wrong.  -cfranks 27 Mar 1997
                TCHAR *pwch = *(TCHAR **)pValueIn;
                TCHAR *pwchEnd = NULL;
                TCHAR chBlank = 0;
                int iLen = FormsStringLen(pwch);

                // strip white space from both ends
                if (iLen > 0  && (IsCharBlank(pwch[0]) || IsCharBlank(pwch[iLen-1])))
                {
                    pwchEnd = pwch + iLen - 1;

                    while (IsCharBlank(*pwch))
                        ++ pwch;

                    while (pwchEnd >= pwch && IsCharBlank(*pwchEnd))
                        -- pwchEnd;

                    if (pwchEnd >= pwch)    // if string isn't all blank...
                    {
                        ++ pwchEnd;     // now points one char past last non-blank
                        chBlank = *pwchEnd;     // save terminating blank
                        *pwchEnd = (TCHAR)0;    // replace it with 0
                    }
                    else
                    {
                        pwchEnd = NULL;
                    }
                }
        
                hr = VarBoolFromStr((OLECHAR *)pwch, LOCALE_USER_DEFAULT, 0,
                               (VARIANT_BOOL *)pValueOut);
                if (hr)
                {
                    *(VARIANT_BOOL *)pValueOut = BoolFromStr((OLECHAR *)pwch);
                    hr = S_OK;
                }

                // restore terminating blank (if we replaced it)
                if (pwchEnd)
                {
                    *pwchEnd = chBlank;
                }
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this BSTR");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_BOOL:
            if (typeOut == TYPE_I2)
                *(short *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_I4)
                *(long *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_R4)
                *(float *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_BOOL;
                pVarOut->boolVal = *(VARIANT_BOOL *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this boolean");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_VARIANT:
        {
            hr = S_OK;

            if ((typeOut == TYPE_I2) && (pVarIn->vt == VT_I2))
                *(short *)pValueOut = ((VARIANT *)pValueIn)->iVal;
            else if ((typeOut == TYPE_I4) && (pVarIn->vt == VT_I4))
                *(long *)pValueOut = ((VARIANT *)pValueIn)->lVal;
            else if ((typeOut == TYPE_R4) && (pVarIn->vt == VT_R4))
                *(float *)pValueOut = ((VARIANT *)pValueIn)->fltVal;
            else if ((typeOut == TYPE_R8) && (pVarIn->vt == VT_R8))
                *(double *)pValueOut = ((VARIANT *)pValueIn)->dblVal;
            else if ((typeOut == TYPE_CY) && (pVarIn->vt == VT_CY))
                *(CY *)pValueOut = ((VARIANT *)pValueIn)->cyVal;
            else if ((typeOut == TYPE_DATE) && (pVarIn->vt == VT_DATE))
                *(DATE *)pValueOut = ((VARIANT *)pValueIn)->date;
            else if ((typeOut == TYPE_BSTR) && (pVarIn->vt == VT_BSTR))
                *(BSTR *)pValueOut = ((VARIANT *)pValueIn)->bstrVal;
            else if ((typeOut == TYPE_BOOL) && (pVarIn->vt == VT_BOOL))
                *(VARIANT_BOOL *)pValueOut = ((VARIANT *)pValueIn)->boolVal;
            else if (typeOut == TYPE_NULL)
            {
                // Do nothing.
            }
            else
            {
                // Indirect the input to convert the data in the variant to our
                // destination type.
                CAN_TYPE inType;

                hr = CanonicalizeType(pVarIn->vt, inType);
                if (!hr)
                {
                    hr = ConvertData(inType, &pVarIn->iVal, typeOut, pValueOut);
                }
            }
            break;
        }

        default:
            Assert(!"Can't cast up");
            break;
        }
    }
    else if (pFunc != NO_CONVERSION)
    {
        // We got a function adress or PROCESS_NOCALL.
        if (typeOut == TYPE_BSTR)       // BSTR?
        {
            hr = CallStr(pFunc, typeIn, pValueIn, pValueOut);
        }
        else
        {
            hr = CallThru(pFunc, typeIn, pValueIn, pValueOut);
        }
    }
    else
    {
        // pFunc == NO_CONVERSION
        Assert(!"We NEVER want to copy the same exact type \n"
                "GetValue/SetValue should have done it.");
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     FVariantType
//
//  Synopsis:   Returns wehter the given DBTYPE is legal in an automation
//              VARIANT.
//
//  Arguments:  dbType  - the database type
//
//  Returns:    TRUE        OK in variant
//              FALSE       not OK in variant
//

BOOL
CTypeCoerce::FVariantType(DBTYPE dbType)
{
    // Variant.h header file show that all acceptable base types
    //   are < 0x20.
    if (dbType & ~(VT_ARRAY|VT_BYREF|0x1F))
    {
        return FALSE;
    }
    // the bitmask below was built by hand from comments in Variant.h
    //
    return ((1 << (dbType &0x1f)) & 0xcf7fff) != 0;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsNearlyEqual (local helper)
//
//  Synopsis:   Determines whether two floating-point numbers are "equal"
//              within a tolerance allowing for the usual floating-point
//              vagaries (drift, loss of precision, roundoff, etc)

static BOOL
IsNearlyEqual(double d1, double d2)
{
    if (d1 == 0.0)
    {
        return (d1 == d2);
    }
    else
    {
        double dRelError = (d1-d2)/d1;
        if (dRelError < 0)
            dRelError = -dRelError;
        return (dRelError < 1.0e-6);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     IsEqual, static
//
//  Synopsis:   For two values of the same type VariantType, determines 
//              whether or no their values match.  Used by databinding
//              code to compare contents of element with contents of
//              databas, and to decide whether or not to actually save
//              changed data to the data source.
//
//  Arguments:  vt  - data type of values being compared
//              pv1 - pointer to data of first value
//              pv2 - pointer to data of second value
//
//  Returns:    S_OK        The two values match
//              S_FALSE     The values don't match
//              E_*         Something went wrong, assume failure.
//

HRESULT
CTypeCoerce::IsEqual(VARTYPE vt, void *pv1, void *pv2)
{
    HRESULT hr = S_OK;
    
    switch (vt)
    {
    case VT_BSTR:
        if (FormsStringCmp(* (BSTR *) pv1, * (BSTR *) pv2))
        {
            hr = S_FALSE;
        }
        break;
    case VT_VARIANT:
        if (((VARIANT *) pv1)->vt != ((VARIANT *) pv2)->vt)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = IsEqual(((VARIANT *) pv1)->vt,
                         & ((VARIANT *) pv1)->iVal,
                         & ((VARIANT *) pv2)->iVal);
        }
        break;

    case VT_BOOL:
        // In theory, these should be VARIANT_BOOLs with only two possible
        //  values: -1 and 0.  However, to be cautious, we'll consider any
        //  two non-zero values to match.
        // However, I've changed these to VARIANT_BOOL rather than BOOL.
        // Since most of our code only assigns the first 16 bits, we should
        // only look at the first 16 bits.  -cfranks 10 Jan 97
        if (! * (VARIANT_BOOL *) pv1 != ! * (VARIANT_BOOL *) pv2)
        {
            hr = S_FALSE;
        }
        break;
        
    case VT_NULL:
    case VT_EMPTY:
        // we violate conventional database rules, and say that NULL==NULL.
        //  This behavior is required by our clients, which use this routine
        //  to figure out if an element's contents differ from that in the
        //  database.
        break;
        
    case VT_I2:
        if (* (WORD *) pv1 != * (WORD *) pv2)
        {
            hr = S_FALSE;
        }
        break;
        
    case VT_I4:
        if (* (DWORD *) pv1 != * (DWORD *) pv2)
        {
            hr = S_FALSE;
        }
        break;

    case VT_R4:
        if (!IsNearlyEqual(* (float *) pv1, * (float *) pv2))
        {
            hr = S_FALSE;
        }
        break;
        
    case VT_R8:
        if (!IsNearlyEqual(* (double *) pv1, * (double *) pv2))
        {
            hr = S_FALSE;
        }
        break;

    case VT_DATE:
        if (* (double *) pv1 != * (double *) pv2)
        {
            hr = S_FALSE;
        }
        break;

    case VT_CY:
#ifdef UNIX
        if (CY_INT64(pv1) != CY_INT64(pv2))
#else
        if (((CY *) pv1)->int64 != ((CY *) pv2)->int64)
#endif
        {
            hr = S_FALSE;
        }
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        // TODO: should probably call IsSameObject
        if (((VARIANT *) pv1)->punkVal != ((VARIANT *) pv2)->punkVal)
        {
            hr = S_FALSE;
        }
        break;

    default:
        Assert(!"comparing unexpected databinding type.");
        hr = E_FAIL;
        break;
    }
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\currec.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1997
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Current Record Instance objects
//
//  History:    10/1/96     (sambent) created

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>
#endif

/////////////////////////////////////////////////////////////////////////////
/////                 CCurrentRecordInstance methods                    /////
/////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
// Member:      constructor (public)
//
// Synopsis:    initialize to dormant state

CCurrentRecordInstance::CCurrentRecordInstance():
    _ulRefCount(1), _priCurrent(0), _hrow(0)
{
}


//+-------------------------------------------------------------------------
// Member:      Init (public)
//
// Synopsis:    Associate my record instance with a RowPosition
//
// Arguments:   pRowPos     RowPosition to attach
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::Init(CDataSourceProvider *pProvider, IRowPosition *pRowPos)
{
    Assert("must be passive to attach" && !_priCurrent);
    Assert("need provider" && pProvider);

    HRESULT hr = S_OK;
    IConnectionPointContainer *pCPC = 0;

    // remember my owner
    _pProvider = pProvider;
    
    // hold on to the RowPosition (let go in Detach)
    _pRowPos = pRowPos;

    if (_pRowPos)
    {
        _pRowPos->AddRef();
        
        // sink notifications from the RowPosition
        hr = _pRowPos->QueryInterface(IID_IConnectionPointContainer,
                                               (void **)&pCPC );
        if (hr)
            goto Cleanup;
        hr = pCPC->FindConnectionPoint(IID_IRowPositionChange, &_pCP);
        if (hr)
            goto Cleanup;
        hr = _pCP->Advise(this, &_dwAdviseCookie);
        if (hr)
        {
            ClearInterface(&_pCP);
            goto Cleanup;
        }
    }
        
Cleanup:
    ReleaseInterface(pCPC);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      InitChapter (public)
//
// Synopsis:    Hook up to a new chapter
//
// Arguments:   hChapter        chapter to attach
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::InitChapter(HCHAPTER hChapter)
{
    IRowset *pRowset = 0;
    HRESULT hr = E_FAIL;

    _hChapter = hChapter;

    Assert(_pProvider);
    hr = _pProvider->QueryDataInterface(IID_IRowset, (void**)&pRowset);
    if (hr)
        goto Cleanup;
    
    // get a DLCursor
    if (_pDLC)
    {
        _pDLC->Release();
    }
    _pDLC = new CDataLayerCursor(this);
    if (!_pDLC)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    // attach DLCursor to the rowset, don't filter notifications to the chapter
    hr = _pDLC->Init(pRowset, _hChapter, CDataLayerCursor::DLC_SinkNotifications);
    if (hr)
        goto Cleanup;

    // set up the current record instance
    if (_priCurrent)
    {
        _priCurrent->Detach(TRUE);      // clear the elements first
        delete _priCurrent;
    }
    _priCurrent = new CRecordInstance(_pDLC, _hrow);
    if (!_priCurrent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pRowset);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      InitPosition (public)
//
// Synopsis:    Initialize the position of my underlying RowPos
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::InitPosition(BOOL fFireRowEnter)
{
    if (!_pRowPos)
        goto Cleanup;

    IGNORE_HR(InitCurrentRow());
    
    // grab the current HROW
    IGNORE_HR(OnRowPositionChange(DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                  DBEVENTPHASE_SYNCHAFTER,
                                  TRUE));

    if (fFireRowEnter)
    {
        _pProvider->FireDelayedRowEnter();
    }
    
Cleanup:
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Passivate (private, called by Release())
//
// Synopsis:    return to pre-init state
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::Passivate()
{
    Assert("call Detach before Passivate" && !_priCurrent);

    if (_pDLC)
    {
        _pDLC->Release();
        _pDLC = NULL;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Detach (public)
//
// Synopsis:    Disassociate from my RowPosition
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::Detach()
{
    HRESULT hr = S_OK;

    // stop listening for events
    if (_pCP)
    {
        IGNORE_HR(_pCP->Unadvise(_dwAdviseCookie));
        ClearInterface(&_pCP);
    }

    // let go of current row
    if (_hrow != DB_NULL_HROW)
    {
        _pDLC->ReleaseRows(1, &_hrow);
        _hrow = DB_NULL_HROW;
    }

    // let go of the RowPosition
    ClearInterface(&_pRowPos);

    // let go of my current record
    if (_priCurrent)
    {
        _priCurrent->Detach();
        delete _priCurrent;
        _priCurrent = 0;
    }

    // release the cursor
    if (_pDLC)
    {
        _pDLC->Release();
        _pDLC = NULL;
    }
    
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      Get Current Record Instance (public)
//
// Synopsis:    return pointer to my record instance
//
// Arguments:   ppRecInstance   where to store the pointer
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::GetCurrentRecordInstance(CRecordInstance **ppRecInstance)
{
    Assert("nowhere to store pointer" && ppRecInstance);
    *ppRecInstance = _priCurrent;
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, go away when it hits zero
//
// Arguments:   none
//
// Returns:     new refcount

ULONG
CCurrentRecordInstance::Release()
{
    HRESULT hr;
    ULONG ulRefCount = --_ulRefCount;
    if (ulRefCount == 0) {
        hr = Passivate();
        delete this;
    }
    return ulRefCount;
}


//+-------------------------------------------------------------------------
// Member:      Query Interface (public, IUnknown)
//
// Synopsis:    return desired interface pointer
//
// Arguments:   riid        IID of desired interface
//              ppv         where to store the pointer
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punkReturn = 0;

    // check for bad arguments
    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // look for interfaces I support
    if (    IsEqualIID(riid, IID_IUnknown)
        ||  IsEqualIID(riid, IID_ICurrentRecordInstance)
        ||  IsEqualIID(riid, IID_IRowPositionChange)
        )
    {
        punkReturn = this;          // return addref'd copy
        punkReturn->AddRef();
        *ppv = punkReturn;
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

Cleanup:
    return hr;        
}


//+-------------------------------------------------------------------------
// Member:      On Row Position Change (public, IRowPositionChange)
//
// Synopsis:    sink notification from RowPosition object, adjust
//              my record instance accordingly.
//
// Arguments:   eReason     reason we're being notified
//              ePhase      which notification phase
//              fCantDeny   true if I can't veto the event
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase,
                            BOOL fCantDeny)
{
    HRESULT hr;
    HCHAPTER hchapter;
    DBPOSITIONFLAGS dwPositionFlags;

    hr = _pDLC->CheckCallbackThread();
    if (hr)
        goto Cleanup;
    
    switch (ePhase)
    {
    case DBEVENTPHASE_OKTODO:
        // if we're in act of deleting current record, don't bother
        //  checking if Ok to change HROW.
        if (_dlbDeleted.IsNull())
        {
            hr = _priCurrent->OkToChangeHRow();
        }
        break;
    
    case DBEVENTPHASE_ABOUTTODO:        // position is changing, release HROW
        _pDLC->ReleaseRows(1, &_hrow);
        _hrow = DB_NULL_HROW;
        break;

    case DBEVENTPHASE_FAILEDTODO:
    case DBEVENTPHASE_SYNCHAFTER:       // position changed, get new HROW
        if (_hrow == DB_NULL_HROW)
        {
            _pRowPos->GetRowPosition(&hchapter, &_hrow, &dwPositionFlags);
            
            if (hchapter == _hChapter)
            {
                _priCurrent->SetHRow(_hrow);
            }
            else
            {
                // chapter changes are handled elsewhere.  If the chapter is
                // changing, I'm about to die anyway.
                Assert(eReason == DBREASON_ROWPOSITION_CHAPTERCHANGED);
            }
            
            ReleaseChapterAndRow(hchapter, DB_NULL_HROW, _pRowPos);
        }
        break;
    }

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      All Changed (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   none
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::AllChanged()
{
    return DB_S_UNWANTEDREASON;
}


//+-------------------------------------------------------------------------
// Member:      Rows Changed (public, CDataLayerCursorEvents)
//
// Synopsis:    if my HROW has changed, update my Record Instance
//
// Arguments:   cRows       count of changed rows
//              ahRows      HROW for each changed row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::RowsChanged(DBCOUNTITEM cRows, const HROW *ahRows)
{
    for (ULONG k=0; k<cRows; ++k)
    {
        if (_pDLC->IsSameRow(_hrow, ahRows[k]))
        {
            _priCurrent->SetHRow(ahRows[k]);
        }
    }
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Fields Changed (public, CDataLayerCursorEvents)
//
// Synopsis:    if my HROW is the changed one, notify my Record Instance
//
// Arguments:   hRows       the changed HROW
//              cColumns    count of changed columns
//              aColumns    index of each changed column
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::FieldsChanged(HROW hRow, DBORDINAL cColumns, DBORDINAL aColumns[])
{
    HRESULT hr;
    hr = _priCurrent->OnFieldsChanged(hRow, cColumns, aColumns);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      Rows Inserted (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   cRows       count of inserted rows
//              ahRows      HROW of each inserted row
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::RowsInserted(DBCOUNTITEM cRows, const HROW *ahRows)
{
    return DB_S_UNWANTEDREASON;
}


//+-------------------------------------------------------------------------
// Member:      Deleting Rows (public, CDataLayerCursorEvents)
//
// Synopsis:    notification that rows are about to be deleted.  If one of them
//              is my current row, get a bookmark for it.
//
// Arguments:   cRows       count of deleted rows
//              ahRows      HROW of each deleted row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::DeletingRows(DBCOUNTITEM cRows, const HROW *ahRows)
{
    ULONG i;
    
    // if my current record is being deleted, get a bookmark for it
    for (i=0; i<cRows; ++i)
    {
        if (_pDLC->IsSameRow(_hrow, ahRows[i]))
        {
            Assert(_dlbDeleted.IsNull());
            IGNORE_HR(_pDLC->CreateBookmark(ahRows[i], &_dlbDeleted));
            break;
        }
    }
    
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Rows Deleted (CDataLayerCursorEvents, public)
//
// Synopsis:    notification that rows have been deleted.  If we have a
//              bookmark, the current row was deleted.  In this case, move
//              the current row forward (or backward if already at the end).
//
// Arguments:   cRows       count of deleted rows
//              ahRows      HROW of each deleted row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::RowsDeleted(DBCOUNTITEM, const HROW *)
{
    DBCOUNTITEM cRows;
    HROW hrow;
    HRESULT hr;
    DBPOSITIONFLAGS dwPositionFlags = DBPOSITION_OK;
    
    if (!_dlbDeleted.IsNull())
    {
        // try moving forward
        hr = _pDLC->GetRowsAt(_dlbDeleted, 0, 1, &cRows, &hrow);

        // if that doesn't work, try moving backward
        if (FAILED(hr) || cRows==0)
            hr = _pDLC->GetRowsAt(_dlbDeleted, -1, -1, &cRows, &hrow);

        // if we didn't get a good row, use the null row
        if (FAILED(hr) || cRows==0)
        {
            hrow = DB_NULL_HROW;
            dwPositionFlags = DBPOSITION_EOF;
        }

        // set current position to the new row
        if (_pRowPos && S_OK == _pRowPos->ClearRowPosition())
            _pRowPos->SetRowPosition(_hChapter, hrow, dwPositionFlags);
        // clear the bookmark
        _dlbDeleted = CDataLayerBookmark::TheNull;

        // release the row
        _pDLC->ReleaseRows(1, &hrow);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      DeleteCancelled (public, CDataLayerCursorEvents)
//
// Synopsis:    notification that row deletion was cancelled
//
// Arguments:   cRows       count of deleted rows
//              ahRows      HROW of each deleted row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::DeleteCancelled(DBCOUNTITEM cRows, const HROW *ahRows)
{
    // discard the bookmark I may have taken out during pre-notification
    _dlbDeleted = CDataLayerBookmark::TheNull;
    
    return S_OK;
}

//+-------------------------------------------------------------------------
// Member:      Rows Added (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::RowsAdded()
{
    return InitCurrentRow();
}


//+-------------------------------------------------------------------------
// Member:      Population Complete (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::PopulationComplete()
{
    return InitCurrentRow();
}


//+-------------------------------------------------------------------------
// Member:      InitCurrentRow (private helper)
//
// Synopsis:    set the current row, if not set already

HRESULT
CCurrentRecordInstance::InitCurrentRow()
{
    HROW hrow = DB_NULL_HROW;
    HCHAPTER hchapter = DB_NULL_HCHAPTER;
    DBPOSITIONFLAGS dwPositionFlags;

    if (!_pRowPos || !_pDLC)
        goto Cleanup;

    // if current HROW is null, move to the first row
    _pRowPos->GetRowPosition(&hchapter, &hrow, &dwPositionFlags);
    if (hrow == DB_NULL_HROW)
    {
        // Get the first row.
        if (S_OK == _pDLC->GetRowAt(CDataLayerBookmark::TheFirst, &hrow))
        {
            dwPositionFlags = DBPOSITION_OK;
        }
        else
        {
            // if there isn't one, try to set the chapter anyway
            hrow = DB_NULL_HROW;
            dwPositionFlags = DBPOSITION_NOROW;
        }
        if (S_OK == _pRowPos->ClearRowPosition())
            _pRowPos->SetRowPosition(_hChapter, hrow, dwPositionFlags);
    }

    ReleaseChapterAndRow(hchapter, hrow, _pRowPos);

Cleanup:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\dmembmgr.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for CDataSourceProvider
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include <evntprm.hxx>      // for eventparam (needed by fire_ondata*)
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include <elemdb.hxx>       // for DBSPEC
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <adoid.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h> // for iid_ivbdsc
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include <tearoff.hxx>
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include <generic.hxx>
#endif

#ifndef X_SIMPDC_H_
#define X_SIMPDC_H_
#include "simpdc.h"
#endif

DeclareTag(tagDataMemberMgr, "databinding", "DataMemberMgr methods");
DeclareTag(tagUseDebugSDC, "databinding", "implement SDC with VarChangeType");

MtDefine(COSPProxy, DataBind, "COSPProxy");
MtDefine(CDataMemberMgr, DataBind, "CDataMemberMgr");
MtDefine(CDataMemberMgr_aryDataMember_pv, DataBind, "CDataMemberMgr::_aryDataMember::_pv")

const IID IID_ISimpleDataConverter = {0x78667670,0x3C3D,0x11d2,0x91,0xF9,0x00,0x60,0x97,0xC9,0x7F,0x9B};

#if DBG == 1
MtDefine(CDbgSimpleDataConverter, DataBind, "CDbgSimpleDataConverter");

//+---------------------------------------------------------------------------
//
//  Class:      CDbgSimpleDataConverter
//
//  Purpose:    For debugging, we implement ISimpleDataConverter internally
//              by simply calling VariantChangeTypeEx for certain types
//              that we're interested in testing.
//
//----------------------------------------------------------------------------

class CDbgSimpleDataConverter : public ISimpleDataConverter
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDbgSimpleDataConverter));
    CDbgSimpleDataConverter(): _ulRefs(1) {}
    
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE   QueryInterface(REFIID riid, void **ppv);
    ULONG STDMETHODCALLTYPE     AddRef() { return ++ _ulRefs; }
    ULONG STDMETHODCALLTYPE     Release();

    // ISimpleDataConverter methods
    HRESULT STDMETHODCALLTYPE ConvertData( 
        VARIANT varSrc,
        long vtDest,
        IUnknown __RPC_FAR *pUnknownElement,
        VARIANT __RPC_FAR *pvarDest);
    
    HRESULT STDMETHODCALLTYPE CanConvertData( 
        long vt1,
        long vt2);

private:
    ULONG   _ulRefs;        // refcount
};

HRESULT STDMETHODCALLTYPE
CDbgSimpleDataConverter::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISimpleDataConverter))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}


ULONG STDMETHODCALLTYPE
CDbgSimpleDataConverter::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}

HRESULT STDMETHODCALLTYPE
CDbgSimpleDataConverter::ConvertData( 
    VARIANT varSrc,
    long vtDest,
    IUnknown *pUnknownElement,
    VARIANT *pvarDest)
{
    HRESULT hr;

    if (!pvarDest)
    {
        hr = S_OK;
    }
    else if (S_OK != CanConvertData(V_VT(&varSrc), vtDest))
    {
        hr = E_FAIL;
    }
    else
    {
        hr = VariantChangeTypeEx(pvarDest, &varSrc, g_lcidUserDefault, 0, vtDest);
    }
    
    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
CDbgSimpleDataConverter::CanConvertData( 
    long vt1,
    long vt2)
{
    HRESULT hr = S_FALSE;

    // one of the types must be BSTR
    if (vt1 != VT_BSTR)
    {
        long vtTemp = vt1;
        vt1 = vt2;
        vt2 = vtTemp;
    }

    if (vt1 != VT_BSTR)
        goto Cleanup;

    // the other can be on the list below
    switch (vt2)
    {
    case VT_DATE:
    case VT_CY:
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_DECIMAL:
        hr = S_OK;
        break;

    default:
        break;
    }

Cleanup:
    return hr;
}

#endif DBG == 1


//+---------------------------------------------------------------------------
//
//  Class:      COSPProxy
//
//  Purpose:    This class serves a single purpose.  Namely, to delay
//              the Release() of the java ocx until we've released the
//              OSP object down to zero.
//
//----------------------------------------------------------------------------

class COSPProxy : OLEDBSimpleProvider
{
    int _refs;
    OLEDBSimpleProvider *_pOSPReal;
    IUnknown *_pUnkOther;
    public:
        DECLARE_MEMALLOC_NEW_DELETE(Mt(COSPProxy))
        COSPProxy() : _pOSPReal(NULL), _pUnkOther(NULL), _refs(1) { }

        HRESULT Init(IUnknown *pOSPReal, IUnknown *pUnkOther)
        {
            HRESULT hr = pOSPReal->QueryInterface(IID_OLEDBSimpleProvider, (void**)&_pOSPReal);
            if (hr)
                goto Cleanup;
            _pUnkOther = pUnkOther;
            _pUnkOther->AddRef();
        Cleanup:
            return hr;
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
        {
            HRESULT hr = E_NOINTERFACE;
            *ppvObject = NULL;
            if (riid == IID_IUnknown)
                *ppvObject = (void**)this;
            else if (riid == IID_OLEDBSimpleProvider)
                *ppvObject = (void**)this;
            if (*ppvObject)
            {
                hr = S_OK;
                AddRef();
            }
            return hr;
        }
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return ++_refs;
        }
        
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (--_refs == 0)
            {
                // this ordering is crucial
                _pOSPReal->Release();
                _pUnkOther->Release();
                delete this;
                return 0;
            }
            return _refs;
        }
        
        virtual HRESULT STDMETHODCALLTYPE getRowCount( 
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *pcRows)
        {
            return _pOSPReal->getRowCount(pcRows);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getColumnCount( 
            /* [retval][out] */ DB_LORDINAL __RPC_FAR *pcColumns)
        {
            return _pOSPReal->getColumnCount(pcColumns);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getRWStatus( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [retval][out] */ OSPRW __RPC_FAR *prwStatus)
        {
            return _pOSPReal->getRWStatus(iRow, iColumn, prwStatus);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [retval][out] */ VARIANT __RPC_FAR *pVar)
        {
            return _pOSPReal->getVariant(iRow, iColumn, format, pVar);
        }
        
        virtual HRESULT STDMETHODCALLTYPE setVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [in] */ VARIANT Var)
        {
            return _pOSPReal->setVariant(iRow, iColumn, format, Var);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getLocale( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLocale)
        {
            return _pOSPReal->getLocale(pbstrLocale);
        }
        
        virtual HRESULT STDMETHODCALLTYPE deleteRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *pcRowsDeleted)
        {
            return _pOSPReal->deleteRows(iRow, cRows, pcRowsDeleted);
        }
        
        virtual HRESULT STDMETHODCALLTYPE insertRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *pcRowsInserted)
        {
            return _pOSPReal->insertRows(iRow, cRows, pcRowsInserted);
        }
        
        virtual HRESULT STDMETHODCALLTYPE find( 
            /* [in] */ DBROWCOUNT iRowStart,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ VARIANT val,
            /* [in] */ OSPFIND findFlags,
            /* [in] */ OSPCOMP compType,
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *piRowFound)
        {
            return _pOSPReal->find(iRowStart, iColumn, val, findFlags, compType, piRowFound);
        }
        
        virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener( 
            /* [in] */ OLEDBSimpleProviderListener __RPC_FAR *pospIListener)
        {
            return _pOSPReal->addOLEDBSimpleProviderListener(pospIListener);
        }
        
        virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener( 
            /* [in] */ OLEDBSimpleProviderListener __RPC_FAR *pospIListener)
        {
            return _pOSPReal->removeOLEDBSimpleProviderListener(pospIListener);
        }
        
        virtual HRESULT STDMETHODCALLTYPE isAsync( 
            /* [retval][out] */ BOOL __RPC_FAR *pbAsynch)
        {
            return _pOSPReal->isAsync(pbAsynch);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getEstimatedRows( 
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *piRows)
        {
            return _pOSPReal->getEstimatedRows(piRows);
        }
        
        virtual HRESULT STDMETHODCALLTYPE stopTransfer( void)
        {
            return _pOSPReal->stopTransfer();
        }
};


//+---------------------------------------------------------------------------
//
//  Member:     Create (static, public)
//
//  Synopsis:   Create a CDataMemberMgr for a given element.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::Create(CElement *pElement, CDataMemberMgr **ppMgr)
{
    Assert(pElement && ppMgr);
    HRESULT hr = S_OK;
    CDataMemberMgr *pMgr = NULL;

    switch (pElement->Tag())
    {
    case ETAG_OBJECT:
    case ETAG_APPLET:
    case ETAG_EMBED:
        pMgr = new CDataMemberMgr(ET_OLESITE, pElement);
        break;

    case ETAG_GENERIC_LITERAL:
        if (0 == _tcsicmp(pElement->TagName(), _T("XML")))
        {
            pMgr = new CDataMemberMgr(ET_XML, pElement);
        }
        else
            hr = E_INVALIDARG;
        break;
        
    default:
        hr = E_INVALIDARG;
        break;
    }
    
    if (!hr && pMgr == NULL)
        hr = E_OUTOFMEMORY;

    *ppMgr = pMgr;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     constructor (private)
//
//----------------------------------------------------------------------------

CDataMemberMgr::CDataMemberMgr(ELEMENT_TYPE et, CElement *pElement) :
    _ulRefs(1),
    _et(et),
    _pElementOwner(pElement),
    _aryDataMember(Mt(CDataMemberMgr_aryDataMember_pv)),
    _dispidDataBinding(DISPID_UNKNOWN)
{
    Assert(pElement);
    
    switch (_et)
    {
    case ET_OLESITE:
        _pOleSite = DYNCAST(COleSite, pElement);
        break;

    case ET_XML:
        _pXML = DYNCAST(CGenericElement, pElement);
        break;

    case ET_SCRIPT:
        break;
    }

    _pDoc = _pElementOwner->Doc();
    _pElementOwner->SubAddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     destructor (private)
//
//----------------------------------------------------------------------------

CDataMemberMgr::~CDataMemberMgr()
{
    _pElementOwner->SubRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     QueryInterface (IUnknown)
//
//  Synopsis:   We support the following interfaces:
//
//                  IUnknown
//                  DataSourceListener
//                  IDATASRCListener
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_DataSourceListener)
    {
        *ppv = (DataSourceListener *) this;
    }
    else if (iid == IID_IDATASRCListener)
    {
        *ppv = (IDATASRCListener *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CDataMemberMgr::AddRef( )
{
    return ++_ulRefs;
}


STDMETHODIMP_(ULONG)
CDataMemberMgr::Release( )
{
    ULONG ulRefs = --_ulRefs;

    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     IllegalCall (private)
//
//  Returns:    TRUE    illegal call (wrong thread, etc)
//              FALSE   legal call
//----------------------------------------------------------------------------

BOOL
CDataMemberMgr::IllegalCall(DWORD dwFlags)
{
    switch (_et)
    {
    case ET_OLESITE:
        Assert(_pOleSite);
        return _pOleSite->IllegalSiteCall(dwFlags);
        break;

    case ET_XML:
    case ET_SCRIPT:
        if (_pDoc->_dwTID != GetCurrentThreadId())
        {
            Assert(0 && "ActiveX control called MSHTML across apartment thread boundary (not an MSHTML bug)");
            return TRUE;
        }
        break;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     IsReady (public)
//
//  Returns:    S_OK    ready
//              S_FALSE not ready
//              E_*     some bad kind of error occurred
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::IsReady()
{
    HRESULT hr = S_OK;
    LONG lReadyState;
    
    switch (_et)
    {
    case ET_OLESITE:
        hr = _pOleSite->GetReadyState(&lReadyState);
        if (hr==S_OK && lReadyState < READYSTATE_LOADED)
        {
            hr = S_FALSE;
        }
        break;

    case ET_XML:
        break;
    
    case ET_SCRIPT:
        hr = E_NOTIMPL;    // TODO notimpl
        break;
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetDataMemberRecord (protected)
//
//  Synopsis:   looks up bstrName in the associative array, and returns
//              the corresponding data member record.
//
//----------------------------------------------------------------------------

CDataMemberMgr::CDataMemberRecord *
CDataMemberMgr::GetDataMemberRecord(BSTR bstrName)
{
    int i;
    CDataMemberRecord *pdmr;

    for (pdmr=_aryDataMember, i=_aryDataMember.Size(); i > 0; ++pdmr, --i)
    {
        if (FormsStringCmp(bstrName, pdmr->_bstrName) == 0)
        {
            return pdmr;
        }
    }

    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     AddDataMemberRecord (protected)
//
//  Synopsis:   adds a new data member record to the associative array,
//              with bstrName as the key.  Returns a pointer to the new record.
//
//----------------------------------------------------------------------------

CDataMemberMgr::CDataMemberRecord *
CDataMemberMgr::AddDataMemberRecord(BSTR bstrName)
{
    HRESULT hr;
    CDataMemberRecord *pdmrResult;

    pdmrResult = _aryDataMember.Append();
    if (pdmrResult)
    {
        hr = FormsAllocString(bstrName, &pdmrResult->_bstrName);
        if (!hr)
        {
            pdmrResult->_pdspProvider = NULL;
            pdmrResult->_punkDataBinding = PUNKDB_UNKNOWN;
        }
        else
        {
            pdmrResult = NULL;
            _aryDataMember.Delete(_aryDataMember.Size()-1);
        }
    }

    return pdmrResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     AccessAllowed (private)
//
//  Synopsis:   determine if cross-domain data access is allowed
//
//----------------------------------------------------------------------------

BOOL
CDataMemberMgr::AccessAllowed()
{
    BOOL fAllowXDomain = FALSE;
    IDispatch *pDisp;

    if (_et == ET_OLESITE)
    {
        switch (_eSecurity)
        {
        case SEC_UNKNOWN:
            Assert(_pOleSite);
            _pOleSite->CacheDispatch();
            pDisp = _pOleSite->_pDisp;
            
            if (pDisp)
            {
                fAllowXDomain = _pOleSite->AccessAllowed(pDisp);

                // if cross-domain access, check the user's policy
                if (!fAllowXDomain)
                {
                    THR(_pOleSite->GetMarkupPtr()->ProcessURLAction(
                        URLACTION_CROSS_DOMAIN_DATA,
                        &fAllowXDomain));
                }
            }

            // remember the answer, so we don't prompt more than once
            _eSecurity = fAllowXDomain ? SEC_SAFE : SEC_UNSAFE;
            break;

        case SEC_SAFE:
            fAllowXDomain = TRUE;
            break;

        case SEC_UNSAFE:
            fAllowXDomain = FALSE;
            break;
        }
            
    }
    else
        fAllowXDomain = TRUE;

    return fAllowXDomain;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetDataSourceProvider (public)
//
//  Synopsis:   return a data-interface provider associated with this <OBJECT>
//              (and its control), creating it if needed.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::GetDataSourceProvider(BSTR bstrMember, CDataSourceProvider **ppdsp)
{
    Assert(ppdsp);

    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr;

    *ppdsp = NULL;      // just in case

    // look up the data member
    pdmr = GetDataMemberRecord(bstrMember);

    // if not there, create one
    if (pdmr == NULL)
    {
        pdmr = AddDataMemberRecord(bstrMember);
        if (pdmr == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // Create the top-level provider, if necessary.
    if (!pdmr->_pdspProvider)
    {
        hr = CDataSourceProvider::Create(this, Doc(), bstrMember, &pdmr->_pdspProvider);
        if (hr)
            goto Cleanup;
    }

    // return the answer
    *ppdsp = pdmr->_pdspProvider;
    if (*ppdsp)
        (*ppdsp)->AddRef();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     ChangeDataBindingInterface (protected)
//
//  Synopsis:   React to changes in my control's databinding interface,
//              by replacing my provider.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::ChangeDataBindingInterface(BSTR bstrMember, BOOL fDataAvail)
{
    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr = GetDataMemberRecord(bstrMember);
    CDataSourceProvider *pdspOldProvider;
    CDataSourceProvider *pdspNewProvider;
    CDoc *pDoc;

    // turn off databinding during this function.  This postpones the onrowenter
    // event on the new provider until after the bound elements have had a chance
    // to re-bind.  (IE5 bug 82058)
    CMarkup *pMarkup = GetOwner()->GetMarkup();
    BOOL fDatabindingEnabled = pMarkup->SetDataBindingEnabled(FALSE);

    // if my control isn't a data provider or we don't care about data member,
    // just ignore
    if (_dpt <= DPT_NOTAPROVIDER || pdmr == NULL)
        goto Cleanup;

    // remember the old provider, discard the old interface
    pdspOldProvider = pdmr->_pdspProvider;
    if (pdmr->_punkDataBinding != PUNKDB_UNKNOWN)
    {
        ClearInterface(&pdmr->_punkDataBinding);
    }
    pdmr->_punkDataBinding = PUNKDB_UNKNOWN;

    // if the notification came from a Trident-as-OSP, the data page may have
    // navigated to a new site, so we should re-evaluate cross-domain
    // security
    if (GetTridentAsOSP(&pDoc) == S_OK)
    {
        _eSecurity = SEC_UNKNOWN;
    }
    
    // get the new interface from the control
    if (fDataAvail)
    {
        IGNORE_HR(EnsureDataBindingInterface(bstrMember));
    }

    // let my provider know what happened
    if (!pdspOldProvider)   // no provider, nothing to do
        goto Cleanup;

    pdmr->_pdspProvider = NULL;                     // unhook the old provider
    hr = GetDataSourceProvider(bstrMember, &pdspNewProvider);   // hook up a new one
    if (hr)
    {
        pdmr->_pdspProvider = pdspOldProvider;      // if error, restore status quo
        goto Cleanup;
    }

    pdspOldProvider->ReplaceProvider(pdspNewProvider);  // notify provider's clients
    pdspOldProvider->Release();                     // let go of old provider
    pdspNewProvider->Release();                     // release local ref to new one

Cleanup:
    // the data member change may let bindings succeed that didn't before,
    // notably bindings to the inner datasets of a hierarchy.  So tell the
    // binding task to try again.
    pMarkup->GetDataBindTask()->SetWaiting();
    pMarkup->SetDataBindingEnabled(fDatabindingEnabled);

    return hr;
}


CDataMemberMgr::DATA_PROVIDER_TYPE
CDataMemberMgr::GetDataProviderType()
{
    // Do we already know what data provider type this site is hosting?
    if (_dpt==DPT_UNKNOWN)
    {
        // No. Try to find one.
        FindDataProviderType();
    }
    return _dpt;
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataBindingInterface (protected)
//
//  Synopsis:   Query the underlying control/applet for an interface
//              its clients can use for databinding
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::EnsureDataBindingInterface(BSTR bstrMember)
{
    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr;
    IUnknown *punkNew = NULL;

    // look up the data member
    pdmr = GetDataMemberRecord(bstrMember);

    // if not there, create one
    if (pdmr == NULL)
    {
        pdmr = AddDataMemberRecord(bstrMember);
        if (pdmr == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // get the interface, if not there already
    if (pdmr->_punkDataBinding == PUNKDB_UNKNOWN)
    {
        CLASSINFO *pci;
        IServiceProvider *pServiceProvider = NULL;

        // make sure it's still safe to talk to the provider (Windows 549760)
        if (!AccessAllowed())
        {
            pdmr->_punkDataBinding = NULL;
            goto Cleanup;
        }

        switch (GetDataProviderType())
        {
        case DPT_DATASOURCE:
            Assert(_pDataSource);
            hr = _pDataSource->getDataMember(bstrMember, IID_IUnknown, &punkNew);
            break;

        case DPT_COM:
        case DPT_JAVA:
            Assert(_et == ET_OLESITE);
            // the service provider (if needed) is the doc
            Doc()->PrivateQueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);
            hr = CallDispMethod(pServiceProvider,
                                _pOleSite->_pDisp,
                                _dispidDataBinding,
                                g_lcidUserDefault,
                                VT_UNKNOWN,
                                &punkNew,
                                EVENT_PARAM(VTS_BSTR),
                                bstrMember
                                );
            ReleaseInterface(pServiceProvider);
            break;

        case DPT_ICURSOR:
            AssertSz(0, "ChangeDataBindingInterface called on ICursor provider");
            break;
            
        case DPT_PROPERTY:
            Assert(_et == ET_OLESITE);
            pci = _pOleSite->GetClassInfo();
            if (pci->dispidSTD != DISPID_UNKNOWN) // offers OLEDBSimpleProvider
            {
                hr = _pOleSite->GetInterfaceProperty(pci->uGetSTD, pci->dispidSTD,
                                            IID_OLEDBSimpleProvider, &punkNew);
            }
            else if (pci->dispidRowset != DISPID_UNKNOWN)        // offers IRowset
            {
                hr = _pOleSite->GetInterfaceProperty(pci->uGetRowset, pci->dispidRowset,
                                            IID_IRowset, &punkNew);
            }
            break;
        }

        // OSP providers are notoriously guilty of the following sin:  they
        // allow the control to die while references to OSPs are still outstanding.
        // To work around this problem, build a proxy object that artificially
        // increments the refcount of the control throughout the lifetime of the OSP.
        if (!hr && punkNew)
        {
            IUnknown *punkOther = NULL;
            COSPProxy *pProxy = new COSPProxy();

            // get a controlling unknown for the DSO
            switch (_et)
            {
            case ET_OLESITE:
                punkOther = _pOleSite->PunkCtrl();
                punkOther->AddRef();
                break;
            case ET_XML:
                if (S_OK != _pDataSource->QueryInterface(IID_IUnknown, (void**)&punkOther))
                    punkOther = NULL;
                break;
            default:
                break;
            }
            
            // If anything goes wrong (such as if Init() fails because
            // punkNew doesn't implement OLEDBSimpleProvider), then we'll
            // just proceed as normal.
            if (punkOther == NULL || pProxy == NULL || pProxy->Init(punkNew, punkOther))
            {
                delete pProxy;
            }
            else
            {
                punkNew->Release();
                punkNew = (IUnknown*)(void*)pProxy;
            }

            ReleaseInterface(punkOther);
        }

        pdmr->_punkDataBinding = punkNew;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetDataBindingInterface (public)
//
//  Synopsis:   Query the underlying control/applet for an interface
//              its clients can use for databinding
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::GetDataBindingInterface(BSTR bstrMember, IUnknown **ppunkDataBinding)
{
    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr;
    IUnknown *punkDataBinding = NULL;

    // look up the data member
    pdmr = GetDataMemberRecord(bstrMember);

    // if this is first request, try to get the dataset
    if (pdmr == NULL || pdmr->_punkDataBinding == PUNKDB_UNKNOWN)
    {
        hr = EnsureDataBindingInterface(bstrMember);
        if (pdmr == NULL)
            pdmr = GetDataMemberRecord(bstrMember);
    }
    
    punkDataBinding = pdmr ? pdmr->_punkDataBinding : NULL;
    if (punkDataBinding == PUNKDB_UNKNOWN)
        punkDataBinding = NULL;

    // return the answer
    Assert(ppunkDataBinding);
    *ppunkDataBinding = punkDataBinding;
    if (punkDataBinding)
        punkDataBinding->AddRef();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     FindDataProviderType (private helper)
//
//  Synopsis:   determine if the underlying DSO provides data, and if so, how
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::FindDataProviderType()
{
    HRESULT hr = S_OK;
    CLASSINFO *pci;
    IDispatch *pDisp;
    DISPID dispid;
    IUnknown *punkInterface = 0;
    static OLECHAR * oszMsDATASRCObject = _T("msDataSourceObject");
    static OLECHAR * oszAddDataSrcListener = _T("addDataSourceListener");
    DataSource *pDataSource = 0;
    IServiceProvider *pServiceProvider = 0;
    
    Assert(_dpt == DPT_UNKNOWN);    // if we already know, why bother

    _dpt = DPT_NOTAPROVIDER;        // assume the worst

    switch (_et)
    {
    case ET_OLESITE:
        Assert(_pOleSite);
        // must have a valid dispatch for any of our methods
        _pOleSite->CacheDispatch();
        pDisp = _pOleSite->_pDisp;
        if (!pDisp)
            goto Cleanup;

        if (!AccessAllowed())
            goto Cleanup;

        // the service provider (if needed) is the doc
        Doc()->PrivateQueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);

        switch (_pOleSite->OlesiteTag())
        {
        case COleSite::OSTAG_ACTIVEX:
            // method 5:  look for DataSource
            hr = _pOleSite->QueryControlInterface(IID_DataSource, (void**)&pDataSource);
            if (hr == S_OK)
            {
                _dpt = DPT_DATASOURCE;
                IGNORE_HR(pDataSource->addDataSourceListener((DataSourceListener*)this));
                _pDataSource = pDataSource;
                break;
            }

            // method 1:  look for the MsDatasrcInterface method (COM objects)
            hr = CallDispMethod(pServiceProvider,
                                _pOleSite->_pDisp,
                                DISPID_MSDATASRCINTERFACE,
                                g_lcidUserDefault,
                                VT_UNKNOWN,
                                &punkInterface,
                                EVENT_PARAM(VTS_BSTR),
                                (BSTR) 0
                                );
            if (!DISPID_NOT_FOUND(hr))
            {
                _dpt = DPT_COM;
                _dispidDataBinding = DISPID_MSDATASRCINTERFACE;
                
                // listen for DatasrcChanged
                IGNORE_HR(CallDispMethod(pServiceProvider,
                                        _pOleSite->_pDisp,
                                        DISPID_ADVISEDATASRCCHANGEEVENT,
                                        g_lcidUserDefault,
                                        VT_VOID,
                                        NULL,
                                        EVENT_PARAM(VTS_UNKNOWN),
                                        (IUnknown*)(DataSourceListener*) this
                                        ));
                break;
            }

            // method 3:  look for IVBDSC (VB ICursor controls)
            hr = _pOleSite->QueryControlInterface(IID_IVBDSC, (void**)&punkInterface);
            if (hr == S_OK)
            {
                _dpt = DPT_ICURSOR;
                break;
            }

            // method 4:  look for a databinding interface in a property (older controls)
            //      This is last so that we don't look at the typelib until all else fails.
            pci = _pOleSite->GetClassInfo();
            if (pci->dispidSTD != DISPID_UNKNOWN)           // offers ISimpleTabularData
            {
                _dpt = DPT_PROPERTY;
                break;
            }
            if (pci->dispidRowset != DISPID_UNKNOWN)        // offers IRowset
            {
                _dpt = DPT_PROPERTY;
                break;
            }
            
        break;

        case COleSite::OSTAG_APPLET:
            // method 2:  look for the msDATASRCObject method (Java applets)
            hr = _pOleSite->_pDisp->GetIDsOfNames(IID_NULL, &oszMsDATASRCObject, 1,
                                        g_lcidUserDefault, &dispid);
            if (hr == S_OK)
            {
                DataSourceListener *pDSL = 0;
                
                _dpt = DPT_JAVA;
                _dispidDataBinding = dispid;
                
                // listen for DatasrcChanged
                if (S_OK ==_pOleSite->_pDisp->GetIDsOfNames(IID_NULL, &oszAddDataSrcListener, 1,
                                        g_lcidUserDefault, &dispid))
                {
                    IGNORE_HR(CallDispMethod(pServiceProvider,
                                            _pOleSite->_pDisp,
                                            dispid,
                                            g_lcidUserDefault,
                                            VT_VOID,
                                            NULL,
                                            EVENT_PARAM(VTS_UNKNOWN),
                                            (IUnknown*)(DataSourceListener*) this
                                            ));
                    ReleaseInterface(pDSL);
                }
            }
            break;
            
        }
        break;

    case ET_XML:
    {
        HRESULT     hr;
        DataSource *pDataSource = NULL;

        // get DataSource from the data island
        hr = _pElementOwner->QueryInterface(IID_DataSource, (void**)&pDataSource);
        if (hr == S_OK)
        {
            _dpt = DPT_DATASOURCE;
            IGNORE_HR(pDataSource->addDataSourceListener((DataSourceListener*)this));
            _pDataSource = pDataSource;
        }
        break;
    }
    
    default:
        break;
    }


    // if the DSO uses DataSource, it might also use ISimpleDataConverter
    if (_dpt == DPT_DATASOURCE)
    {
        ISimpleDataConverter *pSDC = NULL;

        hr = _pDataSource->QueryInterface(IID_ISimpleDataConverter, (void**)&pSDC);

#if DBG == 1
        // for debugging, use an internal mock-up of ISimpleDataConverter
        if (IsTagEnabled(tagUseDebugSDC))
        {
            ReleaseInterface(pSDC);
            pSDC = new CDbgSimpleDataConverter;
            hr = S_OK;
        }
#endif

        if (!hr && pSDC)
        {
            _pSDC = pSDC;
        }
    }
    
Cleanup:
    ReleaseInterface(punkInterface);
    ReleaseInterface(pServiceProvider);
    
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::DetachDataProviders (public)
//
//  Synopsis:   Release resources associated with data provider objects
//
//----------------------------------------------------------------------------
void
CDataMemberMgr::DetachDataProviders()
{
    int i;
    CDataMemberRecord *pdmr;

    // disconnect providers
    for (i=_aryDataMember.Size(), pdmr=_aryDataMember; i>0; --i, ++pdmr)
    {
        if (pdmr->_pdspProvider)
        {
            pdmr->_pdspProvider->Detach();
            pdmr->_pdspProvider->Release();
            pdmr->_pdspProvider = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::Detach (public)
//
//  Synopsis:   Release resources associated with data source objects
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::Detach()
{
    int i;
    CDataMemberRecord *pdmr;
    
    // disconnect databinding stuff
    for (i=_aryDataMember.Size(), pdmr=_aryDataMember; i>0; --i, ++pdmr)
    {
        FormsFreeString(pdmr->_bstrName);
        
        if (pdmr->_pdspProvider)
        {
            pdmr->_pdspProvider->Detach();
            pdmr->_pdspProvider->Release();
            pdmr->_pdspProvider = NULL;
        }

        if (pdmr->_punkDataBinding != PUNKDB_UNKNOWN)
        {
            ClearInterface(&pdmr->_punkDataBinding);
        }
    }
    _aryDataMember.DeleteAll();

    switch (_dpt)
    {
    case DPT_DATASOURCE:
        IGNORE_HR(_pDataSource->removeDataSourceListener((DataSourceListener*)this));
        ClearInterface(&_pDataSource);
        ClearInterface(&_pSDC);
        break;

    case DPT_COM:
    case DPT_JAVA:
        Assert(_et==ET_OLESITE && _pOleSite);
    // NOTE the spec says we're supposed to call addDataSourceListener(NULL)
    // but TDC, and presumably other controls, barf if we do
#if defined(CONTROLS_KNOW_HOW_TO_HANDLE_AddDataSourceListener_NULL)
        Doc()->PrivateQueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);
        IGNORE_HR(CallDispMethod(pServiceProvider,
                                _pOleSite->_pDisp,
                                DISPID_ADVISEDATASRCCHANGEEVENT,
                                g_lcidUserDefault,
                                VT_VOID,
                                NULL,
                                EVENT_PARAM(VTS_UNKNOWN),
                                NULL
                                ));
        ReleaseInterface(pServiceProvider);
#endif
        break;
        
    default:
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::Notify (public)
//
//  Synopsis:   handle notifications set to my element
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::Notify(CNotification * pnf)
{
    CDataMemberRecord * pdmr;
    int                 i;

    switch (pnf->Type())
    {
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if (_aryDataMember.Size())
            pnf->SetSecondChanceRequested();
        break;

    case NTYPE_STOP_2:
    case NTYPE_MARKUP_UNLOAD_2:
        // try to stop any data transfers that may be in progress
        for (i=_aryDataMember.Size(), pdmr=_aryDataMember;
             i > 0;
             --i, ++pdmr)
        {
            if (pdmr->_pdspProvider)
            {
                IGNORE_HR(pdmr->_pdspProvider->Stop());
            }
        }
        break;
        
    case NTYPE_BEFORE_UNLOAD:
        // Databinding spec requires us to fire onrowexit here..
        for (i=_aryDataMember.Size(), pdmr=_aryDataMember; i>0; --i, ++pdmr)
        {
            if (pdmr->_pdspProvider)          // Are we a data provider?
            {
                pdmr->_pdspProvider->FireDataEvent(&s_propdescCElementonrowexit);
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        DetachDataProviders();
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     GetTridentAsOSP (public)
//
//  Synopsis:   If my element is a Trident-As-OSP, return a pointer to
//              the CDoc.
//
//  Returns:    S_OK        my element is a Trident-As-OSP.  *ppDocOSP set.
//              S_FALSE     my element isn't a Trident-As-OSP.
//
//  Note:       The returned doc is *not* refcounted.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::GetTridentAsOSP(CDoc **ppDocOSP)
{
    HRESULT hr = S_FALSE;

    if (_et == ET_OLESITE &&
        S_OK == _pOleSite->QueryControlInterface(CLSID_HTMLDocument,
                                                (void**)ppDocOSP))
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataEvents (public)
//
//  Synopsis:   make sure there's a provider to actually fire data events
//              (see IE5 bug 3201).
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::EnsureDataEvents()
{
    CDataMemberRecord *pdmr = GetDataMemberRecord(NULL);
    CDataSourceBinder *pdsb;
    
    // if there's already a provider, no need to create a new one
    if (pdmr==NULL || pdmr->_pdspProvider == NULL)
    {
        // create a provider next time the databinding task list runs
        pdsb = new CDataSourceBinder(_pElementOwner, 0, BINDEROP_ENSURE_DATA_EVENTS);

        if (pdsb)
        {
            HRESULT hr;
            DBSPEC dbs;
            memset(&dbs, 0, sizeof(DBSPEC));

            hr = pdsb->Register(&dbs);
            if (hr)
            {
                pdsb->Passivate();      // will delete the binder
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::namedRecordset
//
//  Synopsis:   returns an ADO Recordset for the named data member.  Tunnels
//              into the hierarchy using the path, if given.
//
//  Arguments:  bstrDataMember  name of data member (NULL for default)
//              pvarHierarchy   BSTR path through hierarchy (optional)
//              pRecordSet      where to return the recordset.
//
//  Returns:    S_FALSE         not a provider
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::namedRecordset(BSTR bstrDatamember,
                               VARIANT *pvarHierarchy,
                               IDispatch **ppRecordSet)
{
    HRESULT hr=S_OK;
    BSTR bstrHierarchy = NULL;

    if (ppRecordSet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppRecordSet = NULL;                 // Make sure to null on failure.

    if (pvarHierarchy && V_VT(pvarHierarchy) == VT_BSTR)
    {
        bstrHierarchy = V_BSTR(pvarHierarchy);
    }
    
    // normal case, return ADO recordset based on my provider
    if (IsDataProvider())
    {
        CDataSourceProvider *pdsp = NULL;

        // get the top-level provider for the desired data member
        hr = GetDataSourceProvider(bstrDatamember, &pdsp);

        // find the inner level of hierarchy, if desired
        if (!hr && pdsp && !FormsIsEmptyString(bstrHierarchy))
        {
            CDataSourceProvider *pdspTop = pdsp;
            hr = pdspTop->GetSubProvider(&pdsp, bstrHierarchy);
            pdspTop->Release();
        }

        if (pdsp)
        {
            // We then query the CDataSourceProvider to give us back an ADO recordset,
            // if it can.
            hr = pdsp->QueryDataInterface(IID_IADORecordset15, (void **)ppRecordSet);
            pdsp->Release();

            // We clamp the most obvious failure mode here, so script authors can
            // simply test for recordset being NULL, and not get script errors.
            if (E_NOINTERFACE == hr)
            {
                hr = S_OK;
            }
        }
    }

    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     dataMemberChanged (DataSourceListener)
//
//  Synopsis:   DataSource notifies that a dataset has changed shape
//
//  Arguments:  bstrDM      name of the changed dataset (NULL means default)
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::dataMemberChanged(BSTR bstrDM)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::dataMemberChanged SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;

    hr = THR(ChangeDataBindingInterface(bstrDM, TRUE));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     dataMemberAdded (DataSourceListener)
//
//  Synopsis:   DataSource notifies that a new dataset has been born
//
//  Arguments:  bstrDM      name of the new dataset
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::dataMemberAdded(BSTR bstrDM)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::dataMemberAdded SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    RRETURN(S_OK);      // we don't care
}

//+---------------------------------------------------------------------------
//
//  Member:     dataMemberRemoved (DataSourceListener)
//
//  Synopsis:   DataSource notifies that a dataset has died
//
//  Arguments:  bstrDM      name of the dead dataset
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::dataMemberRemoved(BSTR bstrDM)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::dataMemberRemoved SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    CDataMemberRecord *pdmr = GetDataMemberRecord(bstrDM);

    if (pdmr)
    {
        if (pdmr->_pdspProvider)
        {
            pdmr->_pdspProvider->Detach();
            pdmr->_pdspProvider->Release();
            pdmr->_pdspProvider = NULL;
        }

        if (pdmr->_punkDataBinding != PUNKDB_UNKNOWN)
        {
            ClearInterface(&pdmr->_punkDataBinding);
        }
    }
        
    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     datasrcChanged (IDATASRCListener)
//
//  Synopsis:   DataSource notifies that a dataset has changed shape
//
//  Arguments:  bstrQualifier   name of the changed dataset (NULL means default)
//              fDataAvail      true if new dataset is available
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::datasrcChanged(BSTR bstrQualifier, BOOL fDataAvail)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::datasrcChanged SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;

    hr = THR(ChangeDataBindingInterface(bstrQualifier, fDataAvail));

    RRETURN(hr);
}


// This method is implemented here (rather than in baseprop.cxx)
// because it uses OleSite methods.  Getting #include <olesite.hxx> to work
// from src\core\cdbase proved to be an insurmountable challenge.

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_DataEvent(VARIANT v)
{
    GET_THUNK_PROPDESC

    return put_DataEventHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_DataEventHelper(VARIANT v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    HRESULT     hr;

    hr = put_VariantHelper(v, pPropDesc,  ppAttr);

    if (!hr)
    {
        // if we add a data event to an element, make sure the event can fire
        CDataMemberMgr::EnsureDataEventsFor(this, pPropDesc->GetDispid());
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataEventsFor (static)
//
//  Synopsis:   Make sure that data events can fire for the given element
//
//  Arguments:  pBase       the given element
//              dispid      the dispid of the event being hooked up
//
//  Returns:    nothing
//----------------------------------------------------------------------------

void
CDataMemberMgr::EnsureDataEventsFor(CBase *pBase, DISPID dispid)
{
    CElement *pElement = NULL;
    CDataMemberMgr *pdmm;
    HRESULT hr;

    switch (dispid)
    {
    // this list must agree with the list of events marked "dataevent"
    // in element.pdl
    case DISPID_EVPROP_ONROWEXIT:
    case DISPID_EVPROP_ONROWENTER:
    case DISPID_EVPROP_ONDATASETCHANGED:
    case DISPID_EVPROP_ONDATAAVAILABLE:
    case DISPID_EVPROP_ONDATASETCOMPLETE:
    case DISPID_EVPROP_ONROWSDELETE:
    case DISPID_EVPROP_ONROWSINSERTED:
    case DISPID_EVPROP_ONCELLCHANGE:

        hr = pBase->PrivateQueryInterface(CLSID_CElement, (void**)&pElement);
        if (!hr && pElement && pElement->IsConnectedToPrimaryMarkup())
        {
            pElement->EnsureDataMemberManager();
            pdmm = pElement->GetDataMemberManager();
            if (pdmm)
            {
                pdmm->EnsureDataEvents();
            }
        }
        break;

    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\drecgen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       drecgen.cxx
//
//  Contents:   record generator.
//              CRecordGeneratorTask
//              CRecordGenerator
//
//  History:
//
//  Jul-96      AlexA   Creation
//  8/13/96     SamBent Made record generation a LW task, to simulate async
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include <table.hxx>
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>                   // for db_s_endofrowset
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_DRECGEN_HXX_
#define X_DRECGEN_HXX_
#include "drecgen.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

DeclareTag(tagRecGenTask,"Databinding","CRecordGeneratorTask");
DeclareTag(tagRecGen,"DataBinding","CRecordGenerator");
DeclareTag(tagRecGenBatchSize, "Databinding", "Fetch g_BatchSize records at a time");

PerfDbgTag(tagSyncDatabind,  "Databinding", "Grab all records at once")

MtDefine(CRecordGenerator, DataBind, "CRecordGenerator")
MtDefine(CRecordGeneratorTask, DataBind, "CRecordGeneratorTask")

const int INITIAL_BATCH_SIZE = 3;

#if DBG == 1
static int g_BatchSize = 1;     // When tagRecGenBatchSize is enabled;  change via debugger
#endif


//////////////////////////////////////////////////////////////////////////
//
//  CRecordGeneratorTask implementation
//
//////////////////////////////////////////////////////////////////////////

// The lightweight task that generates records uses a buffer divided into
// four sections, containing respectively
//      o records client has released
//      o records client has fetched (but not released yet)
//      o records task has retrieved from the cursor (but client hasn't fetched)
//      o emply slots
// These areas are defined by data members _iEndReleased, _iEndFetched, and
// _iEndGenerated, which give the index just after the corresponding area:
//
//       --------------------------------------------------------------------
//      |   released    |     fetched     |    generated      |   (empty)    |
//       --------------------------------------------------------------------
//       _iEndReleased---^  _iEndFetched---^  _iEndGenerated---^

// typedef char CompileTimeAssert[cInitialRequestSize<=cBufferCapacity];


CRecordGeneratorTask::CRecordGeneratorTask(CDetailGenerator* pDetailGenerator,
                                           CRecordGenerator* pRecordGenerator,
                                           const CDataLayerBookmark& dlbStart,
                                           LONG lSkipCount,
                                           LONG lRecordsDesired,
                                           int cInitialRequestSize):
    CTask(TRUE),                        // this task should be born blocked
    _pDetailGenerator(pDetailGenerator),
    _pRecordGenerator(pRecordGenerator),
    _dlbLastRetrieved(dlbStart),
    _lSkipCount(lSkipCount),
    _hrTerminated(S_FALSE),         // in case I'm cancelled
    _cInitialRequestSize(cInitialRequestSize)
{
    if (lRecordsDesired > 0)
    {
        _cDirection = 1;
        _cDesired = lRecordsDesired;
    }
    else
    {
        _cDirection = -1;
        _cDesired = -lRecordsDesired;
    }
    Assert(_pDetailGenerator && _pRecordGenerator); 
    Assert(_cDesired > 0);
}

#if DBG==1
//+------------------------------------------------------------------------
//
//  Member:     IsValid
//
//  Synopsis:   Check that buffer representation is valid (used in Asserts)
//
//  Arguments:  none
//
//  Returns:    true        buffer is valid
//              false       buffer isn't valid

BOOL
CRecordGeneratorTask::IsValid() const
{
    return  _iEndReleased <= _iEndFetched &&
            _iEndFetched <= _iEndGenerated &&
            _iEndGenerated <= cBufferCapacity &&
            _cDirection * _cDirection == 1;
}
#endif


//+------------------------------------------------------------------------
//
//  Member:     FetchRecords (called by client)
//
//  Synopsis:   Move records from my buffer to client's buffer
//
//  Arguments:  cRecords            number of records to copy
//              ahRecords           client's array of records
//              pcRecordsFetched    number of records copied
//
//  Returns:    S_OK        it worked

HRESULT
CRecordGeneratorTask::FetchRecords(IN  ULONG  cRecords,
                     OUT RECORD ahRecords[],
                     OUT ULONG* pcRecordsFetched)
{
//    TraceTag((tagRecGenTask,
//                "CRecordGeneratorTask[%p]::FetchRecords(%lu, %p, %p) time %lu",
//                this, cRecords, ahRecords, pcRecordsFetched, GetTickCount()));
    Assert(pcRecordsFetched && "NULL pointer");
    Assert(IsValid());

    // don't fetch more records than we have
    if (cRecords > _iEndGenerated-_iEndFetched)
        cRecords = _iEndGenerated-_iEndFetched;

    // copy records to client's memory
    memmove(ahRecords, &_aRecordBuffer[_iEndFetched], cRecords * sizeof(RECORD));
    _iEndFetched += cRecords;
    
    // tell client how many
    *pcRecordsFetched = cRecords;

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Member:     ReleaseRecords (called by client)
//
//  Synopsis:   Release records
//
//  Arguments:  cRecords            number of records to release
//
//  Returns:    S_OK        it worked

HRESULT
CRecordGeneratorTask::ReleaseRecords(ULONG cRecords)
{
//    TraceTag((tagRecGenTask,
//                "CRecordGeneratorTask[%p]::ReleaseRecords(%lu) time %lu",
//                this, cRecords, GetTickCount()));
    Assert(IsValid());
    HRESULT hr;

    CDataLayerCursor* pCursor;
    
    hr = _pRecordGenerator->GetCursor(&pCursor);
    if (hr)
        goto Cleanup;
    
    // don't release more records than we have
    if (cRecords > _iEndGenerated-_iEndReleased)
        cRecords = _iEndGenerated-_iEndReleased;

    // release the records, and mark them released
    pCursor->ReleaseRows(cRecords, &_aRecordBuffer[_iEndReleased]);
    _iEndReleased += cRecords;
    if (_iEndFetched < _iEndReleased)
        _iEndFetched = _iEndReleased;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnRun (called by task manager)
//
//  Synopsis:   Retrieve more records, and callback to client
//
//  Arguments:  dwTimeout           tick count by which we should finish
//
//  Returns:    nothing

void 
CRecordGeneratorTask::OnRun(DWORD dwTimeout)
{
    TraceTag((tagRecGenTask,
                "CRecordGeneratorTask[%p]::OnRun(%lu) time %lu",
                this, dwTimeout, GetTickCount()));
    Assert(IsValid());

    BOOL    fPerfCtrlSyncDatabind = g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_SYNC_DATABIND)
#ifdef SWITCHES_ENABLED
                                    ||  IsSwitchSyncDatabind()
#endif
#if DBG==1 || defined(PERFTAGS)
                                    ||  IsPerfDbgEnabled(tagSyncDatabind)
#endif
           ;

    do
    {
        HRESULT hr;
        DBCOUNTITEM ulRecordsRetrieved = 0;
        ULONG   cThrottleRecords;         // how many we have time for
        ULONG   cRecords;                 // how many we plan to retrieve
        const   ULONG dwStartTime = GetTickCount();
        CDataLayerCursor* pCursor;

    #if DBG==1
        ULONG cPrevTime = _cPrevTime;
        ULONG cPrevGenerated = _cPrevGenerated;
    #endif
    
        hr = _pRecordGenerator->GetCursor(&pCursor);
        Assert(!hr && "Couldn't get cursor");       // this shouldn't happen

        // discard released records, and shift contents of buffer
        if (_iEndReleased > 0)
        {
            memmove(_aRecordBuffer, &_aRecordBuffer[_iEndReleased],
                    (_iEndGenerated-_iEndReleased) * sizeof(RECORD));
            _iEndGenerated -= _iEndReleased;
            _iEndFetched   -= _iEndReleased;
            _iEndReleased   = 0;
        }
        Assert(IsValid());

        // cThrottleRecords is the "ideal" number of records to fetch
        cThrottleRecords = 
                        // first time - throttle to initial request
            (_cPrevTime == 0) ? _cInitialRequestSize :
                        // otherwise estimate how many we have time for
            (2*_cPrevGenerated*(dwTimeout-dwStartTime) + _cPrevTime) / (2*_cPrevTime);
        if (cThrottleRecords < 1)   // but get at least one
            cThrottleRecords = 1;    
    
        // determine how many records to fetch
        cRecords = _cDesired - _cTotalGenerated;     // try to finish request
        if (cRecords > cThrottleRecords)             // but don't take too long
            cRecords = cThrottleRecords;
        if (cRecords > cBufferCapacity-_iEndGenerated) // and don't overflow buffer
            cRecords = cBufferCapacity - _iEndGenerated;

    #if DBG==1
        if (IsTagEnabled(tagRecGenBatchSize))
            cRecords = g_BatchSize;
    #endif
        AssertSz(cRecords > 0, "Can't make progress fetching 0 records");

        // retrieve the records, mark them generated
        hr = pCursor->GetRowsAt(_dlbLastRetrieved,
                                _lSkipCount,
                                _cDirection * (DBROWCOUNT) cRecords,
                                &ulRecordsRetrieved,
                                &_aRecordBuffer[_iEndGenerated]);
    
        _cTotalGenerated += (ULONG)ulRecordsRetrieved;
        _iEndGenerated += (ULONG)ulRecordsRetrieved;

        // notify client that records are available
        if (_iEndGenerated - _iEndFetched > 0)
        {
            IGNORE_HR(_pDetailGenerator->OnRecordsAvailable(_iEndGenerated - _iEndFetched));
        }

        // prepare for the next batch
        if (ulRecordsRetrieved > 0)
        {
            // remember where we stopped
            IGNORE_HR(pCursor->CreateBookmark(_aRecordBuffer[_iEndGenerated-1],
                                            &_dlbLastRetrieved));
            _lSkipCount = _cDirection;

            // remember how long it took and how many records we got
            _cPrevTime = GetTickCount() - dwStartTime;
            _cPrevGenerated = ulRecordsRetrieved;
        }

        TraceTag((tagRecGenTask,
            "CRecordGeneratorTask[%p]::OnRun (time %lu) retrieved %lu records in %lu ticks \n"
            " desired = %lu, cThrottleRecords = %lu, cRecords = %lu, cPrevTime = %lu, cPrevGenerated = %lu, ticks = %lu",
            this, GetTickCount(), ulRecordsRetrieved, _cPrevTime,
            _cDesired, cThrottleRecords, cRecords,
            cPrevTime, cPrevGenerated , dwTimeout-dwStartTime
            ));

        // if we're done, terminate
        if (_iEndGenerated - _iEndFetched == 0 &&
            (FAILED(hr) || ulRecordsRetrieved<cRecords || _cTotalGenerated>=_cDesired))
        {
            _hrTerminated = hr;
            Terminate();
        }
    }
    while ( fPerfCtrlSyncDatabind && !TestFlag(TASKF_TERMINATED) );

}

//+------------------------------------------------------------------------
//
//  Member:     OnTerminate (called by task manager)
//
//  Synopsis:   notify parent that task is done
//
//  Arguments:  none
//
//  Returns:    nothing

void
CRecordGeneratorTask::OnTerminate()
{
    TraceTag((tagRecGenTask,
                "CRecordGeneratorTask[%p]::OnTerminate() time %lu",
                this, GetTickCount()));
    
    // release records
    IGNORE_HR(ReleaseRecords(_iEndGenerated - _iEndReleased));
    _dlbLastRetrieved = CDataLayerBookmark::TheNull;

    // tell parent I'm done
    if (_hrTerminated != S_FALSE)
        _pRecordGenerator->OnTaskDone();
}
    


//////////////////////////////////////////////////////////////////////////
//
//  CRecordGenerator implementation
//
//////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  class       CRecordGenerator
//
//  Member:     constructor
//
//-------------------------------------------------------------------------
CRecordGenerator::CRecordGenerator ():
    _pDLC(0),
    _pDetailGenerator(0),
    _pTask(0)
{
    TraceTag((tagRecGen, "CRecordGenerator::constructor() -> %p", this));
}




//+------------------------------------------------------------------------
//
//  class       CRecordGenerator
//
//  Member:     destructor
//
//-------------------------------------------------------------------------
CRecordGenerator::~CRecordGenerator()
{
    TraceTag((tagRecGen, "CRecordGenerator::destructor() -> %p", this));

    Assert (!_pDLC);                // Detach should be called first
    Assert (!_pDetailGenerator);
    Assert (!_pTask);
}




//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detaches the object, removing any internal self-
//              references.
//
//-------------------------------------------------------------------------
void 
CRecordGenerator::Detach()
{
    TraceTag((tagRecGen, "CRecordGenerator::Detach() -> %p", this));

    // if my task is running, shut it off
    if (_pTask)
    {
        _pTask->Release();
        _pTask = 0;
    }

    if (_pDLC)
    {
        _pDLC->Release();
        _pDLC = NULL;
    }
    
    _pDetailGenerator = NULL;
}




//+------------------------------------------------------------------------
//
//  Member:     RequestMetaData
//
//  Synopsis:   Before starting generating rows, we need to get the metadata
//              to establish binding specifications for the bound elements.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT 
CRecordGenerator::RequestMetaData()
{
    TraceTag((tagRecGen, "CRecordGenerator::RequestMetaData() -> %p", this));
    Assert(_pDetailGenerator && "call Init first");
    
    HRESULT hr;
    CDataLayerCursor *pCursor;

    hr = GetCursor(&pCursor);
    if (hr)
        goto Cleanup;

    hr = _pDetailGenerator->OnMetaDataAvailable();

Cleanup:
    RRETURN (hr);
}



//+------------------------------------------------------------------------
//
//  Member:     GetCursor
//
//  Synopsis:   Get Cursor 
//
//  Note:       Could fail during the metadata fetching
//
//  Arguments:  [ppCursor]              -- pointer to an a result (pointer to a Cursor).
//                                          
//  Returns:    HRESULT 
//
//-------------------------------------------------------------------------
HRESULT 
CRecordGenerator::GetCursor(CDataLayerCursor **ppDataLayerCursor)
{
    *ppDataLayerCursor = _pDLC;
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CancelRequest
//
//  Synopsis:   Call from the Host to stop previous request to generate rows
//
//  Arguments:  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT 
CRecordGenerator::CancelRequest ()
{
//    TraceTag((tagRecGen, "CRecordGenerator::CancelRequest() -> %p", this));

    if (_pTask)
    {
        _pTask->Release();      // this calls Terminate
        _pTask = 0;
    }
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     GetRatio
//
//  Synopsis:   Get the ratio for the record
//
//  Arguments:  record          record to get the ratio for
//              pulNumerator    result
//              pulDenominator  result
//                                          
//-------------------------------------------------------------------------

void 
CRecordGenerator::GetRatio(RECORD record, 
                           DBCOUNTITEM *pulNumerator, 
                           DBCOUNTITEM *pulDenominator)
{
    Assert (pulNumerator);
    Assert (pulDenominator);

    CDataLayerCursor *  pCursor;
    HRESULT             hr;

    hr = GetCursor(&pCursor);
    if (hr)
        goto Cleanup;
    
    hr = pCursor->GetPositionAndSize(record, pulNumerator, pulDenominator);
    Assert (!hr);           // should never fail

Cleanup:
    return;
}




#if DBG==1
static ULONG ulDebugGenerateCount=0;    // set (in debugger) to truncate query
static BOOL fDebugSynchronous=0;        // set to turn off asynchrony
#endif

//+------------------------------------------------------------------------
//
//  Member:     StartTask
//
//  Synopsis:   Start a task to retrive records
//
//  Arguments:  dlbStart        bookmark of starting record
//              lSkipCount      offset from bookmark to starting record
//              ulGenerateCount number of records to generate
//
//  Returns:    HRESULT

HRESULT
CRecordGenerator::StartTask(const CDataLayerBookmark& dlbStart, 
                           LONG lSkipCount,
                           ULONG ulGenerateCount)
{
    TraceTag((tagRecGen, "CRecordGenerator::StartTask[%p](%p, %ld, %lu)",
                            this, &dlbStart, lSkipCount, ulGenerateCount));
    HRESULT hr = S_OK;
    
#if DBG==1
    // debugging - reset desired count
    if (ulDebugGenerateCount>0 && ulDebugGenerateCount<ulGenerateCount)
        ulGenerateCount = ulDebugGenerateCount;
#endif

    Assert(!_pTask);

    // create a task to generate the records (this also schedules the task)
    _pTask = new CRecordGeneratorTask(_pDetailGenerator, this, dlbStart,
                                      lSkipCount, ulGenerateCount, INITIAL_BATCH_SIZE);
    if (_pTask == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _pTask->SetBlocked(FALSE);          // let task get scheduled now.

#if DBG==1
    // debugging - do task synchronously
    if (fDebugSynchronous)
    {
        while (_pTask)
        {
            _pTask->OnRun(GetTickCount()+100);
        }
    }
#endif

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnTaskDone
//
//  Synopsis:   Notification from task that it's done.  Release the task,
//              and notify my client

void
CRecordGenerator::OnTaskDone()
{
    if (_pTask)
    {
        HRESULT hrReasonTerminated = _pTask->ReasonTerminated();
        
        _pTask->Release();
        _pTask = 0;

        Assert(_pDetailGenerator);
        _pDetailGenerator->OnRequestDone( hrReasonTerminated == DB_S_ENDOFROWSET 
                                    || hrReasonTerminated == DB_E_BADSTARTPOSITION );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\dbtask.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1997
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Bind Task objects
//
//  Classes:    
//
//  History:    10/1/96     (sambent) created


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_SIMPDC_HXX_
#define X_SIMPDC_HXX_
#include "simpdc.hxx"
#endif

PerfDbgTag(tagDBTask,"Databinding","Databinding task");
MtDefine(CDataBindTask, DataBind, "CDataBindTask");
MtDefine(CDataBindTask_aryCRI_pv, CDataBindTask, "CDataBindTask::_aryCRI::_pv");


/////////////////////////////////////////////////////////////////////////////
/////                       CDataBindTask methods                       /////
/////////////////////////////////////////////////////////////////////////////

/*  Each CDoc owns a CDataBindTask to manage its databinding chores.
*/


//+-------------------------------------------------------------------------
// Member:      SetEnabled (public)
//
// Synopsis:    change the enabled state of the task
//
// Arguments:   fEnabled    new state
//
// Returns:     old state

BOOL
CDataBindTask::SetEnabled(BOOL fEnabled)
{
    BOOL fOldEnabled = _fEnabled;
    PerfDbgLog1(tagDBTask, this, "fEnabled is now %d", fEnabled);
    _fEnabled = fEnabled;
    DecideToRun();
    return fOldEnabled;
}


//+-------------------------------------------------------------------------
// Member:      Add Deferred Binding (public)
//
// Synopsis:    add a binder to the list of deferred bindings
//
// Arguments:   pdsb        the new binding

HRESULT
CDataBindTask::AddDeferredBinding(CDataSourceBinder *pdsb, BOOL fSetWait)
{
    HRESULT hr = S_OK;
    Assert(pdsb);

    if (pdsb->_fOnTaskList)
    {
        RemoveDeferredBinding(pdsb);
    }
    Assert(!pdsb->_fOnTaskList);

    PerfDbgLog2(tagDBTask, this, "Add binding for %ls %x",
                pdsb->GetElementConsumer()->TagName(), pdsb->GetElementConsumer());
    
    // add new binder to my waiting list
    pdsb->_pdsbNext = _pdsbWaiting;
    _pdsbWaiting = pdsb;
    pdsb->_fOnTaskList = TRUE;

    if (fSetWait)
    {
        SetWaiting();
    }
    
    DecideToRun();
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      RemoveBindingFromList (private)
//
// Synopsis:    remove a binder from the list of deferred bindings
//
// Arguments:   pdsb                binder to remove
//              ppdsbListHead       pointer to head of list
//              pdwProgCookie       progress cookie for this list

void
CDataBindTask::RemoveBindingFromList(CDataSourceBinder *pdsb,
                                        CDataSourceBinder **ppdsbListHead,
                                        DWORD *pdwProgCookie)
{
    CDataSourceBinder **ppdsbPrev = ppdsbListHead;
    
    // remove binder the list
    while (*ppdsbPrev)
    {
        if (*ppdsbPrev == pdsb)
            *ppdsbPrev = pdsb->_pdsbNext;       // delete binder from list
        else
            ppdsbPrev = &((*ppdsbPrev)->_pdsbNext);
    }

    // if list is now empty, deletes its progress item
    if (*ppdsbListHead == NULL && *pdwProgCookie)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);

        if (pProgSink)
        {        
            pProgSink->DelProgress(*pdwProgCookie);
            *pdwProgCookie = 0;
        }
    }
}


//+-------------------------------------------------------------------------
// Member:      Remove Deferred Binding (public)
//
// Synopsis:    remove a binder from the list of deferred bindings
//
// Arguments:   pdsb        the new binding

HRESULT
CDataBindTask::RemoveDeferredBinding(CDataSourceBinder *pdsb)
{
    HRESULT hr = S_OK;
    Assert(pdsb);

    PerfDbgLog2(tagDBTask, this, "Remove binding for %ls %x",
                pdsb->GetElementConsumer()->TagName(), pdsb->GetElementConsumer());

    // remove binder from my in-process list
    RemoveBindingFromList(pdsb, &_pdsbInProcess, &_dwProgCookieActive);

    // remove binder from my waiting list
    RemoveBindingFromList(pdsb, &_pdsbWaiting, &_dwProgCookieWait);
    
    pdsb->_fOnTaskList = FALSE;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      RemoveDataEventRequestsFor (public)
//
// Synopsis:    remove all ENSURE_DATA_EVENTS requests for the given element
//
// Arguments:   pelProvider     the element whose requests we should remove

HRESULT
CDataBindTask::RemoveDataEventRequestsFor(CElement *pelProvider)
{
    HRESULT hr = S_OK;
    CDataSourceBinder *pdsb, *pdsbNext;

    PerfDbgLog2(tagDBTask, this, "Remove data event requests for %ls %x",
                pelProvider->TagName(), pelProvider);

    // remove requests from my in-process list
    for (pdsb = _pdsbInProcess;  pdsb;  pdsb = pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS &&
            pelProvider == pdsb->GetElementConsumer())
        {
            RemoveBindingFromList(pdsb, &_pdsbInProcess, &_dwProgCookieActive);
            delete pdsb;
        }
    }

    // remove requests from my waiting list
    for (pdsb = _pdsbWaiting;  pdsb;  pdsb = pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS &&
            pelProvider == pdsb->GetElementConsumer())
        {
            RemoveBindingFromList(pdsb, &_pdsbWaiting, &_dwProgCookieWait);
            delete pdsb;
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      InitCurrentRecord (public)
//
// Synopsis:    add to the list of CRI's that need init
//
// Arguments:   pCRI        CRI that needs init

HRESULT
CDataBindTask::InitCurrentRecord(CCurrentRecordInstance *pCRI)
{
    HRESULT hr = _aryCRI.Append(pCRI);
    if (!hr)
    {
        pCRI->AddRef();
        DecideToRun();
    }
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      DecideToRun (public)
//
// Synopsis:    unblock if there's work to do, and permission to do it
//
// Arguments:   none

void
CDataBindTask::DecideToRun()
{
    BOOL fBlocked = !_fEnabled;

    // if there's work waiting, set up a progress sink in the Doc.
    // This delays onload until databinding is done.
    if (_dwProgCookieWait == 0 && _fWorkWaiting && _pdsbWaiting)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);

        if (pProgSink)
            IGNORE_HR(pProgSink->AddProgress(PROGSINK_CLASS_DATABIND, &_dwProgCookieWait));
    }

    if (_fEnabled)
    {
        // transfer waiting tasks to the active list, if it's empty
        if (_fWorkWaiting && !_pdsbInProcess)
        {
            int cBindingsMoved = 0;

            // The binders were added to the front of the waiting list, so
            // they appear in reverse order.  We reverse the list here, so that
            // we process them in the same order they appeared on the page.
            // This is pshychologically more pleasant, and also improves performance
            // (we change the page top-to-bottom, so recalc is faster).
            // This also processes nested tables in the right order (outside-in).
            while (_pdsbWaiting)
            {
                CDataSourceBinder *pdsbTemp = _pdsbWaiting->_pdsbNext;
                _pdsbWaiting->_pdsbNext = _pdsbInProcess;
                _pdsbInProcess = _pdsbWaiting;
                _pdsbWaiting = pdsbTemp;
                ++ cBindingsMoved;
            }

            PerfDbgLog1(tagDBTask, this, "Moving %d bindings to active list", cBindingsMoved);

            // the previous active list may not have shut down its progress sink
            // yet.  If not, do it now.
            if (_dwProgCookieActive)
            {
                IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);
                Assert(pProgSink);

                pProgSink->DelProgress(_dwProgCookieActive);
                _dwProgCookieActive = 0;
            }
            
            _dwProgCookieActive = _dwProgCookieWait;
            _dwProgCookieWait = 0;

            // tell my progress sink to start supplying feedback
            if (_pdsbInProcess && _dwProgCookieActive)
            {
                IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pdsbInProcess->GetElementConsumer()->GetMarkup());
                Assert(pProgSink);
                
                IGNORE_HR(pProgSink->SetProgress(_dwProgCookieActive,
                    PROGSINK_SET_STATE | PROGSINK_SET_IDS |
                    PROGSINK_SET_POS | PROGSINK_SET_MAX,
                    PROGSINK_STATE_LOADING, NULL, IDS_DATABINDING, 0, cBindingsMoved));
            }
            _cInProcess = 0;        // OnRun will count up again
        }

        // if there's nothing to do, init the CRIs
        if (!_fBinding && _pdsbInProcess == NULL)
        {
            int i;
            CCurrentRecordInstance **ppCRI;
            CPtrAry<CCurrentRecordInstance*> aryCRI(Mt(CDataBindTask_aryCRI_pv));

            // make a local copy of the array, in case there's reentrancy
            for (i=_aryCRI.Size(), ppCRI=_aryCRI; i>0;  --i, ++ppCRI)
            {
                if (S_OK == aryCRI.Append(*ppCRI))
                {
                    (*ppCRI)->AddRef();
                }
            }
            _aryCRI.ReleaseAll();

            // init all the CRI's 
            for (i=aryCRI.Size(), ppCRI=aryCRI; i>0;  --i, ++ppCRI)
            {
                (*ppCRI)->InitPosition(TRUE);
            }
            aryCRI.ReleaseAll();
        }

        // init-ing the CRI's may have caused new bindings to join the list
        fBlocked = (_pdsbInProcess == NULL);
    }

    // if the waiting list is empty, turn off the waiting flag
    if (_pdsbWaiting == NULL)
        _fWorkWaiting = FALSE;

    SetBlocked(fBlocked);
}


//+-------------------------------------------------------------------------
// Member:      On Run (public, CTask)
//
// Synopsis:    process deferred bindings
//
// Arguments:   dwTimeout       time by which I should finish

void
CDataBindTask::OnRun(DWORD dwTimeout)
{
    HRESULT hr=S_OK;

    _fBinding = TRUE;
    
    // process as many bindings as we can do in the allotted time
    while (_pdsbInProcess)
    {
        CDataSourceBinder *pdsbCurrent = _pdsbInProcess;
#if DBG==1 || defined(PERFTAGS)
        int dbop = pdsbCurrent->_dbop;
        CElement *pElemConsumer = pdsbCurrent->GetElementConsumer();
#endif
        
        _pdsbInProcess = _pdsbInProcess->_pdsbNext; // update the list
        pdsbCurrent->_fOnTaskList = FALSE;
        ++ _cInProcess;                             // track progress

        PerfDbgLog3(tagDBTask, this, "+Op %d for %ls %x",
                        dbop, pElemConsumer->TagName(), pElemConsumer);

        // do the operation the current binder wants
        switch (pdsbCurrent->_dbop)
        {
        case BINDEROP_BIND:
            hr = pdsbCurrent->_fNotReady ? S_FALSE : pdsbCurrent->TryToBind();
            break;

        case BINDEROP_UNBIND:
            hr = pdsbCurrent->UnBind();
            break;

        case BINDEROP_REBIND:
            hr = pdsbCurrent->_fNotReady ? S_FALSE : pdsbCurrent->ReBind();
            break;

        case BINDEROP_ENSURE_DATA_EVENTS:
            hr = pdsbCurrent->EnsureDataEvents();
            // once the events are ensured, we don't need the binder
            if (!hr)
            {
                delete pdsbCurrent;
            }
            break;
        }

        PerfDbgLog4(tagDBTask, this, "-Op %d for %ls %x yielded hr %x",
                        dbop, pElemConsumer->TagName(), pElemConsumer,
                        hr);
        
        // If something went wrong, throw the binder back on the waiting list;
        // we'll try again later, perhaps it'll work then.
        if (hr)
        {
            AddDeferredBinding(pdsbCurrent, FALSE);
        }

        if (GetTickCount() >= dwTimeout)            // don't exceed allotted time
            break;
    }

    // report progress
    if (_dwProgCookieActive)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);
        Assert(pProgSink);

        if (_pdsbInProcess)
        {
            pProgSink->SetProgress(_dwProgCookieActive,
                                    PROGSINK_SET_POS, 0, NULL, 0, _cInProcess, 0);
        }
        else
        {
            pProgSink->DelProgress(_dwProgCookieActive);
            _dwProgCookieActive = 0;
        }
    }

    _fBinding = FALSE;
    
    DecideToRun();              // see if there's more work to do
}


//+-------------------------------------------------------------------------
// Member:      On Terminate (public, CTask)
//
// Synopsis:    shut down the task (possibly before all bindings have happened)
//
// Arguments:   none

void
CDataBindTask::OnTerminate()
{
    if (_pDoc == NULL)
        goto Cleanup;

    Stop();

    _pDoc->SubRelease();
    _pDoc = NULL;
    _pMarkup->SubRelease();
    _pMarkup = NULL;

Cleanup:
    return;
}


//+-------------------------------------------------------------------------
// Member:      Stop (public)
//
// Synopsis:    shut down the task (possibly before all bindings have happened)
//
// Arguments:   none

void
CDataBindTask::Stop()
{
    CDataSourceBinder *pdsb, *pdsbNext;
    IProgSink *pProgSink;

    _fWorkWaiting = FALSE;               // don't process the waiting list
    
    // discard waiting list
    for (pdsb=_pdsbWaiting; pdsb; pdsb=pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        pdsb->_fOnTaskList = FALSE;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS)
        {
            delete pdsb;
        }
    }
    _pdsbWaiting = 0;
    
    // discard in-process list
    for (pdsb=_pdsbInProcess; pdsb; pdsb=pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        pdsb->_fOnTaskList = FALSE;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS)
        {
            delete pdsb;
        }
    }
    _pdsbInProcess = 0;

    // discard CRI list
    _aryCRI.ReleaseAll();

    // turn off progress items
    pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);
    if (pProgSink && _dwProgCookieWait)
    {
        pProgSink->DelProgress(_dwProgCookieWait);
        _dwProgCookieWait = 0;
    }
    if (pProgSink && _dwProgCookieActive)
    {
        pProgSink->DelProgress(_dwProgCookieActive);
        _dwProgCookieActive = 0;
    }

    ClearInterface(&_pSDC);
}


//+-------------------------------------------------------------------------
// Member:      GetSimpleDataConverter (public)
//
// Synopsis:    return the doc-global SimpleDataConverter, creating it
//              if necessary.  This is used for elements bound with
//              dataFormatAs = localized-text.
//
// Arguments:   none

ISimpleDataConverter *
CDataBindTask::GetSimpleDataConverter()
{
    if (!_pSDC)
    {
        _pSDC = new CSimpleDataConverter;
    }
    return _pSDC;       // not refcounted!!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\provider.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1997
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Source Provider objects
//
//  Classes:    CDataSourceProvider (abstract)
//                  CAdaptingProvider
//                      CRowsetProvider
//                      CSTDProvider
//                      CCursorProvider
//                  CNullProvider
//              CDataSetEvents (used by provider classes)
//
//  History:    10/1/96     (sambent) created

// The concrete classes derived from CDataSourceProvider are
// declared in this file, which makes them unknown to the rest of the world.
// The function CDataSourceProvider::Create acts as a
// factory -- creating the appropriate concrete provider.
// 
// To support a new type of provider, derive a new class from CDataSourceProvider,
// and add code to CDataSourceProvider::Create to create an instance.

// The CDataSourceProvider class (and classes derived from it), are
// designed to be owned by a CObjectElement associated with a data-source
// control.  This allows the Trident object model to expose an ADO
// interface on suitable controls -- the OM request for ADO translates into
// a QDI (QueryDataInterface) on the element's provider object.
// A CDataSourceBinder object also holds a reference to a provider, usually (but
// not always) one that it shares with a control site.
// 
// Some words about refcounting.  The provider object owns (and refcounts)
// references into the control.  The owning element also owns references
// into the control, as well as a reference to the provider.  When the
// owning element is through with its control, its Detach method releases
// the provider, which in turn releases its own references to the control.
// Releasing in Detach solves any circular reference problems.
// 
// When a provider is shared by a control site and a binder, it doesn't die
// until both references go away.  This keeps the control alive even after
// its site has died as long as it's still in use for databinding.
// 
// Providers also snap in adapters between a control's native interface and
// the interface desired by a data-bound element (or the object model).  A
// provider remembers adapted interfaces it has handed out, so that it can
// hand out the same interface if asked again.  Thus, several
// ICursor-consuming elements can be bound to single STD control, and the
// provider arranges that they all share the same ICursor it has created by
// interposing the Viaduct II (cursor-to-rowset) and Nile2Std
// (rowset-to-STD) adapters.

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include <rowset.hxx>
#endif

#ifndef X_FORMSARY_HXX_
#define X_FORMSARY_HXX_
#include <formsary.hxx>
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include <evntprm.hxx>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_DBINDING_HXX_
#define X_DBINDING_HXX_
#include "dbinding.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

#ifndef X_SIMPDC_H_
#define X_SIMPDC_H_
#include "simpdc.h"
#endif

#ifndef X_BMKCOLL_HXX_
#define X_BMKCOLL_HXX_
#include "bmkcoll.hxx"
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <adoid.h>
#endif

#ifndef X_ADO_ADOINT_H_
#define X_ADO_ADOINT_H_
#include <adoint.h>
#endif

#ifndef X_ADO_ADOSECUR_H_
#define X_ADO_ADOSECUR_H_
#include <adosecur.h>
#endif

#define VD_INCLUDE_ROWPOSITION 

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include <vbcursor/ocdb.h>
#endif

#ifndef X_VBCURSOR_OCDBID_H_
#define X_VBCURSOR_OCDBID_H_
#include <vbcursor/ocdbid.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h>
#endif

#ifndef X_VBCURSOR_OLEBIND_H_
#define X_VBCURSOR_OLEBIND_H_
#include <vbcursor/olebind.h>
#endif

#ifndef X_VBCURSOR_MSC2R_H_
#define X_VBCURSOR_MSC2R_H_
#include <vbcursor/msc2r.h>                      // viaduct-i  ole include
#endif

#ifndef X_VBCURSOR_MSR2C_H_
#define X_VBCURSOR_MSR2C_H_
#include <vbcursor/msr2c.h>                      // viaduct-ii ole include
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

typedef Recordset15 IADORecordset;    // beats me why ADO doesn't use I...
typedef ADORecordsetConstruction IADORecordsetConstruction;

#ifdef UNIX
#include "unixposition.hxx"
#else
   EXTERN_C const CLSID CLSID_CRowPosition;
#endif

class CAdaptingProvider;

DeclareTag(tagRowEvents, "RowEvents", "Show row events");
MtDefine(CDataSetEvents, DataBind, "CDataSetEvents")
MtDefine(CADOClientSite, DataBind, "CADOClientSite")
MtDefine(CNullProvider, DataBind, "CNullProvider")
MtDefine(CAdaptingProvider, DataBind, "CAdaptingProvider")
MtDefine(CAdaptingProvider_aryCR_pv, CAdaptingProvider, "CAdaptingProvider::_aryCR::_pv")
MtDefine(CAdaptingProvider_aryPR_pv, CAdaptingProvider, "CAdaptingProvider::_aryPR::_pv")
MtDefine(CAdaptingProvider_aryAR_pv, CAdaptingProvider, "CAdaptingProvider::_aryAR::_pv")
MtDefine(CAdaptingProvider_aryXT_pv, CAdaptingProvider, "CAdaptingProvider::_aryXT::_pv");


/////////////////////////////////////////////////////////////////////////////
/////                       Helper functions                            /////
/////////////////////////////////////////////////////////////////////////////

void
ReleaseChapterAndRow(HCHAPTER hchapter, HROW hrow, IRowPosition *pRowPos)
{
    IRowset *pRowset = NULL;
    IChapteredRowset *pChapRowset = NULL;
    
    if (pRowPos && (hrow != DB_NULL_HROW || hchapter != DB_NULL_HCHAPTER))
    {
        pRowPos->GetRowset(IID_IRowset, (IUnknown **)&pRowset);
        AssertSz(pRowset, "Can't get rowset from rowpos");

        // release the hrow
        if (hrow != DB_NULL_HROW)
        {
            pRowset->ReleaseRows(1, &hrow, NULL, NULL, NULL);
        }

        // release the hchapter
        if (hchapter != DB_NULL_HCHAPTER)
        {
            pRowset->QueryInterface(IID_IChapteredRowset, (void**)&pChapRowset);
            if (pChapRowset)
            {
                pChapRowset->ReleaseChapter(hchapter, NULL);
                ReleaseInterface(pChapRowset);
            }
        }

        ReleaseInterface(pRowset);
    }
}


/////-------------------------------------------------------------------/////
///// CADOClientSite.  Client site given to ADO.  We only implement the /////
///// methods ADO actually uses, and delegate the real work to the Doc. /////
/////-------------------------------------------------------------------/////
class CADOClientSite: public IOleClientSite, public IServiceProvider
{
public:
    // creation/destruction
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CADOClientSite))
    CADOClientSite(CDoc *pDoc);
    ~CADOClientSite();

    // IOleClientSite methods
    HRESULT STDMETHODCALLTYPE SaveObject();
    HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign,
            DWORD dwWhichMoniker,
            LPMONIKER FAR* ppmk);
    HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER FAR* ppContainer);
    HRESULT STDMETHODCALLTYPE ShowObject();
    HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL fShow);
    HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();
    
    //  IServiceProvider methods
    HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID iid, void ** ppv);

    // IUnknown methods
    STDMETHODIMP_(ULONG)    AddRef() { return ++_ulRefs; }
    STDMETHODIMP_(ULONG)    Release();
    STDMETHODIMP            QueryInterface(REFIID riid, void **ppv);

    // public methods

private:
    ULONG               _ulRefs;        // reference count
    CDoc *              _pDoc;          // my Doc

    // private methods
    CDoc *              Doc() { return _pDoc; }
};

//+-------------------------------------------------------------------------
// Member:      constructor (CADOClientSite, public)
//
// Synopsis:    

CADOClientSite::CADOClientSite(CDoc *pDoc) : _ulRefs(1)
{
    Assert(pDoc);

    _pDoc = pDoc;
    if (_pDoc)
        _pDoc->SubAddRef();
}

//+-------------------------------------------------------------------------
// Member:      destructor (CADOClientSite, public)
//
// Synopsis:    

CADOClientSite::~CADOClientSite()
{
    if (_pDoc)
        _pDoc->SubRelease();
}

//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, die if 0
//
// Returns:     new refcount

ULONG
CADOClientSite::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
        delete this;
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      Query Interface (public, IUnknown)
//
// Synopsis:    return desired interface pointer
//
// Arguments:   riid        IID of desired interface
//              ppv         where to store the pointer
//
// Returns:     HRESULT

HRESULT
CADOClientSite::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punkReturn = 0;

    // check for bad arguments
    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // look for interfaces I support
    if (IsEqualIID(riid, IID_IUnknown))
    {
        punkReturn = (IOleClientSite *)this;
    }
    else if (IsEqualIID(riid, IID_IOleClientSite))
    {
        punkReturn = (IOleClientSite *)this;
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        punkReturn = (IServiceProvider *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }
    punkReturn->AddRef();          // return addref'd copy
    *ppv = punkReturn;
    hr = S_OK;

Cleanup:
    return hr;        
}


/////////////      IOleClientSite methods     ////////////////////////////
// We only need these so we can give ADO a client site (so it can determine
// its security behavior).  But ADO only calls GetContainer, to get to the
// Doc, and QI(ServiceProvider).

STDMETHODIMP
CADOClientSite::SaveObject()
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::GetMoniker(DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER FAR* ppmk)
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    HRESULT hr;
    hr = Doc() ? THR(Doc()->QueryInterface(IID_IOleContainer, (void **)ppContainer)) : E_FAIL;
    RRETURN(hr);
}

STDMETHODIMP
CADOClientSite::ShowObject()
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::OnShowWindow(BOOL fShow)
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::RequestNewObjectLayout()
{ return E_NOTIMPL; }


/////////////      IServiceProvider methods     ////////////////////////////
// We delegate all requests (from ADO) right to the Doc

STDMETHODIMP
CADOClientSite::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    RRETURN(Doc() ? Doc()->QueryService(guidService, iid, ppv) : E_FAIL);
}


/////-------------------------------------------------------------------/////
///// CDataSetEvents.  Listens for rowset notifications on behalf of    /////
///// provider, and fires data events                                   /////
/////-------------------------------------------------------------------/////

class CDataSetEvents: public IRowPositionChange, public IDBAsynchNotify,
                      public IRowsetNotify
{
    friend class CAdaptingProvider;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDataSetEvents))
    // creation/destruction
    CDataSetEvents(): _ulRefs(1) {}
    ~CDataSetEvents();
    HRESULT Init(CDataMemberMgr *pDMembMgr, IRowset *pRowset, IRowPosition *pRowPos,
                    CAdaptingProvider *pProvider);
    HRESULT Detach();

    // watch out for callback on wrong thread
    HRESULT CheckCallbackThread();
    
    // IRowPositionChanged methods
    STDMETHODIMP OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase,
                                BOOL fCantDeny);

    //  IDBAsynchNotify methods
    virtual HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DB_DWRESERVE dwReserved);
        
    virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE ulStatusCode,
            /* [in] */ LPOLESTR pwszStatusText);
        
    virtual HRESULT STDMETHODCALLTYPE OnStop( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText);

    // IRowsetNotify methods
    virtual HRESULT STDMETHODCALLTYPE OnFieldChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ HROW hRow,
        /* [in] */ DBORDINAL cColumns,
        /* [size_is][in] */ DBORDINAL rgColumns[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny);
    
    virtual HRESULT STDMETHODCALLTYPE OnRowChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBCOUNTITEM cRows,
        /* [size_is][in] */ const HROW rghRows[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny);
    
    virtual HRESULT STDMETHODCALLTYPE OnRowsetChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny);

    // IUnknown methods
    STDMETHODIMP_(ULONG)    AddRef() { return ++_ulRefs; }
    STDMETHODIMP_(ULONG)    Release();
    STDMETHODIMP            QueryInterface(REFIID riid, void **ppv);

    // accessors
    CDataMemberMgr *  GetDataMemberManager() const { return _pDMembMgr; }
    CElement *      GetOwner() { Assert(_pDMembMgr); return _pDMembMgr->GetOwner(); }
    CDoc *          Doc();
    
private:
    HRESULT Fire_ondatasetcomplete(long lReason);
    ULONG           _ulRefs;            // reference count
    CDataMemberMgr  *_pDMembMgr;        // my data manager.  Fire events on its owner.
    IRowset         *_pRowset;          // the Rowset I'm listening to
    IRowPosition    *_pRowPos;          // the RowPosition I'm listening to
    IConnectionPoint *_pCPRowPos;       // Connection point for listening on RowPos
    IConnectionPoint *_pCPDBAsynch;       // Connection point for listening on Rowset
    IConnectionPoint *_pCPRowset;       // Connection point for listening on Rowset
    DWORD           _dwAdviseCookieRowPos; // saved from Advise, so I can Unadvise
    DWORD           _dwAdviseCookieDBAsynch; // saved from Advise, so I can Unadvise
    DWORD           _dwAdviseCookieRowset; // saved from Advise, so I can Unadvise
    CAdaptingProvider *_pProvider;      // the provider who owns me
    const HROW      *_rghRows;          // HROWs affected by change
    DBCOUNTITEM     _cRows;             // number of HROWs affected by change
    DBORDINAL      *_rgColumns;        // columns affected by change
    DBORDINAL       _cColumns;          // number of columns affected by change
    unsigned        _fCompleteFired:1;  // iff ondatasetcomplete already fired

    void SetEventData(const HROW *rghRows, DBCOUNTITEM cRows,
                      DBORDINAL *rgColumns, DBORDINAL cColumns)
    {
        _rghRows = rghRows;
        _cRows = cRows;
        _rgColumns = rgColumns;
        _cColumns = cColumns;
    }
    void SetEventData(const HROW *rghRows, DBCOUNTITEM cRows)
    {
        _rghRows = rghRows;
        _cRows = cRows;
    }
    void ClearEventData()
    {
        _rghRows = NULL;
        _cRows = 0;
        _rgColumns = NULL;
        _cColumns = 0;
    }
};


/////-------------------------------------------------------------------/////
/////                        Adapting provider                          /////
///// This abstract class is the base class for many of the concrete    /////
///// providers defined below.  It provides common behavior (code       /////
///// sharing), principally the management of interface adapters.       /////
/////-------------------------------------------------------------------/////

class CAdaptingProvider: public CDataSourceProvider
{
    typedef CDataSourceProvider super;
    friend class CDataSetEvents;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CAdaptingProvider))
    CAdaptingProvider() :
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
        {}
    virtual ~CAdaptingProvider() { ReleaseAll(); }
    virtual void    Detach();
    virtual HRESULT QueryDataInterface(REFIID riid, void **ppv);
    virtual HRESULT ReplaceProvider(CDataSourceProvider *pdspNewProvider);
    virtual HRESULT Stop();
    virtual CXferThunk* GetXT(LPCTSTR strColumn, CVarType vtDest);

    // hierarchy
    virtual HRESULT GetSubProvider(CDataSourceProvider **ppdsp,
                        LPCTSTR bstrName, HROW hrow=0);
    virtual HCHAPTER GetChapter() { return _hChapter; }
    BOOL    IsTopLevel() const { return (_pProviderParent == NULL); }
    HRESULT ChangeChapter(HCHAPTER hChapterNew, HROW hRowNew);

    // events
    virtual HRESULT FireDataEvent(const PROPERTYDESC_BASIC *pDesc,
                            BOOL *pfCancelable = NULL,
                            long lReason = 0);
    virtual HRESULT FireDelayedRowEnter();
    virtual HRESULT get_bookmarks(IHTMLBookmarkCollection* *);
    virtual HRESULT get_recordset(IDispatch* *);
    virtual HRESULT get_dataFld(BSTR *);
    
    // helpers for plugging in interface adapters
    HRESULT AdaptRowsetOnRowPosition(IRowset** ppRowset, IRowPosition *pRowPos);
    HRESULT AdaptRowsetOnSTD(IRowset** ppRowset, OLEDBSimpleProvider *pSTD);
    HRESULT AdaptCursorOnRowset(ICursor** ppCursor, IRowset *pRowset);
    HRESULT AdaptCursorOnRowPosition(ICursor** ppCursor, IRowPosition *pRowPos);
    HRESULT AdaptRowPositionOnRowset(IRowPosition** ppRowPos, IRowset *pRowset);
    HRESULT AdaptADOOnRowset(IADORecordset** ppADO, IRowset *pRowset);
    HRESULT AdaptADOOnRowPos(IADORecordset** ppADO, IRowPosition *pRowPos);
    HRESULT AdaptRowsetOnCursor(IRowset** ppRowset, ICursor *pCursor);

    // initialization
    HRESULT Init(CDataMemberMgr *pdmm, HCHAPTER hChapter=DB_NULL_HCHAPTER,
                 CAdaptingProvider *pProviderParent=NULL)
    {
        HRESULT hr;

        _pDoc = pdmm->Doc();
        _pMarkup = pdmm->GetOwner()->GetMarkup();
        _hChapter = hChapter;
        _pProviderParent = pProviderParent;

        // if I'm tied to a chapter, addref it
        if (_hChapter != DB_NULL_HCHAPTER && EnsureRowset())
        {
            IChapteredRowset *pChapRowset = NULL;

            if (S_OK == _pRowset->QueryInterface(IID_IChapteredRowset,
                        reinterpret_cast<void**>(&pChapRowset)))
            {
                IGNORE_HR(pChapRowset->AddRefChapter(_hChapter, NULL));
            }

            ReleaseInterface(pChapRowset);
        }

        // We're about to do things that fire events.  The event handlers
        // might run script that destroys the provider (e.g. ondatasetcomplete
        // handler resets the DSO's URL or query as in bug 57231).  So
        // stabilize to avoid dying during this kind of reentrancy.

        AddRef();
        
        // The order of the next three lines is critical.  We must ensure
        // the CRI before hooking up notifications, because SetRowChangedEventTarget
        // can (and often does) fire ondatasetchanged and ondatasetcomplete.
        // If the handlers for these events touch the rowset and cause
        // IRowsetNotify notificaitons, we need the DLCursor in place, and it's
        // owned by the CRI.  (See bug 59405.)
        //
        // However, we also need to hook up notifications before setting the
        // initial position of the CRI.  This is because setting CRI position
        // causes onrowenter to fire, and it's the CDataSetEvents that does
        // the firing.  (See bug 58708.)
        
        // always hook up CRI, so that we get the "adjust current record after
        // it's deleted" effect, even if there are no current-record-bound elements.
        EnsureCRI();

        // listen for notifications
        hr = SetRowChangedEventTarget(pdmm);

        // set the CRI to its initial position
        if (_pCRI)
            _pMarkup->GetDataBindTask()->InitCurrentRecord(_pCRI);

        Release();
        return hr;
    }

    // create from IRowPosition
    CAdaptingProvider(IRowPosition *pRowPos, HROW hrow): _pRowPos(pRowPos),
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        _pRowPos->AddRef();
        _fNeedRowEnter =  (hrow != DB_NULL_HROW);
    }

    // create from IRowset
    CAdaptingProvider(IRowset *pRowset): _pRowset(pRowset),
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        _pRowset->AddRef();
    }

    // create from ISimpleTabularData
    CAdaptingProvider(OLEDBSimpleProvider *pSTD): _pSTD(pSTD),
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        _pSTD->AddRef();
    }

    // create from IVDBDC (ICursor generator)
    CAdaptingProvider(IVBDSC *pVBDSC) :
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        IGNORE_HR(pVBDSC->CreateCursor(&_pCursor));
    }

protected:
    CDataSetEvents      *_pRowEvents; // sink for RowChanged events
    OLEDBSimpleProvider *_pSTD;     // ISTD interface
    IRowset             *_pRowset;  // IRowset interface
    IRowPosition        *_pRowPos;  // IRowPosition interface
    ICursor             *_pCursor;  // ICursor interface
    IADORecordset       *_pADO;     // ADO interface
    CCurrentRecordInstance  *_pCRI; // Current record interface
    CAdaptingProvider   *_pProviderParent;  // my parent provider (hierarchy)
    ISimpleDataConverter *_pSDC;    // DSO's simple data converter (if any)

    struct CXTRecord {          // map <field, type> to <XT>
        BSTR                bstrField;
        CVarType            vtDest;
        CXferThunk *        pXT;
    };

    // support for hierarchical rowsets
    struct CChapterRecord {     // map <hrow, field> to <chapter>
        HROW                hrow;
        BSTR                bstrField;
        HCHAPTER            hChapter;
    };
    
    struct CProviderRecord {    // map <field, chapter> to <provider>
        BSTR                bstrField;
        HCHAPTER            hChapter;
        CDataSourceProvider *pdsp;
    };

    struct CAccessorRecord {    // map <field> to <accessor, rowset>
        BSTR        bstrField;
        HACCESSOR   hAccessor;
        IRowset *   pRowset;
        DBORDINAL   ulOrdinal;  // internal use only
    };

    CDataAry<CXTRecord>         _aryXT;
    CDataAry<CChapterRecord>    _aryCR;
    CDataAry<CProviderRecord>   _aryPR;
    CDataAry<CAccessorRecord>   _aryAR;
    HCHAPTER                    _hChapter;  // restrict to this chapter
    
    unsigned        _fNeedRowEnter:1;   // iff we need to fire onrowenter
    unsigned        _fRowEnterOK:1;     // iff we can fire onrowenter now

    // hierarchy methods
    HRESULT GetChapterFromField(HROW hrow, BSTR bstrField, HCHAPTER *phChapter);
    HRESULT GetProviderFromField(BSTR bstrField, HROW hrow,
                                CDataSourceProvider **ppdsp);
    HRESULT GetAccessorAndRowsetForField(BSTR bstrField,
                                HACCESSOR *phAccessor, IRowset **ppRowset);
    HRESULT GetAccessorForField(BSTR bstrField, HACCESSOR *phAccessor)
            { return GetAccessorAndRowsetForField(bstrField, phAccessor, NULL); }
    HRESULT GetRowsetForField(BSTR bstrField, IRowset **ppRowset)
            { return GetAccessorAndRowsetForField(bstrField, NULL, ppRowset); }
    HRESULT InitializeProviderRecord(CProviderRecord *pPR,
                        HCHAPTER hChapter, BSTR bstrField);
    HRESULT InitializeAccessorRecord(CAccessorRecord *pAR, BSTR bstrField);
    BOOL    EnsureAccessorInAccessorRecord(CAccessorRecord *pAR);
    BOOL    EnsureRowsetInAccessorRecord(CAccessorRecord *pAR);
    static HRESULT CreateSubProvider(CAdaptingProvider *pProviderParent,
                                    IRowset *pChildRowset, IRowPosition *pChildRowPos,
                                    CDataMemberMgr *pdmm,
                                    HCHAPTER hChapter, HROW hrow,
                                    CDataSourceProvider **ppdsp);
    void    RemoveSubProvider(CDataSourceProvider *pdsp);
    HRESULT UpdateProviderRecords(HCHAPTER hChapterOld, CDataSourceProvider *pdspOld,
                                HCHAPTER hChapterNew, CDataSourceProvider *pdspNew);
    
    // helper methods
    HRESULT SetRowChangedEventTarget(CDataMemberMgr *pdmm);
    void    ReleaseAll();
    CDataLayerCursor * GetDLCursor() { return _pCRI ? _pCRI->GetDLCursor() : NULL; }
    BOOL    IsSameRow(HROW hrow1, HROW hrow2)
                { return GetDLCursor()->IsSameRow(hrow1, hrow2); }
private:
    // helper methods to generate adapters, if necessary
    BOOL    EnsureSTD();
    BOOL    EnsureRowset();
    BOOL    EnsureRowsetPosition();
    BOOL    EnsureCursor();
    BOOL    EnsureADO();
    BOOL    EnsureCRI();
};


inline CDoc *
CDataSetEvents::Doc()  { Assert(_pDMembMgr); return _pDMembMgr->Doc(); }

//+-------------------------------------------------------------------------
// Member:      Init (CDataSetEvents, public)
//
// Synopsis:    listen to the given IRowPosition, and remember the OleSite

HRESULT
CDataSetEvents::Init(CDataMemberMgr *pdmm, IRowset *pRowset, IRowPosition *pRowPos,
                    CAdaptingProvider *pProvider)
{
    Assert(pdmm && pProvider);

    HRESULT hr = S_OK, hrFire = S_OK;
    IConnectionPointContainer *pCPC = 0;
    
    _pProvider = pProvider;

    // We can be called with a NULL pRowPos, but not with a NULL pRowset.
    Assert(pRowset);

    // hold on to the RowSet (let go in Detach)
    _pRowset = pRowset;
    _pRowset->AddRef();

    // hold on to the data member manager
    _pDMembMgr = pdmm;
    _pDMembMgr->AddRef();

    // sink notifications from the RowPosition, if we have one
    if (pRowPos)
    {
        // hold on to the RowPosition (let go in Detach)
        _pRowPos = pRowPos;
        _pRowPos->AddRef();

        if (S_OK == _pRowPos->QueryInterface(IID_IConnectionPointContainer,
                                           (void **)&pCPC )
           &&
           S_OK == pCPC->FindConnectionPoint(IID_IRowPositionChange, &_pCPRowPos))
        {
            if (FAILED(_pCPRowPos->Advise((IRowPositionChange *)this, &_dwAdviseCookieRowPos)))
                ClearInterface(&_pCPRowPos);
        }
    }

    ClearInterface(&pCPC);             // re-use connection point container

    // We fire the script event from all the way down here, because
    // if we waited until after we hooked up the Rowset event sink,
    // the Rowset might cause ondataavailable or ondatasetcomplete
    // to be fired before we fired datasetchanged.

    // Fire datasetchanged to tell script code we just got a new
    // dataset.  Note this fires for the initial dataset and for
    // any subsequent datasets.
    if (_pProvider->IsTopLevel())
    {
        hrFire = pProvider->FireDataEvent(&s_propdescCElementondatasetchanged);
    }

    // sink notifications from the Rowset
    if (S_OK == pRowset->QueryInterface(IID_IConnectionPointContainer,
                                        (void **)&pCPC ))
    {
        if (S_OK == pCPC->FindConnectionPoint(IID_IDBAsynchNotify, &_pCPDBAsynch))
        {
            if (FAILED(_pCPDBAsynch->Advise((IDBAsynchNotify *)this, &_dwAdviseCookieDBAsynch)))
            {
                ClearInterface(&_pCPDBAsynch);
            }
        }
        
        if (S_OK == pCPC->FindConnectionPoint(IID_IRowsetNotify, &_pCPRowset))
        {
            if (FAILED(_pCPRowset->Advise((IRowsetNotify *)this, &_dwAdviseCookieRowset)))
            {
                ClearInterface(&_pCPRowset);
            }
        }
    }

    // The Rowset may or may not have fired IDBAsynchNotify::OnStop, during,
    // or since, our Advise call.  If it did, we're done.  If not, then we
    // want to ask the rowset if it was complete, in which case we can fire
    // it for it.
    if (!_fCompleteFired)
    {
        DBASYNCHPHASE ulStatusCode = DBASYNCHPHASE_COMPLETE;
        IDBAsynchStatus *pAsynchStatus;
        DBCOUNTITEM ulProgress, ulProgressMax;

        if (_pRowset &&
            S_OK == _pRowset->QueryInterface(IID_IDBAsynchStatus,
                                             (void **)&pAsynchStatus))
        {
            // Get the Rowset's ulStatusCode
            // (We don't care about ulProgress & ulProgressMax, but I was afraid
            // some OLE-DB providers might crash if we passed in NULL).
            pAsynchStatus->GetStatus(_pProvider->GetChapter(), DBASYNCHOP_OPEN,
                                     &ulProgress, &ulProgressMax,
                                     &ulStatusCode, NULL);

            ClearInterface(&pAsynchStatus);
        }

        if (DBASYNCHPHASE_COMPLETE == ulStatusCode)
        {
            hr = Fire_ondatasetcomplete(0);
        }
    }

    ClearInterface(&pCPC);

    // If we got no other errors, but the Fire OnDataSetChanged event returned
    // an hr, then use that for our hr.  It probably means some script
    // code triggered an ondatasetchanged event in inside the ondatasetchanged
    // handler, and blew the stack.  Checking this hr should stop it.
    if (S_OK == hr)
        hr = hrFire;

    return hr;
}


//+-------------------------------------------------------------------------
// Member:      destructor (CDataSetEvents, public)
//
// Synopsis:    stop listening to my RowPosition, release my OleSite

CDataSetEvents::~CDataSetEvents()
{
    // let go of my data member manager
    if (_pDMembMgr)
    {
        _pDMembMgr->Release();
        _pDMembMgr = NULL;
    }
}


//+-------------------------------------------------------------------------
// Member:      Detach (CDataSetEvents, public)
//
// Synopsis:    stop listening to my RowPosition, release my OleSite

HRESULT
CDataSetEvents::Detach()
{
    HRESULT hr = S_OK;

    // stop listening for events
    if (_pCPRowPos)
    {
        IGNORE_HR(_pCPRowPos->Unadvise(_dwAdviseCookieRowPos));
        ClearInterface(&_pCPRowPos);
    }

    // stop listening for events
    if (_pCPDBAsynch)
    {
        IGNORE_HR(_pCPDBAsynch->Unadvise(_dwAdviseCookieDBAsynch));
        ClearInterface(&_pCPDBAsynch);
    }
    if (_pCPRowset)
    {
        IGNORE_HR(_pCPRowset->Unadvise(_dwAdviseCookieRowset));
        ClearInterface(&_pCPRowset);
    }

    // let go of the Rowset
    ClearInterface(&_pRowset);    
    
    // let go of the RowPosition
    ClearInterface(&_pRowPos);

    // let go of my provider
    if (_pProvider)
    {
        _pProvider = NULL;
    }
    
    return hr;
}



//+-------------------------------------------------------------------------
// Member:      OnRowPositionChange (IRowPositionChange, public)
//
// Synopsis:    translate IRowPosition notifications into
//              onRowExit/Enter events on my OLE site.

HRESULT
CDataSetEvents::OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase,
                                        BOOL fCantDeny)
{
    HCHAPTER hchapter = DB_NULL_HCHAPTER;
    HROW hrow = DB_NULL_HROW;
    DBPOSITIONFLAGS dwPositionFlags;
    HRESULT hr = CheckCallbackThread();
    BOOL fCancelled;

    _pProvider->AddRef();               // stabilize

    if (hr)
        goto Cleanup;

    switch (ePhase)
    {
    case DBEVENTPHASE_ABOUTTODO:        // position is changing, fire onRowExit
        _pRowPos->GetRowPosition(&hchapter, &hrow, &dwPositionFlags);
        if (hrow != DB_NULL_HROW)
        {
            TraceTag((tagRowEvents, "%p -> onRowExit", _pDMembMgr->GetOwner()));
            
            _pProvider->FireDataEvent(&s_propdescCElementonrowexit, &fCancelled);
            if (fCancelled)
            {
                hr = S_FALSE;
            }
        }
        break;
        
    case DBEVENTPHASE_SYNCHAFTER:
        switch (eReason)
        {
        case DBREASON_ROWPOSITION_CHAPTERCHANGED:
            // the provider is effectively a tearoff rowset on a specific
            // chapter, so when the chapter changes we need to replace
            // the provider
            Assert(_pProvider);
            _pRowPos->GetRowPosition(&hchapter, &hrow, &dwPositionFlags);
            IGNORE_HR(_pProvider->ChangeChapter(hchapter, hrow));
            break;

        default:
            break;
        }
        break;
    
    case DBEVENTPHASE_DIDEVENT:         // position changed, fire onRowEnter
        switch (eReason)
        {
        case DBREASON_ROWPOSITION_CHANGED:
            if (_pProvider->_fRowEnterOK)
            {
                TraceTag((tagRowEvents, "%p -> onRowEnter", _pDMembMgr->GetOwner()));
                _pProvider->FireDataEvent(&s_propdescCElementonrowenter);
            }
            else
            {
                _pProvider->_fNeedRowEnter = TRUE;
            }
            break;

        default:
            break;
        }
        break;
    }
    
Cleanup:
    // if we acquired an hrow or hchapter from the row position, release it now
    ReleaseChapterAndRow(hchapter, hrow, _pRowPos);
    
    _pProvider->Release();
    
    RRETURN1(hr, S_FALSE);
}

//  IDBAsynchNotify methods
HRESULT STDMETHODCALLTYPE
CDataSetEvents::OnLowResource( 
            /* [in] */ DB_DWRESERVE dwReserved)
{
    return E_NOTIMPL;
}

HRESULT
CDataSetEvents::Fire_ondatasetcomplete(long lReason)
{
    HRESULT hr = S_OK;
    if (_pProvider && !_fCompleteFired)
    {
        _fCompleteFired = TRUE;

        // only fire for top-level provider
        if (_pProvider->IsTopLevel())
        {
            hr = _pProvider->FireDataEvent(&s_propdescCElementondatasetcomplete,
                                        NULL, lReason);
        }
    }    
    return hr;
}

HRESULT STDMETHODCALLTYPE
CDataSetEvents::OnProgress( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE ulStatusCode,
            /* [in] */ LPOLESTR pwszStatusText)
{
    HRESULT hr = CheckCallbackThread();
 
    if (hr)
        goto Cleanup;
        
    if (_pProvider && ulStatusCode==DBASYNCHPHASE_POPULATION && !_fCompleteFired)
    {
        // good place to fire script event
        hr = _pProvider->FireDataEvent(&s_propdescCElementondataavailable);
    }

Cleanup:
    return S_OK;                        // only allowed OLEDB return here
 }

STDMETHODIMP
CDataSetEvents:: OnStop( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ ULONG ulOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText)
{
    long lReason;
    HRESULT hr = CheckCallbackThread();

    if (hr)
        goto Cleanup;
        

    switch (hrStatus)
    {
        case DB_E_CANCELED:
            lReason = 1;                // Abort
            break;

        case E_FAIL:
            lReason = 2;                // Error
            break;

        case S_OK:
        default:
            lReason = 0;
            break;
    }

    Fire_ondatasetcomplete(lReason);

Cleanup:
    RRETURN(hr);
}


// IRowsetNotify methods

STDMETHODIMP
CDataSetEvents::OnFieldChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ HROW hRow,
        /* [in] */ DBORDINAL cColumns,
        /* [size_is][in] */ DBORDINAL rgColumns[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny)
{
    HRESULT hr;
    CDataLayerCursor *pDLC;

    switch (eReason)
    {
    case DBREASON_COLUMN_SET:
        switch (ePhase)
        {
        case DBEVENTPHASE_ABOUTTODO:
            // first make sure the row belongs to my chapter
            pDLC = _pProvider->GetDLCursor();
            if (pDLC)
            {
                DBROWCOUNT cRowsGood;
                const HROW *pRowsGood;

                hr = pDLC->FilterRowsToChapter(1, &hRow,
                                                    &cRowsGood, &pRowsGood);
                if (!hr && cRowsGood != 0)
                {
                    Assert(pRowsGood == &hRow); // no allocation for only one row
                    SetEventData(&hRow, 1, rgColumns, cColumns);
                    
                    _pProvider->FireDataEvent(&s_propdescCElementoncellchange);

                    ClearEventData();
                }
             }
            hr = S_OK;
            break;

        default:
            hr = DB_S_UNWANTEDPHASE;
            break;
        }
        break;

    default:
        hr = DB_S_UNWANTEDREASON;
        break;
    }
    
    return hr;
}

    
STDMETHODIMP
CDataSetEvents::OnRowChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBCOUNTITEM cRows,
        /* [size_is][in] */ const HROW rghRows[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny)
{
    HRESULT hr = S_OK;
    DBROWCOUNT cRowsGood;
    const HROW *pRowsGood = rghRows;

    // ignore rows that don't belong to my chapter
    CDataLayerCursor *pDLC = _pProvider->GetDLCursor();
    if (!pDLC)
        goto Cleanup;
    hr = pDLC->FilterRowsToChapter(cRows, rghRows, &cRowsGood, &pRowsGood);
    if (hr || cRowsGood == 0)
        goto Cleanup;

    switch (eReason)
    {
    case DBREASON_ROW_DELETE:
    case DBREASON_ROW_UNDOINSERT:
        switch (ePhase)
        {
        case DBEVENTPHASE_ABOUTTODO:
            SetEventData(pRowsGood, cRowsGood);
            
            _pProvider->FireDataEvent(&s_propdescCElementonrowsdelete);

            ClearEventData();
            hr = S_OK;
            break;
        default:
            hr = DB_S_UNWANTEDPHASE;
            break;
        }
        break;
    
    case DBREASON_ROW_INSERT:
    case DBREASON_ROW_ASYNCHINSERT:
    case DBREASON_ROW_UNDODELETE:
        switch (ePhase)
        {
        case DBEVENTPHASE_DIDEVENT:
            SetEventData(pRowsGood, cRowsGood);
            
            _pProvider->FireDataEvent(&s_propdescCElementonrowsinserted);

            ClearEventData();
            hr = S_OK;
            break;
        default:
            hr = DB_S_UNWANTEDPHASE;
            break;
        }
        break;

    default:
        hr = DB_S_UNWANTEDREASON;
        break;
    }

Cleanup:
    if (pRowsGood != rghRows)
        delete const_cast<HROW *>(pRowsGood);
    
    return hr;
}

    
STDMETHODIMP
CDataSetEvents::OnRowsetChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny)
{
    return DB_S_UNWANTEDREASON;
}


HRESULT
CDataSetEvents::CheckCallbackThread()
{
    HRESULT hr = S_OK;

    if (_pDMembMgr
        && _pDMembMgr->Doc()
        && _pDMembMgr->Doc()->_dwTID != GetCurrentThreadId() )
    {
        Assert(!"OLEDB callback on wrong thread");
        hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, die if 0
//
// Returns:     new refcount

ULONG
CDataSetEvents::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
        delete this;
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      Query Interface (public, IUnknown)
//
// Synopsis:    return desired interface pointer
//
// Arguments:   riid        IID of desired interface
//              ppv         where to store the pointer
//
// Returns:     HRESULT

HRESULT
CDataSetEvents::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punkReturn = 0;

    // check for bad arguments
    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // look for interfaces I support
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // We inherit IUnknown from both IRowPositionChange & IDBAsynchNotify,
        // We can arbitrarily return the IUknown from one of them..
        punkReturn = (IRowPositionChange *)this;
    }
    else if (IsEqualIID(riid, IID_IRowPositionChange))
    {
        punkReturn = (IRowPositionChange *)this;
    }
    else if (IsEqualIID(riid, IID_IRowsetNotify))
    {
        punkReturn = (IRowsetNotify *)this;
    }
    else if (IsEqualIID(riid, IID_IDBAsynchNotify))
    {
        punkReturn = (IDBAsynchNotify *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }
    punkReturn->AddRef();          // return addref'd copy
    *ppv = punkReturn;
    hr = S_OK;

Cleanup:
    return hr;        
}


/////////////////////////////////////////////////////////////////////////////
/////                       Helper functions                            /////
/////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Function:    Adapt Rowset On RowPosition (static helper)
//
// Synopsis:    point pRowset at a rowset obtained from the RowPosition object.
//              If pRowset already points at an adapter, don't change it.
//
// Arguments:   ppRowset    [out] where to store adapter
//              pSTD        [in] pointer to ISTD

HRESULT
CAdaptingProvider::AdaptRowsetOnRowPosition(IRowset** ppRowset, IRowPosition *pRowPos)
{
    HRESULT hr = S_OK;
    Assert("RowPos expected" && pRowPos);

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;

    // get its IRowset interface
    hr = pRowPos->GetRowset(IID_IRowset, (IUnknown**)ppRowset);
    if (hr)
        goto Cleanup;
    Assert(*ppRowset);

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt Rowset On STD (static helper)
//
// Synopsis:    point pRowset at an object that adapts IRowset to OLEDBSimpleProvider.
//              If pRowset already points at an adapter, don't change it.
//
// Arguments:   ppRowset    [out] where to store adapter
//              pOSP        [in] pointer to OLEDBSimpleProvider

#if defined(USE_PW_DLL)
HRESULT
CAdaptingProvider::AdaptRowsetOnSTD(IRowset** ppRowset, OLEDBSimpleProvider *pOSP)
{
    HRESULT hr = S_OK;
    IUnknown *pUnkRowset = 0;
    Assert("OSP expected" && pOSP);
    static const CLSID clsidPW = {0xdfc8bdc0, 0xe378, 0x11d0, 0x9b, 0x30, 0x00, 0x80, 0xc7, 0xe9, 0xfe, 0x95};
    static const GUID DBPROPSET_PWROWSET = {0xe6e478db,0xf226,0x11d0,{0x94,0xee,0x0,0xc0,0x4f,0xb6,0x6a,0x50}};
    const DWORD PWPROP_OSPVALUE = 2;
    DBID dbidTable;
    DBPROPSET rgdbpropset[1];
    DBPROP rgprop[1];
    IDBInitialize *pIDBInitialize = NULL;
    IDBCreateSession *pIDBCreateSession = NULL;
    IOpenRowset *pIOpenRowset = NULL;

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;

    // Instantiate the OSP->Rowset adapter
    hr = CoCreateInstance(clsidPW,
                            NULL,
                            CLSCTX_ALL,
                            IID_IDBInitialize,
                            (void **)&pIDBInitialize);
    if (hr)
        goto Cleanup;

    hr = pIDBInitialize->Initialize();
    if (hr)
        goto Cleanup;

    hr = pIDBInitialize->QueryInterface(IID_IDBCreateSession,
                                        (void **)&pIDBCreateSession);
    if (hr)
        goto Cleanup;

    hr = pIDBCreateSession->CreateSession(NULL, IID_IOpenRowset,
                                            (IUnknown **)&pIOpenRowset);
    if (hr)
        goto Cleanup;

    // Set OSPVALUE property
    rgdbpropset[0].guidPropertySet = DBPROPSET_PWROWSET;
    rgdbpropset[0].cProperties = 1;
    rgdbpropset[0].rgProperties = &rgprop[0];

    rgprop[0].dwPropertyID = PWPROP_OSPVALUE;
    rgprop[0].dwOptions = DBPROPOPTIONS_REQUIRED;
    rgprop[0].dwStatus = DBPROPSTATUS_OK;
    // rgprop[0].colid = DB_NULLID;
    memset(&rgprop[0].colid, 0, sizeof(rgprop[0].colid));
    VariantInit(&(rgprop[0].vValue));
    V_VT(&(rgprop[0].vValue)) = VT_UNKNOWN;
    V_UNKNOWN(&(rgprop[0].vValue)) = (IUnknown *)pOSP;

    dbidTable.eKind = DBKIND_NAME;
    dbidTable.uName.pwszName = NULL;

    hr = pIOpenRowset->OpenRowset(NULL,
                                    &dbidTable,
                                    NULL,
                                    IID_IRowset,
                                    1,
                                    rgdbpropset,
                                    (IUnknown **)ppRowset);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIDBInitialize);
    ReleaseInterface(pIDBCreateSession);
    ReleaseInterface(pIOpenRowset);

    return hr;
}
#else // USE_PW_DLL
HRESULT
CAdaptingProvider::AdaptRowsetOnSTD(IRowset** ppRowset, OLEDBSimpleProvider *pOSP)
{
    HRESULT hr = S_OK;
    IUnknown *pUnkRowset = 0;
    Assert("OSP expected" && pOSP);

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;

    hr = CTopRowset::CreateRowset(pOSP, &pUnkRowset);
    if (hr)
        goto Cleanup;

    // get its IRowset interface
    hr = pUnkRowset->QueryInterface(IID_IRowset, (void**)ppRowset);
    if (hr)
        goto Cleanup;
    Assert(*ppRowset);

Cleanup:
    ReleaseInterface(pUnkRowset);
    return hr;
}
#endif USE_PW_DLL


//+-------------------------------------------------------------------------
// Function:    Adapt Cursor On Rowset (static helper)
//
// Synopsis:    point pCursor at an object that adapts ICursor to IRowset.
//              If pCursor already points at an adapter, don't change it.
//
// Arguments:   ppCursor    [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptCursorOnRowset(ICursor** ppCursor, IRowset *pRowset)
{
    HRESULT hr = S_OK;
    Assert("rowset expected" && pRowset);
    ICursorFromRowset *pIcfr = 0;

    // if adapter already exists, nothing to do
    if (*ppCursor)
        goto Cleanup;

    // create an adapter
    hr = CoCreateInstance(CLSID_CCursorFromRowset, NULL,
                          CLSCTX_INPROC, IID_ICursorFromRowset,
                          (void **)&pIcfr);
    if (hr) 
        goto Cleanup;
        
    // get its ICursor interface
    hr = THR(pIcfr->GetCursor(pRowset, ppCursor, g_lcidUserDefault));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIcfr);
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt Cursor On Row Position (static helper)
//
// Synopsis:    point pCursor at an object that adapts ICursor to IRowset.
//              If pCursor already points at an adapter, don't change it.
//
// Arguments:   ppCursor    [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptCursorOnRowPosition(ICursor** ppCursor, IRowPosition *pRowPos)
{
    HRESULT hr = S_OK;
#ifdef VD_INCLUDE_ROWPOSITION
    Assert("rowposition expected" && pRowPos);
    ICursorFromRowPosition *pIcfr = 0;

    // if adapter already exists, nothing to do
    if (*ppCursor)
        goto Cleanup;

    // create an adapter
    hr = CoCreateInstance(CLSID_CCursorFromRowset, NULL,
                          CLSCTX_INPROC, IID_ICursorFromRowPosition,
                          (void **)&pIcfr);
    if (hr) 
        goto Cleanup;
        
    // get its ICursor interface
    hr = THR(pIcfr->GetCursor(pRowPos, ppCursor, g_lcidUserDefault));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIcfr);
#endif // VD_INCLUDE_ROWPOSITION
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    SetADOClientSite (static)
//
// Synopsis:    Tell ADO to use the given client site
//
// Arguments:   pADO            ADO object
//              pClientSite     client site
//
// Returns:     HRESULT

static HRESULT
SetADOClientSite(IADORecordset *pADO, IOleClientSite *pClientSite)
{
    HRESULT hr;
    IObjectWithSite *pObjSite = NULL;

    Assert(pADO);
    hr = pADO->QueryInterface(IID_IObjectWithSite, (void **)&pObjSite);
    if (OK(hr) && pObjSite)
    {
        hr = pObjSite->SetSite(pClientSite);
        ReleaseInterface(pObjSite);
        goto Cleanup;
    }
    hr = S_OK;
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Function:    GetADOConstructor (static helper)
//
// Synopsis:    point pADO at an object that adapts IADORecordset to IRowset.
//              point pADOConstructor at its constructor interface
//
// Arguments:   ppADO               [out] where to store adapter
//              ppADOConstructor    [out] where to store constructor

static HRESULT
GetADOConstructor(IADORecordset **ppADO,
                  IADORecordsetConstruction **ppADOConstructor,
                  CDataSourceProvider *pProvider)
{
    HRESULT hr;
    IADOSecurity *pADOSecurity = NULL;
    IADORecordset *pADO = NULL;
    IObjectSafety *pObjSafety = NULL;
    static const IID IID_IADOSecurity = {0x782d16ae, 0x905f, 0x11d1, 0xac, 0x38, 0x0, 0xc0, 0x4f, 0xc2, 0x9f, 0x8f};
    
    // create an adapter
    hr = CoCreateInstance(CLSID_CADORecordset, NULL,
                          CLSCTX_INPROC, IID_IADORecordset15,
                          (void **)&pADO);
    if (hr) 
        goto Cleanup;

    Assert(pProvider);
    if (pProvider == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // tell it to act safely
    // ADO 2.1 uses ClientSite / ObjectSafety.  Try that first.
    
    // give ADO a client site, so it can post security dialogs
    hr = SetADOClientSite(pADO, (IOleClientSite*) (pProvider->ADOClientSite()));

    // now tell it to act safely
    if (!hr)
        hr = pADO->QueryInterface(IID_IObjectSafety, (void**)&pObjSafety);
    if (!hr && pObjSafety)
    {
        // make it safe to init on IPersistPropertyBag
        IGNORE_HR(pObjSafety->SetInterfaceSafetyOptions(IID_IPersistPropertyBag,
                            INTERFACESAFE_FOR_UNTRUSTED_DATA,
                            INTERFACESAFE_FOR_UNTRUSTED_DATA));

        // make it safe to script on IDispatchEx or IDispatch
        hr = pObjSafety->SetInterfaceSafetyOptions(IID_IDispatchEx,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER);
        if (hr)
            hr = pObjSafety->SetInterfaceSafetyOptions(IID_IDispatch,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER);

        ReleaseInterface(pObjSafety);

        hr = S_OK;      // we tried our best.  If that failed, just carry on.
    }

    // If that didn't work, maybe it's because ADO 1.5 is installed.
    // So try the old private interface approach.
    if (hr && S_OK == pADO->QueryInterface(IID_IADOSecurity, (void**)&pADOSecurity))
    {
        BSTR bstrURL = NULL;

        hr = pADOSecurity->SetSafe(TRUE);
        
        if (!hr)
            hr = pProvider->Doc()->_pWindowPrimary->Document()->get_URL(&bstrURL);
        if (!hr)
            hr = pADOSecurity->SetURL(bstrURL);

        FormsFreeString(bstrURL);
        ReleaseInterface(pADOSecurity);

        if (hr)
        {
            ReleaseInterface(pADO);
            goto Cleanup;
        }
    }

    *ppADO = pADO;
    
    // get its IADORecordsetConstruction interface
    hr = pADO->QueryInterface(IID_IADORecordsetConstruction,
                                (void **)ppADOConstructor);

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt ADO On Rowset (static helper)
//
// Synopsis:    point pADO at an object that adapts IADORecordset to IRowset.
//              If pADO already points at an adapter, don't change it.
//
// Arguments:   ppADO       [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptADOOnRowset(IADORecordset** ppADO, IRowset *pRowset)
{
    HRESULT hr = S_OK;
    IADORecordset *pADO = 0;
    IADORecordsetConstruction *pAdoConstructor = 0;
    Assert("rowset expected" && pRowset);
    
    // if adapter already exists, nothing to do
    if (*ppADO)
        goto Cleanup;

    // create an adapter
    hr = GetADOConstructor(&pADO, &pAdoConstructor, this);
    if (hr)
        goto Cleanup;

    // return addref'd result to caller
    pADO->AddRef();
    *ppADO = pADO;
        
    // give it the rowset.  This may fire onrowenter, which might ask for
    // event.recordset, so we must set *ppADO first.
    hr = THR(pAdoConstructor->put_Rowset(pRowset));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pADO);
    ReleaseInterface(pAdoConstructor);
    return hr;
}

//+-------------------------------------------------------------------------
// Function:    Adapt ADO On RowPosition (static helper)
//
// Synopsis:    point pADO at an object that adapts IADORecordset to IRowset.
//              If pADO already points at an adapter, don't change it.
//
// Arguments:   ppADO       [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptADOOnRowPos(IADORecordset** ppADO, IRowPosition *pRowPos)
{
    HRESULT hr = S_OK;
    IADORecordset *pADO = 0;
    IADORecordsetConstruction *pAdoConstructor = 0;
    Assert("rowpos expected" && pRowPos);
    
    // if adapter already exists, nothing to do
    if (*ppADO)
        goto Cleanup;

    // create an adapter
    hr = GetADOConstructor(&pADO, &pAdoConstructor, this);
    if (hr)
        goto Cleanup;

    // return addref'd result to caller
    pADO->AddRef();
    *ppADO = pADO;
        
    // give it the row position.  This may fire onrowenter, which might ask for
    // event.recordset, so we must set *ppADO first.
    hr = THR(pAdoConstructor->put_RowPosition(pRowPos));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pADO);
    ReleaseInterface(pAdoConstructor);
    return hr;
}

EXTERN_C const CLSID CLSID_CRowPosition;

//+-------------------------------------------------------------------------
// Function:    Adapt RowPosition On Rowset (static helper)
//
// Synopsis:    point pRowPos at an object that adapts IRowPosition to IRowset.
//              If pRowPos already points at an adapter, don't change it.
//
// Arguments:   ppRowPos    [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptRowPositionOnRowset(IRowPosition** ppRowPos, IRowset *pRowset)
{
    IRowPosition *pRowPos = NULL;
    HRESULT hr = S_OK;
    Assert("rowset expected" && pRowset);
    
    // if adapter already exists, nothing to do
    if (*ppRowPos)
        goto Cleanup;

    // create an adapter
    hr = CoCreateInstance(CLSID_CRowPosition, NULL,
                          CLSCTX_INPROC, IID_IRowPosition,
                          (void **)&pRowPos);
    if (hr)
    {
#ifndef UNIX
        // Win32 doesn't have a built-in CRowPosition anymore
        goto Cleanup;
#else
        pRowPos = new CRowPosition();
        if (!pRowPos)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
#endif
    }


    hr = pRowPos->Initialize(pRowset);
    if (hr)
    {
        ReleaseInterface(pRowPos);
        goto Cleanup;
    }
        
Cleanup:
    if (!hr && pRowPos)
        *ppRowPos = pRowPos;
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt Rowset On Cursor (static helper)
//
// Synopsis:    point pRowset at an object that adapts IRowset to ICursor.
//              If pRowset already points at an adapter, don't change it.
//
// Arguments:   ppRowset    [out] where to store adapter
//              pCursor     [in] pointer to ICursor

HRESULT
CAdaptingProvider::AdaptRowsetOnCursor(IRowset** ppRowset, ICursor *pCursor)
{
    HRESULT hr = S_OK;
//    IRowsetFromCursor *pIrfc = 0;
    Assert("cursor expected" && pCursor);

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;
    
    // Disable Viaduct Phase I.  The Viaduct-I DLL uses OLE-DB M6.1, but
    // we're at M11.  So it would be a bad idea to hook up to it.
    // (Viaduct is never going to change - so don't ever change this.)
#if !defined(GetRidOfThisWhenViaductConvertsToOleDBM11)
    hr = E_NOTIMPL;
#else // Viaduct-I is enabled

    // create an adapter
    hr = CoCreateInstance(CLSID_CRowsetFromCursor, NULL,
                          CLSCTX_INPROC, IID_IRowsetFromCursor,
                          (void **)&pIrfc);
    if (hr) 
        goto Cleanup;
        
    // get its IRowset interface
    hr = THR(pIrfc->GetRowset(pCursor, ppRowset, g_lcidUserDefault));
#endif // disable Viaduct-I

Cleanup:
//     ReleaseInterface(pIrfc);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////                       Provider Classes                            /////
/////////////////////////////////////////////////////////////////////////////

/////-------------------------------------------------------------------/////
///// null provider.  Used when binding fails.  Always returns error.   /////
/////-------------------------------------------------------------------/////

class CNullProvider: public CDataSourceProvider
{
    typedef CDataSourceProvider super;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CNullProvider))
    CNullProvider(CDoc *pDoc): _pADO(0) { _pDoc = pDoc; }
    virtual ~CNullProvider();
    virtual HRESULT QueryDataInterface(REFIID riid, void **ppv);
    virtual HRESULT GetSubProvider(CDataSourceProvider **ppdsp,
                LPCTSTR bstrName, HROW hrow=0) { *ppdsp = this;  AddRef(); return S_OK; }
private:
    IADORecordset *_pADO;
};


//+-------------------------------------------------------------------------
// Member:      Query Data Interface (CNullProvider, public)
//
// Synopsis:    return addref'd interface pointer.  NullProvider supports
//              QDI for ADO, and returns an empty ADO;  this allows scripts
//              to limp along even when there's no real provider.
//              All other requests return E_NOINTERFACE.
//
//              ** The behavior described above also deprives script authors **
//              ** of a reasonable why of telling whether or not they have   **
//              ** a valid recordset, since foo.recordset == null will return**
//              ** false.  I'm going to try deprecating this and see what    **
//              ** happens -- cfranks 2 August 1997                          **
//
// Arguments:   riid        desired interface
//              ppvUnk      where to store interface pointer
//
// Returns:     HRESULT

HRESULT
CNullProvider::QueryDataInterface(REFIID riid, void **ppvUnk)
{
    HRESULT hr = E_NOINTERFACE;     // assume the worst

    if (IsEqualIID(riid, IID_IADORecordset15))
    {
        if (!_pADO)
        {
            IADORecordset *pADO;
            IADORecordsetConstruction *pADOC;

            hr = GetADOConstructor(&pADO, &pADOC, this);
            if (hr)
                goto Cleanup;

            _pADO = pADO;
            ReleaseInterface(pADOC);
        }

        if (_pADO)
        {
            _pADO->AddRef();
            *ppvUnk = _pADO;
            hr = S_OK;
        }
    }
Cleanup:

    return hr;
}


//+-------------------------------------------------------------------------
// Member:      destructor (CNullProvider, public)

CNullProvider::~CNullProvider()
{ 
    if (_pADO)
    {
        SetADOClientSite(_pADO, NULL);
        ReleaseInterface(_pADO);
    }
}


//+-------------------------------------------------------------------------
// Member:      Detach (CDataSourceProvider, public)
//
// Synopsis:    Detach my resources

void
CAdaptingProvider::Detach()
{
    super::Detach();
}


//+-------------------------------------------------------------------------
// Member:      SetRowChangedEventTarget (CAdaptingProvider, protected)
//
// Synopsis:    wire up a listener to my IRowPosition, so I can fire
//              onRowExit/Enter to the given OLE site, and wire up
//              a listener to my IDBAsynchNotify, so we can get transfer
//              notifications.

HRESULT
CAdaptingProvider::SetRowChangedEventTarget(CDataMemberMgr *pdmm)
{
    HRESULT hr = S_OK;
    Assert(pdmm);

    // cache the SimpleDataConverter, if any
    _pSDC = pdmm->GetSDC();
    if (_pSDC)
        _pSDC->AddRef();

    // Try to make sure we have both a row position & a rowset, but ultimately
    // proceed if we have either one.  (Note that Ensuring a RowsetPosition will
    // ensure a Rowset, but not visa versa so the order here is important.)
    if (EnsureRowsetPosition() || EnsureRowset())
    {
        _pRowEvents = new CDataSetEvents;
        if (_pRowEvents)
        {
            hr = _pRowEvents->Init(pdmm, _pRowset, _pRowPos, this);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
// Member:      ReleaseAll (CAdaptingProvider, protected)
//
// Synopsis:    release my resources

void
CAdaptingProvider::ReleaseAll()
{
    int i;
    CXTRecord       *pXR;
    CChapterRecord  *pCR;
    CProviderRecord *pPR;
    CAccessorRecord *pAR;
    CDataMemberMgr  *pdmm = NULL;
    
    if (_pRowEvents)
    {
        pdmm = _pRowEvents->GetDataMemberManager();
        if (pdmm)
        {
            pdmm->AddRef();       // keep control alive through shutdown
        }
        _pRowEvents->Detach();
    }
    ClearInterface((IUnknown**)&_pRowEvents);

    // release the XferThunk cache
    for (i=_aryXT.Size(), pXR=_aryXT;  i>0;  --i, ++pXR)
    {
        // release field name
        FormsFreeString(pXR->bstrField);

        // release XT
        if (pXR->pXT)
            pXR->pXT->Release();
    }
    _aryXT.DeleteAll();

    // release current record instance
    if (_pCRI)
        _pCRI->Detach();
    ClearInterface(&_pCRI);

    // release chapter table
    for (i=_aryCR.Size(), pCR=_aryCR;  i>0;  --i, ++pCR)
    {
        // release hrow
        Assert(_pRowset);
        IGNORE_HR(_pRowset->ReleaseRows(1, &pCR->hrow, NULL, NULL, NULL));

        // release field name
        FormsFreeString(pCR->bstrField);
    }
    _aryCR.DeleteAll();
    
    // release provider table
    for (i=_aryPR.Size(), pPR=_aryPR;  i>0;  --i, ++pPR)
    {
        FormsFreeString(pPR->bstrField);
        if (pPR->pdsp)
            pPR->pdsp->Release();
    }
    _aryPR.DeleteAll();

    // release accessor/rowset table
    if (_aryAR.Size() > 0)
    {
        IAccessor *pAccessor = NULL;

        Assert(_pRowset && "hierarchy without a rowset?");
        
        _pRowset->QueryInterface(IID_IAccessor, reinterpret_cast<void**>(&pAccessor));
            
        for (i=_aryAR.Size(), pAR=_aryAR;  i>0;  --i, ++pAR)
        {
            FormsFreeString(pAR->bstrField);
            if (pAccessor && pAR->hAccessor)
                pAccessor->ReleaseAccessor(pAR->hAccessor, NULL);

            ReleaseInterface(pAR->pRowset);
        }
        _aryAR.DeleteAll();

        ReleaseInterface(pAccessor);
    }

    if (_hChapter != DB_NULL_HCHAPTER)
    {
        Assert(_pRowset && "hierarchy without a rowset?");
        IChapteredRowset *pChapRowset = NULL;
        HRESULT hr = _pRowset->QueryInterface(IID_IChapteredRowset,
                        reinterpret_cast<void**>(&pChapRowset));

        if (!hr)
        {
            pChapRowset->ReleaseChapter(_hChapter, NULL);
        }

        _hChapter = DB_NULL_HCHAPTER;
        ReleaseInterface(pChapRowset);
    }

    if (_pADO)
        SetADOClientSite(_pADO, NULL);
    ClearInterface(&_pSDC);
    ClearInterface(&_pCursor);
    ClearInterface(&_pRowset);
    ClearInterface(&_pRowPos);
    ClearInterface(&_pSTD);
    ClearInterface(&_pADO);
    if (pdmm)
        pdmm->Release();
}


//+-------------------------------------------------------------------------
// Member:      Ensure STD (private)
//
// Synopsis:    Try to acquire a valid ISTD interface
//
// Arguments:   none
//
// Returns:     true    _pSTD is valid
//              false   _pSTD is invalid

BOOL
CAdaptingProvider::EnsureSTD()
{
    return !!_pSTD;
}


//+-------------------------------------------------------------------------
// Member:      Ensure Rowset (private)
//
// Synopsis:    Try to acquire a valid IRowset interface
//
// Arguments:   none
//
// Returns:     true    _pRowset is valid
//              false   _pRowset is invalid

BOOL
CAdaptingProvider::EnsureRowset()
{
    if (_pRowPos)
        AdaptRowsetOnRowPosition(&_pRowset, _pRowPos);
    else if (_pSTD)
        AdaptRowsetOnSTD(&_pRowset, _pSTD);
    else if (_pCursor)
        AdaptRowsetOnCursor(&_pRowset, _pCursor);
    return !!_pRowset;
}


//+-------------------------------------------------------------------------
// Member:      Ensure Rowset Position (private)
//
// Synopsis:    Try to acquire a valid IRowPosition interface
//
// Arguments:   none
//
// Returns:     true    _pRowPos is valid
//              false   _pRowPos is invalid

BOOL
CAdaptingProvider::EnsureRowsetPosition()
{
    if (EnsureRowset())
        AdaptRowPositionOnRowset(&_pRowPos, _pRowset);
    return !!_pRowPos;
}


//+-------------------------------------------------------------------------
// Member:      Ensure Cursor (private)
//
// Synopsis:    Try to acquire a valid ICursor interface
//
// Arguments:   none
//
// Returns:     true    _pCursor is valid
//              false   _pCursor is invalid

BOOL
CAdaptingProvider::EnsureCursor()
{
    if (!_pCursor)
    {
#ifdef VD_INCLUDE_ROWPOSITION
        if (EnsureRowsetPosition())
            AdaptCursorOnRowPosition(&_pCursor, _pRowPos);
        else
#endif
        if (EnsureRowset())
            AdaptCursorOnRowset(&_pCursor, _pRowset);
    }
    return !!_pCursor;
}


//+-------------------------------------------------------------------------
// Member:      Ensure ADO (private)
//
// Synopsis:    Try to acquire a valid IADORecordset interface
//
// Arguments:   none
//
// Returns:     true    _pADO is valid
//              false   _pADO is invalid

BOOL
CAdaptingProvider::EnsureADO()
{
    if (_pADO)
        goto Cleanup;
    
    if (EnsureRowsetPosition())
    {
        if (_pCRI)
            _pCRI->InitPosition();      // in case it hasn't been done yet
        AdaptADOOnRowPos(&_pADO, _pRowPos);
    }
    else
    if (EnsureRowset())
        AdaptADOOnRowset(&_pADO, _pRowset);

Cleanup:
    return !!_pADO;
}


//+-------------------------------------------------------------------------
// Member:      Ensure CRI (private)
//
// Synopsis:    Try to acquire a valid ICurrentRecordInstance interface
//
// Arguments:   none
//
// Returns:     true    _pCRI is valid
//              false   _pCRI is invalid

BOOL
CAdaptingProvider::EnsureCRI()
{
    HRESULT hr = S_OK;
    
    if (_pCRI)                      // already exists, nothing to do
        goto Cleanup;

    EnsureRowsetPosition();         // need a valid RowPosition

    // get a CRI object
    _pCRI = new CCurrentRecordInstance;
    if (!_pCRI)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // tell it to track the RowPosition
    hr = _pCRI->Init(this, _pRowPos);
    if (!hr)
        hr = _pCRI->InitChapter(_hChapter);
    if (hr)
    {
        _pCRI->Detach();
        ClearInterface(&_pCRI);
        goto Cleanup;
    }

Cleanup:
    return !!_pCRI;
}


//+-------------------------------------------------------------------------
// Member:      Query Data Interface (CAdaptingProvider, public)
//
// Synopsis:    return addref'd interface pointer
//
// Arguments:   riid        desired interface
//              ppvUnk      where to store interface pointer
//
// Returns:     HRESULT

#define TEST(intf, EnsureFn, _pIntf) \
    if (IsEqualIID(riid, intf))     \
    {                               \
        if (EnsureFn())             \
        {                           \
            _pIntf->AddRef();       \
            *ppvUnk = _pIntf;       \
            hr = S_OK;              \
        }                           \
    }

HRESULT
CAdaptingProvider::QueryDataInterface(REFIID riid, void **ppvUnk)
{
    HRESULT hr = E_NOINTERFACE;     // assume the worst

            TEST(IID_IRowset,               EnsureRowset,           _pRowset)
    else    TEST(IID_ICurrentRecordInstance,EnsureCRI,              _pCRI)
    else    TEST(IID_IADORecordset15,       EnsureADO,              _pADO)
    else    TEST(IID_IRowPosition,          EnsureRowsetPosition,   _pRowPos)
    else    TEST(IID_ICursor,               EnsureCursor,           _pCursor)
    else    TEST(IID_OLEDBSimpleProvider,   EnsureSTD,              _pSTD)

    return hr;
}

#undef TEST


//+-------------------------------------------------------------------------
// Member:      Stop
//
// Synopsis:    Stops any asynchronous download that may be in progress
//
// Arguments:   
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::Stop()
{
    HRESULT hr=S_OK;
    IDBAsynchStatus * pRowsetAsynch;

    if (_pRowset)
    {
        hr = _pRowset->QueryInterface(IID_IDBAsynchStatus, (void **)&pRowsetAsynch);
        if (SUCCEEDED(hr) && pRowsetAsynch)
        {
            hr = pRowsetAsynch->Abort(NULL, DBASYNCHOP_OPEN);
            pRowsetAsynch->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Member:      ReplaceProvider (CAdaptingProvider, public)
//
// Synopsis:    tear down current-record bindings before going away
//
// Arguments:   pdspNewProvider        new provider
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::ReplaceProvider(CDataSourceProvider *pdspNewProvider)
{
    HRESULT hr;
    int i;
    CProviderRecord *pPR;
    
    // notify everyone attached to me that I'm changing
    hr = super::ReplaceProvider(pdspNewProvider);

    // notify all my child providers that their clients should rebind
    for (i=_aryPR.Size(), pPR=_aryPR;  i > 0;  --i, ++pPR)
    {
        if (pPR->pdsp)
        {
            HRESULT hrT;

            hrT = pPR->pdsp->ReplaceProvider(NULL);
            if (!hr)
                hr = hrT;               // report first error
        }
    }
    
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     GetXT
//
//  Synopsis:   Return the CXferThunk used to get/set data from the given
//              field using the given type.  Create one, if necessary, and
//              cache it in _aryXT.
//
//  Returns:    XT

CXferThunk *
CAdaptingProvider::GetXT(LPCTSTR strColumn, CVarType vtDest)
{
    CXferThunk *pXT = NULL;
    int i;
    CXTRecord *pXR;

    // look up <field, type> in the table
    for (i=_aryXT.Size(), pXR=_aryXT;  i>0;  --i, ++pXR)
    {
        if (0 == FormsStringCmp(strColumn, pXR->bstrField) &&
            vtDest.IsEqual(pXR->vtDest))
        {
            break;
        }
    }

    // if it's there, just return the XT
    if (i != 0)
    {
        pXT = pXR->pXT;
    }

    // if it's not, create and cache a new XT
    else
    {
        ISimpleDataConverter *pSDC;
        CDataLayerCursor *pDLC = GetDLCursor();

        if (!pDLC)
            goto Cleanup;

        pSDC = vtDest.FLocalized() ? _pMarkup->GetSimpleDataConverter() : _pSDC;

        // create a cache entry
        pXR = _aryXT.Append();
        if (pXR == NULL)
            goto Cleanup;

        // create an XT
        CXferThunk::Create(pDLC, strColumn, vtDest, pSDC, &pXT);

        // fill in the cache entry
        FormsAllocString(strColumn, &pXR->bstrField);
        pXR->vtDest = vtDest;
        pXR->pXT = pXT;
    }

Cleanup:
    return pXT;
}



//+-------------------------------------------------------------------------
// Member:      GetSubProvider (CDataSourceProvider, public)
//
// Synopsis:    return a sub-provider of a hierarchical provider
//
// Arguments:   ppdsp       where to store the answer
//              bstrName    path through hierarchy (e.g. "orders.details")
//              hrow        hrow of interest
//
// Description: This function is called in two circumstances.
//              (1) during nested table expansion, inner tables need a
//              sub-provider corresponding to the HROW of the enclosing table
//              row.  In this case hrow is non-null, and bstrName is a single
//              component denoting the field that holds the chapter handle.
//              (2) script and current-record bound elements need the sub-
//              provider obtained by walking down the tree following the
//              current row position of each provider.  In this case, hrow is
//              null, and bstrName can have many components separated by dots.
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::GetSubProvider(CDataSourceProvider **ppdsp,
                                    LPCTSTR bstrName, HROW hrow)
{
    HRESULT hr = S_OK;
    BSTR bstrHead = NULL;
    BSTR bstrTail = NULL;
    HCHAPTER hchapter = DB_NULL_HCHAPTER;
    HROW hrowCurr = DB_NULL_HROW;

    // bookkeeping to get started
    Assert(ppdsp);
    *ppdsp = NULL;
    FormsSplitFirstComponent(bstrName, &bstrHead, &bstrTail);

    // if the name is empty, return myself
    if (FormsStringLen(bstrHead) == 0)
    {
        AddRef();
        *ppdsp = this;
    }

    // if an HROW is given, use sub-provider corresponding to chapter (case 1)
    else if (hrow != DB_NULL_HROW)
    {
        hr = GetProviderFromField(bstrHead, hrow, ppdsp);
    }

    // otherwise, follow current position down the tree
    else if (EnsureRowsetPosition())
    {
        DBPOSITIONFLAGS dwFlags;
        CDataSourceProvider *pSubProvider = NULL;

        Assert(_pCRI);
        _pCRI->InitPosition();      // make sure _pRowPos has valid position
        
        // get the current hrow
        hr = _pRowPos->GetRowPosition(&hchapter, &hrowCurr, &dwFlags);
        if (!hr && hrowCurr == DB_NULL_HROW)
            hr = DB_E_BADROWHANDLE;

        // get next level sub-provider
        if (!hr)
            hr = GetProviderFromField(bstrHead, hrowCurr, &pSubProvider);

        // if something failed, return a null provider (so script gets
        // a zombie ADO recordset)
        if (hr)
        {
            *ppdsp = new CNullProvider(Doc());
            hr = (*ppdsp) ? S_OK : E_OUTOFMEMORY;
            goto Cleanup;
        }

        // continue search at next level
        Assert (pSubProvider);

        hr = pSubProvider->GetSubProvider(ppdsp, bstrTail);
        pSubProvider->Release();
    }

    // without a row position object, we're helpless
    else
    {
        hr = E_FAIL;
    }

Cleanup:
    ReleaseChapterAndRow(hchapter, hrowCurr, _pRowPos);
    FormsFreeString(bstrHead);
    FormsFreeString(bstrTail);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      GetChapterFromField (CAdaptingProvider, private)
//
// Synopsis:    find the chapter handle in the given hrow's field.
//
// Flame:       You might think this could be done by doing GetData
//              on the given HROW and field.  But it seems that OLE-DB
//              allows providers to generate chapter handles dynamically,
//              returning a new handle each time you call GetData.  This
//              isn't specifically mentioned in the OLE-DB spce (v2.0), but
//              I called the OLE-DB spec guru (12-May-98) and he attested
//              that this behavior is permitted.
//              Furthermore, at least one provider (the Shape Provider)
//              works this way.  So we have to fetch the handle once and
//              cache it.
//
// Arguments:   hrow        HROW holding desired chapter value
//              bstrField   name of chapter-valued field
//              phChapter   where to return the answer
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::GetChapterFromField(HROW hrow, BSTR bstrField,
                                        HCHAPTER *phChapter)
{
    HRESULT hr = S_OK;
    int i;
    CChapterRecord *pCR;
    
    // look up <hrow, field> in chapter table
    for (i=_aryCR.Size(), pCR=_aryCR; i>0;  --i, ++pCR)
    {
        if (IsSameRow(pCR->hrow, hrow) &&
            FormsStringCmp(pCR->bstrField, bstrField) == 0)
        {
            break;
        }
    }

    // if it's not there, fetch the handle and cache it in the table
    if (i == 0)
    {
        HACCESSOR hAccessor;
        HCHAPTER hChapter;

        // fetch the chapter handle from the rowset
        hr = GetAccessorForField(bstrField, &hAccessor);
        if (hr)
            goto Cleanup;

        hr = _pRowset->GetData(hrow, hAccessor, &hChapter);
        if (hr)
            goto Cleanup;

        // add an entry to the cache
        pCR = _aryCR.Append();
        if (pCR)
        {
            _pRowset->AddRefRows(1, &hrow, NULL, NULL);
            pCR->hrow = hrow;
            FormsAllocString(bstrField, &pCR->bstrField);
            pCR->hChapter = hChapter;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // return the desired chapter handle
    *phChapter = pCR->hChapter;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      GetProviderFromField (CAdaptingProvider, private)
//
// Synopsis:    find the provider associated with the chapter value in the
//              given hrow's field.
//
// Arguments:   bstrField   name of chapter-valued field
//              hrow        HROW holding desired chapter value
//              ppdsp       where to return the answer
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::GetProviderFromField(BSTR bstrField, HROW hrow,
                                        CDataSourceProvider **ppdsp)
{
    HRESULT hr;
    HCHAPTER hChapter;
    int i;
    CProviderRecord *pPR;

    Assert(_pRowset);
    *ppdsp = NULL;

    hr = GetChapterFromField(hrow, bstrField, &hChapter);
    if (hr)
        goto Cleanup;

    // look up <field, chapter> in my cache
    for (i=_aryPR.Size(), pPR=_aryPR;  i > 0;  --i, ++pPR)
    {
        if (pPR->hChapter == hChapter &&
            FormsStringCmp(pPR->bstrField, bstrField) == 0)
        {
            break;
        }
    }

    // if it wasn't there, create the desired provider and add it to the cache
    if (i == 0)
    {
        pPR = _aryPR.Append();
        if (!pPR)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = InitializeProviderRecord(pPR, hChapter, bstrField);
        if (hr)
            goto Cleanup;
    }

    // return the desired result
    *ppdsp = pPR->pdsp;
    if (*ppdsp)
        (*ppdsp)->AddRef();

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      GetAccessorAndRowsetForField (CAdaptingProvider, private)
//
// Synopsis:    find the accessor for the chapter-valued column
//
// Arguments:   bstrField   name of chapter-valued field
//              phAccessor  where to store accessor
//              ppRowset    where to store field's referenced rowset
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::GetAccessorAndRowsetForField(BSTR bstrField,
                                        HACCESSOR *phAccessor, IRowset **ppRowset)
{
    HRESULT hr = S_OK;
    int i;
    CAccessorRecord *pAR;

    // prepare for failure
    if (phAccessor)
        *phAccessor = NULL;
    if (ppRowset)
        *ppRowset = NULL;

    // look up the field in the cache
    for (i=_aryAR.Size(), pAR=_aryAR;  i>0;  --i, ++pAR)
    {
        if (FormsStringCmp(bstrField, pAR->bstrField) == 0)
            break;
    }

    // if not in the cache, add it
    if (i == 0)
    {
        pAR = _aryAR.Append();
        if (!pAR)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = InitializeAccessorRecord(pAR, bstrField);
        if (hr)
            goto Cleanup;
    }

    // return the desired results
    if (phAccessor)
    {
        if (EnsureAccessorInAccessorRecord(pAR))
        {
            *phAccessor = pAR->hAccessor;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    
    if (ppRowset)
    {
        if (EnsureRowsetInAccessorRecord(pAR))
        {
            *ppRowset = pAR->pRowset;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      InitializeProviderRecord (CAdaptingProvider, private)
//
// Synopsis:    initialize an entry in the _aryPR array that maps
//              <fieldname, chapter> to <provider>.
//
// Arguments:   pPR         pointer to entry that needs initializing
//              hChapter    chapter handle
//              bstrField   name of chapter-valued field
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::InitializeProviderRecord(CProviderRecord *pPR,
                        HCHAPTER hChapter, BSTR bstrField)
{
    HRESULT hr;
    IRowsetInfo *pRowsetInfo = NULL;
    IRowset *pChildRowset = NULL;

    // fill in entries with null (in case of error)
    FormsAllocString(bstrField, &pPR->bstrField);
    pPR->hChapter = hChapter;
    pPR->pdsp = NULL;

    // get the rowset to which the chapter applies
    hr = GetRowsetForField(bstrField, &pChildRowset);
    if (hr)
        goto Cleanup;

    // create a provider and stick it into the table
    hr = CreateSubProvider(this, pChildRowset, NULL, _pRowEvents->GetDataMemberManager(),
                            hChapter, DB_NULL_HROW, &pPR->pdsp);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pRowsetInfo);

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      InitializeAccessorRecord (CAdaptingProvider, private)
//
// Synopsis:    initialize an entry in the _aryAR array that maps
//              <fieldname> to <accessor, ordinal>.
//
// Arguments:   pAR         pointer to entry that needs initializing
//              bstrField   name of chapter-valued field
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::InitializeAccessorRecord(CAccessorRecord *pAR, BSTR bstrField)
{
    HRESULT hr;
    IColumnsInfo *pColumnsInfo = NULL;
    DBORDINAL cColumns;
    DBCOLUMNINFO *aColumnInfo = NULL;
    OLECHAR *pStringsBuffer = NULL;
    DBORDINAL i;

    FormsAllocString(bstrField, &pAR->bstrField);
    pAR->hAccessor = 0;
    pAR->pRowset = NULL;
    pAR->ulOrdinal = DB_INVALIDCOLUMN;

    // get the column info
    hr = _pRowset->QueryInterface(IID_IColumnsInfo, reinterpret_cast<void**>(&pColumnsInfo));
    if (hr)
        goto Cleanup;

    hr = pColumnsInfo->GetColumnInfo(&cColumns, &aColumnInfo, &pStringsBuffer);
    if (hr)
        goto Cleanup;

    // look up the desired column, make sure it's chapter-valued
    hr = E_FAIL;        // in case search fails
    for (i=0; i<cColumns; ++i)
    {
        if (FormsStringICmp(bstrField, aColumnInfo[i].pwszName) == 0)
            break;
    }
    if (i == cColumns)
        goto Cleanup;
    if ( !(aColumnInfo[i].dwFlags & DBCOLUMNFLAGS_ISCHAPTER) )
        goto Cleanup;

    pAR->ulOrdinal = i;
    hr = S_OK;

Cleanup:
    CoTaskMemFree(aColumnInfo);
    CoTaskMemFree(pStringsBuffer);
    ReleaseInterface(pColumnsInfo);

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      EnsureAccessorInAccessorRecord (CAdaptingProvider, private)
//
// Synopsis:    make sure the accessor field is filled in
//
// Arguments:   pAR         the accessor record of interest
//
// Returns:     TRUE        if accessor field has a valid accessor

BOOL
CAdaptingProvider::EnsureAccessorInAccessorRecord(CAccessorRecord *pAR)
{
    HRESULT hr = S_OK;
    IAccessor *pAccessor = NULL;
    DBBINDING dbBinding;
    DBBINDSTATUS dbBindStatus;

    if (pAR->hAccessor != 0 || pAR->ulOrdinal == DB_INVALIDCOLUMN)
        goto Cleanup;
    
    hr = _pRowset->QueryInterface(IID_IAccessor, reinterpret_cast<void**>(&pAccessor));
    if (hr)
        goto Cleanup;

    dbBinding.iOrdinal = pAR->ulOrdinal;
    dbBinding.obValue = 0;
    dbBinding.dwPart = DBPART_VALUE;
    dbBinding.wType = DBTYPE_HCHAPTER;

    dbBinding.pTypeInfo = 0;
    dbBinding.pBindExt = 0;
    dbBinding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    dbBinding.dwFlags = 0;
    
    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &dbBinding, 0,
                                    &pAR->hAccessor, &dbBindStatus);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pAccessor);
    return (pAR->hAccessor != 0);
}


//+-------------------------------------------------------------------------
// Member:      EnsureRowsetInAccessorRecord (CAdaptingProvider, private)
//
// Synopsis:    make sure the rowset field is filled in
//
// Arguments:   pAR         the accessor record of interest
//
// Returns:     TRUE        if rowset field has a valid rowset

BOOL
CAdaptingProvider::EnsureRowsetInAccessorRecord(CAccessorRecord *pAR)
{
    HRESULT hr = S_OK;
    IRowsetInfo *pRowsetInfo = NULL;

    if (pAR->pRowset != NULL || pAR->ulOrdinal == DB_INVALIDCOLUMN)
        goto Cleanup;
    
    hr = _pRowset->QueryInterface(IID_IRowsetInfo, reinterpret_cast<void**>(&pRowsetInfo));
    if (hr)
        goto Cleanup;

    hr = pRowsetInfo->GetReferencedRowset(pAR->ulOrdinal, IID_IRowset,
                                    reinterpret_cast<IUnknown**>(&pAR->pRowset));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pRowsetInfo);
    return (pAR->pRowset != NULL);
}


//+-------------------------------------------------------------------------
// Member:      Create (CAdaptingProvider, static)
//
// Synopsis:    create a sub-provider for a child rowset (for hierarchy)
//
// Arguments:   pChildRowset    child rowset on which to base provider
//              hChapter        chapter to restrict provider
//              ppdsp           where to store the result
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::CreateSubProvider(CAdaptingProvider *pProviderParent,
                                    IRowset *pChildRowset,
                                    IRowPosition *pChildRowPos,
                                    CDataMemberMgr *pdmm,
                                    HCHAPTER hChapter, HROW hrow,
                                    CDataSourceProvider **ppdsp)
{
    HRESULT hr = S_OK;
    CAdaptingProvider *pProvider;

    if (pChildRowPos)
    {
        pProvider = new CAdaptingProvider(pChildRowPos, hrow);
    }
    else
    {
        Assert(pChildRowset);
        pProvider = new CAdaptingProvider(pChildRowset);
    }
    
    if (pProvider)
    {
        *ppdsp = pProvider;
        pProvider->Init(pdmm, hChapter, pProviderParent);
    }
    else
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      RemoveSubProvider (CAdaptingProvider, private)
//
// Synopsis:    remove a sub-provider from my tables
//
// Arguments:   pdsp            sub-provider to remove
//
// Returns:     nothing

void
CAdaptingProvider::RemoveSubProvider(CDataSourceProvider *pdsp)
{
    int i;
    CProviderRecord *pPR;
    Assert(pdsp);

    // look up <field, chapter> in my cache
    for (i=_aryPR.Size()-1, pPR=_aryPR+i;  i >= 0;  --i, --pPR)
    {
        if (pPR->pdsp == pdsp)
        {
            FormsFreeString(pPR->bstrField);
            pPR->pdsp->Release();
            _aryPR.Delete(i);
        }
    }
}


//+-------------------------------------------------------------------------
// Member:      UpdateProviderRecords (CAdaptingProvider, private)
//
// Synopsis:    Replace old <chapter, provider> by new one in my tables
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::UpdateProviderRecords(HCHAPTER hChapterOld, CDataSourceProvider *pdspOld,
                                HCHAPTER hChapterNew, CDataSourceProvider *pdspNew)
{
    int i, j;
    CProviderRecord *pPR;
    CChapterRecord *pCR;

    // find record for old provider
    for (i=_aryPR.Size()-1, pPR=_aryPR+i;  i >= 0;  --i, --pPR)
    {
        if (pPR->pdsp == pdspOld)
        {
            // it should correspond to the old chapter
            Assert(pPR->hChapter == hChapterOld);

            // replace it with the new chapter and provider
            pPR->hChapter = hChapterNew;
            pdspNew->AddRef();
            pdspOld->Release();
            pPR->pdsp = pdspNew;

            // update the chapter table
            for (j=_aryCR.Size()-1, pCR=_aryCR+j;  j>=0;  --j, --pCR)
            {
                if (pCR->hChapter == hChapterOld &&
                    FormsStringCmp(pPR->bstrField, pCR->bstrField) == 0)
                {
                    IRowset *pChildRowset = NULL;
                    if (S_OK == GetRowsetForField(pPR->bstrField, &pChildRowset)
                        && pChildRowset)
                    {
                        IChapteredRowset *pChapRowset = NULL;

                        if (S_OK == pChildRowset->QueryInterface(IID_IChapteredRowset,
                                                                 (void**)&pChapRowset)
                                && pChapRowset)
                        {
                            IGNORE_HR(pChapRowset->AddRefChapter(hChapterNew, NULL));
                            IGNORE_HR(pChapRowset->ReleaseChapter(pCR->hChapter, NULL));
                        }

                        ReleaseInterface(pChapRowset);
                    }
                    
                    pCR->hChapter = hChapterNew;
                }
            }
        }
    }

    RRETURN(S_OK);
}


//+-------------------------------------------------------------------------
// Member:      ChangeChapter (CAdaptingProvider, private)
//
// Synopsis:    change the chapter I get my data from
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::ChangeChapter(HCHAPTER hChapterNew, HROW hrowNew)
{
    HRESULT hr = S_OK;
    CDataSourceProvider *pProviderNew = NULL;

    AddRef();               // stabilize during this routine
    
    if (hChapterNew == _hChapter)
        goto Cleanup;
    
    if (_pProviderParent)   // Child provider.
    {
        // create a new provider tied to the new chapter
        hr = CreateSubProvider(_pProviderParent, NULL, _pRowPos,
                                _pRowEvents->GetDataMemberManager(),
                                hChapterNew, hrowNew, &pProviderNew);
        
        // tell my parent to update her records
        if (!hr)
            hr = _pProviderParent->UpdateProviderRecords(_hChapter, this,
                            hChapterNew, pProviderNew);

        // tell my clients to use the new provider
        if (!hr)
            hr = ReplaceProvider(pProviderNew);
    }

    else                    // Top-level provider
    {
        // change my chapter
        IChapteredRowset *pChapRowset = NULL;

        if (S_OK == _pRowset->QueryInterface(IID_IChapteredRowset,
                                             (void**)&pChapRowset)
                     && pChapRowset)
        {
            IGNORE_HR(pChapRowset->AddRefChapter(hChapterNew, NULL));
            IGNORE_HR(pChapRowset->ReleaseChapter(_hChapter, NULL));
            ReleaseInterface(pChapRowset);
        }

        // tell my clients to rebind
        hr = ReplaceProvider(this);
        
        _hChapter = hChapterNew;

        _fNeedRowEnter = (hrowNew != DB_NULL_HROW);
        _fRowEnterOK = FALSE;
        
        IGNORE_HR(_pCRI->InitChapter(_hChapter));
        _pMarkup->GetDataBindTask()->InitCurrentRecord(_pCRI);
    }
    
Cleanup:
    if (pProviderNew)
    {
        pProviderNew->Release();
    }
    Release();      // don't use (this) any more
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     FireDelayedRowEnter
//
//  Synopsis:   Fire onrowenter now, if there was reason to fire it during
//              startup and we haven't fired it yet.
//
//  Returns:    HRESULT

HRESULT
CAdaptingProvider::FireDelayedRowEnter()
{
    if (_fNeedRowEnter && _pRowEvents)
    {
        TraceTag((tagRowEvents, "%p -> onRowEnter", _pRowEvents->GetOwner()));
        FireDataEvent(&s_propdescCElementonrowenter);
    }
    
    _fNeedRowEnter = FALSE;
    _fRowEnterOK = TRUE;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     FireDataEvent
//
//  Synopsis:   Fire one of the events we synthesize on data source objects:
//              datasetchanged, dataavail, datasetcomplete, rowenter, rowexit,
//              rowsinserted, rowsdelete, cellchange
//
//  Returns:    HRESULT

HRESULT
CAdaptingProvider::FireDataEvent(const PROPERTYDESC_BASIC *pDesc,
                                 BOOL *pfCancelled /* NULL */,
                                 long lReason /* 0 */)
{
    HRESULT         hr = S_OK;

    // if there's no _pRowEvents, there's no use trying
    if (_pRowEvents)
    {
        CDataMemberMgr * pdmm = _pRowEvents->GetDataMemberManager();
        CTreeNode *     pNodeContext = pdmm->GetOwner()->GetFirstBranch();
        CDoc *          pDoc = pdmm->Doc();
        CDoc *          pDocOSP = NULL;
        BOOL            fRet = TRUE;
        DISPID          dispidEvent = (DISPID)(pDesc->c);
        DISPID          dispidProp = pDesc->b.dispid;

        // look for Trident-as-OSP, attach param accordingly
        if (S_OK == pdmm->GetTridentAsOSP(&pDocOSP) && pDocOSP)
        {
            pDoc = pDocOSP;
        }
        EVENTPARAM      param(pDoc, pdmm->GetOwner(), NULL, TRUE);
        CDoc::CLock     Lock(pDoc);
    
        // set event parameters
        param.SetNodeAndCalcCoordinates(pNodeContext);
        param.SetType(pDesc->a.pstrName + 2);
        param.SetQualifier(_cstrDataMember);
        param._lReason      = lReason;
        param.pProvider     = this;

        AddRef();       // stabilize during event

        // if we're firing onrowexit, make sure we've enabled firing
        // onrowenter as well
        if (dispidEvent == DISPID_EVMETH_ONROWEXIT && !_fRowEnterOK)
        {
            FireDelayedRowEnter();
        }
        
        // fire the event
        if (pDocOSP)
        {   // Trident-as-OSP (note, pDocOSP is *not* refcounted)
            hr = THR(pDocOSP->FireEvent(pDocOSP,
                            pdmm->GetOwner(),
                            NULL,
                            dispidEvent,
                            dispidProp,
                            NULL,
                            &fRet));
        }
        else
        {   // normal DSO
            hr = pdmm->GetOwner()->FireEvent(
                        pDesc,
                        FALSE,
                        pNodeContext,
                        0);

            fRet = !!hr;
        }

        // see if it was cancelled
        if (pfCancelled)
        {
            *pfCancelled = !fRet;
        }

        Release();
    }
    
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     get_bookmarks
//
//  Synopsis:   return a collection of ADO bookmarks corresponding to the
//              hrows affected by the current data change event
//
//  Returns:    HRESULT

HRESULT 
CAdaptingProvider::get_bookmarks(IHTMLBookmarkCollection **ppBookmarkCollection)
{
    HRESULT hr;
    CBookmarkCollection *pBmkColl = NULL;

    if (ppBookmarkCollection == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // create a collection
    pBmkColl = new CBookmarkCollection;
    if (pBmkColl == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(_pCRI);
    _pCRI->InitPosition();      // make sure _pRowPos has valid position

    // fill it with ADO bookmarks
    hr = pBmkColl->Init(_pRowEvents->_rghRows, _pRowEvents->_cRows, _pADO);
    if (hr)
        goto Cleanup;

    // return the answer
    hr = pBmkColl->QueryInterface(IID_IHTMLBookmarkCollection,
                                  (void**)ppBookmarkCollection);

Cleanup:
    ReleaseInterface(pBmkColl);
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_recordset
//
//  Synopsis:   return the ADO recordset for this provider's dataset
//
//  Returns:    HRESULT

HRESULT 
CAdaptingProvider::get_recordset(IDispatch **ppRecordset)
{
    return QueryDataInterface(IID_IADORecordset15, (void**)ppRecordset);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_dataFld
//
//  Synopsis:   return the name of the data field changed in the current
//              oncellchange event
//
//  Returns:    HRESULT

HRESULT 
CAdaptingProvider::get_dataFld(BSTR *pbstrDataFld)
{
    HRESULT hr;
    
    if (pbstrDataFld)
    {
        if (_pRowEvents->_cColumns > 0)
        {
            LPCTSTR pchDataFld = NULL;
            CDataLayerCursor *pDLC = GetDLCursor();

            hr = pDLC ? pDLC->GetColumnNameFromNumber(_pRowEvents->_rgColumns[0],
                                                        &pchDataFld)
                      : E_FAIL;
            if (!hr)
                hr = FormsAllocString(pchDataFld, pbstrDataFld);
        }
        else
        {
            *pbstrDataFld = NULL;
            hr = S_OK;
        }
    }
    else
        hr = E_POINTER;

    RRETURN(hr);
}


/////-------------------------------------------------------------------/////
/////                   CDataSourceProvider methods                     /////
/////-------------------------------------------------------------------/////

//+-------------------------------------------------------------------------
// Member:      Create (CDataSourceProvider, static, public)
//
// Synopsis:    Factory method - creates an element's interface provider
//
// Arguments:   pelProvider     underlying element
//              ppdsp           where to put pointer to created provider object
//
// Returns:     S_OK            it worked
//              E_OUTOFMEMORY   amnesia

HRESULT
CDataSourceProvider::Create(CDataMemberMgr *pDMembMgr, CDoc *pDoc,
                            BSTR bstrDataMember, CDataSourceProvider **ppdsp)
{
    Assert(ppdsp);
    
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;
    CAdaptingProvider * pAdaptingProvider = NULL;
    OLEDBSimpleProvider *pSTD;
    IRowset *pRowset;
    IVBDSC *pVBDSC;
    IRowPosition *pRowPos = NULL;
    HCHAPTER hChapter = DB_NULL_HCHAPTER;
    HROW hrow = DB_NULL_HROW;

    *ppdsp = NULL;                      // assume failure

    // get the databinding interface
    if (pDMembMgr)
    {
        // Check for NULL punk instead of HRESULT..
        IGNORE_HR(pDMembMgr->GetDataBindingInterface(bstrDataMember, &punk));
    }

    // match it to the ones we know about
    if (punk == NULL)
        *ppdsp = new CNullProvider(pDoc);
    else if (S_OK == punk->QueryInterface(IID_IRowPosition, (void**)&pRowPos) && pRowPos)
    {
        pRowPos->GetRowPosition(&hChapter, &hrow, NULL);
        pAdaptingProvider = new CAdaptingProvider(pRowPos, hrow);
    }
    else if (S_OK == punk->QueryInterface(IID_IRowset, (void**)&pRowset) && pRowset)
    {
        pAdaptingProvider = new CAdaptingProvider(pRowset);
        ReleaseInterface(pRowset);
    }
    else if (S_OK == punk->QueryInterface(IID_OLEDBSimpleProvider, (void**)&pSTD) && pSTD)
    {
        pAdaptingProvider = new CAdaptingProvider(pSTD);
        ReleaseInterface(pSTD);
    }
    else if (S_OK == punk->QueryInterface(IID_IVBDSC, (void**)&pVBDSC) && pVBDSC)
    {
        pAdaptingProvider = new CAdaptingProvider(pVBDSC);
        ReleaseInterface(pVBDSC);
    }
    else
        *ppdsp = new CNullProvider(pDoc);

    // return the answer (this must be done here;  see below)
    if (pAdaptingProvider)
    {
        *ppdsp = pAdaptingProvider;
    }

    // tell the new provider which data member he's attached to
    if (*ppdsp)
    {
        (*ppdsp)->_cstrDataMember.Set(bstrDataMember);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (pAdaptingProvider)
    {
        // It's very important that *ppdsp be set before we call the Init routine,
        // because the Init may fire script events that could attempt to reference
        // the recordset, which would cause us to arrive here recursively unless
        // our caller's _pdspProvider has already been set.
        hr = pAdaptingProvider->Init(pDMembMgr, hChapter);
    }

    // release the chapter, if we got one
    ReleaseChapterAndRow(hChapter, hrow, pRowPos);
        
    ReleaseInterface(pRowPos);
    ReleaseInterface(punk);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      destructor (CDataSourceProvider, public)
//
// Synopsis:    release resources

CDataSourceProvider::~CDataSourceProvider()
{
    ClearInterface((IUnknown**)&_pADOClientSite);
}


//+-------------------------------------------------------------------------
// Member:      Release (CDataSourceProvider, public)
//
// Synopsis:    decrement refcount, and if it's 0 delete myself
//
// Returns:     new refcount

ULONG
CDataSourceProvider::Release()
{
    ULONG ulRefCount = --_ulRefCount;
    if (ulRefCount == 0)
        delete this;
    return ulRefCount;        
}


//+-------------------------------------------------------------------------
// Member:      Detach (CDataSourceProvider, public)
//
// Synopsis:    Detach my resources

void
CDataSourceProvider::Detach()
{
    ReplaceProvider(NULL);
    _aryAdvisees.DeleteAll();
}


//+-------------------------------------------------------------------------
// Member:      ADOClientSite (CDataSourceProvider, protected)
//
// Synopsis:    Return my ADO client site, creating it if necessary

CADOClientSite *
CDataSourceProvider::ADOClientSite()
{
    if (!_pADOClientSite)
    {
        _pADOClientSite = new CADOClientSite(Doc());
    }

    return _pADOClientSite;
}


//+-------------------------------------------------------------------------
// Member:      AdviseDataProviderEvents (CDataSourceProvider, public)
//
// Synopsis:    add a new advisee
//
// Returns:     HRESULT

HRESULT
CDataSourceProvider::AdviseDataProviderEvents(CDataSourceBinder *pdsb)
{
    HRESULT hr = S_OK;
    const int iEmpty = _aryAdvisees.Find(NULL);

    if (iEmpty != -1)
    {
        _aryAdvisees[iEmpty] = pdsb;
    }
    else
    {
        hr = THR(_aryAdvisees.Append(pdsb));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      UnadviseDataProviderEvents (CDataSourceProvider, public)
//
// Synopsis:    remove an advisee
//
// Returns:     HRESULT

HRESULT
CDataSourceProvider::UnadviseDataProviderEvents(CDataSourceBinder *pdsb)
{
    HRESULT hr = S_OK;
    const int iIndex = _aryAdvisees.Find(pdsb);

    if (iIndex >= 0)
    {
        _aryAdvisees[iIndex] = NULL;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      ReplaceProvider (CDataSourceProvider, public)
//
// Synopsis:    I'm about to be replaced by a new provider.  Inform my advisees.
//
// Returns:     HRESULT

HRESULT
CDataSourceProvider::ReplaceProvider(CDataSourceProvider *pdspNewProvider)
{
    HRESULT hr = S_OK;
    int k;

    for (k=0; k<_aryAdvisees.Size(); ++k)
    {
        if (_aryAdvisees[k])
            _aryAdvisees[k]->ReplaceProvider(pdspNewProvider);
    }

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     LoadBoundElementCollection
//
//  Synopsis:   load a collection with the elements bound to my dataset
//
//  Returns:    HRESULT

HRESULT 
CDataSourceProvider::LoadBoundElementCollection(CCollectionCache *pCollectionCache,
                                                long lIndex)
{
    HRESULT hr = S_OK;
    CDataSourceBinder **ppdsb;
    int i;
    
    for (ppdsb=_aryAdvisees, i=_aryAdvisees.Size();  i>0;  ++ppdsb, --i)
    {
        CElement *pBoundElement = (*ppdsb)->GetElementConsumer();
        
        hr = THR(pCollectionCache->SetIntoAry(lIndex, pBoundElement ));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\simpdc.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIMPDC_HXX_
#define X_SIMPDC_HXX_
#include "simpdc.hxx"
#endif


MtDefine(CSimpleDataConverter, DataBind, "CSimpleDataConverter");


HRESULT STDMETHODCALLTYPE
CSimpleDataConverter::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISimpleDataConverter))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}


ULONG STDMETHODCALLTYPE
CSimpleDataConverter::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}


HRESULT STDMETHODCALLTYPE
CSimpleDataConverter::ConvertData( 
    VARIANT varSrc,
    long vtDest,
    IUnknown *pUnknownElement,
    VARIANT *pvarDest)
{
    HRESULT hr = S_OK;

    if (pvarDest)
    {
        if (vtDest == VT_NULL ||
                (varSrc.vt == VT_BSTR && varSrc.bstrVal == NULL && vtDest != VT_BSTR))
        {
            pvarDest->vt = VT_NULL;
        }
        else if (S_OK == CanConvertData(varSrc.vt, vtDest))
        {
            BOOL fTryVariantChangeType = TRUE;

            // VariantChangeTypeEx converts VT_CY to VT_BSTR by converting to
            // float then to BSTR.  This is bogus - no currency symbol, wrong
            // decimal separator, etc.  So let's trap this and use the
            // special-purpose VarFormatCurrency instead. (The reverse conversion
            // is OK.)
            if (varSrc.vt == VT_CY && vtDest == VT_BSTR)
            {
                BSTR bstrTemp;
                // these magic numbers simply mean to use defaults for number of
                // digits, leading zeros, parens, groups, and allow user to
                // override system locale.
                hr = VarFormatCurrency(&varSrc, -1, -2, -2, -2, 0, &bstrTemp);
                if (!hr)
                {
                    VariantClear(pvarDest);
                    pvarDest->vt = VT_BSTR;
                    pvarDest->bstrVal = bstrTemp;
                    fTryVariantChangeType = FALSE;
                }
            }

            if (fTryVariantChangeType)
            {
                hr = VariantChangeTypeEx(pvarDest, &varSrc, _lcid, 0, vtDest);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    RRETURN(hr);
}


HRESULT STDMETHODCALLTYPE
CSimpleDataConverter::CanConvertData( 
    long vt1,
    long vt2)
{
    HRESULT hr = S_FALSE;

    // one of the types must be BSTR
    if (vt1 != VT_BSTR)
    {
        long vtTemp = vt1;
        vt1 = vt2;
        vt2 = vtTemp;
    }

    if (vt1 != VT_BSTR)
        goto Cleanup;

    // the other can be on the list below
    switch (vt2)
    {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_DECIMAL:
        hr = S_OK;
        break;

    default:
        break;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\ospmrshl.cxx ===
// Copyright (c) 1996-1997  Microsoft Corporation.  All rights reserved.
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define JAVAVMAPI                   // avoid dll linkage errors

#ifndef X_WINDOWS_H_
#define X_WINDOWS_H_
#include <windows.h>
#endif

#ifndef X_OLEAUTO_H_
#define X_OLEAUTO_H_
#include <oleauto.h>
#endif

#ifndef X_NATIVE_H_
#define X_NATIVE_H_
#include "native.h" // Raw Native Interface declarations.
#endif

#ifndef X_NATIVCOM_H_
#define X_NATIVCOM_H_
#include "nativcom.h"
#endif

// helpers for date conversions
const static double daysBetween1900And1970 = 25567.0;
const static __int64 iSecondsPerDay = 86400;

typedef enum {
    IntegerClass,
    StringClass,
    LongClass,
    FloatClass,
    DoubleClass,
    BooleanClass,
    DateClass
} ClassIDs;

typedef VARIANT *PETYPE, **PPETYPE;

typedef OBJECT* JTYPE;

typedef void (*pf)(JTYPE javaval, PETYPE petype);

typedef struct {
    ClassClass *type;
    pf func;
    char *className;
} TypeFuncPair;

#define EXTERNC extern "C"

static void fInteger(JTYPE javaval, PETYPE petype)
{
    long iTemp = execute_java_dynamic_method(NULL,
                                             javaval,
                                             "intValue",
                                             "()I");
    V_VT(petype) = VT_I4;
    V_I4(petype) = iTemp;
}

static void fLong(JTYPE javaval, PETYPE petype)
{
#if 0
    // do we have a long long type???
    long long iTemp = execute_java_dynamic_method64(NULL,
        javaval,
        "longValue",
        "()J");
    V_VT(petype) = VT_I8;
    V_I4(petype) = iTemp;
#else
    fInteger(javaval, petype);
#endif
}

static void fFloat(JTYPE javaval, PETYPE petype)
{
    long rTemp = execute_java_dynamic_method(NULL,
                                             javaval,
                                             "floatValue",
                                             "()F");
    V_VT(petype) = VT_R4;
    V_I4(petype) = rTemp;
}

static void fDouble(JTYPE javaval, PETYPE petype)
{
    double iTemp = execute_java_dynamic_method64(NULL,
                                                 javaval,
                                                 "doubleValue",
                                                 "()D");
    V_VT(petype) = VT_R8;
    V_R8(petype) = iTemp;
}

static void fBoolean(JTYPE javaval, PETYPE petype)
{
    int iTemp = execute_java_dynamic_method64(NULL,
                                              javaval,
                                              "booleanValue",
                                              "()Z");
    V_VT(petype) = VT_BOOL;
    V_BOOL(petype) = (iTemp ? VARIANT_TRUE : VARIANT_FALSE);
}

static void fDate(JTYPE javaval, PETYPE petype)
{
    // java to variant

    __int64 iDate = execute_java_dynamic_method64(NULL,
                                                  javaval,
                                                  "getTime",
                                                  "()J");

    __int64 iDays = (iDate / 1000) / iSecondsPerDay;
    __int64 iRemainingMS = iDate - (iDays * iSecondsPerDay * 1000);

    double variantDate = daysBetween1900And1970    +
                         (double)iDays             +
                         ((double)iRemainingMS / ((double)iSecondsPerDay * 1000.0));
    
    V_VT(petype) = VT_DATE;
    V_DATE(petype) = variantDate;
}

static void fString(JTYPE javaval, PETYPE petype)
{
    Hjava_lang_String *stringValue = (Hjava_lang_String *) javaval;
    unicode *uc = javaStringStart (stringValue);
    int ucLen = javaStringLength(stringValue);

    V_VT(petype) = VT_BSTR;
    V_BSTR(petype) = SysAllocStringLen(uc, ucLen);
}

static void fStringViaToString(JTYPE javaval, PETYPE petype)
{
    LONG_PTR stringValue = execute_java_dynamic_method64(NULL,  // ExecEnv *ee,
        javaval,                    // HObject *obj,
        "toString",                 // method name
        "()Ljava/lang/String;");    // signature
        fString((JTYPE)stringValue, petype);
}

static void fIUnknown(JTYPE javaval, PETYPE petype)
{
    // TODO what about the iid param
    IUnknown *punk = convert_Java_Object_to_IUnknown(javaval, &IID_IUnknown);
    if (punk != NULL)
    {
        V_VT(petype) = VT_UNKNOWN;
        V_UNKNOWN(petype) = punk;
    }
    else
        fStringViaToString(javaval, petype);
}

static void fVariant(JTYPE javaval, PETYPE petype)
{
    VARIANT *v = (VARIANT*) jcdwGetData(javaval);
    if (v != NULL)
        VariantCopy(petype, v);
}

static TypeFuncPair dispatchTable[] = {
    NULL,       fInteger,           "java/lang/Integer",
    NULL,       fString,            "java/lang/String",
    NULL,       fLong,              "java/lang/Long",
    NULL,       fFloat,             "java/lang/Float",
    NULL,       fDouble,            "java/lang/Double",
    NULL,       fBoolean,           "java/lang/Boolean",
    NULL,       fDate,              "java/util/Date",
    NULL,       fVariant,           "com/ms/com/Variant"
};



static int initialized = 0;

#define EXTERNC     extern "C"

#define JAVAMETHOD(typ, name) \
                              EXTERNC \
                              typ __cdecl com_ms_osp_ospmrshl_##name

DWORD __cdecl RNIGetCompatibleVersion()
{
    return RNIVER;
}

JAVAMETHOD(void, classInit) (OBJECT*x)
{
    int i;
    for (i = 0; i < sizeof(dispatchTable)/sizeof(TypeFuncPair); i++)
    {
        TypeFuncPair *pair = &dispatchTable[i];
        pair->type = FindClass(NULL, pair->className, TRUE);
        if (pair->type == NULL)
        {
            //          char buf[512];
            //          sprintf(buf, "Could not preload %s class!", pair->className);
            //          SignalErrorPrintf("java/lang/ClassNotFoundException", buf);
        }
    }
    initialized = 1;
}

//==========================================================================
// toJava/toJava64
//==========================================================================
#ifdef _WIN64
JAVAMETHOD(JTYPE, toJava64) (OBJECT*x, __int64 ppVariant, int flags)
#else
JAVAMETHOD(JTYPE, toJava) (OBJECT*x, int ppVariant, int flags)
#endif
{
    VARIANT *pVariant = *(PPETYPE)ppVariant;

    VARTYPE type = V_VT(pVariant) & ~VT_BYREF;
    int isByRef = V_ISBYREF(pVariant);

    if ( !initialized )
        com_ms_osp_ospmrshl_classInit(0);

    // question: can we safely ignore the VT_BYREF and assume that
    // the accessor macros will dereference for us?

    if (V_ISARRAY(pVariant) || V_ISVECTOR(pVariant))
        return NULL;

    switch (type)
    {
        case VT_UI1:
        case VT_I1:
        case VT_UI2:
        case VT_I2:
            //      case VT_UI4:
        case VT_I4:
        {
            int intVal = 0;
            switch(V_VT(pVariant))
            {
                case VT_UI1: intVal = (isByRef ? *V_UI1REF(pVariant) : V_UI1(pVariant)); break;
                case VT_I1 : intVal = (isByRef ? *V_I1REF (pVariant) : V_I1 (pVariant)); break;

                case VT_UI2: intVal = (isByRef ? *V_UI2REF(pVariant) : V_UI2(pVariant)); break;
                case VT_I2 : intVal = (isByRef ? *V_I2REF (pVariant) : V_I2 (pVariant)); break;

                             //             case VT_UI4: intVal = (isByRef ? *V_UI4REF(pVariant) : V_UI4(pVariant)); break;
                case VT_I4 : intVal = (isByRef ? *V_I4REF (pVariant) : V_I4 (pVariant)); break;
            }
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[IntegerClass].type,
                                            "(I)", intVal);
        }

        case VT_UI4:
        {
            __int64 intVal = (isByRef ? *V_UI4REF(pVariant) : V_UI4(pVariant));
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[LongClass].type,
                                            "(J)", intVal);
        }

        case VT_R4:
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[FloatClass].type, "(F)",
                                            (isByRef ? *V_R4REF(pVariant) : V_R4(pVariant)));

        case VT_R8:
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[DoubleClass].type, "(D)",
                                            (isByRef ? *V_R8REF(pVariant) : V_R8(pVariant)));

        case VT_CY:
            return NULL;  // TODO (mwagner) what to do about VT_CY (currency)
            break;

        case VT_BSTR:
        {
            BSTR string = (isByRef ? *V_BSTRREF(pVariant) : V_BSTR(pVariant));
            return (HObject*)makeJavaStringW(string, SysStringLen(string));
        }

        case VT_BOOL:
        {
            BOOL b = !!(isByRef ? *V_BOOLREF(pVariant) : V_BOOL(pVariant));
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[BooleanClass].type, "(Z)",
                                            b);
        }

        case VT_DATE:
        {
            double variantDate = (isByRef ? *V_DATEREF(pVariant) : V_DATE(pVariant));
            __int64 iDays = (__int64)variantDate;  // truncate, giving integral number of days
            __int64 iMS = (__int64)(variantDate - (double)iDays) * iSecondsPerDay * 1000;
            __int64 iJavaDate = (iDays * 1000) + iMS;  // millisecond units
            
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[DateClass].type, "(J)",
                                            iJavaDate);       
        }

        case VT_VARIANT:
#ifdef _WIN64
            return com_ms_osp_ospmrshl_toJava64(x, (INT_PTR)&V_VARIANTREF(pVariant), flags);
#else
            return com_ms_osp_ospmrshl_toJava(x, (INT_PTR)&V_VARIANTREF(pVariant), flags);
#endif

        case VT_DISPATCH:
        {
            Hjava_lang_Object *retVal = NULL;
            IDispatch *pdisp = (isByRef ? *V_DISPATCHREF(pVariant) : V_DISPATCH(pVariant));
            IUnknown *punk = NULL;
            if (0 == pdisp->QueryInterface(IID_IUnknown, (void**)&punk))
            {
                retVal = convert_IUnknown_to_Java_Object(punk, NULL, 1);
                punk->Release();
            }
            return retVal;
            break;
        }

        case VT_UNKNOWN:
        {
            IUnknown *punk = (isByRef ? *V_UNKNOWNREF(pVariant) : V_UNKNOWN(pVariant));
            return convert_IUnknown_to_Java_Object(punk, NULL, 1);
        }

        case VT_ARRAY:
        case VT_BYREF:
            
        case VT_ERROR:
        case VT_NULL:
        case VT_EMPTY:

        default:
        {
            return NULL;
        }
    }
}


//==========================================================================
// copyToExternal/copyToExternal64
//==========================================================================

#ifdef _WIN64
JAVAMETHOD(void, copyToExternal64) (OBJECT*x, JTYPE javaval, __int64 ppetype, 
int flags)
#else
JAVAMETHOD(void, copyToExternal) (OBJECT*x, JTYPE javaval, int ppetype, int 
flags)
#endif
{
    PETYPE petype = *(PPETYPE)ppetype;
    int i;
    JTYPE preservedValues[2] = { NULL, (JTYPE)-1 };
    GCFrame frame;
    GCFramePush(&frame, &preservedValues, sizeof(javaval));
    preservedValues[0] = javaval;

    BOOL fDone = FALSE;

    if ( !initialized )
        com_ms_osp_ospmrshl_classInit(0);

    if (preservedValues[0] == NULL)
    {
        V_VT(petype) = VT_NULL;
    }
    else {
        for (i = 0; i < sizeof(dispatchTable)/sizeof(TypeFuncPair); i++)
        {
            const TypeFuncPair *pair = &dispatchTable[i];
            if ( pair->type && is_instance_of(preservedValues[0], pair->type, NULL) )
            {
                (*pair->func)(preservedValues[0], petype);
                fDone = TRUE;
            }
        }
        if (!fDone)
            fIUnknown(preservedValues[0], petype); // could also be fStringViaToString(javaval, petype);
    }
    GCFramePop(&frame);
}

//==========================================================================
// releaseByValExternal/releaseByValExternal64
//==========================================================================
#ifdef _WIN64
JAVAMETHOD(void, releaseByValExternal64) (OBJECT*x, __int64 ppetype, int flags)
#else
JAVAMETHOD(void, releaseByValExternal) (OBJECT*x, int ppetype, int flags)
#endif
{
    PETYPE petype = *(PPETYPE)ppetype;
    VariantClear(petype);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\unixposition.cxx ===
//--------------------------------------------------------------------
// IRowPosition class
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       position.cxx
//  Author:     Charles Frankston (cfranks)
//
//  Contents:   CRowPosition object implementation
//

#include <dlaypch.hxx>
#pragma hdrstop

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include <connect.hxx>
#include <coredisp.h>
#include "unixposition.hxx"

#ifdef ROWPOSITION_DELETE
IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CRowPosition::MyRowsetNotify,
                                   CRowPosition, _RowsetNotify);

// Gee, why doesn't the macro above give us one of these??
STDMETHODIMP
CRowPosition::MyRowsetNotify::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IRowsetNotify))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
    }
    
    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

#endif  // ROWPOSITION_DELETE

const CONNECTION_POINT_INFO CRowPosition::s_acpi[] =
{
    CPI_ENTRY(IID_IRowPositionChange, DISPID_A_ROWPOSITIONCHANGESINK)
    CPI_ENTRY_NULL
};

const CRowPosition::CLASSDESC CRowPosition::s_classdesc =
{
        NULL,                           // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                              // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
};

//+---------------------------------------------------------------------------
//  Member:     GetClassDesc (public member)
//
//  Synopsis:   Return the class descriptor, we only use the descriptor to
//              describe the number of connection points our container can
//              handle and the connection points.
//
//  Arguments:  None
//
//  Returns:    CLASSDESC
//

const CBase::CLASSDESC *
CRowPosition::GetClassDesc () const
{
    return &s_classdesc;
}


STDMETHODIMP
CRowPosition::PrivateQueryInterface (REFIID riid, LPVOID * ppv)
{

    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IPrivateUnknown *)this;
    }
#define TEST(IFace) else if (IsEqualIID(riid, IID_##IFace)) *ppv = (IFace *)this

    TEST(IRowPosition);

#undef TEST

    else if (IsEqualIID(riid, IID_IConnectionPointContainer))
    {
        *((IConnectionPointContainer **)ppv) =
                                            new CConnectionPointContainer(this, NULL);
        if (!*ppv)
        {
            RRETURN(E_OUTOFMEMORY);
        }
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//  Member:     Passivate()
//
//  Synopsis:   Called from our base class's release (CBase::Release).
//              Clean ourselves up in preparation for destruction.
//
//  Arguments:  None
//
//  Returns:    None

void
CRowPosition::Passivate()
{
    ReleaseResources();
    super::Passivate();
}

//+---------------------------------------------------------------------------
//  Member:     ReleaseResources()      (protected helper
//
//  Synopsis:   Release my resources
//
//  Arguments:  None
//
//  Returns:    None

void
CRowPosition::ReleaseResources()
{
    if (_pCP)
    {
        _pCP->Unadvise(_wAdviseCookie);
        ClearInterface(&_pCP);
    }

    if (_pRowset)
    {
#ifdef ROWPOSITION_DELETE
        ReleaseBookmarkAccessor();
        ClearInterface(&_pRowsetLocate);
#endif

        // Special code for our cleanup
        if (_hRow != DB_NULL_HROW)
        {
            _pRowset->ReleaseRows(1, &_hRow, NULL,
                                  NULL, NULL);    
            _hRow = NULL;
        }

        if (_pChapRowset &&_hChapter != DB_NULL_HCHAPTER)
        {
            _pChapRowset->ReleaseChapter(_hChapter, NULL);
        }
        
        ClearInterface(&_pChapRowset);
        ClearInterface(&_pRowset);
    }
}

//+---------------------------------------------------------------------------
//  Member:     Init (public member)
//
//  Synopsis:   Initializes a newly create CRowPosition.
//              We initialize most things here rather than in the constructor
//              so we can do better error checking.
//
//  Arguments:  pRowSet             Pointer to the IRowset we're on top of.
//
//  Returns:    S_OK                if everything is fine,
//

HRESULT
CRowPosition::Initialize(IUnknown *pRowset)
{
    HRESULT hr;
    IConnectionPointContainer *pCPC = NULL;

#ifdef ROWPOSITION_DELETE
    Assert(_pRowsetLocate == NULL && _Bookmark.ptr==NULL && _pAccessor==NULL &&
           _hAccessorBookmark==NULL && "IRowPosition init'd more than once.");
#endif

    Assert(_pRowset==NULL && _pCP==NULL && 
           _hRow==NULL && "IRowPosition init'd more than once.");

    if (!pRowset)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    hr =  pRowset->QueryInterface(IID_IRowset, (LPVOID *)&_pRowset);
    if (FAILED(hr)) goto Error;

    IGNORE_HR(pRowset->QueryInterface(IID_IChapteredRowset, (LPVOID *)&_pChapRowset));

#ifdef ROWPOSITION_DELETE

    hr = _pRowset->QueryInterface(IID_IRowsetLocate, (void **)&_pRowsetLocate);
    if (FAILED(hr)) goto Error;

    hr = _pRowset->QueryInterface(IID_IConnectionPointContainer, (void **)&pCPC);
    if (pCPC)
    {
        hr = pCPC->FindConnectionPoint(IID_IRowsetNotify, &_pCP);
        if (_pCP)
        {
            hr = _pCP->Advise((IUnknown *)&_RowsetNotify, &_wAdviseCookie);
            if (FAILED(hr))
            {
                ClearInterface(&_pCP);  // make sure we don't DeAdvise
            }
        }
        ClearInterface(&pCPC);
    }

    if (FAILED(hr)) goto Error;

    // Initialize and remember bookmark accessor.
    hr = CreateBookmarkAccessor();
    if (FAILED(hr)) goto Error;

#endif



Cleanup:
    return hr;

Error:
    ReleaseResources();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//  Member:     GetRowset (public member)
//
//  Synopsis:   returns an interface pointer from the rowset we're on top of.
//              Note this does a QI on that interface, remember to release!
//
//  Arguments:  iid             the IID of the interface we want.
//              *ppIUnknown     pointer to the interface requested
//
//  Returns:    S_OK                if everything is fine,
//
STDMETHODIMP
CRowPosition::GetRowset(REFIID riid, LPUNKNOWN *ppIUnknown)
{
    HRESULT hr;

    if (_pRowset)
    {
        hr = _pRowset->QueryInterface(riid, (void **)ppIUnknown);
    }
    else
    {
        Assert(FALSE && "Rowset disappeared?");
        hr = E_UNEXPECTED;
    }
    return hr;
};

STDMETHODIMP
CRowPosition::ClearRowPosition()
{
    HRESULT hr;
    int iProgress=0;                    // track # of sinks.

    if (!_pRowset || _fCleared)
        return E_UNEXPECTED;

    // First, OKTODO..
    hr = FireRowPositionChange(DBREASON_ROWPOSITION_CLEARED, DBEVENTPHASE_OKTODO, 0, &iProgress);   
    if (CANCELLED(hr))
        goto Cancel;

    // Then ABOUTTODO
    iProgress = 0;
    hr = FireRowPositionChange(DBREASON_ROWPOSITION_CLEARED,  DBEVENTPHASE_ABOUTTODO, 0, &iProgress);
    if (CANCELLED(hr))
        goto Cancel;

    // release our hold on the HROW
    if (_hRow != DB_NULL_HROW)
        _pRowset->ReleaseRows(1, &_hRow, NULL, NULL, NULL);
    
    // set internal state
    _fCleared = TRUE;   
    _hRow = DB_NULL_HROW;
    _dwPositionFlags = DBPOSITION_NOROW;

    return NOERROR;

Cancel: 
    // If Change was cancelled, we fire a FAILEDTODO event.
    FireRowPositionChange(DBREASON_ROWPOSITION_CLEARED, DBEVENTPHASE_FAILEDTODO, 1, &iProgress);
    // UNDONE:  we aren't turning off events yet per connection
    return DB_E_CANCELED;             // User cancelled
};


STDMETHODIMP
CRowPosition::SetRowPosition(HCHAPTER hChapter, HROW hRow, DBPOSITIONFLAGS dwPositionFlags)
{
    HRESULT hr;
    int iProgress=0;                    // track # of sinks.
    int iDummy=0;
    DBREASON eReason = DBREASON_ROWPOSITION_CHANGED;

    if (!_pRowset || !_fCleared)
        return E_UNEXPECTED;

    if( (hRow && dwPositionFlags != DBPOSITION_OK) || 
        (!hRow && dwPositionFlags == DBPOSITION_OK) )
        return E_INVALIDARG;

    // AddRef the new hRow
    // UNDONE:  Is it the client's duty to addref the hRow before
    // returning it back from Move?
    if (hRow!=DB_NULL_HROW) 
    {
        hr = _pRowset->AddRefRows(1, &hRow, NULL, NULL);
        if( FAILED(hr) )
            return DB_E_BADROWHANDLE;
    }

    if (_hChapter != hChapter)
    {
        if (_pChapRowset)
        {
            if (hChapter != DB_NULL_HCHAPTER)
                _pChapRowset->AddRefChapter(hChapter, NULL);
            if (_hChapter != DB_NULL_HCHAPTER)
                _pChapRowset->ReleaseChapter(_hChapter, NULL);
        }
        
        _hChapter = hChapter;   
        eReason = DBREASON_ROWPOSITION_CHAPTERCHANGED;
    }

    _hRow = hRow;               // make the change
    _dwPositionFlags = dwPositionFlags;

    // Do the SYNCHAFTER event.  This cannot be cancelled or fail!
    FireRowPositionChange(eReason, DBEVENTPHASE_SYNCHAFTER, 1, &iDummy);

    iDummy = 0;
    // Do the DIDEVENT.  This cannot be cancelled or fail!
    FireRowPositionChange(eReason, DBEVENTPHASE_DIDEVENT, 1, &iDummy);

    // reset
    _fCleared = FALSE;

    return NOERROR;
}

//+---------------------------------------------------------------------------
//  Member:     GetRowPosition (public member)
//
//  Synopsis:   Gets our current position in the Rowset (as an hRow).
//              AddRefRows the hRow.  CALLER MUST ReleaseRows!!
//
//  Arguments:  hRow            current hRow position
//
//  Returns:    S_OK            if everything is fine,
//
STDMETHODIMP
CRowPosition::GetRowPosition(HCHAPTER *phChapter, HROW *phRow,
                             DBPOSITIONFLAGS *pdwPositionFlags)
{
    if (!_pRowset)
        return E_UNEXPECTED;

    if (phRow)
    {
        if (_hRow != DB_NULL_HROW)
        {
            _pRowset->AddRefRows(1, &_hRow, NULL, NULL);
        }

        *phRow = _hRow;
    }

    if (phChapter)
    {
        if (_hChapter != DB_NULL_HCHAPTER)
        {
            if (_pChapRowset)
            {
                _pChapRowset->AddRefChapter(_hChapter, NULL);
            }
        }

        *phChapter = _hChapter;
    }

    if (pdwPositionFlags)
    {
        *pdwPositionFlags = _dwPositionFlags;
    }

    return S_OK;
};

#ifdef ROWPOSITION_DELETE
//+---------------------------------------------------------------------------
//  Member: CreateBookMarkAccessor (private)
//
//  Synopsis:   Helper function to create the Bookmark Accessor
//  
//  Arguments:  none, uses member variables.
//
//  Returns:    S_OK            if everything is fine,
//
HRESULT
CRowPosition::CreateBookmarkAccessor()
{
    HRESULT       hr=E_FAIL;            // if we can't QI IAccessor!
    DBBINDING     dbind;

    Assert(_hAccessorBookmark==NULL);   // Already init'd??

    hr = _pRowset->QueryInterface(IID_IAccessor,
                                  (void **)&_pAccessor);
    if (_pAccessor)
    {
        dbind.iOrdinal = 0;         // columns 0 must mean Bookmark
        dbind.obValue = 0;          // offset to value
        dbind.obLength = 0;         // ignored, no DBPART_LENGTH
        dbind.obStatus = 0;         // ignored no DBPART_STATUS
        dbind.pTypeInfo = NULL;     // spec sez set to null
        dbind.pObject = NULL;       // ignored unless DBTYPE_IUNKNOWN
        dbind.pBindExt = NULL;      // spec sez set to null
        dbind.dwPart = DBPART_VALUE;
        dbind.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
        dbind.eParamIO = DBPARAMIO_NOTPARAM;
        dbind.cbMaxLen = 0;         // not used for DBTYPE_VECTOR
        dbind.dwFlags = 0;          // spec sez set to 0
        dbind.wType = (DBTYPE_UI1 | DBTYPE_VECTOR);
        hr = _pAccessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                        1, &dbind, 0,
                                        &_hAccessorBookmark,
                                        NULL /*rgStatus*/);
        if (FAILED(hr))
        {
            ClearInterface(&_pAccessor);
        }
    } // _pAccessor

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ClearBookmark
//
//  Synopsis:  Helper function to de-allocate any bookmarks we might have,
//             because we need this in a few places.
//
//  Arguments: uses member variables.
//

void
CRowPosition::ClearBookmark()
{
    if (_Bookmark.ptr)
    {
        CoTaskMemFree(_Bookmark.ptr);
        _Bookmark.ptr = NULL;
    }
}

//+-----------------------------------------------------------------------
//
//  Member:   ReleaseBookmarkAccessor
//
//  Synopsis:  Helper function to destroy the bookmark accessor.
//
//  Arguments: uses member variables.
//

void
CRowPosition::ReleaseBookmarkAccessor()
{
    ULONG ulDontCare;

    ClearBookmark();
    if (_pAccessor && _hAccessorBookmark)
    {
        _pAccessor->ReleaseAccessor(_hAccessorBookmark, &ulDontCare);
        _hAccessorBookmark = NULL;
    }
    ClearInterface(&_pAccessor);
}
#endif

//+---------------------------------------------------------------------------
//  Member:     CRowPosition::FireRowPositionChange
//
//  Synopsis:   Helper routine to Fire change notices to all of our clients.
//
//  Arguments:  eReason [in]     reason for event
//              ePhase [in]      which notification phase this is
//              fCantDeny [in]   TRUE iff client can cancel this phase
//              piProgress [in]  send this event to the first iProgress sinks
//                        [out]  on output: decremented by the number of sinks,
//                               stop firing when count reaches 0.  We always
//                               fire at least one event however.
//
//  Returns:    S_OK             client accepts change
//              S_FALSE          client wants to cancel change
//              S_UNWANTEDPHASE  client doesn't want any more phase notifications
//                               (caller doesn't have to comply)
//              S_UNWANTEDREASON client doesn't want any more of this reason
//                               (caller doesn't have to comply)
//

HRESULT
CRowPosition::FireRowPositionChange(DBREASON eReason,
                                    DBEVENTPHASE ePhase,
                                    BOOL fCantDeny,
                                    int *piProgress)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    NOTIFY_STATE    ns;

    DWORD pdwCookie = 0;                // cookie for GetNextSink
    IRowPositionChange *pRPC=NULL;      // Notification we fire.

    aaidx = AA_IDX_UNKNOWN;

    ns = EnterNotify(eReason, DBEVENTPHASE_DIDEVENT);

    for (;;)
    {
        aaidx = FindNextAAIndex(DISPID_A_ROWPOSITIONCHANGESINK, 
                                CAttrValue::AA_Internal, 
                                aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;

        ClearInterface(&pRPC);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRPC)))
        {
            hr = pRPC->OnRowPositionChange(eReason, ePhase, fCantDeny);

            // Have we fired all we're supposed to yet?
            if (--*piProgress==0) break;

            // Stop upon the first event that fails, or was cancelled.
            // We don't stop on (or propagate upward) DB_S_UNWANTEDPHASE
            // or DB_S_UNWANTED REASON.
            if (FAILED(hr) || (hr==S_FALSE && !fCantDeny))
            {
                // flip piProgress, so if we're called again with the same
                // iProgress, we fire only as many events as we did this time.
                // (Note iProgress actually represents # sinks fired+1).
                *piProgress = -*piProgress;
                goto Cleanup;
            }

        }
    }

    // If we fired events to all sinks without error or cancel.
    *piProgress = 0;

Cleanup:
    LeaveNotify(eReason, DBEVENTPHASE_DIDEVENT, ns);

    ReleaseInterface(pRPC);
    RRETURN(hr);
}

#ifdef ROWPOSITION_DELETE
//+---------------------------------------------------------------------------
//  Member:     MyRowsetNotify::OnChapterChange
//
//  Synopsis:   Implemenation of IRowsetNotify::OnRowChange
//              This doesn't do anything.
//

// We're not interested in OnFieldChange
STDMETHODIMP
CRowPosition::MyRowsetNotify::OnFieldChange (IRowset *pRowset,
                                             HROW hRow,
                                             ULONG cColumns,
                                             ULONG aColumns[],
                                             DBREASON eReason,
                                             DBEVENTPHASE ePhase,
                                             BOOL fCantDeny)
{
    return DB_S_UNWANTEDREASON;
}

//+---------------------------------------------------------------------------
//  Member:     MyRowsetNotify::OnRowChange
//
//  Synopsis:   Implemenation of IRowsetNotify::OnRowChange
//              Looks for ROw_DELETE notifications in case they affect the hRow
//              we're currently on, in which case we pass them along.
//
//  Arguments:  hRow            new hRow position
//
//  Returns:    S_OK                if everything is fine,
//
// We are interested in OnRowChange
STDMETHODIMP
CRowPosition::MyRowsetNotify::OnRowChange (IRowset *pRowset,
                                         ULONG cRows,
                                         const HROW ahRows[],
                                         DBREASON eReason,
                                         DBEVENTPHASE ePhase,
                                         BOOL fCantDeny)
{
    HRESULT thr, hr = S_OK;
    ULONG cRowsObt, i;
    HROW * phRow;
    int iDummy=0;
    // We need a pointer to our containing class..
    CRowPosition *pCRP = CONTAINING_RECORD(this, CRowPosition, _RowsetNotify);
    
    // We only care about the DELETE notification because,
    // only the Delete notification can change the current position.
    if (eReason!=DBREASON_ROW_DELETE)
    {    
        hr = DB_S_UNWANTEDREASON;
        goto Cleanup;
    }

    if (!pCRP->_pRPCSink)               // Do we have any sinks?
    {
        goto Cleanup;                   // No, pointless to continue.
    }

    // For each hRow in the ahRows array,
    for (i=0; i!=cRows; i++)
    {
        // ignore if it doesn't match our current row.
        if (ahRows[i] != pCRP->_hRow)
            continue;
            
        // Our "current row" is the one being deleted.
        // Propogate the notifications to our clients.
        thr = pCRP->FireRowPositionChange(eReason, ePhase, fCantDeny,
                                          &iDummy);

        // Vetos are allowed only when our source says so..
        if (!fCantDeny && thr==S_FALSE )
        {
            hr = S_FALSE; // our client veto'd this change

            // Won't need bookmark anymore (if we had one).
            // (Note if our source is behaving properly, it should send
            // us a FAILEDTODO event, which would also clear the bookmark,
            // but its probably more reliable to not depend on this).
            pCRP->ClearBookmark();
        }
        else
        {
            switch (ePhase)
            {
              case (DBEVENTPHASE_ABOUTTODO):
                // Get a bookmark for the current hRow.
                pCRP->ClearBookmark(); // kill any previous

                // Try to get a bookmark.  If we fail, the
                // DIDEVENT phase is robust, so ignore HR here.
                pCRP->_pRowset->GetData(pCRP->_hRow, pCRP->_hAccessorBookmark,
                                         &pCRP->_Bookmark);
                break;

              case(DBEVENTPHASE_DIDEVENT):
                phRow = &pCRP->_hRow;
                // Make sure to decrement refcount of old _hRow..
                if (*phRow!=NULL)
                {
                    pCRP->_pRowset->ReleaseRows(1, phRow, NULL, NULL, NULL);
                    *phRow = NULL; // Null it out now.
                }

                // Make sure we really have a bookmark.
                if (!pCRP->_Bookmark.ptr) break;

                if (!pCRP->_pRowsetLocate) break;

                thr = pCRP->_pRowsetLocate->GetRowsAt(NULL, NULL,
                                                      pCRP->_Bookmark.size,
                                                      (BYTE *)pCRP->_Bookmark.ptr,
                                                      0, // lRowsOffset 
                                                      1, // cRows [in]
                                                      &cRowsObt, // [out]
                                                      &phRow);

                if (thr==DB_S_ENDOFROWSET) // off the end?
                {
                    // Hmm, try it backwards this time.
                    pCRP->_pRowsetLocate->GetRowsAt(NULL, NULL, 
                                                    pCRP->_Bookmark.size,
                                                    (BYTE *)pCRP->_Bookmark.ptr,
                                                    0, // lRowsOffset 
                                                    -1,  // cRows [in]
                                                    &cRowsObt, //[out]
                                                    &phRow);
                } // DB_S_ENDOFROWSET

                pCRP->ClearBookmark(); // We're done with the bookmark
                break;

              case(DBEVENTPHASE_FAILEDTODO):
                // Something failed, make sure bookmark is cleared.
                  pCRP->ClearBookmark();
                  break;

            } // switch ePhase

        } // else for change veto'd

        break;                      // out of for loop..

    }                                   // for (ULONG i=0; i!=cRows; i++)

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     MyRowsetNotify::OnRowsetChange
//
//  Synopsis:   Implementation of IRowsetNotify::OnRowsetChange
//              Currently, the only eReason is ROWSET_RELEASE.  We can never get
//              one of these because if we're still connected, the row position
//              can't go away.
//
//  Arguments:  hRow            new hRow position
//
//  Returns:    S_OK                if everything is fine,
//
STDMETHODIMP
CRowPosition::MyRowsetNotify::OnRowsetChange (IRowset *pRowset,
                                              DBREASON eReason,
                                              DBEVENTPHASE ePhase,
                                              BOOL fCantDeny)
{
    Assert(eReason!=DBREASON_ROWSET_RELEASE && "Impossible event");
    return DB_S_UNWANTEDREASON;

#ifdef never
    CRowPosition *pCRP = CONTAINING_RECORD(this, CRowPosition, _RowsetNotify);

    // The whole rowset is going away.
    // Propagate the notification to our clients.
    IGNORE_HR(pCRP->FireRowPositionChange(eReason, ePhase, fCantDeny));
    
    // Make sure to decrement refcount of our _hRow so rowset cleans up
    // nicely.
    if (pCRP->_hRow!=NULL)
    {
        IGNORE_HR(pCRP->_pRowset->ReleaseRows(1, &pCRP->_hRow,
                                              NULL, NULL, NULL));
        pCRP->_hRow = NULL;
    }
    return S_OK;
#endif    
}

//+------------------------------------------------------------------------
//
//  Member:     CreateRowPosition
//
//  Synopsis:   Creates a new RowPosition instance.
//
//  Arguments:  pUnkOuter   Outer unknown -- must be NULL
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


#endif

#ifdef UNIX
CBase * STDMETHODCALLTYPE
CreateRowPosition(IUnknown * pUnkOuter)
{
    CBase * pBase;
    Assert(!pUnkOuter);
    pBase = new CRowPosition();
    return(pBase);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\trdntosp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       TRDNTOSP.CXX
//
//  Contents:   Object for HTML based OSP
//
//  Classes:    (part of) CDoc
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include "simpdata.h"
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include "msdatsrc.h"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

MtDefine(TridentOSP, DataBind, "TridentOSP")
MtDefine(TridentOSP_apaBSTRtagData_pv, TridentOSP, "TridentOSP::_apaBSTRtagData::_pv")
MtDefine(TridentOSPInit_pDataColumn, Locals, "TridentOSP::Init pDataColumn")
MtDefine(TridentOSPInit_pDataColumn_pv, Locals, "TridentOSP::Init pDataColumn::_pv")

BEGIN_TEAROFF_TABLE(CDoc, DataSource)
    TEAROFF_METHOD(CDoc, getDataMember, getdatamember, (DataMember bstrDM, REFIID riid, IUnknown **ppunk))
    TEAROFF_METHOD(CDoc, getDataMemberName, getdatamembername, (long lIndex, DataMember *pbstrDM))
    TEAROFF_METHOD(CDoc, getDataMemberCount, getdatamembercount, (long *plCount))
    TEAROFF_METHOD(CDoc, addDataSourceListener, adddatasourcelistener, (DataSourceListener *pDSL))
    TEAROFF_METHOD(CDoc, removeDataSourceListener, removedatasourcelistener, (DataSourceListener *pDSL))
END_TEAROFF_TABLE()

class TridentOSP:OLEDBSimpleProvider
{ 
public:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(TridentOSP))

// Constructors
    TridentOSP(CDoc *pDoc);

// Destructor
    ~TridentOSP();

// Initializer
    HRESULT Init();
// IOLEDBSimpleProvider
    
    virtual HRESULT STDMETHODCALLTYPE getRowCount(DBROWCOUNT *pcRows);
    virtual HRESULT STDMETHODCALLTYPE getColumnCount(DB_LORDINAL *pcColumns);
    virtual HRESULT STDMETHODCALLTYPE getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPRW *prwStatus);
    virtual HRESULT STDMETHODCALLTYPE getVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT *pVar);
    virtual HRESULT STDMETHODCALLTYPE setVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT Var);
    virtual HRESULT STDMETHODCALLTYPE getLocale(BSTR *pbstrLocale);
    virtual HRESULT STDMETHODCALLTYPE deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted);
    virtual HRESULT STDMETHODCALLTYPE insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted);
    virtual HRESULT STDMETHODCALLTYPE find(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val, OSPFIND findflags, OSPCOMP compType, DBROWCOUNT *piRowFound);
    virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE isAsync(BOOL *pbAsynch);
    virtual HRESULT STDMETHODCALLTYPE getEstimatedRows(DBROWCOUNT *piRows);
    virtual HRESULT STDMETHODCALLTYPE stopTransfer(void);

//  IUnknown Interfaces
    virtual HRESULT __stdcall QueryInterface(const IID& iid, void **ppv);
    virtual ULONG __stdcall AddRef();
    virtual ULONG __stdcall Release();

private:
    long _refCount;
    long _rowCount;
    CDoc *_pDoc;
    OLEDBSimpleProviderListener *_pospMyListener;
    CDataAry< CDataAry<BSTR> *> _apaBSTRtagData;

#ifdef OBJCNTCHK
    DWORD _dwObjCnt;
#endif

};


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::TridentOSP(CDoc *pDoc)
//
//  Synopsis:   Class constructor which takes a pointer to CDoc, gets the 
//              IHTML Collection and stores the tags with ID's in a dynamically
//              allocated array of type CDataAry. Called upon "new TridentOSP"
//
//  Returns:    no return value
//
//-------------------------------------------------------------------------

TridentOSP::TridentOSP(CDoc *pDoc)
    : _apaBSTRtagData(Mt(TridentOSP_apaBSTRtagData_pv))
{
    _pDoc = pDoc;

// reference counting
    _refCount = 1;
    _rowCount = 0;
    _pDoc->SubAddRef();
    IncrementObjectCount(&_dwObjCnt);

    return;
}

HRESULT
TridentOSP::Init() 
{   
    long i, j, dataLength, dataIndex;
    HRESULT hr;
    VARIANT v, vEmpty;
    IDispatch *pout = NULL;
    IHTMLElement *pout2 = NULL;
    
    CDataAry<BSTR> *pDataColumn, *pDataPtr;
    IHTMLElementCollection *pElementCollection; 
    dataIndex = 0;


//initialization of 2D tag data array

    _pDoc->PrimaryMarkup()->GetCollection(CMarkup::ELEMENT_COLLECTION, &pElementCollection);
    hr = pElementCollection->get_length(&dataLength);
    if(hr)
        return hr;

    V_VT(&vEmpty) = VT_EMPTY;
    V_VT(&v) = VT_I4;

    for (i = 0; i < dataLength; i++) 
    {
        BSTR pstrID = NULL, pstrData = NULL;

        V_I4(&v) = i;
        hr = pElementCollection->item(v, vEmpty, &pout);
        if(hr)
            goto Cleanup;

        pout->QueryInterface(IID_IHTMLElement, (void **)&pout2);
        hr = pout2->get_id(&pstrID);
        if (hr)
            goto Cleanup;

        hr = pout2->get_innerHTML(&pstrData);
        // <HTML> tag gives hr error on get_innerHTML.  Must check ht value and make sure tag is not
        // empty
        if(pstrID && !hr)
        {
            pDataColumn = NULL;
            
            for ( j = 0; j < _apaBSTRtagData.Size(); j++)
            { 
                // Search for a duplicate tag ID in existing structure
                pDataPtr = _apaBSTRtagData.Item(j);

                if (! _tcscmp(pstrID, pDataPtr->Item(0)))       
                    pDataColumn = pDataPtr;
            }

            if (!pDataColumn)
                {       // no match.  Insert new tag id to _apaBSTRtagData
                pDataColumn = new(Mt(TridentOSPInit_pDataColumn)) CDataAry<BSTR>(Mt(TridentOSPInit_pDataColumn_pv));
                if (pDataColumn)
                {
                    _apaBSTRtagData.InsertIndirect(dataIndex, &pDataColumn);
                    pDataColumn->InsertIndirect(0, &pstrID);      
                    dataIndex++; 
                }
            }

            if (pDataColumn)
            {
                pDataColumn->InsertIndirect(pDataColumn->Size(), &pstrData);
                    if (pDataColumn->Size()-1 > _rowCount)
                    _rowCount = pDataColumn->Size()-1;          
            }
        }
        else
        {
           if(pstrData)
               SysFreeString(pstrData);
           if(pstrID)
               SysFreeString(pstrID);
        }

        ClearInterface(&pout);
        ClearInterface(&pout2);
    }


Cleanup:
    ReleaseInterface(pElementCollection);
    ReleaseInterface(pout);
    ReleaseInterface(pout2);

return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::~TridentOSP()
//
//  Synopsis:   Class deconstructor which releases the CDoc reference and 
//              decrements the object count
//
//  Returns:    no return value
//
//-------------------------------------------------------------------------

TridentOSP::~TridentOSP()
{
    CDataAry<BSTR> **pElem;

    int    i, j;

    for (i = _apaBSTRtagData.Size(), pElem = _apaBSTRtagData;
         i > 0;
         i--, pElem++)
    {
        for (j = (*pElem)->Size()-1;
             j >= 0;
             j--)  
        {
             SysFreeString((*pElem)->Item(j));
        }

        (*pElem)->DeleteAll();
        delete *pElem;        
    }
    _apaBSTRtagData.DeleteAll();

    _pDoc->SubRelease();
    DecrementObjectCount(&_dwObjCnt);
    ReleaseInterface(_pospMyListener);
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getRowCount(long *pcRows)
//
//  Synopsis:   Returns the number of rows of data.   For now, the number of 
//              rows is only 2, but future revisions will allow access of 
//              multiple rows for duplicate tag ID's 
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getRowCount(DBROWCOUNT *pcRows)
{
    *pcRows = _rowCount;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::GetColumnCount(long *pcColumns)
//
//  Synopsis:   Returns the number of columns in the _apaBSTRtagData structure
//              which corresponds to the number of non-empty, unique HTML Tag
//              ID's in the data source.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getColumnCount(DB_LORDINAL *pcColumns)
{
    *pcColumns = _apaBSTRtagData.Size();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getRWStatus(long iRow, long iColumn, OSPRW *prwStatus)
//
//  Synopsis:   Returns the Read/Write Status of the structure.   All elements
//              are read-only
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY;
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT *pVar)
//
//  Synopsis:   Gets the desired Variant from the data structure and returns it. 
//              Row 0 is the Tag ID, and any other row is the Inner HTML.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT *pVar)
{
    CDataAry<BSTR> *pDataColumn;
    BSTR tempBSTR;

    V_VT(pVar) = VT_BSTR;

    pDataColumn = _apaBSTRtagData.Item(iColumn - 1);

    if (iRow == 0)
    {
       tempBSTR = SysAllocString(pDataColumn->Item(0));
       V_BSTR(pVar) = tempBSTR;
    }

    else
    {   
        if (iRow >= pDataColumn->Size())
            tempBSTR = SysAllocString(_T(""));
        else
            tempBSTR = SysAllocString(pDataColumn->Item(iRow));
        
        V_BSTR(pVar) = tempBSTR;
    }       

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var)
//
//  Synopsis:   Unimplemented.   setVariant should never be called since all the 
//              elements are READONLY  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::setVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT Var)
{
    return E_FAIL;
}



//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getLocale(BSTR *pbstrLocale)
//
//  Synopsis:   Unimplemented.    
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getLocale(BSTR *pbstrLocale)
{
// TODO (t-trevs) this should be implemented
    *pbstrLocale = NULL;
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::deleteRows(long iRow, long cRows, long *pcRowsDeleted)
//
//  Synopsis:   Unimplemented.  Data structure is read-only.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted)
{
    *pcRowsDeleted = 0;
    return E_FAIL;
}



//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::insertRows(long iRow, long cRows, long *pcRowsInserted)
//
//  Synopsis:   Unimplemented.  Data structure is read-only.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted)
{
    *pcRowsInserted = 0;
    return E_FAIL;
}


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::find(long iRowStart, long iColumn, VARIANT val, 
//                               OSPFIND findflags, OSPCOMP compType, long *piRowFound)
//
//  Synopsis:   Unimplemented.   
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::find(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val, OSPFIND findflags, OSPCOMP compType, DBROWCOUNT *piRowFound)
{
// TODO (t-trevs) we should probably implement TridentOSP::Find()
    return E_FAIL;
}



//+------------------------------------------------------------------------
//
//  Member:    addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
//
//  Synopsis:   Sets current OLEDBSimpleProviderListener to input pointer.   Sets
//              the member variable.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    _pospMyListener = pospIListener;
    pospIListener->AddRef();
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
//
//  Synopsis:   removes the current listener and releases the interface.  Clears the 
//              member variable.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    Assert(_pospMyListener == pospIListener);
    _pospMyListener = NULL;
    ReleaseInterface(pospIListener);

    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::isAsync(BOOL *pbAsynch)
//
//  Synopsis:   Implementation does not support Asynchronous data transfer 
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::isAsync(BOOL *pbAsynch)
{
    *pbAsynch = 0;
    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::getEstimatedRows(long *piRows)
//
//  Synopsis:   Returns unspecified estimation of rows  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getEstimatedRows(DBROWCOUNT *piRows)
{
    *piRows = -1;
    return S_OK;
}



//+------------------------------------------------------------------------
//  Member:     TridentOSP::stopTransfer(void)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::stopTransfer(void)
{
    return S_OK;
}




//+------------------------------------------------------------------------
//  Member:     TridentOSP::AddRef()
//
//  Synopsis:   Increments the Reference Count
//
//  Returns:    ULONG
//
//-------------------------------------------------------------------------


ULONG __stdcall
TridentOSP::AddRef()
{
    return ++_refCount;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::AddRef()
//
//  Synopsis:   Decrements the Reference Count and if reference count becomes
//              0, deletes the instance
//
//  Returns:    ULONG
//
//-------------------------------------------------------------------------

ULONG __stdcall
TridentOSP::Release()
{
    ULONG ulRefs = --_refCount;
    if (ulRefs == 0)
        delete this;

    return ulRefs;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::QueryInterface(const IID& iid, void **ppv)
//
//  Synopsis:   QueryInterface implementation for TridentOSP class
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT __stdcall
TridentOSP::QueryInterface(const IID& iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_OLEDBSimpleProvider)
    {
        _refCount++;
        *ppv = this;
        return S_OK;
    }
    
    return E_FAIL;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::getDataMember(DataMember bstrDM,REFIID riid, IUnknown **ppunk)
//
//  Synopsis:   sets ppunk to point to a new TridentOSP class.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------



HRESULT STDMETHODCALLTYPE
CDoc::getDataMember(DataMember bstrDM,REFIID riid, IUnknown **ppunk)
{
    HRESULT hr = S_OK;
    *ppunk = NULL;

    if (PrimaryMarkup()->GetReadyState() == READYSTATE_COMPLETE)
    {
        TridentOSP *pNew = new TridentOSP(this);
        if (pNew)
        {
            hr = pNew->Init();
            if ( !hr )
            {
                *ppunk = (IUnknown *) (void *) pNew;
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::getDataMemberName(long lIndex, DataMember *pbstrDM)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE 
CDoc::getDataMemberName(long lIndex, DataMember *pbstrDM)
{
    *pbstrDM = NULL;
    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::getDataMemberCount(long *plCount)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::getDataMemberCount(long *plCount)
{
    *plCount = NULL;
    return S_OK;
}

//+------------------------------------------------------------------------
//  Member:     CDoc::addDataSourceListener(DataSourceListener *pDSL)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::addDataSourceListener(DataSourceListener *pDSL)
{
    _pDSL = pDSL;
    pDSL->AddRef();
    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::removeDataSourceListener(DataSourceListener *pDSL)
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::removeDataSourceListener(DataSourceListener *pDSL)
{
    Assert(_pDSL == pDSL);
    _pDSL = NULL;
    ReleaseInterface(pDSL);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\advdisp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       advdisp.cxx
//
//  Contents:   Advanced display features
//
//  Classes:    CAdvancedDisplay
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ADVDISP_HXX_
#define X_ADVDISP_HXX_
#include "dispnode.hxx"
#endif


MtDefine(CAdvancedDisplay, DisplayTree, "CAdvancedDisplay");
MtDefine(CAryDispClientInfo_pv, DisplayTree, "CAryDispClientInfo_pv");
MtDefine(CAdvancedDisplayIndex_pv, DisplayTree, "CAdvancedDisplayIndex_pv");
MtDefine(CAdvancedDisplayDrawProgram_pv, DisplayTree, "CAdvancedDisplayDrawProgram_pv");


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::CAdvancedDisplay
//
//  Synopsis:   Construct an advanced display object owned by the given
//              disp node.  It takes over the pointer to the disp client.
//
//  Arguments:  pDispNode       my owner
//              pDispClient     the disp client
//
//  Notes:
//
//----------------------------------------------------------------------------


CDispNode::CAdvancedDisplay::CAdvancedDisplay(CDispNode *pDispNode, CDispClient *pDispClient)
{
    _pDispNode = pDispNode;
    _pDispClient = pDispClient;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::GetDrawProgram
//
//  Synopsis:   Construct a draw program for the disp node.
//
//  Arguments:  paryProgram     array for program
//              paryCookie      array for cookie arguments in the program
//
//  Notes:
//
//----------------------------------------------------------------------------

#define GrowArray(ary, size)   if (FAILED(ary.Grow(size))) return E_OUTOFMEMORY;

HRESULT
CDispNode::CAdvancedDisplay::GetDrawProgram(CAryDrawProgram *paryProgram,
                                            CAryDrawCookie *paryCookie,
                                            LONG lDrawLayers)
{
    int i;
    CAryDrawProgram& aryProgram = *paryProgram;
    CAryDrawCookie& aryCookie = *paryCookie;
    _aryDispClientInfo.DeleteAll();     // start from scratch
    const LONG lZOrder = _pDispNode->GetPainterInfo(&_aryDispClientInfo);

    if (_pDispNode->NeedAdvanced(&_aryDispClientInfo, lDrawLayers))
    {
        //
        // first sort the info list by the lZOrder field.
        //
        
        // Distribution Counting sort - it's stable (which we need)
        int count[HTMLPAINT_ZORDER_WINDOW_TOP + 1];
        memset(count, 0, sizeof(count));

        // count the occurrences of each zorder
        for (i=_aryDispClientInfo.Size()-1; i>=0; --i)
        {
            Assert(_aryDispClientInfo[i]._sInfo.lZOrder < ARRAY_SIZE(count));
            ++ count[_aryDispClientInfo[i]._sInfo.lZOrder];
        }

        // accumulate the counts in the desired order
        count[HTMLPAINT_ZORDER_REPLACE_ALL]         +=  count[HTMLPAINT_ZORDER_NONE];
        count[HTMLPAINT_ZORDER_REPLACE_BACKGROUND]  +=  count[HTMLPAINT_ZORDER_REPLACE_ALL];
        count[HTMLPAINT_ZORDER_REPLACE_CONTENT]     +=  count[HTMLPAINT_ZORDER_REPLACE_BACKGROUND];
        count[HTMLPAINT_ZORDER_BELOW_CONTENT]       +=  count[HTMLPAINT_ZORDER_REPLACE_CONTENT];
        count[HTMLPAINT_ZORDER_BELOW_FLOW]          +=  count[HTMLPAINT_ZORDER_BELOW_CONTENT];
        count[HTMLPAINT_ZORDER_ABOVE_FLOW]          +=  count[HTMLPAINT_ZORDER_BELOW_FLOW];
        count[HTMLPAINT_ZORDER_ABOVE_CONTENT]       +=  count[HTMLPAINT_ZORDER_ABOVE_FLOW];
        count[HTMLPAINT_ZORDER_WINDOW_TOP]          +=  count[HTMLPAINT_ZORDER_ABOVE_CONTENT];

        // create the mapping into the original array
        CStackDataAry<int, 8> aryIndex(Mt(CAdvancedDisplayIndex_pv));
        GrowArray(aryIndex, _aryDispClientInfo.Size());
        for (i=_aryDispClientInfo.Size()-1; i>=0; --i)
        {
            aryIndex[--count[_aryDispClientInfo[i]._sInfo.lZOrder]] = i;
        }

        //
        // now write the draw program
        //

        BOOL fReplaceAll = FALSE;
        BOOL fReplaceBackground = FALSE;
        BOOL fReplaceContent = FALSE;
        unsigned layerCurrent = DISPNODELAYER_BORDER;
        int iPC = DP_START_INDEX;
        int iCookie = 0;
        GrowArray(aryProgram, iPC);
        GrowArray(aryCookie, iCookie);

        for (i=0; i<=_aryDispClientInfo.Size(); ++i)
        {
            unsigned layerNext = DISPNODELAYER_POSITIVEZ;
            int iOp = DP_WindowTopMulti;
            long lZOrder = i==_aryDispClientInfo.Size() ? HTMLPAINT_ZORDER_WINDOW_TOP
                            : _aryDispClientInfo[aryIndex[i]]._sInfo.lZOrder;
            BOOL fExpand = i==_aryDispClientInfo.Size() ? FALSE :
                            (memcmp(&_aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand,
                                    &g_Zero.rc, sizeof(RECT)));
    
            // the extra iteration with lZOrder==WINDOW_TOP ensures that we
            // draw all the content.  We'll remove the last WINDOW_TOP instruction
            // afterward.

            switch (lZOrder)
            {
            case HTMLPAINT_ZORDER_NONE:
                break;

            case HTMLPAINT_ZORDER_REPLACE_ALL:
                if (!fReplaceAll)
                {
                    fReplaceAll = TRUE;
                    fExpand = TRUE;     // this replaces the borders as well
                    if (lDrawLayers & FILTER_DRAW_CONTENT)
                    {
                        if (fExpand)
                        {
                            GrowArray(aryProgram, iPC+5);
                            aryProgram[iPC++] = DP_Expand;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawPainterMulti;
                        GrowArray(aryCookie, iCookie+1);
                        aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                    }
                }
                break;

            case HTMLPAINT_ZORDER_REPLACE_BACKGROUND:
                if (!fReplaceAll && !fReplaceBackground)
                {
                    fReplaceBackground = TRUE;
                    if (lDrawLayers & FILTER_DRAW_BORDER)
                    {
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawBorder;
                    }
                    GrowArray(aryProgram, iPC+1);
                    aryProgram[iPC++] = DP_BoxToContent;
                    if (lDrawLayers & FILTER_DRAW_BACKGROUND)
                    {
                        if (fExpand)
                        {
                            GrowArray(aryProgram, iPC+5);
                            aryProgram[iPC++] = DP_Expand;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawPainterMulti;
                        GrowArray(aryCookie, iCookie+1);
                        aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                    }
                    layerCurrent = DISPNODELAYER_NEGATIVEINF;
                }
                break;

            case HTMLPAINT_ZORDER_REPLACE_CONTENT:
                if (!fReplaceAll && !fReplaceContent)
                {
                    fReplaceContent = TRUE;
                    if (!fReplaceBackground)
                    {
                        if (lDrawLayers & FILTER_DRAW_BORDER)
                        {
                            GrowArray(aryProgram, iPC+1);
                            aryProgram[iPC++] = DP_DrawBorder;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = (lDrawLayers & FILTER_DRAW_BACKGROUND)
                                        ? DP_DrawBackground : DP_BoxToContent;
                    }
                    if (lDrawLayers & FILTER_DRAW_CONTENT)
                    {
                        if (fExpand)
                        {
                            GrowArray(aryProgram, iPC+5);
                            aryProgram[iPC++] = DP_Expand;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawPainterMulti;
                        GrowArray(aryCookie, iCookie+1);
                        aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                    }
                }
                break;

                        // the shifts of layerNext set it to the desired value!
            case HTMLPAINT_ZORDER_BELOW_CONTENT:    layerNext >>= 1;
            case HTMLPAINT_ZORDER_BELOW_FLOW:       layerNext >>= 1;
            case HTMLPAINT_ZORDER_ABOVE_FLOW:       layerNext >>= 1;
            case HTMLPAINT_ZORDER_ABOVE_CONTENT:    iOp = DP_DrawPainterMulti;
            case HTMLPAINT_ZORDER_WINDOW_TOP:
                if (!fReplaceAll && !fReplaceContent)
                {
                    if (layerCurrent == DISPNODELAYER_BORDER)
                    {
                        if (lDrawLayers & FILTER_DRAW_BORDER)
                        {
                            GrowArray(aryProgram, iPC+1);
                            aryProgram[iPC++] = DP_DrawBorder;
                        }
                        layerCurrent = DISPNODELAYER_BACKGROUND;
                    }
                    if (layerCurrent == DISPNODELAYER_BACKGROUND)
                    {
                        if (!fReplaceBackground)
                        {
                            GrowArray(aryProgram, iPC+1);
                            aryProgram[iPC++] = (lDrawLayers & FILTER_DRAW_BACKGROUND)
                                            ? DP_DrawBackground : DP_BoxToContent;
                        }
                        layerCurrent = DISPNODELAYER_NEGATIVEINF;
                    }
                    if (layerCurrent < layerNext)
                    {
                        if (lDrawLayers & FILTER_DRAW_CONTENT)
                        {
                            GrowArray(aryProgram, iPC+2);
                            aryProgram[iPC++] = DP_DrawContent;
                            aryProgram[iPC++] = layerNext;
                        }
                        layerCurrent = layerNext;
                    }
                }
                if (i < _aryDispClientInfo.Size() &&
                    (lDrawLayers & FILTER_DRAW_CONTENT) &&
                    (iOp == DP_WindowTopMulti || (!fReplaceAll && !fReplaceContent)) )
                {
                    if (fExpand)
                    {
                        GrowArray(aryProgram, iPC+5);
                        aryProgram[iPC++] = DP_Expand;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                    }
                    GrowArray(aryProgram, iPC+1);
                    aryProgram[iPC++] = iOp;
                    GrowArray(aryCookie, iCookie+1);
                    aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                }
                break;
            }
        }

        // mark the end of the program
        GrowArray(aryProgram, iPC+1);
        aryProgram[iPC++] = DP_Done;
    }
    else if (_aryDispClientInfo.Size() <= 1)
    {
        Assert(s_rgDrawPrograms[lZOrder][DP_START_INDEX-1] == lZOrder);
        GrowArray(aryProgram, DP_MAX_LENGTH);
        aryProgram.CopyIndirect(DP_MAX_LENGTH, (int *) s_rgDrawPrograms[lZOrder], FALSE);
    }
    else
    {
        return S_FALSE;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::MapBounds
//
//  Synopsis:   Apply the mapping specified by the filter behavior (if any)
//
//  Arguments:  prcpBounds      rect to map (in parent coords)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::CAdvancedDisplay::MapBounds(CRect *prcpBounds) const
{
    Assert(prcpBounds);
    // Assert prcpBounds is in parent coords

    if (!_rcpBoundsMapped.IsEmpty())
    {
        CSize sizeOffset = prcpBounds->TopLeft().AsSize();
        *prcpBounds = _rcpBoundsMapped;
        prcpBounds->OffsetRect(sizeOffset);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::MoveOverlays
//
//  Synopsis:   Notify any overlay clients that they have moved
//
//  Arguments:  none
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::CAdvancedDisplay::MoveOverlays()
{
    if (_fHasOverlay)
    {
        // compute the new rect (global coordinates)
        CRect rcgBounds;
        CRect rcpBounds = _pDispNode->GetBounds();

        _pDispNode->GetMappedBounds(&rcpBounds);
        _pDispNode->TransformAndClipRect(rcpBounds, COORDSYS_PARENT, &rcgBounds, COORDSYS_GLOBAL);

        // tell the peers
        _pDispClient->MoveOverlayPeers(_pDispNode, &rcgBounds, &_rcScreen);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\dbind\simpdc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Aug 25 10:20:38 1998
 */
/* Compiler settings for S:\zen\ocp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


#ifndef I_SIMPDC_H_
#define I_SIMPDC_H_

/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISimpleDataConverter_FWD_DEFINED__
#define __ISimpleDataConverter_FWD_DEFINED__
typedef interface ISimpleDataConverter ISimpleDataConverter;
#endif 	/* __ISimpleDataConverter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ISimpleDataConverter_INTERFACE_DEFINED__
#define __ISimpleDataConverter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISimpleDataConverter
 * at Tue Aug 25 10:20:38 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [hidden][helpcontext][unique][uuid][object] */ 



DEFINE_GUID(IID_ISimpleDataConverter,0x78667670,0x3C3D,0x11d2,0x91,0xF9,0x00,0x60,0x97,0xC9,0x7F,0x9B);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78667670-3C3D-11d2-91F9-006097C97F9B")
    ISimpleDataConverter : public IUnknown
    {
    public:
        virtual /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ConvertData( 
            VARIANT varSrc,
            long vtDest,
            IUnknown __RPC_FAR *pUnknownElement,
            VARIANT __RPC_FAR *pvarDest) = 0;
        
        virtual /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CanConvertData( 
            long vt1,
            long vt2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleDataConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISimpleDataConverter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISimpleDataConverter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISimpleDataConverter __RPC_FAR * This);
        
        /* [helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertData )( 
            ISimpleDataConverter __RPC_FAR * This,
            VARIANT varSrc,
            long vtDest,
            IUnknown __RPC_FAR *pUnknownElement,
            VARIANT __RPC_FAR *pvarDest);
        
        /* [helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanConvertData )( 
            ISimpleDataConverter __RPC_FAR * This,
            long vt1,
            long vt2);
        
        END_INTERFACE
    } ISimpleDataConverterVtbl;

    interface ISimpleDataConverter
    {
        CONST_VTBL struct ISimpleDataConverterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleDataConverter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleDataConverter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleDataConverter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleDataConverter_ConvertData(This,varSrc,vtDest,pUnknownElement,pvarDest)	\
    (This)->lpVtbl -> ConvertData(This,varSrc,vtDest,pUnknownElement,pvarDest)

#define ISimpleDataConverter_CanConvertData(This,vt1,vt2)	\
    (This)->lpVtbl -> CanConvertData(This,vt1,vt2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext] */ HRESULT STDMETHODCALLTYPE ISimpleDataConverter_ConvertData_Proxy( 
    ISimpleDataConverter __RPC_FAR * This,
    VARIANT varSrc,
    long vtDest,
    IUnknown __RPC_FAR *pUnknownElement,
    VARIANT __RPC_FAR *pvarDest);


void __RPC_STUB ISimpleDataConverter_ConvertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext] */ HRESULT STDMETHODCALLTYPE ISimpleDataConverter_CanConvertData_Proxy( 
    ISimpleDataConverter __RPC_FAR * This,
    long vt1,
    long vt2);


void __RPC_STUB ISimpleDataConverter_CanConvertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleDataConverter_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif I_SIMPDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\basictreenode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       basictreenode.cxx
//
//  Contents:   
//
//  Classes:    
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

DeclareTag(tagRecursiveVerify, "BasicTree: Recursive verify", "Recursively verify basic tree")


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ExtractOrDestroyNodes
//              
//  Synopsis:   Extract or destroy a range of sibling nodes.  These nodes may
//              be children of different structure nodes.
//              
//  Arguments:  pStartNode      first sibling to extract or destroy
//              pEndNode        last sibling to extract or destroy
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::ExtractOrDestroyNodes(
        CDispNode* pStartNode,
        CDispNode* pEndNode)
{
    Assert(pStartNode != NULL && pEndNode != NULL);
    Assert(pStartNode->_pParent != NULL && pEndNode->_pParent != NULL);
    Assert(!pEndNode->IsStructureNode());
    
#if DBG==1
    CDispNode* pTrueParent = pStartNode->GetParentNode();
    Assert(pTrueParent == pEndNode->GetParentNode());
#endif

    CDispNode* pNode = pStartNode;
    CDispParentNode* pParent = pNode->_pParent;
    
    // tricky case: start node and end node have different parents
    while (pParent != pEndNode->_pParent)
    {
        // unlink all children to the right of (and including) pNode
        CDispNode** ppPrevious = (pNode->_pPrevious)
            ? &(pNode->_pPrevious->_pNext)
            : &(pParent->_pFirstChild);
        *ppPrevious = NULL;
        pParent->_pLastChild = pNode->_pPrevious;
        
        pParent->UnlinkChildren(pNode);
        WHEN_DBG(pParent->VerifyChildrenCount();)
        pParent->SetChildrenChanged();
        pParent->RequestRecalc();
        
        // proceed up the tree, looking for the next child
        CDispNode* pNext = NULL;
        do
        {
            Assert(pParent->IsStructureNode());
            
            long cChildren = pParent->_cChildren;

            pNode = pParent;
            pNext = pNode->_pNext;
            pParent = pNode->_pParent;
            Assert(pParent != NULL);

            if (cChildren == 0)
            {
                // delete empty structure node
                pParent->UnlinkChild(pNode);
                pNode->Delete();
                pParent->SetChildrenChanged();
                pParent->RequestRecalc();
            }
        }
        while (pNext == NULL);
        
        pNode = pNext;
        Assert(pNode->IsStructureNode());
        
        // descend into structure nodes
        do
        {
            pParent = pNode->AsParent();
            pNode = pParent->_pFirstChild;
            Assert(pNode != NULL);
        }
        while (pNode->IsStructureNode());
    }
    
    
    // now the easy case: start node and end node are children of same parent
        
    // unlink start and end nodes, then process all nodes in between
    CDispNode** ppPrevious = (pNode->_pPrevious)
        ? &(pNode->_pPrevious->_pNext)
        : &(pParent->_pFirstChild);
    CDispNode** ppNext = (pEndNode->_pNext)
        ? &(pEndNode->_pNext->_pPrevious)
        : &(pParent->_pLastChild);
    *ppPrevious = pEndNode->_pNext;
    *ppNext = pNode->_pPrevious;
    
    // mark end of nodes to be unlinked
    pEndNode->_pNext = NULL;
    pParent->UnlinkChildren(pNode);
    WHEN_DBG(pParent->VerifyChildrenCount();)
    pParent->SetChildrenChanged();
    pParent->RequestRecalc();

    // collapse empty structure nodes
    if (pParent->IsStructureNode() && pParent->_cChildren == 0)
        pParent->CollapseStructureNode();

#if DBG==1
    WHEN_DBG(pTrueParent->VerifyTreeCorrectness();)
#endif

}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ReplaceParent
//
//  Synopsis:   Replace this node's parent with this node, and delete the parent
//              node and any of its other children.
//
//  Arguments:  none
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::ReplaceParent()
{
    Assert(_pParent != NULL);
    
    // skip structure nodes between this node and its true parent
    CDispParentNode* pParent = GetParentNode();

    // copy all information needed to insert child in correct spot in tree
    CDispParentNode* pGrandparent = pParent->_pParent;
    CDispNode* pPrevious = pParent->_pPrevious;
    CDispNode* pNext = pParent->_pNext;

    pParent->ExtractFromTree();

    // delete the parent and its unowned children (but make this node owned
    // so it doesn't get deleted)
    BOOL fOwned = IsOwned();
    SetOwned(TRUE);
    pParent->Destroy();
    SetOwned(fOwned);

    // now insert in parent's spot
    if (pPrevious != NULL)
        pPrevious->InsertSiblingNode(this, after);
    else if (pNext != NULL)
        pNext->InsertSiblingNode(this, before);
    else if (pGrandparent != NULL)
        pGrandparent->InsertFirstChildNode(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::InsertParent
//
//  Synopsis:   Insert a new parent node above this node.
//
//  Arguments:  pNewParent      new parent node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::InsertParent(CDispParentNode* pNewParent)
{
    // pNewParent should not be in the tree
    Assert(pNewParent->_pParent == NULL);
    Assert(pNewParent->_pPrevious == NULL);
    Assert(pNewParent->_pNext == NULL);
    
    // pNewParent should have no children
#if DBG==1
    Assert(pNewParent->_cChildren == 0);
    Assert(pNewParent->_pFirstChild == NULL);
    Assert(pNewParent->_pLastChild == NULL);
#endif

    // insert new parent as sibling of this node, then re-parent this node
    // to new parent
    if (_pParent != NULL)
    {
        Verify(InsertSiblingNode(pNewParent, after));
    }
    Verify(pNewParent->InsertNodeAsOnlyChild(this));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::SetFlagsToRoot
//              
//  Synopsis:   Set flag(s) all the way up this branch of the tree.
//
//  Arguments:  flag        the flag(s) to set
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::SetFlagsToRoot(int flags)
{
    SetFlags(flags);
    
    // set these flags all the way up the branch until we run into the root
    // node or a node that already has these flags set
    for (CDispNode* pNode = _pParent;
        pNode && !pNode->IsAllSet(flags);
        pNode = pNode->_pParent)
    {
        pNode->SetFlags(flags);
    }
    
    WHEN_DBG(VerifyFlagsToRoot(flags));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ClearFlagsToRoot
//              
//  Synopsis:   Clear flags all the way to the root, without ORing with flag
//              values contributed by other siblings along the way.
//
//  Arguments:  flags       flags to clear
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::ClearFlagsToRoot(int flags)
{
    ClearFlags(flags);
    
    for (CDispNode* pNode = _pParent;
        pNode != NULL && pNode->IsAnySet(flags);
        pNode = pNode->_pParent)
    {
        pNode->ClearFlags(flags);
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::VerifyTreeCorrectness
//              
//  Synopsis:   Verify that the subtree rooted at this node is correct.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::VerifyTreeCorrectness()
{
    if (IsParentNode())
    {
        CDispParentNode* p = AsParent();
        
        // verify first/last child node pointers
        AssertSz((p->_pFirstChild && p->_pLastChild) ||
                 (!p->_pFirstChild && !p->_pLastChild),
                "Inconsistent first/last child nodes");
        AssertSz(!p->_pFirstChild || p->_pFirstChild->_pPrevious == NULL,
                 "Invalid first child node");
        AssertSz(!p->_pLastChild || p->_pLastChild->_pNext == NULL,
                 "Invalid last child node");
    
        // verify number of children
        p->VerifyChildrenCount();

        // structure nodes must have non-destroyed children
        AssertSz(!IsStructureNode() || p->_cChildren > 0,
                 "Structure node must have at least one non-destroyed child");
        
        // verify parent-child and sibling relationships
        CDispNode * pLastChild = NULL;
        CDispNode * pChild;
        for (pChild = p->_pFirstChild;
             pChild != NULL;
             pLastChild = pChild, pChild = pChild->_pNext)
        {
            AssertSz(pChild != this, "Invalid parent-child loop");
            AssertSz(pChild->_pParent == this, "Invalid parent-child relationship");
            AssertSz(pChild->_pPrevious == pLastChild, "Invalid previous sibling order");
            AssertSz(pChild->_pNext || pChild == p->_pLastChild, "Invalid last child node");
            AssertSz(!pChild->IsNewInsertion() || IsStructureNode() || ChildrenChanged(), "Inserted child must set ChildrenChanged on parent");
        }
        
        // verify each child
        if (IsTagEnabled(tagRecursiveVerify))
        {
            for (pChild = p->_pFirstChild;
                 pChild != NULL;
                 pChild = pChild->_pNext)
            {
                pChild->VerifyTreeCorrectness();
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::VerifyFlagsToRoot
//              
//  Synopsis:   Verify that the given flags are set on this node and all nodes
//              on this branch from this node to the root.
//              
//  Arguments:  flags       flags to verify
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::VerifyFlagsToRoot(int flags)
{
    for (CDispNode* pNode = this;
         pNode != NULL;
         pNode = pNode->_pParent)
    {
        AssertSz(pNode->IsAllSet(flags), "Flags were not set all the way to the root");
        if (!pNode->IsAllSet(flags))
            break;
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\dbgmetaf.cxx ===
// dbgmetaf.cxx
// 
// This file useful for debugging windows metafiles only, so it will be included
// in build only if TRACE_META_RECORDS is defined. 


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "dbgmetaf.hxx"

#if defined (TRACE_META_RECORDS) && (DBG==1)

DeclareTag(tagGbgMetaXform, "DbgMetaXform", "Trace metafile transform");

/////////////////////////////////////////////////////////

struct _DebugMetaFunc__
	{
	char*	m_pczMetaFuncName;
	unsigned short	m_wValue;
	};

extern _DebugMetaFunc__ s_rgAllMeta[];

//////////////////////////////////////////////////////////

void TraceMetaFunc(unsigned short wMetaFunc, int c)
{
	for (_DebugMetaFunc__*pCurrent = s_rgAllMeta; pCurrent->m_wValue; pCurrent++)
		{
		if (pCurrent->m_wValue == wMetaFunc)
			{
			TraceTag((tagGbgMetaXform, "TraceMetaFunc %d: %s\n", c, pCurrent->m_pczMetaFuncName));
			return;
			}
		}
	TraceTag((tagGbgMetaXform, "TraceMetaFunc: Unknown Meta Function %d\n", wMetaFunc));
}
			
/* Metafile Functions */
_DebugMetaFunc__ s_rgAllMeta[] =
	{
		{ "META_SETBKCOLOR",			0x0201 },
		{ "META_SETBKMODE",				0x0102 },  
		{ "META_SETMAPMODE",			0x0103 },
		{ "META_SETROP2",				0x0104 },
		{ "META_SETRELABS",				0x0105 },
		{ "META_SETPOLYFILLMODE",		0x0106 },
		{ "META_SETSTRETCHBLTMODE",		0x0107 },
		{ "META_SETTEXTCHAREXTRA",		0x0108 },
		{ "META_SETTEXTCOLOR",			0x0209 },
		{ "META_SETTEXTJUSTIFICATION",	0x020A },
		{ "META_SETWINDOWORG",			0x020B },
		{ "META_SETWINDOWEXT",			0x020C },
		{ "META_SETVIEWPORTORG",		0x020D },
		{ "META_SETVIEWPORTEXT",		0x020E },
		{ "META_OFFSETWINDOWORG",		0x020F },
		{ "META_SCALEWINDOWEXT",		0x0410 },
		{ "META_OFFSETVIEWPORTORG",		0x0211 },
		{ "META_SCALEVIEWPORTEXT",		0x0412 },
		{ "META_LINETO",				0x0213 },
		{ "META_MOVETO",				0x0214 },
		{ "META_EXCLUDECLIPRECT",		0x0415 },
		{ "META_INTERSECTCLIPRECT",		0x0416 },
		{ "META_ARC",					0x0817 },
		{ "META_ELLIPSE",				0x0418 },
		{ "META_FLOODFILL",				0x0419 },
		{ "META_PIE",					0x081A },
		{ "META_RECTANGLE",				0x041B },
		{ "META_ROUNDRECT",				0x061C },
		{ "META_PATBLT",				0x061D },
		{ "META_SAVEDC",				0x001E },
		{ "META_SETPIXEL",				0x041F },
		{ "META_OFFSETCLIPRGN",			0x0220 },
		{ "META_TEXTOUT",				0x0521 },
		{ "META_BITBLT",				0x0922 },
		{ "META_STRETCHBLT",			0x0B23 },
		{ "META_POLYGON",				0x0324 },
		{ "META_POLYLINE",				0x0325 },
		{ "META_ESCAPE",				0x0626 },
		{ "META_RESTOREDC",				0x0127 },
		{ "META_FILLREGION",			0x0228 },
		{ "META_FRAMEREGION",			0x0429 },
		{ "META_INVERTREGION",			0x012A },
		{ "META_PAINTREGION",			0x012B },
		{ "META_SELECTCLIPREGION",		0x012C },
		{ "META_SELECTOBJECT",			0x012D },
		{ "META_SETTEXTALIGN",			0x012E },
		{ "META_CHORD",					0x0830 },
		{ "META_SETMAPPERFLAGS",		0x0231 },
		{ "META_EXTTEXTOUT",			0x0a32 },
		{ "META_SETDIBTODEV",			0x0d33 },
		{ "META_SELECTPALETTE",			0x0234 },
		{ "META_REALIZEPALETTE",		0x0035 },
		{ "META_ANIMATEPALETTE",		0x0436 },
		{ "META_SETPALENTRIES",			0x0037 },
		{ "META_POLYPOLYGON",			0x0538 },
		{ "META_RESIZEPALETTE",			0x0139 },
		{ "META_DIBBITBLT",				0x0940 },
		{ "META_DIBSTRETCHBLT",			0x0b41 },
		{ "META_DIBCREATEPATTERNBRUSH",	0x0142 },
		{ "META_STRETCHDIB",			0x0f43 },
		{ "META_EXTFLOODFILL",			0x0548 },
		{ "META_DELETEOBJECT",			0x01f0 },
		{ "META_CREATEPALETTE",			0x00f7 },
		{ "META_CREATEPATTERNBRUSH",	0x01F9 },
		{ "META_CREATEPENINDIRECT",		0x02FA },
		{ "META_CREATEFONTINDIRECT",	0x02FB },
		{ "META_CREATEBRUSHINDIRECT",	0x02FC },
		{ "META_CREATEREGION",			0x06FF },
		{ NULL, 0 }  // Terminater
	};

#endif 	// DEBUG && TRACE_META_RECORDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\debugpaint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       debugpaint.cxx
//
//  Contents:   Utility class to debug painting code.
//
//  Classes:    CDebugPaint
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_REGION_HXX_
#define X_REGION_HXX_
#include "region.hxx"
#endif

DeclareTag(tagTimePaint,    "DisplayTree", "Time paint");
ExternTag(tagNoOffScr);

//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::NoOffScreen
//              
//  Synopsis:   Determine whether rendering should happen offscreen.
//              
//  Arguments:  none
//              
//  Returns:    FALSE if rendering should be offscreen.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDebugPaint::NoOffScreen()
{
#if defined(PRODUCT_PROF)    // profile build
    static const int noOffScreen =
        GetPrivateProfileIntA("displaytree", "NoOffScreen", 0, "mshtmdbg.ini");
    return (noOffScreen != 0);
#elif DBG==1                // debug build
    return IsTagEnabled(tagNoOffScr);
#else
    return FALSE;
#endif
}

#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     ShowPaint
//
//  Synopsis:   Debugging function to show what's getting
//              painted during each frame.
//
//  Arguments:  prcPaint    rect to paint (if rgnPaint is NULL)
//              rgnPaint    region to paint
//              tagShow     tag which governs whether we show or not
//              tagPause    tag which governs whether we pause briefly or not
//              tagWait     tag which governs whether we wait for shift key
//              fHatch      TRUE if we should use a hatch pattern
//              
//----------------------------------------------------------------------------

void
CDebugPaint::ShowPaint(
        const RECT* prcPaint,
        HRGN rgnPaint,
        HDC hdc,
        TRACETAG tagShow,
        TRACETAG tagPause,
        TRACETAG tagWait,
        BOOL fHatch)
{
    if (IsTagEnabled(tagShow) || IsTagEnabled(tagPause) || IsTagEnabled(tagWait))
    {
        // Flash the background.
        if (hdc == NULL || (prcPaint == NULL && rgnPaint == NULL))
        {
            return;
        }

        HBRUSH hbr;
        static int s_iclr;
        static COLORREF s_aclr[] =
        {
                RGB(  0,   0, 255),
                RGB(  0, 255,   0),
                RGB(  0, 255, 255),
                RGB(255,   0,   0),
                RGB(255,   0, 255),
                RGB(255, 255,   0)
        };

        GetAsyncKeyState(VK_SHIFT);

        do
        {
            if (IsTagEnabled(tagShow))
            {
                // Fill the rect.
                s_iclr = (s_iclr + 1) % ARRAY_SIZE(s_aclr);
                if (fHatch)
                {
                    hbr = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
                    int bkMode = SetBkMode(hdc, TRANSPARENT);
                    if (rgnPaint != NULL)
                    {
                        FillRgn(hdc, rgnPaint, hbr);
                    }
                    else
                    {
                        FillRect(hdc, prcPaint, hbr);
                    }
                    DeleteObject((HGDIOBJ)hbr);
                    SetBkMode(hdc, bkMode);
                }
                else
                {
                    hbr = GetCachedBrush(s_aclr[s_iclr]);
                    if (rgnPaint != NULL)
                    {
                        FillRgn(hdc, rgnPaint, hbr);
                    }
                    else
                    {
                        FillRect(hdc, prcPaint, hbr);
                    }
                    ReleaseCachedBrush(hbr);
                }
                GdiFlush();
            }
            
            if (IsTagEnabled(tagPause))
            {
                DWORD dwTick = GetTickCount();
                while (GetTickCount() - dwTick < 100) ;
            }
        }
        while (IsTagEnabled(tagWait) &&
               (GetAsyncKeyState(VK_SHIFT) & 0x8000) == 0);
        
        while (IsTagEnabled(tagWait) && 
               (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0)
        {
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::PausePaint
//              
//  Synopsis:   
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDebugPaint::PausePaint(TRACETAG tagWait)
{
    GdiFlush();
    
    while (IsTagEnabled(tagWait) &&
           (GetAsyncKeyState(VK_SHIFT) & 0x8000) == 0)
        ;
    
    while (IsTagEnabled(tagWait) && 
           (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0)
        ;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::StartTimer
//              
//  Synopsis:   
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDebugPaint::StartTimer()
{
    QueryPerformanceCounter((LARGE_INTEGER *)&_timeStart);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::StopTimer
//              
//  Synopsis:   
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDebugPaint::StopTimer(TRACETAG tag, char* message, BOOL fMicrosec)
{
    if (IsTagEnabled(tag))
    {
        __int64 timeEnd, timeFreq;
        QueryPerformanceCounter((LARGE_INTEGER *)&timeEnd);
        QueryPerformanceFrequency((LARGE_INTEGER *)&timeFreq);
        if (fMicrosec)
        {
            TraceTag((tag, "%s: %ld usec.", message, 
                ((LONG)(((timeEnd - _timeStart) * 1000000) / timeFreq))));
        }
        else
        {
            TraceTag((tag, "%s: %ld msec.", message, 
                ((LONG)(((timeEnd - _timeStart) * 1000) / timeFreq))));
        }
    }
}

CRegionRects::CRegionRects(const CRegion& rgn)
{
    if (rgn.IsEmpty())
        _count = 0;
    else
    {
        HRGN hRgn = rgn.GetRegionForLook();
        GetRegionData(hRgn, sizeof(_rd), (RGNDATA *)&_rd);
        // TODO 112427 (mikhaill 6/21/00) - this is not quite exact
        // for two reasons: hRgn can be 0 and GetRegionData can
        // return zero as a sign of failure. Cleanup required
        // (unless we'll continue to use this stuff for debugging
        // purposes only)
        _count = _rd.rdh.nCount;
    }
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\dispclipnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispclipnode.cxx
//
//  Contents:   A container node that clips all content (flow and positioned).
//
//  Classes:    CDispClipNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPCLIPNODE_HXX_
#define X_DISPCLIPNODE_HXX_
#include "dispclipnode.hxx"
#endif

MtDefine(CDispClipNode, DisplayTree, "CDispClipNode")

//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::DrawUnbufferedBorder
//              
//  Synopsis:   Draw borders of clipping nodes near the root of the display
//              tree.  This is an important optimization when we're scrolling.
//              We can paint the scrollbar, remove it from the redraw region,
//              and accelerate all remaining intersection tests and painting.
//              
//  Arguments:  pContext        display context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispClipNode::DrawUnbufferedBorder(CDispDrawContext* pContext)
{
    // TODO (donmarsh) -- this routine doesn't take into account transparent
    // borders yet.  We won't draw the background underneath them correctly.
    
    // go to box coordinates (no need to restore the transform)
    if (!TransformedToBoxCoords(&pContext->GetClipTransform(), pContext->GetRedrawRegion()))
        return;
    
    // draw border for this node
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    DrawBorder(pContext, *di._prcbBorderWidths, GetDispClient());
    
    // descend branch if we have exactly one child, and it is a CDispClipNode,
    // and it is in the flow layer, and it isn't offset by an inset or transform
    CDispNode* pChild = NULL;
    if (CountChildren() == 1 && !HasInset() && !HasUserTransform())
    {
        pChild = GetFirstChildNode();
        if (!pChild->IsClipNode())
            pChild = NULL;
    }
    
    if (pChild)
    {
        // go to flow coordinates, which we simplify here because there is
        // no inset or transform
        pContext->AddPreOffset(di._prcbBorderWidths->TopLeft().AsSize());
        AssertCoords(&pContext->GetClipTransform(), COORDSYS_TRANSFORMED, COORDSYS_FLOWCONTENT);
        Assert(pChild->IsClipNode());
        CDispClipNode::Cast(pChild)->DrawUnbufferedBorder(pContext);
    }
    else
    {
        // simplify redraw region, because now we only have to draw stuff inside
        // this border
        CSize size = di._sizebScrollToBox;
        size += di._sizesScroll;
        di._rccBackgroundClip.OffsetRect(size);   // to box coords
        CRect rcgInsideBorder;
        pContext->GetClipTransform().Transform(di._rccBackgroundClip, &rcgInsideBorder);
        pContext->GetRedrawRegion()->Intersect(rcgInsideBorder);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::CalcDispInfo
//              
//  Synopsis:   Calculate clipping and positioning info for this node.
//
//  Arguments:  rcbClip         clip rect in box coords
//              pdi             display info structure
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispClipNode::CalcDispInfo( const CRect& rcbClip, CDispInfo* pdi) const
{
    super::CalcDispInfo(rcbClip, pdi);
    
    // positioned content gets clipped like the background
    if (_fClipX)
    {
        pdi->_rccPositionedClip.left = pdi->_rccBackgroundClip.left;
        pdi->_rccPositionedClip.right = pdi->_rccBackgroundClip.right;
    }
    if (_fClipY)
    {
        pdi->_rccPositionedClip.top = pdi->_rccBackgroundClip.top;
        pdi->_rccPositionedClip.bottom = pdi->_rccBackgroundClip.bottom;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::GetContentClipInScrollCoords
//              
//  Synopsis:   Return clipping rectange for content.
//              
//  Arguments:  prcsClip    returns content clip rect
//              
//  Returns:    TRUE if this node clips content
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispClipNode::GetContentClipInScrollCoords(CRect* prcsClip) const
{
    if (_fClipX && _fClipY)
        return GetFlowClipInScrollCoords(prcsClip);
    
    if ((_fClipX || _fClipY) && GetFlowClipInScrollCoords(prcsClip))
    {
        // NOTE (donmarsh) -- this big constant is the same that we use in
        // CDispClipTransform::SetHugeClip, but it doesn't have to be.  We
        // don't want to use MAXLONG because translation would overflow.
        static const LONG bigVal = 5000000;
        if (!_fClipX)
        {
            prcsClip->left = -bigVal;
            prcsClip->right = bigVal;
        }
        if (!_fClipY)
        {
            prcsClip->top = -bigVal;
            prcsClip->bottom = bigVal;
        }
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::ComputeVisibleBounds
//
//  Synopsis:   Compute visible bounds for a parent node, marking children
//              that determine the edges of these bounds
//
//  Arguments:  none
//
//  Returns:    TRUE if visible bounds changed.
//
//----------------------------------------------------------------------------

BOOL
CDispClipNode::ComputeVisibleBounds()
{
    // visible bounds is always the size of the container, and may be extended
    // by items in Z layers that fall outside these bounds
    CRect rcbBounds(_rcpContainer.Size());
    GetMappedBounds(&rcbBounds);
    CRect rcbBoundsExpanded;
    CRect rctBounds(_rctBounds);
    
    SetPainterState(rcbBounds, &rcbBoundsExpanded);

    // convert to transformed coordinates
    TransformRect(rcbBoundsExpanded, COORDSYS_BOX, &_rctBounds, COORDSYS_TRANSFORMED);
        
    // the normal case is to clip in both dimensions.  If so, we're done.  But
    // if either dimension is not clipped, we have to examine the visible bounds
    // of all this node's positioned children to determine this node's visible
    // bounds.
    if (!_fClipX || !_fClipY)
    {
        CRect rctClipped(_rctBounds);
        // calculate visible bounds including all positioned children
        super::ComputeVisibleBounds();
        if (_fClipX)
        {
            _rctBounds.left = rctClipped.left;
            _rctBounds.right = rctClipped.right;
        }
        if (_fClipY)
        {
            _rctBounds.top = rctClipped.top;
            _rctBounds.bottom = rctClipped.bottom;
        }
    }

    return (_rctBounds != rctBounds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\basictreeparentnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       basictreeparentnode.cxx
//
//  Contents:   A basic tree node with children.
//
//  Classes:    
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DISPSTRUCTURENODE_HXX_
#define X_DISPSTRUCTURENODE_HXX_
#include "dispstructurenode.hxx"
#endif

//
// tree balancing constants
//

#define DISP_AVERAGE_CHILDREN     50     // ave. # of children in new structure node
#define DISP_MAX_CHILDREN        100     // max. # of children allowed per node
#define DISP_STRUCTURE_DEVIATION   5     // acceptable deviation from average
#define DISP_STRUCTURE_MASK CDispNode::s_layerMask   // flag mask used to identify groups of children
                                                     // that can be turned into structured subtrees

//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::CountChildren
//              
//  Synopsis:   Count all the non-structure children belonging to this node.
//              
//  Arguments:  none
//              
//  Returns:    Count of all the non-structure children.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

LONG
CDispParentNode::CountChildren() const
{
    long cChildren = 0;
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        cChildren += (pChild->IsStructureNode())
            ? pChild->AsParent()->CountChildren()
            : 1;
    }
    
    return cChildren;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertFirstChildNode
//              
//  Synopsis:   Insert the given node as the first child of this node,
//              descending through structure nodes as necessary.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Returns:    TRUE if new node was inserted into a new location in the tree
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertFirstChildNode(CDispNode* pNewChild)
{
    // no other children
    if (_pFirstChild == NULL)
    {
        return InsertNodeAsOnlyChild(pNewChild);
    }
    
    // no structure nodes
    if (!_pFirstChild->IsStructureNode())
    {
        return _pFirstChild->InsertSiblingNode(pNewChild, before);
    }
    
    // descend into structure nodes
    CDispNode* pFirstChild = GetFirstChildNode();
    
    // pFirstChild can only be NULL if structure nodes only have destroyed
    // children.  This shouldn't happen due to the implementation of Destroy.
    Assert(pFirstChild != NULL);
    return pFirstChild->InsertSiblingNode(pNewChild, before);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertLastChildNode
//              
//  Synopsis:   Insert the given node as the last child of this node,
//              descending through structure nodes as necessary.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Returns:    TRUE if new node was inserted into a new location in the tree
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertLastChildNode(CDispNode* pNewChild)
{
    // no other children
    if (_pLastChild == NULL)
    {
        return InsertNodeAsOnlyChild(pNewChild);
    }
    
    // no structure nodes
    if (!_pLastChild->IsStructureNode())
    {
        return _pLastChild->InsertSiblingNode(pNewChild, after);
    }
    
    // descend into structure nodes
    CDispNode* pLastChild = GetLastChildNode();
    
    // pLastChild can only be NULL if structure nodes only have destroyed
    // children.  This shouldn't happen due to the implementation of Destroy.
    Assert(pLastChild != NULL);
    return pLastChild->InsertSiblingNode(pNewChild, after);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertNodeAsOnlyChild
//              
//  Synopsis:   Insert a new node as the only child of this node.
//
//  Arguments:  pNew        node to be inserted as sibling of this node
//              
//  Returns:    TRUE if new node was inserted into a new location in the tree
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertNodeAsOnlyChild(CDispNode* pNew)
{
    Assert(pNew != NULL);
    Assert(_cChildren == 0 ||
           (_pFirstChild == pNew && _pLastChild == pNew));

    // shouldn't be inserting a structure node
    Assert(!pNew->IsStructureNode());
    
    // if new node is already in the tree, don't insert
    if (pNew == this || pNew == _pFirstChild)
        goto NoInsertion;
        
    // extract new sibling from its current location
    if (pNew->_pParent != NULL)
        pNew->ExtractFromTree();

    Assert(pNew->_pParent == NULL);
    Assert(pNew->_pPrevious == NULL);
    Assert(pNew->_pNext == NULL);
    Assert(_cChildren == 0 && 
           _pFirstChild == NULL &&
           _pLastChild == NULL);

    // link new child
    pNew->_pParent = this;
    pNew->_pPrevious = NULL;
    pNew->_pNext = NULL;
    
    // modify parent
    _cChildren++;
    _pFirstChild = _pLastChild = pNew;
    SetChildrenChanged();

    // recalc subtree starting with newly inserted node
    pNew->SetFlags(s_newInsertion | s_recalcSubtree);
    pNew->RequestRecalc();
    
    WHEN_DBG(VerifyTreeCorrectness();)

    pNew->SetInvalid();
    return TRUE;
    
NoInsertion:
    WHEN_DBG(VerifyTreeCorrectness();)
    return FALSE;
}


void
CDispParentNode::CollapseStructureNode()
{
    Assert(IsStructureNode() && _cChildren == 0);
    
    CDispParentNode* pNode = this;
    CDispParentNode* pParent;
    
    while (pNode->IsStructureNode() && pNode->_cChildren == 0)
    {
        pParent = pNode->_pParent;
        Assert(pParent != NULL);
        
        // remove this node from parent's list of children
        pParent->UnlinkChild(pNode);
        pNode->Delete();
        WHEN_DBG(pParent->VerifyChildrenCount();)

        pNode = pParent;
    }

    // this branch will need recalc
    pNode->RequestRecalc();
    pNode->SetChildrenChanged();
}


#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::DestroyTreeWithPrejudice
//
//  Synopsis:   Destroy the entire tree in an optimal fashion without executing
//              any destructors.
//
//  Arguments:  none
//
//  Notes:      WARNING!  You must be sure that nothing holds a pointer to
//              any node in the tree before calling this method.
//
//----------------------------------------------------------------------------

void
CDispParentNode::DestroyTreeWithPrejudice()
{
    // traverse entire tree, blowing away everything without running any
    // destructors or calling any virtual methods
    CDispNode* pChild = this;
    CDispParentNode* pParent = NULL;

    while (pChild != NULL)
    {
        // find left-most descendant of this parent node
        while (pChild->IsParentNode())
        {
            pParent = pChild->AsParent();
            pChild = pParent->_pFirstChild;
            if (pChild == NULL)
                break;
            pParent->_pFirstChild = pChild->_pNext;
        }

        // blow away left-most leaf nodes at this level
        while (pChild != NULL && pChild->IsLeafNode())
        {
            CDispNode* pDeadChild = pChild;
            pChild = pChild->_pNext;
            pDeadChild->Delete();
        }

        // descend into tree if we found a parent node
        if (pChild != NULL)
        {
            pParent = pChild->AsParent();
            pParent->_pFirstChild = pChild->_pNext;
        }

        // go up a level in the tree if we ran out of nodes at this level
        else
        {
            Assert(pParent != NULL);
            pChild = pParent->_pParent;
            pParent->_cChildren   = 0;
            pParent->_pFirstChild = 0;
            pParent->_pLastChild  = 0;
            pParent->Delete();
        }
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::UnlinkChildren
//              
//  Synopsis:   Unlink all children belonging to this node, and delete any
//              destroyed children.
//              
//  Arguments:  pFirstChild     first child to unlink
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::UnlinkChildren(CDispNode* pFirstChild)
{
    CDispNode* pChild = (pFirstChild) ? pFirstChild : _pFirstChild;
    
    while (pChild != NULL)
    {
        // since we're unlinking this list, we have to remember the next child
        CDispNode* pNext = pChild->_pNext;
        
        // adjust parent's child count
        _cChildren--;
        
        // extract or delete
        if (!pChild->IsStructureNode() && pChild->IsOwned())
        {
            pChild->_pParent = NULL;
            pChild->_pPrevious = pChild->_pNext = NULL;
        }
        else
        {
            pChild->Delete();
        }
        
        pChild = pNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::RebalanceParentNode
//              
//  Synopsis:   Rebalance structured subtrees as necessary.
//
//  Note:       After call to this routine all the s_rebalance flags in "structure
//              subtree" are clean. The "structure subtree" means all structure
//              children of this node and of nodes of "structure subtree"
//----------------------------------------------------------------------------

void
CDispParentNode::RebalanceParentNode()
{
    Assert(!IsStructureNode() && ChildrenChanged() && HasChildren());
    
    // rebalance structure nodes
    if (_pFirstChild->IsStructureNode())
    {
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            Assert(pChild->IsStructureNode());
            if (pChild->MustRebalance())
                pChild->AsParent()->RebalanceIfNecessary();
        }
        WHEN_DBG(VerifyChildrenCount();)
    }


    // quick check to see if restructuring is needed
    if (_cChildren <= DISP_MAX_CHILDREN)
        return;
    
    //
    // scan the children to see if restructuring is needed.  This has to be done
    // in a separate pass from the actual restructuring, in case we find a mixture of
    // large and small groups of similar children.  In this case, all the groups must
    // be restructured to maintain the invariant that structure nodes are never
    // siblings of non-structure nodes.
    // 

    // Note: the following restructuring can violate invariant mentioned above
    //       if InsertStructureNode will meet memory allocation failure
    //       (mikhaill 10/4/00)
    // TODO: improve it by allocating all structure nodes at once
    
    CDispNode* pStartNode = _pFirstChild;
    int structureFlags = pStartNode->MaskFlags(DISP_STRUCTURE_MASK);
    long cChildren = 1;
    CDispNode* pNode;
    CDispNode* pNext;
    BOOL fNeedRestructure = FALSE;
    
    for (pNode = pStartNode;
         pNode != NULL;
         pNode = pNext)
    {
        pNext = pNode->_pNext;
        
        if (pNext != NULL && pNext->MaskFlags(DISP_STRUCTURE_MASK) == structureFlags)
        {
            cChildren++;
        }
        else
        {
            if (cChildren > DISP_MAX_CHILDREN)
            {
                fNeedRestructure = TRUE;
                break;
            }
            if (pNext != NULL)
            {
                pStartNode = pNext;
                structureFlags = pNext->MaskFlags(DISP_STRUCTURE_MASK);
                cChildren = 1;
            }
        }
    }
    
    //
    // insert structure nodes for groups of children who share the same flag values
    // 

    if (fNeedRestructure)
    {
        pStartNode = _pFirstChild;
        structureFlags = pStartNode->MaskFlags(DISP_STRUCTURE_MASK);
        cChildren = 1;

        for (pNode = pStartNode;
             pNode != NULL;
             pNode = pNext)
        {
            pNext = pNode->_pNext;
            
            if (pNext != NULL && pNext->MaskFlags(DISP_STRUCTURE_MASK) == structureFlags)
            {
                cChildren++;
            }
            else
            {
                InsertStructureNode(pStartNode, pNode, cChildren);
                if (pNext != NULL)
                {
                    pStartNode = pNext;
                    structureFlags = pNext->MaskFlags(DISP_STRUCTURE_MASK);
                    cChildren = 1;
                }
            }
        }
    }
    
    WHEN_DBG(VerifyChildrenCount();)
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::CreateStructureNodes
//              
//  Synopsis:   Create the requested number of structure nodes in the given
//              array.
//              
//  Arguments:  ppNodeArray     array in which the nodes are returned
//              cNodes          how many nodes
//              
//  Returns:    FALSE if creation was unsuccessful in any way.
//              
//  Notes:      If FALSE is returned, all intermediate nodes must be deleted.
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::CreateStructureNodes(
        CDispParentNode** ppNodeArray,
        long cNodes)
{
    for (long i = 0; i < cNodes; i++)
    {
        CDispStructureNode* pNewNode = CDispStructureNode::New();
        if (pNewNode != NULL)
        {
            ppNodeArray[i] = pNewNode;
        }
        else
        {
            // delete nodes already allocated and fail
            while (--i >= 0)
                ppNodeArray[i]->Destroy();
            return FALSE;
        }
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertStructureNode
//              
//  Synopsis:   Replace the indicated group of children with a structured
//              subtree.
//              
//  Arguments:  pFirstNode          first child to include in structured subtree
//              pLastNode           last child to include in structured subtree
//              cChildren           amount of children to move under new
//                                  structure node, inluding pFirstNode and pLastNode
//----------------------------------------------------------------------------

void
CDispParentNode::InsertStructureNode(
        CDispNode* pFirstNode,
        CDispNode* pLastNode,
        long cChildren)
{
    CDispParentNode* pStrNode;
    if (!CreateStructureNodes(&pStrNode, 1))
        return;
    
    Assert(pStrNode->IsStructureNode());
    
    // set flags in structure node correctly
    int structureFlags = pFirstNode->MaskFlags(DISP_STRUCTURE_MASK);
    pStrNode->CopyFlags(structureFlags, DISP_STRUCTURE_MASK);

    // replace children with this structure node
    pStrNode->_pParent = this;
    pStrNode->_pPrevious = pFirstNode->_pPrevious;
    pStrNode->_pNext = pLastNode->_pNext;
    if (pFirstNode->_pPrevious != NULL)
    {
        pFirstNode->_pPrevious->_pNext = pStrNode;
        pFirstNode->_pPrevious = NULL;
    }
    else
    {
        _pFirstChild = pStrNode;
    }
    if (pLastNode->_pNext != NULL)
    {
        pLastNode->_pNext->_pPrevious = pStrNode;
        pLastNode->_pNext = NULL;
    }
    else
    {
        _pLastChild = pStrNode;
    }
    
    // structure node adopts the children it replaced
    pStrNode->_cChildren = cChildren;
    pStrNode->_pFirstChild = pFirstNode;
    pStrNode->_pLastChild = pLastNode;
    
    for (CDispNode* pChild = pFirstNode;
         pChild != pLastNode->_pNext;
         pChild = pChild->_pNext)
    {
        pChild->_pParent = pStrNode;
    }

    // parent loses these children but gains 1 structure node
    _cChildren -= cChildren - 1;

    WHEN_DBG(VerifyTreeCorrectness();)
    
    // now rebalance the new structure node
    if (cChildren > DISP_AVERAGE_CHILDREN)
    {
        pStrNode->Rebalance(cChildren);
    }
    else
    {
        pStrNode->CopyFlags(s_recalc, s_recalc);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertNewStructureNode
//              
//  Synopsis:   Insert a new (childless) structure node as a child.
//              
//  Arguments:  pNodePrev           child that becomes predecessor of new node
//              pNodeNext           child that becomes successor of new node
//              structureFlags      value for flag bits
//              structureMask       mask for flag bits
//
//  Returns:    pointer to new structure node
//              
//----------------------------------------------------------------------------

CDispParentNode *
CDispParentNode::InsertNewStructureNode(
        CDispNode* pNodePrev,
        CDispNode* pNodeNext,
        int structureFlags,
        int structureMask)
{
    CDispParentNode* pStrNode;
    if (!CreateStructureNodes(&pStrNode, 1))
        return NULL;
    
    Assert(pStrNode->IsStructureNode());
    Assert(pNodePrev == NULL || (pNodePrev->_pParent == this && pNodePrev->_pNext == pNodeNext));
    Assert(pNodeNext == NULL || (pNodeNext->_pParent == this && pNodeNext->_pPrevious == pNodePrev));
    
    // set flags in structure node correctly
    pStrNode->CopyFlags(structureFlags, structureMask);

    // hook up new node into the tree
    pStrNode->_pParent = this;
    pStrNode->_pPrevious = pNodePrev;
    pStrNode->_pNext = pNodeNext;
    if (pNodePrev)
        pNodePrev->_pNext = pStrNode;
    if (pNodeNext)
        pNodeNext->_pPrevious = pStrNode;

    // set new node's child info
    pStrNode->_cChildren = 0;
    pStrNode->_pFirstChild = NULL;
    pStrNode->_pLastChild = NULL;

    // update this node's child info: one more child, which may be first or last
    _cChildren++;
    if (pNodePrev == NULL)
        _pFirstChild = pStrNode;
    if (pNodeNext == NULL)
        _pLastChild = pStrNode;

    WHEN_DBG(VerifyTreeCorrectness();)

    return pStrNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetStructureInfo
//              
//  Synopsis:   Prepare for rebalancing and gather relevant balancing data.
//              
//  Arguments:  pfMustRebalance     returns TRUE if balancing is required
//              pcNonStructure      returns count of non structure descendants
//                              
//  Returns:    number of immediate children belonging to this node
//              
//----------------------------------------------------------------------------

long
CDispParentNode::GetStructureInfo(BOOL* pfMustRebalance, long* pcNonStructure)
{
    Assert(IsStructureNode());
    
    Assert(_cChildren > 0);
    long cTotalGrandchildren = 0;
    long cMaxGrandchildren = MINLONG;
    long cMinGrandchildren = MAXLONG;
    
    CDispNode* pChild = _pFirstChild;
    while (pChild != NULL)
    {
        if (pChild->IsStructureNode())
        {
            long cGrandchildren =
                pChild->AsParent()->GetStructureInfo(pfMustRebalance, pcNonStructure);
            
            if (cGrandchildren > cMaxGrandchildren)
                cMaxGrandchildren = cGrandchildren;
            if (cGrandchildren < cMinGrandchildren)
                cMinGrandchildren = cGrandchildren;
            cTotalGrandchildren += cGrandchildren;
        }
        else
        {
            (*pcNonStructure)++;
        }
        pChild = pChild->_pNext;
    }
    
    long cAverageGrandchildren = cTotalGrandchildren / _cChildren;
    
    if (_cChildren > DISP_MAX_CHILDREN ||
        cMaxGrandchildren > cAverageGrandchildren + DISP_STRUCTURE_DEVIATION ||
        cMinGrandchildren < cAverageGrandchildren - DISP_STRUCTURE_DEVIATION)
    {
        *pfMustRebalance = TRUE;
    }
    
    ClearFlag(s_rebalance);
    
    return _cChildren;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::RebalanceIfNecessary
//              
//  Synopsis:   Rebalance the subtree rooted at this structure node if
//              rebalancing is actually needed.
//              
//----------------------------------------------------------------------------

void
CDispParentNode::RebalanceIfNecessary()
{
    Assert(IsStructureNode());
    Assert(MustRebalance());
    
    BOOL fMustRebalance = FALSE;
    long cNonStructure = 0;
    GetStructureInfo(&fMustRebalance, &cNonStructure);
    
    if (fMustRebalance)
        Rebalance(cNonStructure);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetNextSiblingNodeOf
//              
//  Synopsis:   Find the right nearest node, descending as necessary
//              through structure nodes.
//
//  Arguments:  pNode: ptr to node which sibling is to be found
//
//  Returns:    ptr to next sibling or NULL
//
//  Note:       this routine is almost the same as CDispNode::GetNextSiblingNode.
//              The only difference is tree ascending is limited with "this" node
//              (while CDispNode::GetNextSiblingNode stops ascending
//              when meet any non-structure node).
//----------------------------------------------------------------------------
__forceinline CDispNode*
CDispParentNode::GetNextSiblingNodeOf(CDispNode* pNode) const
{
    if (pNode->_pNext) return pNode->_pNext;

    // ascending to next level of tree
    for (pNode = pNode->_pParent; ; pNode = pNode->_pParent)
    {
        if (pNode->AsParent() == this) return 0;
        if (pNode->_pNext) break;
    }
    
    pNode = pNode->_pNext;
    Assert(pNode->IsStructureNode());

    // descending into structure nodes
    do
    {
        pNode = pNode->AsParent()->_pFirstChild;
        Assert(pNode);
    }
    while (pNode->IsStructureNode());

    return pNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::Rebalance
//              
//  Synopsis:   Rebalance the subtree rooted at this structure node.
//              
//  Arguments:  cChildren           the total number of non-structure
//                                  descendents in this subtree
//                              
//  Notes:      This routine is somewhat tricky.  One of the goals in its
//              design was to avoid excessive memory allocation.
//              
//----------------------------------------------------------------------------

void
CDispParentNode::Rebalance(long cChildren)
{
    Assert(IsStructureNode());

    // how many structure nodes will we need?
    long cNodes = cChildren;
    long cTotalStrNodes = 0;
    do
    {
        // calculate number of structure nodes on the next level of the tree
        cNodes = (cNodes + DISP_AVERAGE_CHILDREN - 1) / DISP_AVERAGE_CHILDREN;
        cTotalStrNodes += cNodes;
    } while (cNodes > DISP_AVERAGE_CHILDREN);
    
    // allocate structure nodes
    CDispParentNode** ppStrNodes = new CDispParentNode* [cTotalStrNodes+1];
    if(!ppStrNodes)
        return;
    if (!CreateStructureNodes(ppStrNodes, cTotalStrNodes))
    {
        delete [] ppStrNodes;
        return;
    }
    
    // we add this structure node to the array of structure nodes, so that its
    // new children will be linked into it as the final step of our rebalancing
    // algorithm
    ppStrNodes[cTotalStrNodes] = this;
    
    // set recalc flag on all structure nodes
    int strFlags = MaskFlags(DISP_STRUCTURE_MASK) | s_recalc;
    int strMask  =           DISP_STRUCTURE_MASK  | s_recalc;
    
    long i = 0;
    CDispNode* pChild = GetFirstChildNode();
    
    // calculate number of structure nodes at the base level
    long cStrNodes = (cChildren + DISP_AVERAGE_CHILDREN - 1) / DISP_AVERAGE_CHILDREN;
    Assert(cStrNodes > 0);
    long cChildrenPerNode = cChildren / cStrNodes;
    Assert(cChildrenPerNode > 0);
    long cExtraChildren = cChildren - cStrNodes * cChildrenPerNode;
    
    for (i = 0; i < cStrNodes; i++)
    {
        // get next structure node and calculate how many children it gets
        CDispParentNode* pStrNode = ppStrNodes[i];
        Assert(pStrNode != NULL && pStrNode->IsStructureNode());
        pStrNode->CopyFlags(strFlags, strMask);
        pStrNode->_cChildren = cChildrenPerNode;
        if (cExtraChildren > 0)
        {
            (pStrNode->_cChildren)++;
            cExtraChildren--;
        }
        
        // adopt first child
        Assert(pChild != NULL);
        pStrNode->_pFirstChild = pChild;
        
        // move children to structure node
        CDispNode* pPrevious = NULL;
        for (long j = 0; j < pStrNode->_cChildren; j++)
        {
            Assert(pChild != NULL);
            CDispNode* pNext = GetNextSiblingNodeOf(pChild);
            pChild->_pParent = pStrNode;
            pChild->_pPrevious = pPrevious;
            pPrevious = pChild;
            pChild = pNext;
            pPrevious->_pNext = pChild;
        }
        
        // adopt last child
        Assert(pPrevious != NULL);
        pStrNode->_pLastChild = pPrevious;
        pPrevious->_pNext = NULL;
    }
    
    // we better have moved all the children
    Assert(pChild == NULL && cExtraChildren == 0);
        
    // delete old structure nodes
    DeleteStructureNodes();
    
    // adopt each new layer of structure nodes
    long cAdoptChild = 0;
    do
    {
        // calculate number of structure nodes on the next level of the tree
        cChildren = cStrNodes;
        cStrNodes = (cChildren + DISP_AVERAGE_CHILDREN - 1) / DISP_AVERAGE_CHILDREN;
        Assert(cStrNodes > 0);
        cChildrenPerNode = cChildren / cStrNodes;
        Assert(cChildrenPerNode > 0);
        cExtraChildren = cChildren - cStrNodes * cChildrenPerNode;
        
        for (long j = 0; j < cStrNodes; j++)
        {
            CDispParentNode* pStrNode = ppStrNodes[i++];
            Assert(pStrNode != NULL && pStrNode->IsStructureNode());
            pStrNode->CopyFlags(strFlags, strMask);
            pStrNode->_cChildren = cChildrenPerNode;
            if (cExtraChildren > 0)
            {
                (pStrNode->_cChildren)++;
                cExtraChildren--;
            }
            
            // adopt first child
            pChild = ppStrNodes[cAdoptChild];
            pStrNode->_pFirstChild = pChild;
            
            // move children to structure node
            CDispNode* pPrevious = NULL;
            for (long k = 0; k < pStrNode->_cChildren; k++)
            {
                CDispParentNode* pNext = ppStrNodes[++cAdoptChild];
                pChild->_pParent = pStrNode;
                pChild->_pPrevious = pPrevious;
                pPrevious = pChild;
                pChild = pNext;
                pPrevious->_pNext = pChild;
            }
            
            // adopt last child
            Assert(pPrevious != NULL);
            pStrNode->_pLastChild = pPrevious;
            pPrevious->_pNext = NULL;
        }
    } while (cAdoptChild < cTotalStrNodes);

    delete [] ppStrNodes;

    WHEN_DBG(VerifyTreeCorrectness();)
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::DeleteStructureNodes
//              
//  Synopsis:   Recursively delete unused structure nodes under this
//              structure node after we've finished rebalancing
//              a structured subtree.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::DeleteStructureNodes()
{
    Assert(IsStructureNode());
    Assert(_pFirstChild != NULL);

    if (_pFirstChild->IsStructureNode())
    {
        CDispParentNode* pStrNode;
        CDispParentNode* pNext;
        for (pStrNode = _pFirstChild->AsParent();
             pStrNode != NULL;
             pStrNode = pNext)
        {
            Assert(pStrNode->IsStructureNode());
            
            pNext = pStrNode->_pNext->AsParent();
            pStrNode->DeleteStructureNodes();
            
            // ensure that destructor for structure node doesn't try to
            // delete children
            pStrNode->_cChildren   = 0;
            pStrNode->_pFirstChild = 0;
            pStrNode->_pLastChild  = 0;
            pStrNode->Delete();
        }
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::VerifyChildrenCount
//              
//  Synopsis:   Verify that this parent node has the correct number of
//              non-destroyed children.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::VerifyChildrenCount()
{
    long cChildren = 0;
    for (CDispNode* pChild = _pFirstChild;
         pChild != NULL;
         pChild = pChild->_pNext)
    {
        cChildren++;
    }
    
    Assert(cChildren == _cChildren);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\dispcontainer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispcontainer.cxx
//
//  Contents:   Basic container node which introduces a new coordinate system
//              and clipping.
//
//  Classes:    CDispContainer
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

#ifndef X_DISPFILTER_HXX_
#define X_DISPFILTER_HXX_
#include "dispfilter.hxx"
#endif

#ifndef _PAINTER_H_
#define _PAINTER_H_
#include "painter.h"
#endif

MtDefine(CDispContainer, DisplayTree, "CDispContainer")


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::CDispContainer
//
//  Synopsis:   Construct a container node with equivalent functionality to
//              the CDispLeafNode passed as an argument.
//
//  Arguments:  pLeafNode       the prototype CDispLeafNode
//
//  Notes:
//
//----------------------------------------------------------------------------


CDispContainer::CDispContainer(const CDispLeafNode* pLeafNode)
        : CDispParentNode(pLeafNode->GetDispClient())
{
    // copy size and position
    pLeafNode->GetBounds(&_rcpContainer);

    // copy relevant flags
    CopyFlags(pLeafNode->GetFlags(), s_layerMask |
                                     s_visibleNode |
                                     s_owned | 
                                     s_hasBackground |
                                     s_noScrollBounds |
                                     s_drawnExternally);
    Assert(!IsStructureNode());
    Assert(IsParentNode());

    // Container's effective origin is calculated differently from 
    // leaf node's (in fact, it is always zero). Update origin with 
    // current values to force recalculation
    if (HasContentOrigin())
    {
        SetContentOrigin(GetContentOrigin(), GetContentOffsetRTL());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::SetSize
//
//  Synopsis:   Set size of this node.
//
//  Arguments:  sizep               new size in parent coords
//              fInvalidateAll      TRUE to entirely invalidate this node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::SetSize(
        const CSize& sizep,
        const CRect *prcpMapped,
        BOOL fInvalidateAll)
{
    if (prcpMapped)
    {
        if (!HasAdvanced())
            SetUpAdvancedDisplay();
        if (HasAdvanced())
            GetAdvanced()->SetMappedBounds(prcpMapped);
    }
    else
    {
        if (HasAdvanced())
            GetAdvanced()->SetNoMappedBounds();
    }

    if (sizep == _rcpContainer.Size())
        return;

    if (!IsInvalid() && IsVisible() && IsInView() && (fInvalidateAll || HasUserTransform()))
    {
       // Invalidate the old rect
        Invalidate();
    }  

    CRect rcpOld(_rcpContainer);
    _rcpContainer.SetSize(sizep);

    // for RTL nodes, keep orinal content right-aligned by adjusting content offset
    if (HasContentOrigin() && GetContentOffsetRTL() >= 0)
    {
        // this recalculates offset from left and invalidates if necessary
        SetContentOrigin(GetContentOrigin(), GetContentOffsetRTL());
    }
    

    // if the inval flag is set, we don't need to invalidate because the
    // current bounds might never have been rendered
    if (!IsInvalid())
    {
        // recalculate in-view flag of all children
        RequestRecalcSubtree();

        if (HasWindowTop())
        {
            InvalidateAtWindowTop();
            SetInvalid();
        }
        else if (IsInView())
        {
            if (fInvalidateAll || HasUserTransform())
            {
                SetInvalid();                           // inval new bounds
            }
            else
            {
                CRect rcbBorderWidths;
                GetBorderWidths(&rcbBorderWidths);
                InvalidateEdges(rcpOld.Size(), sizep, rcbBorderWidths);
            }
        }
        else
        {
            SetInvalid();
        }
    }

    GetDispClient()->OnResize(sizep, this);
    WHEN_DBG(VerifyRecalc());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::SetPosition
//
//  Synopsis:   Set the top left position of this container.
//
//  Arguments:  ptpTopLeft      top left coordinate of this container
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::SetPosition(const CPoint& ptpTopLeft)
{
    if (_rcpContainer.TopLeft() != ptpTopLeft)
    {
        // TODO (donmarsh) - I believe we are recalcing the entire
        // subtree to compute new inview status, but this seems like
        // overkill.  We may be able to improve perf by being a little
        // smarter here.
        InvalidateAndRecalcSubtree();
        
        Assert(MustRecalc());

        _rcpContainer.MoveTo(ptpTopLeft);
        // _rctBounds will be recomputed during recalc
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::GetClientRect
//
//  Synopsis:   Return rectangles for various interesting parts of a display
//              node.
//
//  Arguments:  prc         rect which is returned
//              type        type of rect wanted
//
//  Notes:      WARNING: the coordinate system of the returned rect depends
//              on the type!
//
//----------------------------------------------------------------------------

void
CDispContainer::GetClientRect(RECT* prc, CLIENTRECT type) const
{
    switch (type)
    {
    case CLIENTRECT_BACKGROUND:
    case CLIENTRECT_CONTENT:
        {
            CRect rcbBorderWidths;
            GetBorderWidths(&rcbBorderWidths);
            
            ((CRect*)prc)->SetRect(
                _rcpContainer.Size()
                - rcbBorderWidths.TopLeft().AsSize()
                - rcbBorderWidths.BottomRight().AsSize());

            // RTL nodes may have non-zero content origin
            if (HasContentOrigin())
            {
                ((CRect*)prc)->OffsetRect(-GetContentOrigin());
            }

            // NOTE: we check emptiness for each individual dimension instead
            // of simply assigning g_Zero.rc, because the layout code uses
            // values from the non-empty dimension in certain circumstances
            if (prc->left >= prc->right)
                prc->left = prc->right = 0;
            if (prc->top >= prc->bottom)
                prc->top = prc->bottom = 0;
        }
        break;
    default:
        *prc = g_Zero.rc;
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::PreDraw
//
//  Synopsis:   Before drawing starts, PreDraw processes the redraw region,
//              subtracting areas that are blocked by opaque or buffered items.
//              PreDraw is finished when the redraw region becomes empty
//              (i.e., an opaque item completely obscures all content below it)
//
//  Arguments:  pContext    draw context, in COORDSYS_TRANSFORMED
//
//  Returns:    TRUE if first opaque node to draw has been found
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::PreDraw(CDispDrawContext* pContext)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(s_preDrawSelector));
    Assert(pContext->IntersectsRedrawRegion(_rctBounds));
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    // We do not delve inside a node whose content is drawn externally.
    // TODO (sambent) Someday, filters may help determine whether PreDraw
    // can safely look at its children and come up with the correct answers.
    if (IsDrawnExternally())
        return FALSE;
    
    // TODO (donmarsh) - subtracting transformed nodes (or their transformed
    // children) from the redraw region is too expensive.  This is overkill, and
    // will degrade the performance of Print Preview, for example.  However, we
    // may be able to do a one-time hack for a transformation at the root of
    // the Display Tree, and thus get back opaque optimizations for the case
    // where the whole view is scaled (but not rotated!)
    if (HasUserTransform())
        return FALSE;
    
    // save current transform
    CDispClipTransform saveTransform(pContext->GetClipTransform());
    if (!TransformedToBoxCoords(&pContext->GetClipTransform(), pContext->GetRedrawRegion()))
    {
        pContext->SetClipTransform(saveTransform);
        return FALSE;
    }
    
    // offset children
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    TransformBoxToContent(&pContext->GetClipTransform(), di);
    CDispClipTransform saveContentTransform(pContext->GetClipTransform());

    // continue predraw traversal of children, top layers to bottom
    int lastLayer = s_layerMask;  // greater than any possible value
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        // only children which meet our selection criteria
        if (pChild->IsAllSet(s_preDrawSelector))
        {
            // switch clip rectangles and offsets between different layer types
            int childLayer = pChild->GetLayer();
            if (childLayer != lastLayer)
            {
                Assert(lastLayer > childLayer);

                if (childLayer < s_layerFlow)
                {
                    Assert(childLayer == s_layerNegZ);
                    pContext->SetClipTransform(saveContentTransform);
                }
                else if (childLayer == s_layerFlow)
                {
                    TransformContentToFlow(&pContext->GetClipTransform(), di);
                }
                else
                {
                    Assert(childLayer == s_layerPosZ);
                }

                lastLayer = childLayer;
            }

            // if we found the first child to draw, stop further PreDraw calcs
            if (PreDrawChild(pChild, pContext, saveTransform))
                return TRUE;
        }
    }

    // restore previous transform
    pContext->SetClipTransform(saveTransform);
    
    // if this container is opaque, check to see if it needs to be subtracted
    // from the redraw region
    return
        IsOpaque() &&
        pContext->IntersectsRedrawRegion(_rcpContainer) &&
        CDispNode::PreDraw(pContext);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DrawSelf
//
//  Synopsis:   Draw this node's children, plus optional background.
//
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              pChild          start drawing at this child
//              lDrawLayers     layers to draw (for filters)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::DrawSelf(CDispDrawContext* pContext, CDispNode* pChild, long lDrawLayers)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(pContext->GetDrawSelector()));
    Assert(!IsAnySet(s_flagsNotSetInDraw));
    Assert(!HasUserTransform() || !IsSet(s_savedRedrawRegion));

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);

    // prepare to run the draw program
    CRect rccContent(di._sizecBackground);
    CRect rccClip;
    CDispClipTransform transformBox;

    // fSkipToContent flag is to distinguish full draw pass (fSkipToContent == false)
    // from partial one (fSkipToContent == true). Partial pass arrears as a result
    // of PreDraw() optimization.
    BOOL fSkipToContent = (pChild != NULL);

    // draw children, bottom layers to top
    if (pChild == NULL)
        pChild = _pFirstChild;

    // find out which draw program to run
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, lDrawLayers))
    {
        AssertSz(0, "Failed to get draw program");
        return;
    }

    if (HasAdvanced())
    {
        transformBox = pContext->GetClipTransform();
    }

    int iCookie = -1;
    void * cookie = NULL;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    // run the program
    for (int iPC = DP_START_INDEX;  aryProgram[iPC] != DP_Done;  ++iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawBorder:
            // draw optional border
            //Assert(pContext is in box coords);
            DrawBorder(pContext, *di._prcbBorderWidths, GetDispClient());
            break;

        case DP_DrawBackground:
            //Assert(pContext is in box coords);
            if (HasBackground() && !fSkipToContent)
            {
                DrawBackground(pContext, di);
            }
            // fall through to BoxToContent

        case DP_BoxToContent:
            TransformBoxToContent(&pContext->GetClipTransform(), di);
            break;

        case DP_DrawContent:
            {
                DISPNODELAYER layerType = (DISPNODELAYER)aryProgram[++iPC];
                int layerStop = layerType >= DISPNODELAYER_POSITIVEZ ? s_layerPosZ
                              : layerType >= DISPNODELAYER_FLOW      ? s_layerFlow
                              : layerType >= DISPNODELAYER_NEGATIVEZ ? s_layerNegZ
                              : -1;
                while (pChild && pChild->GetLayer() <= layerStop)
                {
                    if (pChild->IsFlowNode())
                    {
                        CDispClipTransform saveTransform = pContext->GetClipTransform();
                        TransformContentToFlow(&pContext->GetClipTransform(), di);
                        DrawChildren(pContext, &pChild);
                        pContext->SetClipTransform(saveTransform);
                    }
                    else
                        DrawChildren(pContext, &pChild);
                    fSkipToContent = false;
                }
            }
            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.top    = aryProgram[++iPC];
            rcExpand.left   = aryProgram[++iPC];
            rcExpand.bottom = aryProgram[++iPC];
            rcExpand.right  = aryProgram[++iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced());
            cookie = aryCookie[++iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
            // Assert(pContext is in content coords);
            if (!fSkipToContent)
            {
                if (!fExpand)
                {
                    rccClip = di._rccBackgroundClip;
                    
                    GetDispClient()->DrawClientLayers(
                        &rccContent,
                        &rccClip,
                        pContext->PrepareDispSurface(),
                        this,
                        cookie,
                        pContext,
                        CLIENTLAYERS_AFTERBACKGROUND);
                }
                else
                {
                    Assert(HasAdvanced());
                    CSaveDispClipTransform transformSaveContent(pContext);
                    CRect rcbBounds = _rcpContainer.Size();
                    GetMappedBounds(&rcbBounds);
                    
                    pContext->SetClipTransform(transformBox);
                    rcbBounds.Expand(rcExpand);
                    CRect rcbClip = rcbBounds;
                    rcbClip.IntersectRect(transformBox.GetClipRect());
                    
                    GetDispClient()->DrawClientLayers(
                        &rcbBounds,
                        &rcbClip,
                        pContext->PrepareDispSurface(),
                        this,
                        cookie,
                        pContext,
                        CLIENTLAYERS_AFTERBACKGROUND);
                }
            }
            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_WindowTopMulti:     ++iCookie;  // ignore cookie
        case DP_WindowTop:
            if (!HasWindowTop())
            {
                pContext->GetRootNode()->AddWindowTop(this);
            }
            fExpand = FALSE;
            break;

        default:
            AssertSz(0, "Unrecognized draw program opcode");
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DrawChildren
//              
//  Synopsis:   Draw children for a particular layer, starting at the indicated
//              child.
//              
//  Arguments:  pContext    draw context, coordinate system neutral
//              ppChildNode [in] child to start drawing, if it is in the
//                          requested layer
//                          [out] child in next layer (may be NULL)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------
void
CDispContainer::DrawChildren(
        CDispDrawContext* pContext,
        CDispNode** ppChildNode)
{
    CDispNode* pChild = *ppChildNode;
    Assert(pChild);
    if(!pChild || !pContext)
        return;

    int layer = pChild->GetLayer();
    
    do
    {
        // is this child visible and in view?
        if (pChild->IsAllSet(pContext->GetDrawSelector()))
            pChild->Draw(pContext, NULL, FILTER_DRAW_ALLLAYERS);
        
        pChild = pChild->_pNext;
    }
    while (pChild != NULL && pChild->GetLayer() == layer);
    
    // remember new child pointer for subsequent layers
    *ppChildNode = pChild;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::HitTestPoint
//
//  Synopsis:   Determine whether any of our children, OR THIS CONTAINER,
//              intersects the hit test point.
//
//  Arguments:  pContext        hit context, in COORDSYS_TRANSFORMED
//              fForFilter      TRUE when we're called from a filter
//              fHitContent     TRUE to hit contents of this container,
//                              regardless of this container's bounds
//                              
//  Returns:    TRUE if any child or this container intersects the hit test pt.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::HitTestPoint(CDispHitContext* pContext, BOOL fForFilter, BOOL fHitContent)
{
    Assert(IsVisibleBranch());
    
    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //
    Assert(fHitContent || fForFilter || pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest()));

    CDispClipTransform transformSaveTransformed(pContext->GetClipTransform());
    TransformedToBoxCoords(&pContext->GetClipTransform());
    CDispClipTransform boxTransform(pContext->GetClipTransform());
    BOOL               fPeerDeclinedHit = FALSE;

    //
    // Save the current coordinate system
    //
    COORDINATE_SYSTEM csSave = pContext->GetHitTestCoordinateSystem();

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);

    // open up clipping rect for children if we are hitting contents
    // regardless of this container's bounds
    if (fHitContent)
    {
        di._rccPositionedClip = di._rcfFlowClip = di._rcbContainerClip;
    }
    
    CRect rccContent(di._sizecBackground);

    // transform to content coordinates
    TransformBoxToContent(&pContext->GetClipTransform(), di);
    CDispClipTransform contentTransform(pContext->GetClipTransform());

    // hack for VID's "frozen" attribute
    {
        CPoint ptcHitTest;
        pContext->GetHitTestPoint(&ptcHitTest);
        if (GetDispClient()->HitTestBoxOnly(
                &ptcHitTest,
                this,
                pContext->_pClientData))
        {
            // NOTE: don't bother to restore context transform for speed
            pContext->SetHitTestCoordinateSystem(COORDSYS_CONTENT);                
            return TRUE;
        }
    }

    // get the draw program
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    int iPC;
    int iCookie;
    BOOL fNeedScrollbarTest = IsScroller();
    
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, FILTER_DRAW_ALLLAYERS))
    {
        AssertSz(0, "Failed to get draw program");
        return FALSE;
    }

    // we will run the program backwards;  first fix up the arguments
    ReverseDrawProgram(aryProgram, &iPC, &iCookie);

    // search for a hit from foreground layers to background
    int lastLayer = s_layerMask;
    int layerStop;
    void * cookie = NULL;
    COORDINATE_SYSTEM csCurrent = COORDSYS_CONTENT;
    BOOL fExpand = false;
    CRect rcExpand = g_Zero.rc; // keep compiler happy
    
    for (CDispNode* pChild = _pLastChild;  iPC>=DP_START_INDEX;  --iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawContent:
            // we make an exception to the "hittest is reverse of draw" rule for scrollers.
            // Scrollbars are drawn at the same time as the border (i.e. before content),
            // but we hit test the scrollbars before the content to avoid an expensive
            // descent into the tree just to scroll.
            if (fNeedScrollbarTest)
            {
                pContext->SetClipTransform(boxTransform);
                if (DYNCAST(CDispScroller, this)->HitTestScrollbars(pContext, fHitContent))
                {
                    pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                    return TRUE;
                }
                pContext->SetClipTransform(contentTransform);
                fNeedScrollbarTest = FALSE;
            }

            {
                DISPNODELAYER layerType = (DISPNODELAYER)aryProgram[--iPC];
                layerStop = layerType <= DISPNODELAYER_NEGATIVEZ ? s_layerNegZ
                          : layerType <= DISPNODELAYER_FLOW      ? s_layerFlow
                          : layerType <= DISPNODELAYER_POSITIVEZ ? s_layerPosZ
                          :                                        s_layerMask;
            }
            for ( ;
                pChild && pChild->GetLayer() >= layerStop;
                pChild = pChild->_pPrevious)
            {
                // if this branch has no visible children, skip it
                if (!pChild->IsVisibleBranch())
                    continue;
     
                // switch clip rectangles and offsets between different layer types
                int childLayer = pChild->GetLayer();
                if (childLayer != lastLayer)
                {
                    Assert(lastLayer > childLayer);
                    COORDINATE_SYSTEM csDesired = (childLayer == s_layerFlow
                                        ? COORDSYS_FLOWCONTENT : COORDSYS_CONTENT);
                    if (csDesired != csCurrent)
                    {
                        switch (csDesired)
                        {
                        case COORDSYS_CONTENT:
                            pContext->SetClipTransform(contentTransform);
                            break;
                        case COORDSYS_FLOWCONTENT:
                            TransformContentToFlow(&pContext->GetClipTransform(), di);
                            break;
                        default:
                            Assert(FALSE);
                            break;
                        }
                        csCurrent = csDesired;
                    }
                    lastLayer = childLayer;

                    //
                    //
                    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
                    // TODO - At some point the edit team may want to provide
                    // a better UI-level way of selecting nested "thin" tables
                    //

                    // can any child in this layer contain the hit point?
                    if (!pContext->FuzzyRectIsHit(pContext->GetClipRect(), IsFatHitTest() ))
                    {
                        // skip to previous layer:
                        // find the first child that have layerType == childLayer
                        for (pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
                        {
                            int childLayer2 = pChild->GetLayer();
                            if (childLayer2 == childLayer)
                                break; // found it; result may be a structure node
                            if (childLayer2 > childLayer)
                            {
                                pChild = NULL; // no such layer present
                                break;
                            }
                        }
                        continue;
                    }
                }

                //
                // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
                // TODO - At some point the edit team may want to provide
                // a better UI-level way of selecting nested "thin" tables
                //
                if (pContext->FuzzyRectIsHit(pChild->_rctBounds, pChild->IsFatHitTest() ) &&
                    pChild->HitTestPoint(pContext))
                {
                    // NOTE: don't bother to restore _ptHitTest for speed
                    return TRUE;
                }
            }

            //
            // if the hit test failed from here
            // restore the original cs
            //

            pContext->SetHitTestCoordinateSystem(csSave);

            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.right  = aryProgram[--iPC];
            rcExpand.bottom = aryProgram[--iPC];
            rcExpand.left   = aryProgram[--iPC];
            rcExpand.top    = aryProgram[--iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced() && iCookie>=1);
            cookie = aryCookie[--iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
            if (IsVisible())
            {
                if (!fExpand)
                {
                    pContext->SetClipTransform(contentTransform);
                    if (pContext->RectIsHit(di._rccBackgroundClip))
                    {
                        CPoint ptcHitTest;
                        BOOL   fLocalPeerDeclined = FALSE;  

                        pContext->GetHitTestPoint(&ptcHitTest);
                        pContext->SetClipTransform(transformSaveTransformed);
                        if (GetDispClient()->HitTestPeer(
                                &ptcHitTest,
                                COORDSYS_CONTENT,
                                this,
                                cookie,
                                pContext->_pClientData,
                                fHitContent,
                                pContext,
                                &fLocalPeerDeclined))
                        {
                            // NOTE: don't bother to restore context transform for speed
                            return TRUE;
                        }

                        fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;

                        pContext->SetClipTransform(contentTransform);
                    }
                }
                else
                {
                    pContext->SetClipTransform(boxTransform);
                    CRect rcbBounds = _rcpContainer.Size();
                    if (!fForFilter)
                        GetMappedBounds(&rcbBounds);
                    rcbBounds.Expand(rcExpand);
                    if (pContext->RectIsHit(rcbBounds))
                    {
                        CPoint ptbHitTest;
                        BOOL   fLocalPeerDeclined = FALSE;  

                        pContext->GetHitTestPoint(&ptbHitTest);
                        pContext->SetClipTransform(transformSaveTransformed);
                        if (GetDispClient()->HitTestPeer(
                                &ptbHitTest,
                                COORDSYS_BOX,
                                this,
                                cookie,
                                pContext->_pClientData,
                                fHitContent,
                                pContext,
                                &fLocalPeerDeclined))
                        {
                            // NOTE: don't bother to restore context transform for speed
                            return TRUE;
                        }

                        fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;
                    }
                    pContext->SetClipTransform(contentTransform);
                    csCurrent = COORDSYS_CONTENT;
                }
            }
            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_DrawBackground:
            if (IsVisible())
            {
                pContext->SetClipTransform(contentTransform);
                if (pContext->RectIsHit(di._rccBackgroundClip))
                {
                    CPoint ptcHitTest;
                    pContext->GetHitTestPoint(&ptcHitTest);
                    if (GetDispClient()->HitTestContent(
                            &ptcHitTest,
                            this,
                            pContext->_pClientData,
                            fPeerDeclinedHit ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_CONTENT);
                        return TRUE;
                    }
                }
            }
            break;

        case DP_WindowTopMulti:     --iCookie;
        case DP_WindowTop:
            fExpand = FALSE;
            break;

        case DP_BoxToContent:
            break;

        case DP_DrawBorder:
            // check for scrollbar hit (if we haven't already done so)
            if (fNeedScrollbarTest)
            {
                pContext->SetClipTransform(boxTransform);
                if (DYNCAST(CDispScroller, this)->HitTestScrollbars(pContext, fHitContent))
                {
                    pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                    return TRUE;
                }
                pContext->SetClipTransform(contentTransform);
                fNeedScrollbarTest = FALSE;
            }

            // check for border hit
            if (IsVisible() && HasBorder())
            {
                pContext->SetClipTransform(boxTransform);
                CSize sizepNode = _rcpContainer.Size();
                
                if (pContext->RectIsHit(di._rcbContainerClip) &&
                    (pContext->RectIsHit(CRect(0,0, di._prcbBorderWidths->left, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0,0, sizepNode.cx, di._prcbBorderWidths->top)) ||
                     pContext->RectIsHit(CRect(sizepNode.cx - di._prcbBorderWidths->right, 0, sizepNode.cx, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0, sizepNode.cy - di._prcbBorderWidths->bottom, sizepNode.cx, sizepNode.cy))))
                {
                    CPoint ptbHitTest;
                    pContext->GetHitTestPoint(&ptbHitTest);
                    
                    if (GetDispClient()->HitTestBorder(
                            &ptbHitTest,
                            (CDispContainer*)this,
                            pContext->_pClientData))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                        return TRUE;
                    }
                }
                
                pContext->SetClipTransform(contentTransform);
            }
            break;
        }
        
    }
    
    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    
    // do fuzzy hit test if requested
    if (pContext->_cFuzzyHitTest)
    {
        pContext->SetClipTransform(boxTransform);
        CRect rcbContainer(_rcpContainer.Size());
        if (!pContext->RectIsHit(rcbContainer) &&
            pContext->FuzzyRectIsHit(rcbContainer, IsFatHitTest()))
        {
            CPoint ptbHitTest;
            pContext->GetHitTestPoint(&ptbHitTest);
            if (GetDispClient()->HitTestFuzzy(
                    &ptbHitTest,
                    (CDispContainer*)this,
                    pContext->_pClientData))
            {
                pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                return TRUE;
            }
        }
    }
        
    // restore transform
    pContext->SetClipTransform(transformSaveTransformed);
    
    return FALSE;
}


CDispScroller *
CDispContainer::HitScrollInset(const CPoint& pttHit, DWORD *pdwScrollDir)
{
    CPoint ptcHit;
    TransformPoint(pttHit, COORDSYS_TRANSFORMED, &ptcHit, GetContentCoordinateSystem());
    return super::HitScrollInset(ptcHit, pdwScrollDir);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::CalcDispInfo
//
//  Synopsis:   Calculate clipping and positioning info for this node.
//
//  Arguments:  rcbClip         clip rect in box coords
//              pdi             display info structure
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::CalcDispInfo(
        const CRect& rcbClip,
        CDispInfo* pdi) const
{
    CDispInfo& di = *pdi;   // notational convenience

    // no scrolling
    di._sizesScroll = g_Zero.size;
    
    // content size
    _rcpContainer.GetSize(&di._sizesContent);
    
    // offset to box coordinates
    _rcpContainer.GetTopLeft(&(di._sizepBoxToParent.AsPoint()));

    // calc container clip in box coordinates
    di._rcbContainerClip.SetRect(di._sizesContent);
    di._rcbContainerClip.IntersectRect(rcbClip);
    
    // calc positioned clip (in box coordinates, so far)
    di._rccPositionedClip = rcbClip;

    // inset user clip and flow clip by optional border
    GetBorderWidthsAndInset(&di._prcbBorderWidths, &di._sizecInset, &di._rcTemp);
    di._sizebScrollToBox = di._prcbBorderWidths->TopLeft().AsSize();
    di._sizesContent.cx -= di._prcbBorderWidths->left + di._prcbBorderWidths->right;
    di._sizesContent.cy -= di._prcbBorderWidths->top + di._prcbBorderWidths->bottom;
    di._sizecBackground = di._sizesContent;
    di._rccPositionedClip.OffsetRect(-di._sizebScrollToBox);    // to scroll coords
    di._rccBackgroundClip.top = max(0L, di._rccPositionedClip.top);
    di._rccBackgroundClip.bottom = min(di._sizesContent.cy,
                                      di._rccPositionedClip.bottom);
    di._rccBackgroundClip.left = max(0L, di._rccPositionedClip.left);
    di._rccBackgroundClip.right = min(di._sizecBackground.cx,
                                     di._rccPositionedClip.right);
    di._rcfFlowClip.left = max(di._rccBackgroundClip.left, di._sizecInset.cx);
    di._rcfFlowClip.right = di._rccBackgroundClip.right;
    di._rcfFlowClip.top = max(di._rccBackgroundClip.top, di._sizecInset.cy);
    di._rcfFlowClip.bottom = di._rccBackgroundClip.bottom;
    di._rcfFlowClip.OffsetRect(-di._sizecInset);
    
    // optional offset from content origin
    if (HasContentOrigin())
    {
        const CSize& sizecOrigin = GetContentOrigin();
        di._sizesScroll += sizecOrigin;

        // adjust all content rects for content origin
        di._rccPositionedClip.OffsetRect(-sizecOrigin);
        di._rccBackgroundClip.OffsetRect(-sizecOrigin);
        di._rcfFlowClip.OffsetRect(-sizecOrigin);
    }

    if (HasExpandedClipRect())
    {
        const CRect& rcExpandedClip = GetExpandedClipRect();
        di._rccPositionedClip.Expand(rcExpandedClip);
        di._rccBackgroundClip.Expand(rcExpandedClip);
        di._rcfFlowClip.Expand(rcExpandedClip);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::PushTransform
//
//  Synopsis:   Get transform for the given child node.
//
//  Arguments:  pChild          the child node
//              pTransformStack transform stack to save transform changes in
//              pTransform      display transform
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::PushTransform(
        const CDispNode* pChild,
        CDispTransformStack* pTransformStack,
        CDispClipTransform* pTransform) const
{
    super::PushTransform(pChild, pTransformStack, pTransform);

    // modify transform for child
    CDispClipTransform childTransform;
    GetNodeClipTransform(
        &childTransform,
        pChild->GetContentCoordinateSystem(),
        COORDSYS_TRANSFORMED);
    
    // child transform first
    childTransform.AddPostTransform(*pTransform);
    *pTransform = childTransform;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::ComputeVisibleBounds
//
//  Synopsis:   Compute visible bounds for a parent node, marking children
//              that determine the edges of these bounds
//
//  Arguments:  none
//
//  Returns:    TRUE if visible bounds changed.
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::ComputeVisibleBounds()
{
    // visible bounds is always the size of the container, and may be extended
    // by items in Z layers that fall outside these bounds
    CRect rcbBounds(_rcpContainer.Size());
    GetMappedBounds(&rcbBounds);
    CRect rcbBoundsExpanded;
    
    SetPainterState(rcbBounds, &rcbBoundsExpanded);

    // expand bounds to include all positioned children
    CRect rccBounds(CRect::CRECT_EMPTY);
    CRect rcbChildren;

    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        if ((!pChild->IsFlowNode() || pChild->HasWindowTop())
            &&
            !pChild->_rctBounds.IsEmpty())
        {
            rccBounds.Union(pChild->_rctBounds);
        }
    }
    TransformRect(rccBounds, COORDSYS_CONTENT, &rcbChildren, COORDSYS_BOX);
    rcbBoundsExpanded.Union(rcbChildren);

    // convert to transformed coordinates
    CRect rctBounds;
    TransformRect(rcbBoundsExpanded, COORDSYS_BOX, &rctBounds, COORDSYS_TRANSFORMED);
        
    if (rctBounds != _rctBounds)
    {
        _rctBounds = rctBounds;
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::CalculateInView
//
//  Synopsis:   Calculate whether this node and its children are in view or not.
//
//  Arguments:  transform           display transform, in COORDSYS_TRANSFORMED
//              fPositionChanged    TRUE if position changed
//              fNoRedraw           TRUE to suppress redraw (after scrolling)
//
//  Returns:    TRUE if this node is in view
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::CalculateInView(
        const CDispClipTransform& transform,
        BOOL fPositionChanged,
        BOOL fNoRedraw,
        CDispRoot *pDispRoot)
{
    BOOL fInView = _rctBounds.Intersects(transform.GetClipRect());
    BOOL fWasInView = IsInView();
    
    // calculate in view status of children unless this node is not in view
    // and was not in view
    if (fInView || fWasInView)
    {
        // accelerated way to clear in view status of all children, unless
        // some child needs change notification
        if (!fInView && !IsInViewAware())
        {
            ClearSubtreeFlags(s_inView);
            return FALSE;
        }

        CDispClipTransform newTransform(transform);
        TransformedToBoxCoords(&newTransform);
        
        // calculate clip and position info
        CDispInfo di;
        CalcDispInfo(newTransform.GetClipRect(), &di);

        // set up for content
        TransformBoxToContent(&newTransform, di);
        CDispClipTransform contentTransform(newTransform);

        int lastLayer = -1;
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            // switch clip rectangles and offsets between different layer types
            int childLayer = pChild->GetLayer();
            if (childLayer != lastLayer)
            {
                Assert(lastLayer < childLayer);
                switch (childLayer)
                {
                case s_layerNegZ:
                    break;
                case s_layerFlow:
                    TransformContentToFlow(&newTransform,di);
                    break;
                default:
                    Assert(childLayer == s_layerPosZ);
                    if (lastLayer == s_layerFlow)
                        newTransform = contentTransform;
                    break;
                }
                lastLayer = childLayer;
            }

            pChild->CalculateInView(newTransform, fPositionChanged, fNoRedraw,
                                    pDispRoot);
        }

        // if an obscuring container comes into view, let the root decide
        // whether the obscuring algorithm needs to be run.
        if (!fWasInView && GetDispClient()->WantsToObscure(this))
        {
            Assert(!pDispRoot->IsInRecalc());
            pDispRoot->ObscureElements(g_Zero.rc, this);
        }
    }

    SetInView(fInView);
    return fInView;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::RecalcChildren
//
//  Synopsis:   Recalculate children.
//
//  Arguments:  pContext            recalc context, in COORDSYS_TRANSFORMED
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::RecalcChildren(
        CRecalcContext* pRecalcContext)
{
    Assert(pRecalcContext != NULL);
    
    CDispRecalcContext* pContext = DispContext(pRecalcContext);
    
    // accumulate flag values that are propagated up the tree to the root
    int childrenFlags = 0;

    {
        // save the current transform
        CSaveDispClipTransform saveTransform(pContext);
        TransformedToBoxCoords(&pContext->GetClipTransform());
        
        // calculate clip and position info
        CDispInfo di;
        CalcDispInfo(pContext->GetClipRect(), &di);

        // offset children
        TransformBoxToContent(&pContext->GetClipTransform(), di);
        CDispClipTransform contentTransform(pContext->GetClipTransform());

        // set flag values that are passed down our subtree
        CSwapRecalcState swapRecalcState(pContext, this);

        int lastLayer = -1;
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            Assert(pContext->_fRecalcSubtree ||
                pChild->MustRecalc() ||
                !pChild->IsInvalid());

            // recalc children that need it, or all children if we are recalculating
            // the entire subtree
            if (pContext->_fRecalcSubtree || pChild->MustRecalc())
            {
                // switch clip rectangles and offsets between different layer types
                int childLayer = pChild->GetLayer();
                if (childLayer != lastLayer)
                {
                    Assert(lastLayer < childLayer);
                    switch (childLayer)
                    {
                    case s_layerNegZ:
                        break;
                    case s_layerFlow:
                        TransformContentToFlow(&pContext->GetClipTransform(), di);
                        break;
                    default:
                        Assert(childLayer == s_layerPosZ);
                        if (lastLayer == s_layerFlow)
                            pContext->SetClipTransform(contentTransform);
                        break;
                    }
                    lastLayer = childLayer;
                }

                pChild->Recalc(pContext);
            }
        
            Assert(!pChild->IsInvalid());
            Assert(pChild->IsParentNode() || !pChild->PositionChanged());
            Assert(!pChild->MustRecalc());
            Assert(!pChild->MustRecalcSubtree());
            childrenFlags |= pChild->GetFlags();
        }
    }

    // ensure that we don't bother to invalidate anything during bounds calc.
    SetMustRecalc();
    ComputeVisibleBounds();
    
    BOOL fWasInvalid = IsInvalid();

    // propagate flags from children, and clear recalc and inval flags
    CopyFlags(childrenFlags, s_inval | s_propagatedMask | s_recalc | s_recalcSubtree);

    // set in-view status
    SetInView(pContext->IsInView(_rctBounds));

    // add to invalid area if necessary
    if (fWasInvalid && !pContext->_fSuppressInval && IsAllSet(s_inView | s_visibleNode))
    {
        pContext->AddToRedrawRegion(_rctBounds, !HasWindowTop());
    }

    // set visible branch flag, just in case this container has no
    // children from which the visible branch flag is propagated
    if (IsVisible())
    {
        SetVisibleBranch();
    }

    // set opaque branch flag
    if (MaskFlags(s_opaqueBranch | s_opaqueNode) == s_opaqueNode &&
        _rcpContainer.Area() >= MINIMUM_OPAQUE_PIXELS &&
        !HasUserTransform())
    {
        SetOpaqueBranch();
    }

    // if this element should obscure windows lower in the z-order, do so now
    if (IsInView() && IsVisible() && GetDispClient()->WantsToObscure(this))
    {
        CRect rcgClient;
        CRect rcgClip;

        // save old transform, change context to box coordinates
        CSaveDispClipTransform saveTransform(pContext);
        TransformedToBoxCoords(&pContext->GetClipTransform());

        GetGlobalClientAndClipRects(pContext->GetClipTransform(),
                                    &rcgClient,
                                    &rcgClip);

        pContext->_pRootNode->ObscureElements(rcgClip, this);
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DumpContentInfo
//              
//  Synopsis:   Dump custom information for this node.
//              
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispContainer::DumpContentInfo(HANDLE hFile, long level, long childNumber) const
{
#if 0
    IDispClientDebug* pIDebug;
    if (SUCCEEDED(
        GetDispClient()->QueryInterface(IID_IDispClientDebug,(void**)&pIDebug)))
    {
        pIDebug->DumpDebugInfo(hFile, level, childNumber, this, 0);
        pIDebug->Release();
    }
#else
    GetDispClient()->DumpDebugInfo(hFile, level, childNumber, this, 0);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DumpBounds
//
//  Synopsis:   Dump custom information for this node.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//----------------------------------------------------------------------------

void
CDispContainer::DumpBounds(HANDLE hFile, long level, long childNumber) const
{
    super::DumpBounds(hFile, level, childNumber);

    WriteString(hFile, _T("<rcContainer>"));
    DumpRect(hFile, _rcpContainer);
    WriteString(hFile, _T("</rcContainer>\r\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\dispcontext.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispcontext.cxx
//
//  Contents:   Context object passed throughout display tree.
//
//  Classes:    CDispContext, CDispDrawContext, CDispHitContext
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

MtDefine(CDispContext, DisplayTree, "CDispContext")
MtDefine(CDispHitContext, DisplayTree, "CDispHitContext")
MtDefine(CDispDrawContext, DisplayTree, "CDispDrawContext")
MtDefine(CDispRecalcContext, DisplayTree, "CDispRecalcContext")
MtDefine(CDispContext_LayoutContextStack_pv, DisplayTree, "Layout context stack")


//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//
const int FAT_HIT_TEST = 4;


//+---------------------------------------------------------------------------
//
//  Member:     CLayoutContextStack::GetLayoutContext()
//              
//  Synopsis:   Returnes the last pushed layout context leaving it on the stack
//  Notes:      In case the stack is empty it returns GUL_USEFIRSTLAYOUT
//              
//----------------------------------------------------------------------------
CLayoutContext *
CLayoutContextStack::GetLayoutContext()
{
    if(_aryContext.Size() > 0)
        return _aryContext.Item(_aryContext.Size() - 1);
    else
        return GUL_USEFIRSTLAYOUT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayoutContextStack::PushLayoutContext
//              
//  Synopsis:   Pushed given layout context into the layout context stack
//  Notes:
//              
//----------------------------------------------------------------------------
void
CLayoutContextStack::PushLayoutContext(CLayoutContext *pCnt)
{
    Assert(pCnt != GUL_USEFIRSTLAYOUT);
    Assert(pCnt != 0);
    _aryContext.Append(pCnt);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayoutContextStack::PushLayoutContext
//              
//  Synopsis:   Pops the last pushed layout context from the layout context stach
//  Notes:      It does not return the Poped context
//              
//----------------------------------------------------------------------------
void
CLayoutContextStack::PopLayoutContext()
{
    Assert(_aryContext.Size() > 0);
    _aryContext.Delete(_aryContext.Size() - 1);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDispRecalcContext::AddToRedrawRegionGlobal
//              
//  Synopsis:   Add the given rect (in global coords) to the current redraw
//              region.
//              
//  Arguments:  rcg     rect to add to redraw region (in global coords)
//              
//  Notes:      Do not make this an in-line method, because dispcontext.hxx
//              cannot be dependent on disproot.hxx (circular dependency).
//              
//----------------------------------------------------------------------------

void
CDispRecalcContext::AddToRedrawRegionGlobal(const CRect& rcg)
{
    Assert(_pRootNode != NULL);
    _pRootNode->InvalidateRoot(rcg, FALSE, FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::PushRedrawRegion
//              
//  Synopsis:   Save the current redraw region, then subtract the given region
//              from the redraw region, and make it the new redraw region.
//              
//  Arguments:  rgng        region to subtract from the current redraw region
//              key         key used to decide when to pop the next region
//              
//  Returns:    TRUE if redraw region was successfully pushed, FALSE if the
//              redraw region became empty after subtraction or the stack is
//              full.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispDrawContext::PushRedrawRegion(const CRegion& rgng, void* key)
{
    Assert(!_pRedrawRegionStack->IsFull());
    
    // save the old redraw region
    CRect rcgBounds;
    CRegion* prgngTemp = new CRegion(*_prgngRedraw);
    if (prgngTemp == NULL)
        return FALSE;
     
    rgng.GetBounds(&rcgBounds);
    _pRedrawRegionStack->PushRegion(_prgngRedraw, key, rcgBounds);

    // New region.
    _prgngRedraw = prgngTemp;

    // subtract given region from current redraw region
    _prgngRedraw->Subtract(rgng);

    // if new redraw region is empty, start drawing
    if (_prgngRedraw->IsEmpty())
        return FALSE;    

    // if the stack became full, we will have to render from the root node
    if (_pRedrawRegionStack->IsFull())
    {
        _pFirstDrawNode = (CDispNode*) _pRootNode;
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::PopTransform
//              
//  Synopsis:   Pop transform off the transform stack.
//              
//  Arguments:  pDispNode       current node for which we should be getting
//                              the transform
//              
//  Returns:    TRUE if the proper transform was found
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispDrawContext::PopTransform(CDispNode* pDispNode)
{
    Assert(_pTransformStack != NULL);
    return _pTransformStack->PopTransform(&GetClipTransform(), pDispNode);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::FillTransformStack
//              
//  Synopsis:   Fill the transform stack with transforms for display node
//              ancestors.
//              
//  Arguments:  pDispNode       current display node
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispDrawContext::FillTransformStack(CDispNode* pDispNode)
{
    Assert(_pTransformStack != NULL);
    _pTransformStack->Init();
    Assert(pDispNode->HasParent());
    pDispNode->GetRawParentNode()->
        PushTransform(pDispNode, _pTransformStack, &GetClipTransform());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::SaveTransform
//              
//  Synopsis:   Save the given transform on the transform stack.
//              
//  Arguments:  pDispNode       node the context is associated with
//              transform       transform to save
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispDrawContext::SaveTransform(
        const CDispNode *pDispNode,
        const CDispClipTransform& transform)
{
    // can't inline, because CDispDrawContext doesn't know what a transform
    // stack is (circular dependency)
    _pTransformStack->SaveTransform(transform, pDispNode);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::GetRawDC
//              
//  Synopsis:   Get a raw DC (no adjustments to offset or clipping).
//              
//  Arguments:  none
//              
//  Returns:    DC
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

HDC
CDispDrawContext::GetRawDC()
{
    return _pDispSurface->GetRawDC();
}


void
CDispDrawContext::SetSurfaceRegion()
{
    _pDispSurface->SetClipRgn(_prgngRedraw);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::PrepareDispSurface
//              
//  Synopsis:   Return the display surface, properly prepared for client
//              rendering.
//              
//  Arguments:  none
//              
//  Returns:    pointer to the display surface
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CDispSurface*
CDispDrawContext::PrepareDispSurface()
{
    _pDispSurface->PrepareClientSurface(&GetClipTransform());
    return _pDispSurface;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispHitContext::RectIsHit
//              
//  Synopsis:   Determine whether the given rect, in local coordinates,
//              intersects the hit point.
//              
//  Arguments:  rc      rect in local coordinates
//              
//  Returns:    TRUE if the rect intersects the hit point
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispHitContext::RectIsHit(const CRect& rc) const
{
    // transform the rect into global coordinates and perform the hit test
    CRect rcg;
    GetClipTransform().Transform(rc, &rcg);
    if (!rcg.Contains(_ptgHitTest))
        return FALSE;
    
    // now we know that the hit test succeeded in global coordinates.  However,
    // this is not a sufficient test, because the rectangle is too large in
    // global coordinates if there were any rotations that weren't multiples
    // of 90 degrees.  To catch this case, we transform the global hit point
    // back into local coordinates, and redo the test there.
    // 
    // TODO (donmarsh) -- this is still not sufficient if there are multiple
    // nested non-90 degree rotations that perform clipping.  In that case, we
    // have to use a more complex clipping region to answer the question
    // correctly, but this is a larger task than can be accomplished now.
    CPoint ptHitTest;
    GetHitTestPoint(&ptHitTest);
    return rc.Contains(ptHitTest);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispHitContext::FuzzyRectIsHit
//              
//  Synopsis:   Perform fuzzy hit testing.
//              
//  Arguments:  rc          rect to hit
//              
//  Returns:    TRUE if rect is hit
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL            
CDispHitContext::FuzzyRectIsHit(const CRect& rc, BOOL fFatHitTest )
{
    // simple intersection test first
    CRect rcg;
    GetClipTransform().Transform(rc, &rcg);
    if (rcg.Contains(_ptgHitTest))
    {
        // now we know that the hit test succeeded in global coordinates.  However,
        // this is not a sufficient test, because the rectangle is too large in
        // global coordinates if there were any rotations that weren't multiples
        // of 90 degrees.  To catch this case, we transform the global hit point
        // back into local coordinates, and redo the test there.
        // 
        // TODO (donmarsh) -- this is still not sufficient if there are multiple
        // nested non-90 degree rotations that perform clipping.  In that case, we
        // have to use a more complex clipping region to answer the question
        // correctly, but this is a larger task than can be accomplished now.
        CPoint ptHitTest;
        GetHitTestPoint(&ptHitTest);
        return rc.Contains(ptHitTest);
    }
    
    // no intersection if the simple intersection test failed and we're not
    // doing fuzzy hit test
    if (_cFuzzyHitTest == 0)
    {
        Assert( ! fFatHitTest ); // don't expect to do a fat hit test if not doing a fuzzy.
        return FALSE;
    }
    
    // fail if the transformed rect is empty
    CSize size;
    rcg.GetSize(&size);
    if (size.cx <= 0 || size.cy <= 0)
        return FALSE;
    
    // bump out sides by fuzzy factor if the rect is small in either dimension
    CRect rcgFuzzy(rcg);
    size.cx -= _cFuzzyHitTest;
    size.cy -= _cFuzzyHitTest;
    if (size.cx < 0)
    {
        rcgFuzzy.left += size.cx;
        rcgFuzzy.right -= size.cx; 
    }
    if (size.cy < 0)
    {
        rcgFuzzy.top += size.cy;
        rcgFuzzy.bottom -= size.cy; 
    }

    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //

    if (rcgFuzzy.Contains(_ptgHitTest))
        return TRUE;
    else 
        return fFatHitTest && FatRectIsHit( rcg );
}




//+====================================================================================
//
// Method: FatRectIsHit
//
// Synopsis: Check to see if the "fat rect is hit"
//
//------------------------------------------------------------------------------------

//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//

BOOL            
CDispHitContext::FatRectIsHit(const CRect& rcg)
{
    CRect rcgFat(rcg);
    rcgFat.InflateRect(FAT_HIT_TEST, FAT_HIT_TEST);
    return rcgFat.Contains(_ptgHitTest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\dibrot.cxx ===
/****************************************************************************\
|   File:  DibRot . CXX                                                      |
|                                                                            |
|                                                                            |
|   Rotation of bitmaps                                                      |
|                                                                            |
|    Copyright 1990-1995 Microsoft Corporation.  All rights reserved.        |
|    Microsoft Confidential                                                  |
|                                                                            |
\****************************************************************************/

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef NOTYET // FUTURE (alexmog, 6/20/2000): This rotation code is not used in 
              // IE5.5. It will probably never be used. Delete when
              // design for rotation in Blackcomb is settled.
              // The code is ported from Quill.

#ifndef X_MATH_H_
#define X_MATH_H_
#include <math.h>
#endif

#ifndef X_XGDI2_HXX_
#define X_XGDI2_HXX_
#include "xgdi2.hxx"
#endif

#ifndef X_PUBROT_HXX_
#define X_PUBROT_HXX_
#include "pubrot.hxx"
#endif

#ifndef X_PUBPRINT_HXX_
#define X_PUBPRINT_HXX_
#include "pubprint.hxx"
#endif

#ifndef X_DBGMETAF_HXX_
#define X_DBGMETAF_HXX_
#include "grafrot.hxx"
#endif

#ifndef X_DIBROT_HXX_
#define X_DIBROT_HXX_
#include "dibrot.hxx"
#endif

// LIBC FUNCTIONS USED FROM TRAN.LIB: cos sin

#ifndef DEBUG
#define DBGSetupFenceValues(a,b,c,d)
#define  DBGCheckSrcPointer(a)
#define  DBGCheckDstPointer(a)
#endif
// ***************************************************************************
//*********************  NEXT TWO FUNCTIONS ARE DEBUG  ONLY ******************
// ***************************************************************************
#ifdef DEBUG
BYTE  *vpSrcMinDBG, *vpSrcMaxDBG, *vpDstMinDBG, *vpDstMaxDBG;

void DBGSetupFenceValues(BYTE *lpSrc, int cbSrc, BYTE *lpDst, int cbDst)
{
    vpSrcMinDBG = lpSrc;
    vpSrcMaxDBG = lpSrc + cbSrc;
    vpDstMinDBG = lpDst;
    vpDstMaxDBG = lpDst + cbDst;
}

_inline void DBGCheckSrcPointer(BYTE *lpSrc)
{
    AssertEx((lpSrc >= vpSrcMinDBG) && (lpSrc < vpSrcMaxDBG));
}
_inline void DBGCheckDstPointer(BYTE *lpDst)
{
    AssertEx((lpDst >= vpDstMinDBG) && (lpDst < vpDstMaxDBG));
}
#endif // DEBUG

// ***************************************************************************
// %%Function: SkewHorz                 %%Owner: harip    %%Reviewed: 12/15/94
// Description: Skew scan line pointed to by psrc to pdst starting at ipixStart.
//              cbSrc : width of src scanline
//              cbDst : width of dst scan line.
// ***************************************************************************
void SkewHorz(BYTE *psrc, int cbSrc, int cbDst, int ipixStart, BYTE *pdst, int cbPixel, BOOL fFlip)
{
    int i, lim;

    if (ipixStart < 0)
        psrc -= ipixStart;
    i = max(0, ipixStart);
    lim = min(cbSrc + ipixStart, cbDst);

	DBGCheckSrcPointer(psrc);
	DBGCheckDstPointer(pdst + i);
	DBGCheckDstPointer(pdst + lim - 1);

	int cb = (lim - i) / cbPixel; // For 24-bit pixel images, each cb represents 3 bytes.
	pdst += i;
	AssertEx(pdst <= psrc || psrc + i <= pdst);
	AssertEx(cbPixel == 1 || cbPixel == 3);
	int cbIncrSrc, cbIncrDst;
	if (fFlip)
		{
		pdst += ((cb - 1) * cbPixel);
		cbIncrDst = -cbPixel;
		}
	else
		{
		cbIncrDst = cbPixel;
		}
	cbIncrSrc = cbPixel;
		
	while (cb--)
		{
		*pdst = *psrc;
		if (cbPixel > 1)
			{
            *(pdst + 1) = *(psrc + 1);
            *(pdst + 2) = *(psrc + 2);
			}
		pdst += cbIncrDst;
		psrc += cbIncrSrc;
		}

}   /* SkewHorz */

// ***************************************************************************
// %%Function: SkewVert                 %%Owner: harip    %%Reviewed: 12/15/94
// Description:
// Description: Skew vertical line of pixels pointed to by psrc to pdst starting
//              at ipixStart. Distance between pixels is cpixOffset.
//              cpixSrc : height of src scanline
//              cpixDst : height of dst scan line.
//  cbPixel : number of bytes per pixel
// ***************************************************************************
void SkewVert(BYTE *psrc, int cpixSrc, int cpixDst, int ipixStart, int cpixOffset,
                    BYTE *pdst, int cbPixel)
{
    int i, lim;

    if (ipixStart < 0)
        {
        psrc -= (ipixStart * cpixOffset);
        i = 0;
        }
    else
        {
        pdst += (ipixStart * cpixOffset);
        i = ipixStart;
        }
    lim = min(cpixSrc + ipixStart, cpixDst);

    for (; i < lim; i++)
        {
        *pdst = *psrc;

		DBGCheckSrcPointer(psrc);
		DBGCheckDstPointer(pdst);

        if (cbPixel > 1)    // shd most probably unravel into 2 functions. Review.
            {
            //AssertEx(cbPixel == 3);
            *(pdst + 1) = *(psrc + 1);
            *(pdst + 2) = *(psrc + 2);
            }
        psrc += cpixOffset;
        pdst += cpixOffset;
        }
}   /* SkewVert */

// ***************************************************************************
// %%Function: HDIBConvert1To8          %%Owner: harip    %%Reviewed: 12/15/94
//
// Parameters: lpbmi : refers to the src (1 bit) bitmap.
//             pDIBOrig : pointer to original DIB's bits
// Returns:     handle to 8 bit dib
//
// Description: Converts a 1-bit dib to an 8bit dib
//  Aborts! caller (catcher) beware!
// ***************************************************************************
HQ HQDIBConvert1To8(LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig)
{
    BYTE *lpPixels;
    BYTE *lpOutPixels;
    BYTE *lpT;
    BYTE *lpOutT;
    WORD cbits;
    int x, y, cbInc, cbIncOut, cpixHeight, cpixWidth;
    HQ hqOutDIB;
    BYTE cMask;
    LPBITMAPINFOHEADER lpbmiOut;
    LPBITMAPINFO lpbi;
    int cbAlloc;

    cbits = lpbmi->biBitCount;

    AssertEx(cbits == 1);
    cpixHeight = lpbmi->biHeight;
    cpixWidth = lpbmi->biWidth;

    cbInc = WIDTHBYTES(cpixWidth); // Scan lines must be word-aligned
    cbIncOut = WIDTHBYTES(cpixWidth << 3);

	cbAlloc = sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD) + ((DWORD) cpixHeight) * cbIncOut;
    hqOutDIB = HqAlloc(cbAlloc);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpbmiOut = (LPBITMAPINFOHEADER)LpLockHq(hqOutDIB);
    ZeroMemory(lpbmiOut, cbAlloc);
    *lpbmiOut = *lpbmi;
    lpbmiOut->biBitCount  = 8;
    lpbmiOut->biSizeImage = 0;
    lpbmiOut->biClrUsed = lpbmiOut->biClrImportant = 0;

    // now build the palette
    lpbi = (LPBITMAPINFO)(LPBYTE)lpbmiOut;
    // fill in colors 0,1 with colors from 1-bit DIB
    for (x = 0; x < (1 << cbits); x++)
        lpbi->bmiColors[x] = ((LPBITMAPINFO) lpbmi)->bmiColors[x];

    lpPixels = pDIBOrig;
    lpOutPixels = (BYTE *)((LPBYTE)lpbi + CbDibHeader(lpbmiOut));

    // Do actual transfer
    for (y = 0; y < cpixHeight; y++)
        {
        lpT = lpPixels + ((DWORD)cbInc) * y;
        lpOutT = lpOutPixels + ((DWORD)cbIncOut) * y;
        for (x = 0, cMask = (BYTE)128; x < cpixWidth; x++)
            {
            if (*lpT & cMask)   // no need to set to 0 since we do ZEROINIT
                *lpOutT = 1;
            lpOutT++;
            if (!(cMask >>= 1))
                {    // start next byte of 1-bit DIB
                lpT++;
                cMask = (BYTE)128;
                }
            }
        }
    UnlockHq(hqOutDIB);
LErrOOM:
    return hqOutDIB;
}   /* HDIBConvert1To8 */

// ***************************************************************************
// %%Function: HDIBConvert4To8          %%Owner: harip    %%Reviewed: 12/15/94
//
// Parameters: lpbmi : refers to the src (4 bit) bitmap.
//             pDIBOrig : pointer to original DIB's bits
// Returns:     handle to 8 bit dib
//
// Description: Converts a 4-bit dib to an 8bit dib
//  ABorts! caller (catcher) beware!
// ***************************************************************************
HQ HQDIBConvert4To8(LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig)
{
    BYTE *lpPixels;
    BYTE *lpOutPixels;
    BYTE *lpT;
    BYTE *lpOutT;
    LPBITMAPINFOHEADER lpbmiOut;
    LPBITMAPINFO   lpbi;
    WORD cbits;
    int x, y, cbInc, cbIncOut, cpixHeight, cpixWidth;
    HQ hqOutDIB;
    int cbAlloc;

    AssertEx(lpbmi->biBitCount == 4);
    cpixHeight = lpbmi->biHeight;
    cpixWidth = lpbmi->biWidth;
    cbits = lpbmi->biBitCount;
    cbInc = WIDTHBYTES(cpixWidth << 2); // Scan lines must be word-aligned
    cbIncOut = WIDTHBYTES(cpixWidth << 3);

	cbAlloc = sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD) + ((DWORD) cpixHeight) * cbIncOut;
    hqOutDIB = HqAlloc(cbAlloc);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpbmiOut = (LPBITMAPINFOHEADER)LpLockHq(hqOutDIB);
    ZeroMemory(lpbmiOut, cbAlloc);
    *lpbmiOut = *lpbmi;
    lpbmiOut->biBitCount  = 8;
    lpbmiOut->biSizeImage = 0;
    lpbmiOut->biClrUsed = lpbmiOut->biClrImportant = 0;
    // now build the palette
    lpbi = (LPBITMAPINFO)(LPBYTE)lpbmiOut;
    // fill colors 0-15 of the palette with colors of 4-bit DIB
    for (x = 0; x < (1 << cbits); x++)
        lpbi->bmiColors[x] = ((LPBITMAPINFO) lpbmi)->bmiColors[x];

    lpPixels = pDIBOrig;
    lpOutPixels = (BYTE *)((LPBYTE)lpbi + CbDibHeader(lpbmiOut));

    // perform actual transfer
    for (y = 0; y < cpixHeight; y++)
        {
        lpT = lpPixels + ((DWORD)cbInc) * y;
        lpOutT = lpOutPixels + ((DWORD)cbIncOut) * y;
        for (x = 0; x < cpixWidth; x += 2)
            {
            // If cpixWidth is odd, this writes one too many pixels, but since
            // lines are extended to be word aligned, this is OK
            *(lpOutT++) = ((*lpT & 0xf0)>>4);
            *(lpOutT++) = (*(lpT++) & 0x0f);
            }
        }
    UnlockHq(hqOutDIB);
LErrOOM:
    return hqOutDIB;

}   /* HDIBConv4To8 */

// ***************************************************************************
// %%Function: HDIBRot90Incs            %%Owner: harip    %%Reviewed: 12/15/94
//
// Description:  Returns handle to the bits of a dib roated by 90, 180 or 270 degs
// Parameters:  lpbmi : refers to incoming bits (some fields are changed. SEE NOTE)
//              pDIBOrig : points to bits of the incoming DIB.
//              wRot :  1 = 90 degs
//                      2 = 180 degs
//                      3 = 270 degs
//              cbPixel : number of bytes per pixel
// NOTE: alters biWidth & biHeight fields in lpbmi to reflect new dimensions
//       and also sets biSizeImage to 0.
//  Aborts on OOM. caller better catch.
//
// Since this routine is expected to return a handle to the bits of a dib, so
// we don't have the opportunity to optimize the case where the image is rotated
// 180 degrees and flipped both horizontally and vertically resulting in the original
// untransformed image.  That optimization should be made higher up.
// ***************************************************************************
HQ HQDIBRot90Incs(LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig, WORD wRot,
                            int cbPixel,    BYTE bFill, int qflip)
{
    int dxNew, dyNew, cbInc, cbIncOut, cbIncLoop, x, y;
    HQ hqDIBOut = hqNil;
    BYTE *lpPixels, *lpOutPixels;

    AssertEx(wRot==1 || wRot==2 || wRot==3);

    if (wRot == 2)  //180
        {
        dyNew = lpbmi->biHeight;
        dxNew = lpbmi->biWidth;
        }
    else        // 90, 270
        {
        dxNew = lpbmi->biHeight;
        dyNew = lpbmi->biWidth;
        }
    cbInc = WIDTHBYTES(lpbmi->biWidth*lpbmi->biBitCount);
    cbIncOut = WIDTHBYTES(dxNew*lpbmi->biBitCount);

    hqDIBOut = HqAlloc(dyNew * cbIncOut); // allocate for new dib bits
    if (hqDIBOut == hqNil)
    	goto LErrOOM;
    lpOutPixels = (BYTE*)LpLockHq(hqDIBOut);
    // setup debug fence values
    DBGSetupFenceValues(pDIBOrig, cbInc * lpbmi->biHeight, lpOutPixels, dyNew * cbIncOut);

    FillLpb(bFill, lpOutPixels, dyNew*cbIncOut); // white out
    lpPixels = pDIBOrig;
    if (wRot==3)        // 270
        {
        lpOutPixels += ((DWORD)cbIncOut) * (dyNew - 1);
        cbIncLoop = -cbIncOut;
        }
    else if (wRot == 2)    // 180
        {
        lpOutPixels += cbPixel * (dxNew - 1);
        cbIncLoop = -cbPixel;
        }
    else                // 90
        cbIncLoop = cbIncOut;
    for (y = 0; y < lpbmi->biHeight; y++)
        {
        BYTE *lpOutT, *lpT;

        if (wRot == 3)        // 270
            lpOutT = lpOutPixels + cbPixel * y;
        else if (wRot == 2)    // 180
            lpOutT = lpOutPixels + ((DWORD)cbIncOut) * (dyNew - y - 1);
        else                 // 90
            lpOutT = lpOutPixels + cbPixel * (dxNew - y - 1);
        lpT = lpPixels + ((DWORD)cbInc) * y;
        for (x = 0; x < lpbmi->biWidth; x++)
            {
            *lpOutT = *lpT;
			DBGCheckSrcPointer(lpT);
			DBGCheckDstPointer(lpOutT);
            if (cbPixel == 3)
                {
                *(lpOutT+1) = *(lpT+1);
                *(lpOutT+2) = *(lpT+2);
                }
            lpT += cbPixel;
            lpOutT += cbIncLoop;
            }
        }
    UnlockHq(hqDIBOut);
    lpbmi->biHeight = dyNew;
    lpbmi->biWidth = dxNew;
    lpbmi->biSizeImage = 0;
LErrOOM:
    return hqDIBOut;
}   /* HDIBRot90Incs */

// ***************************************************************************
// %%Function: HDIBBitsRot              %%Owner: harip    %%Reviewed: 12/15/94
//
// Parameters: lpbmi : refers to the incoming DIB.
//             pDIBOrig : points to bits of the Orig DIB.
//              ang :  angle of rotation
// Returns: Handle to memory containing bits to the rotated dib and changes
//              biHeight and biWidth in lpbmi to be that for the new size.
//              Also sets biSizeImage to 0.
//
// Description : Main dib rotating function.
// ALGORITHM: this implements the Paeth/ Tanaka, et. al,1986, 3 pass shear
//              algorithm. Good desription is there in 'Digital Image Warping'
//                                                  by George Wolberg.
// ***************************************************************************
HQ HQDIBBitsRot(MRS *pmrs, LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig, ANG ang)
{
    RAD radCos, radSin, radAng, radTanHalfAng;
    int dyNew, dxNew, dxmax;
    int cbInc, cbIncTemp, cbIncOut;
    int cbitsPix, cbPixel;
    HQ hqOutDIB = hqNil;
    HQ hqTempDIB = hqNil;
    HQ hqDIBT = hqNil;
    HQ hqDIB8 = hqNil;
    BOOL fNotOOM = fTrue;
    BYTE *lpTempPixels, *lpOutPixels, *lpPixels, *psrc, *pdst;
    int x, y;
    // variables for Bresenham's line algorithm
    int dx, dy, incrE, incrNE, d, x0, x1, y0, y1, Offst;
    int dxOrig, dyOrig;
    int i;
    LPBITMAPINFO lpbi;
    LPBITMAPINFOHEADER lpbmiSav = lpbmi;
    COLORREF crBackground; // color to fill in as background
    BYTE bFill;
    BOOL fFlippedBits = (lpbmi->biHeight < 0);
	int qflip = pmrs->qflip;

    if (fFlippedBits)
        lpbmi->biHeight *= -1;
    // if bit depth is less than eight convert to an 8bpp image so that we can rotate.
    if (lpbmi->biBitCount < 8)
        {
        hqDIB8 = (lpbmi->biBitCount == 4) ? HQDIBConvert4To8(lpbmi, pDIBOrig) :
											HQDIBConvert1To8(lpbmi, pDIBOrig);
		if (hqDIB8 == hqNil)
			goto LErrOOM;

        lpbmi = (LPBITMAPINFOHEADER)LpLockHq(hqDIB8);
        pDIBOrig = (LPBYTE)((LPBYTE)lpbmi + CbDibHeader(lpbmi));

#ifdef DEBUG_BITS_ROT
    	StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
                            0,0, lpbmi->biWidth, lpbmi->biHeight, pDIBOrig,
                            (LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
#endif // DEBUG_BITS_ROT
		}

    cbitsPix = lpbmi->biBitCount; // number of bits per pixel
    AssertEx(cbitsPix == 8 || cbitsPix == 24);
    cbPixel = cbitsPix / 8;         // number of bytes per pixel

    // color to set as background
	crBackground=RGB(255,255,255);

    // find fill value (index into palette) to fill in for background
    lpbi = (LPBITMAPINFO)(LPBYTE)lpbmi;
    if (cbitsPix == 8)
        {
        for (i = 0;  i < 256;  i++)
            {
            if (lpbi->bmiColors[i].rgbRed   == GetRValue(crBackground) &&
                lpbi->bmiColors[i].rgbGreen == GetGValue(crBackground) &&
                lpbi->bmiColors[i].rgbBlue  == GetBValue(crBackground))
                break;
            }
        if (i == 256)   // no black in the colors in the DIB
            bFill = 0;  // so set it deliberately to 0
        else
            bFill = i;
        }
    else
        bFill = 255;

    // make sure degrees within bounds
    ang = AngNormalize(ang);
    if (ang >= ang90)
        {
        hqDIBT = HQDIBRot90Incs(lpbmi, pDIBOrig, (WORD)(ang / ang90), cbPixel, bFill, qflip);
        if (hqDIBT == hqNil)
        	goto LErrOOM;

		if ((qflip & qflipVert || qflip & qflipHorz) &&
			!(qflip & qflipVert && qflip & qflipHorz) &&
			(ang / ang90) % 2)
			{
			qflip = (qflip & qflipVert) ? qflipHorz : qflipVert;
			}

        ang = ang % ang90;
        if (ang == 0 && qflip == 0)
            {
            // got to do this since mem pointed to by lpbmi is going away AND
            // the caller (FStretchMetaFoo()) needs the new values passed back
            *lpbmiSav = *lpbmi;
            lpbmi = lpbmiSav;
            if (hqDIB8)
                {
                UnlockHq(hqDIB8);
                FreeHq(hqDIB8);
                }
            return hqDIBT;
            }

        // lpbmi now contains sizes for new DIB (in hqDIBT )
        pDIBOrig = (BYTE*)LpLockHq(hqDIBT);
        } // ang >= ang90

    // convert ang to radians
    radAng = ang * PI / ang180;

    radCos = cos(radAng);
    radSin = sin(radAng);
    radAng /= 2; // ang/2 for tan

    radTanHalfAng = sin(radAng) / cos(radAng);

    dxOrig = lpbmi->biWidth;
    dyOrig = lpbmi->biHeight;

    // new size of bitmap and intermediate width. the +1's to take care of roundoff
    dyNew = radSin * dxOrig + radCos * dyOrig + 1;
    dxNew = radSin * dyOrig + radCos * dxOrig + 1;
    dxmax = dxOrig + dyOrig * radTanHalfAng + 1;

    cbInc = WIDTHBYTES(dxOrig * cbitsPix);
    cbIncTemp = WIDTHBYTES(dxmax * cbitsPix);
    cbIncOut = WIDTHBYTES(dxNew * cbitsPix);

    hqOutDIB = HqAlloc(dyOrig * cbIncTemp);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpOutPixels = (BYTE *)LpLockHq(hqOutDIB);
    FillLpb(bFill, lpOutPixels, dyOrig * cbIncTemp); // initialise in background color
    lpPixels = pDIBOrig;
    // setup debug fence values
    DBGSetupFenceValues(pDIBOrig, dyOrig * cbInc, lpOutPixels, dyOrig * cbIncTemp);

    if ((fFlippedBits || qflip & qflipVert) && 
    	!(fFlippedBits && qflip & qflipVert))
        {
        psrc = lpPixels - cbInc; // because we increment right in the beginning
        cbInc = -cbInc;
        }
    else
    	{
        psrc = lpPixels + cbInc * dyOrig; // go to the end, since we will be inverting
        }
        
    pdst = lpOutPixels;
    // **************** skew #1 ************************
    y0 = 0;
    x0 = 0;
    y1 = dyOrig;
    x1 = radTanHalfAng * y1 + 0.5;
    dx = x1 - x0;
    dy = y1 - y0;
    incrE = dx << 1;
    d = incrE - dy;
    incrNE = (dx - dy) << 1;
    x = x0;
    y = y0;
    // All this *3 stuff is there since  SkewHorz() expects cb's and
    // so here we multiply by the number of bytes per pixel.
    if (cbitsPix == 24)
        {
        x = cbPixel * x0;
        dxOrig *=cbPixel;
        dxmax *= cbPixel;
        }
    do
        {
        psrc -= cbInc;
        SkewHorz(psrc, dxOrig, dxmax,  x, pdst, cbPixel, qflip & qflipHorz);

#ifdef DEBUG_BITS_ROT
		BLOCK
			{
		    lpbmi->biWidth = dxmax;
		    lpbmi->biHeight = dyOrig;
    		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
				0,0, lpbmi->biWidth, lpbmi->biHeight, lpOutPixels,
				(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
			}
#endif // DEBUG_BITS_ROT

        pdst += cbIncTemp;
        y++;
        if (d <= 0)
            d += incrE;
        else
            {
            d += incrNE;
            x += cbPixel;
            }
        }
    while (y < y1);

    if (cbitsPix == 24)
        {
        dxOrig /= cbPixel;
        dxmax /= cbPixel;
        }
    if (hqDIBT)
        {
        UnlockHq(hqDIBT);    // possibly assert that ang > 890
        FreeHq(hqDIBT);
        hqDIBT = hqNil;
        }

    hqTempDIB = HqAlloc(dyNew * cbIncTemp);
    if (hqTempDIB == hqNil)
    	goto LErrOOM;
    lpTempPixels = (BYTE*)LpLockHq(hqTempDIB);
    FillLpb(bFill, lpTempPixels, dyNew * cbIncTemp); // initialise in background color
    psrc = lpOutPixels;
    pdst = lpTempPixels;
    // setup debug fence values
    DBGSetupFenceValues(psrc, dyOrig * cbIncTemp, pdst, dyNew * cbIncTemp);
    // **************** skew #2 ************************
    x0 = 0;
    y0 = radSin * (dxOrig - 1) + 0.5;
    x1 = dxmax;
    y1 = radSin * (dxOrig - dxmax - 1) + 0.5;
    dx = x1 - x0;
    dy = y0 - y1;
    incrE = dy << 1;
    d = incrE - dx;
    incrNE = (dy - dx) << 1;
    x = x0;
    y = y0;

    do
        {
        SkewVert(psrc, dyOrig, dyNew,  y, cbIncTemp, pdst, cbPixel);

#ifdef DEBUG_BITS_ROT
		BLOCK
			{
		    lpbmi->biWidth = dxmax;
		    lpbmi->biHeight = dyNew;
    		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
				0,0, lpbmi->biWidth, lpbmi->biHeight, lpTempPixels,
				(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
			}
#endif // DEBUG_BITS_ROT

        psrc += cbPixel;
        pdst += cbPixel;

        x++;
        if (d <= 0)
            d += incrE;
        else
            {
            d += incrNE;
            y--;
            }
        }
    	while (x < dxmax);

    UnlockHq(hqOutDIB);
    FreeHq(hqOutDIB);
    hqOutDIB = hqNil;

    hqOutDIB = HqAlloc(dyNew * cbIncOut);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpOutPixels = (BYTE *)LpLockHq(hqOutDIB);
    FillLpb(bFill, lpOutPixels, dyNew * cbIncOut); // initialise in background color
    // setup debug fence values
    DBGSetupFenceValues(lpTempPixels, dyNew * cbIncTemp, lpOutPixels , dyNew * cbIncOut);
    psrc = lpTempPixels;
    pdst = lpOutPixels + (cbIncOut * dyNew);
    // **************** skew #3 ************************
    {
    Offst = (dxOrig - 1) * radSin;

    y0 = 0;
    x0 = (y0 - Offst) * radTanHalfAng + 0.5;
    y1 = dyNew;
    x1 = (y1 - Offst) * radTanHalfAng + 0.5;
    dx = x1 - x0;
    dy = y1 - y0;
    incrE = dx << 1;
    d = incrE - dy;
    incrNE = (dx - dy) << 1;
    x = x0;
    y = y0;
    // All this *3 stuff is just so we can reuse the SkewHorz code.

    if (cbitsPix == 24)
        {
        x = cbPixel * x0;
        dxNew *= cbPixel;
        dxmax *= cbPixel;
        }
    do
        {
        pdst -= cbIncOut;
        SkewHorz(psrc, dxmax, dxNew, x, pdst, cbPixel, qflipNil);

#ifdef DEBUG_BITS_ROT
		BLOCK
			{
		    lpbmi->biWidth = dxNew;
		    lpbmi->biHeight = dyNew;
    		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
				0,0, lpbmi->biWidth, lpbmi->biHeight, lpOutPixels,
				(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
			}
#endif // DEBUG_BITS_ROT

        psrc += cbIncTemp;
        y++;
        if (d <= 0)
            d += incrE;
        else
            {
            d += incrNE;
            x += cbPixel;
            }
        }
    while (y < y1);
    if (cbitsPix == 24)
        dxNew /= cbPixel;
    }

LErrOOM:
    // following 2 lines because lpbmi points to hqDIB8 for < 8bpp bmps
    // and that is going to be freed.
    *lpbmiSav = *lpbmi;
    lpbmi = lpbmiSav;
    if (hqDIB8)
        {
        UnlockHq(hqDIB8);
        FreeHq(hqDIB8);
        }
    if (hqDIBT)
        {
        AssertEx(pmrs->ang > ang90);
        UnlockHq(hqDIBT);
        FreeHq(hqDIBT);
        }
    if (hqTempDIB)
        {
        UnlockHq(hqTempDIB);
        FreeHq(hqTempDIB);
        }
    // REVIEW (davidhoe):  If fail to alloc hqTempDIB then the first hqOutDIB
    // will be returned.  Is this desirable?  Could have else case for cleaning
    // up hqTempDIB immediately above that would free hqTempDIB and set it to hqNil.
    if (hqOutDIB)
        UnlockHq(hqOutDIB);
    lpbmi->biWidth = dxNew;
    lpbmi->biHeight = dyNew;
    lpbmi->biSizeImage = 0;
    return hqOutDIB;
}   /* HDIBBitsRot */

// ***************************************************************************
// %%Function: FreeDIBSection           %%Owner: harip    %%Reviewed: 00/00/00
//
// Description: Frees up resources allocated for the DIBSection in pdsi.
//
// ***************************************************************************
void FreeDIBSection(PDSI pdsi)
{
	if (pdsi->hdc)
		{
		HBITMAP hbm = NULL;
		if (pdsi->hbmOld)
			{
			if ((hbm = (HBITMAP)SelectObject(pdsi->hdc, pdsi->hbmOld)) != NULL)
				{
				DeleteObject(hbm);
				}
#ifdef DEBUG
			else
				{
				CommSz(_T("Could not free up created DIBSection"));
				CommCrLf();
				}
#endif
			}
		DeleteDC(pdsi->hdc);
		}
}   /* FreeDIBSection */

// ***************************************************************************
// %%Function: FDIBBitsScaledFromHDIB   %%Owner: harip    %%Reviewed: 00/00/00
//
// Parameters: lpbmih lpBits :info about and the bits to be stretched.
//              dxNew dyNew: new size for the bits.
//
// Returns: fTrue if success else fFalse.
//
// Description: Creates a new DIB of size dxNew, dyNew from lpbmih & lpbi.
//              Uses a DIBSection to do so instead of using a Compat. bmp
//              to stretch the bits to and doing GetDIBits etc that
//              HDIBScaledFromHDib() uses
// ***************************************************************************
BOOL  FDIBBitsScaledFromHDIB(HDC hdc, MRS *pmrs, LPBITMAPINFOHEADER lpbmih,
	BYTE *lpBits, int dxNew, int dyNew, PDSI pdsi)
{
    BOOL fOK = fFalse;
    HBITMAP hbmSec=NULL;
    BITMAPINFOHEADER bmihSav = *lpbmih, bmihNew;

    // sanity checking.
    if (dxNew == 0)
        dxNew = 1;
    if (dyNew == 0)
        dyNew = 1;

#ifdef DEBUG_BITS_ROT
	BLOCK
		{
		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmih->biWidth, lpbmih->biHeight,
			0,0, lpbmih->biWidth, lpbmih->biHeight, lpBits,
			(LPBITMAPINFO)lpbmih, DIB_RGB_COLORS, SRCCOPY);
		}
#endif // DEBUG_BITS_ROT

    lpbmih->biHeight = Abs(dyNew);
    lpbmih->biWidth = dxNew;
    bmihNew = *lpbmih;
    // clear out *pdsi
    ZeroMemory(pdsi, sizeof(DSI));

    if ((pdsi->hdc = CreateCompatibleDC(hdc)) &&
		(hbmSec = CreateDIBSection(hdc, (LPBITMAPINFO)lpbmih,DIB_RGB_COLORS,
                                    &(pdsi->lpBits), NULL, 0)))
        {
        GdiFlush();
        if (pdsi->hbmOld = (HBITMAP)SelectObject(pdsi->hdc, hbmSec))
            {
            SetStretchBltMode(pdsi->hdc, COLORONCOLOR);
            *lpbmih = bmihSav;  // restore for the stretchDIBits() call
            fOK = (StretchDIBits(pdsi->hdc, 0, 0, dxNew, dyNew,
                          0, 0, lpbmih->biWidth, lpbmih->biHeight,
                          lpBits, (LPBITMAPINFO)lpbmih,
                          DIB_RGB_COLORS, SRCCOPY) != GDI_ERROR);

#ifdef DEBUG_BITS_ROT
			BLOCK
				{
				*lpbmih = bmihNew;  // reflect new size.
				StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmih->biWidth, lpbmih->biHeight,
					0,0, lpbmih->biWidth, lpbmih->biHeight, pdsi->lpBits,
					(LPBITMAPINFO)lpbmih, DIB_RGB_COLORS, SRCCOPY);
				}
#endif // DEBUG_BITS_ROT
            }
        }
    if (!pdsi->hbmOld && hbmSec)
        {
        AssertEx(!fOK);
        DeleteObject(hbmSec);
        }

    *lpbmih = bmihNew;  // reflect new size.

    return fOK;
}   /* FDIBBitsScaledFromHDIB */

// ***************************************************************************
// %%Function: HDIBConvertDIB           %%Owner: harip    %%Reviewed: 12/15/94
//
// Description: returns a handle to dib-bits which contains the same info passed
//              in, except that the type of compression is now dwCompression.
//              lpbmi and lpBits shd point to same block of mem.
//              lpbmi has some of its fields changed.
// ***************************************************************************
HQ HQDIBBitsConvertDIB(HDC hdc, LPBITMAPINFOHEADER lpbmi, BYTE *pDIBBits, DWORD dwCompression)
{
    BITMAPINFOHEADER bmih = *lpbmi;
    HBITMAP hbmT;
    HQ hDIBBitsNew = NULL;
    BYTE *pBitsNew;
    BOOL fOK = fFalse;

    AssertEx(lpbmi->biCompression != dwCompression);
    // convert RLE to RGB bitmap, since rotating rle bits leads to bogosity
    bmih.biCompression = dwCompression;
    hbmT = CreateDIBitmap(hdc, (LPBITMAPINFOHEADER)&bmih, CBM_INIT, pDIBBits,
    					(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS);
    if (!hbmT)
        goto LError;
    *((DWORD *)lpbmi) = sizeof(BITMAPINFOHEADER);
    lpbmi->biCompression = dwCompression;
    // get the size of the image
    if (!GetDIBits(hdc, hbmT, 0, lpbmi->biHeight,(LPVOID)NULL,
				  (LPBITMAPINFO)lpbmi, DIB_RGB_COLORS))
		{
		goto LError;
		}

	hDIBBitsNew = HqAlloc(lpbmi->biSizeImage); // alloc mem for bits
	if (hDIBBitsNew == hqNil)
		goto LError;
	pBitsNew = (BYTE *)LpLockHq(hDIBBitsNew);

    // now get the bits
    fOK = GetDIBits(hdc, hbmT, 0, lpbmi->biHeight, (LPVOID)pBitsNew,
					(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS);
    UnlockHq(hDIBBitsNew);
    if (!fOK)
        goto LError;
    lpbmi->biSizeImage = 0; // just to be safe

    return hDIBBitsNew;
LError:
    if (hDIBBitsNew)
        FreeHq(hDIBBitsNew);
    return NULL;
} /* HQDIBBitsConvertDIB */

#endif // NOTYET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\displeafnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       displeafnode.cxx
//
//  Contents:   A display item supporting background, border, and
//              user clip.
//
//  Classes:    CDispLeafNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

#ifndef X_DISPFILTER_HXX_
#define X_DISPFILTER_HXX_
#include "dispfilter.hxx"
#endif

MtDefine(CDispLeafNode, DisplayTree, "CDispLeafNode")


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::Recalc
//              
//  Synopsis:   Recalculate this node's cached state.
//              
//  Arguments:  pRecalcContext      display recalc context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispLeafNode::Recalc(CRecalcContext* pRecalcContext)
{
    CDispRecalcContext* pContext = DispContext(pRecalcContext);
    
    // shouldn't be here unless this node requested recalc, or we're recalcing
    // the whole subtree
    Assert(MustRecalc() || pContext->_fRecalcSubtree);

    CRect rcpBounds(GetBounds());
    GetMappedBounds(&rcpBounds);
    CRect rcbBounds(rcpBounds.Size());
    CRect rcpBoundsExpanded;

    SetPainterState(rcpBounds, &rcpBoundsExpanded);

    // if we have a transform, recalc the post transformed bounds
    if (HasUserTransform())
    {
        TransformRect(rcpBoundsExpanded, COORDSYS_PARENT, &_rctBounds, COORDSYS_TRANSFORMED);
    }

    // if no transform, but advanced, just use the expanded rect
    else if (HasAdvanced())
    {
        *PBounds() = rcpBounds;
        _rctBounds = rcpBoundsExpanded;
        
        // transformed nodes are not allowed to be opaque because of non-90 degree
        // rotations
        ClearFlag(s_opaqueBranch);
    }

    // if no tranform or advanced, just use the basic rect
    else
    {
        _rctBounds = rcpBounds;
        
        // if no transform or advanced, check for possible opacity optimization
        SetFlag(s_opaqueBranch, IsOpaque() && rcbBounds.Area() >= MINIMUM_OPAQUE_PIXELS);
    }
    
    // is this item in view?
    BOOL fVisible = IsVisible();
    BOOL fWasInView = IsInView();
    BOOL fInView = fVisible && pContext->IsInView(_rctBounds);
    
    // notify client of visibility changes if requested
    if (IsAnySet(s_notifyInViewChange | s_notifyNewInsertion))
    {
        // if our parent moved and forced recalc of its children, the
        // children may have moved
        if (pContext->_fRecalcSubtree)
            SetPositionChanged();

        if (fInView != fWasInView ||
            (fInView && PositionChanged()) ||
            IsAllSet(s_newInsertion | s_notifyNewInsertion))
        {
            // save old transform, change context to box coordinates
            CSaveDispClipTransform saveTransform(pContext);
            TransformedToBoxCoords(&pContext->GetClipTransform());
        
            NotifyInViewChange(
                pContext->GetClipTransform(),
                fInView,
                fWasInView,
                FALSE,
                pContext->_pRootNode);
        }
    }
    
    SetInView(fInView);
    SetVisibleBranch(fVisible);
    
    // add to invalid area
    if (IsAllSet(s_inval | s_inView | s_visibleNode) && !pContext->_fSuppressInval)
    {
        pContext->AddToRedrawRegion(_rctBounds, !HasWindowTop());
    }

    // if this element should obscure windows lower in the z-order, do so now
    if (fInView && fVisible && GetDispClient()->WantsToObscure(this))
    {
        CRect rcgClient;
        CRect rcgClip;

        // save old transform, change context to box coordinates
        CSaveDispClipTransform saveTransform(pContext);
        TransformedToBoxCoords(&pContext->GetClipTransform());

        GetGlobalClientAndClipRects(pContext->GetClipTransform(),
                                    &rcgClient,
                                    &rcgClip);

        pContext->_pRootNode->ObscureElements(rcgClip, this);
    }
    
    // clear display recalc flags
    ClearFlags(s_inval | s_positionChanged);
    
    //BasicRecalc(pContext);
    Assert(pContext != NULL);
    ClearFlags(s_childrenChanged | s_newInsertion | s_recalc | s_recalcSubtree);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::SetSize
//
//  Synopsis:   Set size for this node.
//
//  Arguments:  sizep           new size
//              fInvalidateAll  TRUE to invalidate entire contents of this node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::SetSize(const CSize& sizep, const CRect *prcpMapped, BOOL fInvalidateAll)
{
    // calculate new bounds
    CRect* prcpBounds = PBounds();

    if (prcpMapped)
    {
        if (!HasAdvanced())
            SetUpAdvancedDisplay();
        if (HasAdvanced())
            GetAdvanced()->SetMappedBounds(prcpMapped);
    }
    else
    {
        if (HasAdvanced())
            GetAdvanced()->SetNoMappedBounds();
    }

    if (sizep == prcpBounds->Size())
        return;

    if (!IsInvalid() && IsVisible() && IsInView() && (fInvalidateAll || HasUserTransform()))
    {
       // Invalidate the old rect
        Invalidate();
    }

    CRect rcpOld(*prcpBounds);
    prcpBounds->SetSize(sizep);
    
    // TODO (donmarsh) - this should really be s_viewHasChanged, when
    // we have such a flag.
    SetPositionChanged();

    // for RTL nodes, keep orinal content right-aligned by adjusting content offset
    if (HasContentOrigin() && GetContentOffsetRTL() >= 0)
    {
        // this recalculates offset from left and invalidates if necessary
        SetContentOrigin(GetContentOrigin(), GetContentOffsetRTL());
    }
    
    // if the inval flag is set, we don't need to invalidate because the
    // current bounds has never been rendered
    if (!IsInvalid())
    {
        RequestRecalc();
        
        if (IsVisible())
        {
            if (HasWindowTop())
            {
                InvalidateAtWindowTop();
                SetInvalid();
            }
            else if (IsInView())
            {
                if (fInvalidateAll || HasUserTransform())
                {
                    // mark invalid, so that new area will be repainted
                    SetInvalid();
                }
                else
                {
                    CRect rcbBorderWidths;
                    GetBorderWidths(&rcbBorderWidths);
                    InvalidateEdges(rcpOld.Size(), sizep, rcbBorderWidths);
                }
            }
            else
            {
                SetInvalid();
            }
        }
    }
    
    GetDispClient()->OnResize(sizep, this);
    Assert(MustRecalc());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::SetPosition
//              
//  Synopsis:   Set the position of this leaf node.
//              
//  Arguments:  ptpTopLeft      new top left coordinates (in PARENT coordinates)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispLeafNode::SetPosition(const CPoint& ptpTopLeft)
{
    // calculate new bounds
    CRect* prcpBounds = PBounds();
    if (ptpTopLeft == prcpBounds->TopLeft())
        return;

    if (!IsInvalid())
    {
        if (HasWindowTop())
        {
            InvalidateAtWindowTop();
            SetInvalid();
        }
        else if (IsVisible())
        {
            Invalidate();
            SetInvalid();
        }
    }
    
    prcpBounds->MoveTo(ptpTopLeft);
    
    SetPositionChanged();
    RequestRecalc();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::GetClientRect
//
//  Synopsis:   Return rectangles for various interesting parts of a display
//              node.
//
//  Arguments:  prc         rect which is returned
//              type        type of rect wanted
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::GetClientRect(RECT* prc, CLIENTRECT type) const
{
    switch (type)
    {
    case CLIENTRECT_BACKGROUND:
    case CLIENTRECT_CONTENT:
        {
            CRect rcbBorderWidths;
            GetBorderWidths(&rcbBorderWidths);
            ((CRect*)prc)->SetRect(
                GetSize()
                - rcbBorderWidths.TopLeft().AsSize()
                - rcbBorderWidths.BottomRight().AsSize());
            if (prc->left >= prc->right || prc->top >= prc->bottom)
                *prc = g_Zero.rc;
        }
        break;
    default:
        *prc = g_Zero.rc;
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::HitTestPoint
//
//  Synopsis:   Determine whether this item intersects the hit test point.
//
//  Arguments:  pContext        hit context, in COORDSYS_TRANSFORMED
//              fForFilter      TRUE when we're called from a filter
//              fHitContent     TRUE to hit contents of this container,
//                              regardless of this container's bounds
//
//  Returns:    TRUE if this item intersects the hit test point.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispLeafNode::HitTestPoint(CDispHitContext* pContext, BOOL fForFilter, BOOL fHitContent)
{
    Assert(IsVisible());
    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //   
    Assert(fHitContent || fForFilter || pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest() ));

    CDispClipTransform transformSaveTransformed(pContext->GetClipTransform());
    TransformedToBoxCoords(&pContext->GetClipTransform());
    CDispClipTransform transformSaveBox(pContext->GetClipTransform());
    BOOL               fPeerDeclinedHit = FALSE;
    
    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    CRect rccContent(di._sizesContent);

    // hack for VID's "frozen" attribute
    {
        TransformBoxToContent(&pContext->GetClipTransform().NoClip(), di);
        CPoint ptcHitTest;
        pContext->GetHitTestPoint(&ptcHitTest);
        if (GetDispClient()->HitTestBoxOnly(
                &ptcHitTest,
                this,
                pContext->_pClientData))
        {
            // NOTE: don't bother to restore context transform for speed
            pContext->SetHitTestCoordinateSystem(COORDSYS_CONTENT);                
            return TRUE;
        }
        pContext->SetClipTransform(transformSaveBox);
    }

    // get the draw program
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    int iPC;
    int iCookie;

    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, FILTER_DRAW_ALLLAYERS))
    {
        AssertSz(0, "Failed to get draw program");
        return FALSE;
    }

    // we will run the program backwards;  first fix up the arguments
    ReverseDrawProgram(aryProgram, &iPC, &iCookie);

    // search for a hit from foreground layers to background
    DISPNODELAYER layerStop;
    void * cookie = NULL;
    BOOL fContentHasDrawn = FALSE;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    TransformBoxToScroll(&pContext->GetClipTransform().NoClip(), di);

    for ( ;  iPC>=DP_START_INDEX;  --iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawContent:
            layerStop = (DISPNODELAYER) aryProgram[--iPC];

            if (!fContentHasDrawn && DISPNODELAYER_FLOW >= layerStop)
            {
                CDispClipTransform transformSaveScroll(pContext->GetClipTransform());
                TransformScrollToContent(&pContext->GetClipTransform(), di);
                // hit test content
                fContentHasDrawn = TRUE;
                if (pContext->RectIsHit(di._rccBackgroundClip))
                {
                    TransformContentToFlow(&pContext->GetClipTransform(), di);
                    
                    CPoint ptfHitTest;
                    pContext->GetHitTestPoint(&ptfHitTest);

                    if (GetDispClient()->HitTestContent(
                            &ptfHitTest,
                            (CDispNode*)this,
                            pContext->_pClientData,
                            fPeerDeclinedHit ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_FLOWCONTENT);                
                        return TRUE;
                    }
                }
                pContext->SetClipTransform(transformSaveScroll);
            }
            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.right  = aryProgram[--iPC];
            rcExpand.bottom = aryProgram[--iPC];
            rcExpand.left   = aryProgram[--iPC];
            rcExpand.top    = aryProgram[--iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced() && iCookie>=1);
            cookie = aryCookie[--iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
        {
            CDispClipTransform transformSaveScroll(pContext->GetClipTransform());

            if (!fExpand)
            {
                if (pContext->RectIsHit(di._rccBackgroundClip))
                {
                    CPoint ptcHitTest;
                    BOOL   fLocalPeerDeclined = FALSE;
                    pContext->GetHitTestPoint(&ptcHitTest);
                    pContext->SetClipTransform(transformSaveTransformed);
                    if (GetDispClient()->HitTestPeer(
                            &ptcHitTest,
                            COORDSYS_CONTENT,
                            this,
                            cookie,
                            pContext->_pClientData,
                            fHitContent,
                            pContext,
                            &fLocalPeerDeclined ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        return TRUE;
                    }

                    fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;
                }
            }
            else
            {
                Assert(HasAdvanced());
                CRect rcbBounds = GetBounds().Size();
                if (!fForFilter)
                    GetMappedBounds(&rcbBounds);
                rcbBounds.Expand(rcExpand);
                pContext->SetClipTransform(transformSaveBox);

                if (pContext->RectIsHit(rcbBounds))
                {
                    CPoint ptbHitTest;
                    BOOL   fLocalPeerDeclined = FALSE;

                    pContext->GetHitTestPoint(&ptbHitTest);
                    pContext->SetClipTransform(transformSaveTransformed);
                    if (GetDispClient()->HitTestPeer(
                            &ptbHitTest,
                            COORDSYS_BOX,
                            this,
                            cookie,
                            pContext->_pClientData,
                            fHitContent,
                            pContext,
                            &fLocalPeerDeclined ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        return TRUE;
                    }

                    fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;
                }
            }
            cookie = NULL;
            fExpand = FALSE;
            pContext->SetClipTransform(transformSaveScroll);
            break;
        }

        case DP_DrawBackground:
            break;

        case DP_WindowTopMulti:     --iCookie;
        case DP_WindowTop:
            fExpand = FALSE;
            break;

        case DP_BoxToContent:
            break;

        case DP_DrawBorder:
            // hit test border
            pContext->SetClipTransform(transformSaveBox);
            if (HasBorder())
            {
                CSize sizepNode = GetSize();
                if (pContext->RectIsHit(di._rcbContainerClip) &&
                    (pContext->RectIsHit(CRect(0,0, di._prcbBorderWidths->left, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0,0, sizepNode.cx, di._prcbBorderWidths->top)) ||
                     pContext->RectIsHit(CRect(sizepNode.cx - di._prcbBorderWidths->right, 0, sizepNode.cx, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0, sizepNode.cy - di._prcbBorderWidths->bottom, sizepNode.cx, sizepNode.cy))))
                {
                    CPoint ptbHitTest;
                    pContext->GetHitTestPoint(&ptbHitTest);
                    BOOL fHitBorder = GetDispClient()->HitTestBorder(
                                                                        &ptbHitTest,
                                                                        (CDispNode*)this,
                                                                        pContext->_pClientData);                    
                    if (fHitBorder)
                    {
                        // NOTE: don't bother to context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);                
                        return TRUE;
                    }
                }
            }
            break;
        }
        
    }

    pContext->SetClipTransform(transformSaveTransformed);

    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //
    
    // do fuzzy hit test if requested
    if (pContext->_cFuzzyHitTest &&
        !pContext->RectIsHit(_rctBounds) &&
        pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest()))
    {
        CPoint ptbHitTest;
        pContext->SetClipTransform(transformSaveBox);
        pContext->GetHitTestPoint(&ptbHitTest);
        if (GetDispClient()->HitTestFuzzy(
                &ptbHitTest,
                (CDispNode*)this,
                pContext->_pClientData))
        {
            pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
            return TRUE;
        }

        // restore transform
        pContext->SetClipTransform(transformSaveTransformed);
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::CalculateInView
//
//  Synopsis:   Determine whether this leaf node is in view, and whether its
//              client must be notified.
//
//  Arguments:  transform           display transform, in COORDSYS_TRANSFORMED
//              fPositionChanged    TRUE if position changed
//              fNoRedraw           TRUE to suppress redraw (after scrolling)
//
//  Returns:    TRUE if this node is in view.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispLeafNode::CalculateInView(
        const CDispClipTransform& transform,
        BOOL fPositionChanged,
        BOOL fNoRedraw,
        CDispRoot *pDispRoot)
{
    // change to box coordinates
    CDispClipTransform newTransform(transform);
    TransformedToBoxCoords(&newTransform);
    
    CRect rcbBounds = GetExpandedBounds();
    BOOL fInView = rcbBounds.Intersects(newTransform.GetClipRect());
    BOOL fWasInView = IsInView();

    // notify client if client requests it and view status changes
    if (IsAllSet(s_notifyInViewChange | s_visibleBranch) && (fInView || fWasInView))
    {
        if (fPositionChanged)
            SetPositionChanged();
        
        NotifyInViewChange(
            newTransform,
            fInView,
            fWasInView,
            fNoRedraw,
            pDispRoot);
        
        SetPositionChanged(FALSE);
    }

    SetInView(fInView);
    return fInView;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::DrawSelf
//
//  Synopsis:   Draw this item.
//
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              pChild          start drawing at this child
//              lDrawLayers     layers to draw (for filters)
//
//----------------------------------------------------------------------------

void
CDispLeafNode::DrawSelf(CDispDrawContext* pContext, CDispNode* pChild,
                            LONG lDrawLayers)
{
    // shouldn't be called unless this node was selected to draw
    Assert(IsAllSet(pContext->GetDrawSelector()));
    Assert(IsSet(s_savedRedrawRegion) ||
           pContext->IntersectsRedrawRegion(GetExpandedBounds()) ||
           !pContext->GetClipTransform().IsOffsetOnly());
    Assert(!IsAnySet(s_flagsNotSetInDraw));
    Assert(pChild == NULL);

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    
    // prepare to run the draw program
    CRect rccContent(di._sizesContent);
    rccContent.OffsetRect(-di._sizesScroll);    // content offset
    
    DISPNODELAYER layerStop;
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, lDrawLayers))
    {
        AssertSz(0, "Failed to get draw program");
        return;
    }
    BOOL fContentHasDrawn = FALSE;
    BOOL fDrawWithinBorders = TRUE;
    int iCookie = -1;
    void * cookie = NULL;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    CDispClipTransform transformBox = pContext->GetClipTransform();

    // TODO (sambent) containers draw background in box coordinates,
    // yet leaves draw in content coordinates.  Shouldn't they be the same?

    TransformBoxToContent(&pContext->GetClipTransform().NoClip(), di);
    pContext->SetClipRect(di._rccBackgroundClip);
    CRect rccClip(di._rccBackgroundClip);
    pContext->IntersectRedrawRegion(&rccClip);

    // run the program
    for (int iPC = DP_START_INDEX;  aryProgram[iPC] != DP_Done;  ++iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawBorder:
            // draw optional border
            if (HasBorder())
            {
                CSaveDispClipTransform transformSaveContent(pContext);
                pContext->SetClipTransform(transformBox);
                //Assert(pContext is in box coords)
                DrawBorder(pContext, *di._prcbBorderWidths, GetDispClient());
            }
            // having drawn the border, we may not need to draw anything else
            fDrawWithinBorders = !rccClip.IsEmpty();
            break;

        case DP_DrawBackground:
            //Assert(pContext is in content coords);
            if (fDrawWithinBorders && HasBackground())
            {
                GetDispClient()->DrawClientBackground(
                        &rccContent,
                        &rccClip,
                        pContext->PrepareDispSurface(),
                        this, 
                        pContext->GetClientData(),
                        0);
            }
            // fall through to BoxToContent

        case DP_BoxToContent:
            // not needed for leaves - we're already in content coords
            break;

        case DP_DrawContent:
            layerStop = (DISPNODELAYER)aryProgram[++iPC];

            if (fDrawWithinBorders && !fContentHasDrawn && DISPNODELAYER_FLOW <= layerStop)
            {
                BOOL fRestoreTransform = (aryProgram[iPC+1] != DP_Done);
                CDispClipTransform transformSave;

                if (fRestoreTransform)
                    transformSave = pContext->GetClipTransform();
                
                TransformContentToFlow(&pContext->GetClipTransform().NoClip(),di);
                CRect rcfClip(rccClip);
                if (!di._sizecInset.IsZero())
                {
                    rcfClip.OffsetRect(-di._sizecInset);
                    rcfClip.IntersectRect(CRect(di._sizecBackground - di._sizecInset));
                }
                if (!rcfClip.IsEmpty())
                {
                    pContext->SetClipRect(rcfClip);
                    CRect rcfContent(di._sizesContent - di._sizecInset);
                    rcfContent.OffsetRect(-di._sizesScroll);    // content offset
                    GetDispClient()->DrawClient(
                        &rcfContent,
                        &rcfClip,
                        pContext->PrepareDispSurface(),
                        this,
                        0,
                        pContext->GetClientData(),
                        0);
                }

                if (fRestoreTransform)
                    pContext->SetClipTransform(transformSave);

                fContentHasDrawn = TRUE;
            }
            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.top    = aryProgram[++iPC];
            rcExpand.left   = aryProgram[++iPC];
            rcExpand.bottom = aryProgram[++iPC];
            rcExpand.right  = aryProgram[++iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced());
            cookie = aryCookie[++iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
            // Assert(pContext is in content coords);
            if (!fExpand)
            {
                if (fDrawWithinBorders)
                {
                    GetDispClient()->DrawClientLayers(
                        &rccContent,
                        &di._rccBackgroundClip,
                        pContext->PrepareDispSurface(),
                        this,
                        cookie,
                        pContext,
                        CLIENTLAYERS_AFTERBACKGROUND);
                }
            }
            else
            {
                Assert(HasAdvanced());
                CSaveDispClipTransform transformSaveContent(pContext);
                CRect rcbBounds = GetBounds().Size();
                GetMappedBounds(&rcbBounds);

                pContext->SetClipTransform(transformBox);
                rcbBounds.Expand(rcExpand);
                CRect rcbClip = rcbBounds;
                rcbClip.IntersectRect(transformBox.GetClipRect());

                GetDispClient()->DrawClientLayers(
                    &rcbBounds,
                    &rcbClip,
                    pContext->PrepareDispSurface(),
                    this,
                    cookie,
                    pContext,
                    CLIENTLAYERS_AFTERBACKGROUND);
            }
            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_WindowTopMulti:     ++iCookie;  // ignore cookie
        case DP_WindowTop:
            if (!HasWindowTop())
            {
                pContext->GetRootNode()->AddWindowTop(this);
            }
            fExpand = FALSE;
            break;

        default:
            AssertSz(0, "Unrecognized draw program opcode");
            break;
        }
    }

#if DBG==1
    CDebugPaint::PausePaint(tagPaintWait);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::CalcDispInfo
//
//  Synopsis:   Calculate clipping and positioning info for this node.
//
//  Arguments:  rcbClip         clip rect in box coordinates
//              pdi             display info structure
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::CalcDispInfo(
        const CRect& rcbClip,
        CDispInfo* pdi) const
{
    CDispInfo& di = *pdi;   // notational convenience

    // no scrolling
    di._sizesScroll = g_Zero.size;

    // get content size and offset to local coordinates
    CRect rcpBounds;
    GetBounds(&rcpBounds);
    rcpBounds.GetSize(&di._sizesContent);
    rcpBounds.GetTopLeft(&di._sizepBoxToParent.AsPoint());
    
    // adjust by optional border
    GetBorderWidthsAndInset(&di._prcbBorderWidths, &di._sizecInset, &di._rcTemp);
    di._sizesContent.cx -= di._prcbBorderWidths->left + di._prcbBorderWidths->right;
    di._sizesContent.cy -= di._prcbBorderWidths->top + di._prcbBorderWidths->bottom;
    di._sizecBackground = di._sizesContent;
    di._sizebScrollToBox = di._prcbBorderWidths->TopLeft().AsSize();

    // calc container clip
    di._rcbContainerClip = rcbClip;
    
    // NOTE: CDispLeafNode doesn't use di._rccPositionedClip, so it is not initialized
    
    // calc background clip
    di._rccBackgroundClip = rcbClip;
    di._rccBackgroundClip.OffsetRect(-di._sizebScrollToBox);
    di._rccBackgroundClip.IntersectRect(CRect(di._sizecBackground));

    // calc flow clip
    di._rcfFlowClip = di._rccBackgroundClip;
    if (!di._sizecInset.IsZero())
    {
        di._rcfFlowClip.OffsetRect(-di._sizecInset);
        di._rcfFlowClip.IntersectRect(CRect(di._sizecBackground - di._sizecInset));
    }

    // optional offset from content origin
    if (HasContentOrigin())
    {
        const CSize& sizecOrigin = GetContentOrigin();
        di._sizesScroll += sizecOrigin;
        
        // adjust for content origin
        di._rccBackgroundClip.OffsetRect(-sizecOrigin);
        di._rcfFlowClip.OffsetRect(-sizecOrigin);
    }

    if (HasExpandedClipRect())
    {
        const CRect& rcExpandedClip = GetExpandedClipRect();
        di._rccBackgroundClip.Expand(rcExpandedClip);
        di._rcfFlowClip.Expand(rcExpandedClip);
    }
    
    // leaf nodes don't have positioned children, but we need this rectangle
    // for the TransformScrollToContent method
    di._rccPositionedClip = di._rccBackgroundClip;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::NotifyInViewChange
//              
//  Synopsis:   Notify client when this item's in-view status or position
//              changes.
//
//  Arguments:  transform           display transform in COORDSYS_BOX
//              fResolvedVisible    TRUE if this item is visible and in view
//              fWasResolvedVisible TRUE if this item was visible and in view
//              fNoRedraw           TRUE to suppress redraw
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispLeafNode::NotifyInViewChange(
        const CDispClipTransform& transform,
        BOOL fResolvedVisible,
        BOOL fWasResolvedVisible,
        BOOL fNoRedraw,
        CDispRoot *pDispRoot)
{
    CRect rcgClient;
    CRect rcgClip;

    GetGlobalClientAndClipRects(transform, &rcgClient, &rcgClip);

    DWORD viewChangedFlags = 0;
    if (fResolvedVisible)
        viewChangedFlags = VCF_INVIEW;
    if (fResolvedVisible != fWasResolvedVisible)
        viewChangedFlags |= VCF_INVIEWCHANGED;
    if (PositionChanged())
        viewChangedFlags |= VCF_POSITIONCHANGED;
    if (fNoRedraw)
        viewChangedFlags |= VCF_NOREDRAW;

    if (fResolvedVisible && GetDispClient()->WantsToBeObscured(this))
    {
        pDispRoot->AddObscureElement(this, rcgClient, rcgClip);
    }
    
    GetDispClient()->HandleViewChange(
        viewChangedFlags,
        &rcgClient,
        &rcgClip,
        this);

    if (HasAdvanced() && GetAdvanced()->HasOverlays())
    {
        GetAdvanced()->MoveOverlays();
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::DumpContentInfo
//
//  Synopsis:   Dump custom information for this node.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::DumpContentInfo(HANDLE hFile, long level, long childNumber) const
{
#if 0
    IDispClientDebug* pIDebug;
    if (SUCCEEDED(
        GetDispClient()->QueryInterface(IID_IDispClientDebug,(void**)&pIDebug)))
    {
        pIDebug->DumpDebugInfo(hFile, level, childNumber, this, 0);
        pIDebug->Release();
    }
#else
    GetDispClient()->DumpDebugInfo(hFile, level, childNumber, this, 0);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\dispparent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispparent.cxx
//
//  Contents:   Base class for parent (non-leaf) display nodes.
//
//  Classes:    CDispParentNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

PerfDbgTag(tagDispPosZ,      "Display", "Trace CDisplay::InsertChildInPosZ")


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::~CDispParentNode
//              
//  Synopsis:   Destruct this node, as well as any children marked for
//              destruction.
//              
//----------------------------------------------------------------------------


CDispParentNode::~CDispParentNode() 
{
    UnlinkChildren();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertChildInFlow
//              
//  Synopsis:   Insert new child at the end of the flow layer list.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertChildInFlow(CDispNode* pNewChild)
{
    CDispNode *pChildPrev=NULL, *pChildNext=NULL;
    
    // scan backwards through layers
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        int childLayer = pChild->GetLayer();
        
        if (childLayer == s_layerFlow)
        {
            return (pChild->IsStructureNode())
                ? pChild->AsParent()->InsertLastChildNode(pNewChild)
                : pChild->InsertSiblingNode(pNewChild, after);
        }
        
        if (childLayer < s_layerFlow)
        {
            pChildPrev = pChild;
            break;
        }
        else
        {
            pChildNext = pChild;
        }
    }

    if ((pChildPrev && pChildPrev->IsStructureNode()) ||
        (pChildNext && pChildNext->IsStructureNode()))
    {
        // this node is a structure parent, but there are no children at the flow layer (yet)
        CDispParentNode *pParent = InsertNewStructureNode(pChildPrev, pChildNext,
                                                s_layerFlow, s_layerMask);
        return pParent ? pParent->InsertChildInFlow(pNewChild) : FALSE;
    }
    else    // not a structure parent
    {
        if (pChildPrev)
            return pChildPrev->InsertSiblingNode(pNewChild, after);
        else
            return InsertFirstChildNode(pNewChild);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertFirstChildInFlow
//              
//  Synopsis:   Insert new child at the beginning of the flow layer list.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertFirstChildInFlow(CDispNode* pNewChild)
{
    CDispNode *pChildPrev=NULL, *pChildNext=NULL;
    
    // scan forwards through layers
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        int childLayer = pChild->GetLayer();
        
        if (childLayer == s_layerFlow)
        {
            return (pChild->IsStructureNode())
                ? pChild->AsParent()->InsertFirstChildNode(pNewChild)
                : pChild->InsertSiblingNode(pNewChild, before);
        }
        
        if (childLayer > s_layerFlow)
        {
            pChildNext = pChild;
            break;
        }
        else
        {
            pChildPrev = pChild;
        }
    }

    if ((pChildPrev && pChildPrev->IsStructureNode()) ||
        (pChildNext && pChildNext->IsStructureNode()))
    {
        // this node is a structure parent, but there are no children at the flow layer (yet)
        CDispParentNode *pParent = InsertNewStructureNode(pChildPrev, pChildNext,
                                                s_layerFlow, s_layerMask);
        return pParent ? pParent->InsertFirstChildInFlow(pNewChild) : FALSE;
    }
    else    // not a structure parent
    {
        if (pChildNext)
            return pChildNext->InsertSiblingNode(pNewChild, before);
        else
            return InsertLastChildNode(pNewChild);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertChildInNegZ
//              
//  Synopsis:   Insert a negative z-ordered child node.
//              
//  Arguments:  pNewChild       child node to insert
//              zOrder          negative z value
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertChildInNegZ(CDispNode* pNewChild, LONG zOrder)
{
    Assert(zOrder < 0);

    CDispNode* pChild = _pFirstChild;

    BOOL fStructureParent = pChild && pChild->IsStructureNode();

    if (!fStructureParent)
    {
        // scan forwards through layers
        for ( ; pChild; pChild = pChild->_pNext)
        {
            int childLayer = pChild->GetLayer();
            Assert(!pChild->IsStructureNode());

            if (childLayer == s_layerNegZ)
            {
                // if we found a node with greater z order, insert before it
                if (pChild->IsGreaterZOrder(pNewChild, zOrder))
                    return pChild->InsertSiblingNode(pNewChild, before);
            }

            else //if (childLayer > s_layerNegZ)
                return pChild->InsertSiblingNode(pNewChild, before);
        }

        return InsertLastChildNode(pNewChild);
    }
    
    else    // this is a structure parent
    {
        CDispParentNode* pParent = NULL;
        CDispNode* pChildFirst = pChild;

        // scan forwards through layers
        for ( ; pChild; pChild = pChild->_pNext)
        {
            int childLayer = pChild->GetLayer();
            Assert(pChild->IsStructureNode());
            
            if (childLayer == s_layerNegZ)
            {
                pParent = pChild->AsParent();
                CDispNode* pRightChild = pParent->GetLastChildNode();
                if (pRightChild && pRightChild->IsGreaterZOrder(pNewChild, zOrder))
                {
                    break;
                }
            }
            
            else //if (childLayer > s_layerNegZ)
            {
                break;
            }
        }

        // if we didn't find the right parent, there are no (structure) children
        // at the right layer.  So create one.
        if (!pParent)
        {
            pParent = InsertNewStructureNode(NULL, pChildFirst,
                                            s_layerNegZ, s_layerMask);
        }

        // insert new child node in proper order inside this structure node
        return pParent ? pParent->InsertChildInNegZ(pNewChild, zOrder) : FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertChildInPosZ
//              
//  Synopsis:   Insert a positive z-ordered child node.
//              
//  Arguments:  pNewChild       child node to insert
//              zOrder          positive z value
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertChildInPosZ(CDispNode* pNewChild, LONG zOrder)
{
    Assert(zOrder >= 0);

    BOOL fRet;

    PerfDbgLog(tagDispPosZ, this, "+CDispParentNode::InsertChildInPosZ");

    CDispNode* pChild = _pLastChild;

    BOOL fStructureParent = pChild && pChild->IsStructureNode();

    if (!fStructureParent)
    {
        // scan backwards through layers
        // NB: binary search here?
        for ( ; pChild; pChild = pChild->_pPrevious)
        {
            int childLayer = pChild->GetLayer();
            Assert(!pChild->IsStructureNode());
            
            if (childLayer == s_layerPosZ)
            {
                // if we found a node with lesser z order, insert after it
                if (!pChild->IsGreaterZOrder(pNewChild, zOrder))
                {
                    fRet = pChild->InsertSiblingNode(pNewChild, after);
                    goto PerfDbgOut;
                }
            }
            
            else //if (childLayer < s_layerPosZ)
            {
                fRet = pChild->InsertSiblingNode(pNewChild, after);
                goto PerfDbgOut;
            }
        }
        
        fRet = InsertFirstChildNode(pNewChild);

PerfDbgOut:
        PerfDbgLog(tagDispPosZ, this, "-CDispParentNode::InsertChildInPosZ (regular)");
    }
    
    else    // this is a structure parent
    {
        CDispParentNode* pParent = NULL;
        CDispNode* pChildLast = pChild;

        // scan backwards through layers
        for ( ; pChild; pChild = pChild->_pPrevious)
        {
            int childLayer = pChild->GetLayer();
            Assert(pChild->IsStructureNode());
            
            if (childLayer == s_layerPosZ)
            {
                pParent = pChild->AsParent();
                CDispNode* pLeftChild = pParent->GetFirstChildNode();
                if (pLeftChild && !pLeftChild->IsGreaterZOrder(pNewChild, zOrder))
                {
                    break;
                }
            }
            
            else //if (childLayer < s_layerPosZ)
            {
                break;
            }
        }

        // if we didn't find the right parent, there are no (structure) children
        // at the right layer.  So create one.
        if (!pParent)
        {
            pParent = InsertNewStructureNode(pChildLast, NULL,
                                            s_layerPosZ, s_layerMask);
        }

        PerfDbgLog(tagDispPosZ, this, "-CDispParentNode::InsertChildInPosZ (recurse)");

        // insert new child node in proper order inside this structure node
        fRet = pParent ? pParent->InsertChildInPosZ(pNewChild, zOrder) : FALSE;
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::Recalc
//              
//  Synopsis:   Recalculate this node's cached state.
//              
//  Arguments:  pRecalcContext      display recalc context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::Recalc(CRecalcContext* pRecalcContext)
{
    // shouldn't be here unless this node requested recalc, or we're recalcing
    // the whole subtree
    Assert(MustRecalc() || pRecalcContext->_fRecalcSubtree);
    
    // rebalance children
    if (ChildrenChanged() && !IsStructureNode() && HasChildren())
        RebalanceParentNode();
    
    // recalculate children
    RecalcChildren(pRecalcContext);

    
    Assert(!IsInvalid());
    Assert(!MustRecalc() && !MustRecalcSubtree());
    
    ClearFlags(s_childrenChanged | s_newInsertion | s_recalc | s_recalcSubtree);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::RecalcChildren
//              
//  Synopsis:   Recalculate children.
//
//  Arguments:  pRecalcContext      recalc context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::RecalcChildren(
        CRecalcContext* pRecalcContext)
{
    Assert(pRecalcContext != NULL);
    
    CDispRecalcContext* pContext = DispContext(pRecalcContext);
    
    // set flag values that are passed down our subtree
    CSwapRecalcState swapRecalcState(pContext, this);

    // accumulate flag values that are propagated up the tree to the root
    int childrenFlags = 0;

    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        Assert(pContext->_fRecalcSubtree ||
            pChild->MustRecalc() ||
            !pChild->IsInvalid());

        // recalc children that need it, or all children if we are recalculating
        // the entire subtree
        if (pContext->_fRecalcSubtree || pChild->MustRecalc())
        {
            pChild->Recalc(pContext);
        }
        
        Assert(!pChild->IsInvalid());
        Assert(pChild->IsParentNode() || !pChild->PositionChanged());
        Assert(!pChild->MustRecalc());
        Assert(!pChild->MustRecalcSubtree());
        
        childrenFlags |= pChild->GetFlags();
    }

    // ensure that we don't bother to invalidate anything during bounds calc.
    SetMustRecalc();
    ComputeVisibleBounds();

    // set in-view status
    SetInView(pContext->IsInView(_rctBounds));
    
    // propagate flags from children, and clear recalc and inval flags
    CopyFlags(childrenFlags, s_inval | s_propagatedMask | s_recalc | s_recalcSubtree);
    
    Assert(!IsAnySet(s_inval | s_recalc | s_recalcSubtree));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::PreDraw
//              
//  Synopsis:   Before drawing starts, PreDraw processes the redraw region,
//              subtracting areas that are blocked by opaque or buffered items.
//              PreDraw is finished when the redraw region becomes empty
//              (i.e., an opaque item completely obscures all content below it)
//              
//  Arguments:  pContext    draw context, in COORDSYS_TRANSFORMED
//              
//  Returns:    TRUE if first opaque node to draw has been found
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::PreDraw(CDispDrawContext* pContext)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(s_preDrawSelector));
    Assert(pContext->IntersectsRedrawRegion(_rctBounds));
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    // we shouldn't be here if this is an opaque node
    Assert(!IsOpaque());
    
    // the only node type that should be executing here is CDispStructureNode,
    // which can't be filtered or transformed
    Assert(!IsDrawnExternally() && !HasUserTransform());
    
    CDispClipTransform saveTransform(pContext->GetClipTransform());

    // continue predraw traversal of children, top layers to bottom
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        // only children which meet our selection criteria
        if (pChild->IsAllSet(s_preDrawSelector))
        {
            // if we found the first child to draw, stop further PreDraw calcs
            if (PreDrawChild(pChild, pContext, saveTransform))
                return TRUE;
        }
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::PreDrawChild
//              
//  Synopsis:   Call the PreDraw method of the given child, and post-process
//              the results.
//              
//  Arguments:  pChild      child node to predraw
//              pContext    display context, in COORDSYS_TRANSFORMED for pChild
//              saveContext context of this parent node which may be saved
//                          on the context stack (and may differ from the
//                          child's context in pContext)
//              
//  Returns:    TRUE if first child to draw was this child or one of the
//              descendants in its branch
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::PreDrawChild(
    CDispNode* pChild,
    CDispDrawContext* pContext,
    const CDispClipTransform& saveTransform) const
{
    Assert(pChild != NULL);
    Assert(pChild->IsAllSet(s_preDrawSelector));
    // PreDraw should weed out parent nodes with transforms before calling PreDrawChild
    Assert(!HasUserTransform());

    // do the clipped visible bounds of this child intersect the
    // redraw region?
    if (!pContext->IntersectsRedrawRegion(pChild->_rctBounds) ||
        !pChild->PreDraw(pContext))
    {
        // continue predraw pass
        return FALSE;
    }
    
    // if we get here, we found the last opaque node which intersects the
    // redraw region.  No node at any lower layer needs to be drawn.
    // Add context information to stack, which will be used by Draw.
    if (pChild != _pLastChild ||
        pContext->GetFirstDrawNode() == NULL)
    {
        pContext->SaveTransform(this, saveTransform);
        
        // if this child was the first node to be drawn, remember it
        if (pContext->GetFirstDrawNode() == NULL)
            pContext->SetFirstDrawNode(pChild);
    }
    
    // finished with predraw pass
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::DrawSelf
//              
//  Synopsis:   Draw this node's children, no clip or offset changes.
//              
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              pChild          start drawing at this child
//              lDrawLayers     layers to draw (for filters)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::DrawSelf(CDispDrawContext* pContext, CDispNode* pChild, LONG lDrawLayers)
{
    // Interesting nodes are visible and in-view
    Assert(!HasUserTransform());  // nodes that can have transform should override DrawSelf
    Assert(IsAllSet(pContext->GetDrawSelector()));
    Assert(!IsAnySet(s_flagsNotSetInDraw));
    Assert(!IsDrawnExternally());
    
    // draw children, bottom layers to top
    if (pChild == NULL) pChild = _pFirstChild;
    for (; pChild; pChild = pChild->_pNext)
    {
        // only children which meet our visibility and inview criteria
        if (pChild->IsAllSet(pContext->GetDrawSelector()))
            pChild->Draw(pContext, NULL, FILTER_DRAW_ALLLAYERS);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::HitTestPoint
//              
//  Synopsis:   Test children for intersection with hit test point.
//              
//  Arguments:  pContext        hit context, in COORDSYS_TRANSFORMED
//              fHitContent     TRUE to hit contents of this container,
//                              regardless of this container's bounds
//              
//  Returns:    TRUE if intersection found
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::HitTestPoint(CDispHitContext* pContext, BOOL fForFilter, BOOL fHitContent)
{
    Assert(IsVisibleBranch());
    Assert(fHitContent || fForFilter || pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest() ));

    // NOTE: we don't have to worry about any transforms, offsets, or
    // user clip here, because this code can only be executed by
    // CDispStructureNode, which has none of those.  All other parent
    // nodes derive from CDispContainer, which overrides HitTestPoint.
    
    // search for a hit from foreground layers to background
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        // NOTE: we can't select on s_inView because when sometimes we hit test
        // on content that is not in view.
        if (pChild->IsVisibleBranch())
        {
            //
            // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
            // TODO - At some point the edit team may want to provide
            // a better UI-level way of selecting nested "thin" tables
            //
            //
            // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
            //
            
            if (fHitContent || pContext->FuzzyRectIsHit(pChild->_rctBounds, IsFatHitTest() ) &&
                pChild->HitTestPoint(pContext))
            {
                return TRUE;
            }
        }
    }
    
    return FALSE;
}


CDispScroller *
CDispParentNode::HitScrollInset(const CPoint& pttHit, DWORD *pdwScrollDir)
{
    CDispScroller * pDispScroller;

    // search for a hit from foreground layers to background
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        if (pChild->IsParentNode() &&
            pChild->IsAllSet(s_inView | s_visibleBranch) &&
            pChild->_rctBounds.Contains(pttHit))
        {
            pDispScroller = pChild->HitScrollInset(pttHit, pdwScrollDir);
            if (pDispScroller)
            {
                return pDispScroller;
            }
        }
    }
    
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::PushTransform
//              
//  Synopsis:   Get transform information for the given child node.
//              
//  Arguments:  pChild          the child node
//              pTransformStack transform stack to save transform changes in
//              pTransform      display transform
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::PushTransform(
        const CDispNode* pChild,
        CDispTransformStack* pTransformStack,
        CDispClipTransform* pTransform) const
{
    // transform needs to be saved only if this child is not our last, or this
    // will be the first entry in the transform stack
    if (pChild != _pLastChild || pTransformStack->IsEmpty())
    {
        pTransformStack->ReserveSlot(this);
        if (_pParent != NULL)
            GetRawParentNode()->PushTransform(this, pTransformStack, pTransform);
        pTransformStack->PushTransform(*pTransform, this);
    }
    else if (_pParent != NULL)
    {
        GetRawParentNode()->PushTransform(this, pTransformStack, pTransform);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::ComputeVisibleBounds
//
//  Synopsis:   Compute visible bounds for a parent node, marking children
//              that determine the edges of these bounds
//              
//  Arguments:  none
//              
//  Returns:    TRUE if visible bounds changed.
//
//----------------------------------------------------------------------------

BOOL
CDispParentNode::ComputeVisibleBounds()
{
    // any node that can be filtered should have overridden ComputeVisibleBounds.
    // The only kind of node that doesn't override currently is CDispStructureNode.
    Assert(!IsDrawnExternally());
    
    CRect rctBounds;
    
    if (_pFirstChild == NULL)
    {
        rctBounds.SetRectEmpty();
    }
    
    else
    {
        rctBounds.SetRect(MAXLONG,MAXLONG,MINLONG,MINLONG);
    
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            const CRect& rctChild = pChild->_rctBounds;
            if (!rctChild.IsEmpty())
            {
                rctBounds.Union(rctChild);
            }
        }
    }

    if (rctBounds != _rctBounds)
    {
        _rctBounds = rctBounds;
        return TRUE;
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::CalculateInView
//
//  Synopsis:   Calculate whether this node and its children are in view or not.
//
//  Arguments:  pTransform          display transform, in COORDSYS_TRANSFORMED
//              fPositionChanged    TRUE if position changed
//              fNoRedraw           TRUE to suppress redraw (after scrolling)
//              
//  Returns:    TRUE if this node is in view
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispParentNode::CalculateInView(CDispRoot *pDispRoot)
{
    CDispClipTransform transform;
    GetNodeClipTransform(&transform, COORDSYS_TRANSFORMED, COORDSYS_GLOBAL);
    return CalculateInView(transform, FALSE, FALSE, pDispRoot);
}


BOOL
CDispParentNode::CalculateInView(
    const CDispClipTransform& transform,
    BOOL fPositionChanged,
    BOOL fNoRedraw,
    CDispRoot *pDispRoot)
{
    // we shouldn't have to worry about user clip here, because all nodes that
    // provide user clip override CalculateInView
    Assert(!HasUserClip());
    
    BOOL fInView = _rctBounds.Intersects(transform.GetClipRect());
    BOOL fWasInView = IsInView();
    
    // calculate in view status of children unless this node is not in view
    // and was not in view
    if (fInView || fWasInView)
    {
        // accelerated way to clear in view status of all children, unless
        // some child needs change notification
        if (!fInView && !IsInViewAware())
        {
            ClearSubtreeFlags(s_inView);
            return FALSE;
        }
        
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
            pChild->CalculateInView(transform, fPositionChanged, fNoRedraw, pDispRoot);
    }
    
    SetInView(fInView);
    return fInView;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::ClearSubtreeFlags
//
//  Synopsis:   Clear given flags in this subtree.
//
//  Arguments:  flags       flags to clear
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispParentNode::ClearSubtreeFlags(int flags)
{
    // this routine is optimized to deal only with propagated flag values
    Assert((flags & s_propagatedMask) == flags);
    
    ClearFlags(flags);
    
    // process children
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        // only need to clear subtrees whose root has these flags set
        if (pChild->IsAnySet(flags))
        {
            if (pChild->IsLeafNode())
            {
                pChild->ClearFlags(flags);
            }
            else
            {
                pChild->AsParent()->ClearSubtreeFlags(flags);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::SetSubtreeFlags
//
//  Synopsis:   Set given flags in this subtree.
//
//  Arguments:  flags       flags to set
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispParentNode::SetSubtreeFlags(int flags)
{
    // only propagated flag values allowed
    // (to be consistent with ClearSubtreeFlags)
    Assert((flags & s_propagatedMask) == flags);
    
    SetFlags(flags);
    
    // process children
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        if (pChild->IsLeafNode())
        {
            pChild->SetFlags(flags);
        }
        else
        {
            pChild->AsParent()->SetSubtreeFlags(flags);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetScrollableBounds
//              
//  Synopsis:   Calculate the bounds of scrollable content, excluding child nodes
//              which are marked as not contributing to scroll size calculations.
//              
//  Arguments:  prc         returns bounds of scrollable content
//              cs          coordinate system for returned rect
//              
//----------------------------------------------------------------------------

void
CDispParentNode::GetScrollableBounds(CRect* prc, COORDINATE_SYSTEM cs) const
{
    Assert(prc != NULL);
    
    *prc = g_Zero.rc;
    
    // extend size by size of positioned children which contribute to scrollable
    // content area
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        CRect rccChild;
        
        // must recurse for parent nodes in the -Z and +Z layers, because
        // they may contain only relatively-positioned content.  For this
        // reason, it is NOT sufficient to use the child's _rctBounds.
        if (pChild->IsParentNode() &&
            !pChild->IsScroller() &&
            !pChild->IsDrawnExternally() &&
            !pChild->IsFlowNode())
        {
            pChild->AsParent()->GetScrollableBounds(&rccChild, COORDSYS_TRANSFORMED);
            prc->Union(rccChild);
        }
        else if (pChild->AffectsScrollBounds())
        {
            if (pChild->IsStructureNode())
                rccChild = pChild->_rctBounds;
            else
                pChild->GetExpandedBounds(&rccChild, COORDSYS_TRANSFORMED);
            prc->Union(rccChild);
        }
    }
    
    if (prc->IsEmpty())
        return;

    // note: we don't restrict bounds to positive coordinates here - 
    // CDispScroller::RecalcChildren (our only caller) has logic to do that
    // It also handles RTL, which is slightly trickier than just clipping negative
    
    // transform to requested coordinate system
    TransformRect(*prc, COORDSYS_CONTENT, prc, cs);
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::VerifyTreeCorrectness
//
//  Synopsis:   Verify the display node integrity
//
//----------------------------------------------------------------------------

void
CDispParentNode::VerifyTreeCorrectness()
{
    // verify the basic node structure
    super::VerifyTreeCorrectness();

    for (CDispNode* pChild = _pFirstChild, *pLastChild = NULL; pChild; pLastChild = pChild, pChild = pChild->_pNext)
    {
        if (pLastChild)
        {
            AssertSz(pChild->GetLayer() >= pLastChild->GetLayer(),
                "Invalid layer ordering");
            if (!pChild->IsFlowNode() && !pLastChild->IsFlowNode())
            {
                CDispNode* pBefore = pLastChild;
                CDispNode* pAfter = pChild;
                if (pBefore->IsStructureNode())
                    pBefore = pBefore->GetLastChildNode();
                if (pAfter->IsStructureNode())
                    pAfter = pAfter->GetFirstChildNode();
                Assert(pBefore != NULL && pAfter != NULL);
                Assert(!pBefore->IsStructureNode() && !pAfter->IsStructureNode());
/* (dmitryt) there are legal situations when this invariant is not true.
   In particular, when massive attribute change is happening (somebody
   changing a lot of 'className' attributes from script is one example)
   we can have a disptree temporarily not reflecting the zindexes of 
   their clients. As calculations progress, order will be restored.
   See IE6 bug 16186 for details and repro.
   
#ifndef ND_ASSERT  // AlexPf: causes problems in Netdocs which sets z-index in .css files
                   // of relative positioned divs which are dynamically inserted. 20 05 1999
                   // Remove this assert when trident bug #79126 is resolved.
                {
                    int bf = 0; bf = bf + pBefore->GetZOrder();
                    int af = 0; af = af + pAfter->GetZOrder();
                AssertSz(!pBefore->IsGreaterZOrder(pAfter, pAfter->GetZOrder()),
                    "Invalid z ordering");
                }
#endif // ND_ASSERT
*/
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetMemorySize
//              
//  Synopsis:   Return memory size of the display tree rooted at this node.
//              
//  Arguments:  none
//              
//  Returns:    Memory size of this node and its children.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

size_t
CDispParentNode::GetMemorySize() const
{
    size_t size = GetMemorySizeOfThis();
    
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        size += pChild->GetMemorySize();
    
    return size;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::VerifyFlags
//              
//  Synopsis:   Verify that nodes in this subtree have flags set properly.
//              
//  Arguments:  mask        mask to apply to flags
//              value       value to test after mask has been applied
//              fEqual      TRUE if value must be equal, FALSE if not equal
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::VerifyFlags(
        int mask,
        int value,
        BOOL fEqual) const
{
    AssertSz((MaskFlags(mask) == value) == fEqual,
             "Display Tree flags are invalid");
    
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        if (pChild->IsLeafNode())
        {
            AssertSz((pChild->MaskFlags(mask) == value) == fEqual,
                     "Display Tree flags are invalid");
        }
        else
        {
            pChild->AsParent()->VerifyFlags(mask, value, fEqual);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\display\dispscroller.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispscroller.cxx
//
//  Contents:   Simple scrolling container.
//
//  Classes:    CDispScroller
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

MtDefine(CDispScroller, DisplayTree, "CDispScroller")

DeclareTag(tagDispScroll, "Scroll", "trace scrolling");

void
CDispScroller::GetVScrollbarRect(
    CRect* prcbVScrollbar,
    const CRect& rcbBorderWidths) const
{
    if (!IsRTLScroller())
    {
        prcbVScrollbar->right =  _rcpContainer.Width() - rcbBorderWidths.right;
        prcbVScrollbar->left =
            max(rcbBorderWidths.left, prcbVScrollbar->right - _sizeScrollbars.cx);
    }
    else
    {
        prcbVScrollbar->left = rcbBorderWidths.left;
        prcbVScrollbar->right =
            min(_rcpContainer.Width() - rcbBorderWidths.right,
                prcbVScrollbar->left + _sizeScrollbars.cx);
    }
    prcbVScrollbar->top = rcbBorderWidths.top;
    prcbVScrollbar->bottom = _rcpContainer.Height() - rcbBorderWidths.bottom;
    if (_fHasHScrollbar)
        prcbVScrollbar->bottom -= _sizeScrollbars.cy;
}

void
CDispScroller::GetHScrollbarRect(
    CRect* prcbHScrollbar,
    const CRect& rcbBorderWidths) const
{
    prcbHScrollbar->bottom = _rcpContainer.Height() - rcbBorderWidths.bottom;
    prc